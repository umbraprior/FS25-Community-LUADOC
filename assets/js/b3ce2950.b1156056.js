"use strict";(globalThis.webpackChunkfs25_community_luadoc=globalThis.webpackChunkfs25_community_luadoc||[]).push([[82218],{28453(e,n,t){t.d(n,{R:()=>s,x:()=>d});var i=t(96540);const a={},r=i.createContext(a);function s(e){const n=i.useContext(r);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function d(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:s(e.components),i.createElement(r.Provider,{value:n},e.children)}},30624(e,n,t){t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>d,default:()=>p,frontMatter:()=>s,metadata:()=>i,toc:()=>o});const i=JSON.parse('{"id":"script/Specializations/SpeedRotatingParts","title":"SpeedRotatingParts","description":"SpeedRotatingParts","source":"@site/../docs/script/Specializations/SpeedRotatingParts.md","sourceDirName":"script/Specializations","slug":"/script/Specializations/SpeedRotatingParts","permalink":"/FS25-Community-LUADOC/script/Specializations/SpeedRotatingParts","draft":false,"unlisted":false,"tags":[],"version":"current","lastUpdatedAt":1767161192000,"frontMatter":{},"sidebar":"docsSidebar","previous":{"title":"SowingMachine","permalink":"/FS25-Community-LUADOC/script/Specializations/SowingMachine"},"next":{"title":"SplineVehicle","permalink":"/FS25-Community-LUADOC/script/Specializations/SplineVehicle"}}');var a=t(74848),r=t(28453);const s={},d=void 0,l={},o=[{value:"SpeedRotatingParts",id:"speedrotatingparts",level:2},{value:"getIsSpeedRotatingPartActive",id:"getisspeedrotatingpartactive",level:3},{value:"getSpeedRotatingPartDirection",id:"getspeedrotatingpartdirection",level:3},{value:"initSpecialization",id:"initspecialization",level:3},{value:"loadSpeedRotatingPartFromXML",id:"loadspeedrotatingpartfromxml",level:3},{value:"onLoad",id:"onload",level:3},{value:"onReadStream",id:"onreadstream",level:3},{value:"onReadUpdateStream",id:"onreadupdatestream",level:3},{value:"onUpdate",id:"onupdate",level:3},{value:"onUpdateTick",id:"onupdatetick",level:3},{value:"onWriteStream",id:"onwritestream",level:3},{value:"onWriteUpdateStream",id:"onwriteupdatestream",level:3},{value:"prerequisitesPresent",id:"prerequisitespresent",level:3},{value:"registerEventListeners",id:"registereventlisteners",level:3},{value:"registerFunctions",id:"registerfunctions",level:3},{value:"registerOverwrittenFunctions",id:"registeroverwrittenfunctions",level:3},{value:"updateSpeedRotatingPart",id:"updatespeedrotatingpart",level:3},{value:"validateWashableNode",id:"validatewashablenode",level:3}];function c(e){const n={a:"a",blockquote:"blockquote",code:"code",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,r.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.h2,{id:"speedrotatingparts",children:"SpeedRotatingParts"}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Description"})}),"\n",(0,a.jsxs)(n.blockquote,{children:["\n",(0,a.jsx)(n.p,{children:"Specialization for vehicle with (non-wheel) parts rotating or scrolling dependent on its driving speed"}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Functions"})}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.a,{href:"#getisspeedrotatingpartactive",children:"getIsSpeedRotatingPartActive"})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.a,{href:"#getspeedrotatingpartdirection",children:"getSpeedRotatingPartDirection"})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.a,{href:"#initspecialization",children:"initSpecialization"})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.a,{href:"#loadspeedrotatingpartfromxml",children:"loadSpeedRotatingPartFromXML"})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.a,{href:"#onload",children:"onLoad"})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.a,{href:"#onreadstream",children:"onReadStream"})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.a,{href:"#onreadupdatestream",children:"onReadUpdateStream"})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.a,{href:"#onupdate",children:"onUpdate"})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.a,{href:"#onupdatetick",children:"onUpdateTick"})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.a,{href:"#onwritestream",children:"onWriteStream"})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.a,{href:"#onwriteupdatestream",children:"onWriteUpdateStream"})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.a,{href:"#prerequisitespresent",children:"prerequisitesPresent"})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.a,{href:"#registereventlisteners",children:"registerEventListeners"})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.a,{href:"#registerfunctions",children:"registerFunctions"})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.a,{href:"#registeroverwrittenfunctions",children:"registerOverwrittenFunctions"})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.a,{href:"#updatespeedrotatingpart",children:"updateSpeedRotatingPart"})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.a,{href:"#validatewashablenode",children:"validateWashableNode"})}),"\n"]}),"\n",(0,a.jsx)(n.h3,{id:"getisspeedrotatingpartactive",children:"getIsSpeedRotatingPartActive"}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Description"})}),"\n",(0,a.jsxs)(n.blockquote,{children:["\n",(0,a.jsx)(n.p,{children:"Returns true if speed rotating part is active"}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Definition"})}),"\n",(0,a.jsxs)(n.blockquote,{children:["\n",(0,a.jsx)(n.p,{children:"getIsSpeedRotatingPartActive(table speedRotatingPart)"}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n",(0,a.jsx)(n.table,{children:(0,a.jsx)(n.thead,{children:(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.th,{children:"table"}),(0,a.jsx)(n.th,{children:"speedRotatingPart"}),(0,a.jsx)(n.th,{children:"speedRotatingPart"})]})})}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Return Values"})}),"\n\n\n\n\n\n\n\n\n",(0,a.jsx)(n.table,{children:(0,a.jsx)(n.thead,{children:(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.th,{children:"table"}),(0,a.jsx)(n.th,{children:"isActive"}),(0,a.jsx)(n.th,{children:"speed rotating part is active"})]})})}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Code"})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-lua",children:"function SpeedRotatingParts:getIsSpeedRotatingPartActive(speedRotatingPart)\n    if speedRotatingPart.onlyActiveWhenLowered then\n        if self.getIsLowered ~ = nil and not self:getIsLowered() then\n            return false\n        else\n                return true\n            end\n        end\n\n        return true\n    end\n\n"})}),"\n",(0,a.jsx)(n.h3,{id:"getspeedrotatingpartdirection",children:"getSpeedRotatingPartDirection"}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Description"})}),"\n",(0,a.jsxs)(n.blockquote,{children:["\n",(0,a.jsx)(n.p,{children:"Return direction of speed rotating part"}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Definition"})}),"\n",(0,a.jsxs)(n.blockquote,{children:["\n",(0,a.jsx)(n.p,{children:"getSpeedRotatingPartDirection(table speedRotatingPart)"}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n",(0,a.jsx)(n.table,{children:(0,a.jsx)(n.thead,{children:(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.th,{children:"table"}),(0,a.jsx)(n.th,{children:"speedRotatingPart"}),(0,a.jsx)(n.th,{children:"speed rotating part"})]})})}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Return Values"})}),"\n\n\n\n\n\n\n\n\n",(0,a.jsx)(n.table,{children:(0,a.jsx)(n.thead,{children:(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.th,{children:"table"}),(0,a.jsx)(n.th,{children:"direction"}),(0,a.jsx)(n.th,{children:"direction"})]})})}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Code"})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-lua",children:"function SpeedRotatingParts:getSpeedRotatingPartDirection(speedRotatingPart)\n    return 1\nend\n\n"})}),"\n",(0,a.jsx)(n.h3,{id:"initspecialization",children:"initSpecialization"}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Description"})}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Definition"})}),"\n",(0,a.jsxs)(n.blockquote,{children:["\n",(0,a.jsx)(n.p,{children:"initSpecialization()"}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Code"})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-lua",children:'function SpeedRotatingParts.initSpecialization()\n    local schema = Vehicle.xmlSchema\n    schema:setXMLSpecializationType( "SpeedRotatingParts" )\n\n    schema:register(XMLValueType.NODE_INDEX, SpeedRotatingParts.SPEED_ROTATING_PART_XML_KEY .. "#node" , "Speed rotating part node" )\n    schema:register(XMLValueType.NODE_INDICES, SpeedRotatingParts.SPEED_ROTATING_PART_XML_KEY .. "#nodes" , "Speed rotating part nodes(first node will be used as main repr node and the others just copy the rotation values)" )\n    schema:register(XMLValueType.NODE_INDEX, SpeedRotatingParts.SPEED_ROTATING_PART_XML_KEY .. "#shaderNode" , "Speed rotating part shader node" )\n    schema:register(XMLValueType.BOOL, SpeedRotatingParts.SPEED_ROTATING_PART_XML_KEY .. "#useRotation" , "Use shader rotation" , true )\n    schema:register(XMLValueType.VECTOR_ 2 , SpeedRotatingParts.SPEED_ROTATING_PART_XML_KEY .. "#scrollScale" , "Shader scroll speed" )\n    schema:register(XMLValueType.INT, SpeedRotatingParts.SPEED_ROTATING_PART_XML_KEY .. "#shaderComponent" , "Shader parameter component to control" , "Default based on available shader attributes" )\n    schema:register(XMLValueType.VECTOR_N, SpeedRotatingParts.SPEED_ROTATING_PART_XML_KEY .. "#shaderComponentSpeeds" , "Speed factor for different shader components(usable with \'vtxRotate\' shader variation)" )\n        schema:register(XMLValueType.FLOAT, SpeedRotatingParts.SPEED_ROTATING_PART_XML_KEY .. "#scrollLength" , "Shader scroll length" )\n        schema:register(XMLValueType.NODE_INDEX, SpeedRotatingParts.SPEED_ROTATING_PART_XML_KEY .. "#driveNode" , "Drive node to apply x drive" , "speedRotatingPart#node" )\n        schema:register(XMLValueType.INT, SpeedRotatingParts.SPEED_ROTATING_PART_XML_KEY .. "#refComponentIndex" , "Reference component index" )\n        schema:register(XMLValueType.INT, SpeedRotatingParts.SPEED_ROTATING_PART_XML_KEY .. "#wheelIndex" , "Reference wheel index" )\n        schema:register(XMLValueType.NODE_INDICES, SpeedRotatingParts.SPEED_ROTATING_PART_XML_KEY .. "#wheelNodes" , "List of reference wheel nodes(repr or drive node).The average speed of the wheels WITH ground contact is used." )\n        schema:register(XMLValueType.BOOL, SpeedRotatingParts.SPEED_ROTATING_PART_XML_KEY .. "#hasConfigWheels" , "Defined wheels are part of configurations, so no warning is displayed while they are not found." , false )\n\n            schema:register(XMLValueType.NODE_INDEX, SpeedRotatingParts.SPEED_ROTATING_PART_XML_KEY .. "#dirRefNode" , "Direction reference node" )\n            schema:register(XMLValueType.NODE_INDEX, SpeedRotatingParts.SPEED_ROTATING_PART_XML_KEY .. "#dirFrameNode" , "Direction reference frame" )\n\n            schema:register(XMLValueType.BOOL, SpeedRotatingParts.SPEED_ROTATING_PART_XML_KEY .. "#alignDirection" , "Align direction" , false )\n            schema:register(XMLValueType.BOOL, SpeedRotatingParts.SPEED_ROTATING_PART_XML_KEY .. "#applySteeringAngle" , "Apply steering angle" , false )\n            schema:register(XMLValueType.BOOL, SpeedRotatingParts.SPEED_ROTATING_PART_XML_KEY .. "#useWheelReprTranslation" , "Apply wheel repr translation" , true )\n            schema:register(XMLValueType.BOOL, SpeedRotatingParts.SPEED_ROTATING_PART_XML_KEY .. "#updateXDrive" , "Update X drive" , true )\n            schema:register(XMLValueType.BOOL, SpeedRotatingParts.SPEED_ROTATING_PART_XML_KEY .. "#versatileYRot" , "Versatile Y rot" , false )\n\n            schema:register(XMLValueType.ANGLE, SpeedRotatingParts.SPEED_ROTATING_PART_XML_KEY .. "#minYRot" , "Min.Y rotation" )\n            schema:register(XMLValueType.ANGLE, SpeedRotatingParts.SPEED_ROTATING_PART_XML_KEY .. "#maxYRot" , "Max.Y rotation" )\n\n            schema:register(XMLValueType.FLOAT, SpeedRotatingParts.SPEED_ROTATING_PART_XML_KEY .. "#wheelScale" , "Wheel scale" )\n            schema:register(XMLValueType.FLOAT, SpeedRotatingParts.SPEED_ROTATING_PART_XML_KEY .. "#radius" , "Radius" , 1 )\n\n            schema:register(XMLValueType.BOOL, SpeedRotatingParts.SPEED_ROTATING_PART_XML_KEY .. "#onlyActiveWhenLowered" , "Only active if lowered" , false )\n                schema:register(XMLValueType.BOOL, SpeedRotatingParts.SPEED_ROTATING_PART_XML_KEY .. "#stopIfNotActive" , "Stop if not active" , false )\n                    schema:register(XMLValueType.FLOAT, SpeedRotatingParts.SPEED_ROTATING_PART_XML_KEY .. "#fadeOutTime" , "Fade out time" , 3 )\n                    schema:register(XMLValueType.FLOAT, SpeedRotatingParts.SPEED_ROTATING_PART_XML_KEY .. "#activationSpeed" , "Min.speed for activation" , 1 )\n                        schema:register(XMLValueType.NODE_INDEX, SpeedRotatingParts.SPEED_ROTATING_PART_XML_KEY .. "#speedReferenceNode" , "Speed reference node" )\n\n                        schema:register(XMLValueType.BOOL, SpeedRotatingParts.SPEED_ROTATING_PART_XML_KEY .. "#hasTireTracks" , "Has Tire Tracks" , false )\n                        schema:register(XMLValueType.INT, SpeedRotatingParts.SPEED_ROTATING_PART_XML_KEY .. "#tireTrackAtlasIndex" , "Index on tire track atlas" , 0 )\n                        schema:register(XMLValueType.FLOAT, SpeedRotatingParts.SPEED_ROTATING_PART_XML_KEY .. "#tireTrackWidth" , "Width of tire tracks" , 0.5 )\n                        schema:register(XMLValueType.BOOL, SpeedRotatingParts.SPEED_ROTATING_PART_XML_KEY .. "#tireTrackInverted" , "Tire track texture inverted" , false )\n                        schema:register(XMLValueType.NODE_INDEX, SpeedRotatingParts.SPEED_ROTATING_PART_XML_KEY .. "#tireTrackWheelNode" , "Reference wheel for the tire tracks(radius, ground contact, etc)" )\n\n                            schema:register(XMLValueType.FLOAT, SpeedRotatingParts.SPEED_ROTATING_PART_XML_KEY .. "#maxUpdateDistance" , "Max.distance from current camera to vehicle to update part" , SpeedRotatingParts.DEFAULT_MAX_UPDATE_DISTANCE)\n\n                            schema:setXMLSpecializationType()\n                        end\n\n'})}),"\n",(0,a.jsx)(n.h3,{id:"loadspeedrotatingpartfromxml",children:"loadSpeedRotatingPartFromXML"}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Description"})}),"\n",(0,a.jsxs)(n.blockquote,{children:["\n",(0,a.jsx)(n.p,{children:"Loads speed rotating parts from xml"}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Definition"})}),"\n",(0,a.jsxs)(n.blockquote,{children:["\n",(0,a.jsx)(n.p,{children:"loadSpeedRotatingPartFromXML(table speedRotatingPart, XMLFile xmlFile, string key)"}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,a.jsxs)(n.table,{children:[(0,a.jsx)(n.thead,{children:(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.th,{children:"table"}),(0,a.jsx)(n.th,{children:"speedRotatingPart"}),(0,a.jsx)(n.th,{children:"speedRotatingPart"})]})}),(0,a.jsxs)(n.tbody,{children:[(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:"XMLFile"}),(0,a.jsx)(n.td,{children:"xmlFile"}),(0,a.jsx)(n.td,{children:"XMLFile instance"})]}),(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:"string"}),(0,a.jsx)(n.td,{children:"key"}),(0,a.jsx)(n.td,{children:"key"})]})]})]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Return Values"})}),"\n\n\n\n\n\n\n\n\n",(0,a.jsx)(n.table,{children:(0,a.jsx)(n.thead,{children:(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.th,{children:"string"}),(0,a.jsx)(n.th,{children:"success"}),(0,a.jsx)(n.th,{children:"success"})]})})}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Code"})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-lua",children:'function SpeedRotatingParts:loadSpeedRotatingPartFromXML(speedRotatingPart, xmlFile, key)\n    XMLUtil.checkDeprecatedXMLElements(xmlFile, key .. "#vtxPositionArrayFilename" , "Array should be assigned properly inside i3d." ) -- FS22 to FS25\n\n    speedRotatingPart.reprNodes = xmlFile:getValue(key .. "#nodes" , nil , self.components, self.i3dMappings, true )\n\n    speedRotatingPart.repr = xmlFile:getValue(key .. "#node" , speedRotatingPart.reprNodes[ 1 ], self.components, self.i3dMappings)\n    speedRotatingPart.shaderNode = xmlFile:getValue(key .. "#shaderNode" , nil , self.components, self.i3dMappings)\n\n    if #speedRotatingPart.reprNodes > 0 then\n        if speedRotatingPart.reprNodes[ 1 ] = = speedRotatingPart.repr then\n            table.remove(speedRotatingPart.reprNodes, 1 )\n        end\n    end\n\n    speedRotatingPart.shaderParameterName = "offsetUV"\n    speedRotatingPart.shaderParameterPrevName = nil\n    speedRotatingPart.shaderParameterComponent = 3\n    speedRotatingPart.shaderParameterSpeedScale = 1\n    speedRotatingPart.shaderParameterValues = { 0 , 0 , 0 , 0 }\n    if speedRotatingPart.shaderNode ~ = nil then\n        speedRotatingPart.useShaderRotation = xmlFile:getValue(key .. "#useRotation" , true )\n        speedRotatingPart.scrollScale = xmlFile:getValue(key .. "#scrollScale" , "1 0" , true )\n        speedRotatingPart.scrollLength = xmlFile:getValue(key .. "#scrollLength" )\n\n        if getHasShaderParameter(speedRotatingPart.shaderNode, "rotationAngle" ) then\n            speedRotatingPart.shaderParameterName = "rotationAngle"\n            speedRotatingPart.shaderParameterPrevName = "prevRotationAngle"\n            speedRotatingPart.shaderParameterComponent = 1\n            speedRotatingPart.shaderParameterSpeedScale = - 1\n        end\n\n        if getHasShaderParameter(speedRotatingPart.shaderNode, "scrollPos" ) then\n            speedRotatingPart.shaderParameterName = "scrollPos"\n            speedRotatingPart.shaderParameterPrevName = "prevScrollPos"\n            speedRotatingPart.shaderParameterComponent = 1\n            speedRotatingPart.shaderParameterSpeedScale = 1\n        end\n\n        speedRotatingPart.shaderParameterComponent = xmlFile:getValue(key .. "#shaderComponent" , speedRotatingPart.shaderParameterComponent)\n\n        speedRotatingPart.shaderComponentSpeeds = xmlFile:getValue(key .. "#shaderComponentSpeeds" , nil , true )\n    end\n\n    if speedRotatingPart.repr = = nil and speedRotatingPart.shaderNode = = nil then\n        Logging.xmlWarning( self.xmlFile, "Invalid speedRotationPart node \'%s\' in \'%s\'" , tostring(getXMLString(xmlFile.handle, key .. "#node" ) or getXMLString(xmlFile.handle, key .. "#shaderNode" )), key)\n        return false\n    end\n    speedRotatingPart.driveNode = xmlFile:getValue(key .. "#driveNode" , speedRotatingPart.repr, self.components, self.i3dMappings)\n\n    local componentIndex = xmlFile:getValue(key .. "#refComponentIndex" )\n    if componentIndex ~ = nil and self.components[componentIndex] ~ = nil then\n        speedRotatingPart.componentNode = self.components[componentIndex].node\n    else\n            local node = Utils.getNoNil(speedRotatingPart.driveNode, speedRotatingPart.shaderNode)\n            speedRotatingPart.componentNode = self:getParentComponent(node)\n        end\n\n        speedRotatingPart.xDrive = 0\n        local wheelIndex = xmlFile:getValue(key .. "#wheelIndex" )\n        local wheelNodes = xmlFile:getValue(key .. "#wheelNodes" , nil , self.components, self.i3dMappings, true )\n        if wheelIndex ~ = nil or #wheelNodes > 0 then\n            if self.getWheels = = nil then\n                Logging.xmlWarning( self.xmlFile, "wheelIndex for speedRotatingPart \'%s\' given, but no wheels loaded/defined" , key)\n                else\n                        local wheels = { }\n                        if wheelIndex ~ = nil then\n                            local wheel = self:getWheelFromWheelIndex(wheelIndex)\n                            if wheel ~ = nil then\n                                table.insert(wheels, wheel)\n                            else\n                                    if not xmlFile:getValue(key .. "#hasConfigWheels" , false ) then\n                                        Logging.xmlWarning( self.xmlFile, "Invalid wheel index \'%s\' for speedRotatingPart \'%s\'" , wheelIndex, key)\n                                        end\n                                    end\n                                end\n\n                                if #wheelNodes > 0 then\n                                    for _, wheelNode in ipairs(wheelNodes) do\n                                        local wheel = self:getWheelByWheelNode(wheelNode)\n                                        if wheel ~ = nil then\n                                            table.insert(wheels, wheel)\n                                        else\n                                                if not xmlFile:getValue(key .. "#hasConfigWheels" , false ) then\n                                                    Logging.xmlWarning( self.xmlFile, "Invalid wheel node \'%s\' for speedRotatingPart \'%s\'" , getName(wheelNode), key)\n                                                    end\n                                                end\n                                            end\n                                        end\n\n                                        if #wheels = = 0 then\n                                            return false\n                                        end\n\n                                        for _, wheel in ipairs(wheels) do\n                                            wheel.syncContactState = true\n\n                                            if not wheel.physics.isSynchronized then\n                                                Logging.xmlWarning( self.xmlFile, "Referenced wheel \'%s\' for speedRotatingPart \'%s\' is not synchronized in multiplayer" , getName(wheel.repr), key)\n                                                end\n                                            end\n\n                                            speedRotatingPart.wheels = wheels\n                                            speedRotatingPart.lastWheelXRot = { }\n                                        end\n                                    end\n\n                                    speedRotatingPart.hasTireTracks = xmlFile:getValue(key .. "#hasTireTracks" , false )\n                                    speedRotatingPart.tireTrackAtlasIndex = xmlFile:getValue(key .. "#tireTrackAtlasIndex" , 0 )\n                                    speedRotatingPart.tireTrackWidth = xmlFile:getValue(key .. "#tireTrackWidth" , 0.5 )\n                                    speedRotatingPart.tireTrackInverted = xmlFile:getValue(key .. "#tireTrackInverted" , false )\n                                    speedRotatingPart.tireTrackWheelNode = xmlFile:getValue(key .. "#tireTrackWheelNode" , nil , self.components, self.i3dMappings)\n                                    if speedRotatingPart.hasTireTracks and Platform.gameplay.wheelTireTracks then\n                                        local activeFunc = function ()\n                                            return self:getIsSpeedRotatingPartActive(speedRotatingPart)\n                                        end\n\n                                        local wheel\n                                        if speedRotatingPart.wheels ~ = nil then\n                                            wheel = speedRotatingPart.wheels[ 1 ]\n                                        elseif speedRotatingPart.tireTrackWheelNode ~ = nil then\n                                                wheel = self:getWheelByWheelNode(speedRotatingPart.tireTrackWheelNode)\n                                            else\n                                                    Logging.xmlWarning( self.xmlFile, "Tire tracks for speedRotationPart \'%s\' defined, but no wheels or tireTrackWheelNode given" , key)\n                                                        return false\n                                                    end\n\n                                                    speedRotatingPart.tireTrackNodeIndex = self:addTireTrackNode(wheel, speedRotatingPart.componentNode, speedRotatingPart.driveNode, speedRotatingPart.tireTrackAtlasIndex, speedRotatingPart.tireTrackWidth, wheel.physics.radius, speedRotatingPart.tireTrackInverted, activeFunc)\n                                                end\n\n                                                speedRotatingPart.dirRefNode = xmlFile:getValue(key .. "#dirRefNode" , nil , self.components, self.i3dMappings)\n                                                speedRotatingPart.dirFrameNode = xmlFile:getValue(key .. "#dirFrameNode" , nil , self.components, self.i3dMappings)\n                                                speedRotatingPart.alignDirection = xmlFile:getValue(key .. "#alignDirection" , false )\n                                                speedRotatingPart.applySteeringAngle = xmlFile:getValue(key .. "#applySteeringAngle" , false )\n                                                speedRotatingPart.useWheelReprTranslation = xmlFile:getValue(key .. "#useWheelReprTranslation" , true )\n                                                speedRotatingPart.updateXDrive = xmlFile:getValue(key .. "#updateXDrive" , true )\n\n                                                speedRotatingPart.versatileYRot = xmlFile:getValue(key .. "#versatileYRot" , false )\n                                                if speedRotatingPart.versatileYRot and speedRotatingPart.repr = = nil then\n                                                    Logging.xmlWarning( self.xmlFile, "Versatile speedRotationPart \'%s\' does not support shaderNodes" , key)\n                                                    return false\n                                                end\n\n                                                speedRotatingPart.minYRot = xmlFile:getValue(key .. "#minYRot" )\n                                                speedRotatingPart.maxYRot = xmlFile:getValue(key .. "#maxYRot" )\n                                                speedRotatingPart.steeringAngle = 0\n                                                speedRotatingPart.steeringAngleSent = 0\n\n                                                speedRotatingPart.speedReferenceNode = xmlFile:getValue(key .. "#speedReferenceNode" , nil , self.components, self.i3dMappings)\n                                                if speedRotatingPart.speedReferenceNode ~ = nil and speedRotatingPart.speedReferenceNode = = speedRotatingPart.driveNode then\n                                                    Logging.xmlWarning( self.xmlFile, "Ignoring speedRotationPart \'%s\' because speedReferenceNode is identical with driveNode.Need to be different!" , key)\n                                                    return false\n                                                end\n\n                                                speedRotatingPart.wheelScale = xmlFile:getValue(key .. "#wheelScale" )\n                                                if speedRotatingPart.wheelScale = = nil then\n                                                    local baseRadius = 1.0\n                                                    local radius = 1.0\n                                                    if speedRotatingPart.wheels ~ = nil and speedRotatingPart.speedReferenceNode = = nil then\n                                                        baseRadius = speedRotatingPart.wheels[ 1 ].physics.radius\n                                                        radius = speedRotatingPart.wheels[ 1 ].physics.radius\n                                                    end\n                                                    speedRotatingPart.wheelScale = baseRadius / xmlFile:getValue(key .. "#radius" , radius)\n                                                end\n\n                                                speedRotatingPart.wheelScaleBackup = speedRotatingPart.wheelScale\n\n                                                speedRotatingPart.onlyActiveWhenLowered = xmlFile:getValue(key .. "#onlyActiveWhenLowered" , false )\n                                                speedRotatingPart.stopIfNotActive = xmlFile:getValue(key .. "#stopIfNotActive" , false )\n                                                speedRotatingPart.fadeOutTime = xmlFile:getValue(key .. "#fadeOutTime" , 3 ) * 1000\n                                                speedRotatingPart.activationSpeed = xmlFile:getValue(key .. "#activationSpeed" , 1 )\n\n                                                speedRotatingPart.lastSpeed = 0\n                                                speedRotatingPart.lastDir = 1\n\n                                                speedRotatingPart.maxUpdateDistance = xmlFile:getValue(key .. "#maxUpdateDistance" , SpeedRotatingParts.DEFAULT_MAX_UPDATE_DISTANCE)\n\n                                                -- always update to sync the correct angle to the clients\n                                                if self.isServer and speedRotatingPart.versatileYRot then\n                                                    speedRotatingPart.maxUpdateDistance = math.huge\n                                                end\n\n                                                return true\n                                            end\n\n'})}),"\n",(0,a.jsx)(n.h3,{id:"onload",children:"onLoad"}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Description"})}),"\n",(0,a.jsxs)(n.blockquote,{children:["\n",(0,a.jsx)(n.p,{children:"Called on loading"}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Definition"})}),"\n",(0,a.jsxs)(n.blockquote,{children:["\n",(0,a.jsx)(n.p,{children:"onLoad(table savegame)"}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n",(0,a.jsx)(n.table,{children:(0,a.jsx)(n.thead,{children:(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.th,{children:"table"}),(0,a.jsx)(n.th,{children:"savegame"}),(0,a.jsx)(n.th,{children:"savegame"})]})})}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Code"})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-lua",children:'function SpeedRotatingParts:onLoad(savegame)\n    local spec = self.spec_speedRotatingParts\n\n    XMLUtil.checkDeprecatedXMLElements( self.xmlFile, "vehicle.speedRotatingParts.speedRotatingPart(0)#index" , "vehicle.speedRotatingParts.speedRotatingPart(0)#node" ) -- FS17\n\n    local maxUpdateDistance\n    spec.individualUpdateDistance = false\n    spec.speedRotatingParts = { }\n\n    for _, baseName in self.xmlFile:iterator( "vehicle.speedRotatingParts.speedRotatingPart" ) do\n        local speedRotatingPart = { }\n        if self:loadSpeedRotatingPartFromXML(speedRotatingPart, self.xmlFile, baseName) then\n            table.insert(spec.speedRotatingParts, speedRotatingPart)\n\n            if maxUpdateDistance ~ = nil and maxUpdateDistance ~ = speedRotatingPart.maxUpdateDistance then\n                spec.individualUpdateDistance = true\n            end\n            maxUpdateDistance = speedRotatingPart.maxUpdateDistance\n        else\n                if speedRotatingPart.tireTrackNodeIndex ~ = nil then\n                    self:removeTireTrackNode(speedRotatingPart.tireTrackNodeIndex)\n                end\n            end\n        end\n\n        spec.maxUpdateDistance = maxUpdateDistance or SpeedRotatingParts.DEFAULT_MAX_UPDATE_DISTANCE\n\n        spec.dirtyFlag = self:getNextDirtyFlag()\n\n        if #spec.speedRotatingParts = = 0 then\n            SpecializationUtil.removeEventListener( self , "onReadStream" , SpeedRotatingParts )\n            SpecializationUtil.removeEventListener( self , "onWriteStream" , SpeedRotatingParts )\n            SpecializationUtil.removeEventListener( self , "onReadUpdateStream" , SpeedRotatingParts )\n            SpecializationUtil.removeEventListener( self , "onWriteUpdateStream" , SpeedRotatingParts )\n            SpecializationUtil.removeEventListener( self , "onUpdate" , SpeedRotatingParts )\n            SpecializationUtil.removeEventListener( self , "onUpdateTick" , SpeedRotatingParts )\n        end\n    end\n\n'})}),"\n",(0,a.jsx)(n.h3,{id:"onreadstream",children:"onReadStream"}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Description"})}),"\n",(0,a.jsxs)(n.blockquote,{children:["\n",(0,a.jsx)(n.p,{children:"Called on client side on join"}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Definition"})}),"\n",(0,a.jsxs)(n.blockquote,{children:["\n",(0,a.jsx)(n.p,{children:"onReadStream(integer streamId, Connection connection)"}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,a.jsxs)(n.table,{children:[(0,a.jsx)(n.thead,{children:(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.th,{children:"integer"}),(0,a.jsx)(n.th,{children:"streamId"}),(0,a.jsx)(n.th,{children:"streamId"})]})}),(0,a.jsx)(n.tbody,{children:(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:"Connection"}),(0,a.jsx)(n.td,{children:"connection"}),(0,a.jsx)(n.td,{children:"connection"})]})})]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Code"})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-lua",children:"function SpeedRotatingParts:onReadStream(streamId, connection)\n    local spec = self.spec_speedRotatingParts\n    for i = 1 , #spec.speedRotatingParts do\n        local speedRotatingPart = spec.speedRotatingParts[i]\n        if speedRotatingPart.versatileYRot then\n            local yRot = streamReadUIntN(streamId, 9 )\n            speedRotatingPart.steeringAngle = yRot / 511 * math.pi * 2\n        end\n    end\nend\n\n"})}),"\n",(0,a.jsx)(n.h3,{id:"onreadupdatestream",children:"onReadUpdateStream"}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Description"})}),"\n",(0,a.jsxs)(n.blockquote,{children:["\n",(0,a.jsx)(n.p,{children:"Called on on update"}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Definition"})}),"\n",(0,a.jsxs)(n.blockquote,{children:["\n",(0,a.jsx)(n.p,{children:"onReadUpdateStream(integer streamId, integer timestamp, table connection)"}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,a.jsxs)(n.table,{children:[(0,a.jsx)(n.thead,{children:(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.th,{children:"integer"}),(0,a.jsx)(n.th,{children:"streamId"}),(0,a.jsx)(n.th,{children:"stream ID"})]})}),(0,a.jsxs)(n.tbody,{children:[(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:"integer"}),(0,a.jsx)(n.td,{children:"timestamp"}),(0,a.jsx)(n.td,{children:"timestamp"})]}),(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:"table"}),(0,a.jsx)(n.td,{children:"connection"}),(0,a.jsx)(n.td,{children:"connection"})]})]})]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Code"})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-lua",children:"function SpeedRotatingParts:onReadUpdateStream(streamId, timestamp, connection)\n    if connection.isServer then\n        local hasUpdate = streamReadBool(streamId)\n        if hasUpdate then\n            local spec = self.spec_speedRotatingParts\n            for i = 1 , #spec.speedRotatingParts do\n                local speedRotatingPart = spec.speedRotatingParts[i]\n                if speedRotatingPart.versatileYRot then\n                    local yRot = streamReadUIntN(streamId, 9 )\n                    speedRotatingPart.steeringAngle = yRot / 511 * math.pi * 2\n                end\n            end\n        end\n    end\nend\n\n"})}),"\n",(0,a.jsx)(n.h3,{id:"onupdate",children:"onUpdate"}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Description"})}),"\n",(0,a.jsxs)(n.blockquote,{children:["\n",(0,a.jsx)(n.p,{children:"Called on update"}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Definition"})}),"\n",(0,a.jsxs)(n.blockquote,{children:["\n",(0,a.jsx)(n.p,{children:"onUpdate(float dt, boolean isActiveForInput, boolean isSelected, )"}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,a.jsxs)(n.table,{children:[(0,a.jsx)(n.thead,{children:(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.th,{children:"float"}),(0,a.jsx)(n.th,{children:"dt"}),(0,a.jsx)(n.th,{children:"time since last call in ms"})]})}),(0,a.jsxs)(n.tbody,{children:[(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:"boolean"}),(0,a.jsx)(n.td,{children:"isActiveForInput"}),(0,a.jsx)(n.td,{children:"true if vehicle is active for input"})]}),(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:"boolean"}),(0,a.jsx)(n.td,{children:"isSelected"}),(0,a.jsx)(n.td,{children:"true if vehicle is selected"})]}),(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:"any"}),(0,a.jsx)(n.td,{children:"isSelected"}),(0,a.jsx)(n.td,{})]})]})]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Code"})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-lua",children:"function SpeedRotatingParts:onUpdate(dt, isActiveForInput, isActiveForInputIgnoreSelection, isSelected)\n    local spec = self.spec_speedRotatingParts\n\n    if spec.individualUpdateDistance or self.currentUpdateDistance < spec.maxUpdateDistance then\n        for i = 1 , #spec.speedRotatingParts do\n            local speedRotatingPart = spec.speedRotatingParts[i]\n            if not spec.individualUpdateDistance or self.currentUpdateDistance < speedRotatingPart.maxUpdateDistance then\n                if speedRotatingPart.isActive or(speedRotatingPart.lastSpeed ~ = 0 and not speedRotatingPart.stopIfNotActive) then\n                    self:updateSpeedRotatingPart(speedRotatingPart, dt, speedRotatingPart.isActive)\n                end\n            end\n        end\n    end\nend\n\n"})}),"\n",(0,a.jsx)(n.h3,{id:"onupdatetick",children:"onUpdateTick"}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Description"})}),"\n",(0,a.jsxs)(n.blockquote,{children:["\n",(0,a.jsx)(n.p,{children:"Called on update tick"}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Definition"})}),"\n",(0,a.jsxs)(n.blockquote,{children:["\n",(0,a.jsx)(n.p,{children:"onUpdateTick(float dt, boolean isActiveForInput, boolean isSelected, )"}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,a.jsxs)(n.table,{children:[(0,a.jsx)(n.thead,{children:(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.th,{children:"float"}),(0,a.jsx)(n.th,{children:"dt"}),(0,a.jsx)(n.th,{children:"time since last call in ms"})]})}),(0,a.jsxs)(n.tbody,{children:[(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:"boolean"}),(0,a.jsx)(n.td,{children:"isActiveForInput"}),(0,a.jsx)(n.td,{children:"true if vehicle is active for input"})]}),(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:"boolean"}),(0,a.jsx)(n.td,{children:"isSelected"}),(0,a.jsx)(n.td,{children:"true if vehicle is selected"})]}),(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:"any"}),(0,a.jsx)(n.td,{children:"isSelected"}),(0,a.jsx)(n.td,{})]})]})]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Code"})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-lua",children:"function SpeedRotatingParts:onUpdateTick(dt, isActiveForInput, isActiveForInputIgnoreSelection, isSelected)\n    local spec = self.spec_speedRotatingParts\n\n    if spec.individualUpdateDistance or self.currentUpdateDistance < spec.maxUpdateDistance then\n        for i = 1 , #spec.speedRotatingParts do\n            local speedRotatingPart = spec.speedRotatingParts[i]\n            if not spec.individualUpdateDistance or self.currentUpdateDistance < speedRotatingPart.maxUpdateDistance then\n                speedRotatingPart.isActive = self:getIsSpeedRotatingPartActive(speedRotatingPart)\n            end\n        end\n    end\nend\n\n"})}),"\n",(0,a.jsx)(n.h3,{id:"onwritestream",children:"onWriteStream"}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Description"})}),"\n",(0,a.jsxs)(n.blockquote,{children:["\n",(0,a.jsx)(n.p,{children:"Called on server side on join"}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Definition"})}),"\n",(0,a.jsxs)(n.blockquote,{children:["\n",(0,a.jsx)(n.p,{children:"onWriteStream(integer streamId, Connection connection)"}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,a.jsxs)(n.table,{children:[(0,a.jsx)(n.thead,{children:(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.th,{children:"integer"}),(0,a.jsx)(n.th,{children:"streamId"}),(0,a.jsx)(n.th,{children:"streamId"})]})}),(0,a.jsx)(n.tbody,{children:(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:"Connection"}),(0,a.jsx)(n.td,{children:"connection"}),(0,a.jsx)(n.td,{children:"connection"})]})})]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Code"})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-lua",children:"function SpeedRotatingParts:onWriteStream(streamId, connection)\n    local spec = self.spec_speedRotatingParts\n    for i = 1 , #spec.speedRotatingParts do\n        local speedRotatingPart = spec.speedRotatingParts[i]\n        if speedRotatingPart.versatileYRot then\n            local yRot = speedRotatingPart.steeringAngle % ( math.pi * 2 )\n            streamWriteUIntN(streamId, math.clamp( math.floor(yRot / ( math.pi * 2 ) * 511 ), 0 , 511 ), 9 )\n        end\n    end\nend\n\n"})}),"\n",(0,a.jsx)(n.h3,{id:"onwriteupdatestream",children:"onWriteUpdateStream"}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Description"})}),"\n",(0,a.jsxs)(n.blockquote,{children:["\n",(0,a.jsx)(n.p,{children:"Called on on update"}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Definition"})}),"\n",(0,a.jsxs)(n.blockquote,{children:["\n",(0,a.jsx)(n.p,{children:"onWriteUpdateStream(integer streamId, table connection, integer dirtyMask)"}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,a.jsxs)(n.table,{children:[(0,a.jsx)(n.thead,{children:(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.th,{children:"integer"}),(0,a.jsx)(n.th,{children:"streamId"}),(0,a.jsx)(n.th,{children:"stream ID"})]})}),(0,a.jsxs)(n.tbody,{children:[(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:"table"}),(0,a.jsx)(n.td,{children:"connection"}),(0,a.jsx)(n.td,{children:"connection"})]}),(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:"integer"}),(0,a.jsx)(n.td,{children:"dirtyMask"}),(0,a.jsx)(n.td,{children:"dirty mask"})]})]})]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Code"})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-lua",children:"function SpeedRotatingParts:onWriteUpdateStream(streamId, connection, dirtyMask)\n    if not connection.isServer then\n        local spec = self.spec_speedRotatingParts\n        if streamWriteBool(streamId, bit32.band(dirtyMask, spec.dirtyFlag) ~ = 0 ) then\n            for i = 1 , #spec.speedRotatingParts do\n                local speedRotatingPart = spec.speedRotatingParts[i]\n                if speedRotatingPart.versatileYRot then\n                    local yRot = speedRotatingPart.steeringAngle % ( math.pi * 2 )\n                    streamWriteUIntN(streamId, math.clamp( math.floor(yRot / ( math.pi * 2 ) * 511 ), 0 , 511 ), 9 )\n                end\n            end\n        end\n    end\nend\n\n"})}),"\n",(0,a.jsx)(n.h3,{id:"prerequisitespresent",children:"prerequisitesPresent"}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Description"})}),"\n",(0,a.jsxs)(n.blockquote,{children:["\n",(0,a.jsx)(n.p,{children:"Checks if all prerequisite specializations are loaded"}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Definition"})}),"\n",(0,a.jsxs)(n.blockquote,{children:["\n",(0,a.jsx)(n.p,{children:"prerequisitesPresent(table specializations)"}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n",(0,a.jsx)(n.table,{children:(0,a.jsx)(n.thead,{children:(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.th,{children:"table"}),(0,a.jsx)(n.th,{children:"specializations"}),(0,a.jsx)(n.th,{children:"specializations"})]})})}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Return Values"})}),"\n\n\n\n\n\n\n\n\n",(0,a.jsx)(n.table,{children:(0,a.jsx)(n.thead,{children:(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.th,{children:"table"}),(0,a.jsx)(n.th,{children:"hasPrerequisite"}),(0,a.jsx)(n.th,{children:"true if all prerequisite specializations are loaded"})]})})}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Code"})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-lua",children:"function SpeedRotatingParts.prerequisitesPresent(specializations)\n    return true\nend\n\n"})}),"\n",(0,a.jsx)(n.h3,{id:"registereventlisteners",children:"registerEventListeners"}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Description"})}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Definition"})}),"\n",(0,a.jsxs)(n.blockquote,{children:["\n",(0,a.jsx)(n.p,{children:"registerEventListeners()"}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,a.jsx)(n.table,{children:(0,a.jsx)(n.thead,{children:(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.th,{children:"any"}),(0,a.jsx)(n.th,{children:"vehicleType"})]})})}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Code"})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-lua",children:'function SpeedRotatingParts.registerEventListeners(vehicleType)\n    SpecializationUtil.registerEventListener(vehicleType, "onLoad" , SpeedRotatingParts )\n    SpecializationUtil.registerEventListener(vehicleType, "onReadStream" , SpeedRotatingParts )\n    SpecializationUtil.registerEventListener(vehicleType, "onWriteStream" , SpeedRotatingParts )\n    SpecializationUtil.registerEventListener(vehicleType, "onReadUpdateStream" , SpeedRotatingParts )\n    SpecializationUtil.registerEventListener(vehicleType, "onWriteUpdateStream" , SpeedRotatingParts )\n    SpecializationUtil.registerEventListener(vehicleType, "onUpdate" , SpeedRotatingParts )\n    SpecializationUtil.registerEventListener(vehicleType, "onUpdateTick" , SpeedRotatingParts )\nend\n\n'})}),"\n",(0,a.jsx)(n.h3,{id:"registerfunctions",children:"registerFunctions"}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Description"})}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Definition"})}),"\n",(0,a.jsxs)(n.blockquote,{children:["\n",(0,a.jsx)(n.p,{children:"registerFunctions()"}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,a.jsx)(n.table,{children:(0,a.jsx)(n.thead,{children:(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.th,{children:"any"}),(0,a.jsx)(n.th,{children:"vehicleType"})]})})}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Code"})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-lua",children:'function SpeedRotatingParts.registerFunctions(vehicleType)\n    SpecializationUtil.registerFunction(vehicleType, "loadSpeedRotatingPartFromXML" , SpeedRotatingParts.loadSpeedRotatingPartFromXML)\n    SpecializationUtil.registerFunction(vehicleType, "getIsSpeedRotatingPartActive" , SpeedRotatingParts.getIsSpeedRotatingPartActive)\n    SpecializationUtil.registerFunction(vehicleType, "getSpeedRotatingPartDirection" , SpeedRotatingParts.getSpeedRotatingPartDirection)\n    SpecializationUtil.registerFunction(vehicleType, "updateSpeedRotatingPart" , SpeedRotatingParts.updateSpeedRotatingPart)\nend\n\n'})}),"\n",(0,a.jsx)(n.h3,{id:"registeroverwrittenfunctions",children:"registerOverwrittenFunctions"}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Description"})}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Definition"})}),"\n",(0,a.jsxs)(n.blockquote,{children:["\n",(0,a.jsx)(n.p,{children:"registerOverwrittenFunctions()"}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,a.jsx)(n.table,{children:(0,a.jsx)(n.thead,{children:(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.th,{children:"any"}),(0,a.jsx)(n.th,{children:"vehicleType"})]})})}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Code"})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-lua",children:'function SpeedRotatingParts.registerOverwrittenFunctions(vehicleType)\n    SpecializationUtil.registerOverwrittenFunction(vehicleType, "validateWashableNode" , SpeedRotatingParts.validateWashableNode)\nend\n\n'})}),"\n",(0,a.jsx)(n.h3,{id:"updatespeedrotatingpart",children:"updateSpeedRotatingPart"}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Description"})}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Definition"})}),"\n",(0,a.jsxs)(n.blockquote,{children:["\n",(0,a.jsx)(n.p,{children:"updateSpeedRotatingPart()"}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,a.jsxs)(n.table,{children:[(0,a.jsx)(n.thead,{children:(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.th,{children:"any"}),(0,a.jsx)(n.th,{children:"speedRotatingPart"})]})}),(0,a.jsxs)(n.tbody,{children:[(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:"any"}),(0,a.jsx)(n.td,{children:"dt"})]}),(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:"any"}),(0,a.jsx)(n.td,{children:"isPartActive"})]})]})]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Code"})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-lua",children:'function SpeedRotatingParts:updateSpeedRotatingPart(speedRotatingPart, dt, isPartActive)\n    local spec = self.spec_speedRotatingParts\n    local speed = speedRotatingPart.lastSpeed\n    local dir = speedRotatingPart.lastDir\n\n    -- use angle from the repr node since the repr node could be rotated by another spec\n    if speedRotatingPart.repr ~ = nil then\n        if self.isServer or not speedRotatingPart.versatileYRot then\n            local _\n            _, speedRotatingPart.steeringAngle, _ = getRotation(speedRotatingPart.repr)\n        end\n    end\n\n    if isPartActive then\n        if speedRotatingPart.speedReferenceNode ~ = nil then\n            local newX, newY, newZ = getWorldTranslation(speedRotatingPart.speedReferenceNode)\n            if speedRotatingPart.lastPosition = = nil then\n                speedRotatingPart.lastPosition = { newX, newY, newZ }\n            end\n\n            local dx, dy, dz = worldDirectionToLocal(speedRotatingPart.speedReferenceNode, newX - speedRotatingPart.lastPosition[ 1 ], newY - speedRotatingPart.lastPosition[ 2 ], newZ - speedRotatingPart.lastPosition[ 3 ])\n            speed = MathUtil.vector3Length(dx, dy, dz)\n\n            if dz > 0.001 then\n                dir = 1\n            elseif dz < - 0.001 then\n                    dir = - 1\n                else\n                        dir = 0\n                    end\n\n                    speedRotatingPart.lastPosition[ 1 ], speedRotatingPart.lastPosition[ 2 ], speedRotatingPart.lastPosition[ 3 ] = newX, newY, newZ\n                elseif speedRotatingPart.wheels ~ = nil then\n                        local speedSum, numWheels = 0 , 0\n                        dir = 0\n                        for i, wheel in ipairs(speedRotatingPart.wheels) do\n                            if speedRotatingPart.lastWheelXRot[i] = = nil then\n                                speedRotatingPart.lastWheelXRot[i] = wheel.physics.netInfo.xDrive\n                            end\n\n                            if wheel.physics.contact ~ = WheelContactType.NONE or #speedRotatingPart.wheels = = 1 then\n                                local rotDiff = wheel.physics.netInfo.xDrive - speedRotatingPart.lastWheelXRot[i]\n                                if rotDiff > math.pi then\n                                    rotDiff = rotDiff - ( 2 * math.pi)\n                                elseif rotDiff < - math.pi then\n                                        rotDiff = rotDiff + ( 2 * math.pi)\n                                    end\n\n                                    speedSum = speedSum + math.abs(rotDiff)\n                                    if math.sign(rotDiff) ~ = 0 then\n                                        dir = math.sign(rotDiff)\n                                    end\n\n                                    numWheels = numWheels + 1\n                                end\n\n                                speedRotatingPart.lastWheelXRot[i] = wheel.physics.netInfo.xDrive\n                            end\n\n                            if numWheels > 0 then\n                                speed = speedSum / numWheels\n                            else\n                                    speed = 0\n                                end\n\n                                if not speedRotatingPart.versatileYRot then\n                                    local _\n                                    _, speedRotatingPart.steeringAngle, _ = getRotation(speedRotatingPart.wheels[ 1 ].repr)\n                                end\n                            else\n                                    speed = self.lastSpeedReal * dt\n                                    dir = self.movingDirection\n                                end\n                                speedRotatingPart.brakeForce = speed * dt / speedRotatingPart.fadeOutTime\n                            else\n                                    speed = math.max(speed - speedRotatingPart.brakeForce, 0 )\n\n                                    if speedRotatingPart.wheels ~ = nil then\n                                        for wheelIndex, _ in pairs(speedRotatingPart.lastWheelXRot) do\n                                            speedRotatingPart.lastWheelXRot[wheelIndex] = nil\n                                        end\n                                    end\n                                end\n\n                                speedRotatingPart.lastSpeed = speed\n                                speedRotatingPart.lastDir = dir\n                                if speedRotatingPart.updateXDrive then\n                                    speedRotatingPart.xDrive = (speedRotatingPart.xDrive + speed * dir * self:getSpeedRotatingPartDirection(speedRotatingPart) * speedRotatingPart.wheelScale) % ( 2 * math.pi)\n                                end\n\n                                if speedRotatingPart.versatileYRot then\n                                    if speed > 0.0017 then -- 0.1deg threshold cause float accuracy\n                                        if self.isServer and self:getLastSpeed( true ) > speedRotatingPart.activationSpeed then\n                                            local posX, posY, posZ = localToLocal(speedRotatingPart.repr, speedRotatingPart.componentNode, 0 , 0 , 0 )\n                                            speedRotatingPart.steeringAngle = Utils.getVersatileRotation(speedRotatingPart.repr, speedRotatingPart.componentNode, dt, posX, posY, posZ, speedRotatingPart.steeringAngle, speedRotatingPart.minYRot, speedRotatingPart.maxYRot)\n\n                                            local steeringAngleSent = math.floor((speedRotatingPart.steeringAngle % ( math.pi * 2 )) / ( math.pi * 2 ) * 511 )\n                                            if steeringAngleSent ~ = speedRotatingPart.steeringAngleSent then\n                                                speedRotatingPart.steeringAngleSent = steeringAngleSent\n                                                self:raiseDirtyFlags(spec.dirtyFlag)\n                                            end\n                                        end\n                                    end\n                                else\n                                        if speedRotatingPart.componentNode ~ = nil and speedRotatingPart.dirRefNode ~ = nil and not speedRotatingPart.alignDirection then\n                                            speedRotatingPart.steeringAngle = Utils.getYRotationBetweenNodes(speedRotatingPart.componentNode, speedRotatingPart.dirRefNode)\n                                            local _,yTrans,_ = localToLocal(speedRotatingPart.driveNode, speedRotatingPart.wheels[ 1 ].driveNode, 0 , 0 , 0 )\n                                            setTranslation(speedRotatingPart.driveNode, 0 , yTrans, 0 )\n                                        end\n\n                                        if speedRotatingPart.dirRefNode ~ = nil and speedRotatingPart.alignDirection then\n                                            local upX, upY, upZ = localDirectionToWorld(speedRotatingPart.dirFrameNode, 0 , 1 , 0 )\n                                            local dirX, dirY, dirZ = localDirectionToWorld(speedRotatingPart.dirRefNode, 0 , 0 , 1 )\n                                            I3DUtil.setWorldDirection(speedRotatingPart.repr, dirX, dirY, dirZ, upX, upY, upZ, 2 )\n                                            if speedRotatingPart.wheels ~ = nil and speedRotatingPart.useWheelReprTranslation then\n                                                local _,yTrans,_ = localToLocal(speedRotatingPart.wheels[ 1 ].driveNode, getParent(speedRotatingPart.repr), 0 , 0 , 0 )\n                                                setTranslation(speedRotatingPart.repr, 0 , yTrans, 0 )\n                                            end\n                                        end\n                                    end\n\n                                    if speedRotatingPart.driveNode ~ = nil then\n                                        if speedRotatingPart.repr = = speedRotatingPart.driveNode then\n                                            local steeringAngle = speedRotatingPart.steeringAngle\n                                            if not speedRotatingPart.applySteeringAngle then\n                                                steeringAngle = 0\n                                            end\n\n                                            setRotation(speedRotatingPart.repr, speedRotatingPart.xDrive, steeringAngle, 0 )\n\n                                            for _, repr in ipairs(speedRotatingPart.reprNodes) do\n                                                setRotation(repr, speedRotatingPart.xDrive, steeringAngle, 0 )\n                                            end\n                                        else\n                                                if not speedRotatingPart.alignDirection and(speedRotatingPart.versatileYRot or speedRotatingPart.applySteeringAngle) then\n                                                    setRotation(speedRotatingPart.repr, 0 , speedRotatingPart.steeringAngle, 0 )\n\n                                                    for _, repr in ipairs(speedRotatingPart.reprNodes) do\n                                                        setRotation(repr, 0 , speedRotatingPart.steeringAngle, 0 )\n                                                    end\n                                                end\n                                                setRotation(speedRotatingPart.driveNode, speedRotatingPart.xDrive, 0 , 0 )\n                                            end\n                                        end\n\n                                        if speedRotatingPart.shaderNode ~ = nil then\n                                            if speedRotatingPart.useShaderRotation then\n                                                local values = speedRotatingPart.shaderParameterValues\n\n                                                if speedRotatingPart.shaderComponentSpeeds ~ = nil then\n                                                    for index, speedScale in ipairs(speedRotatingPart.shaderComponentSpeeds) do\n                                                        if speedRotatingPart.scrollLength ~ = nil then\n                                                            values[index] = (speedRotatingPart.xDrive * speedRotatingPart.shaderParameterSpeedScale * speedScale) % speedRotatingPart.scrollLength\n                                                        else\n                                                                values[index] = (speedRotatingPart.xDrive * speedRotatingPart.shaderParameterSpeedScale * speedScale)\n                                                            end\n                                                        end\n                                                    else\n                                                            if speedRotatingPart.scrollLength ~ = nil then\n                                                                values[speedRotatingPart.shaderParameterComponent] = (speedRotatingPart.xDrive * speedRotatingPart.shaderParameterSpeedScale) % speedRotatingPart.scrollLength\n                                                            else\n                                                                    values[speedRotatingPart.shaderParameterComponent] = (speedRotatingPart.xDrive * speedRotatingPart.shaderParameterSpeedScale)\n                                                                end\n                                                            end\n\n                                                            if speedRotatingPart.shaderParameterPrevName ~ = nil then\n                                                                g_animationManager:setPrevShaderParameter(speedRotatingPart.shaderNode, speedRotatingPart.shaderParameterName, values[ 1 ], values[ 2 ], values[ 3 ], values[ 4 ], false , speedRotatingPart.shaderParameterPrevName)\n                                                            else\n                                                                    setShaderParameter(speedRotatingPart.shaderNode, speedRotatingPart.shaderParameterName, values[ 1 ], values[ 2 ], values[ 3 ], values[ 4 ], false )\n                                                                end\n                                                            else\n                                                                    local pos = (speedRotatingPart.xDrive % math.pi) / ( 2 * math.pi) -- normalize rotation\n                                                                    setShaderParameter(speedRotatingPart.shaderNode, "offsetUV" , pos * speedRotatingPart.scrollScale[ 1 ], pos * speedRotatingPart.scrollScale[ 2 ], 0 , 0 , false )\n                                                                end\n                                                            end\n                                                        end\n\n'})}),"\n",(0,a.jsx)(n.h3,{id:"validatewashablenode",children:"validateWashableNode"}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Description"})}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Definition"})}),"\n",(0,a.jsxs)(n.blockquote,{children:["\n",(0,a.jsx)(n.p,{children:"validateWashableNode()"}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,a.jsxs)(n.table,{children:[(0,a.jsx)(n.thead,{children:(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.th,{children:"any"}),(0,a.jsx)(n.th,{children:"superFunc"})]})}),(0,a.jsx)(n.tbody,{children:(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:"any"}),(0,a.jsx)(n.td,{children:"node"})]})})]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Code"})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-lua",children:'function SpeedRotatingParts:validateWashableNode(superFunc, node)\n    local spec = self.spec_speedRotatingParts\n    for _, speedRotatingPart in pairs(spec.speedRotatingParts) do\n        if speedRotatingPart.wheels ~ = nil then\n            local speedRotatingPartsNodes = { }\n\n            if speedRotatingPart.repr ~ = nil then\n                I3DUtil.getNodesByShaderParam(speedRotatingPart.repr, "scratches_dirt_snow_wetness" , speedRotatingPartsNodes)\n            end\n\n            for _, repr in ipairs(speedRotatingPart.reprNodes) do\n                I3DUtil.getNodesByShaderParam(repr, "scratches_dirt_snow_wetness" , speedRotatingPartsNodes)\n            end\n\n            if speedRotatingPart.shaderNode ~ = nil then\n                I3DUtil.getNodesByShaderParam(speedRotatingPart.shaderNode, "scratches_dirt_snow_wetness" , speedRotatingPartsNodes)\n            end\n\n            if speedRotatingPart.driveNode ~ = nil then\n                I3DUtil.getNodesByShaderParam(speedRotatingPart.driveNode, "scratches_dirt_snow_wetness" , speedRotatingPartsNodes)\n            end\n\n            if speedRotatingPartsNodes[node] ~ = nil then\n                local nodeData = { }\n                nodeData.wheel = speedRotatingPart.wheels[ 1 ]\n                nodeData.fieldDirtMultiplier = nodeData.wheel.physics.fieldDirtMultiplier\n                nodeData.streetDirtMultiplier = nodeData.wheel.physics.streetDirtMultiplier\n                nodeData.waterWetnessFactor = nodeData.wheel.physics.waterWetnessFactor\n                nodeData.minDirtPercentage = nodeData.wheel.physics.minDirtPercentage\n                nodeData.maxDirtOffset = nodeData.wheel.physics.maxDirtOffset\n                nodeData.dirtColorChangeSpeed = nodeData.wheel.physics.dirtColorChangeSpeed\n                nodeData.isSnowNode = true\n\n                return false , self.updateWheelDirtAmount, nodeData.wheel, nodeData\n            end\n        end\n    end\n\n    return superFunc( self , node)\nend\n\n'})})]})}function p(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(c,{...e})}):c(e)}}}]);