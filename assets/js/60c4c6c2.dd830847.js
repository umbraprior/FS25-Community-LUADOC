"use strict";(globalThis.webpackChunkfs25_community_luadoc=globalThis.webpackChunkfs25_community_luadoc||[]).push([[42092],{16452(n,e,i){i.r(e),i.d(e,{assets:()=>r,contentTitle:()=>a,default:()=>h,frontMatter:()=>s,metadata:()=>t,toc:()=>c});const t=JSON.parse('{"id":"script/Specializations/HookLiftTrailer","title":"HookLiftTrailer","description":"HookLiftTrailer","source":"@site/../docs/script/Specializations/HookLiftTrailer.md","sourceDirName":"script/Specializations","slug":"/script/Specializations/HookLiftTrailer","permalink":"/FS25-Community-LUADOC/script/Specializations/HookLiftTrailer","draft":false,"unlisted":false,"tags":[],"version":"current","lastUpdatedAt":1767161192000,"frontMatter":{},"sidebar":"docsSidebar","previous":{"title":"HookLiftContainer","permalink":"/FS25-Community-LUADOC/script/Specializations/HookLiftContainer"},"next":{"title":"HydraulicHammer","permalink":"/FS25-Community-LUADOC/script/Specializations/HydraulicHammer"}}');var o=i(74848),l=i(28453);const s={},a=void 0,r={},c=[{value:"HookLiftTrailer",id:"hooklifttrailer",level:2},{value:"addToPhysics",id:"addtophysics",level:3},{value:"getCanDetachContainer",id:"getcandetachcontainer",level:3},{value:"getDoConsumePtoPower",id:"getdoconsumeptopower",level:3},{value:"getIsFoldAllowed",id:"getisfoldallowed",level:3},{value:"getIsTippingAllowed",id:"getistippingallowed",level:3},{value:"getPtoRpm",id:"getptorpm",level:3},{value:"initSpecialization",id:"initspecialization",level:3},{value:"isDetachAllowed",id:"isdetachallowed",level:3},{value:"onLoad",id:"onload",level:3},{value:"onPostAttachImplement",id:"onpostattachimplement",level:3},{value:"onPostLoad",id:"onpostload",level:3},{value:"onPreDetachImplement",id:"onpredetachimplement",level:3},{value:"onUpdateAnimation",id:"onupdateanimation",level:3},{value:"onUpdateTick",id:"onupdatetick",level:3},{value:"prerequisitesPresent",id:"prerequisitespresent",level:3},{value:"registerEventListeners",id:"registereventlisteners",level:3},{value:"registerFunctions",id:"registerfunctions",level:3},{value:"registerOverwrittenFunctions",id:"registeroverwrittenfunctions",level:3},{value:"removeFromPhysics",id:"removefromphysics",level:3},{value:"setHookLiftContainerPhysicsState",id:"sethookliftcontainerphysicsstate",level:3},{value:"startTipping",id:"starttipping",level:3},{value:"stopTipping",id:"stoptipping",level:3},{value:"updateAdditionalHookLiftContainerJoint",id:"updateadditionalhookliftcontainerjoint",level:3},{value:"updateHookLiftContainerLockState",id:"updatehookliftcontainerlockstate",level:3}];function d(n){const e={a:"a",blockquote:"blockquote",code:"code",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,l.R)(),...n.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(e.h2,{id:"hooklifttrailer",children:"HookLiftTrailer"}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Description"})}),"\n",(0,o.jsxs)(e.blockquote,{children:["\n",(0,o.jsx)(e.p,{children:"Specialization for hooklift trailers providing separate load-up and tipping animations"}),"\n"]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Functions"})}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsx)(e.li,{children:(0,o.jsx)(e.a,{href:"#addtophysics",children:"addToPhysics"})}),"\n",(0,o.jsx)(e.li,{children:(0,o.jsx)(e.a,{href:"#getcandetachcontainer",children:"getCanDetachContainer"})}),"\n",(0,o.jsx)(e.li,{children:(0,o.jsx)(e.a,{href:"#getdoconsumeptopower",children:"getDoConsumePtoPower"})}),"\n",(0,o.jsx)(e.li,{children:(0,o.jsx)(e.a,{href:"#getisfoldallowed",children:"getIsFoldAllowed"})}),"\n",(0,o.jsx)(e.li,{children:(0,o.jsx)(e.a,{href:"#getistippingallowed",children:"getIsTippingAllowed"})}),"\n",(0,o.jsx)(e.li,{children:(0,o.jsx)(e.a,{href:"#getptorpm",children:"getPtoRpm"})}),"\n",(0,o.jsx)(e.li,{children:(0,o.jsx)(e.a,{href:"#initspecialization",children:"initSpecialization"})}),"\n",(0,o.jsx)(e.li,{children:(0,o.jsx)(e.a,{href:"#isdetachallowed",children:"isDetachAllowed"})}),"\n",(0,o.jsx)(e.li,{children:(0,o.jsx)(e.a,{href:"#onload",children:"onLoad"})}),"\n",(0,o.jsx)(e.li,{children:(0,o.jsx)(e.a,{href:"#onpostattachimplement",children:"onPostAttachImplement"})}),"\n",(0,o.jsx)(e.li,{children:(0,o.jsx)(e.a,{href:"#onpostload",children:"onPostLoad"})}),"\n",(0,o.jsx)(e.li,{children:(0,o.jsx)(e.a,{href:"#onpredetachimplement",children:"onPreDetachImplement"})}),"\n",(0,o.jsx)(e.li,{children:(0,o.jsx)(e.a,{href:"#onupdateanimation",children:"onUpdateAnimation"})}),"\n",(0,o.jsx)(e.li,{children:(0,o.jsx)(e.a,{href:"#onupdatetick",children:"onUpdateTick"})}),"\n",(0,o.jsx)(e.li,{children:(0,o.jsx)(e.a,{href:"#prerequisitespresent",children:"prerequisitesPresent"})}),"\n",(0,o.jsx)(e.li,{children:(0,o.jsx)(e.a,{href:"#registereventlisteners",children:"registerEventListeners"})}),"\n",(0,o.jsx)(e.li,{children:(0,o.jsx)(e.a,{href:"#registerfunctions",children:"registerFunctions"})}),"\n",(0,o.jsx)(e.li,{children:(0,o.jsx)(e.a,{href:"#registeroverwrittenfunctions",children:"registerOverwrittenFunctions"})}),"\n",(0,o.jsx)(e.li,{children:(0,o.jsx)(e.a,{href:"#removefromphysics",children:"removeFromPhysics"})}),"\n",(0,o.jsx)(e.li,{children:(0,o.jsx)(e.a,{href:"#sethookliftcontainerphysicsstate",children:"setHookLiftContainerPhysicsState"})}),"\n",(0,o.jsx)(e.li,{children:(0,o.jsx)(e.a,{href:"#starttipping",children:"startTipping"})}),"\n",(0,o.jsx)(e.li,{children:(0,o.jsx)(e.a,{href:"#stoptipping",children:"stopTipping"})}),"\n",(0,o.jsx)(e.li,{children:(0,o.jsx)(e.a,{href:"#updateadditionalhookliftcontainerjoint",children:"updateAdditionalHookLiftContainerJoint"})}),"\n",(0,o.jsx)(e.li,{children:(0,o.jsx)(e.a,{href:"#updatehookliftcontainerlockstate",children:"updateHookLiftContainerLockState"})}),"\n"]}),"\n",(0,o.jsx)(e.h3,{id:"addtophysics",children:"addToPhysics"}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Description"})}),"\n",(0,o.jsxs)(e.blockquote,{children:["\n",(0,o.jsx)(e.p,{children:"Add to physics"}),"\n"]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Definition"})}),"\n",(0,o.jsxs)(e.blockquote,{children:["\n",(0,o.jsx)(e.p,{children:"addToPhysics()"}),"\n"]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,o.jsx)(e.table,{children:(0,o.jsx)(e.thead,{children:(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.th,{children:"any"}),(0,o.jsx)(e.th,{children:"superFunc"})]})})}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Return Values"})}),"\n\n\n\n\n\n\n\n\n",(0,o.jsx)(e.table,{children:(0,o.jsx)(e.thead,{children:(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.th,{children:"any"}),(0,o.jsx)(e.th,{children:"success"}),(0,o.jsx)(e.th,{children:"success"})]})})}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Code"})}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-lua",children:"function HookLiftTrailer:addToPhysics(superFunc)\n    if not superFunc( self ) then\n        return false\n    end\n\n    local spec = self.spec_hookLiftTrailer\n    if spec.attachedContainer ~ = nil then\n        self:setHookLiftContainerPhysicsState(spec.attachedContainer.object, true )\n    end\n\n    return true\nend\n\n"})}),"\n",(0,o.jsx)(e.h3,{id:"getcandetachcontainer",children:"getCanDetachContainer"}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Description"})}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Definition"})}),"\n",(0,o.jsxs)(e.blockquote,{children:["\n",(0,o.jsx)(e.p,{children:"getCanDetachContainer()"}),"\n"]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Code"})}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-lua",children:"function HookLiftTrailer:getCanDetachContainer()\n    local spec = self.spec_hookLiftTrailer\n    return self:getAnimationTime(spec.refAnimation) = = 1\nend\n\n"})}),"\n",(0,o.jsx)(e.h3,{id:"getdoconsumeptopower",children:"getDoConsumePtoPower"}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Description"})}),"\n",(0,o.jsxs)(e.blockquote,{children:["\n",(0,o.jsx)(e.p,{children:"Returns if should consume pto power"}),"\n"]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Definition"})}),"\n",(0,o.jsxs)(e.blockquote,{children:["\n",(0,o.jsx)(e.p,{children:"getDoConsumePtoPower()"}),"\n"]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,o.jsx)(e.table,{children:(0,o.jsx)(e.thead,{children:(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.th,{children:"any"}),(0,o.jsx)(e.th,{children:"superFunc"})]})})}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Return Values"})}),"\n\n\n\n\n\n\n\n\n",(0,o.jsx)(e.table,{children:(0,o.jsx)(e.thead,{children:(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.th,{children:"any"}),(0,o.jsx)(e.th,{children:"consume"}),(0,o.jsx)(e.th,{children:"consumePtoPower"})]})})}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Code"})}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-lua",children:"function HookLiftTrailer:getDoConsumePtoPower(superFunc)\n    local spec = self.spec_hookLiftTrailer\n    local doConsume = superFunc( self )\n\n    return doConsume or self:getIsAnimationPlaying(spec.refAnimation) or self:getIsAnimationPlaying(spec.unloadingAnimation)\nend\n\n"})}),"\n",(0,o.jsx)(e.h3,{id:"getisfoldallowed",children:"getIsFoldAllowed"}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Description"})}),"\n",(0,o.jsxs)(e.blockquote,{children:["\n",(0,o.jsx)(e.p,{children:"Returns if fold is allowed"}),"\n"]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Definition"})}),"\n",(0,o.jsxs)(e.blockquote,{children:["\n",(0,o.jsx)(e.p,{children:"getIsFoldAllowed()"}),"\n"]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,o.jsxs)(e.table,{children:[(0,o.jsx)(e.thead,{children:(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.th,{children:"any"}),(0,o.jsx)(e.th,{children:"superFunc"})]})}),(0,o.jsxs)(e.tbody,{children:[(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.td,{children:"any"}),(0,o.jsx)(e.td,{children:"direction"})]}),(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.td,{children:"any"}),(0,o.jsx)(e.td,{children:"onAiTurnOn"})]})]})]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Return Values"})}),"\n\n\n\n\n\n\n\n\n",(0,o.jsx)(e.table,{children:(0,o.jsx)(e.thead,{children:(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.th,{children:"any"}),(0,o.jsx)(e.th,{children:"allowsFold"}),(0,o.jsx)(e.th,{children:"allows folding"})]})})}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Code"})}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-lua",children:"function HookLiftTrailer:getIsFoldAllowed(superFunc, direction, onAiTurnOn)\n    local spec = self.spec_hookLiftTrailer\n    if self:getAnimationTime(spec.unloadingAnimation) > 0 then\n        return false\n    end\n\n    return superFunc( self , direction, onAiTurnOn)\nend\n\n"})}),"\n",(0,o.jsx)(e.h3,{id:"getistippingallowed",children:"getIsTippingAllowed"}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Description"})}),"\n",(0,o.jsxs)(e.blockquote,{children:["\n",(0,o.jsx)(e.p,{children:"Returns if tipping is allowed"}),"\n"]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Definition"})}),"\n",(0,o.jsxs)(e.blockquote,{children:["\n",(0,o.jsx)(e.p,{children:"getIsTippingAllowed()"}),"\n"]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Return Values"})}),"\n\n\n\n\n\n\n\n\n",(0,o.jsx)(e.table,{children:(0,o.jsx)(e.thead,{children:(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.th,{children:"any"}),(0,o.jsx)(e.th,{children:"tippingAllowed"}),(0,o.jsx)(e.th,{children:"tipping is allowed"})]})})}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Code"})}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-lua",children:"function HookLiftTrailer:getIsTippingAllowed()\n    local spec = self.spec_hookLiftTrailer\n    return self:getAnimationTime(spec.refAnimation) = = 0\nend\n\n"})}),"\n",(0,o.jsx)(e.h3,{id:"getptorpm",children:"getPtoRpm"}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Description"})}),"\n",(0,o.jsxs)(e.blockquote,{children:["\n",(0,o.jsx)(e.p,{children:"Returns rpm of pto"}),"\n"]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Definition"})}),"\n",(0,o.jsxs)(e.blockquote,{children:["\n",(0,o.jsx)(e.p,{children:"getPtoRpm()"}),"\n"]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,o.jsx)(e.table,{children:(0,o.jsx)(e.thead,{children:(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.th,{children:"any"}),(0,o.jsx)(e.th,{children:"superFunc"})]})})}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Return Values"})}),"\n\n\n\n\n\n\n\n\n",(0,o.jsx)(e.table,{children:(0,o.jsx)(e.thead,{children:(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.th,{children:"any"}),(0,o.jsx)(e.th,{children:"rpm"}),(0,o.jsx)(e.th,{children:"rpm of pto"})]})})}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Code"})}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-lua",children:"function HookLiftTrailer:getPtoRpm(superFunc)\n    local spec = self.spec_hookLiftTrailer\n    local rpm = superFunc( self )\n\n    if self:getIsAnimationPlaying(spec.refAnimation) or self:getIsAnimationPlaying(spec.unloadingAnimation) then\n        return self.spec_powerConsumer.ptoRpm\n    else\n            return rpm\n        end\n    end\n\n"})}),"\n",(0,o.jsx)(e.h3,{id:"initspecialization",children:"initSpecialization"}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Description"})}),"\n",(0,o.jsxs)(e.blockquote,{children:["\n",(0,o.jsx)(e.p,{children:"Called on specialization initializing"}),"\n"]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Definition"})}),"\n",(0,o.jsxs)(e.blockquote,{children:["\n",(0,o.jsx)(e.p,{children:"initSpecialization()"}),"\n"]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Code"})}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-lua",children:'function HookLiftTrailer.initSpecialization()\n    local schema = Vehicle.xmlSchema\n    schema:setXMLSpecializationType( "HookLiftTrailer" )\n\n    schema:register(XMLValueType.STRING, "vehicle.hookLiftTrailer.jointLimits#refAnimation" , "Reference animation" , "unfoldHand" )\n\n    schema:register(XMLValueType.FLOAT, "vehicle.hookLiftTrailer.jointLimits.key(?)#time" , "Key time" )\n    schema:register(XMLValueType.VECTOR_ROT, "vehicle.hookLiftTrailer.jointLimits.key(?)#rotLimit" , "Rotation limit" , "0 0 0" )\n    schema:register(XMLValueType.VECTOR_ROT, "vehicle.hookLiftTrailer.jointLimits.key(?)#rotMinLimit" , "Negative rotation limit" )\n    schema:register(XMLValueType.VECTOR_ROT, "vehicle.hookLiftTrailer.jointLimits.key(?)#rotMaxLimit" , "Positive rotation limit" )\n    schema:register(XMLValueType.VECTOR_TRANS, "vehicle.hookLiftTrailer.jointLimits.key(?)#transLimit" , "Translation limit" , "0 0 0" )\n    schema:register(XMLValueType.VECTOR_TRANS, "vehicle.hookLiftTrailer.jointLimits.key(?)#transMinLimit" , "Negative translation limit" )\n    schema:register(XMLValueType.VECTOR_TRANS, "vehicle.hookLiftTrailer.jointLimits.key(?)#transMaxLimit" , "Positive translation limit" )\n\n    schema:register(XMLValueType.NODE_INDEX, "vehicle.hookLiftTrailer.additionalJoint#node" , "Additional joint to mount the container when fully lifted" )\n    schema:register(XMLValueType.NODE_INDEX, "vehicle.hookLiftTrailer.additionalJoint#attacherJointNode" , "Attacher joint node of the hook" )\n    schema:register(XMLValueType.BOOL, "vehicle.hookLiftTrailer.additionalJoint#disableCollision" , "Disable collision between trailer and container when fully lifted" , false )\n    schema:register(XMLValueType.FLOAT, "vehicle.hookLiftTrailer.additionalJoint#lockTime" , "Animation time when the additional joint is created" , 0.01 )\n\n    schema:register(XMLValueType.FLOAT, "vehicle.hookLiftTrailer.additionalJoint.key(?)#time" , "Key time" )\n    schema:register(XMLValueType.VECTOR_ROT, "vehicle.hookLiftTrailer.additionalJoint.key(?)#rotLimit" , "Rotation limit" , "0 0 0" )\n    schema:register(XMLValueType.VECTOR_ROT, "vehicle.hookLiftTrailer.additionalJoint.key(?)#rotMinLimit" , "Negative rotation limit" )\n    schema:register(XMLValueType.VECTOR_ROT, "vehicle.hookLiftTrailer.additionalJoint.key(?)#rotMaxLimit" , "Positive rotation limit" )\n    schema:register(XMLValueType.VECTOR_TRANS, "vehicle.hookLiftTrailer.additionalJoint.key(?)#transLimit" , "Translation limit" , "0 0 0" )\n    schema:register(XMLValueType.VECTOR_TRANS, "vehicle.hookLiftTrailer.additionalJoint.key(?)#transMinLimit" , "Negative translation limit" )\n    schema:register(XMLValueType.VECTOR_TRANS, "vehicle.hookLiftTrailer.additionalJoint.key(?)#transMaxLimit" , "Positive translation limit" )\n\n    schema:register(XMLValueType.STRING, "vehicle.hookLiftTrailer.unloadingAnimation#name" , "Unload animation" , "unloading" )\n    schema:register(XMLValueType.FLOAT, "vehicle.hookLiftTrailer.unloadingAnimation#speed" , "Unload animation speed" , 1 )\n    schema:register(XMLValueType.FLOAT, "vehicle.hookLiftTrailer.unloadingAnimation#reverseSpeed" , "Unload animation reverse speed" , - 1 )\n\n    schema:register(XMLValueType.NODE_INDEX, "vehicle.hookLiftTrailer.hookLock#referenceNode" , "Reference node for distance to the container" )\n        schema:register(XMLValueType.FLOAT, "vehicle.hookLiftTrailer.hookLock#minDistance" , "Min.distance to the reference node to activate object change(in Y and Z offset)" , 0.05 )\n        schema:register(XMLValueType.FLOAT, "vehicle.hookLiftTrailer.hookLock#minDistanceSide" , "Min.distance to the reference node to activate object change(in X offset)" , 0.15 )\n        ObjectChangeUtil.registerObjectChangeXMLPaths(schema, "vehicle.hookLiftTrailer.hookLock" )\n\n        ObjectChangeUtil.registerObjectChangeXMLPaths(schema, "vehicle.hookLiftTrailer.containerLock" )\n\n        schema:register(XMLValueType.NODE_INDEX, "vehicle.hookLiftTrailer.visualRoll(?)#node" , "Visual roll that spins when the container gets close" )\n        schema:register(XMLValueType.FLOAT, "vehicle.hookLiftTrailer.visualRoll(?)#radius" , "Radius of the roll" , 0.1 )\n        schema:register(XMLValueType.INT, "vehicle.hookLiftTrailer.visualRoll(?)#rotAxis" , "Rotation axis" , 1 )\n        schema:register(XMLValueType.INT, "vehicle.hookLiftTrailer.visualRoll(?)#direction" , "Rotation direction" , - 1 )\n\n        schema:register(XMLValueType.STRING, "vehicle.hookLiftTrailer.texts#unloadContainer" , "Unload container text" , "$l10n_unload_container" )\n        schema:register(XMLValueType.STRING, "vehicle.hookLiftTrailer.texts#loadContainer" , "Load container text" , "$l10n_load_container" )\n        schema:register(XMLValueType.STRING, "vehicle.hookLiftTrailer.texts#unloadArm" , "Unload arm text" , "$l10n_unload_arm" )\n        schema:register(XMLValueType.STRING, "vehicle.hookLiftTrailer.texts#loadArm" , "Load arm text" , "$l10n_load_arm" )\n\n        schema:setXMLSpecializationType()\n    end\n\n'})}),"\n",(0,o.jsx)(e.h3,{id:"isdetachallowed",children:"isDetachAllowed"}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Description"})}),"\n",(0,o.jsxs)(e.blockquote,{children:["\n",(0,o.jsx)(e.p,{children:"Returns true if detach is allowed"}),"\n"]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Definition"})}),"\n",(0,o.jsxs)(e.blockquote,{children:["\n",(0,o.jsx)(e.p,{children:"isDetachAllowed()"}),"\n"]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,o.jsx)(e.table,{children:(0,o.jsx)(e.thead,{children:(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.th,{children:"any"}),(0,o.jsx)(e.th,{children:"superFunc"})]})})}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Return Values"})}),"\n\n\n\n\n\n\n\n\n",(0,o.jsx)(e.table,{children:(0,o.jsx)(e.thead,{children:(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.th,{children:"any"}),(0,o.jsx)(e.th,{children:"detachAllowed"}),(0,o.jsx)(e.th,{children:"detach is allowed"})]})})}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Code"})}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-lua",children:"function HookLiftTrailer:isDetachAllowed(superFunc)\n    if self:getAnimationTime( self.spec_hookLiftTrailer.unloadingAnimation) = = 0 then\n        return superFunc( self )\n    else\n            return false , nil\n        end\n    end\n\n"})}),"\n",(0,o.jsx)(e.h3,{id:"onload",children:"onLoad"}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Description"})}),"\n",(0,o.jsxs)(e.blockquote,{children:["\n",(0,o.jsx)(e.p,{children:"Called on loading"}),"\n"]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Definition"})}),"\n",(0,o.jsxs)(e.blockquote,{children:["\n",(0,o.jsx)(e.p,{children:"onLoad(table savegame)"}),"\n"]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n",(0,o.jsx)(e.table,{children:(0,o.jsx)(e.thead,{children:(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.th,{children:"table"}),(0,o.jsx)(e.th,{children:"savegame"}),(0,o.jsx)(e.th,{children:"savegame"})]})})}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Code"})}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-lua",children:'function HookLiftTrailer:onLoad(savegame)\n    local spec = self.spec_hookLiftTrailer\n\n    spec.refAnimation = self.xmlFile:getValue( "vehicle.hookLiftTrailer.jointLimits#refAnimation" , "unfoldHand" )\n\n    local function loadJointLimits(xmlFile, limitsKey)\n        local jointLimits = AnimCurve.new(linearInterpolatorN)\n        for _, key in xmlFile:iterator(limitsKey .. ".key" ) do\n            local t = xmlFile:getValue(key .. "#time" )\n            if t ~ = nil then\n                local rx, ry, rz = xmlFile:getValue(key .. "#rotLimit" , "0 0 0" )\n\n                local minRx, minRy, minRz = xmlFile:getValue(key .. "#rotMinLimit" )\n                local maxRx, maxRy, maxRz = xmlFile:getValue(key .. "#rotMaxLimit" )\n                minRx, minRy, minRz = minRx or - rx, minRy or - ry, minRz or - rz\n                maxRx, maxRy, maxRz = maxRx or rx, maxRy or ry, maxRz or rz\n\n                local tx, ty, tz = xmlFile:getValue(key .. "#transLimit" , "0 0 0" )\n\n                local minTx, minTy, minTz = xmlFile:getValue(key .. "#transMinLimit" )\n                local maxTx, maxTy, maxTz = xmlFile:getValue(key .. "#transMaxLimit" )\n                minTx, minTy, minTz = minTx or - tx, minTy or - ty, minTz or - tz\n                maxTx, maxTy, maxTz = maxTx or tx, maxTy or ty, maxTz or tz\n\n                jointLimits:addKeyframe( { minRx, minRy, minRz, maxRx, maxRy, maxRz, minTx, minTy, minTz, maxTx, maxTy, maxTz, time = t } )\n            end\n        end\n\n        if jointLimits.numKeyframes = = 0 then\n            return nil\n        end\n\n        return jointLimits\n    end\n\n    spec.jointLimits = loadJointLimits( self.xmlFile, "vehicle.hookLiftTrailer.jointLimits" )\n\n    spec.additionalJointNode = self.xmlFile:getValue( "vehicle.hookLiftTrailer.additionalJoint#node" , nil , self.components, self.i3dMappings)\n    spec.additionalJointReferenceJointNode = self.xmlFile:getValue( "vehicle.hookLiftTrailer.additionalJoint#attacherJointNode" , nil , self.components, self.i3dMappings)\n    spec.additionalJointDisableCollision = self.xmlFile:getValue( "vehicle.hookLiftTrailer.additionalJoint#disableCollision" , false )\n    spec.additionalJointLockTime = self.xmlFile:getValue( "vehicle.hookLiftTrailer.additionalJoint#lockTime" , 0.01 )\n    spec.additionalJointState = false\n    if spec.additionalJointNode ~ = nil and spec.additionalJointReferenceJointNode ~ = nil then\n        spec.additionalJointOffset = { localToLocal(spec.additionalJointNode, spec.additionalJointReferenceJointNode, 0 , 0 , 0 ) }\n    end\n\n    spec.additionalJointLimits = loadJointLimits( self.xmlFile, "vehicle.hookLiftTrailer.additionalJoint" )\n\n    spec.unloadingAnimation = self.xmlFile:getValue( "vehicle.hookLiftTrailer.unloadingAnimation#name" , "unloading" )\n    spec.unloadingAnimationSpeed = self.xmlFile:getValue( "vehicle.hookLiftTrailer.unloadingAnimation#speed" , 1 )\n    spec.unloadingAnimationReverseSpeed = self.xmlFile:getValue( "vehicle.hookLiftTrailer.unloadingAnimation#reverseSpeed" , - 1 )\n\n    if self.isClient then\n        spec.hookLock = { }\n        spec.hookLock.state = false\n        spec.hookLock.referenceNode = self.xmlFile:getValue( "vehicle.hookLiftTrailer.hookLock#referenceNode" , nil , self.components, self.i3dMappings)\n        spec.hookLock.minDistance = self.xmlFile:getValue( "vehicle.hookLiftTrailer.hookLock#minDistance" , 0.05 )\n        spec.hookLock.minDistanceSide = self.xmlFile:getValue( "vehicle.hookLiftTrailer.hookLock#minDistanceSide" , 0.15 )\n\n        spec.hookLock.changeObjects = { }\n        ObjectChangeUtil.loadObjectChangeFromXML( self.xmlFile, "vehicle.hookLiftTrailer.hookLock" , spec.hookLock.changeObjects, self.components, self )\n        ObjectChangeUtil.setObjectChanges(spec.hookLock.changeObjects, false , self , self.setMovingToolDirty)\n    end\n\n    spec.containerLockState = false\n    spec.containerLockChangeObjects = { }\n    ObjectChangeUtil.loadObjectChangeFromXML( self.xmlFile, "vehicle.hookLiftTrailer.containerLock" , spec.containerLockChangeObjects, self.components, self )\n    ObjectChangeUtil.setObjectChanges(spec.containerLockChangeObjects, false , self , self.setMovingToolDirty)\n\n    spec.visualRolls = { }\n    for _, key in self.xmlFile:iterator( "vehicle.hookLiftTrailer.visualRoll" ) do\n        local visualRoll = { }\n        visualRoll.node = self.xmlFile:getValue(key .. "#node" , nil , self.components, self.i3dMappings)\n        if visualRoll.node ~ = nil then\n            visualRoll.radius = self.xmlFile:getValue(key .. "#radius" , 0.1 )\n            visualRoll.rotAxis = self.xmlFile:getValue(key .. "#rotAxis" , 1 )\n            visualRoll.direction = self.xmlFile:getValue(key .. "#direction" , 01 )\n            table.insert(spec.visualRolls, visualRoll)\n        end\n    end\n\n    spec.texts = { }\n    spec.texts.unloadContainer = g_i18n:convertText( self.xmlFile:getValue( "vehicle.hookLiftTrailer.texts#unloadContainer" , "$l10n_unload_container" ), self.customEnvironment)\n    spec.texts.loadContainer = g_i18n:convertText( self.xmlFile:getValue( "vehicle.hookLiftTrailer.texts#loadContainer" , "$l10n_load_container" ), self.customEnvironment)\n    spec.texts.unloadArm = g_i18n:convertText( self.xmlFile:getValue( "vehicle.hookLiftTrailer.texts#unloadArm" , "$l10n_unload_arm" ), self.customEnvironment)\n    spec.texts.loadArm = g_i18n:convertText( self.xmlFile:getValue( "vehicle.hookLiftTrailer.texts#loadArm" , "$l10n_load_arm" ), self.customEnvironment)\nend\n\n'})}),"\n",(0,o.jsx)(e.h3,{id:"onpostattachimplement",children:"onPostAttachImplement"}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Description"})}),"\n",(0,o.jsxs)(e.blockquote,{children:["\n",(0,o.jsx)(e.p,{children:"Called on attaching a implement"}),"\n"]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Definition"})}),"\n",(0,o.jsxs)(e.blockquote,{children:["\n",(0,o.jsx)(e.p,{children:"onPostAttachImplement(table implement, , , )"}),"\n"]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,o.jsxs)(e.table,{children:[(0,o.jsx)(e.thead,{children:(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.th,{children:"table"}),(0,o.jsx)(e.th,{children:"implement"}),(0,o.jsx)(e.th,{children:"implement to attach"})]})}),(0,o.jsxs)(e.tbody,{children:[(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.td,{children:"any"}),(0,o.jsx)(e.td,{children:"inputJointDescIndex"}),(0,o.jsx)(e.td,{})]}),(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.td,{children:"any"}),(0,o.jsx)(e.td,{children:"jointDescIndex"}),(0,o.jsx)(e.td,{})]}),(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.td,{children:"any"}),(0,o.jsx)(e.td,{children:"loadFromSavegame"}),(0,o.jsx)(e.td,{})]})]})]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Code"})}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-lua",children:"function HookLiftTrailer:onPostAttachImplement(attachable, inputJointDescIndex, jointDescIndex, loadFromSavegame)\n    local spec = self.spec_hookLiftTrailer\n\n    local attacherJoint = attachable:getActiveInputAttacherJoint()\n    if attacherJoint ~ = nil then\n        if attacherJoint.jointType = = AttacherJoints.JOINTTYPE_HOOKLIFT then\n            local jointDesc = self:getAttacherJointByJointDescIndex(jointDescIndex)\n            spec.attachedContainer = { }\n            spec.attachedContainer.jointIndex = jointDesc.jointIndex\n            spec.attachedContainer.jointDescIndex = jointDescIndex\n            spec.attachedContainer.implement = self:getImplementByObject(attachable)\n            spec.attachedContainer.object = attachable\n            spec.attachedContainer.limitLocked = false\n\n            local foldableSpec = self.spec_foldable\n            foldableSpec.posDirectionText = spec.texts.unloadContainer\n            foldableSpec.negDirectionText = spec.texts.loadContainer\n        end\n    end\n\n    self:updateHookLiftContainerLockState()\nend\n\n"})}),"\n",(0,o.jsx)(e.h3,{id:"onpostload",children:"onPostLoad"}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Description"})}),"\n",(0,o.jsxs)(e.blockquote,{children:["\n",(0,o.jsx)(e.p,{children:"Called after loading"}),"\n"]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Definition"})}),"\n",(0,o.jsxs)(e.blockquote,{children:["\n",(0,o.jsx)(e.p,{children:"onPostLoad(table savegame)"}),"\n"]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n",(0,o.jsx)(e.table,{children:(0,o.jsx)(e.thead,{children:(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.th,{children:"table"}),(0,o.jsx)(e.th,{children:"savegame"}),(0,o.jsx)(e.th,{children:"savegame"})]})})}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Code"})}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-lua",children:"function HookLiftTrailer:onPostLoad(savegame)\n    local spec = self.spec_hookLiftTrailer\n    local foldableSpec = self.spec_foldable\n    foldableSpec.posDirectionText = spec.texts.unloadArm\n    foldableSpec.negDirectionText = spec.texts.loadArm\nend\n\n"})}),"\n",(0,o.jsx)(e.h3,{id:"onpredetachimplement",children:"onPreDetachImplement"}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Description"})}),"\n",(0,o.jsxs)(e.blockquote,{children:["\n",(0,o.jsx)(e.p,{children:"Called on detaching a implement"}),"\n"]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Definition"})}),"\n",(0,o.jsxs)(e.blockquote,{children:["\n",(0,o.jsx)(e.p,{children:"onPreDetachImplement(integer implementIndex)"}),"\n"]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n",(0,o.jsx)(e.table,{children:(0,o.jsx)(e.thead,{children:(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.th,{children:"integer"}),(0,o.jsx)(e.th,{children:"implementIndex"}),(0,o.jsx)(e.th,{children:"index of implement to detach"})]})})}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Code"})}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-lua",children:"function HookLiftTrailer:onPreDetachImplement(implement)\n    local spec = self.spec_hookLiftTrailer\n    if spec.attachedContainer ~ = nil then\n        if implement = = spec.attachedContainer.implement then\n            spec.attachedContainer.object:onHookLiftContainerLockChanged( false )\n\n            local foldableSpec = self.spec_foldable\n            foldableSpec.posDirectionText = spec.texts.unloadArm\n            foldableSpec.negDirectionText = spec.texts.loadArm\n\n            if spec.attachedContainer.additionalJointIndex ~ = nil then\n                removeJoint(spec.attachedContainer.additionalJointIndex)\n                spec.attachedContainer.additionalJointIndex = nil\n            end\n\n            if spec.attachedContainer.jointNodeContainer ~ = nil then\n                delete(spec.attachedContainer.jointNodeContainer)\n                spec.attachedContainer.jointNodeContainer = nil\n            end\n\n            spec.attachedContainer = nil\n        end\n    end\n\n    self:updateHookLiftContainerLockState()\nend\n\n"})}),"\n",(0,o.jsx)(e.h3,{id:"onupdateanimation",children:"onUpdateAnimation"}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Description"})}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Definition"})}),"\n",(0,o.jsxs)(e.blockquote,{children:["\n",(0,o.jsx)(e.p,{children:"onUpdateAnimation()"}),"\n"]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,o.jsx)(e.table,{children:(0,o.jsx)(e.thead,{children:(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.th,{children:"any"}),(0,o.jsx)(e.th,{children:"name"})]})})}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Code"})}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-lua",children:"function HookLiftTrailer:onUpdateAnimation(name)\n    local spec = self.spec_hookLiftTrailer\n    if name = = spec.refAnimation then\n        self:updateHookLiftContainerLockState()\n\n        if spec.attachedContainer ~ = nil then\n            local spec_hookLiftContainer = spec.attachedContainer.object.spec_hookLiftContainer\n            local startNode, endNode = spec_hookLiftContainer.visualReferenceNodeStart, spec_hookLiftContainer.visualReferenceNodeEnd\n            if startNode ~ = nil and endNode ~ = nil then\n                local _, y1, z1 = localToLocal(startNode, self.rootNode, 0 , 0 , 0 )\n                local _, y2, z2 = localToLocal(endNode, self.rootNode, 0 , 0 , 0 )\n                local dirY, dirZ = y2 - y1, z2 - z1\n                local length = MathUtil.vector2Length(dirY, dirZ)\n                if length > 0 then\n                    dirY, dirZ = dirY / length, dirZ / length\n\n                    for _, visualRoll in ipairs(spec.visualRolls) do\n                        local _, y3, z3 = localToLocal(visualRoll.node, self.rootNode, 0 , 0 , 0 )\n\n                        local positionOnLine = MathUtil.getProjectOnLineParameter(y3, z3 , y1, z1, dirY, dirZ)\n                        if positionOnLine > = 0 and positionOnLine < = length then\n                            local y4, z4 = y1 + dirY * positionOnLine, z1 + dirZ * positionOnLine\n                            local distance = MathUtil.vector2Length(y3 - y4, z3 - z4)\n\n                            if distance < = visualRoll.radius + 0.025 then\n                                if visualRoll.lastPositionOnLine = = nil then\n                                    visualRoll.lastPositionOnLine = positionOnLine\n                                end\n\n                                local moved = visualRoll.lastPositionOnLine - positionOnLine\n                                local rotOffset = moved / visualRoll.radius * visualRoll.direction\n\n                                if visualRoll.rotAxis = = 1 then\n                                    rotate(visualRoll.node, rotOffset, 0 , 0 )\n                                elseif visualRoll.rotAxis = = 2 then\n                                        rotate(visualRoll.node, 0 , rotOffset, 0 )\n                                    elseif visualRoll.rotAxis = = 3 then\n                                            rotate(visualRoll.node, 0 , 0 , rotOffset)\n                                        end\n\n                                        visualRoll.lastPositionOnLine = positionOnLine\n                                    else\n                                            visualRoll.lastPositionOnLine = nil\n                                        end\n                                    else\n                                            visualRoll.lastPositionOnLine = nil\n                                        end\n                                    end\n                                end\n                            end\n                        end\n                    end\n\n                    if self.isServer then\n                        if name = = spec.unloadingAnimation then\n                            if spec.attachedContainer ~ = nil and spec.attachedContainer.additionalJointIndex ~ = nil then\n                                setJointFrame(spec.attachedContainer.additionalJointIndex, 1 , spec.additionalJointNode)\n                            end\n                        end\n                    end\n                end\n\n"})}),"\n",(0,o.jsx)(e.h3,{id:"onupdatetick",children:"onUpdateTick"}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Description"})}),"\n",(0,o.jsxs)(e.blockquote,{children:["\n",(0,o.jsx)(e.p,{children:"Called on update tick"}),"\n"]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Definition"})}),"\n",(0,o.jsxs)(e.blockquote,{children:["\n",(0,o.jsx)(e.p,{children:"onUpdateTick(float dt, boolean isActiveForInput, boolean isSelected, )"}),"\n"]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,o.jsxs)(e.table,{children:[(0,o.jsx)(e.thead,{children:(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.th,{children:"float"}),(0,o.jsx)(e.th,{children:"dt"}),(0,o.jsx)(e.th,{children:"time since last call in ms"})]})}),(0,o.jsxs)(e.tbody,{children:[(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.td,{children:"boolean"}),(0,o.jsx)(e.td,{children:"isActiveForInput"}),(0,o.jsx)(e.td,{children:"true if vehicle is active for input"})]}),(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.td,{children:"boolean"}),(0,o.jsx)(e.td,{children:"isSelected"}),(0,o.jsx)(e.td,{children:"true if vehicle is selected"})]}),(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.td,{children:"any"}),(0,o.jsx)(e.td,{children:"isSelected"}),(0,o.jsx)(e.td,{})]})]})]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Code"})}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-lua",children:"function HookLiftTrailer:onUpdateTick(dt, isActiveForInput, isActiveForInputIgnoreSelection, isSelected)\n    local spec = self.spec_hookLiftTrailer\n\n    if spec.attachedContainer ~ = nil then\n        local animTime = self:getAnimationTime(spec.refAnimation)\n        spec.attachedContainer.object.allowsDetaching = animTime > 0.95\n\n        if ( self:getIsAnimationPlaying(spec.refAnimation) or not spec.attachedContainer.limitLocked) and not spec.attachedContainer.implement.attachingIsInProgress then\n            if spec.jointLimits ~ = nil then\n                local minRx, minRy, minRz, maxRx, maxRy, maxRz, minTx, minTy, minTz, maxTx, maxTy, maxTz = spec.jointLimits:get(animTime)\n\n                setJointRotationLimit(spec.attachedContainer.jointIndex, 0 , true , minRx, maxRx)\n                setJointRotationLimit(spec.attachedContainer.jointIndex, 1 , true , minRy, maxRy)\n                setJointRotationLimit(spec.attachedContainer.jointIndex, 2 , true , minRz, maxRz)\n\n                setJointTranslationLimit(spec.attachedContainer.jointIndex, 0 , true , minTx, maxTx)\n                setJointTranslationLimit(spec.attachedContainer.jointIndex, 1 , true , minTy, maxTy)\n                setJointTranslationLimit(spec.attachedContainer.jointIndex, 2 , true , minTz, maxTz)\n            end\n\n            if spec.additionalJointLimits ~ = nil and spec.attachedContainer.additionalJointIndex ~ = nil then\n                local minRx, minRy, minRz, maxRx, maxRy, maxRz, minTx, minTy, minTz, maxTx, maxTy, maxTz = spec.additionalJointLimits:get(animTime)\n\n                setJointRotationLimit(spec.attachedContainer.additionalJointIndex, 0 , true , minRx, maxRx)\n                setJointRotationLimit(spec.attachedContainer.additionalJointIndex, 1 , true , minRy, maxRy)\n                setJointRotationLimit(spec.attachedContainer.additionalJointIndex, 2 , true , minRz, maxRz)\n\n                setJointTranslationLimit(spec.attachedContainer.additionalJointIndex, 0 , true , minTx, maxTx)\n                setJointTranslationLimit(spec.attachedContainer.additionalJointIndex, 1 , true , minTy, maxTy)\n                setJointTranslationLimit(spec.attachedContainer.additionalJointIndex, 2 , true , minTz, maxTz)\n            end\n\n            if animTime > = 0.99 then\n                spec.attachedContainer.limitLocked = true\n            end\n        end\n    end\n\n    if self.isClient then\n        if spec.hookLock.referenceNode ~ = nil then\n            local state = false\n\n            local attachableInfo = self.spec_attacherJoints.attachableInfo\n            if attachableInfo.attachable ~ = nil and attachableInfo.attachableJointDescIndex ~ = nil then\n                local inputAttacherJoint = attachableInfo.attachable:getInputAttacherJointByJointDescIndex(attachableInfo.attachableJointDescIndex)\n                if inputAttacherJoint ~ = nil then\n                    local x, y, z = localToLocal(inputAttacherJoint.node, spec.hookLock.referenceNode, 0 , 0 , 0 )\n                    local distance = MathUtil.vector2Length(y, z)\n                    if distance < spec.hookLock.minDistance and math.abs(x) < spec.hookLock.minDistanceSide then\n                        state = true\n                    end\n                end\n            end\n\n            if state ~ = spec.hookLock.state then\n                spec.hookLock.state = state\n                ObjectChangeUtil.setObjectChanges(spec.hookLock.changeObjects, state, self , self.setMovingToolDirty)\n            end\n        end\n    end\nend\n\n"})}),"\n",(0,o.jsx)(e.h3,{id:"prerequisitespresent",children:"prerequisitesPresent"}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Description"})}),"\n",(0,o.jsxs)(e.blockquote,{children:["\n",(0,o.jsx)(e.p,{children:"Checks if all prerequisite specializations are loaded"}),"\n"]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Definition"})}),"\n",(0,o.jsxs)(e.blockquote,{children:["\n",(0,o.jsx)(e.p,{children:"prerequisitesPresent(table specializations)"}),"\n"]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n",(0,o.jsx)(e.table,{children:(0,o.jsx)(e.thead,{children:(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.th,{children:"table"}),(0,o.jsx)(e.th,{children:"specializations"}),(0,o.jsx)(e.th,{children:"specializations"})]})})}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Return Values"})}),"\n\n\n\n\n\n\n\n\n",(0,o.jsx)(e.table,{children:(0,o.jsx)(e.thead,{children:(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.th,{children:"table"}),(0,o.jsx)(e.th,{children:"hasPrerequisite"}),(0,o.jsx)(e.th,{children:"true if all prerequisite specializations are loaded"})]})})}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Code"})}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-lua",children:"function HookLiftTrailer.prerequisitesPresent(specializations)\n    return SpecializationUtil.hasSpecialization( AnimatedVehicle , specializations) and SpecializationUtil.hasSpecialization( Foldable , specializations)\nend\n\n"})}),"\n",(0,o.jsx)(e.h3,{id:"registereventlisteners",children:"registerEventListeners"}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Description"})}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Definition"})}),"\n",(0,o.jsxs)(e.blockquote,{children:["\n",(0,o.jsx)(e.p,{children:"registerEventListeners()"}),"\n"]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,o.jsx)(e.table,{children:(0,o.jsx)(e.thead,{children:(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.th,{children:"any"}),(0,o.jsx)(e.th,{children:"vehicleType"})]})})}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Code"})}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-lua",children:'function HookLiftTrailer.registerEventListeners(vehicleType)\n    SpecializationUtil.registerEventListener(vehicleType, "onLoad" , HookLiftTrailer )\n    SpecializationUtil.registerEventListener(vehicleType, "onPostLoad" , HookLiftTrailer )\n    SpecializationUtil.registerEventListener(vehicleType, "onUpdateTick" , HookLiftTrailer )\n    SpecializationUtil.registerEventListener(vehicleType, "onPostAttachImplement" , HookLiftTrailer )\n    SpecializationUtil.registerEventListener(vehicleType, "onPreDetachImplement" , HookLiftTrailer )\n    SpecializationUtil.registerEventListener(vehicleType, "onUpdateAnimation" , HookLiftTrailer )\nend\n\n'})}),"\n",(0,o.jsx)(e.h3,{id:"registerfunctions",children:"registerFunctions"}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Description"})}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Definition"})}),"\n",(0,o.jsxs)(e.blockquote,{children:["\n",(0,o.jsx)(e.p,{children:"registerFunctions()"}),"\n"]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,o.jsx)(e.table,{children:(0,o.jsx)(e.thead,{children:(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.th,{children:"any"}),(0,o.jsx)(e.th,{children:"vehicleType"})]})})}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Code"})}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-lua",children:'function HookLiftTrailer.registerFunctions(vehicleType)\n    SpecializationUtil.registerFunction(vehicleType, "startTipping" , HookLiftTrailer.startTipping)\n    SpecializationUtil.registerFunction(vehicleType, "stopTipping" , HookLiftTrailer.stopTipping)\n    SpecializationUtil.registerFunction(vehicleType, "getIsTippingAllowed" , HookLiftTrailer.getIsTippingAllowed)\n    SpecializationUtil.registerFunction(vehicleType, "getCanDetachContainer" , HookLiftTrailer.getCanDetachContainer)\n    SpecializationUtil.registerFunction(vehicleType, "updateHookLiftContainerLockState" , HookLiftTrailer.updateHookLiftContainerLockState)\n    SpecializationUtil.registerFunction(vehicleType, "updateAdditionalHookLiftContainerJoint" , HookLiftTrailer.updateAdditionalHookLiftContainerJoint)\n    SpecializationUtil.registerFunction(vehicleType, "setHookLiftContainerPhysicsState" , HookLiftTrailer.setHookLiftContainerPhysicsState)\nend\n\n'})}),"\n",(0,o.jsx)(e.h3,{id:"registeroverwrittenfunctions",children:"registerOverwrittenFunctions"}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Description"})}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Definition"})}),"\n",(0,o.jsxs)(e.blockquote,{children:["\n",(0,o.jsx)(e.p,{children:"registerOverwrittenFunctions()"}),"\n"]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,o.jsx)(e.table,{children:(0,o.jsx)(e.thead,{children:(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.th,{children:"any"}),(0,o.jsx)(e.th,{children:"vehicleType"})]})})}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Code"})}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-lua",children:'function HookLiftTrailer.registerOverwrittenFunctions(vehicleType)\n    SpecializationUtil.registerOverwrittenFunction(vehicleType, "getIsFoldAllowed" , HookLiftTrailer.getIsFoldAllowed)\n    SpecializationUtil.registerOverwrittenFunction(vehicleType, "isDetachAllowed" , HookLiftTrailer.isDetachAllowed)\n    SpecializationUtil.registerOverwrittenFunction(vehicleType, "getDoConsumePtoPower" , HookLiftTrailer.getDoConsumePtoPower)\n    SpecializationUtil.registerOverwrittenFunction(vehicleType, "getPtoRpm" , HookLiftTrailer.getPtoRpm)\n    SpecializationUtil.registerOverwrittenFunction(vehicleType, "addToPhysics" , HookLiftTrailer.addToPhysics)\n    SpecializationUtil.registerOverwrittenFunction(vehicleType, "removeFromPhysics" , HookLiftTrailer.removeFromPhysics)\nend\n\n'})}),"\n",(0,o.jsx)(e.h3,{id:"removefromphysics",children:"removeFromPhysics"}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Description"})}),"\n",(0,o.jsxs)(e.blockquote,{children:["\n",(0,o.jsx)(e.p,{children:"Remove vehicle from physics"}),"\n"]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Definition"})}),"\n",(0,o.jsxs)(e.blockquote,{children:["\n",(0,o.jsx)(e.p,{children:"removeFromPhysics()"}),"\n"]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,o.jsx)(e.table,{children:(0,o.jsx)(e.thead,{children:(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.th,{children:"any"}),(0,o.jsx)(e.th,{children:"superFunc"})]})})}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Code"})}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-lua",children:"function HookLiftTrailer:removeFromPhysics(superFunc)\n    local spec = self.spec_hookLiftTrailer\n\n    if spec.attachedContainer ~ = nil then\n        self:setHookLiftContainerPhysicsState(spec.attachedContainer.object, false )\n    end\n\n    if not superFunc( self ) then\n        return false\n    end\n\n    return true\nend\n\n"})}),"\n",(0,o.jsx)(e.h3,{id:"sethookliftcontainerphysicsstate",children:"setHookLiftContainerPhysicsState"}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Description"})}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Definition"})}),"\n",(0,o.jsxs)(e.blockquote,{children:["\n",(0,o.jsx)(e.p,{children:"setHookLiftContainerPhysicsState()"}),"\n"]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,o.jsxs)(e.table,{children:[(0,o.jsx)(e.thead,{children:(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.th,{children:"any"}),(0,o.jsx)(e.th,{children:"container"})]})}),(0,o.jsx)(e.tbody,{children:(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.td,{children:"any"}),(0,o.jsx)(e.td,{children:"state"})]})})]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Code"})}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-lua",children:"function HookLiftTrailer:setHookLiftContainerPhysicsState(container, state)\n    local spec = self.spec_hookLiftTrailer\n\n    if spec.attachedContainer ~ = nil and spec.attachedContainer.object = = container then\n        if state then\n            local jointDesc = self:getAttacherJointByJointDescIndex(spec.attachedContainer.jointDescIndex)\n            if jointDesc.jointIndex ~ = 0 then\n                spec.attachedContainer.jointIndex = jointDesc.jointIndex\n                spec.attachedContainer.limitLocked = false\n            end\n        else\n                spec.attachedContainer.jointIndex = 0\n            end\n\n            self:updateAdditionalHookLiftContainerJoint()\n        end\n    end\n\n"})}),"\n",(0,o.jsx)(e.h3,{id:"starttipping",children:"startTipping"}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Description"})}),"\n",(0,o.jsxs)(e.blockquote,{children:["\n",(0,o.jsx)(e.p,{children:"Called on start tipping"}),"\n"]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Definition"})}),"\n",(0,o.jsxs)(e.blockquote,{children:["\n",(0,o.jsx)(e.p,{children:"startTipping()"}),"\n"]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Code"})}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-lua",children:"function HookLiftTrailer:startTipping()\n    local spec = self.spec_hookLiftTrailer\n    self:playAnimation(spec.unloadingAnimation, spec.unloadingAnimationSpeed, self:getAnimationTime(spec.unloadingAnimation), true )\nend\n\n"})}),"\n",(0,o.jsx)(e.h3,{id:"stoptipping",children:"stopTipping"}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Description"})}),"\n",(0,o.jsxs)(e.blockquote,{children:["\n",(0,o.jsx)(e.p,{children:"Called on stop tipping"}),"\n"]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Definition"})}),"\n",(0,o.jsxs)(e.blockquote,{children:["\n",(0,o.jsx)(e.p,{children:"stopTipping()"}),"\n"]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Code"})}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-lua",children:"function HookLiftTrailer:stopTipping()\n    local spec = self.spec_hookLiftTrailer\n    self:playAnimation(spec.unloadingAnimation, spec.unloadingAnimationReverseSpeed, self:getAnimationTime(spec.unloadingAnimation), true )\nend\n\n"})}),"\n",(0,o.jsx)(e.h3,{id:"updateadditionalhookliftcontainerjoint",children:"updateAdditionalHookLiftContainerJoint"}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Description"})}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Definition"})}),"\n",(0,o.jsxs)(e.blockquote,{children:["\n",(0,o.jsx)(e.p,{children:"updateAdditionalHookLiftContainerJoint()"}),"\n"]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Code"})}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-lua",children:'function HookLiftTrailer:updateAdditionalHookLiftContainerJoint()\n    local spec = self.spec_hookLiftTrailer\n    if spec.additionalJointNode = = nil then\n        return\n    end\n\n    local attachedContainer = spec.attachedContainer\n    if spec.additionalJointState and attachedContainer ~ = nil and self.isAddedToPhysics and attachedContainer.object.isAddedToPhysics then\n        local jointDesc = self:getAttacherJointByJointDescIndex(attachedContainer.jointDescIndex)\n        local inputAttacherJoint = attachedContainer.object:getActiveInputAttacherJoint()\n\n        local ox, oy, oz\n        if spec.additionalJointOffset ~ = nil then\n            ox, oy, oz = spec.additionalJointOffset[ 1 ], spec.additionalJointOffset[ 2 ], spec.additionalJointOffset[ 3 ]\n        else\n                ox, oy, oz = localToLocal(spec.additionalJointNode, jointDesc.jointTransform, 0 , 0 , 0 )\n            end\n\n            local jointNodeContainer = createTransformGroup( "hookLiftJointContainer" )\n            link(inputAttacherJoint.node, jointNodeContainer)\n            setTranslation(jointNodeContainer, ox, oy, oz)\n            setRotation(jointNodeContainer, 0 , 0 , 0 )\n\n            local constr = JointConstructor.new()\n            constr:setActors(inputAttacherJoint.rootNode, jointDesc.rootNode)\n\n            constr:setJointTransforms(jointNodeContainer, spec.additionalJointNode)\n\n            local animTime = self:getAnimationTime(spec.refAnimation)\n            local minRx, minRy, minRz, maxRx, maxRy, maxRz, minTx, minTy, minTz, maxTx, maxTy, maxTz = spec.additionalJointLimits:get(animTime)\n\n            constr:setRotationLimit( 0 , minRx, maxRx)\n            constr:setRotationLimit( 1 , minRy, maxRy)\n            constr:setRotationLimit( 2 , minRz, maxRz)\n\n            constr:setTranslationLimit( 0 , true , minTx, maxTx)\n            constr:setTranslationLimit( 1 , true , minTy, maxTy)\n            constr:setTranslationLimit( 2 , true , minTz, maxTz)\n\n            constr:setEnableCollision( not spec.additionalJointDisableCollision)\n\n            attachedContainer.additionalJointIndex = constr:finalize()\n            attachedContainer.jointNodeContainer = jointNodeContainer\n        elseif attachedContainer ~ = nil then\n                if attachedContainer.additionalJointIndex ~ = nil then\n                    removeJoint(spec.attachedContainer.additionalJointIndex)\n                    attachedContainer.additionalJointIndex = nil\n                end\n\n                if attachedContainer.jointNodeContainer ~ = nil then\n                    delete(spec.attachedContainer.jointNodeContainer)\n                    attachedContainer.jointNodeContainer = nil\n                end\n            end\n        end\n\n'})}),"\n",(0,o.jsx)(e.h3,{id:"updatehookliftcontainerlockstate",children:"updateHookLiftContainerLockState"}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Description"})}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Definition"})}),"\n",(0,o.jsxs)(e.blockquote,{children:["\n",(0,o.jsx)(e.p,{children:"updateHookLiftContainerLockState()"}),"\n"]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Code"})}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-lua",children:"function HookLiftTrailer:updateHookLiftContainerLockState()\n    local spec = self.spec_hookLiftTrailer\n\n    local animTime = self:getAnimationTime(spec.refAnimation)\n    local state = animTime < 0.001 and spec.attachedContainer ~ = nil\n    if state ~ = spec.containerLockState then\n        spec.containerLockState = state\n        ObjectChangeUtil.setObjectChanges(spec.containerLockChangeObjects, state, self , self.setMovingToolDirty)\n\n        if spec.attachedContainer ~ = nil then\n            spec.attachedContainer.object:onHookLiftContainerLockChanged(state)\n        end\n    end\n\n    if self.isServer then\n        local additionalJointState = animTime < spec.additionalJointLockTime and spec.attachedContainer ~ = nil\n        if additionalJointState ~ = spec.additionalJointState then\n            spec.additionalJointState = additionalJointState\n\n            self:updateAdditionalHookLiftContainerJoint()\n        end\n    end\nend\n\n"})})]})}function h(n={}){const{wrapper:e}={...(0,l.R)(),...n.components};return e?(0,o.jsx)(e,{...n,children:(0,o.jsx)(d,{...n})}):d(n)}},28453(n,e,i){i.d(e,{R:()=>s,x:()=>a});var t=i(96540);const o={},l=t.createContext(o);function s(n){const e=t.useContext(l);return t.useMemo(function(){return"function"==typeof n?n(e):{...e,...n}},[e,n])}function a(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(o):n.components||o:s(n.components),t.createElement(l.Provider,{value:e},n.children)}}}]);