"use strict";(globalThis.webpackChunkfs25_community_luadoc=globalThis.webpackChunkfs25_community_luadoc||[]).push([[7236],{28453(n,e,t){t.d(e,{R:()=>l,x:()=>s});var i=t(96540);const o={},r=i.createContext(o);function l(n){const e=i.useContext(r);return i.useMemo(function(){return"function"==typeof n?n(e):{...e,...n}},[e,n])}function s(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(o):n.components||o:l(n.components),i.createElement(r.Provider,{value:e},n.children)}},78186(n,e,t){t.r(e),t.d(e,{assets:()=>d,contentTitle:()=>s,default:()=>h,frontMatter:()=>l,metadata:()=>i,toc:()=>a});const i=JSON.parse('{"id":"script/Handtools/HandToolHands","title":"HandToolHands","description":"HandToolHands","source":"@site/../docs/script/Handtools/HandToolHands.md","sourceDirName":"script/Handtools","slug":"/script/Handtools/HandToolHands","permalink":"/FS25-Community-LUADOC/script/Handtools/HandToolHands","draft":false,"unlisted":false,"tags":[],"version":"current","lastUpdatedAt":1767161192000,"frontMatter":{},"sidebar":"docsSidebar","previous":{"title":"HandToolHPWLance","permalink":"/FS25-Community-LUADOC/script/Handtools/HandToolHPWLance"},"next":{"title":"HandToolHolder","permalink":"/FS25-Community-LUADOC/script/Handtools/HandToolHolder"}}');var o=t(74848),r=t(28453);const l={},s=void 0,d={},a=[{value:"HandToolHands",id:"handtoolhands",level:2},{value:"calculateItemMass",id:"calculateitemmass",level:3},{value:"consoleCommandToggleSuperStrength",id:"consolecommandtogglesuperstrength",level:3},{value:"createItemJoint",id:"createitemjoint",level:3},{value:"dropHeldItem",id:"drophelditem",level:3},{value:"findFootballCallback",id:"findfootballcallback",level:3},{value:"getCanBeDropped",id:"getcanbedropped",level:3},{value:"getCanPickUpNode",id:"getcanpickupnode",level:3},{value:"getHasJoint",id:"gethasjoint",level:3},{value:"getIsAwaitingJointCreation",id:"getisawaitingjointcreation",level:3},{value:"getIsHoldingItem",id:"getisholdingitem",level:3},{value:"getIsThrowingItem",id:"getisthrowingitem",level:3},{value:"getKinematicNode",id:"getkinematicnode",level:3},{value:"levelHeldItem",id:"levelhelditem",level:3},{value:"onCarryingPlayerChanged",id:"oncarryingplayerchanged",level:3},{value:"onDebugDraw",id:"ondebugdraw",level:3},{value:"onDelete",id:"ondelete",level:3},{value:"onDraw",id:"ondraw",level:3},{value:"onHeldEnd",id:"onheldend",level:3},{value:"onHeldItemJointBroken",id:"onhelditemjointbroken",level:3},{value:"onHeldStart",id:"onheldstart",level:3},{value:"onKinematicHelperLoaded",id:"onkinematichelperloaded",level:3},{value:"onLevelAction",id:"onlevelaction",level:3},{value:"onLoad",id:"onload",level:3},{value:"onPickUpAction",id:"onpickupaction",level:3},{value:"onPitchAction",id:"onpitchaction",level:3},{value:"onReadUpdateStream",id:"onreadupdatestream",level:3},{value:"onRegisterActionEvents",id:"onregisteractionevents",level:3},{value:"onThrowAction",id:"onthrowaction",level:3},{value:"onUpdate",id:"onupdate",level:3},{value:"onWriteUpdateStream",id:"onwriteupdatestream",level:3},{value:"onYawAction",id:"onyawaction",level:3},{value:"orientRotationNodeToItem",id:"orientrotationnodetoitem",level:3},{value:"pickupFailed",id:"pickupfailed",level:3},{value:"pickUpTarget",id:"pickuptarget",level:3},{value:"prerequisitesPresent",id:"prerequisitespresent",level:3},{value:"registerEventListeners",id:"registereventlisteners",level:3},{value:"registerFunctions",id:"registerfunctions",level:3},{value:"registerOverwrittenFunctions",id:"registeroverwrittenfunctions",level:3},{value:"registerXMLPaths",id:"registerxmlpaths",level:3},{value:"rotateHeldItem",id:"rotatehelditem",level:3},{value:"shootBall",id:"shootball",level:3},{value:"throwHeldItemWithForceScalar",id:"throwhelditemwithforcescalar",level:3},{value:"updateKinematicNode",id:"updatekinematicnode",level:3}];function c(n){const e={a:"a",blockquote:"blockquote",code:"code",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,r.R)(),...n.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(e.h2,{id:"handtoolhands",children:"HandToolHands"}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Description"})}),"\n",(0,o.jsxs)(e.blockquote,{children:["\n",(0,o.jsx)(e.p,{children:'The hand tool specialisation for "no tool", which is still technically a tool that cannot be dropped or stored.'}),"\n"]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Functions"})}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsx)(e.li,{children:(0,o.jsx)(e.a,{href:"#calculateitemmass",children:"calculateItemMass"})}),"\n",(0,o.jsx)(e.li,{children:(0,o.jsx)(e.a,{href:"#consolecommandtogglesuperstrength",children:"consoleCommandToggleSuperStrength"})}),"\n",(0,o.jsx)(e.li,{children:(0,o.jsx)(e.a,{href:"#createitemjoint",children:"createItemJoint"})}),"\n",(0,o.jsx)(e.li,{children:(0,o.jsx)(e.a,{href:"#drophelditem",children:"dropHeldItem"})}),"\n",(0,o.jsx)(e.li,{children:(0,o.jsx)(e.a,{href:"#findfootballcallback",children:"findFootballCallback"})}),"\n",(0,o.jsx)(e.li,{children:(0,o.jsx)(e.a,{href:"#getcanbedropped",children:"getCanBeDropped"})}),"\n",(0,o.jsx)(e.li,{children:(0,o.jsx)(e.a,{href:"#getcanpickupnode",children:"getCanPickUpNode"})}),"\n",(0,o.jsx)(e.li,{children:(0,o.jsx)(e.a,{href:"#gethasjoint",children:"getHasJoint"})}),"\n",(0,o.jsx)(e.li,{children:(0,o.jsx)(e.a,{href:"#getisawaitingjointcreation",children:"getIsAwaitingJointCreation"})}),"\n",(0,o.jsx)(e.li,{children:(0,o.jsx)(e.a,{href:"#getisholdingitem",children:"getIsHoldingItem"})}),"\n",(0,o.jsx)(e.li,{children:(0,o.jsx)(e.a,{href:"#getisthrowingitem",children:"getIsThrowingItem"})}),"\n",(0,o.jsx)(e.li,{children:(0,o.jsx)(e.a,{href:"#getkinematicnode",children:"getKinematicNode"})}),"\n",(0,o.jsx)(e.li,{children:(0,o.jsx)(e.a,{href:"#levelhelditem",children:"levelHeldItem"})}),"\n",(0,o.jsx)(e.li,{children:(0,o.jsx)(e.a,{href:"#oncarryingplayerchanged",children:"onCarryingPlayerChanged"})}),"\n",(0,o.jsx)(e.li,{children:(0,o.jsx)(e.a,{href:"#ondebugdraw",children:"onDebugDraw"})}),"\n",(0,o.jsx)(e.li,{children:(0,o.jsx)(e.a,{href:"#ondelete",children:"onDelete"})}),"\n",(0,o.jsx)(e.li,{children:(0,o.jsx)(e.a,{href:"#ondraw",children:"onDraw"})}),"\n",(0,o.jsx)(e.li,{children:(0,o.jsx)(e.a,{href:"#onheldend",children:"onHeldEnd"})}),"\n",(0,o.jsx)(e.li,{children:(0,o.jsx)(e.a,{href:"#onhelditemjointbroken",children:"onHeldItemJointBroken"})}),"\n",(0,o.jsx)(e.li,{children:(0,o.jsx)(e.a,{href:"#onheldstart",children:"onHeldStart"})}),"\n",(0,o.jsx)(e.li,{children:(0,o.jsx)(e.a,{href:"#onkinematichelperloaded",children:"onKinematicHelperLoaded"})}),"\n",(0,o.jsx)(e.li,{children:(0,o.jsx)(e.a,{href:"#onlevelaction",children:"onLevelAction"})}),"\n",(0,o.jsx)(e.li,{children:(0,o.jsx)(e.a,{href:"#onload",children:"onLoad"})}),"\n",(0,o.jsx)(e.li,{children:(0,o.jsx)(e.a,{href:"#onpickupaction",children:"onPickUpAction"})}),"\n",(0,o.jsx)(e.li,{children:(0,o.jsx)(e.a,{href:"#onpitchaction",children:"onPitchAction"})}),"\n",(0,o.jsx)(e.li,{children:(0,o.jsx)(e.a,{href:"#onreadupdatestream",children:"onReadUpdateStream"})}),"\n",(0,o.jsx)(e.li,{children:(0,o.jsx)(e.a,{href:"#onregisteractionevents",children:"onRegisterActionEvents"})}),"\n",(0,o.jsx)(e.li,{children:(0,o.jsx)(e.a,{href:"#onthrowaction",children:"onThrowAction"})}),"\n",(0,o.jsx)(e.li,{children:(0,o.jsx)(e.a,{href:"#onupdate",children:"onUpdate"})}),"\n",(0,o.jsx)(e.li,{children:(0,o.jsx)(e.a,{href:"#onwriteupdatestream",children:"onWriteUpdateStream"})}),"\n",(0,o.jsx)(e.li,{children:(0,o.jsx)(e.a,{href:"#onyawaction",children:"onYawAction"})}),"\n",(0,o.jsx)(e.li,{children:(0,o.jsx)(e.a,{href:"#orientrotationnodetoitem",children:"orientRotationNodeToItem"})}),"\n",(0,o.jsx)(e.li,{children:(0,o.jsx)(e.a,{href:"#pickupfailed",children:"pickupFailed"})}),"\n",(0,o.jsx)(e.li,{children:(0,o.jsx)(e.a,{href:"#pickuptarget",children:"pickUpTarget"})}),"\n",(0,o.jsx)(e.li,{children:(0,o.jsx)(e.a,{href:"#prerequisitespresent",children:"prerequisitesPresent"})}),"\n",(0,o.jsx)(e.li,{children:(0,o.jsx)(e.a,{href:"#registereventlisteners",children:"registerEventListeners"})}),"\n",(0,o.jsx)(e.li,{children:(0,o.jsx)(e.a,{href:"#registerfunctions",children:"registerFunctions"})}),"\n",(0,o.jsx)(e.li,{children:(0,o.jsx)(e.a,{href:"#registeroverwrittenfunctions",children:"registerOverwrittenFunctions"})}),"\n",(0,o.jsx)(e.li,{children:(0,o.jsx)(e.a,{href:"#registerxmlpaths",children:"registerXMLPaths"})}),"\n",(0,o.jsx)(e.li,{children:(0,o.jsx)(e.a,{href:"#rotatehelditem",children:"rotateHeldItem"})}),"\n",(0,o.jsx)(e.li,{children:(0,o.jsx)(e.a,{href:"#shootball",children:"shootBall"})}),"\n",(0,o.jsx)(e.li,{children:(0,o.jsx)(e.a,{href:"#throwhelditemwithforcescalar",children:"throwHeldItemWithForceScalar"})}),"\n",(0,o.jsx)(e.li,{children:(0,o.jsx)(e.a,{href:"#updatekinematicnode",children:"updateKinematicNode"})}),"\n"]}),"\n",(0,o.jsx)(e.h3,{id:"calculateitemmass",children:"calculateItemMass"}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Description"})}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Definition"})}),"\n",(0,o.jsxs)(e.blockquote,{children:["\n",(0,o.jsx)(e.p,{children:"calculateItemMass()"}),"\n"]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,o.jsx)(e.table,{children:(0,o.jsx)(e.thead,{children:(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.th,{children:"any"}),(0,o.jsx)(e.th,{children:"itemNode"})]})})}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Code"})}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-lua",children:"function HandToolHands.calculateItemMass(itemNode)\n\n    -- Ensure the given node exists.\n    if itemNode = = nil or not entityExists(itemNode) then\n        return nil\n    end\n\n    -- If the node has an object associated with it, check to see if it can calculate its own mass.\n        local mission = g_currentMission\n        local object = mission:getNodeObject(itemNode)\n        local mass\n        if object ~ = nil and object.getTotalMass ~ = nil then\n            mass = object:getTotalMass()\n        end\n\n        -- Return the object's mass; or the node's mass if it's nil.\n            return mass or getMass(itemNode)\n        end\n\n"})}),"\n",(0,o.jsx)(e.h3,{id:"consolecommandtogglesuperstrength",children:"consoleCommandToggleSuperStrength"}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Description"})}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Definition"})}),"\n",(0,o.jsxs)(e.blockquote,{children:["\n",(0,o.jsx)(e.p,{children:"consoleCommandToggleSuperStrength()"}),"\n"]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Code"})}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-lua",children:'function HandToolHands:consoleCommandToggleSuperStrength()\n    local spec = self.spec_hands\n    spec.hasSuperStrength = not spec.hasSuperStrength\n    local text = "Disabled super strength"\n\n    if spec.hasSuperStrength then\n        spec.currentMaximumMass = HandToolHands.SUPER_STRENGTH_PICKUP_MASS\n        spec.pickupDistance = 10\n        text = "Enabled super strength"\n    else\n            spec.currentMaximumMass = HandToolHands.MAXIMUM_PICKUP_MASS\n            spec.pickupDistance = HandToolHands.PICKUP_DISTANCE\n        end\n\n        local carryingPlayer = self:getCarryingPlayer()\n        if carryingPlayer = = nil or not carryingPlayer.isOwner then\n            return text\n        end\n\n        -- Remove the target type from the player\'s targeter.\n        carryingPlayer.targeter:removeTargetType( HandToolHands )\n        carryingPlayer.targeter:addTargetType( HandToolHands , HandToolHands.TARGET_MASK, 0.5 , spec.pickupDistance)\n\n        return text\n    end\n\n'})}),"\n",(0,o.jsx)(e.h3,{id:"createitemjoint",children:"createItemJoint"}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Description"})}),"\n",(0,o.jsxs)(e.blockquote,{children:["\n",(0,o.jsx)(e.p,{children:"Creates a joint between the currently held item and the kinematic node."}),"\n"]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Definition"})}),"\n",(0,o.jsxs)(e.blockquote,{children:["\n",(0,o.jsx)(e.p,{children:"createItemJoint()"}),"\n"]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Code"})}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-lua",children:'function HandToolHands:createItemJoint()\n\n    -- Reset the phyics index.\n    local spec = self.spec_hands\n    spec.pickupPhysicsIndex = nil\n\n    if not self.isServer then\n        --#debug Player.debugLog(self:getCarryingPlayer(), Player.DEBUG_DISPLAY_FLAG.HANDTOOLS, "createItemJoint can only be used on the server!")\n        return\n    end\n    --#debug Player.debugLog(self:getCarryingPlayer(), Player.DEBUG_DISPLAY_FLAG.HANDTOOLS, "Creating item joint")\n\n    -- Ensure an item is being held, and a joint creation is being awaited.\n    if not self:getIsHoldingItem() then\n        Logging.error( "Cannot create joint for held item when no item is being held!" )\n            return\n        end\n\n        -- Create the joint between the kinematic node and target object.\n        local joint = JointConstructor.new()\n        joint:setActors(spec.kinematicNode, spec.heldItemNode)\n\n        -- Get the centre of mass of the target, and set the position of the joint to it.\n        local targetCentreX, targetCentreY, targetCentreZ = getCenterOfMass(spec.heldItemNode)\n        local targetWorldX, targetWorldY, targetWorldZ = localToWorld(spec.heldItemNode, targetCentreX, targetCentreY, targetCentreZ)\n        joint:setJointWorldPositions(targetWorldX, targetWorldY, targetWorldZ, targetWorldX, targetWorldY, targetWorldZ)\n\n        -- Set the limits.\n        joint:setTranslationLimit( 0 , true , 0 , 0 )\n        joint:setTranslationLimit( 1 , true , 0 , 0 )\n        joint:setTranslationLimit( 2 , true , 0 , 0 )\n        joint:setRotationLimit( 0 , 0 , 0 )\n        joint:setRotationLimit( 1 , 0 , 0 )\n        joint:setRotationLimit( 2 , 0 , 0 )\n\n        -- Set the axes and normals.\n        local targetLeftX, targetLeftY, targetLeftZ = localDirectionToWorld(spec.heldItemNode, 1 , 0 , 0 )\n        joint:setJointWorldAxes(targetLeftX, targetLeftY, targetLeftZ, targetLeftX, targetLeftY, targetLeftZ)\n\n        local targetUpX, targetUpY, targetUpZ = localDirectionToWorld(spec.heldItemNode, 0 , 1 , 0 )\n        joint:setJointWorldNormals(targetUpX, targetUpY, targetUpZ, targetUpX, targetUpY, targetUpZ)\n\n        -- Disable collisions between the kinematic node and the item.\n        joint:setEnableCollision( false )\n\n        -- Position and orient the rotation node so that it matches the target item.\n        self:orientRotationNodeToItem(spec.heldItemNode)\n\n        -- set spring/damper ?!\n        local dampingRatio = 1.0\n        local mass = HandToolHands.calculateItemMass(spec.heldItemNode)\n\n        local rotationLimitSpring = { }\n        local rotationLimitDamper = { }\n        for i = 1 , 3 do\n            rotationLimitSpring[i] = mass * 60\n            rotationLimitDamper[i] = dampingRatio * 2 * math.sqrt(mass * rotationLimitSpring[i])\n        end\n        joint:setRotationLimitSpring(rotationLimitSpring[ 1 ], rotationLimitDamper[ 1 ], rotationLimitSpring[ 2 ], rotationLimitDamper[ 2 ], rotationLimitSpring[ 3 ], rotationLimitDamper[ 3 ])\n\n        local translationLimitSpring = { }\n        local translationLimitDamper = { }\n        for i = 1 , 3 do\n            translationLimitSpring[i] = mass * 60\n            translationLimitDamper[i] = dampingRatio * 2 * math.sqrt(mass * translationLimitSpring[i])\n        end\n        joint:setTranslationLimitSpring(translationLimitSpring[ 1 ], translationLimitDamper[ 1 ], translationLimitSpring[ 2 ], translationLimitDamper[ 2 ], translationLimitSpring[ 3 ], translationLimitDamper[ 3 ])\n\n        if not spec.hasSuperStrength then\n            local forceAcceleration = 4\n            local forceLimit = forceAcceleration * mass * 40.0\n            joint:setBreakable(forceLimit, forceLimit)\n        end\n\n        -- Create the joint.\n        spec.heldItemJointId = joint:finalize()\n\n        -- Listen for the joint being broken due to excess force.\n            addJointBreakReport(spec.heldItemJointId, "onHeldItemJointBroken" , self )\n\n            --#debug Player.debugLog(self:getCarryingPlayer(), Player.DEBUG_DISPLAY_FLAG.HANDTOOLS, "Attached to %s", getName(spec.heldItemNode))\n        end\n\n'})}),"\n",(0,o.jsx)(e.h3,{id:"drophelditem",children:"dropHeldItem"}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Description"})}),"\n",(0,o.jsxs)(e.blockquote,{children:["\n",(0,o.jsx)(e.p,{children:"Drops the currently held item."}),"\n"]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Definition"})}),"\n",(0,o.jsxs)(e.blockquote,{children:["\n",(0,o.jsx)(e.p,{children:"dropHeldItem(boolean? noEventSend)"}),"\n"]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,o.jsx)(e.table,{children:(0,o.jsx)(e.thead,{children:(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.th,{children:"boolean?"}),(0,o.jsx)(e.th,{children:"noEventSend"})]})})}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Code"})}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-lua",children:"function HandToolHands:dropHeldItem(noEventSend)\n\n    if not self:getIsHoldingItem() then\n        return\n    end\n\n    HandsThrowObjectEvent.sendEvent( self , 0 , 0 , 0 , 0 , noEventSend)\n    self:onHeldItemJointBroken( nil , nil , true )\nend\n\n"})}),"\n",(0,o.jsx)(e.h3,{id:"findfootballcallback",children:"findFootballCallback"}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Description"})}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Definition"})}),"\n",(0,o.jsxs)(e.blockquote,{children:["\n",(0,o.jsx)(e.p,{children:"findFootballCallback()"}),"\n"]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,o.jsx)(e.table,{children:(0,o.jsx)(e.thead,{children:(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.th,{children:"any"}),(0,o.jsx)(e.th,{children:"transformId"})]})})}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Code"})}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-lua",children:"function HandToolHands:findFootballCallback(transformId)\n    if transformId ~ = 0 and getHasClassId(transformId, ClassIds.SHAPE) then\n        local mission = g_currentMission\n        local object = mission:getNodeObject(transformId)\n        if object ~ = nil and object:isa( Football ) then\n            local spec = self.spec_hands\n            spec.football = object\n\n            return false\n        end\n    end\n\n    return true\nend\n\n"})}),"\n",(0,o.jsx)(e.h3,{id:"getcanbedropped",children:"getCanBeDropped"}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Description"})}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Definition"})}),"\n",(0,o.jsxs)(e.blockquote,{children:["\n",(0,o.jsx)(e.p,{children:"getCanBeDropped()"}),"\n"]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,o.jsx)(e.table,{children:(0,o.jsx)(e.thead,{children:(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.th,{children:"any"}),(0,o.jsx)(e.th,{children:"superFunc"})]})})}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Code"})}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-lua",children:"function HandToolHands:getCanBeDropped(superFunc)\n    return false\nend\n\n"})}),"\n",(0,o.jsx)(e.h3,{id:"getcanpickupnode",children:"getCanPickUpNode"}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Description"})}),"\n",(0,o.jsxs)(e.blockquote,{children:["\n",(0,o.jsx)(e.p,{children:"Finds if these hands can pick up the given target object."}),"\n"]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Definition"})}),"\n",(0,o.jsxs)(e.blockquote,{children:["\n",(0,o.jsx)(e.p,{children:"getCanPickUpNode(entityId node)"}),"\n"]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n",(0,o.jsx)(e.table,{children:(0,o.jsx)(e.thead,{children:(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.th,{children:"entityId"}),(0,o.jsx)(e.th,{children:"node"}),(0,o.jsx)(e.th,{children:"The target from the player's targeter."})]})})}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Return Values"})}),"\n\n\n\n\n\n\n\n\n",(0,o.jsx)(e.table,{children:(0,o.jsx)(e.thead,{children:(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.th,{children:"entityId"}),(0,o.jsx)(e.th,{children:"canPickUp"}),(0,o.jsx)(e.th,{children:"True if the hands can pick up the given target; otherwise false."})]})})}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Code"})}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-lua",children:"function HandToolHands:getCanPickUpNode(node)\n\n    -- If there is no target, return false.\n    if node = = nil or node = = 0 or not entityExists(node) then\n        return false\n    end\n\n    if self.isServer and getRigidBodyType(node) ~ = RigidBodyType.DYNAMIC then -- all dynamic objects are kinematic on clients, so only do this check on the server\n        return false\n    end\n\n    -- If the hands are holding something, they cannot pick something else up, so return false.\n        if self:getIsHoldingItem() then\n            return false\n        end\n\n        -- If the node has no mass, or the object is too heavy for the player, return false.\n            local spec = self.spec_hands\n            local mass = HandToolHands.calculateItemMass(node)\n            if self.isServer and(mass = = nil or mass > spec.currentMaximumMass) then\n                return false\n            end\n\n            -- If the node has an object associated with it, check to ensure the object is valid.\n            local mission = g_currentMission\n            local object = mission:getNodeObject(node)\n            if object ~ = nil then\n                -- If the object is a mount object, return false.\n                if object.dynamicMountObject ~ = nil or object.tensionMountObject ~ = nil then\n                    return false\n                end\n\n                -- If the object specifically says that the player cannot pick it up, return false.\n                if not spec.hasSuperStrength then\n                    if object.getCanBePickedUp ~ = nil and not object:getCanBePickedUp( self:getCarryingPlayer()) then\n                        return false\n                    end\n                end\n            end\n\n            -- Return true, as all previous checks have passed.\n            return true\n        end\n\n"})}),"\n",(0,o.jsx)(e.h3,{id:"gethasjoint",children:"getHasJoint"}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Description"})}),"\n",(0,o.jsxs)(e.blockquote,{children:["\n",(0,o.jsx)(e.p,{children:"Finds if the hands have a joint between the kinematic node and the held item."}),"\n"]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Definition"})}),"\n",(0,o.jsxs)(e.blockquote,{children:["\n",(0,o.jsx)(e.p,{children:"getHasJoint()"}),"\n"]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Return Values"})}),"\n\n\n\n\n\n\n\n\n",(0,o.jsx)(e.table,{children:(0,o.jsx)(e.thead,{children:(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.th,{children:"entityId"}),(0,o.jsx)(e.th,{children:"hasJoint"}),(0,o.jsx)(e.th,{children:"True if there is a joint between the kinematic node and the held item; otherwise false."})]})})}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Code"})}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-lua",children:"function HandToolHands:getHasJoint()\n    return self.spec_hands.heldItemJointId ~ = nil\nend\n\n"})}),"\n",(0,o.jsx)(e.h3,{id:"getisawaitingjointcreation",children:"getIsAwaitingJointCreation"}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Description"})}),"\n",(0,o.jsxs)(e.blockquote,{children:["\n",(0,o.jsx)(e.p,{children:"Finds if an item has been picked up, but not yet attached to the kinematic node."}),"\n"]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Definition"})}),"\n",(0,o.jsxs)(e.blockquote,{children:["\n",(0,o.jsx)(e.p,{children:"getIsAwaitingJointCreation()"}),"\n"]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Return Values"})}),"\n\n\n\n\n\n\n\n\n",(0,o.jsx)(e.table,{children:(0,o.jsx)(e.thead,{children:(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.th,{children:"entityId"}),(0,o.jsx)(e.th,{children:"isAwaitingJointCreation"}),(0,o.jsx)(e.th,{children:"True if the hands are awaiting a physics update before creating the joint."})]})})}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Code"})}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-lua",children:"function HandToolHands:getIsAwaitingJointCreation()\n    return self.spec_hands.pickupPhysicsIndex ~ = nil\nend\n\n"})}),"\n",(0,o.jsx)(e.h3,{id:"getisholdingitem",children:"getIsHoldingItem"}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Description"})}),"\n",(0,o.jsxs)(e.blockquote,{children:["\n",(0,o.jsx)(e.p,{children:"Finds if the hands are currently holding something. Note that this does not mean there is a joint."}),"\n"]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Definition"})}),"\n",(0,o.jsxs)(e.blockquote,{children:["\n",(0,o.jsx)(e.p,{children:"getIsHoldingItem()"}),"\n"]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Return Values"})}),"\n\n\n\n\n\n\n\n\n",(0,o.jsx)(e.table,{children:(0,o.jsx)(e.thead,{children:(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.th,{children:"entityId"}),(0,o.jsx)(e.th,{children:"isHoldingItem"}),(0,o.jsx)(e.th,{children:"True if the hands are holding something; otherwise false."})]})})}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Code"})}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-lua",children:"function HandToolHands:getIsHoldingItem()\n    return self.spec_hands.heldItemNode ~ = nil\nend\n\n"})}),"\n",(0,o.jsx)(e.h3,{id:"getisthrowingitem",children:"getIsThrowingItem"}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Description"})}),"\n",(0,o.jsxs)(e.blockquote,{children:["\n",(0,o.jsx)(e.p,{children:"Finds if the player is currently charging up a throw."}),"\n"]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Definition"})}),"\n",(0,o.jsxs)(e.blockquote,{children:["\n",(0,o.jsx)(e.p,{children:"getIsThrowingItem()"}),"\n"]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Return Values"})}),"\n\n\n\n\n\n\n\n\n",(0,o.jsx)(e.table,{children:(0,o.jsx)(e.thead,{children:(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.th,{children:"entityId"}),(0,o.jsx)(e.th,{children:"isThrowing"}),(0,o.jsx)(e.th,{children:"True if the player is charging a throw; otherwise false."})]})})}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Code"})}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-lua",children:"function HandToolHands:getIsThrowingItem()\n    return self.spec_hands.currentThrowTime ~ = nil\nend\n\n"})}),"\n",(0,o.jsx)(e.h3,{id:"getkinematicnode",children:"getKinematicNode"}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Description"})}),"\n",(0,o.jsxs)(e.blockquote,{children:["\n",(0,o.jsx)(e.p,{children:"Gets the kinematic helper of the hands. This will be nil until it is loaded."}),"\n"]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Definition"})}),"\n",(0,o.jsxs)(e.blockquote,{children:["\n",(0,o.jsx)(e.p,{children:"getKinematicNode()"}),"\n"]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Return Values"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,o.jsxs)(e.table,{children:[(0,o.jsx)(e.thead,{children:(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.th,{children:"entityId"}),(0,o.jsx)(e.th,{children:"kinematicNode"}),(0,o.jsx)(e.th,{children:"The kinematic node of the hands, or nil if it is not yet loaded."})]})}),(0,o.jsx)(e.tbody,{children:(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.td,{children:"entityId"}),(0,o.jsx)(e.td,{children:"kinematicRotationNode"}),(0,o.jsx)(e.td,{children:"The rotation node of the hands, or nil if it is not yet loaded."})]})})]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Code"})}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-lua",children:"function HandToolHands:getKinematicNode()\n    return self.spec_hands.kinematicNode, self.spec_hands.kinematicRotationNode\nend\n\n"})}),"\n",(0,o.jsx)(e.h3,{id:"levelhelditem",children:"levelHeldItem"}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Description"})}),"\n",(0,o.jsxs)(e.blockquote,{children:["\n",(0,o.jsx)(e.p,{children:"Levels the held item so that it is flat to the floor, preserving its yaw. Should only be uesd for square bales and\npallets."}),"\n"]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Definition"})}),"\n",(0,o.jsxs)(e.blockquote,{children:["\n",(0,o.jsx)(e.p,{children:"levelHeldItem()"}),"\n"]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Code"})}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-lua",children:"function HandToolHands:levelHeldItem()\n\n    -- If no item is being held, do nothing.\n        if not self:getIsHoldingItem() then\n            return\n        end\n\n        -- Get the direction of the held item relative to the kinematic node.\n        local spec = self.spec_hands\n        local kinematicNode, rotationNode = self:getKinematicNode()\n        local itemDirectionX, _, itemDirectionZ = localDirectionToLocal(spec.heldItemNode, kinematicNode, 0 , 0 , 1 )\n\n        -- Set the local yaw of the rotation node to preserve the held item's yaw.Zero out the pitch and roll.\n        local preservedYaw = MathUtil.getYRotationFromDirection(itemDirectionX, itemDirectionZ)\n        setRotation(rotationNode, 0 , preservedYaw, 0 )\n\n        -- Set the joint frame for the joint, so that it updates.\n            if self.isServer then\n                setJointFrame(spec.heldItemJointId, 0 , rotationNode)\n            end\n        end\n\n"})}),"\n",(0,o.jsx)(e.h3,{id:"oncarryingplayerchanged",children:"onCarryingPlayerChanged"}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Description"})}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Definition"})}),"\n",(0,o.jsxs)(e.blockquote,{children:["\n",(0,o.jsx)(e.p,{children:"onCarryingPlayerChanged()"}),"\n"]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,o.jsxs)(e.table,{children:[(0,o.jsx)(e.thead,{children:(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.th,{children:"any"}),(0,o.jsx)(e.th,{children:"player"})]})}),(0,o.jsx)(e.tbody,{children:(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.td,{children:"any"}),(0,o.jsx)(e.td,{children:"lastPlayer"})]})})]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Code"})}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-lua",children:'function HandToolHands:onCarryingPlayerChanged(player, lastPlayer)\n    -- This function should only ever be called once, as the player\'s hands cannot be put down or picked up.\n        -- Add the super strength command.\n        if player ~ = nil and player.isOwner then\n            addConsoleCommand( "gsPlayerSuperStrengthToggle" , "Toggles the super strength mode for the player" , "consoleCommandToggleSuperStrength" , self )\n            elseif lastPlayer ~ = nil and lastPlayer.isOwner then\n                    removeConsoleCommand( "gsPlayerSuperStrengthToggle" )\n                end\n            end\n\n'})}),"\n",(0,o.jsx)(e.h3,{id:"ondebugdraw",children:"onDebugDraw"}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Description"})}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Definition"})}),"\n",(0,o.jsxs)(e.blockquote,{children:["\n",(0,o.jsx)(e.p,{children:"onDebugDraw()"}),"\n"]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Code"})}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-lua",children:'function HandToolHands:onDebugDraw()\n\n    local kinematicNode, rotationNode = self:getKinematicNode()\n    if kinematicNode ~ = nil then\n        DebugUtil.drawDebugNode(kinematicNode, "kinematic" )\n        DebugUtil.drawDebugNode(rotationNode, "rotation" )\n    end\n\n    if self:getIsHoldingItem() then\n        local heldItemNode = self:getHeldItem()\n        DebugUtil.drawDebugNode(heldItemNode, "heldItem" )\n\n        local heldItemPositionX, heldItemPositionY, heldItemPositionZ = getWorldTranslation(heldItemNode)\n        local kinematicPositionX, kinematicPositionY, kinematicPositionZ = getWorldTranslation(kinematicNode)\n\n        local distance = MathUtil.vector3Length(heldItemPositionX - kinematicPositionX, heldItemPositionY - kinematicPositionY, heldItemPositionZ - kinematicPositionZ)\n\n        DebugLine.renderBetweenNodes(kinematicNode, heldItemNode, Color.PRESETS.WHITE, true , string.format( "%.3fm" , distance), 0.03 , Color.PRESETS.GREEN, Color.PRESETS.RED)\n    end\nend\n\n'})}),"\n",(0,o.jsx)(e.h3,{id:"ondelete",children:"onDelete"}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Description"})}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Definition"})}),"\n",(0,o.jsxs)(e.blockquote,{children:["\n",(0,o.jsx)(e.p,{children:"onDelete()"}),"\n"]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Code"})}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-lua",children:'function HandToolHands:onDelete()\n    local spec = self.spec_hands\n\n    self:dropHeldItem( true )\n\n    -- Release the shared i3d file for the kinematic node.\n        if spec.kinematicSharedLoadRequestId ~ = nil then\n            g_i3DManager:releaseSharedI3DFile(spec.kinematicSharedLoadRequestId)\n            spec.kinematicSharedLoadRequestId = nil\n        end\n\n        if spec.kinematicNode ~ = nil then\n            delete(spec.kinematicNode)\n            spec.kinematicNode = nil\n        end\n\n        local player = self:getCarryingPlayer()\n        if player ~ = nil and player.isOwner then\n            removeConsoleCommand( "gsPlayerSuperStrengthToggle" )\n        end\n\n        if spec.crosshair ~ = nil then\n            spec.crosshair:delete()\n            spec.crosshair = nil\n        end\n\n        if spec.pickUpCrosshair ~ = nil then\n            spec.pickUpCrosshair:delete()\n            spec.pickUpCrosshair = nil\n        end\n\n        if spec.throwCrosshair ~ = nil then\n            spec.throwCrosshair:delete()\n            spec.throwCrosshair = nil\n        end\n    end\n\n'})}),"\n",(0,o.jsx)(e.h3,{id:"ondraw",children:"onDraw"}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Description"})}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Definition"})}),"\n",(0,o.jsxs)(e.blockquote,{children:["\n",(0,o.jsx)(e.p,{children:"onDraw()"}),"\n"]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Code"})}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-lua",children:"function HandToolHands:onDraw()\n    local spec = self.spec_hands\n\n    local carryingPlayer = self:getCarryingPlayer()\n    if carryingPlayer ~ = nil and carryingPlayer.isOwner then\n        if carryingPlayer.camera.isFirstPerson then\n            local player = self:getCarryingPlayer()\n            local target = player.targeter.closestTargetsByKey[ HandToolHands ]\n            local node = target and target.node or nil\n            if self:getIsThrowingItem() then\n                -- Scale the throw crosshair based on how powerful the player's throw is.\n                local throwForceScalar = math.clamp(spec.currentThrowTime / HandToolHands.MAXIMUM_THROW_TIME, 0 , 1 )\n                spec.throwCrosshair:setScale(throwForceScalar, throwForceScalar)\n\n                spec.throwCrosshair:render()\n            elseif spec.heldItemNode ~ = nil or self:getCanPickUpNode(node) then\n                    spec.pickUpCrosshair:render()\n                else\n                        spec.crosshair:render()\n                    end\n                end\n            end\n        end\n\n"})}),"\n",(0,o.jsx)(e.h3,{id:"onheldend",children:"onHeldEnd"}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Description"})}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Definition"})}),"\n",(0,o.jsxs)(e.blockquote,{children:["\n",(0,o.jsx)(e.p,{children:"onHeldEnd()"}),"\n"]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Code"})}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-lua",children:"function HandToolHands:onHeldEnd()\n    local carryingPlayer = self:getCarryingPlayer()\n    if carryingPlayer = = nil or not carryingPlayer.isOwner then\n        return\n    end\n\n    -- Remove the target type from the player's targeter.\n    carryingPlayer.targeter:removeTargetType( HandToolHands )\n\n    -- Drop any held item.\n    self:dropHeldItem()\nend\n\n"})}),"\n",(0,o.jsx)(e.h3,{id:"onhelditemjointbroken",children:"onHeldItemJointBroken"}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Description"})}),"\n",(0,o.jsxs)(e.blockquote,{children:["\n",(0,o.jsx)(e.p,{children:"Fired when the item joint is broken, or from dropHeldItem, and handles removing the joint and state."}),"\n"]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Definition"})}),"\n",(0,o.jsxs)(e.blockquote,{children:["\n",(0,o.jsx)(e.p,{children:"onHeldItemJointBroken(entityId jointIndex, float breakingImpulse, boolean noEventSend)"}),"\n"]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,o.jsxs)(e.table,{children:[(0,o.jsx)(e.thead,{children:(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.th,{children:"entityId"}),(0,o.jsx)(e.th,{children:"jointIndex"}),(0,o.jsx)(e.th,{})]})}),(0,o.jsxs)(e.tbody,{children:[(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.td,{children:"float"}),(0,o.jsx)(e.td,{children:"breakingImpulse"}),(0,o.jsx)(e.td,{})]}),(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.td,{children:"boolean"}),(0,o.jsx)(e.td,{children:"noEventSend"}),(0,o.jsx)(e.td,{children:"If this is true, no network event will be sent."})]})]})]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Code"})}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-lua",children:'function HandToolHands:onHeldItemJointBroken(jointIndex, breakingImpulse, noEventSend)\n\n    local spec = self.spec_hands\n\n    local carryingPlayer = self:getCarryingPlayer()\n    if carryingPlayer ~ = nil then\n\n        --#debug if entityExists(spec.heldItemNode) then\n            --#debug carryingPlayer:debugLog(Player.DEBUG_DISPLAY_FLAG.HANDTOOLS, "Detached from %s", getName(spec.heldItemNode))\n            --#debug end\n\n            if carryingPlayer.isOwner then\n                -- Disable any actions that should only be available while an item is held.\n                    g_inputBinding:setActionEventActive(spec.throwActionEventId, false )\n                    g_inputBinding:setActionEventActive(spec.pitchActionEventId, false )\n                    g_inputBinding:setActionEventActive(spec.yawActionEventId, false )\n                    g_inputBinding:setActionEventActive(spec.levelActionEventId, false )\n\n                    -- Disable the action and set its text to "pick up" again.\n                    g_inputBinding:setActionEventActive(spec.pickUpActionEventId, false )\n                    g_inputBinding:setActionEventText(spec.pickUpActionEventId, g_i18n:getText( "action_pickUpObject" ))\n                end\n            end\n\n            -- Reset the collision mask of the node.\n            if entityExists(spec.heldItemNode) and self:getIsHoldingItem() then\n                -- Enable collision against cct\n                local player = self:getCarryingPlayer()\n                if player ~ = nil and player.capsuleController ~ = nil then\n                    local cctIndex = player.capsuleController.capsuleId\n                    if cctIndex ~ = nil then\n                        setCCTPairCollision(cctIndex, spec.heldItemNode, true )\n                    end\n                end\n            end\n\n            -- Reset the held item state.\n            local itemExists = entityExists(spec.heldItemNode)\n            spec.heldItemNode = nil\n\n            if not self.isServer then\n                return\n            end\n\n            -- The server tells the clients about the broken joint by telling them that they threw the object.\n            HandsThrowObjectEvent.sendEvent( self , 0 , 0 , 0 , 0 , noEventSend)\n\n            -- Remove the joint and unset the id.\n            if self:getHasJoint() then\n                if itemExists then\n                    removeJoint(spec.heldItemJointId)\n                end\n                spec.heldItemJointId = nil\n                -- If there\'s no joint, and one is being awaited, cancel it.\n            elseif self:getIsAwaitingJointCreation() then\n                    spec.pickupPhysicsIndex = nil\n                end\n            end\n\n'})}),"\n",(0,o.jsx)(e.h3,{id:"onheldstart",children:"onHeldStart"}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Description"})}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Definition"})}),"\n",(0,o.jsxs)(e.blockquote,{children:["\n",(0,o.jsx)(e.p,{children:"onHeldStart()"}),"\n"]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Code"})}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-lua",children:"function HandToolHands:onHeldStart()\n    local carryingPlayer = self:getCarryingPlayer()\n    if carryingPlayer = = nil or not carryingPlayer.isOwner then\n        return\n    end\n\n    -- Ensure objects are targeted.\n    local spec = self.spec_hands\n    local targeter = self:getCarryingPlayer().targeter\n    targeter:addTargetType( HandToolHands , HandToolHands.TARGET_MASK, 0.5 , spec.pickupDistance)\nend\n\n"})}),"\n",(0,o.jsx)(e.h3,{id:"onkinematichelperloaded",children:"onKinematicHelperLoaded"}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Description"})}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Definition"})}),"\n",(0,o.jsxs)(e.blockquote,{children:["\n",(0,o.jsx)(e.p,{children:"onKinematicHelperLoaded()"}),"\n"]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,o.jsxs)(e.table,{children:[(0,o.jsx)(e.thead,{children:(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.th,{children:"any"}),(0,o.jsx)(e.th,{children:"kinematicNode"})]})}),(0,o.jsx)(e.tbody,{children:(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.td,{children:"any"}),(0,o.jsx)(e.td,{children:"failedReason"})]})})]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Code"})}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-lua",children:'function HandToolHands:onKinematicHelperLoaded(kinematicNode, failedReason)\n    local spec = self.spec_hands\n    self:finishLoadingTask(spec.kinematicLoadingTask)\n    spec.kinematicLoadingTask = nil\n\n    -- Ensure the node loaded correctly.\n    if kinematicNode = = nil or kinematicNode = = 0 then\n        Logging.error( "Hands could not load kinematic helper i3d!" )\n        return\n    end\n\n    spec.kinematicNode = getChildAt(kinematicNode, 0 )\n    link(getRootNode(), spec.kinematicNode)\n    addToPhysics(spec.kinematicNode)\n\n    -- Create the rotation helper node.\n    spec.kinematicRotationNode = createTransformGroup( "kinematicRotationHelper" )\n    link(spec.kinematicNode, spec.kinematicRotationNode)\n\n    delete(kinematicNode)\nend\n\n'})}),"\n",(0,o.jsx)(e.h3,{id:"onlevelaction",children:"onLevelAction"}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Description"})}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Definition"})}),"\n",(0,o.jsxs)(e.blockquote,{children:["\n",(0,o.jsx)(e.p,{children:"onLevelAction()"}),"\n"]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,o.jsxs)(e.table,{children:[(0,o.jsx)(e.thead,{children:(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.th,{children:"any"}),(0,o.jsx)(e.th,{children:"_"})]})}),(0,o.jsx)(e.tbody,{children:(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.td,{children:"any"}),(0,o.jsx)(e.td,{children:"inputValue"})]})})]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Code"})}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-lua",children:"function HandToolHands:onLevelAction(_, inputValue)\n    self:levelHeldItem()\nend\n\n"})}),"\n",(0,o.jsx)(e.h3,{id:"onload",children:"onLoad"}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Description"})}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Definition"})}),"\n",(0,o.jsxs)(e.blockquote,{children:["\n",(0,o.jsx)(e.p,{children:"onLoad()"}),"\n"]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,o.jsxs)(e.table,{children:[(0,o.jsx)(e.thead,{children:(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.th,{children:"any"}),(0,o.jsx)(e.th,{children:"xmlFile"})]})}),(0,o.jsx)(e.tbody,{children:(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.td,{children:"any"}),(0,o.jsx)(e.td,{children:"baseDirectory"})]})})]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Code"})}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-lua",children:'function HandToolHands:onLoad(xmlFile, baseDirectory)\n\n    local spec = self.spec_hands\n\n    spec.hasSuperStrength = false\n\n    -- The current maximum mass that the player can pick up.\n    spec.currentMaximumMass = HandToolHands.MAXIMUM_PICKUP_MASS\n    spec.pickupDistance = HandToolHands.PICKUP_DISTANCE\n\n    -- The current amount of throw time charged up by the player.Is nil unless the player is charging a throw.\n    spec.currentThrowTime = nil\n\n    -- The action event ids.\n    spec.pickUpActionEventId = nil\n    spec.throwActionEventId = nil\n    spec.pitchActionEventId = nil\n    spec.yawActionEventId = nil\n\n    -- The held item data.\n    spec.heldItemJointId = nil\n    spec.heldItemNode = nil\n\n    -- The distance away from the camera that the object is held.This starts at the max distance, but is calculated whenever the player picks something up.\n    spec.currentHoldDistance = HandToolHands.PICKUP_DISTANCE\n\n    -- The kinematic nodes, used for attaching the item to the hands.\n        spec.kinematicNode = nil\n        spec.kinematicRotationNode = nil\n\n        -- Workaround for the weird input system.Keeps track of the last update loop index where the throw button was held.If it does not match with the current update loop index, the item is thrown.\n            spec.lastThrowUpdateIndex = nil\n\n            -- The physics index of the pickup of an object.The joint is created once this physics frame has been simulated.\n            spec.pickupPhysicsIndex = nil\n\n            spec.dirtyFlag = self:getNextDirtyFlag()\n\n            -- Begin loading the kinematic helper.\n            spec.kinematicLoadingTask = self:createLoadingTask(spec)\n            spec.kinematicSharedLoadRequestId = g_i3DManager:loadSharedI3DFileAsync( "dataS/character/shared/kinematicHelper.i3d" , true , false , HandToolHands.onKinematicHelperLoaded, self , nil )\n\n            spec.lastShootTime = g_ time\n            spec.canShoot = false\n            spec.football = nil\n\n            spec.actionPassText = g_i18n:getText( "action_passFootball" )\n            spec.actionShootText = g_i18n:getText( "action_shootFootball" )\n            spec.pickupText = g_i18n:getText( "action_pickUpObject" )\n            spec.throwText = g_i18n:getText( "input_THROW_OBJECT" )\n\n            if self.isClient then\n                spec.crosshair = self:createCrosshairOverlay( "gui.crosshairDefault" , HandTool.DEFAULT_CROSSHAIR_SIZE_PIXELS * 0.5 )\n                spec.crosshair:setColor( nil , nil , nil , 0.25 )\n                spec.pickUpCrosshair = self:createCrosshairOverlay( "gui.grab" )\n                spec.throwCrosshair = self:createCrosshairOverlay( "gui.crosshairThrow" )\n            end\n        end\n\n'})}),"\n",(0,o.jsx)(e.h3,{id:"onpickupaction",children:"onPickUpAction"}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Description"})}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Definition"})}),"\n",(0,o.jsxs)(e.blockquote,{children:["\n",(0,o.jsx)(e.p,{children:"onPickUpAction()"}),"\n"]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,o.jsxs)(e.table,{children:[(0,o.jsx)(e.thead,{children:(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.th,{children:"any"}),(0,o.jsx)(e.th,{children:"_"})]})}),(0,o.jsx)(e.tbody,{children:(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.td,{children:"any"}),(0,o.jsx)(e.td,{children:"inputValue"})]})})]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Code"})}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-lua",children:"function HandToolHands:onPickUpAction(_, inputValue)\n\n    -- Only allow picking up for the owning player.\n        local player = self:getCarryingPlayer()\n        if not player.isOwner then\n            return\n        end\n\n        local spec = self.spec_hands\n        if spec.football ~ = nil then\n            local camera = g_cameraManager:getActiveCamera()\n            local dirX, _, dirZ = localDirectionToWorld(camera, 0 , 0 , - 1 )\n            dirX, _, dirZ = MathUtil.vector3Normalize(dirX, 0 , dirZ)\n\n            self:shootBall(spec.football, dirX, dirZ, 0 , HandToolHands.FOOTBALL_PASS_VELOCITY, Football.TYPE_PASS)\n            return\n        end\n\n        -- If the player is currently holding an item, drop it.\n        if self:getIsHoldingItem() then\n            self:dropHeldItem()\n            -- Otherwise; pick up the targeted item.\n        else\n                local target = player.targeter.closestTargetsByKey[ HandToolHands ]\n                self:pickUpTarget(target)\n            end\n        end\n\n"})}),"\n",(0,o.jsx)(e.h3,{id:"onpitchaction",children:"onPitchAction"}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Description"})}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Definition"})}),"\n",(0,o.jsxs)(e.blockquote,{children:["\n",(0,o.jsx)(e.p,{children:"onPitchAction()"}),"\n"]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,o.jsxs)(e.table,{children:[(0,o.jsx)(e.thead,{children:(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.th,{children:"any"}),(0,o.jsx)(e.th,{children:"_"})]})}),(0,o.jsx)(e.tbody,{children:(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.td,{children:"any"}),(0,o.jsx)(e.td,{children:"inputDelta"})]})})]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Code"})}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-lua",children:"function HandToolHands:onPitchAction(_, inputDelta)\n\n    -- The pitching should always be relative to the player, so no matter which way the held object is facing, it's tilted towards/away from the player.\n    -- Otherwise; the item will be tilted relative to its own axis, which doesn't really make sense if they have no idea what part of the item is the \"front\".\n        local kinematicNode, rotationNode = self:getKinematicNode()\n        local directionX, directionY, directionZ = localDirectionToLocal(kinematicNode, rotationNode, 1 , 0 , 0 )\n\n        self:rotateHeldItem(inputDelta, directionX, directionY, directionZ)\n    end\n\n"})}),"\n",(0,o.jsx)(e.h3,{id:"onreadupdatestream",children:"onReadUpdateStream"}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Description"})}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Definition"})}),"\n",(0,o.jsxs)(e.blockquote,{children:["\n",(0,o.jsx)(e.p,{children:"onReadUpdateStream()"}),"\n"]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,o.jsxs)(e.table,{children:[(0,o.jsx)(e.thead,{children:(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.th,{children:"any"}),(0,o.jsx)(e.th,{children:"streamId"})]})}),(0,o.jsxs)(e.tbody,{children:[(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.td,{children:"any"}),(0,o.jsx)(e.td,{children:"timestamp"})]}),(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.td,{children:"any"}),(0,o.jsx)(e.td,{children:"connection"})]})]})]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Code"})}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-lua",children:"function HandToolHands:onReadUpdateStream(streamId, timestamp, connection)\n    if not connection:getIsServer() then\n        if streamReadBool(streamId) then\n            local kinematicNode, kinematicRotationNode = self:getKinematicNode()\n\n            local paramsXZ = g_currentMission.vehicleXZPosCompressionParams\n            local paramsY = g_currentMission.vehicleYPosCompressionParams\n\n            local kinematicNodePositionX = NetworkUtil.readCompressedWorldPosition(streamId, paramsXZ)\n            local kinematicNodePositionY = NetworkUtil.readCompressedWorldPosition(streamId, paramsY)\n            local kinematicNodePositionZ = NetworkUtil.readCompressedWorldPosition(streamId, paramsXZ)\n\n            local kinematicNodeDirectionX = NetworkUtil.readCompressedRange(streamId, - 1 , 1 , HandToolHands.KINEMATIC_NODE_DIRECTION_NUM_BITS)\n            local kinematicNodeDirectionZ = NetworkUtil.readCompressedRange(streamId, - 1 , 1 , HandToolHands.KINEMATIC_NODE_DIRECTION_NUM_BITS)\n\n            local kinematicNodePitch = NetworkUtil.readCompressedAngle(streamId)\n            local kinematicNodeYaw = NetworkUtil.readCompressedAngle(streamId)\n            local kinematicNodeRoll = NetworkUtil.readCompressedAngle(streamId)\n\n            setWorldTranslation(kinematicNode, kinematicNodePositionX, kinematicNodePositionY, kinematicNodePositionZ)\n            setWorldDirection(kinematicNode, kinematicNodeDirectionX, 0 , kinematicNodeDirectionZ, 0 , 1 , 0 )\n            setWorldRotation(kinematicRotationNode, kinematicNodePitch, kinematicNodeYaw, kinematicNodeRoll)\n\n            if self:getHasJoint() then\n                local spec = self.spec_hands\n                setJointFrame(spec.heldItemJointId, 0 , kinematicRotationNode)\n            end\n        end\n    end\nend\n\n"})}),"\n",(0,o.jsx)(e.h3,{id:"onregisteractionevents",children:"onRegisterActionEvents"}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Description"})}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Definition"})}),"\n",(0,o.jsxs)(e.blockquote,{children:["\n",(0,o.jsx)(e.p,{children:"onRegisterActionEvents()"}),"\n"]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Code"})}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-lua",children:'function HandToolHands:onRegisterActionEvents()\n    if not self:getIsActiveForInput( true ) then\n        return\n    end\n\n    local spec = self.spec_hands\n\n    -- The pick up/drop action.\n    local _, actionEventId = self:addActionEvent(InputAction.ACTIVATE_HANDTOOL, self , HandToolHands.onPickUpAction, true , false , false , false , nil )\n    g_inputBinding:setActionEventTextPriority(actionEventId, GS_PRIO_VERY_HIGH)\n    g_inputBinding:setActionEventText(actionEventId, spec.pickupText)\n    spec.pickUpActionEventId = actionEventId\n\n    -- The throw action.\n    _, actionEventId = self:addActionEvent(InputAction.ACTIVATE_HANDTOOL_SECONDARY, self , HandToolHands.onThrowAction, false , true , true , false , nil )\n    g_inputBinding:setActionEventTextPriority(actionEventId, GS_PRIO_VERY_HIGH)\n    g_inputBinding:setActionEventText(actionEventId, spec.throwText)\n    spec.throwActionEventId = actionEventId\n\n    -- The pitch/yaw actions.\n    _, actionEventId = self:addActionEvent(InputAction.ROTATE_OBJECT_UP_DOWN, self , HandToolHands.onPitchAction, false , false , true , false , nil )\n    g_inputBinding:setActionEventText(actionEventId, g_i18n:getText( "action_rotateObjectVertically" ))\n    spec.pitchActionEventId = actionEventId\n\n    _, actionEventId = self:addActionEvent(InputAction.ROTATE_OBJECT_LEFT_RIGHT, self , HandToolHands.onYawAction, false , false , true , false , nil )\n    g_inputBinding:setActionEventText(actionEventId, g_i18n:getText( "action_rotateObjectHorizontally" ))\n    spec.yawActionEventId = actionEventId\n\n    -- The level action for pallets and square bales.\n        _, actionEventId = self:addActionEvent(InputAction.HANDS_LEVEL_ITEM, self , HandToolHands.onLevelAction, true , false , false , false , nil )\n        spec.levelActionEventId = actionEventId\n    end\n\n'})}),"\n",(0,o.jsx)(e.h3,{id:"onthrowaction",children:"onThrowAction"}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Description"})}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Definition"})}),"\n",(0,o.jsxs)(e.blockquote,{children:["\n",(0,o.jsx)(e.p,{children:"onThrowAction()"}),"\n"]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,o.jsxs)(e.table,{children:[(0,o.jsx)(e.thead,{children:(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.th,{children:"any"}),(0,o.jsx)(e.th,{children:"_"})]})}),(0,o.jsx)(e.tbody,{children:(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.td,{children:"any"}),(0,o.jsx)(e.td,{children:"inputValue"})]})})]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Code"})}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-lua",children:"function HandToolHands:onThrowAction(_, inputValue)\n\n    -- Do nothing if the player is not the owner.\n        local player = self:getCarryingPlayer()\n        if not player.isOwner then\n            return\n        end\n\n        local spec = self.spec_hands\n        if spec.football ~ = nil then\n            local camera = g_cameraManager:getActiveCamera()\n            local dirX, _, dirZ = localDirectionToWorld(camera, 0 , 0 , - 1 )\n            dirX, _, dirZ = MathUtil.vector3Normalize(dirX, 0 , dirZ)\n\n            self:shootBall(spec.football, dirX, dirZ, 30 , HandToolHands.FOOTBALL_SHOT_VELOCITY, Football.TYPE_SHOT)\n        end\n\n        -- Do nothing if no item is held.\n            if not self:getIsHoldingItem() then\n                return\n            end\n\n            -- Keep track of the update loop index that this input was held down for.\n                spec.lastThrowUpdateIndex = g_updateLoopIndex\n\n                -- If there is no throw time, set it to 0.Otherwise; increment it by the dt.\n                if spec.currentThrowTime = = nil then\n                    spec.currentThrowTime = 0\n                else\n                        spec.currentThrowTime + = g_currentDt\n                    end\n                end\n\n"})}),"\n",(0,o.jsx)(e.h3,{id:"onupdate",children:"onUpdate"}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Description"})}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Definition"})}),"\n",(0,o.jsxs)(e.blockquote,{children:["\n",(0,o.jsx)(e.p,{children:"onUpdate()"}),"\n"]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,o.jsx)(e.table,{children:(0,o.jsx)(e.thead,{children:(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.th,{children:"any"}),(0,o.jsx)(e.th,{children:"dt"})]})})}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Code"})}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-lua",children:'function HandToolHands:onUpdate(dt)\n    local carryingPlayer = self:getCarryingPlayer()\n    if carryingPlayer = = nil then\n        return\n    end\n\n    if not self:getIsHeld() then\n        return\n    end\n\n    -- If a joint creation is being awaited, and the physics frame has been simulated, create the joint.This naturally only triggers on the server.\n    local spec = self.spec_hands\n    if self:getIsAwaitingJointCreation() and getIsPhysicsUpdateIndexSimulated(spec.pickupPhysicsIndex) then\n        self:createItemJoint()\n    end\n\n    -- Update the kinematic node.\n    self:updateKinematicNode()\n\n    if not carryingPlayer.isOwner then\n        return\n    end\n\n    spec.canShoot = (spec.lastShootTime + HandToolHands.FOOTBALL_SHOOT_THRESHOLD) < g_ time\n    spec.football = nil\n\n    if self:getIsHoldingItem() then\n        if self.isServer and spec.heldItemNode ~ = nil and not entityExists(spec.heldItemNode) then\n            self:dropHeldItem()\n        end\n    end\n\n    -- If the player is not holding anything, check to see if they\'re looking at something that can be picked up.\n        if not self:getIsHoldingItem() then\n\n            -- Determine if the moused over object can be picked up.\n                local targetNode = carryingPlayer.targeter:getClosestTargetedNodeFromType( HandToolHands )\n                local canPickUpTarget = self:getCanPickUpNode(targetNode)\n\n                if not canPickUpTarget then\n                    local mission = g_currentMission\n                    local object = mission:getNodeObject(targetNode)\n                    if object ~ = nil and object:isa( Football ) then\n                        spec.football = object\n                    end\n\n                    if spec.football = = nil then\n                        local x, y, z = getWorldTranslation(carryingPlayer.graphicsComponent.graphicsRootNode)\n                        overlapSphere(x, y, z, HandToolHands.FOOTBALL_DETECTION_RADIUS, "findFootballCallback" , self , CollisionFlag.DYNAMIC_OBJECT, true , false , false )\n                    end\n                end\n\n                local canShoot = (spec.football ~ = nil and spec.canShoot)\n\n                -- Activate or deactivate the input binding based on if the target object can be picked up or not.\n                    g_inputBinding:setActionEventActive(spec.pickUpActionEventId, canPickUpTarget or canShoot)\n                    g_inputBinding:setActionEventActive(spec.throwActionEventId, spec.heldItemNode or canShoot)\n\n                    if canShoot then\n                        g_inputBinding:setActionEventText(spec.pickUpActionEventId, spec.actionPassText)\n                        g_inputBinding:setActionEventText(spec.throwActionEventId, spec.actionShootText)\n                    else\n                            g_inputBinding:setActionEventText(spec.pickUpActionEventId, spec.pickupText)\n                            g_inputBinding:setActionEventText(spec.throwActionEventId, spec.throwText)\n                        end\n\n                        -- Otherwise; if the player is holding something and has finished throwing it, throw it.\n                        elseif self:getIsThrowingItem() and spec.lastThrowUpdateIndex ~ = nil and spec.lastThrowUpdateIndex ~ = g_updateLoopIndex then\n                                local throwForceScalar = math.clamp(spec.currentThrowTime / HandToolHands.MAXIMUM_THROW_TIME, 0 , 1 )\n                                self:throwHeldItemWithForceScalar(throwForceScalar)\n                            end\n\n                            if spec.football ~ = nil then\n                                if spec.canShoot then\n                                    local footballNode = spec.football.nodeId\n                                    local px, py, pz = getWorldTranslation(carryingPlayer.graphicsComponent.graphicsRootNode)\n                                    local bx, by, bz = getWorldTranslation(footballNode)\n                                    local distance = MathUtil.vector3Length(px - bx, py - by, pz - bz)\n\n                                    if distance > HandToolHands.FOOTBALL_DRIBBLE_MIN_DISTANCE and distance < HandToolHands.FOOTBALL_DRIBBLE_MAX_DISTANCE then\n                                        local camera = g_cameraManager:getActiveCamera()\n                                        local dirX, _, dirZ = localDirectionToWorld(camera, 0 , 0 , - 1 )\n                                        dirX, _, dirZ = MathUtil.vector3Normalize(dirX, 0 , dirZ)\n\n                                        self:shootBall(spec.football, dirX, dirZ, 0 , HandToolHands.FOOTBALL_DRIBBLE_VELOCITY, Football.TYPE_DRIBBLE)\n                                    end\n                                end\n                            end\n                        end\n\n'})}),"\n",(0,o.jsx)(e.h3,{id:"onwriteupdatestream",children:"onWriteUpdateStream"}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Description"})}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Definition"})}),"\n",(0,o.jsxs)(e.blockquote,{children:["\n",(0,o.jsx)(e.p,{children:"onWriteUpdateStream()"}),"\n"]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,o.jsxs)(e.table,{children:[(0,o.jsx)(e.thead,{children:(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.th,{children:"any"}),(0,o.jsx)(e.th,{children:"streamId"})]})}),(0,o.jsxs)(e.tbody,{children:[(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.td,{children:"any"}),(0,o.jsx)(e.td,{children:"connection"})]}),(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.td,{children:"any"}),(0,o.jsx)(e.td,{children:"dirtyMask"})]})]})]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Code"})}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-lua",children:"function HandToolHands:onWriteUpdateStream(streamId, connection, dirtyMask)\n    if connection:getIsServer() then\n        local spec = self.spec_hands\n        if streamWriteBool(streamId, bit32.btest(dirtyMask, spec.dirtyFlag)) then\n            local kinematicNode, kinematicRotationNode = self:getKinematicNode()\n\n            local kinematicNodePitch, kinematicNodeYaw, kinematicNodeRoll = getWorldRotation(kinematicRotationNode)\n            local kinematicNodePositionX, kinematicNodePositionY, kinematicNodePositionZ = getWorldTranslation(kinematicNode)\n            local kinematicNodeDirectionX, _, kinematicNodeDirectionZ = localDirectionToWorld(kinematicNode, 0 , 0 , 1 )\n            kinematicNodeDirectionX, kinematicNodeDirectionZ = MathUtil.vector2Normalize(kinematicNodeDirectionX, kinematicNodeDirectionZ)\n\n            local paramsXZ = g_currentMission.vehicleXZPosCompressionParams\n            local paramsY = g_currentMission.vehicleYPosCompressionParams\n\n            NetworkUtil.writeCompressedWorldPosition(streamId, kinematicNodePositionX, paramsXZ)\n            NetworkUtil.writeCompressedWorldPosition(streamId, kinematicNodePositionY, paramsY)\n            NetworkUtil.writeCompressedWorldPosition(streamId, kinematicNodePositionZ, paramsXZ)\n\n            NetworkUtil.writeCompressedRange(streamId, kinematicNodeDirectionX, - 1 , 1 , HandToolHands.KINEMATIC_NODE_DIRECTION_NUM_BITS)\n            NetworkUtil.writeCompressedRange(streamId, kinematicNodeDirectionZ, - 1 , 1 , HandToolHands.KINEMATIC_NODE_DIRECTION_NUM_BITS)\n\n            NetworkUtil.writeCompressedAngle(streamId, kinematicNodePitch)\n            NetworkUtil.writeCompressedAngle(streamId, kinematicNodeYaw)\n            NetworkUtil.writeCompressedAngle(streamId, kinematicNodeRoll)\n        end\n    end\nend\n\n"})}),"\n",(0,o.jsx)(e.h3,{id:"onyawaction",children:"onYawAction"}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Description"})}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Definition"})}),"\n",(0,o.jsxs)(e.blockquote,{children:["\n",(0,o.jsx)(e.p,{children:"onYawAction()"}),"\n"]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,o.jsxs)(e.table,{children:[(0,o.jsx)(e.thead,{children:(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.th,{children:"any"}),(0,o.jsx)(e.th,{children:"_"})]})}),(0,o.jsx)(e.tbody,{children:(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.td,{children:"any"}),(0,o.jsx)(e.td,{children:"inputDelta"})]})})]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Code"})}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-lua",children:"function HandToolHands:onYawAction(_, inputDelta)\n\n    -- The yaw should always be absolute, so that it spins as if on a pole.\n        local kinematicNode, rotationNode = self:getKinematicNode()\n        local directionX, directionY, directionZ = localDirectionToLocal(kinematicNode, rotationNode, 0 , 1 , 0 )\n\n        self:rotateHeldItem(inputDelta, directionX, directionY, directionZ)\n    end\n\n"})}),"\n",(0,o.jsx)(e.h3,{id:"orientrotationnodetoitem",children:"orientRotationNodeToItem"}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Description"})}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Definition"})}),"\n",(0,o.jsxs)(e.blockquote,{children:["\n",(0,o.jsx)(e.p,{children:"orientRotationNodeToItem()"}),"\n"]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,o.jsx)(e.table,{children:(0,o.jsx)(e.thead,{children:(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.th,{children:"any"}),(0,o.jsx)(e.th,{children:"targetItemNode"})]})})}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Code"})}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-lua",children:"function HandToolHands:orientRotationNodeToItem(targetItemNode)\n\n    local targetCentreX, targetCentreY, targetCentreZ = getCenterOfMass(targetItemNode)\n    local targetWorldX, targetWorldY, targetWorldZ = localToWorld(targetItemNode, targetCentreX, targetCentreY, targetCentreZ)\n\n    -- Position and orient the rotation node so that it matches the target item.\n    local _, kinematicRotationNode = self:getKinematicNode()\n    setWorldTranslation(kinematicRotationNode, targetWorldX, targetWorldY, targetWorldZ)\n    setWorldRotation(kinematicRotationNode, getWorldRotation(targetItemNode))\nend\n\n"})}),"\n",(0,o.jsx)(e.h3,{id:"pickupfailed",children:"pickupFailed"}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Description"})}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Definition"})}),"\n",(0,o.jsxs)(e.blockquote,{children:["\n",(0,o.jsx)(e.p,{children:"pickupFailed()"}),"\n"]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Code"})}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-lua",children:'function HandToolHands:pickupFailed()\n    Logging.devInfo( "HandToolHands.pickupFailed" )\n\n    local spec = self.spec_hands\n    --#debug if spec.heldItemNode ~ = nil and entityExists(spec.heldItemNode) then\n        --#debug Player.debugLog(self:getCarryingPlayer(), Player.DEBUG_DISPLAY_FLAG.HANDTOOLS, "Detached from %s", getName(spec.heldItemNode))\n        --#debug end\n\n        local carryingPlayer = self:getCarryingPlayer()\n        if carryingPlayer ~ = nil and carryingPlayer.isOwner then\n\n            -- Disable any actions that should only be available while an item is held.\n                g_inputBinding:setActionEventActive(spec.throwActionEventId, false )\n                g_inputBinding:setActionEventActive(spec.pitchActionEventId, false )\n                g_inputBinding:setActionEventActive(spec.yawActionEventId, false )\n                g_inputBinding:setActionEventActive(spec.levelActionEventId, false )\n\n                -- Disable the action and set its text to "pick up" again.\n                g_inputBinding:setActionEventActive(spec.pickUpActionEventId, false )\n                g_inputBinding:setActionEventText(spec.pickUpActionEventId, g_i18n:getText( "action_pickUpObject" ))\n            end\n\n            if spec.heldItemNode ~ = nil and entityExists(spec.heldItemNode) and self:getIsHoldingItem() then\n                -- Enable collision against cct\n                local player = self:getCarryingPlayer()\n                if player ~ = nil and player.capsuleController ~ = nil then\n                    local cctIndex = player.capsuleController.capsuleId\n                    if cctIndex ~ = nil then\n                        setCCTPairCollision(cctIndex, spec.heldItemNode, true )\n                    end\n                end\n            end\n\n            -- Reset the held item state.\n            spec.heldItemNode = nil\n        end\n\n'})}),"\n",(0,o.jsx)(e.h3,{id:"pickuptarget",children:"pickUpTarget"}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Description"})}),"\n",(0,o.jsxs)(e.blockquote,{children:["\n",(0,o.jsx)(e.p,{children:"Picks up the given target."}),"\n"]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Definition"})}),"\n",(0,o.jsxs)(e.blockquote,{children:["\n",(0,o.jsx)(e.p,{children:"pickUpTarget(table target, boolean noEventSend)"}),"\n"]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,o.jsxs)(e.table,{children:[(0,o.jsx)(e.thead,{children:(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.th,{children:"table"}),(0,o.jsx)(e.th,{children:"target"}),(0,o.jsx)(e.th,{children:"The target from the player's targeter."})]})}),(0,o.jsx)(e.tbody,{children:(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.td,{children:"boolean"}),(0,o.jsx)(e.td,{children:"noEventSend"}),(0,o.jsx)(e.td,{children:"If this is true, no network event will be sent."})]})})]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Return Values"})}),"\n\n\n\n\n\n\n\n\n",(0,o.jsx)(e.table,{children:(0,o.jsx)(e.thead,{children:(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.th,{children:"boolean"}),(0,o.jsx)(e.th,{children:"success"}),(0,o.jsx)(e.th,{children:"True if the target was picked up; otherwise false."})]})})}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Code"})}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-lua",children:'function HandToolHands:pickUpTarget(target, noEventSend)\n\n    -- If the item cannot be picked up, do nothing.\n        if target = = nil or not self:getCanPickUpNode(target.node) then\n            --#debug Player.debugLog(self:getCarryingPlayer(), Player.DEBUG_DISPLAY_FLAG.HANDTOOLS, "Failed to pick up object")\n            return false\n        end\n\n        HandsPickUpObjectEvent.sendEvent( self , target, noEventSend)\n\n        local mission = g_currentMission\n        local heldObject = mission:getNodeObject(target.node)\n        local heldItemNode = (heldObject ~ = nil and heldObject.rootNode ~ = nil ) and heldObject.rootNode or target.node\n\n        -- Set the held item to the given item, and save its collision mask.\n        local spec = self.spec_hands\n        spec.heldItemNode = heldItemNode\n\n        -- Disable collision against cct\n        local player = self:getCarryingPlayer()\n        if player ~ = nil and player.capsuleController ~ = nil then\n            local cctIndex = player.capsuleController.capsuleId\n            if cctIndex ~ = nil then\n                setCCTPairCollision(cctIndex, spec.heldItemNode, false )\n            end\n        end\n\n        -- Set the current hold distance to the distance from the player\'s camera to the hit position, then update the kinematic helper to ensure it\'s 100% in the correct position.\n        spec.currentHoldDistance = target.distance\n        self:updateKinematicNode()\n\n        -- Enable the actions that are available while holding an item.\n            g_inputBinding:setActionEventActive(spec.throwActionEventId, true )\n            g_inputBinding:setActionEventActive(spec.pitchActionEventId, true )\n            g_inputBinding:setActionEventActive(spec.yawActionEventId, true )\n\n            -- Activate the throw option.\n            g_inputBinding:setActionEventActive(spec.pickUpActionEventId, true )\n            g_inputBinding:setActionEventText(spec.pickUpActionEventId, g_i18n:getText( "action_dropObject" ))\n\n            -- Get the object that represents the node.If the node is a square bale or a pallet, enable the level action.\n            if heldObject ~ = nil and(heldObject.isPallet or(heldObject:isa( Bale ) and not heldObject.isRoundbale)) then\n                g_inputBinding:setActionEventActive(spec.levelActionEventId, true )\n\n                -- Work out the object name for the levelling action, defaulting to "object".\n                    local objectName = "object"\n                    if heldObject.isPallet then\n                        objectName = g_i18n:getText( "typeDesc_pallet" )\n                    elseif heldObject:isa( Bale ) then\n                            objectName = g_i18n:getText( "fillType_squareBale" )\n                        end\n                        g_inputBinding:setActionEventText(spec.levelActionEventId, string.namedFormat(g_i18n:getText( "action_levelObject" ), "objectName" , objectName))\n                    end\n\n                    if self.isServer then\n                        -- The kinematic node is a physics object, so moving it around has a 2 frame delay.If the joint were to be created now, it would fling off once the physics system has finished moving the kinematic node.\n                        -- Due to this, the current physics index is saved, and the joint is created when it has been simulated.\n                        spec.pickupPhysicsIndex = getPhysicsUpdateIndex()\n                        --#debug Player.debugLog(self:getCarryingPlayer(), Player.DEBUG_DISPLAY_FLAG.HANDTOOLS, "Awaiting physics index %d for attachment to %s", spec.pickupPhysicsIndex, getName(spec.heldItemNode))\n                        else\n                                self:orientRotationNodeToItem(heldItemNode)\n                            end\n\n                            return true\n                        end\n\n'})}),"\n",(0,o.jsx)(e.h3,{id:"prerequisitespresent",children:"prerequisitesPresent"}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Description"})}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Definition"})}),"\n",(0,o.jsxs)(e.blockquote,{children:["\n",(0,o.jsx)(e.p,{children:"prerequisitesPresent()"}),"\n"]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,o.jsx)(e.table,{children:(0,o.jsx)(e.thead,{children:(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.th,{children:"any"}),(0,o.jsx)(e.th,{children:"specializations"})]})})}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Code"})}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-lua",children:"function HandToolHands.prerequisitesPresent(specializations)\n    return true\nend\n\n"})}),"\n",(0,o.jsx)(e.h3,{id:"registereventlisteners",children:"registerEventListeners"}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Description"})}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Definition"})}),"\n",(0,o.jsxs)(e.blockquote,{children:["\n",(0,o.jsx)(e.p,{children:"registerEventListeners()"}),"\n"]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,o.jsx)(e.table,{children:(0,o.jsx)(e.thead,{children:(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.th,{children:"any"}),(0,o.jsx)(e.th,{children:"handToolType"})]})})}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Code"})}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-lua",children:'function HandToolHands.registerEventListeners(handToolType)\n    SpecializationUtil.registerEventListener(handToolType, "onLoad" , HandToolHands )\n    SpecializationUtil.registerEventListener(handToolType, "onDelete" , HandToolHands )\n    SpecializationUtil.registerEventListener(handToolType, "onUpdate" , HandToolHands )\n    SpecializationUtil.registerEventListener(handToolType, "onDraw" , HandToolHands )\n    SpecializationUtil.registerEventListener(handToolType, "onWriteUpdateStream" , HandToolHands )\n    SpecializationUtil.registerEventListener(handToolType, "onReadUpdateStream" , HandToolHands )\n    SpecializationUtil.registerEventListener(handToolType, "onRegisterActionEvents" , HandToolHands )\n    SpecializationUtil.registerEventListener(handToolType, "onCarryingPlayerChanged" , HandToolHands )\n    SpecializationUtil.registerEventListener(handToolType, "onHeldStart" , HandToolHands )\n    SpecializationUtil.registerEventListener(handToolType, "onHeldEnd" , HandToolHands )\n    SpecializationUtil.registerEventListener(handToolType, "onDebugDraw" , HandToolHands )\nend\n\n'})}),"\n",(0,o.jsx)(e.h3,{id:"registerfunctions",children:"registerFunctions"}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Description"})}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Definition"})}),"\n",(0,o.jsxs)(e.blockquote,{children:["\n",(0,o.jsx)(e.p,{children:"registerFunctions()"}),"\n"]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,o.jsx)(e.table,{children:(0,o.jsx)(e.thead,{children:(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.th,{children:"any"}),(0,o.jsx)(e.th,{children:"handToolType"})]})})}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Code"})}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-lua",children:'function HandToolHands.registerFunctions(handToolType)\n    SpecializationUtil.registerFunction(handToolType, "updateKinematicNode" , HandToolHands.updateKinematicNode)\n\n    SpecializationUtil.registerFunction(handToolType, "getKinematicNode" , HandToolHands.getKinematicNode)\n    SpecializationUtil.registerFunction(handToolType, "getIsHoldingItem" , HandToolHands.getIsHoldingItem)\n    SpecializationUtil.registerFunction(handToolType, "getIsThrowingItem" , HandToolHands.getIsThrowingItem)\n    SpecializationUtil.registerFunction(handToolType, "getIsAwaitingJointCreation" , HandToolHands.getIsAwaitingJointCreation)\n    SpecializationUtil.registerFunction(handToolType, "getHasJoint" , HandToolHands.getHasJoint)\n    SpecializationUtil.registerFunction(handToolType, "getHeldItem" , HandToolHands.getHeldItem)\n    SpecializationUtil.registerFunction(handToolType, "getCanPickUpNode" , HandToolHands.getCanPickUpNode)\n\n    SpecializationUtil.registerFunction(handToolType, "orientRotationNodeToItem" , HandToolHands.orientRotationNodeToItem)\n    SpecializationUtil.registerFunction(handToolType, "createItemJoint" , HandToolHands.createItemJoint)\n\n    SpecializationUtil.registerFunction(handToolType, "pickUpTarget" , HandToolHands.pickUpTarget)\n    SpecializationUtil.registerFunction(handToolType, "pickupFailed" , HandToolHands.pickupFailed)\n    SpecializationUtil.registerFunction(handToolType, "dropHeldItem" , HandToolHands.dropHeldItem)\n    SpecializationUtil.registerFunction(handToolType, "throwHeldItemWithForceScalar" , HandToolHands.throwHeldItemWithForceScalar)\n    SpecializationUtil.registerFunction(handToolType, "throwHeldItemWithForceVector" , HandToolHands.throwHeldItemWithForceVector)\n\n    SpecializationUtil.registerFunction(handToolType, "rotateHeldItem" , HandToolHands.rotateHeldItem)\n    SpecializationUtil.registerFunction(handToolType, "levelHeldItem" , HandToolHands.levelHeldItem)\n\n    SpecializationUtil.registerFunction(handToolType, "onHeldItemJointBroken" , HandToolHands.onHeldItemJointBroken)\n\n    SpecializationUtil.registerFunction(handToolType, "findFootballCallback" , HandToolHands.findFootballCallback)\n    SpecializationUtil.registerFunction(handToolType, "shootBall" , HandToolHands.shootBall)\n\n    SpecializationUtil.registerFunction(handToolType, "consoleCommandToggleSuperStrength" , HandToolHands.consoleCommandToggleSuperStrength)\nend\n\n'})}),"\n",(0,o.jsx)(e.h3,{id:"registeroverwrittenfunctions",children:"registerOverwrittenFunctions"}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Description"})}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Definition"})}),"\n",(0,o.jsxs)(e.blockquote,{children:["\n",(0,o.jsx)(e.p,{children:"registerOverwrittenFunctions()"}),"\n"]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,o.jsx)(e.table,{children:(0,o.jsx)(e.thead,{children:(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.th,{children:"any"}),(0,o.jsx)(e.th,{children:"vehicleType"})]})})}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Code"})}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-lua",children:'function HandToolHands.registerOverwrittenFunctions(vehicleType)\n    SpecializationUtil.registerOverwrittenFunction(vehicleType, "getCanBeDropped" , HandToolHands.getCanBeDropped)\nend\n\n'})}),"\n",(0,o.jsx)(e.h3,{id:"registerxmlpaths",children:"registerXMLPaths"}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Description"})}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Definition"})}),"\n",(0,o.jsxs)(e.blockquote,{children:["\n",(0,o.jsx)(e.p,{children:"registerXMLPaths()"}),"\n"]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,o.jsx)(e.table,{children:(0,o.jsx)(e.thead,{children:(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.th,{children:"any"}),(0,o.jsx)(e.th,{children:"xmlSchema"})]})})}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Code"})}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-lua",children:'function HandToolHands.registerXMLPaths(xmlSchema)\n    xmlSchema:setXMLSpecializationType( "HandToolHands" )\n    xmlSchema:setXMLSpecializationType()\nend\n\n'})}),"\n",(0,o.jsx)(e.h3,{id:"rotatehelditem",children:"rotateHeldItem"}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Description"})}),"\n",(0,o.jsxs)(e.blockquote,{children:["\n",(0,o.jsx)(e.p,{children:"Rotates the rotation node locally about the given direction axis."}),"\n"]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Definition"})}),"\n",(0,o.jsxs)(e.blockquote,{children:["\n",(0,o.jsx)(e.p,{children:"rotateHeldItem(float inputDelta, float directionX, float directionY, float directionZ)"}),"\n"]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,o.jsxs)(e.table,{children:[(0,o.jsx)(e.thead,{children:(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.th,{children:"float"}),(0,o.jsx)(e.th,{children:"inputDelta"}),(0,o.jsx)(e.th,{children:"The rotation about the axis to make, in radians."})]})}),(0,o.jsxs)(e.tbody,{children:[(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.td,{children:"float"}),(0,o.jsx)(e.td,{children:"directionX"}),(0,o.jsx)(e.td,{children:"The x direction of the axis."})]}),(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.td,{children:"float"}),(0,o.jsx)(e.td,{children:"directionY"}),(0,o.jsx)(e.td,{children:"The y direction of the axis."})]}),(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.td,{children:"float"}),(0,o.jsx)(e.td,{children:"directionZ"}),(0,o.jsx)(e.td,{children:"The z direction of the axis."})]})]})]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Code"})}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-lua",children:"function HandToolHands:rotateHeldItem(inputDelta, directionX, directionY, directionZ)\n\n    -- Calculate the rotation to make.\n    local rotation = ( math.pi * 0.5 ) * (g_physicsDt * 0.001 ) * inputDelta\n\n    -- Rotate the rotation node about the given local axis.\n    local spec = self.spec_hands\n    local _, rotationNode = self:getKinematicNode()\n    rotateAboutLocalAxis(rotationNode, rotation, directionX, directionY, directionZ)\n\n    -- Set the joint frame for the joint, so that it updates.\n        if self.isServer and spec.heldItemJointId ~ = nil then\n            setJointFrame(spec.heldItemJointId, 0 , rotationNode)\n        end\n    end\n\n"})}),"\n",(0,o.jsx)(e.h3,{id:"shootball",children:"shootBall"}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Description"})}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Definition"})}),"\n",(0,o.jsxs)(e.blockquote,{children:["\n",(0,o.jsx)(e.p,{children:"shootBall()"}),"\n"]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,o.jsxs)(e.table,{children:[(0,o.jsx)(e.thead,{children:(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.th,{children:"any"}),(0,o.jsx)(e.th,{children:"football"})]})}),(0,o.jsxs)(e.tbody,{children:[(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.td,{children:"any"}),(0,o.jsx)(e.td,{children:"dirX"})]}),(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.td,{children:"any"}),(0,o.jsx)(e.td,{children:"dirZ"})]}),(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.td,{children:"any"}),(0,o.jsx)(e.td,{children:"angleDeg"})]}),(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.td,{children:"any"}),(0,o.jsx)(e.td,{children:"velocity"})]}),(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.td,{children:"any"}),(0,o.jsx)(e.td,{children:"shotType"})]})]})]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Code"})}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-lua",children:"function HandToolHands:shootBall(football, dirX, dirZ, angleDeg, velocity, shotType)\n    local spec = self.spec_hands\n    spec.lastShootTime = g_ time\n    spec.canShoot = false\n    football:shoot(dirX, dirZ, angleDeg, velocity, shotType)\nend\n\n"})}),"\n",(0,o.jsx)(e.h3,{id:"throwhelditemwithforcescalar",children:"throwHeldItemWithForceScalar"}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Description"})}),"\n",(0,o.jsxs)(e.blockquote,{children:["\n",(0,o.jsx)(e.p,{children:"Throws the currently held item with the given force scalar (from 0 to 1, where 1 is a fully powered throw) in the\ndirection of the player's camera."}),"\n"]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Definition"})}),"\n",(0,o.jsxs)(e.blockquote,{children:["\n",(0,o.jsx)(e.p,{children:"throwHeldItemWithForceScalar(float throwForceScalar, boolean noEventSend)"}),"\n"]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,o.jsxs)(e.table,{children:[(0,o.jsx)(e.thead,{children:(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.th,{children:"float"}),(0,o.jsx)(e.th,{children:"throwForceScalar"}),(0,o.jsx)(e.th,{children:"The throw power from 0 to 1, where 1 is a fully powered throw."})]})}),(0,o.jsx)(e.tbody,{children:(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.td,{children:"boolean"}),(0,o.jsx)(e.td,{children:"noEventSend"}),(0,o.jsx)(e.td,{children:"If this is true, no network event will be sent."})]})})]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Code"})}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-lua",children:'function HandToolHands:throwHeldItemWithForceScalar(throwForceScalar, noEventSend)\n\n    -- Do nothing if no item is being held.\n        if not self:getIsHoldingItem() then\n            return\n        end\n\n        local player = self:getCarryingPlayer()\n        if player = = nil or player.targeter = = nil then\n            Logging.error( "HandToolHands:throwHeldItemWithForceScalar can only be used on the owning player, as it uses their camera direction!" )\n            return\n        end\n\n        local _, _, _, cameraDirectionX, cameraDirectionY, cameraDirectionZ = player.targeter:getLastLookRay()\n        self:throwHeldItemWithForceVector(cameraDirectionX, cameraDirectionY, cameraDirectionZ, throwForceScalar, noEventSend)\n    end\n\n'})}),"\n",(0,o.jsx)(e.h3,{id:"updatekinematicnode",children:"updateKinematicNode"}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Description"})}),"\n",(0,o.jsxs)(e.blockquote,{children:["\n",(0,o.jsx)(e.p,{children:"Updates the position of the kinematic node so that it is always in front of the player."}),"\n"]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Definition"})}),"\n",(0,o.jsxs)(e.blockquote,{children:["\n",(0,o.jsx)(e.p,{children:"updateKinematicNode()"}),"\n"]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Code"})}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-lua",children:"function HandToolHands:updateKinematicNode()\n\n    -- If there is no kinematic node yet, do nothing.\n        local spec = self.spec_hands\n        if spec.kinematicNode = = nil then\n            return\n        end\n\n        -- If the hands are not active, do nothing.\n            if not self:getIsHeld() then\n                return\n            end\n\n            -- If the player is not the owner, do nothing.\n                if not self:getCarryingPlayer().isOwner then\n                    return\n                end\n\n                -- Get the player's last targeter ray.If it is nil, do nothing.\n                    local x, y, z, dx, dy, dz = self:getCarryingPlayer().targeter:getLastLookRay()\n                    if x = = nil then\n                        return\n                    end\n\n                    self:raiseDirtyFlags(spec.dirtyFlag)\n\n                    -- Calculate the position of the kinematic helper along the ray.\n                    x, y, z = x + (dx * spec.currentHoldDistance), y + (dy * spec.currentHoldDistance), z + (dz * spec.currentHoldDistance)\n\n                    -- Set the position and rotation of the kinematic node.Keep the kinematic node level to the world.\n                    setWorldTranslation(spec.kinematicNode, x, y, z)\n                    dx, dz = MathUtil.vector2Normalize(dx, dz)\n                    setWorldDirection(spec.kinematicNode, dx, 0 , dz, 0 , 1 , 0 )\n                end\n\n"})})]})}function h(n={}){const{wrapper:e}={...(0,r.R)(),...n.components};return e?(0,o.jsx)(e,{...n,children:(0,o.jsx)(c,{...n})}):c(n)}}}]);