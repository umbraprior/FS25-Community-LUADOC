"use strict";(globalThis.webpackChunkfs25_community_luadoc=globalThis.webpackChunkfs25_community_luadoc||[]).push([[51798],{28453(n,e,t){t.d(e,{R:()=>s,x:()=>l});var a=t(96540);const i={},r=a.createContext(i);function s(n){const e=a.useContext(r);return a.useMemo(function(){return"function"==typeof n?n(e):{...e,...n}},[e,n])}function l(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(i):n.components||i:s(n.components),a.createElement(r.Provider,{value:e},n.children)}},49919(n,e,t){t.r(e),t.d(e,{assets:()=>o,contentTitle:()=>l,default:()=>p,frontMatter:()=>s,metadata:()=>a,toc:()=>d});const a=JSON.parse('{"id":"script/Specializations/RandomlyMovingParts","title":"RandomlyMovingParts","description":"RandomlyMovingParts","source":"@site/../docs/script/Specializations/RandomlyMovingParts.md","sourceDirName":"script/Specializations","slug":"/script/Specializations/RandomlyMovingParts","permalink":"/FS25-Community-LUADOC/script/Specializations/RandomlyMovingParts","draft":false,"unlisted":false,"tags":[],"version":"current","lastUpdatedAt":1767161192000,"frontMatter":{},"sidebar":"docsSidebar","previous":{"title":"RTKStation","permalink":"/FS25-Community-LUADOC/script/Specializations/RTKStation"},"next":{"title":"ReceivingHopper","permalink":"/FS25-Community-LUADOC/script/Specializations/ReceivingHopper"}}');var i=t(74848),r=t(28453);const s={},l=void 0,o={},d=[{value:"RandomlyMovingParts",id:"randomlymovingparts",level:2},{value:"getIsRandomlyMovingPartActive",id:"getisrandomlymovingpartactive",level:3},{value:"initSpecialization",id:"initspecialization",level:3},{value:"loadRandomlyMovingPartFromXML",id:"loadrandomlymovingpartfromxml",level:3},{value:"onLoad",id:"onload",level:3},{value:"onUpdate",id:"onupdate",level:3},{value:"prerequisitesPresent",id:"prerequisitespresent",level:3},{value:"registerEventListeners",id:"registereventlisteners",level:3},{value:"registerFunctions",id:"registerfunctions",level:3},{value:"updateRandomlyMovingPart",id:"updaterandomlymovingpart",level:3}];function c(n){const e={a:"a",blockquote:"blockquote",code:"code",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,r.R)(),...n.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(e.h2,{id:"randomlymovingparts",children:"RandomlyMovingParts"}),"\n",(0,i.jsx)(e.p,{children:(0,i.jsx)(e.strong,{children:"Description"})}),"\n",(0,i.jsxs)(e.blockquote,{children:["\n",(0,i.jsx)(e.p,{children:"Specialization for making parts randomly move during work using rotation changes"}),"\n"]}),"\n",(0,i.jsx)(e.p,{children:(0,i.jsx)(e.strong,{children:"Functions"})}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:(0,i.jsx)(e.a,{href:"#getisrandomlymovingpartactive",children:"getIsRandomlyMovingPartActive"})}),"\n",(0,i.jsx)(e.li,{children:(0,i.jsx)(e.a,{href:"#initspecialization",children:"initSpecialization"})}),"\n",(0,i.jsx)(e.li,{children:(0,i.jsx)(e.a,{href:"#loadrandomlymovingpartfromxml",children:"loadRandomlyMovingPartFromXML"})}),"\n",(0,i.jsx)(e.li,{children:(0,i.jsx)(e.a,{href:"#onload",children:"onLoad"})}),"\n",(0,i.jsx)(e.li,{children:(0,i.jsx)(e.a,{href:"#onupdate",children:"onUpdate"})}),"\n",(0,i.jsx)(e.li,{children:(0,i.jsx)(e.a,{href:"#prerequisitespresent",children:"prerequisitesPresent"})}),"\n",(0,i.jsx)(e.li,{children:(0,i.jsx)(e.a,{href:"#registereventlisteners",children:"registerEventListeners"})}),"\n",(0,i.jsx)(e.li,{children:(0,i.jsx)(e.a,{href:"#registerfunctions",children:"registerFunctions"})}),"\n",(0,i.jsx)(e.li,{children:(0,i.jsx)(e.a,{href:"#updaterandomlymovingpart",children:"updateRandomlyMovingPart"})}),"\n"]}),"\n",(0,i.jsx)(e.h3,{id:"getisrandomlymovingpartactive",children:"getIsRandomlyMovingPartActive"}),"\n",(0,i.jsx)(e.p,{children:(0,i.jsx)(e.strong,{children:"Description"})}),"\n",(0,i.jsxs)(e.blockquote,{children:["\n",(0,i.jsx)(e.p,{children:"Returns if randomly moving part is active"}),"\n"]}),"\n",(0,i.jsx)(e.p,{children:(0,i.jsx)(e.strong,{children:"Definition"})}),"\n",(0,i.jsxs)(e.blockquote,{children:["\n",(0,i.jsx)(e.p,{children:"getIsRandomlyMovingPartActive(table part)"}),"\n"]}),"\n",(0,i.jsx)(e.p,{children:(0,i.jsx)(e.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n",(0,i.jsx)(e.table,{children:(0,i.jsx)(e.thead,{children:(0,i.jsxs)(e.tr,{children:[(0,i.jsx)(e.th,{children:"table"}),(0,i.jsx)(e.th,{children:"part"}),(0,i.jsx)(e.th,{children:"part to check"})]})})}),"\n",(0,i.jsx)(e.p,{children:(0,i.jsx)(e.strong,{children:"Return Values"})}),"\n\n\n\n\n\n\n\n\n",(0,i.jsx)(e.table,{children:(0,i.jsx)(e.thead,{children:(0,i.jsxs)(e.tr,{children:[(0,i.jsx)(e.th,{children:"table"}),(0,i.jsx)(e.th,{children:"isActive"}),(0,i.jsx)(e.th,{children:"is active"})]})})}),"\n",(0,i.jsx)(e.p,{children:(0,i.jsx)(e.strong,{children:"Code"})}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-lua",children:"function RandomlyMovingParts:getIsRandomlyMovingPartActive(part)\n    local retValue = true\n    if part.groundReferenceNode ~ = nil then\n        retValue = self:getIsGroundReferenceNodeActive(part.groundReferenceNode)\n    end\n\n    return retValue\nend\n\n"})}),"\n",(0,i.jsx)(e.h3,{id:"initspecialization",children:"initSpecialization"}),"\n",(0,i.jsx)(e.p,{children:(0,i.jsx)(e.strong,{children:"Description"})}),"\n",(0,i.jsx)(e.p,{children:(0,i.jsx)(e.strong,{children:"Definition"})}),"\n",(0,i.jsxs)(e.blockquote,{children:["\n",(0,i.jsx)(e.p,{children:"initSpecialization()"}),"\n"]}),"\n",(0,i.jsx)(e.p,{children:(0,i.jsx)(e.strong,{children:"Code"})}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-lua",children:'function RandomlyMovingParts.initSpecialization()\n    local schema = Vehicle.xmlSchema\n    schema:setXMLSpecializationType( "RandomlyMovingParts" )\n\n    schema:register(XMLValueType.FLOAT, "vehicle.randomlyMovingParts#maxUpdateDistance" , RandomlyMovingParts.DEFAULT_MAX_UPDATE_DISTANCE)\n\n    schema:register(XMLValueType.NODE_INDEX, RandomlyMovingParts.RANDOMLY_MOVING_PART_XML_KEY .. "#node" , "Node" )\n    schema:register(XMLValueType.INT, RandomlyMovingParts.RANDOMLY_MOVING_PART_XML_KEY .. "#refNodeIndex" , "Ground reference node index" )\n\n    schema:register(XMLValueType.FLOAT, RandomlyMovingParts.RANDOMLY_MOVING_PART_XML_KEY .. "#speedScale" , "Speed scale" , 1 )\n    schema:register(XMLValueType.FLOAT, RandomlyMovingParts.RANDOMLY_MOVING_PART_XML_KEY .. "#speedVariance" , "Random variance in the speed scale" , 0.1 )\n    schema:register(XMLValueType.TIME, RandomlyMovingParts.RANDOMLY_MOVING_PART_XML_KEY .. "#fadeTime" , "Fade in and fade out time" , 1 )\n\n    local names = { }\n    for name, _ in pairs( RandomlyMovingParts.PRESETS) do\n        table.insert(names, name)\n    end\n\n    schema:register(XMLValueType.STRING, RandomlyMovingParts.RANDOMLY_MOVING_PART_XML_KEY .. "#preset" , "Name of the preset to use for random value behaviour(%s)" , "SOWINGMACHINE" , nil , names)\n\n        schema:register(XMLValueType.VECTOR_ 3 , RandomlyMovingParts.RANDOMLY_MOVING_PART_XML_KEY .. "#noiseFrequency" , "The frequency of the different offsets that is applied" , "used from preset" )\n        schema:register(XMLValueType.VECTOR_ 3 , RandomlyMovingParts.RANDOMLY_MOVING_PART_XML_KEY .. "#noiseAmount" , "The max.offset for each frequency" , "used from preset" )\n\n            schema:register(XMLValueType.BOOL, RandomlyMovingParts.RANDOMLY_MOVING_PART_XML_KEY .. "#hasBumps" , "The max.offset for each frequency" , "used from preset" )\n                schema:register(XMLValueType.TIME, RandomlyMovingParts.RANDOMLY_MOVING_PART_XML_KEY .. "#bumpFrequency" , "Max.time between bumps" , "used from preset" )\n                schema:register(XMLValueType.TIME, RandomlyMovingParts.RANDOMLY_MOVING_PART_XML_KEY .. "#bumpDuration" , "Duration of the bump" , "used from preset" )\n\n                schema:register(XMLValueType.INT, RandomlyMovingParts.RANDOMLY_MOVING_PART_XML_KEY .. "#rotAxis" , "Rotation axis" )\n                schema:register(XMLValueType.ANGLE, RandomlyMovingParts.RANDOMLY_MOVING_PART_XML_KEY .. "#rotMax" , "Max.delta rotation value in position direction" )\n                schema:register(XMLValueType.ANGLE, RandomlyMovingParts.RANDOMLY_MOVING_PART_XML_KEY .. "#rotMin" , "Max.delta rotation value in negative direction" , "Inverted rotMax value" )\n                schema:register(XMLValueType.ANGLE, RandomlyMovingParts.RANDOMLY_MOVING_PART_XML_KEY .. "#rotStart" , "Initial rotation value on the defined axis" , "Current value from i3d" )\n\n                schema:register(XMLValueType.INT, RandomlyMovingParts.RANDOMLY_MOVING_PART_XML_KEY .. "#transAxis" , "Translation axis" )\n                schema:register(XMLValueType.FLOAT, RandomlyMovingParts.RANDOMLY_MOVING_PART_XML_KEY .. "#transMax" , "Max.delta translation value in position direction" )\n                schema:register(XMLValueType.FLOAT, RandomlyMovingParts.RANDOMLY_MOVING_PART_XML_KEY .. "#transMin" , "Max.delta translation value in negative direction" , "Inverted rotMax value" )\n                schema:register(XMLValueType.FLOAT, RandomlyMovingParts.RANDOMLY_MOVING_PART_XML_KEY .. "#transStart" , "Initial translation value on the defined axis" , "Current value from i3d" )\n\n                schema:register(XMLValueType.BOOL, RandomlyMovingParts.RANDOMLY_MOVING_PART_XML_KEY .. "#isSpeedDependent" , "Speed will adjust based on vehicle moving speed" , true )\n\n                schema:register(XMLValueType.NODE_INDEX, RandomlyMovingParts.RANDOMLY_MOVING_PART_XML_KEY .. ".node(?)#node" , "Node that receives the same value" )\n                schema:register(XMLValueType.FLOAT, RandomlyMovingParts.RANDOMLY_MOVING_PART_XML_KEY .. ".node(?)#scale" , "Scale that is applied to the random value(use -1 to invert the value)" , 1 )\n\n                schema:register(XMLValueType.INT, RandomlyMovingParts.RANDOMLY_MOVING_PART_XML_KEY .. ".node(?)#rotAxis" , "Rotation axis" )\n                schema:register(XMLValueType.ANGLE, RandomlyMovingParts.RANDOMLY_MOVING_PART_XML_KEY .. ".node(?)#rotMax" , "Max.delta rotation value in position direction" )\n                schema:register(XMLValueType.ANGLE, RandomlyMovingParts.RANDOMLY_MOVING_PART_XML_KEY .. ".node(?)#rotMin" , "Max.delta rotation value in negative direction" , "Inverted rotMax value" )\n                schema:register(XMLValueType.ANGLE, RandomlyMovingParts.RANDOMLY_MOVING_PART_XML_KEY .. ".node(?)#rotStart" , "Initial rotation value on the defined axis" , "Current value from i3d" )\n\n                schema:register(XMLValueType.INT, RandomlyMovingParts.RANDOMLY_MOVING_PART_XML_KEY .. ".node(?)#transAxis" , "Translation axis" )\n                schema:register(XMLValueType.FLOAT, RandomlyMovingParts.RANDOMLY_MOVING_PART_XML_KEY .. ".node(?)#transMax" , "Max.delta translation value in position direction" )\n                schema:register(XMLValueType.FLOAT, RandomlyMovingParts.RANDOMLY_MOVING_PART_XML_KEY .. ".node(?)#transMin" , "Max.delta translation value in negative direction" , "Inverted rotMax value" )\n                schema:register(XMLValueType.FLOAT, RandomlyMovingParts.RANDOMLY_MOVING_PART_XML_KEY .. ".node(?)#transStart" , "Initial translation value on the defined axis" , "Current value from i3d" )\n\n                schema:setXMLSpecializationType()\n            end\n\n'})}),"\n",(0,i.jsx)(e.h3,{id:"loadrandomlymovingpartfromxml",children:"loadRandomlyMovingPartFromXML"}),"\n",(0,i.jsx)(e.p,{children:(0,i.jsx)(e.strong,{children:"Description"})}),"\n",(0,i.jsxs)(e.blockquote,{children:["\n",(0,i.jsx)(e.p,{children:"Load randomly moving part from xml"}),"\n"]}),"\n",(0,i.jsx)(e.p,{children:(0,i.jsx)(e.strong,{children:"Definition"})}),"\n",(0,i.jsxs)(e.blockquote,{children:["\n",(0,i.jsx)(e.p,{children:"loadRandomlyMovingPartFromXML(table part, XMLFile xmlFile, string key)"}),"\n"]}),"\n",(0,i.jsx)(e.p,{children:(0,i.jsx)(e.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,i.jsxs)(e.table,{children:[(0,i.jsx)(e.thead,{children:(0,i.jsxs)(e.tr,{children:[(0,i.jsx)(e.th,{children:"table"}),(0,i.jsx)(e.th,{children:"part"}),(0,i.jsx)(e.th,{children:"part"})]})}),(0,i.jsxs)(e.tbody,{children:[(0,i.jsxs)(e.tr,{children:[(0,i.jsx)(e.td,{children:"XMLFile"}),(0,i.jsx)(e.td,{children:"xmlFile"}),(0,i.jsx)(e.td,{children:"XMLFile instance"})]}),(0,i.jsxs)(e.tr,{children:[(0,i.jsx)(e.td,{children:"string"}),(0,i.jsx)(e.td,{children:"key"}),(0,i.jsx)(e.td,{children:"key"})]})]})]}),"\n",(0,i.jsx)(e.p,{children:(0,i.jsx)(e.strong,{children:"Return Values"})}),"\n\n\n\n\n\n\n\n",(0,i.jsx)(e.table,{children:(0,i.jsx)(e.thead,{children:(0,i.jsxs)(e.tr,{children:[(0,i.jsx)(e.th,{children:"string"}),(0,i.jsx)(e.th,{children:"success"})]})})}),"\n",(0,i.jsx)(e.p,{children:(0,i.jsx)(e.strong,{children:"Code"})}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-lua",children:'function RandomlyMovingParts:loadRandomlyMovingPartFromXML(part, xmlFile, key)\n    XMLUtil.checkDeprecatedXMLElements(xmlFile, key .. "#index" , key .. "#node" ) --FS17 to FS19\n\n    XMLUtil.checkDeprecatedXMLElements(xmlFile, key .. "#rotMean" ) --FS22 to FS25\n    XMLUtil.checkDeprecatedXMLElements(xmlFile, key .. "#rotVariance" ) --FS22 to FS25\n    XMLUtil.checkDeprecatedXMLElements(xmlFile, key .. "#rotTimeMean" ) --FS22 to FS25\n    XMLUtil.checkDeprecatedXMLElements(xmlFile, key .. "#rotTimeVariance" ) --FS22 to FS25\n    XMLUtil.checkDeprecatedXMLElements(xmlFile, key .. "#pauseMean" ) --FS22 to FS25\n    XMLUtil.checkDeprecatedXMLElements(xmlFile, key .. "#pauseVariance" ) --FS22 to FS25\n\n    local node = xmlFile:getValue(key .. "#node" , nil , self.components, self.i3dMappings)\n    if node = = nil then\n        Logging.xmlWarning(xmlFile, "Unknown node for randomlyMovingPart in \'%s\'" , key)\n            return false\n        end\n\n        part.node = node\n\n        if self.getGroundReferenceNodeFromIndex ~ = nil then\n            local refNodeIndex = xmlFile:getValue(key .. "#refNodeIndex" )\n            if refNodeIndex ~ = nil then\n                if refNodeIndex ~ = 0 then\n                    local groundReferenceNode = self:getGroundReferenceNodeFromIndex(refNodeIndex)\n                    if groundReferenceNode ~ = nil then\n                        part.groundReferenceNode = groundReferenceNode\n                    end\n                else\n                        Logging.xmlWarning(xmlFile, "Unknown ground reference node in \'%s\'! Indices start with \'0\'" , key .. "#refNodeIndex" )\n                    end\n                end\n            end\n\n            part.isSpeedDependent = xmlFile:getValue(key .. "#isSpeedDependent" , true )\n\n            part.speedScale = xmlFile:getValue(key .. "#speedScale" , 1 )\n            part.speedVariance = xmlFile:getValue(key .. "#speedVariance" , 0.1 )\n            part.speedScale = part.speedScale + ( math.random() * part.speedVariance - (part.speedVariance * 0.5 ))\n\n            part.fadeTime = 1 / xmlFile:getValue(key .. "#fadeTime" , 1 )\n\n            local preset = xmlFile:getValue(key .. "#preset" , "SOWINGMACHINE" )\n            preset = RandomlyMovingParts.PRESETS[ string.upper(preset)] or RandomlyMovingParts.PRESETS.SOWINGMACHINE\n\n            part.noiseFrequency = xmlFile:getValue(key .. "#noiseFrequency" , preset.noiseFrequency, true )\n            part.noiseAmount = xmlFile:getValue(key .. "#noiseAmount" , preset.noiseAmount, true )\n\n            part.hasBumps = xmlFile:getValue(key .. "#hasBumps" , preset.hasBumps)\n            if part.hasBumps then\n                part.bumpFrequency = xmlFile:getValue(key .. "#bumpFrequency" , preset.bumpFrequency or 10 )\n                part.bumpNextTime = part.bumpFrequency * math.random()\n\n                part.bumpTimer = 0\n                part.bumpDuration = xmlFile:getValue(key .. "#bumpDuration" , preset.bumpDuration or 0.25 )\n            end\n\n            part.rotAxis = xmlFile:getValue(key .. "#rotAxis" , nil )\n            if part.rotAxis ~ = nil then\n                part.rotMax = xmlFile:getValue(key .. "#rotMax" , 0 )\n                part.rotMin = xmlFile:getValue(key .. "#rotMin" ) or - part.rotMax\n                part.rotation = { getRotation(part.node) }\n                part.initialRotation = { getRotation(part.node) }\n\n                part.rotStart = xmlFile:getValue(key .. "#rotStart" )\n                if part.rotStart ~ = nil then\n                    part.rotation[part.rotAxis] = part.rotStart\n                    part.initialRotation[part.rotAxis] = part.rotStart\n                    setRotation(part.node, part.initialRotation[ 1 ], part.initialRotation[ 2 ], part.initialRotation[ 3 ])\n                end\n            end\n\n            part.transAxis = xmlFile:getValue(key .. "#transAxis" , nil )\n            if part.transAxis ~ = nil then\n                part.transMax = xmlFile:getValue(key .. "#transMax" , 0 )\n                part.transMin = xmlFile:getValue(key .. "#transMin" ) or - part.transMax\n                part.translation = { getTranslation(part.node) }\n                part.initialTranslation = { getTranslation(part.node) }\n\n                part.transStart = xmlFile:getValue(key .. "#transStart" )\n                if part.transStart ~ = nil then\n                    part.translation[part.transAxis] = part.transStart\n                    part.initialTranslation[part.transAxis] = part.transStart\n                    setTranslation(part.node, part.initialTranslation[ 1 ], part.initialTranslation[ 2 ], part.initialTranslation[ 3 ])\n                end\n            end\n\n            if part.rotAxis = = nil and part.transAxis = = nil then\n                Logging.xmlWarning(xmlFile, "No rotation or translation axis for randomlyMovingPart in \'%s\'" , key)\n                    return false\n                end\n\n                part.nodes = { }\n                for _, nodeKey in xmlFile:iterator(key .. ".node" ) do\n                    local node = xmlFile:getValue(nodeKey .. "#node" , nil , self.components, self.i3dMappings)\n                    if node ~ = nil then\n                        local nodeData = { }\n                        nodeData.node = node\n                        nodeData.deltaScale = xmlFile:getValue(nodeKey .. "#scale" , 1 )\n\n                        nodeData.rotAxis = xmlFile:getValue(key .. "#rotAxis" , part.rotAxis)\n                        if nodeData.rotAxis ~ = nil then\n                            nodeData.rotMax = xmlFile:getValue(key .. "#rotMax" , part.rotMax or 0 )\n                            nodeData.rotMin = xmlFile:getValue(key .. "#rotMin" ) or - nodeData.rotMax\n                            nodeData.rotation = { getRotation(nodeData.node) }\n                            nodeData.initialRotation = { getRotation(nodeData.node) }\n\n                            nodeData.rotStart = xmlFile:getValue(key .. "#rotStart" )\n                            if nodeData.rotStart ~ = nil then\n                                nodeData.rotation[nodeData.rotAxis] = nodeData.rotStart\n                                nodeData.initialRotation[nodeData.rotAxis] = nodeData.rotStart\n                                setRotation(nodeData.node, nodeData.initialRotation[ 1 ], nodeData.initialRotation[ 2 ], nodeData.initialRotation[ 3 ])\n                            end\n                        end\n\n                        nodeData.transAxis = xmlFile:getValue(key .. "#transAxis" , part.transAxis)\n                        if nodeData.transAxis ~ = nil then\n                            nodeData.transMax = xmlFile:getValue(key .. "#transMax" , part.transMax or 0 )\n                            nodeData.transMin = xmlFile:getValue(key .. "#transMin" ) or - nodeData.transMax\n                            nodeData.translation = { getTranslation(nodeData.node) }\n                            nodeData.initialTranslation = { getTranslation(nodeData.node) }\n\n                            nodeData.transStart = xmlFile:getValue(key .. "#transStart" )\n                            if nodeData.transStart ~ = nil then\n                                nodeData.translation[nodeData.transAxis] = nodeData.transStart\n                                nodeData.initialTranslation[nodeData.transAxis] = nodeData.transStart\n                                setTranslation(nodeData.node, nodeData.initialTranslation[ 1 ], nodeData.initialTranslation[ 2 ], nodeData.initialTranslation[ 3 ])\n                            end\n                        end\n\n                        if part.rotAxis ~ = nil or part.transAxis ~ = nil then\n                            table.insert(part.nodes, nodeData)\n                        end\n                    end\n                end\n\n                part.isActive = true\n                part.time = math.random()\n                part.alpha = 0\n\n                return true\n            end\n\n'})}),"\n",(0,i.jsx)(e.h3,{id:"onload",children:"onLoad"}),"\n",(0,i.jsx)(e.p,{children:(0,i.jsx)(e.strong,{children:"Description"})}),"\n",(0,i.jsxs)(e.blockquote,{children:["\n",(0,i.jsx)(e.p,{children:"Called on loading"}),"\n"]}),"\n",(0,i.jsx)(e.p,{children:(0,i.jsx)(e.strong,{children:"Definition"})}),"\n",(0,i.jsxs)(e.blockquote,{children:["\n",(0,i.jsx)(e.p,{children:"onLoad(table savegame)"}),"\n"]}),"\n",(0,i.jsx)(e.p,{children:(0,i.jsx)(e.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n",(0,i.jsx)(e.table,{children:(0,i.jsx)(e.thead,{children:(0,i.jsxs)(e.tr,{children:[(0,i.jsx)(e.th,{children:"table"}),(0,i.jsx)(e.th,{children:"savegame"}),(0,i.jsx)(e.th,{children:"savegame"})]})})}),"\n",(0,i.jsx)(e.p,{children:(0,i.jsx)(e.strong,{children:"Code"})}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-lua",children:'function RandomlyMovingParts:onLoad(savegame)\n    local spec = self.spec_randomlyMovingParts\n\n    spec.maxUpdateDistance = self.xmlFile:getValue( "vehicle.randomlyMovingParts#maxUpdateDistance" , RandomlyMovingParts.DEFAULT_MAX_UPDATE_DISTANCE)\n\n    spec.nodes = { }\n\n    for _, key in self.xmlFile:iterator( "vehicle.randomlyMovingParts.randomlyMovingPart" ) do\n        local randomlyMovingPart = { }\n        if self:loadRandomlyMovingPartFromXML(randomlyMovingPart, self.xmlFile, key) then\n            table.insert(spec.nodes, randomlyMovingPart)\n        end\n    end\n\n    if not self.isClient or #spec.nodes = = 0 then\n        SpecializationUtil.removeEventListener( self , "onUpdate" , RandomlyMovingParts )\n    end\nend\n\n'})}),"\n",(0,i.jsx)(e.h3,{id:"onupdate",children:"onUpdate"}),"\n",(0,i.jsx)(e.p,{children:(0,i.jsx)(e.strong,{children:"Description"})}),"\n",(0,i.jsxs)(e.blockquote,{children:["\n",(0,i.jsx)(e.p,{children:"Called on update"}),"\n"]}),"\n",(0,i.jsx)(e.p,{children:(0,i.jsx)(e.strong,{children:"Definition"})}),"\n",(0,i.jsxs)(e.blockquote,{children:["\n",(0,i.jsx)(e.p,{children:"onUpdate(float dt, boolean isActiveForInput, boolean isSelected, )"}),"\n"]}),"\n",(0,i.jsx)(e.p,{children:(0,i.jsx)(e.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,i.jsxs)(e.table,{children:[(0,i.jsx)(e.thead,{children:(0,i.jsxs)(e.tr,{children:[(0,i.jsx)(e.th,{children:"float"}),(0,i.jsx)(e.th,{children:"dt"}),(0,i.jsx)(e.th,{children:"time since last call in ms"})]})}),(0,i.jsxs)(e.tbody,{children:[(0,i.jsxs)(e.tr,{children:[(0,i.jsx)(e.td,{children:"boolean"}),(0,i.jsx)(e.td,{children:"isActiveForInput"}),(0,i.jsx)(e.td,{children:"true if vehicle is active for input"})]}),(0,i.jsxs)(e.tr,{children:[(0,i.jsx)(e.td,{children:"boolean"}),(0,i.jsx)(e.td,{children:"isSelected"}),(0,i.jsx)(e.td,{children:"true if vehicle is selected"})]}),(0,i.jsxs)(e.tr,{children:[(0,i.jsx)(e.td,{children:"any"}),(0,i.jsx)(e.td,{children:"isSelected"}),(0,i.jsx)(e.td,{})]})]})]}),"\n",(0,i.jsx)(e.p,{children:(0,i.jsx)(e.strong,{children:"Code"})}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-lua",children:"function RandomlyMovingParts:onUpdate(dt, isActiveForInput, isActiveForInputIgnoreSelection, isSelected)\n    local spec = self.spec_randomlyMovingParts\n    if self.currentUpdateDistance < spec.maxUpdateDistance then\n        if self:getLastSpeed() > 0.1 then\n            for _, part in pairs(spec.nodes) do\n                self:updateRandomlyMovingPart(part, dt)\n            end\n        end\n    end\nend\n\n"})}),"\n",(0,i.jsx)(e.h3,{id:"prerequisitespresent",children:"prerequisitesPresent"}),"\n",(0,i.jsx)(e.p,{children:(0,i.jsx)(e.strong,{children:"Description"})}),"\n",(0,i.jsxs)(e.blockquote,{children:["\n",(0,i.jsx)(e.p,{children:"Checks if all prerequisite specializations are loaded"}),"\n"]}),"\n",(0,i.jsx)(e.p,{children:(0,i.jsx)(e.strong,{children:"Definition"})}),"\n",(0,i.jsxs)(e.blockquote,{children:["\n",(0,i.jsx)(e.p,{children:"prerequisitesPresent(table specializations)"}),"\n"]}),"\n",(0,i.jsx)(e.p,{children:(0,i.jsx)(e.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n",(0,i.jsx)(e.table,{children:(0,i.jsx)(e.thead,{children:(0,i.jsxs)(e.tr,{children:[(0,i.jsx)(e.th,{children:"table"}),(0,i.jsx)(e.th,{children:"specializations"}),(0,i.jsx)(e.th,{children:"specializations"})]})})}),"\n",(0,i.jsx)(e.p,{children:(0,i.jsx)(e.strong,{children:"Return Values"})}),"\n\n\n\n\n\n\n\n\n",(0,i.jsx)(e.table,{children:(0,i.jsx)(e.thead,{children:(0,i.jsxs)(e.tr,{children:[(0,i.jsx)(e.th,{children:"table"}),(0,i.jsx)(e.th,{children:"hasPrerequisite"}),(0,i.jsx)(e.th,{children:"true if all prerequisite specializations are loaded"})]})})}),"\n",(0,i.jsx)(e.p,{children:(0,i.jsx)(e.strong,{children:"Code"})}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-lua",children:"function RandomlyMovingParts.prerequisitesPresent(specializations)\n    return true\nend\n\n"})}),"\n",(0,i.jsx)(e.h3,{id:"registereventlisteners",children:"registerEventListeners"}),"\n",(0,i.jsx)(e.p,{children:(0,i.jsx)(e.strong,{children:"Description"})}),"\n",(0,i.jsx)(e.p,{children:(0,i.jsx)(e.strong,{children:"Definition"})}),"\n",(0,i.jsxs)(e.blockquote,{children:["\n",(0,i.jsx)(e.p,{children:"registerEventListeners()"}),"\n"]}),"\n",(0,i.jsx)(e.p,{children:(0,i.jsx)(e.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,i.jsx)(e.table,{children:(0,i.jsx)(e.thead,{children:(0,i.jsxs)(e.tr,{children:[(0,i.jsx)(e.th,{children:"any"}),(0,i.jsx)(e.th,{children:"vehicleType"})]})})}),"\n",(0,i.jsx)(e.p,{children:(0,i.jsx)(e.strong,{children:"Code"})}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-lua",children:'function RandomlyMovingParts.registerEventListeners(vehicleType)\n    SpecializationUtil.registerEventListener(vehicleType, "onLoad" , RandomlyMovingParts )\n    SpecializationUtil.registerEventListener(vehicleType, "onUpdate" , RandomlyMovingParts )\nend\n\n'})}),"\n",(0,i.jsx)(e.h3,{id:"registerfunctions",children:"registerFunctions"}),"\n",(0,i.jsx)(e.p,{children:(0,i.jsx)(e.strong,{children:"Description"})}),"\n",(0,i.jsx)(e.p,{children:(0,i.jsx)(e.strong,{children:"Definition"})}),"\n",(0,i.jsxs)(e.blockquote,{children:["\n",(0,i.jsx)(e.p,{children:"registerFunctions()"}),"\n"]}),"\n",(0,i.jsx)(e.p,{children:(0,i.jsx)(e.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,i.jsx)(e.table,{children:(0,i.jsx)(e.thead,{children:(0,i.jsxs)(e.tr,{children:[(0,i.jsx)(e.th,{children:"any"}),(0,i.jsx)(e.th,{children:"vehicleType"})]})})}),"\n",(0,i.jsx)(e.p,{children:(0,i.jsx)(e.strong,{children:"Code"})}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-lua",children:'function RandomlyMovingParts.registerFunctions(vehicleType)\n    SpecializationUtil.registerFunction(vehicleType, "loadRandomlyMovingPartFromXML" , RandomlyMovingParts.loadRandomlyMovingPartFromXML)\n    SpecializationUtil.registerFunction(vehicleType, "updateRandomlyMovingPart" , RandomlyMovingParts.updateRandomlyMovingPart)\n    SpecializationUtil.registerFunction(vehicleType, "getIsRandomlyMovingPartActive" , RandomlyMovingParts.getIsRandomlyMovingPartActive)\nend\n\n'})}),"\n",(0,i.jsx)(e.h3,{id:"updaterandomlymovingpart",children:"updateRandomlyMovingPart"}),"\n",(0,i.jsx)(e.p,{children:(0,i.jsx)(e.strong,{children:"Description"})}),"\n",(0,i.jsxs)(e.blockquote,{children:["\n",(0,i.jsx)(e.p,{children:"Update randomly moving parts"}),"\n"]}),"\n",(0,i.jsx)(e.p,{children:(0,i.jsx)(e.strong,{children:"Definition"})}),"\n",(0,i.jsxs)(e.blockquote,{children:["\n",(0,i.jsx)(e.p,{children:"updateRandomlyMovingPart(table part, float dt)"}),"\n"]}),"\n",(0,i.jsx)(e.p,{children:(0,i.jsx)(e.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,i.jsxs)(e.table,{children:[(0,i.jsx)(e.thead,{children:(0,i.jsxs)(e.tr,{children:[(0,i.jsx)(e.th,{children:"table"}),(0,i.jsx)(e.th,{children:"part"}),(0,i.jsx)(e.th,{children:"part to update"})]})}),(0,i.jsx)(e.tbody,{children:(0,i.jsxs)(e.tr,{children:[(0,i.jsx)(e.td,{children:"float"}),(0,i.jsx)(e.td,{children:"dt"}),(0,i.jsx)(e.td,{children:"time since last call in ms"})]})})]}),"\n",(0,i.jsx)(e.p,{children:(0,i.jsx)(e.strong,{children:"Return Values"})}),"\n\n\n\n\n\n\n\n\n",(0,i.jsx)(e.table,{children:(0,i.jsx)(e.thead,{children:(0,i.jsxs)(e.tr,{children:[(0,i.jsx)(e.th,{children:"float"}),(0,i.jsx)(e.th,{children:"updated"}),(0,i.jsx)(e.th,{children:"part was updated"})]})})}),"\n",(0,i.jsx)(e.p,{children:(0,i.jsx)(e.strong,{children:"Code"})}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-lua",children:"function RandomlyMovingParts:updateRandomlyMovingPart(part, dt)\n    local speed\n    if part.isSpeedDependent then\n        speed = self.lastMovedDistance * self.movingDirection * 0.2\n    else\n            speed = dt * 0.00033\n        end\n\n        part.isActive = self:getIsRandomlyMovingPartActive(part)\n\n        if part.isActive then\n            if part.alpha < 1 then\n                part.alpha = math.min(part.alpha + dt * part.fadeTime, 1 )\n            end\n\n            if part.hasBumps then\n                if not part.isSpeedDependent or self:getLastSpeed() > 1 then\n                    part.bumpNextTime = part.bumpNextTime - dt\n                    if part.bumpNextTime < = 0 then\n                        part.bumpTimer = part.bumpDuration\n                        part.bumpNextTime = part.bumpFrequency * math.random()\n                    end\n                end\n\n                if part.bumpTimer > 0 then\n                    part.bumpTimer = part.bumpTimer - dt\n                end\n            end\n        else\n                if part.alpha > 0 then\n                    part.alpha = math.max(part.alpha - dt * part.fadeTime, 0 )\n                end\n            end\n\n            if part.alpha > 0 then\n                part.time = part.time + speed * part.speedScale\n\n                local delta = math.sin(part.time * part.noiseFrequency[ 1 ]) * part.noiseAmount[ 1 ] + math.sin(part.time * part.noiseFrequency[ 2 ]) * part.noiseAmount[ 2 ] + math.sin(part.time * part.noiseFrequency[ 3 ]) * part.noiseAmount[ 3 ]\n\n                if part.hasBumps then\n                    if part.bumpTimer > 0 then\n                        local bumpAlpha = 1 - (part.bumpTimer / part.bumpDuration)\n                        delta = math.min(delta + math.sin(bumpAlpha * math.pi), 1 )\n                    end\n                end\n\n                updateNodeData( self , part, delta, part.alpha)\n\n                for i, nodeData in ipairs(part.nodes) do\n                    updateNodeData( self , nodeData, delta, part.alpha)\n                end\n            end\n        end\n\n"})})]})}function p(n={}){const{wrapper:e}={...(0,r.R)(),...n.components};return e?(0,i.jsx)(e,{...n,children:(0,i.jsx)(c,{...n})}):c(n)}}}]);