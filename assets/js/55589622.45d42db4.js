"use strict";(globalThis.webpackChunkfs25_community_luadoc=globalThis.webpackChunkfs25_community_luadoc||[]).push([[74191],{8313(e,n,l){l.r(n),l.d(n,{assets:()=>d,contentTitle:()=>r,default:()=>h,frontMatter:()=>s,metadata:()=>i,toc:()=>a});const i=JSON.parse('{"id":"script/Specializations/FillVolume","title":"FillVolume","description":"FillVolume","source":"@site/../docs/script/Specializations/FillVolume.md","sourceDirName":"script/Specializations","slug":"/script/Specializations/FillVolume","permalink":"/FS25-Community-LUADOC/script/Specializations/FillVolume","draft":false,"unlisted":false,"tags":[],"version":"current","lastUpdatedAt":1767161192000,"frontMatter":{},"sidebar":"docsSidebar","previous":{"title":"FillUnit","permalink":"/FS25-Community-LUADOC/script/Specializations/FillUnit"},"next":{"title":"Foldable","permalink":"/FS25-Community-LUADOC/script/Specializations/Foldable"}}');var o=l(74848),t=l(28453);const s={},r=void 0,d={},a=[{value:"FillVolume",id:"fillvolume",level:2},{value:"getFillVolumeIndicesByFillUnitIndex",id:"getfillvolumeindicesbyfillunitindex",level:3},{value:"getFillVolumeLoadInfo",id:"getfillvolumeloadinfo",level:3},{value:"getFillVolumeUnloadInfo",id:"getfillvolumeunloadinfo",level:3},{value:"getFillVolumeUVScrollSpeed",id:"getfillvolumeuvscrollspeed",level:3},{value:"initSpecialization",id:"initspecialization",level:3},{value:"loadExtraDependentParts",id:"loadextradependentparts",level:3},{value:"loadFillVolume",id:"loadfillvolume",level:3},{value:"loadFillVolumeHeightNode",id:"loadfillvolumeheightnode",level:3},{value:"loadFillVolumeInfo",id:"loadfillvolumeinfo",level:3},{value:"onDelete",id:"ondelete",level:3},{value:"onFillUnitFillLevelChanged",id:"onfillunitfilllevelchanged",level:3},{value:"onLoad",id:"onload",level:3},{value:"onReadUpdateStream",id:"onreadupdatestream",level:3},{value:"onUpdate",id:"onupdate",level:3},{value:"onWriteUpdateStream",id:"onwriteupdatestream",level:3},{value:"prerequisitesPresent",id:"prerequisitespresent",level:3},{value:"registerEventListeners",id:"registereventlisteners",level:3},{value:"registerFunctions",id:"registerfunctions",level:3},{value:"registerInfoNodeXMLPaths",id:"registerinfonodexmlpaths",level:3},{value:"registerOverwrittenFunctions",id:"registeroverwrittenfunctions",level:3},{value:"setFillVolumeForcedFillType",id:"setfillvolumeforcedfilltype",level:3},{value:"setFillVolumeForcedFillTypeByFillUnitIndex",id:"setfillvolumeforcedfilltypebyfillunitindex",level:3},{value:"setMovingToolDirty",id:"setmovingtooldirty",level:3},{value:"updateDebugValues",id:"updatedebugvalues",level:3},{value:"updateExtraDependentParts",id:"updateextradependentparts",level:3}];function c(e){const n={a:"a",blockquote:"blockquote",code:"code",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,t.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(n.h2,{id:"fillvolume",children:"FillVolume"}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Description"})}),"\n",(0,o.jsxs)(n.blockquote,{children:["\n",(0,o.jsx)(n.p,{children:"Specialization for visual fill volumes/planes; requires FillUnit specialization"}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Functions"})}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.a,{href:"#getfillvolumeindicesbyfillunitindex",children:"getFillVolumeIndicesByFillUnitIndex"})}),"\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.a,{href:"#getfillvolumeloadinfo",children:"getFillVolumeLoadInfo"})}),"\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.a,{href:"#getfillvolumeunloadinfo",children:"getFillVolumeUnloadInfo"})}),"\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.a,{href:"#getfillvolumeuvscrollspeed",children:"getFillVolumeUVScrollSpeed"})}),"\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.a,{href:"#initspecialization",children:"initSpecialization"})}),"\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.a,{href:"#loadextradependentparts",children:"loadExtraDependentParts"})}),"\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.a,{href:"#loadfillvolume",children:"loadFillVolume"})}),"\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.a,{href:"#loadfillvolumeheightnode",children:"loadFillVolumeHeightNode"})}),"\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.a,{href:"#loadfillvolumeinfo",children:"loadFillVolumeInfo"})}),"\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.a,{href:"#ondelete",children:"onDelete"})}),"\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.a,{href:"#onfillunitfilllevelchanged",children:"onFillUnitFillLevelChanged"})}),"\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.a,{href:"#onload",children:"onLoad"})}),"\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.a,{href:"#onreadupdatestream",children:"onReadUpdateStream"})}),"\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.a,{href:"#onupdate",children:"onUpdate"})}),"\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.a,{href:"#onwriteupdatestream",children:"onWriteUpdateStream"})}),"\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.a,{href:"#prerequisitespresent",children:"prerequisitesPresent"})}),"\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.a,{href:"#registereventlisteners",children:"registerEventListeners"})}),"\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.a,{href:"#registerfunctions",children:"registerFunctions"})}),"\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.a,{href:"#registerinfonodexmlpaths",children:"registerInfoNodeXMLPaths"})}),"\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.a,{href:"#registeroverwrittenfunctions",children:"registerOverwrittenFunctions"})}),"\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.a,{href:"#setfillvolumeforcedfilltype",children:"setFillVolumeForcedFillType"})}),"\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.a,{href:"#setfillvolumeforcedfilltypebyfillunitindex",children:"setFillVolumeForcedFillTypeByFillUnitIndex"})}),"\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.a,{href:"#setmovingtooldirty",children:"setMovingToolDirty"})}),"\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.a,{href:"#updatedebugvalues",children:"updateDebugValues"})}),"\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.a,{href:"#updateextradependentparts",children:"updateExtraDependentParts"})}),"\n"]}),"\n",(0,o.jsx)(n.h3,{id:"getfillvolumeindicesbyfillunitindex",children:"getFillVolumeIndicesByFillUnitIndex"}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Description"})}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Definition"})}),"\n",(0,o.jsxs)(n.blockquote,{children:["\n",(0,o.jsx)(n.p,{children:"getFillVolumeIndicesByFillUnitIndex()"}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,o.jsx)(n.table,{children:(0,o.jsx)(n.thead,{children:(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.th,{children:"any"}),(0,o.jsx)(n.th,{children:"fillUnitIndex"})]})})}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Code"})}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-lua",children:"function FillVolume:getFillVolumeIndicesByFillUnitIndex(fillUnitIndex)\n    local spec = self.spec_fillVolume\n    local indices = { }\n    for i, fillVolume in ipairs(spec.volumes) do\n        if fillVolume.fillUnitIndex = = fillUnitIndex then\n            table.insert(indices, i)\n        end\n    end\n\n    return indices\nend\n\n"})}),"\n",(0,o.jsx)(n.h3,{id:"getfillvolumeloadinfo",children:"getFillVolumeLoadInfo"}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Description"})}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Definition"})}),"\n",(0,o.jsxs)(n.blockquote,{children:["\n",(0,o.jsx)(n.p,{children:"getFillVolumeLoadInfo()"}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,o.jsx)(n.table,{children:(0,o.jsx)(n.thead,{children:(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.th,{children:"any"}),(0,o.jsx)(n.th,{children:"loadInfoIndex"})]})})}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Code"})}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-lua",children:"function FillVolume:getFillVolumeLoadInfo(loadInfoIndex)\n    local spec = self.spec_fillVolume\n    return spec.loadInfos[loadInfoIndex]\nend\n\n"})}),"\n",(0,o.jsx)(n.h3,{id:"getfillvolumeunloadinfo",children:"getFillVolumeUnloadInfo"}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Description"})}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Definition"})}),"\n",(0,o.jsxs)(n.blockquote,{children:["\n",(0,o.jsx)(n.p,{children:"getFillVolumeUnloadInfo()"}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,o.jsx)(n.table,{children:(0,o.jsx)(n.thead,{children:(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.th,{children:"any"}),(0,o.jsx)(n.th,{children:"unloadInfoIndex"})]})})}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Code"})}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-lua",children:"function FillVolume:getFillVolumeUnloadInfo(unloadInfoIndex)\n    local spec = self.spec_fillVolume\n    return spec.unloadInfos[unloadInfoIndex]\nend\n\n"})}),"\n",(0,o.jsx)(n.h3,{id:"getfillvolumeuvscrollspeed",children:"getFillVolumeUVScrollSpeed"}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Description"})}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Definition"})}),"\n",(0,o.jsxs)(n.blockquote,{children:["\n",(0,o.jsx)(n.p,{children:"getFillVolumeUVScrollSpeed()"}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Code"})}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-lua",children:"function FillVolume:getFillVolumeUVScrollSpeed()\n    return 0 , 0 , 0\nend\n\n"})}),"\n",(0,o.jsx)(n.h3,{id:"initspecialization",children:"initSpecialization"}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Description"})}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Definition"})}),"\n",(0,o.jsxs)(n.blockquote,{children:["\n",(0,o.jsx)(n.p,{children:"initSpecialization()"}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Code"})}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-lua",children:'function FillVolume.initSpecialization()\n    g_vehicleConfigurationManager:addConfigurationType( "fillVolume" , g_i18n:getText( "configuration_fillVolume" ), "fillVolume" , VehicleConfigurationItem )\n\n    local schema = Vehicle.xmlSchema\n    schema:setXMLSpecializationType( "FillVolume" )\n\n    local basePath = "vehicle.fillVolume.fillVolumeConfigurations.fillVolumeConfiguration(?)"\n\n    schema:register(XMLValueType.NODE_INDEX, basePath .. ".volumes.volume(?)#node" , "Fill volume node" )\n    schema:register(XMLValueType.INT, basePath .. ".volumes.volume(?)#fillUnitIndex" , "Fill unit index" )\n    schema:register(XMLValueType.FLOAT, basePath .. ".volumes.volume(?)#fillUnitFactor" , "Fill unit factor" , 1 )\n    schema:register(XMLValueType.BOOL, basePath .. ".volumes.volume(?)#useFullCapacity" , "Defines if the fill volume represents the full fill unit capacity when multiple fill volumes are given.If set to \'false\' (default), the fill level is split across the defined volumes.If set to \'true\' all fill up the same." , true )\n        schema:register(XMLValueType.BOOL, basePath .. ".volumes.volume(?)#allSidePlanes" , "All side planes" , true )\n        schema:register(XMLValueType.BOOL, basePath .. ".volumes.volume(?)#retessellateTop" , "Retessellate top plane for better triangulation quality" , false )\n\n            schema:register(XMLValueType.STRING, basePath .. ".volumes.volume(?)#defaultFillType" , "Default fill type name" )\n            schema:register(XMLValueType.STRING, basePath .. ".volumes.volume(?)#forcedVolumeFillType" , "Forced fill type name" )\n\n            schema:register(XMLValueType.FLOAT, basePath .. ".volumes.volume(?)#maxDelta" , "Max.heap size above above input surface [m]" , 1.0 )\n            schema:register(XMLValueType.ANGLE, basePath .. ".volumes.volume(?)#maxAllowedHeapAngle" , "Max.allowed heap surface slope angle [deg]" , 35 )\n            schema:register(XMLValueType.FLOAT, basePath .. ".volumes.volume(?)#maxSurfaceDistanceError" , "Max.allowed distance from input mesh surface to created fill plane mesh [m]" , 0.05 )\n            schema:register(XMLValueType.FLOAT, basePath .. ".volumes.volume(?)#maxSubDivEdgeLength" , "Max.length of sub division edges [m]" , 0.9 )\n            schema:register(XMLValueType.FLOAT, basePath .. ".volumes.volume(?)#syncMaxSubDivEdgeLength" , "Max.length of sub division edges used to sync in multiplayer [m]" , 1.35 )\n\n            schema:register(XMLValueType.NODE_INDEX, basePath .. ".volumes.volume(?).deformNode(?)#node" , "Deformer node" )\n\n            FillVolume.registerInfoNodeXMLPaths(schema, "vehicle.fillVolume.loadInfos.loadInfo(?)" )\n            FillVolume.registerInfoNodeXMLPaths(schema, "vehicle.fillVolume.unloadInfos.unloadInfo(?)" )\n\n            schema:register(XMLValueType.INT, "vehicle.fillVolume.heightNodes.heightNode(?)#fillVolumeIndex" , "Fill volume index" )\n            schema:register(XMLValueType.NODE_INDEX, "vehicle.fillVolume.heightNodes.heightNode(?).refNode(?)#node" , "Reference node" )\n\n            schema:register(XMLValueType.NODE_INDEX, "vehicle.fillVolume.heightNodes.heightNode(?).node(?)#node" , "Height node" )\n            schema:register(XMLValueType.VECTOR_SCALE, "vehicle.fillVolume.heightNodes.heightNode(?).node(?)#baseScale" , "Base scale" , "1 1 1" )\n            schema:register(XMLValueType.VECTOR_ 3 , "vehicle.fillVolume.heightNodes.heightNode(?).node(?)#scaleAxis" , "Scale axis" , "0 0 0" )\n            schema:register(XMLValueType.VECTOR_SCALE, "vehicle.fillVolume.heightNodes.heightNode(?).node(?)#scaleMax" , "Max.scale" , "0 0 0" )\n            schema:register(XMLValueType.VECTOR_ 3 , "vehicle.fillVolume.heightNodes.heightNode(?).node(?)#transAxis" , "Translation axis" , "0 0 0" )\n            schema:register(XMLValueType.VECTOR_TRANS, "vehicle.fillVolume.heightNodes.heightNode(?).node(?)#transMax" , "Max.translation" , "0 0 0" )\n            schema:register(XMLValueType.FLOAT, "vehicle.fillVolume.heightNodes.heightNode(?).node(?)#minHeight" , "Min.fill volume height used for height node" , 0 )\n                schema:register(XMLValueType.FLOAT, "vehicle.fillVolume.heightNodes.heightNode(?).node(?)#heightOffset" , "Fill plane height offset" , 0 )\n                schema:register(XMLValueType.BOOL, "vehicle.fillVolume.heightNodes.heightNode(?).node(?)#orientateToWorldY" , "Orientate to world Y" , false )\n\n                schema:addDelayedRegistrationFunc( "Cylindered:movingTool" , function (cSchema, cKey)\n                    cSchema:register(XMLValueType.INT, cKey .. ".fillVolume#fillVolumeIndex" , "Fill Unit index which includes the deformers" , 1 )\n                    cSchema:register(XMLValueType.VECTOR_N, cKey .. ".fillVolume#deformerNodeIndices" , "Indices of deformer nodes to update" )\n                end )\n\n                schema:addDelayedRegistrationFunc( "Cylindered:movingPart" , function (cSchema, cKey)\n                    cSchema:register(XMLValueType.INT, cKey .. ".fillVolume#fillVolumeIndex" , "Fill Unit index which includes the deformers" , 1 )\n                    cSchema:register(XMLValueType.VECTOR_N, cKey .. ".fillVolume#deformerNodeIndices" , "Indices of deformer nodes to update" )\n                end )\n\n                schema:setXMLSpecializationType()\n            end\n\n'})}),"\n",(0,o.jsx)(n.h3,{id:"loadextradependentparts",children:"loadExtraDependentParts"}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Description"})}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Definition"})}),"\n",(0,o.jsxs)(n.blockquote,{children:["\n",(0,o.jsx)(n.p,{children:"loadExtraDependentParts()"}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,o.jsxs)(n.table,{children:[(0,o.jsx)(n.thead,{children:(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.th,{children:"any"}),(0,o.jsx)(n.th,{children:"superFunc"})]})}),(0,o.jsxs)(n.tbody,{children:[(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:"any"}),(0,o.jsx)(n.td,{children:"xmlFile"})]}),(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:"any"}),(0,o.jsx)(n.td,{children:"baseName"})]}),(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:"any"}),(0,o.jsx)(n.td,{children:"entry"})]})]})]}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Code"})}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-lua",children:'function FillVolume:loadExtraDependentParts(superFunc, xmlFile, baseName, entry)\n    if not superFunc( self , xmlFile, baseName, entry) then\n        return false\n    end\n\n    local fillVolumeIndex = xmlFile:getValue(baseName .. ".fillVolume#fillVolumeIndex" , 1 )\n\n    local indices = xmlFile:getValue(baseName .. ".fillVolume#deformerNodeIndices" , nil , true )\n    if indices ~ = nil and #indices > 0 then\n        entry.fillVolumeIndex = fillVolumeIndex\n        entry.deformerNodes = { }\n\n        for i = 1 , #indices do\n            table.insert(entry.deformerNodes, indices[i])\n        end\n    end\n\n    return true\nend\n\n'})}),"\n",(0,o.jsx)(n.h3,{id:"loadfillvolume",children:"loadFillVolume"}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Description"})}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Definition"})}),"\n",(0,o.jsxs)(n.blockquote,{children:["\n",(0,o.jsx)(n.p,{children:"loadFillVolume()"}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,o.jsxs)(n.table,{children:[(0,o.jsx)(n.thead,{children:(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.th,{children:"any"}),(0,o.jsx)(n.th,{children:"xmlFile"})]})}),(0,o.jsxs)(n.tbody,{children:[(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:"any"}),(0,o.jsx)(n.td,{children:"key"})]}),(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:"any"}),(0,o.jsx)(n.td,{children:"entry"})]})]})]}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Code"})}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-lua",children:'function FillVolume:loadFillVolume(xmlFile, key, entry)\n    local spec = self.spec_fillVolume\n    XMLUtil.checkDeprecatedXMLElements(xmlFile, key .. "#index" , key .. "#node" ) -- FS17\n\n    entry.baseNode = xmlFile:getValue(key .. "#node" , nil , self.components, self.i3dMappings)\n    if entry.baseNode = = nil then\n        printWarning( "Warning:fillVolume \'" .. tostring(key) .. "\' has an invalid \'node\' in \'" .. self.configFileName .. "\'!" )\n        return false\n    end\n\n    if not getHasClassId(entry.baseNode, ClassIds.SHAPE) then\n        Logging.xmlWarning(xmlFile, "fillVolume \'" .. getName(entry.baseNode) .. "\' at \'" .. tostring(key) .. "\' is not a shape!" )\n        return false\n    end\n\n    local fillUnitIndex = xmlFile:getValue(key .. "#fillUnitIndex" )\n    entry.fillUnitIndex = fillUnitIndex\n    if fillUnitIndex = = nil then\n        printWarning( "Warning:fillVolume \'" .. tostring(key) .. "\' has no \'fillUnitIndex\' given in \'" .. self.configFileName .. "\'!" )\n        return false\n    end\n    if not self:getFillUnitExists(fillUnitIndex) then\n        printWarning( "Warning:fillVolume \'" .. tostring(key) .. "\' has an invalid \'fillUnitIndex\' in \'" .. self.configFileName .. "\'!" )\n        return false\n    end\n\n    entry.fillUnitFactor = xmlFile:getValue(key .. "#fillUnitFactor" , 1.0 )\n    entry.useFullCapacity = xmlFile:getValue(key .. "#useFullCapacity" , true )\n\n    if spec.fillUnitFillVolumeMapping[fillUnitIndex] = = nil then\n        spec.fillUnitFillVolumeMapping[fillUnitIndex] = { fillVolumes = { } , sumFactors = 0 }\n    end\n    table.insert(spec.fillUnitFillVolumeMapping[fillUnitIndex].fillVolumes, entry)\n    spec.fillUnitFillVolumeMapping[fillUnitIndex].sumFactors = spec.fillUnitFillVolumeMapping[fillUnitIndex].sumFactors + entry.fillUnitFactor\n\n    entry.allSidePlanes = xmlFile:getValue(key .. "#allSidePlanes" , true )\n    entry.retessellateTop = xmlFile:getValue(key .. "#retessellateTop" , false )\n\n    local defaultFillTypeStr = xmlFile:getValue(key .. "#defaultFillType" )\n    if defaultFillTypeStr ~ = nil then\n        local defaultFillTypeIndex = g_fillTypeManager:getFillTypeIndexByName(defaultFillTypeStr)\n        if defaultFillTypeIndex = = nil then\n            printWarning( "Warning:Invalid defaultFillType \'" .. tostring(defaultFillTypeStr) .. "\' for \'" .. tostring(key) .. "\' in \'" .. self.configFileName .. "\'" )\n                return false\n            else\n                    entry.defaultFillType = defaultFillTypeIndex\n                end\n            else\n                    entry.defaultFillType = self:getFillUnitFirstSupportedFillType(fillUnitIndex)\n                end\n\n                local forcedVolumeFillTypeStr = xmlFile:getValue(key .. "#forcedVolumeFillType" )\n                if forcedVolumeFillTypeStr ~ = nil then\n                    local forcedVolumeFillTypeIndex = g_fillTypeManager:getFillTypeIndexByName(forcedVolumeFillTypeStr)\n                    if forcedVolumeFillTypeIndex ~ = nil then\n                        entry.forcedVolumeFillType = forcedVolumeFillTypeIndex\n                    else\n                            printWarning( "Warning:Invalid forcedVolumeFillType \'" .. tostring(forcedVolumeFillTypeStr) .. "\' for \'" .. tostring(key) .. "\' in \'" .. self.configFileName .. "\'" )\n                                return false\n                            end\n                        end\n\n                        entry.maxDelta = xmlFile:getValue(key .. "#maxDelta" , 1.0 )\n                        entry.maxSurfaceAngle = xmlFile:getValue(key .. "#maxAllowedHeapAngle" , 35 )\n\n                        entry.maxPhysicalSurfaceAngle = math.rad( 35 )\n                        entry.maxSurfaceDistanceError = xmlFile:getValue(key .. "#maxSurfaceDistanceError" , 0.05 )\n                        entry.maxSubDivEdgeLength = xmlFile:getValue(key .. "#maxSubDivEdgeLength" , 0.9 )\n                        entry.syncMaxSubDivEdgeLength = xmlFile:getValue(key .. "#syncMaxSubDivEdgeLength" , 1.35 )\n\n                        entry.uvPosition = { 0 , 0 , 0 }\n\n                        entry.deformers = { }\n                        local j = 0\n                        while true do\n                            local deformerKey = string.format( "%s.deformNode(%d)" , key, j)\n                            if not xmlFile:hasProperty(deformerKey) then\n                                break\n                            end\n\n                            XMLUtil.checkDeprecatedXMLElements(xmlFile, deformerKey .. "#index" , deformerKey .. "#node" ) -- FS17\n\n                            local node = xmlFile:getValue(deformerKey .. "#node" , nil , self.components, self.i3dMappings)\n                            if node ~ = nil then\n                                local initPos = { localToLocal(node, entry.baseNode, 0 , 0 , 0 ) }\n                                local deformer = { node = node, initPos = initPos, posX = initPos[ 1 ], posZ = initPos[ 3 ], polyline = nil , volume = entry.volume, baseNode = entry.baseNode }\n                                table.insert(entry.deformers, deformer)\n                                spec.fillVolumeDeformersByNode[node] = deformer\n                            end\n                            j = j + 1\n                        end\n\n                        entry.lastFillType = FillType.UNKNOWN\n\n                        return true\n                    end\n\n'})}),"\n",(0,o.jsx)(n.h3,{id:"loadfillvolumeheightnode",children:"loadFillVolumeHeightNode"}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Description"})}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Definition"})}),"\n",(0,o.jsxs)(n.blockquote,{children:["\n",(0,o.jsx)(n.p,{children:"loadFillVolumeHeightNode()"}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,o.jsxs)(n.table,{children:[(0,o.jsx)(n.thead,{children:(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.th,{children:"any"}),(0,o.jsx)(n.th,{children:"xmlFile"})]})}),(0,o.jsxs)(n.tbody,{children:[(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:"any"}),(0,o.jsx)(n.td,{children:"key"})]}),(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:"any"}),(0,o.jsx)(n.td,{children:"entry"})]})]})]}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Code"})}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-lua",children:'function FillVolume:loadFillVolumeHeightNode(xmlFile, key, entry)\n    entry.isDirty = false\n\n    entry.fillVolumeIndex = xmlFile:getValue(key .. "#fillVolumeIndex" , 1 )\n\n    if self.spec_fillVolume.volumes[entry.fillVolumeIndex] = = nil then\n        Logging.xmlWarning( self.xmlFile, "Invalid fillVolumeIndex \'%d\' for heightNode \'%s\'.Igoring heightNode!" , entry.fillVolumeIndex, key)\n            return false\n        end\n\n        entry.refNodes = { }\n        local i = 0\n        while true do\n            local nodeKey = key .. string.format( ".refNode(%d)" , i)\n            if not xmlFile:hasProperty(nodeKey) then\n                break\n            end\n\n            XMLUtil.checkDeprecatedXMLElements(xmlFile, nodeKey .. "#index" , nodeKey .. "#node" ) -- FS17 to FS19\n\n            local node = xmlFile:getValue(nodeKey .. "#node" , nil , self.components, self.i3dMappings)\n            if node ~ = nil then\n                table.insert(entry.refNodes, { refNode = node } )\n            else\n                    Logging.xmlWarning( self.xmlFile, "Missing node for \'%s\'" , nodeKey)\n                    end\n\n                    i = i + 1\n                end\n\n                entry.nodes = { }\n                i = 0\n                while true do\n                    local nodeKey = key .. string.format( ".node(%d)" , i)\n                    if not xmlFile:hasProperty(nodeKey) then\n                        break\n                    end\n\n                    XMLUtil.checkDeprecatedXMLElements(xmlFile, nodeKey .. "#index" , nodeKey .. "#node" ) -- FS17 to FS19\n\n                    local node = xmlFile:getValue(nodeKey .. "#node" , nil , self.components, self.i3dMappings)\n                    if node ~ = nil then\n                        local nodeEntry = { }\n                        nodeEntry.node = node\n                        nodeEntry.baseScale = xmlFile:getValue(nodeKey .. "#baseScale" , "1 1 1" , true )\n                        nodeEntry.scaleAxis = xmlFile:getValue(nodeKey .. "#scaleAxis" , "0 0 0" , true )\n                        nodeEntry.scaleMax = xmlFile:getValue(nodeKey .. "#scaleMax" , "0 0 0" , true )\n                        nodeEntry.basePosition = { getTranslation(node) }\n                        nodeEntry.transAxis = xmlFile:getValue(nodeKey .. "#transAxis" , "0 0 0" , true )\n                        nodeEntry.transMax = xmlFile:getValue(nodeKey .. "#transMax" , "0 0 0" , true )\n                        nodeEntry.minHeight = xmlFile:getValue(nodeKey .. "#minHeight" , 0 )\n                        nodeEntry.heightOffset = xmlFile:getValue(nodeKey .. "#heightOffset" , 0 )\n                        nodeEntry.orientateToWorldY = xmlFile:getValue(nodeKey .. "#orientateToWorldY" , false )\n                        table.insert(entry.nodes, nodeEntry)\n                    else\n                            Logging.xmlWarning( self.xmlFile, "Missing node for \'%s\'" , nodeKey)\n                            end\n\n                            i = i + 1\n                        end\n\n                        return true\n                    end\n\n'})}),"\n",(0,o.jsx)(n.h3,{id:"loadfillvolumeinfo",children:"loadFillVolumeInfo"}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Description"})}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Definition"})}),"\n",(0,o.jsxs)(n.blockquote,{children:["\n",(0,o.jsx)(n.p,{children:"loadFillVolumeInfo()"}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,o.jsxs)(n.table,{children:[(0,o.jsx)(n.thead,{children:(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.th,{children:"any"}),(0,o.jsx)(n.th,{children:"xmlFile"})]})}),(0,o.jsxs)(n.tbody,{children:[(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:"any"}),(0,o.jsx)(n.td,{children:"key"})]}),(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:"any"}),(0,o.jsx)(n.td,{children:"entry"})]})]})]}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Code"})}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-lua",children:'function FillVolume:loadFillVolumeInfo(xmlFile, key, entry)\n    entry.nodes = { }\n    local i = 0\n    while true do\n        local infoKey = key .. string.format( ".node(%d)" , i)\n        if not xmlFile:hasProperty(infoKey) then\n            break\n        end\n\n        XMLUtil.checkDeprecatedXMLElements(xmlFile, infoKey .. "#index" , infoKey .. "#node" ) -- FS17 to FS19\n\n        local node = xmlFile:getValue(infoKey .. "#node" , nil , self.components, self.i3dMappings)\n        if node ~ = nil then\n            local nodeEntry = { }\n\n            nodeEntry.node = node\n            nodeEntry.width = xmlFile:getValue(infoKey .. "#width" , 1.0 )\n            nodeEntry.length = xmlFile:getValue(infoKey .. "#length" , 1.0 )\n\n            nodeEntry.fillVolumeHeightIndex = xmlFile:getValue(infoKey .. "#fillVolumeHeightIndex" )\n            nodeEntry.priority = xmlFile:getValue(infoKey .. "#priority" , 1 )\n            nodeEntry.minHeight = xmlFile:getValue(infoKey .. "#minHeight" )\n            nodeEntry.maxHeight = xmlFile:getValue(infoKey .. "#maxHeight" )\n            nodeEntry.minFillLevelPercentage = xmlFile:getValue(infoKey .. "#minFillLevelPercentage" )\n            nodeEntry.maxFillLevelPercentage = xmlFile:getValue(infoKey .. "#maxFillLevelPercentage" )\n\n            nodeEntry.heightForTranslation = xmlFile:getValue(infoKey .. "#heightForTranslation" )\n            nodeEntry.translationStart = xmlFile:getValue(infoKey .. "#translationStart" , nil , true )\n            nodeEntry.translationEnd = xmlFile:getValue(infoKey .. "#translationEnd" , nil , true )\n            nodeEntry.translationAlpha = 0\n\n            table.insert(entry.nodes, nodeEntry)\n        else\n                Logging.xmlWarning( self.xmlFile, "Missing node for \'%s\'" , infoKey)\n                end\n\n                i = i + 1\n            end\n\n            table.sort(entry.nodes, function (a, b) return a.priority > b.priority end )\n\n            return true\n        end\n\n'})}),"\n",(0,o.jsx)(n.h3,{id:"ondelete",children:"onDelete"}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Description"})}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Definition"})}),"\n",(0,o.jsxs)(n.blockquote,{children:["\n",(0,o.jsx)(n.p,{children:"onDelete()"}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Code"})}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-lua",children:"function FillVolume:onDelete()\n    local spec = self.spec_fillVolume\n    if spec.volumes ~ = nil then\n        for _, fillVolume in ipairs(spec.volumes) do\n            if fillVolume.volume ~ = nil then\n                delete(fillVolume.volume)\n            end\n            fillVolume.volume = nil\n        end\n    end\nend\n\n"})}),"\n",(0,o.jsx)(n.h3,{id:"onfillunitfilllevelchanged",children:"onFillUnitFillLevelChanged"}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Description"})}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Definition"})}),"\n",(0,o.jsxs)(n.blockquote,{children:["\n",(0,o.jsx)(n.p,{children:"onFillUnitFillLevelChanged()"}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,o.jsxs)(n.table,{children:[(0,o.jsx)(n.thead,{children:(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.th,{children:"any"}),(0,o.jsx)(n.th,{children:"fillUnitIndex"})]})}),(0,o.jsxs)(n.tbody,{children:[(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:"any"}),(0,o.jsx)(n.td,{children:"fillLevelDelta"})]}),(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:"any"}),(0,o.jsx)(n.td,{children:"_"})]}),(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:"any"}),(0,o.jsx)(n.td,{children:"toolType"})]}),(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:"any"}),(0,o.jsx)(n.td,{children:"fillPositionData"})]}),(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:"any"}),(0,o.jsx)(n.td,{children:"appliedDelta"})]})]})]}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Code"})}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-lua",children:'function FillVolume:onFillUnitFillLevelChanged(fillUnitIndex, fillLevelDelta, _, toolType, fillPositionData, appliedDelta)\n    local spec = self.spec_fillVolume\n\n    local mapping = spec.fillUnitFillVolumeMapping[fillUnitIndex]\n    if mapping = = nil then\n        return\n    end\n\n    local fillLevel = self:getFillUnitFillLevel(fillUnitIndex)\n    local fillType = self:getFillUnitFillType(fillUnitIndex)\n\n    for _, fillVolume in ipairs(mapping.fillVolumes) do\n        local baseNode = fillVolume.baseNode\n        local volumeNode = fillVolume.volume\n        if baseNode = = nil or volumeNode = = nil then\n            return\n        end\n\n        local oldFillLevel = fillVolume.fillLevel\n        fillVolume.fillLevel = math.clamp(fillLevel, 0 , fillVolume.capacity)\n        local fillLevelDelta = fillVolume.fillLevel - oldFillLevel\n\n        if fillVolume.forcedFillType ~ = nil then\n            fillType = fillVolume.forcedFillType\n        end\n        if fillLevel = = 0 then\n            fillVolume.forcedFillType = nil\n        end\n\n        if fillType ~ = fillVolume.lastFillType then\n            local maxPhysicalSurfaceAngle\n            local fillTypeInfo = g_fillTypeManager:getFillTypeByIndex(fillType)\n            if fillTypeInfo ~ = nil then\n                maxPhysicalSurfaceAngle = fillTypeInfo.maxPhysicalSurfaceAngle\n            end\n            if maxPhysicalSurfaceAngle ~ = nil then\n                if fillVolume.volume ~ = nil then\n                    setFillPlaneMaxPhysicalSurfaceAngle(fillVolume.volume, maxPhysicalSurfaceAngle)\n                    fillVolume.maxPhysicalSurfaceAngle = maxPhysicalSurfaceAngle\n                end\n            end\n        end\n\n        setVisibility(fillVolume.volume, fillLevel > 0 )\n\n        if fillType ~ = FillType.UNKNOWN and fillType ~ = fillVolume.lastFillType then\n            local textureArrayIndex = g_fillTypeManager:getTextureArrayIndexByFillTypeIndex(fillType)\n            if textureArrayIndex ~ = nil then\n                setShaderParameter(fillVolume.volume, "fillTypeId" , textureArrayIndex - 1 , 0 , 0 , 0 , false )\n            end\n        end\n\n        if fillPositionData ~ = nil then\n            for i = #spec.availableFillNodes, 1 , - 1 do\n                spec.availableFillNodes[i] = nil\n            end\n\n            if fillPositionData.nodes ~ = nil then\n                local neededPriority = fillPositionData.nodes[ 1 ].priority\n\n                while #spec.availableFillNodes = = 0 and neededPriority > = 1 do\n                    for _,node in pairs(fillPositionData.nodes) do\n                        if node.priority > = neededPriority then\n                            local doInsert = true\n\n                            if node.minHeight ~ = nil or node.maxHeight ~ = nil then\n                                local height = - math.huge\n                                if node.fillVolumeHeightIndex ~ = nil and spec.heightNodes[node.fillVolumeHeightIndex] ~ = nil then\n                                    for _,refNode in pairs(spec.heightNodes[node.fillVolumeHeightIndex].refNodes) do\n                                        local x,_,z = localToLocal(refNode.refNode, baseNode, 0 , 0 , 0 )\n                                        height = math.max(height, getFillPlaneHeightAtLocalPos(volumeNode, x, z) - fillVolume.heightOffset)\n                                    end\n                                else\n                                        local x,_,z = localToLocal(node.node, baseNode, 0 , 0 , 0 )\n                                        height = math.max(height, getFillPlaneHeightAtLocalPos(volumeNode, x, z) - fillVolume.heightOffset)\n                                    end\n\n                                    if node.minHeight ~ = nil and height < node.minHeight then\n                                        doInsert = false\n                                    end\n                                    if node.maxHeight ~ = nil and height > node.maxHeight then\n                                        doInsert = false\n                                    end\n\n                                    if node.heightForTranslation ~ = nil then\n                                        if height > node.heightForTranslation then\n                                            node.translationAlpha = node.translationAlpha + 0.01\n                                            local x,y,z = MathUtil.vector3ArrayLerp(node.translationStart, node.translationEnd, node.translationAlpha)\n                                            setTranslation(node.node, x,y,z)\n                                        else\n                                                node.translationAlpha = node.translationAlpha - 0.01\n                                            end\n                                            node.translationAlpha = math.clamp(node.translationAlpha, 0 , 1 )\n                                        end\n                                    end\n\n                                    if node.minFillLevelPercentage ~ = nil or node.maxFillLevelPercentage ~ = nil then\n                                        local percentage = fillLevel / self:getFillUnitCapacity(fillUnitIndex)\n\n                                        if node.minFillLevelPercentage ~ = nil and percentage < node.minFillLevelPercentage then\n                                            doInsert = false\n                                        end\n                                        if node.maxFillLevelPercentage ~ = nil and percentage > node.maxFillLevelPercentage then\n                                            doInsert = false\n                                        end\n                                    end\n\n                                    if doInsert then\n                                        table.insert(spec.availableFillNodes, node)\n                                    end\n                                end\n                            end\n                            if #spec.availableFillNodes > 0 then\n                                break\n                            end\n                            neededPriority = neededPriority - 1\n                        end\n                    else\n                            table.insert(spec.availableFillNodes, fillPositionData)\n                        end\n\n                        local numFillNodes = #spec.availableFillNodes\n                        local avgX, avgZ = 0 , 0\n\n                        for i = 1 ,numFillNodes do\n                            local node = spec.availableFillNodes[i]\n\n                            local x0,y0,z0 = getWorldTranslation(node.node)\n                            local d1x,d1y,d1z = localDirectionToWorld(node.node, node.width, 0 , 0 )\n                            local d2x,d2y,d2z = localDirectionToWorld(node.node, 0 , 0 ,node.length)\n\n                            if VehicleDebug.state = = VehicleDebug.DEBUG then\n                                drawDebugLine( x0,y0,z0, 1 , 0 , 0 , x0 + d1x, y0 + d1y, z0 + d1z, 1 , 0 , 0 )\n                                drawDebugLine( x0,y0,z0, 0 , 0 , 1 , x0 + d2x, y0 + d2y, z0 + d2z, 0 , 0 , 1 )\n                                drawDebugPoint( x0,y0,z0, 1 , 1 , 1 , 1 )\n                                drawDebugPoint( x0 + d1x, y0 + d1y, z0 + d1z, 1 , 0 , 0 , 1 )\n                                drawDebugPoint( x0 + d2x, y0 + d2y, z0 + d2z, 0 , 0 , 1 , 1 )\n                            end\n                            x0 = x0 - (d1x + d2x) / 2\n                            y0 = y0 - (d1y + d2y) / 2\n                            z0 = z0 - (d1z + d2z) / 2\n                            fillPlaneAdd(fillVolume.volume, fillLevelDelta / numFillNodes, x0,y0,z0, d1x,d1y,d1z, d2x,d2y,d2z)\n\n                            local newX, _, newZ = localToLocal(node.node, fillVolume.volume, 0 , 0 , 0 )\n                            avgX, avgZ = avgX + newX, avgZ + newZ\n                        end\n\n                        local newX = avgX / numFillNodes\n                        local newZ = avgZ / numFillNodes\n                        if math.abs(newX - spec.lastPositionInfoSent[ 1 ]) > FillVolume.SEND_PRECISION or math.abs(newZ - spec.lastPositionInfoSent[ 2 ]) > FillVolume.SEND_PRECISION then\n                            spec.lastPositionInfoSent[ 1 ] = newX\n                            spec.lastPositionInfoSent[ 2 ] = newZ\n\n                            self:raiseDirtyFlags(spec.dirtyFlag)\n                        end\n                    else\n                            -- increase size of fill info if there should not be a heap since a small fill info will still produce a heap\n                                local loadSize = 0.1\n                                if fillVolume.maxPhysicalSurfaceAngle = = 0 or fillVolume.maxSurfaceAngle = = 0 then\n                                    loadSize = 10\n                                end\n\n                                local x,y,z = localToWorld(fillVolume.volume, - loadSize * 0.5 , 0 , - loadSize * 0.5 )\n                                local d1x,d1y,d1z = localDirectionToWorld(fillVolume.volume, loadSize, 0 , 0 )\n                                local d2x,d2y,d2z = localDirectionToWorld(fillVolume.volume, 0 , 0 , loadSize)\n\n                                if not self.isServer then\n                                    if spec.lastPositionInfo[ 1 ] ~ = 0 and spec.lastPositionInfo[ 2 ] ~ = 0 then\n                                        x, y, z = localToWorld(fillVolume.volume, spec.lastPositionInfo[ 1 ], 0 , spec.lastPositionInfo[ 2 ])\n                                    end\n                                end\n\n                                local steps = math.clamp( math.floor(fillLevelDelta / 400 ), 1 , 25 )\n                                for _ = 1 , steps do\n                                    fillPlaneAdd(fillVolume.volume, fillLevelDelta / steps, x,y,z, d1x,d1y,d1z, d2x,d2y,d2z)\n                                end\n                            end\n\n                            local heightNodes = spec.fillVolumeIndexToHeightNode[fillVolume.index]\n                            if heightNodes ~ = nil then\n                                for _, heightNode in ipairs(heightNodes) do\n                                    heightNode.isDirty = true\n                                end\n                            end\n\n                            for _,deformer in pairs(fillVolume.deformers) do\n                                deformer.isDirty = true\n                            end\n\n                            fillVolume.lastFillType = fillType\n                        end\n                    end\n\n'})}),"\n",(0,o.jsx)(n.h3,{id:"onload",children:"onLoad"}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Description"})}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Definition"})}),"\n",(0,o.jsxs)(n.blockquote,{children:["\n",(0,o.jsx)(n.p,{children:"onLoad()"}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,o.jsx)(n.table,{children:(0,o.jsx)(n.thead,{children:(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.th,{children:"any"}),(0,o.jsx)(n.th,{children:"savegame"})]})})}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Code"})}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-lua",children:'function FillVolume:onLoad(savegame)\n    local spec = self.spec_fillVolume\n\n    local fillVolumeConfigurationId = Utils.getNoNil( self.configurations[ "fillVolume" ], 1 )\n    local configKey = string.format( "vehicle.fillVolume.fillVolumeConfigurations.fillVolumeConfiguration(%d).volumes" , fillVolumeConfigurationId - 1 )\n\n    spec.volumes = { }\n    spec.fillVolumeDeformersByNode = { }\n    spec.fillUnitFillVolumeMapping = { }\n\n    self.xmlFile:iterate(configKey .. ".volume" , function (_, key)\n        local entry = { }\n        if self:loadFillVolume( self.xmlFile, key, entry) then\n            table.insert(spec.volumes, entry)\n            entry.index = #spec.volumes\n        end\n    end )\n\n    -- create fill units\n    for _, mapping in ipairs(spec.fillUnitFillVolumeMapping) do\n        for _, fillVolume in ipairs(mapping.fillVolumes) do\n            if not fillVolume.useFullCapacity then\n                fillVolume.fillUnitFactor = fillVolume.fillUnitFactor / mapping.sumFactors\n            end\n        end\n    end\n\n    for _, fillVolume in ipairs(spec.volumes) do\n        local capacity = self:getFillUnitCapacity(fillVolume.fillUnitIndex)\n        fillVolume.capacity = capacity * fillVolume.fillUnitFactor\n        fillVolume.fillLevel = 0\n\n        fillVolume.volume = createFillPlaneShape(fillVolume.baseNode, "fillPlane" , fillVolume.capacity, fillVolume.maxDelta, fillVolume.maxSurfaceAngle, fillVolume.maxPhysicalSurfaceAngle, fillVolume.maxSurfaceDistanceError, fillVolume.maxSubDivEdgeLength, fillVolume.syncMaxSubDivEdgeLength, fillVolume.allSidePlanes, fillVolume.retessellateTop)\n        if fillVolume.volume = = nil or fillVolume.volume = = 0 then\n            printWarning( "Warning:fillVolume \'" .. tostring(getName(fillVolume.baseNode)) .. "\' could not create actual fillVolume in \'" .. self.configFileName .. "\'! Simplifying the mesh could help" )\n            fillVolume.volume = nil\n        else\n\n                setVisibility(fillVolume.volume, false )\n\n                for i = #fillVolume.deformers, 1 , - 1 do\n                    local deformer = fillVolume.deformers[i]\n                    deformer.polyline = findPolyline(fillVolume.volume, deformer.posX, deformer.posZ)\n                    if deformer.polyline = = nil and deformer.polyline ~ = - 1 then\n                        printWarning( "Warning:Could not find \'polyline\' for \'" .. tostring(getName(deformer.node)) .. "\' in \'" .. self.configFileName .. "\'" )\n                            table.remove(fillVolume.deformers, i)\n                        end\n                    end\n\n                    link(fillVolume.baseNode, fillVolume.volume)\n\n                    local fillVolumeMaterial = g_materialManager:getBaseMaterialByName( "fillPlane" )\n                    if fillVolumeMaterial ~ = nil then\n                        setMaterial(fillVolume.volume, fillVolumeMaterial, 0 )\n                        g_fillTypeManager:assignFillTypeTextureArraysFromTerrain(fillVolume.volume, g_terrainNode, true , true , true )\n                    else\n                            Logging.error( "Failed to assign material to fill volume.Base Material \'fillPlane\' not found!" )\n                        end\n\n                        -- check offset between pivot and bottom plane of fill volume\n                        fillPlaneAdd(fillVolume.volume, 1 , 0 , 1 , 0 , 11 , 0 , 0 , 0 , 0 , 11 )\n                        fillVolume.heightOffset = getFillPlaneHeightAtLocalPos(fillVolume.volume, 0 , 0 )\n                        fillPlaneAdd(fillVolume.volume, - 1 , 0 , 1 , 0 , 11 , 0 , 0 , 0 , 0 , 11 )\n                    end\n                end\n\n                spec.loadInfos = { }\n                self.xmlFile:iterate( "vehicle.fillVolume.loadInfos.loadInfo" , function (_, key)\n                    local entry = { }\n                    if self:loadFillVolumeInfo( self.xmlFile, key, entry) then\n                        table.insert(spec.loadInfos, entry)\n                    end\n                end )\n\n                spec.unloadInfos = { }\n                self.xmlFile:iterate( "vehicle.fillVolume.unloadInfos.unloadInfo" , function (_, key)\n                    local entry = { }\n                    if self:loadFillVolumeInfo( self.xmlFile, key, entry) then\n                        table.insert(spec.unloadInfos, entry)\n                    end\n                end )\n\n                spec.heightNodes = { }\n                spec.fillVolumeIndexToHeightNode = { }\n                self.xmlFile:iterate( "vehicle.fillVolume.heightNodes.heightNode" , function (_, key)\n                    local entry = { }\n                    if self:loadFillVolumeHeightNode( self.xmlFile, key, entry) then\n                        table.insert(spec.heightNodes, entry)\n\n                        if spec.fillVolumeIndexToHeightNode[entry.fillVolumeIndex] = = nil then\n                            spec.fillVolumeIndexToHeightNode[entry.fillVolumeIndex] = { }\n                        end\n                        table.insert(spec.fillVolumeIndexToHeightNode[entry.fillVolumeIndex], entry)\n                    end\n                end )\n\n                spec.lastPositionInfo = { 0 , 0 }\n                spec.lastPositionInfoSent = { 0 , 0 }\n                spec.availableFillNodes = { }\n                spec.dirtyFlag = self:getNextDirtyFlag()\n\n                if not self.isClient or(#spec.volumes = = 0 and #spec.heightNodes = = 0 ) then\n                    SpecializationUtil.removeEventListener( self , "onUpdate" , FillVolume )\n                end\n            end\n\n'})}),"\n",(0,o.jsx)(n.h3,{id:"onreadupdatestream",children:"onReadUpdateStream"}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Description"})}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Definition"})}),"\n",(0,o.jsxs)(n.blockquote,{children:["\n",(0,o.jsx)(n.p,{children:"onReadUpdateStream()"}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,o.jsxs)(n.table,{children:[(0,o.jsx)(n.thead,{children:(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.th,{children:"any"}),(0,o.jsx)(n.th,{children:"streamId"})]})}),(0,o.jsxs)(n.tbody,{children:[(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:"any"}),(0,o.jsx)(n.td,{children:"timestamp"})]}),(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:"any"}),(0,o.jsx)(n.td,{children:"connection"})]})]})]}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Code"})}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-lua",children:"function FillVolume:onReadUpdateStream(streamId, timestamp, connection)\n    if connection:getIsServer() then\n        local spec = self.spec_fillVolume\n\n        if streamReadBool(streamId) then\n            spec.lastPositionInfo[ 1 ] = FillVolume.readStreamCompressedPosition(streamId)\n            spec.lastPositionInfo[ 2 ] = FillVolume.readStreamCompressedPosition(streamId)\n        end\n    end\nend\n\n"})}),"\n",(0,o.jsx)(n.h3,{id:"onupdate",children:"onUpdate"}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Description"})}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Definition"})}),"\n",(0,o.jsxs)(n.blockquote,{children:["\n",(0,o.jsx)(n.p,{children:"onUpdate()"}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,o.jsxs)(n.table,{children:[(0,o.jsx)(n.thead,{children:(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.th,{children:"any"}),(0,o.jsx)(n.th,{children:"dt"})]})}),(0,o.jsxs)(n.tbody,{children:[(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:"any"}),(0,o.jsx)(n.td,{children:"isActiveForInput"})]}),(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:"any"}),(0,o.jsx)(n.td,{children:"isActiveForInputIgnoreSelection"})]}),(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:"any"}),(0,o.jsx)(n.td,{children:"isSelected"})]})]})]}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Code"})}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-lua",children:'function FillVolume:onUpdate(dt, isActiveForInput, isActiveForInputIgnoreSelection, isSelected)\n    if self.isClient then\n        local spec = self.spec_fillVolume\n\n        -- deform(fill)volume\n        for _, fillVolume in pairs(spec.volumes) do\n            for _,deformer in ipairs(fillVolume.deformers) do\n                if deformer.isDirty and deformer.polyline ~ = nil and deformer.polyline ~ = - 1 then\n                    deformer.isDirty = false\n\n                    local posX, posY, posZ = localToLocal(deformer.node, deformer.baseNode, 0 , 0 , 0 )\n                    if math.abs(posX - deformer.posX) > 0.0001 or math.abs(posZ - deformer.posZ) > 0.0001 then\n                        --#debug local x, y, z = localToWorld(deformer.baseNode, posX, posY, posZ)\n                        --#debug drawDebugLine(x, y, z, 0, 1, 0, x, y + 4, z, 0, 1, 0, true)\n\n                        deformer.lastPosX = posX\n                        deformer.lastPosZ = posZ\n                        local dx = posX - deformer.initPos[ 1 ]\n                        local dz = posZ - deformer.initPos[ 3 ]\n                        setPolylineTranslation(fillVolume.volume, deformer.polyline, dx,dz)\n                    end\n                end\n            end\n\n            local uvScrollSpeedX, uvScrollSpeedY, uvScrollSpeedZ = self:getFillVolumeUVScrollSpeed(fillVolume.index)\n            if uvScrollSpeedX ~ = 0 or uvScrollSpeedY ~ = 0 or uvScrollSpeedZ ~ = 0 then\n                fillVolume.uvPosition[ 1 ] = fillVolume.uvPosition[ 1 ] + uvScrollSpeedX * (dt / 1000 )\n                fillVolume.uvPosition[ 2 ] = fillVolume.uvPosition[ 2 ] + uvScrollSpeedY * (dt / 1000 )\n                fillVolume.uvPosition[ 3 ] = fillVolume.uvPosition[ 3 ] + uvScrollSpeedZ * (dt / 1000 )\n                setShaderParameter(fillVolume.volume, "uvOffset" , fillVolume.uvPosition[ 1 ], fillVolume.uvPosition[ 2 ], fillVolume.uvPosition[ 3 ], 0 , false )\n            end\n        end\n\n        -- update heightNodes\n        for _, heightNode in pairs(spec.heightNodes) do\n            if heightNode.isDirty then\n                heightNode.isDirty = false\n\n                local fillVolume = spec.volumes[heightNode.fillVolumeIndex]\n\n                local baseNode = fillVolume.baseNode\n                local volumeNode = fillVolume.volume\n\n                if baseNode ~ = nil and volumeNode ~ = nil then\n\n                    local minHeight = math.huge\n                    local maxHeight = - math.huge\n                    local maxHeightWorld = - math.huge\n                    for _, refNode in pairs(heightNode.refNodes) do\n                        local x, _, z = localToLocal(refNode.refNode, baseNode, 0 , 0 , 0 )\n\n                        local height = getFillPlaneHeightAtLocalPos(volumeNode, x, z)\n                        if not MathUtil.isNan(height) then -- fill volume deformed by deformerNodes\n                            height = height - fillVolume.heightOffset\n                            minHeight = math.min(minHeight, height)\n                            maxHeight = math.max(maxHeight, height)\n                            local _, yw, _ = localToWorld(baseNode, x, height, z)\n                            maxHeightWorld = math.max(maxHeightWorld, yw)\n\n                            if VehicleDebug.state = = VehicleDebug.DEBUG_ATTRIBUTES then\n                                local wx1, wy1, wz1 = localToWorld(baseNode, x, fillVolume.heightOffset, z)\n                                local wx2, wy2, wz2 = localToWorld(baseNode, x, height, z)\n                                drawDebugLine(wx1, wy1, wz1, 0 , 1 , 0 , wx2, wy2, wz2, 0 , 1 , 0 , false )\n                                Utils.renderTextAtWorldPosition(wx2, wy2, wz2, string.format( "Height: %.2fm" , height), 0.01 )\n                            end\n                        end\n                    end\n\n                    heightNode.currentMinHeight = minHeight\n                    heightNode.currentMaxHeight = maxHeight\n                    heightNode.currentMaxHeightWorld = maxHeightWorld\n\n                    for _,node in pairs(heightNode.nodes) do\n                        local nodeHeight = math.max(minHeight + node.heightOffset, node.minHeight)\n\n                        local sx = node.scaleAxis[ 1 ] * nodeHeight\n                        local sy = node.scaleAxis[ 2 ] * nodeHeight\n                        local sz = node.scaleAxis[ 3 ] * nodeHeight\n                        if node.scaleMax[ 1 ] > 0 then\n                            sx = math.min(node.scaleMax[ 1 ], sx)\n                        end\n                        if node.scaleMax[ 2 ] > 0 then\n                            sy = math.min(node.scaleMax[ 2 ], sy)\n                        end\n                        if node.scaleMax[ 3 ] > 0 then\n                            sz = math.min(node.scaleMax[ 3 ], sz)\n                        end\n                        local tx = node.transAxis[ 1 ] * nodeHeight\n                        local ty = node.transAxis[ 2 ] * nodeHeight\n                        local tz = node.transAxis[ 3 ] * nodeHeight\n                        if node.transMax[ 1 ] > 0 then\n                            tx = math.min(node.transMax[ 1 ], tx)\n                        end\n                        if node.transMax[ 2 ] > 0 then\n                            ty = math.min(node.transMax[ 2 ], ty)\n                        end\n                        if node.transMax[ 3 ] > 0 then\n                            tz = math.min(node.transMax[ 3 ], tz)\n                        end\n\n                        setScale(node.node, node.baseScale[ 1 ] + sx, node.baseScale[ 2 ] + sy, node.baseScale[ 3 ] + sz)\n                        setTranslation(node.node, node.basePosition[ 1 ] + tx, node.basePosition[ 2 ] + ty, node.basePosition[ 3 ] + tz)\n\n                        if VehicleDebug.state = = VehicleDebug.DEBUG_ATTRIBUTES then\n                            if getEffectiveVisibility(node.node) then\n                                renderShapeOutline(node.node, false )\n\n                                if sy ~ = 0 then\n                                    setScale(node.node, 1 , 1 , 1 )\n\n                                    local wx1, wy1, wz1 = localToWorld(node.node, 0 , 0 , 0 )\n                                    local wx2, wy2, wz2 = localToWorld(node.node, 0 , node.baseScale[ 2 ] + sy, 0 )\n                                    drawDebugLine(wx1, wy1, wz1, 0 , 1 , 0 , wx2, wy2, wz2, 0 , 1 , 0 , false )\n                                    Utils.renderTextAtWorldPosition(wx2, wy2, wz2, string.format( "%s scaleY: %.2f" , getName(node.node), node.baseScale[ 2 ] + sy), 0.01 )\n\n                                    setScale(node.node, node.baseScale[ 1 ] + sx, node.baseScale[ 2 ] + sy, node.baseScale[ 3 ] + sz)\n                                end\n\n                                if ty ~ = 0 then\n                                    local wx1, wy1, wz1 = localToWorld(getParent(node.node), node.basePosition[ 1 ] + tx, node.basePosition[ 2 ], node.basePosition[ 3 ] + tz)\n                                    local wx2, wy2, wz2 = localToWorld(getParent(node.node), node.basePosition[ 1 ] + tx, node.basePosition[ 2 ] + ty, node.basePosition[ 3 ] + tz)\n                                    drawDebugLine(wx1, wy1, wz1, 0 , 1 , 0 , wx2, wy2, wz2, 0 , 1 , 0 , false )\n                                    Utils.renderTextAtWorldPosition(wx2, wy2, wz2, string.format( "%s transY: %.2f" , getName(node.node), node.basePosition[ 2 ] + ty), 0.01 )\n                                end\n                            end\n                        end\n\n                        if node.orientateToWorldY then\n                            local _, dy, _ = localDirectionToWorld(getParent(node.node), 0 , 1 , 0 )\n                            local alpha = math.acos( math.clamp(dy, - 1 , 1 ))\n                            setRotation(node.node, alpha, 0 , 0 )\n                        end\n                    end\n                end\n            end\n        end\n    end\nend\n\n'})}),"\n",(0,o.jsx)(n.h3,{id:"onwriteupdatestream",children:"onWriteUpdateStream"}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Description"})}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Definition"})}),"\n",(0,o.jsxs)(n.blockquote,{children:["\n",(0,o.jsx)(n.p,{children:"onWriteUpdateStream()"}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,o.jsxs)(n.table,{children:[(0,o.jsx)(n.thead,{children:(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.th,{children:"any"}),(0,o.jsx)(n.th,{children:"streamId"})]})}),(0,o.jsxs)(n.tbody,{children:[(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:"any"}),(0,o.jsx)(n.td,{children:"connection"})]}),(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:"any"}),(0,o.jsx)(n.td,{children:"dirtyMask"})]})]})]}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Code"})}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-lua",children:"function FillVolume:onWriteUpdateStream(streamId, connection, dirtyMask)\n    if not connection:getIsServer() then\n        local spec = self.spec_fillVolume\n\n        if streamWriteBool(streamId, bit32.band(dirtyMask, spec.dirtyFlag) ~ = 0 ) then\n            FillVolume.writeStreamCompressedPosition(streamId, spec.lastPositionInfoSent[ 1 ])\n            FillVolume.writeStreamCompressedPosition(streamId, spec.lastPositionInfoSent[ 2 ])\n        end\n    end\nend\n\n"})}),"\n",(0,o.jsx)(n.h3,{id:"prerequisitespresent",children:"prerequisitesPresent"}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Description"})}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Definition"})}),"\n",(0,o.jsxs)(n.blockquote,{children:["\n",(0,o.jsx)(n.p,{children:"prerequisitesPresent()"}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,o.jsx)(n.table,{children:(0,o.jsx)(n.thead,{children:(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.th,{children:"any"}),(0,o.jsx)(n.th,{children:"specializations"})]})})}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Code"})}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-lua",children:"function FillVolume.prerequisitesPresent(specializations)\n    return SpecializationUtil.hasSpecialization( FillUnit , specializations)\nend\n\n"})}),"\n",(0,o.jsx)(n.h3,{id:"registereventlisteners",children:"registerEventListeners"}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Description"})}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Definition"})}),"\n",(0,o.jsxs)(n.blockquote,{children:["\n",(0,o.jsx)(n.p,{children:"registerEventListeners()"}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,o.jsx)(n.table,{children:(0,o.jsx)(n.thead,{children:(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.th,{children:"any"}),(0,o.jsx)(n.th,{children:"vehicleType"})]})})}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Code"})}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-lua",children:'function FillVolume.registerEventListeners(vehicleType)\n    SpecializationUtil.registerEventListener(vehicleType, "onLoad" , FillVolume )\n    SpecializationUtil.registerEventListener(vehicleType, "onDelete" , FillVolume )\n    SpecializationUtil.registerEventListener(vehicleType, "onReadUpdateStream" , FillVolume )\n    SpecializationUtil.registerEventListener(vehicleType, "onWriteUpdateStream" , FillVolume )\n    SpecializationUtil.registerEventListener(vehicleType, "onUpdate" , FillVolume )\n    SpecializationUtil.registerEventListener(vehicleType, "onFillUnitFillLevelChanged" , FillVolume )\nend\n\n'})}),"\n",(0,o.jsx)(n.h3,{id:"registerfunctions",children:"registerFunctions"}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Description"})}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Definition"})}),"\n",(0,o.jsxs)(n.blockquote,{children:["\n",(0,o.jsx)(n.p,{children:"registerFunctions()"}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,o.jsx)(n.table,{children:(0,o.jsx)(n.thead,{children:(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.th,{children:"any"}),(0,o.jsx)(n.th,{children:"vehicleType"})]})})}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Code"})}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-lua",children:'function FillVolume.registerFunctions(vehicleType)\n    SpecializationUtil.registerFunction(vehicleType, "loadFillVolume" , FillVolume.loadFillVolume)\n    SpecializationUtil.registerFunction(vehicleType, "loadFillVolumeInfo" , FillVolume.loadFillVolumeInfo)\n    SpecializationUtil.registerFunction(vehicleType, "loadFillVolumeHeightNode" , FillVolume.loadFillVolumeHeightNode)\n    SpecializationUtil.registerFunction(vehicleType, "getFillVolumeLoadInfo" , FillVolume.getFillVolumeLoadInfo)\n    SpecializationUtil.registerFunction(vehicleType, "getFillVolumeUnloadInfo" , FillVolume.getFillVolumeUnloadInfo)\n    SpecializationUtil.registerFunction(vehicleType, "getFillVolumeIndicesByFillUnitIndex" , FillVolume.getFillVolumeIndicesByFillUnitIndex)\n    SpecializationUtil.registerFunction(vehicleType, "setFillVolumeForcedFillTypeByFillUnitIndex" , FillVolume.setFillVolumeForcedFillTypeByFillUnitIndex)\n    SpecializationUtil.registerFunction(vehicleType, "setFillVolumeForcedFillType" , FillVolume.setFillVolumeForcedFillType)\n    SpecializationUtil.registerFunction(vehicleType, "getFillVolumeUVScrollSpeed" , FillVolume.getFillVolumeUVScrollSpeed)\nend\n\n'})}),"\n",(0,o.jsx)(n.h3,{id:"registerinfonodexmlpaths",children:"registerInfoNodeXMLPaths"}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Description"})}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Definition"})}),"\n",(0,o.jsxs)(n.blockquote,{children:["\n",(0,o.jsx)(n.p,{children:"registerInfoNodeXMLPaths()"}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,o.jsxs)(n.table,{children:[(0,o.jsx)(n.thead,{children:(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.th,{children:"any"}),(0,o.jsx)(n.th,{children:"schema"})]})}),(0,o.jsx)(n.tbody,{children:(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:"any"}),(0,o.jsx)(n.td,{children:"basePath"})]})})]}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Code"})}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-lua",children:'function FillVolume.registerInfoNodeXMLPaths(schema, basePath)\n    schema:register(XMLValueType.NODE_INDEX, basePath .. ".node(?)#node" , "Info node" )\n    schema:register(XMLValueType.FLOAT, basePath .. ".node(?)#width" , "Info width" , 1.0 )\n    schema:register(XMLValueType.FLOAT, basePath .. ".node(?)#length" , "Info length" , 1.0 )\n    schema:register(XMLValueType.INT, basePath .. ".node(?)#fillVolumeHeightIndex" , "Fill volume height index" )\n    schema:register(XMLValueType.INT, basePath .. ".node(?)#priority" , "Priority" , 1 )\n    schema:register(XMLValueType.FLOAT, basePath .. ".node(?)#minHeight" , "Min.height" )\n    schema:register(XMLValueType.FLOAT, basePath .. ".node(?)#maxHeight" , "Max.height" )\n    schema:register(XMLValueType.FLOAT, basePath .. ".node(?)#minFillLevelPercentage" , "Min.fill level percentage" )\n    schema:register(XMLValueType.FLOAT, basePath .. ".node(?)#maxFillLevelPercentage" , "Min.fill level percentage" )\n    schema:register(XMLValueType.FLOAT, basePath .. ".node(?)#heightForTranslation" , "Min.height for translation" )\n        schema:register(XMLValueType.VECTOR_TRANS, basePath .. ".node(?)#translationStart" , "Translation start" )\n        schema:register(XMLValueType.VECTOR_TRANS, basePath .. ".node(?)#translationEnd" , "Translation end" )\n    end\n\n'})}),"\n",(0,o.jsx)(n.h3,{id:"registeroverwrittenfunctions",children:"registerOverwrittenFunctions"}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Description"})}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Definition"})}),"\n",(0,o.jsxs)(n.blockquote,{children:["\n",(0,o.jsx)(n.p,{children:"registerOverwrittenFunctions()"}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,o.jsx)(n.table,{children:(0,o.jsx)(n.thead,{children:(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.th,{children:"any"}),(0,o.jsx)(n.th,{children:"vehicleType"})]})})}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Code"})}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-lua",children:'function FillVolume.registerOverwrittenFunctions(vehicleType)\n    SpecializationUtil.registerOverwrittenFunction(vehicleType, "setMovingToolDirty" , FillVolume.setMovingToolDirty)\n    SpecializationUtil.registerOverwrittenFunction(vehicleType, "loadExtraDependentParts" , FillVolume.loadExtraDependentParts)\n    SpecializationUtil.registerOverwrittenFunction(vehicleType, "updateExtraDependentParts" , FillVolume.updateExtraDependentParts)\nend\n\n'})}),"\n",(0,o.jsx)(n.h3,{id:"setfillvolumeforcedfilltype",children:"setFillVolumeForcedFillType"}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Description"})}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Definition"})}),"\n",(0,o.jsxs)(n.blockquote,{children:["\n",(0,o.jsx)(n.p,{children:"setFillVolumeForcedFillType()"}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,o.jsxs)(n.table,{children:[(0,o.jsx)(n.thead,{children:(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.th,{children:"any"}),(0,o.jsx)(n.th,{children:"fillVolumeIndex"})]})}),(0,o.jsx)(n.tbody,{children:(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:"any"}),(0,o.jsx)(n.td,{children:"forcedFillType"})]})})]}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Code"})}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-lua",children:"function FillVolume:setFillVolumeForcedFillType(fillVolumeIndex, forcedFillType)\n    local spec = self.spec_fillVolume\n    if spec.volumes[fillVolumeIndex] ~ = nil then\n        spec.volumes[fillVolumeIndex].forcedFillType = forcedFillType\n    end\nend\n\n"})}),"\n",(0,o.jsx)(n.h3,{id:"setfillvolumeforcedfilltypebyfillunitindex",children:"setFillVolumeForcedFillTypeByFillUnitIndex"}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Description"})}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Definition"})}),"\n",(0,o.jsxs)(n.blockquote,{children:["\n",(0,o.jsx)(n.p,{children:"setFillVolumeForcedFillTypeByFillUnitIndex()"}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,o.jsxs)(n.table,{children:[(0,o.jsx)(n.thead,{children:(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.th,{children:"any"}),(0,o.jsx)(n.th,{children:"fillUnitIndex"})]})}),(0,o.jsx)(n.tbody,{children:(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:"any"}),(0,o.jsx)(n.td,{children:"forcedFillType"})]})})]}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Code"})}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-lua",children:"function FillVolume:setFillVolumeForcedFillTypeByFillUnitIndex(fillUnitIndex, forcedFillType)\n    local spec = self.spec_fillVolume\n    for i, fillVolume in ipairs(spec.volumes) do\n        if fillVolume.fillUnitIndex = = fillUnitIndex then\n            self:setFillVolumeForcedFillType(i, forcedFillType)\n        end\n    end\nend\n\n"})}),"\n",(0,o.jsx)(n.h3,{id:"setmovingtooldirty",children:"setMovingToolDirty"}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Description"})}),"\n",(0,o.jsxs)(n.blockquote,{children:["\n",(0,o.jsx)(n.p,{children:"Set moving tool dirty"}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Definition"})}),"\n",(0,o.jsxs)(n.blockquote,{children:["\n",(0,o.jsx)(n.p,{children:"setMovingToolDirty(function superFunc, integer node, boolean forceUpdate, float dt)"}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,o.jsxs)(n.table,{children:[(0,o.jsx)(n.thead,{children:(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.th,{children:"function"}),(0,o.jsx)(n.th,{children:"superFunc"}),(0,o.jsx)(n.th,{children:"superFunc"})]})}),(0,o.jsxs)(n.tbody,{children:[(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:"integer"}),(0,o.jsx)(n.td,{children:"node"}),(0,o.jsx)(n.td,{children:"node id"})]}),(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:"boolean"}),(0,o.jsx)(n.td,{children:"forceUpdate"}),(0,o.jsx)(n.td,{children:"force immediate update of moving tool and dependent parts"})]}),(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:"float"}),(0,o.jsx)(n.td,{children:"dt"}),(0,o.jsx)(n.td,{children:"time since last call (only if forceUpdate is set)"})]})]})]}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Code"})}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-lua",children:"function FillVolume:setMovingToolDirty(superFunc, node, forceUpdate, dt)\n    superFunc( self , node, forceUpdate, dt)\n\n    local spec = self.spec_fillVolume\n    if spec.fillVolumeDeformersByNode ~ = nil then\n        local deformer = spec.fillVolumeDeformersByNode[node]\n        if deformer ~ = nil then\n            deformer.isDirty = true\n        end\n    end\nend\n\n"})}),"\n",(0,o.jsx)(n.h3,{id:"updatedebugvalues",children:"updateDebugValues"}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Description"})}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Definition"})}),"\n",(0,o.jsxs)(n.blockquote,{children:["\n",(0,o.jsx)(n.p,{children:"updateDebugValues()"}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,o.jsx)(n.table,{children:(0,o.jsx)(n.thead,{children:(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.th,{children:"any"}),(0,o.jsx)(n.th,{children:"values"})]})})}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Code"})}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-lua",children:'function FillVolume:updateDebugValues(values)\n    local spec = self.spec_fillVolume\n\n    for fillUnitIndex, mapping in pairs(spec.fillUnitFillVolumeMapping) do\n        for index, fillVolume in ipairs(mapping.fillVolumes) do\n            table.insert(values, { name = "fillUnitIndex/fillVolume" , value = tostring(fillUnitIndex) .. " / " .. tostring(index) } )\n            table.insert(values, { name = "lastFillType" , value = g_fillTypeManager:getFillTypeNameByIndex(fillVolume.lastFillType) } )\n            table.insert(values, { name = "volume" , value = tostring(fillVolume.volume) } )\n            if fillVolume.volume ~ = nil then\n                table.insert(values, { name = "visibility" , value = tostring(getVisibility(fillVolume.volume)) } )\n\n                local textureArrayIndex, _, _, _ = getShaderParameter(fillVolume.volume, "fillTypeId" )\n                table.insert(values, { name = "textureArrayIndex" , value = tostring(textureArrayIndex) } )\n            end\n        end\n    end\n\n    table.insert(values, { name = "lastPositionInfo" , value = string.format( "%.2f %.2f" , spec.lastPositionInfo[ 1 ], spec.lastPositionInfo[ 2 ]) } )\n    table.insert(values, { name = "lastPositionInfoSent" , value = string.format( "%.2f %.2f" , spec.lastPositionInfoSent[ 1 ], spec.lastPositionInfoSent[ 2 ]) } )\nend\n\n'})}),"\n",(0,o.jsx)(n.h3,{id:"updateextradependentparts",children:"updateExtraDependentParts"}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Description"})}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Definition"})}),"\n",(0,o.jsxs)(n.blockquote,{children:["\n",(0,o.jsx)(n.p,{children:"updateExtraDependentParts()"}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,o.jsxs)(n.table,{children:[(0,o.jsx)(n.thead,{children:(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.th,{children:"any"}),(0,o.jsx)(n.th,{children:"superFunc"})]})}),(0,o.jsxs)(n.tbody,{children:[(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:"any"}),(0,o.jsx)(n.td,{children:"part"})]}),(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:"any"}),(0,o.jsx)(n.td,{children:"dt"})]})]})]}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Code"})}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-lua",children:"function FillVolume:updateExtraDependentParts(superFunc, part, dt)\n    superFunc( self , part, dt)\n\n    if part.deformerNodes ~ = nil then\n        if part.fillVolumeIndex ~ = nil then\n            part.fillVolume = self.spec_fillVolume.volumes[part.fillVolumeIndex]\n\n            if part.fillVolume = = nil then\n                Logging.xmlWarning( self.xmlFile, \"Unable to find fillVolume with index '%d' for movingPart/movingTool '%s'\" , part.fillVolumeIndex, getName(part.node))\n                    part.deformerNodes = nil\n                end\n                part.fillVolumeIndex = nil\n            end\n\n            if part.fillVolume ~ = nil then\n                for i, nodeIndex in pairs(part.deformerNodes) do\n                    local deformerNode = part.fillVolume.deformers[nodeIndex]\n                    if deformerNode = = nil then\n                        part.deformerNodes[i] = nil\n                    else\n                            deformerNode.isDirty = true\n                        end\n                    end\n                end\n            end\n        end\n\n"})})]})}function h(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(c,{...e})}):c(e)}},28453(e,n,l){l.d(n,{R:()=>s,x:()=>r});var i=l(96540);const o={},t=i.createContext(o);function s(e){const n=i.useContext(t);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:s(e.components),i.createElement(t.Provider,{value:n},e.children)}}}]);