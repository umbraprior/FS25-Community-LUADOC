"use strict";(globalThis.webpackChunkfs25_community_luadoc=globalThis.webpackChunkfs25_community_luadoc||[]).push([[94781],{28453(e,n,s){s.d(n,{R:()=>r,x:()=>d});var l=s(96540);const t={},i=l.createContext(t);function r(e){const n=l.useContext(i);return l.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function d(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:r(e.components),l.createElement(i.Provider,{value:n},e.children)}},51525(e,n,s){s.r(n),s.d(n,{assets:()=>o,contentTitle:()=>d,default:()=>c,frontMatter:()=>r,metadata:()=>l,toc:()=>a});const l=JSON.parse('{"id":"script/GUI/OptionSliderElement","title":"OptionSliderElement","description":"OptionSliderElement","source":"@site/../docs/script/GUI/OptionSliderElement.md","sourceDirName":"script/GUI","slug":"/script/GUI/OptionSliderElement","permalink":"/FS25-Community-LUADOC/script/GUI/OptionSliderElement","draft":false,"unlisted":false,"tags":[],"version":"current","lastUpdatedAt":1767161192000,"frontMatter":{},"sidebar":"docsSidebar","previous":{"title":"NavigationMarker","permalink":"/FS25-Community-LUADOC/script/GUI/NavigationMarker"},"next":{"title":"Overlay","permalink":"/FS25-Community-LUADOC/script/GUI/Overlay"}}');var t=s(74848),i=s(28453);const r={},d=void 0,o={},a=[{value:"OptionSliderElement",id:"optionsliderelement",level:2},{value:"addDefaultElements",id:"adddefaultelements",level:3},{value:"copyAttributes",id:"copyattributes",level:3},{value:"loadFromXML",id:"loadfromxml",level:3},{value:"loadProfile",id:"loadprofile",level:3},{value:"mouseEvent",id:"mouseevent",level:3},{value:"new",id:"new",level:3},{value:"onOpen",id:"onopen",level:3},{value:"setElementsByName",id:"setelementsbyname",level:3},{value:"touchEvent",id:"touchevent",level:3},{value:"updateAbsolutePosition",id:"updateabsoluteposition",level:3},{value:"updateContentElement",id:"updatecontentelement",level:3},{value:"updateSlider",id:"updateslider",level:3}];function f(e){const n={a:"a",blockquote:"blockquote",code:"code",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,i.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.h2,{id:"optionsliderelement",children:"OptionSliderElement"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Description"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"MultiTextOptionElement with a slider to adjust values"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Parent"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.a,{href:"?version=script&category=43&class=479",children:"MultiTextOptionElement"})}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Functions"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#adddefaultelements",children:"addDefaultElements"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#copyattributes",children:"copyAttributes"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#loadfromxml",children:"loadFromXML"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#loadprofile",children:"loadProfile"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#mouseevent",children:"mouseEvent"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#new",children:"new"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#onopen",children:"onOpen"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#setelementsbyname",children:"setElementsByName"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#touchevent",children:"touchEvent"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#updateabsoluteposition",children:"updateAbsolutePosition"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#updatecontentelement",children:"updateContentElement"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#updateslider",children:"updateSlider"})}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"adddefaultelements",children:"addDefaultElements"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Description"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"Adds the default slider element, if autoAddDefaultElements = true"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Definition"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"addDefaultElements()"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Code"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:'function OptionSliderElement:addDefaultElements()\n    OptionSliderElement:superClass().addDefaultElements( self )\n\n    if self.autoAddDefaultElements then\n        if self:getDescendantByName( "fillingBar" ) = = nil then\n            if self.defaultProfileFillingBar ~ = nil then\n                local baseElement = BitmapElement.new( self )\n                baseElement.name = "fillingBar"\n                self:addElement(baseElement)\n                baseElement:applyProfile( self.defaultProfileFillingBar)\n            elseif self.defaultProfileFillingBarThreePart ~ = nil then\n                    local baseElement = ThreePartBitmapElement.new( self )\n                    baseElement.name = "fillingBar"\n                    self:addElement(baseElement)\n                    baseElement:applyProfile( self.defaultProfileFillingBarThreePart)\n                end\n            end\n\n            if self:getDescendantByName( "slider" ) = = nil then\n                if self.defaultProfileSliderRound ~ = nil then\n                    local baseElement = RoundCornerElement.new( self )\n                    baseElement.name = "slider"\n                    self:addElement(baseElement)\n                    baseElement:applyProfile( self.defaultProfileSliderRound)\n                elseif self.defaultProfileSlider ~ = nil then\n                        local baseElement = BitmapElement.new( self )\n                        baseElement.name = "slider"\n                        self:addElement(baseElement)\n                        baseElement:applyProfile( self.defaultProfileSlider)\n                    end\n                end\n            end\n        end\n\n'})}),"\n",(0,t.jsx)(n.h3,{id:"copyattributes",children:"copyAttributes"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Description"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Definition"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"copyAttributes()"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,t.jsx)(n.table,{children:(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"any"}),(0,t.jsx)(n.th,{children:"src"})]})})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Code"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:"function OptionSliderElement:copyAttributes(src)\n    OptionSliderElement:superClass().copyAttributes( self , src)\n\n    self.sliderOffset = src.sliderOffset\n    self.useFillingBar = src.useFillingBar\n    self.updateTextPosition = src.updateTextPosition\n\n    self.defaultProfileSlider = src.defaultProfileSlider\n    self.defaultProfileSliderRound = src.defaultProfileSliderRound\n\n    self.defaultProfileFillingBar = src.defaultProfileFillingBar\n    self.defaultProfileFillingBarThreePart = src.defaultProfileFillingBarThreePart\nend\n\n"})}),"\n",(0,t.jsx)(n.h3,{id:"loadfromxml",children:"loadFromXML"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Description"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Definition"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"loadFromXML()"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"any"}),(0,t.jsx)(n.th,{children:"xmlFile"})]})}),(0,t.jsx)(n.tbody,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"any"}),(0,t.jsx)(n.td,{children:"key"})]})})]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Code"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:'function OptionSliderElement:loadFromXML(xmlFile, key)\n    OptionSliderElement:superClass().loadFromXML( self , xmlFile, key)\n\n    self.sliderOffset = GuiUtils.getNormalizedXValue(getXMLInt(xmlFile, key .. "#sliderOffset" ), self.sliderOffset)\n    self.useFillingBar = getXMLBool(xmlFile, key .. "#useFillingBar" ) or self.useFillingBar\n    self.updateTextPosition = getXMLBool(xmlFile, key .. "#updateTextPosition" ) or self.updateTextPosition\nend\n\n'})}),"\n",(0,t.jsx)(n.h3,{id:"loadprofile",children:"loadProfile"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Description"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Definition"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"loadProfile()"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"any"}),(0,t.jsx)(n.th,{children:"profile"})]})}),(0,t.jsx)(n.tbody,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"any"}),(0,t.jsx)(n.td,{children:"applyProfile"})]})})]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Code"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:'function OptionSliderElement:loadProfile(profile, applyProfile)\n    OptionSliderElement:superClass().loadProfile( self , profile, applyProfile)\n\n    self.sliderOffset = GuiUtils.getNormalizedXValue(profile:getValue( "sliderOffset" ), self.sliderOffset)\n    self.useFillingBar = profile:getBool( "useFillingBar" , self.useFillingBar)\n    self.updateTextPosition = profile:getBool( "updateTextPosition" , self.updateTextPosition)\n\n    self.defaultProfileSlider = profile:getValue( "defaultProfileSlider" , self.defaultProfileSlider)\n    self.defaultProfileSliderRound = profile:getValue( "defaultProfileSliderRound" , self.defaultProfileSliderRound)\n\n    self.defaultProfileFillingBar = profile:getValue( "defaultProfileFillingBar" , self.defaultProfileFillingBar)\n    self.defaultProfileFillingBarThreePart = profile:getValue( "defaultProfileFillingBarThreePart" , self.defaultProfileFillingBarThreePart)\nend\n\n'})}),"\n",(0,t.jsx)(n.h3,{id:"mouseevent",children:"mouseEvent"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Description"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Definition"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"mouseEvent()"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"any"}),(0,t.jsx)(n.th,{children:"posX"})]})}),(0,t.jsxs)(n.tbody,{children:[(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"any"}),(0,t.jsx)(n.td,{children:"posY"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"any"}),(0,t.jsx)(n.td,{children:"isDown"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"any"}),(0,t.jsx)(n.td,{children:"isUp"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"any"}),(0,t.jsx)(n.td,{children:"button"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"any"}),(0,t.jsx)(n.td,{children:"eventUsed"})]})]})]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Code"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:"function OptionSliderElement:mouseEvent(posX, posY, isDown, isUp, button, eventUsed)\n    if self:getIsActive() then\n        if not( self.wasContinuousTrigger and isUp) then\n            --we want to skip the MTO mouse event, so the MTO super class function is called\n                if MultiTextOptionElement:superClass().mouseEvent( self , posX, posY, isDown, isUp, button, eventUsed) then\n                    eventUsed = true\n                end\n            else\n                    eventUsed = true\n                end\n\n                if isDown then\n                    local leftButton = self.leftButtonElement\n                    self.isLeftButtonPressed = not self.hideLeftRightButtons and\n                    GuiUtils.checkOverlayOverlap(posX, posY, leftButton.absPosition[ 1 ], leftButton.absPosition[ 2 ], leftButton.absSize[ 1 ], leftButton.absSize[ 2 ], leftButton.hotspot)\n\n                    local rightButton = self.rightButtonElement\n                    self.isRightButtonPressed = not self.hideLeftRightButtons and\n                    GuiUtils.checkOverlayOverlap(posX, posY, rightButton.absPosition[ 1 ], rightButton.absPosition[ 2 ], rightButton.absSize[ 1 ], rightButton.absSize[ 2 ], rightButton.hotspot)\n\n                    local slider = self.sliderElement\n                    self.isSliderPressed = slider ~ = nil and GuiUtils.checkOverlayOverlap(posX, posY, slider.absPosition[ 1 ], slider.absPosition[ 2 ], slider.absSize[ 1 ], slider.absSize[ 2 ], slider.hotspot)\n                    self.isSliderAreaPressed = GuiUtils.checkOverlayOverlap(posX, posY, self.absPosition[ 1 ] + self.sliderOffset, self.absPosition[ 2 ], self.absSize[ 1 ] - 2 * self.sliderOffset, self.absSize[ 2 ])\n\n                    if self.sliderMousePosX = = nil then\n                        self.sliderMousePosX = posX\n                    end\n\n                    self.delayTime = g_ time\n                elseif isUp then\n                        self.delayTime = math.huge\n                        self.scrollDelayDuration = MultiTextOptionElement.FIRST_INPUT_DELAY\n\n                        self.wasContinuousTrigger = false\n                        self.continuousTriggerTime = 0\n\n                        self.isLeftButtonPressed = false\n                        self.leftDelayTime = 0\n                        self.isRightButtonPressed = false\n                        self.rightDelayTime = 0\n                        self.isSliderPressed = false\n                        self.isSliderAreaPressed = false\n                        self.sliderMousePosX = nil\n                        self.hasWrapped = false\n                    end\n\n                    if not eventUsed and GuiUtils.checkOverlayOverlap(posX, posY, self.absPosition[ 1 ], self.absPosition[ 2 ], self.absSize[ 1 ], self.absSize[ 2 ], nil ) then\n                        if not self.inputEntered and not self:getIsFocused() then\n                            FocusManager:setHighlight( self )\n                            self.inputEntered = true\n                        end\n\n                        --lets players drag MTO sliders, sets slider position and state according to movement\n                        if # self.texts > 1 and self.isSliderAreaPressed then\n                            if not self:getIsFocused() then\n                                FocusManager:setFocus( self )\n                            end\n\n                            local slider = self.sliderElement\n                            local sliderWidth = slider.absSize[ 1 ]\n                            local stepSize = ( self.absSize[ 1 ] - 2 * self.sliderOffset - sliderWidth) / (# self.texts - 1 )\n\n                            local mouseMoveDistance = posX - self.sliderMousePosX\n                            local sliderLocalPosX = posX - self.absPosition[ 1 ] - self.sliderOffset - slider.absSize[ 1 ] * 0.5\n\n                            if self.isSliderPressed then\n                                sliderLocalPosX = slider.absPosition[ 1 ] - self.absPosition[ 1 ] - self.sliderOffset\n                            end\n\n                            local sliderPosX = MathUtil.snapValue(sliderLocalPosX + mouseMoveDistance, stepSize)\n                            sliderPosX = math.clamp(sliderPosX, 0 , self.absSize[ 1 ] - sliderWidth - 2 * self.sliderOffset)\n                            local state = MathUtil.round(sliderPosX / stepSize) + 1\n\n                            if state ~ = self.state then\n                                if self.isSliderPressed then\n                                    self.sliderMousePosX = self.sliderMousePosX + stepSize * (state - self.state)\n                                end\n\n                                self.isSliderPressed = true\n                                self:setState(state, true )\n                            end\n\n                            slider:setAbsolutePosition( self.absPosition[ 1 ] + sliderPosX + self.sliderOffset, slider.absPosition[ 2 ])\n\n                            if self.updateTextPosition then\n                                self.textElement:setAbsolutePosition(slider.absPosition[ 1 ] - ( self.textElement.absSize[ 1 ] - slider.absSize[ 1 ]) * 0.5 , self.textElement.absPosition[ 2 ])\n                            end\n\n                            if self.useFillingBar then\n                                self.fillingBarElement:setSize(( self.state - 1 ) / (# self.texts - 1 ) * ( self.absSize[ 1 ] - self.sliderOffset * 2 ) + self.sliderOffset, nil )\n                            end\n                        end\n                    else\n                            if self.inputEntered and not self.focusActive then\n                                FocusManager:unsetHighlight( self )\n                                self.inputEntered = false\n                            end\n                        end\n                    end\n\n                    return eventUsed\n                end\n\n"})}),"\n",(0,t.jsx)(n.h3,{id:"new",children:"new"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Description"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Definition"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"new()"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"any"}),(0,t.jsx)(n.th,{children:"target"})]})}),(0,t.jsx)(n.tbody,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"any"}),(0,t.jsx)(n.td,{children:"custom_mt"})]})})]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Code"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:"function OptionSliderElement.new(target, custom_mt)\n    local self = MultiTextOptionElement.new(target, custom_mt or OptionSliderElement _mt)\n\n    self.sliderElement = nil\n    self.sliderOffset = nil\n    self.defaultProfileSlider = nil\n    self.defaultProfileSliderRound = nil\n\n    self.useFillingBar = false\n    self.fillingBarElement = nil\n    self.defaultProfileFillingBar = nil\n    self.defaultProfileFillingBarThreePart = nil\n\n    self.updateTextPosition = true\n\n    return self\nend\n\n"})}),"\n",(0,t.jsx)(n.h3,{id:"onopen",children:"onOpen"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Description"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Definition"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"onOpen()"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Code"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:"function OptionSliderElement:onOpen()\n    OptionSliderElement:superClass().onOpen( self )\n\n    self:updateSlider()\nend\n\n"})}),"\n",(0,t.jsx)(n.h3,{id:"setelementsbyname",children:"setElementsByName"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Description"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"We need to re-add all current elements, because they might not have had their name when they were first added"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Definition"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"setElementsByName()"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Code"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:'function OptionSliderElement:setElementsByName()\n    OptionSliderElement:superClass().setElementsByName( self )\n\n    for _, element in pairs( self.elements) do\n        if element.name = = "slider" then\n            self.sliderElement = element\n            element.target = self\n        end\n\n        if element.name = = "fillingBar" then\n            self.fillingBarElement = element\n            element.target = self\n        end\n    end\n\n    if self.fillingBarElement = = nil then\n        self.useFillingBar = false\n    end\n\n    if self.sliderElement = = nil then\n        Logging.warning( "OptionSliderElement:could not find a slider element for element with profile " .. self.profile)\n        elseif self.leftButtonElement ~ = nil and self.sliderElement.absSize[ 1 ] + self.leftButtonElement.absSize[ 1 ] * 2 > = self.absSize[ 1 ] then\n                self.sliderOffset = self.absSize[ 1 ] / 2\n                Logging.warning( "OptionSliderElement:not enough space for slider movement with current settings in profile " .. self.profile)\n                end\n            end\n\n'})}),"\n",(0,t.jsx)(n.h3,{id:"touchevent",children:"touchEvent"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Description"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Definition"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"touchEvent()"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"any"}),(0,t.jsx)(n.th,{children:"posX"})]})}),(0,t.jsxs)(n.tbody,{children:[(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"any"}),(0,t.jsx)(n.td,{children:"posY"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"any"}),(0,t.jsx)(n.td,{children:"isDown"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"any"}),(0,t.jsx)(n.td,{children:"isUp"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"any"}),(0,t.jsx)(n.td,{children:"touchId"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"any"}),(0,t.jsx)(n.td,{children:"eventUsed"})]})]})]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Code"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:"function OptionSliderElement:touchEvent(posX, posY, isDown, isUp, touchId, eventUsed)\n    if self:getIsActive() then\n        if not( self.wasContinuousTrigger and isUp) then\n            --we want to skip the MTO mouse event, so the MTO super class function is called\n                if MultiTextOptionElement:superClass().touchEvent( self , posX, posY, isDown, isUp, touchId, eventUsed) then\n                    eventUsed = true\n                end\n            else\n                    eventUsed = true\n                end\n\n                if isDown then\n                    local leftButton = self.leftButtonElement\n                    self.isLeftButtonPressed = not self.hideLeftRightButtons and GuiUtils.checkOverlayOverlap(posX, posY, leftButton.absPosition[ 1 ], leftButton.absPosition[ 2 ], leftButton.absSize[ 1 ], leftButton.absSize[ 2 ], leftButton.hotspot)\n\n                    local rightButton = self.rightButtonElement\n                    self.isRightButtonPressed = not self.hideLeftRightButtons and GuiUtils.checkOverlayOverlap(posX, posY, rightButton.absPosition[ 1 ], rightButton.absPosition[ 2 ], rightButton.absSize[ 1 ], rightButton.absSize[ 2 ], rightButton.hotspot)\n\n                    local slider = self.sliderElement\n                    self.isSliderPressed = slider ~ = nil and GuiUtils.checkOverlayOverlap(posX, posY, slider.absPosition[ 1 ], slider.absPosition[ 2 ], slider.absSize[ 1 ], slider.absSize[ 2 ], slider.hotspot)\n\n                    if self.sliderMousePosX = = nil then\n                        self.sliderMousePosX = posX\n                    end\n\n                    self.delayTime = g_ time\n                elseif isUp then\n                        self.delayTime = math.huge\n                        self.scrollDelayDuration = MultiTextOptionElement.FIRST_INPUT_DELAY\n\n                        self.wasContinuousTrigger = false\n                        self.continuousTriggerTime = 0\n\n                        self.isLeftButtonPressed = false\n                        self.leftDelayTime = 0\n                        self.isRightButtonPressed = false\n                        self.rightDelayTime = 0\n                        self.isSliderPressed = false\n                        self.sliderMousePosX = nil\n                        self.hasWrapped = false\n                    end\n\n                    if not eventUsed and GuiUtils.checkOverlayOverlap(posX, posY, self.absPosition[ 1 ], self.absPosition[ 2 ], self.absSize[ 1 ], self.absSize[ 2 ], nil ) then\n                        if not self.inputEntered and not self:getIsFocused() then\n                            FocusManager:setHighlight( self )\n                            self.inputEntered = true\n                        end\n\n                        --lets players drag MTO sliders, sets slider position and state according to movement\n                        if self.isSliderPressed and # self.texts > 1 then\n                            if not self:getIsFocused() then\n                                FocusManager:setFocus( self )\n                            end\n\n                            local slider = self.sliderElement\n                            local sliderWidth = slider.absSize[ 1 ]\n                            local stepSize = ( self.absSize[ 1 ] - 2 * self.sliderOffset - sliderWidth) / (# self.texts - 1 )\n\n                            local mouseMoveDistance = posX - self.sliderMousePosX\n                            local sliderLocalPosX = slider.absPosition[ 1 ] - self.absPosition[ 1 ] - self.sliderOffset\n\n                            local sliderPosX = MathUtil.snapValue(sliderLocalPosX + mouseMoveDistance, stepSize)\n                            sliderPosX = math.clamp(sliderPosX, 0 , self.absSize[ 1 ] - sliderWidth - 2 * self.sliderOffset)\n                            local state = MathUtil.round(sliderPosX / stepSize) + 1\n\n                            if state ~ = self.state then\n                                self.sliderMousePosX = self.sliderMousePosX + stepSize * (state - self.state)\n                                self:setState(state, true )\n                            end\n\n                            slider:setAbsolutePosition( self.absPosition[ 1 ] + sliderPosX + self.sliderOffset, slider.absPosition[ 2 ])\n\n                            if self.updateTextPosition then\n                                self.textElement:setAbsolutePosition(slider.absPosition[ 1 ] - ( self.textElement.absSize[ 1 ] - slider.absSize[ 1 ]) * 0.5 , self.textElement.absPosition[ 2 ])\n                            end\n\n                            if self.useFillingBar then\n                                self.fillingBarElement:setSize(( self.state - 1 ) / (# self.texts - 1 ) * ( self.absSize[ 1 ] - self.sliderOffset * 2 ) + self.sliderOffset, nil )\n                            end\n                        end\n                    else\n                            if self.inputEntered and not self:getIsFocused() then\n                                FocusManager:unsetHighlight( self )\n                                self.inputEntered = false\n                            end\n                        end\n                    end\n\n                    return eventUsed\n                end\n\n"})}),"\n",(0,t.jsx)(n.h3,{id:"updateabsoluteposition",children:"updateAbsolutePosition"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Description"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Definition"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"updateAbsolutePosition()"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Code"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:"function OptionSliderElement:updateAbsolutePosition()\n    OptionSliderElement:superClass().updateAbsolutePosition( self )\n\n    self:updateSlider()\nend\n\n"})}),"\n",(0,t.jsx)(n.h3,{id:"updatecontentelement",children:"updateContentElement"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Description"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Definition"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"updateContentElement()"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Code"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:"function OptionSliderElement:updateContentElement()\n    OptionSliderElement:superClass().updateContentElement( self )\n\n    self:updateSlider()\nend\n\n"})}),"\n",(0,t.jsx)(n.h3,{id:"updateslider",children:"updateSlider"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Description"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Definition"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"updateSlider()"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Code"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:"function OptionSliderElement:updateSlider()\n    if self.sliderElement ~ = nil then\n        --by default, the slider offset is width of the left button\n        if self.sliderOffset = = nil then\n            self.sliderOffset = self.leftButtonElement.absSize[ 1 ]\n        end\n\n        local text = self.textElement\n        local slider = self.sliderElement\n\n        local minVal = self.absPosition[ 1 ] + self.sliderOffset\n        local maxVal = self.absPosition[ 1 ] + self.absSize[ 1 ] - slider.absSize[ 1 ] - self.sliderOffset\n        local pos = maxVal\n        if # self.texts > 1 then\n            pos = minVal + ( self.state - 1 ) / (# self.texts - 1 ) * (maxVal - minVal)\n        end\n\n        slider:setAbsolutePosition(pos, slider.absPosition[ 2 ])\n\n        if self.updateTextPosition then\n            text:setAbsolutePosition(pos - (text.absSize[ 1 ] - slider.absSize[ 1 ]) * 0.5 , text.absPosition[ 2 ])\n        end\n\n        if self.useFillingBar then\n            local fillingBarSize = self.absSize[ 1 ] - self.sliderOffset\n            if # self.texts > 1 then\n                fillingBarSize = ( self.state - 1 ) / (# self.texts - 1 ) * ( self.absSize[ 1 ] - self.sliderOffset * 2 ) + self.sliderOffset\n            end\n\n            self.fillingBarElement:setSize(fillingBarSize, nil )\n        end\n    end\nend\n\n"})})]})}function c(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(f,{...e})}):f(e)}}}]);