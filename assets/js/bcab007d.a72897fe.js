"use strict";(globalThis.webpackChunkfs25_community_luadoc=globalThis.webpackChunkfs25_community_luadoc||[]).push([[76334],{28453(e,n,t){t.d(n,{R:()=>c,x:()=>l});var o=t(96540);const s={},i=o.createContext(s);function c(e){const n=o.useContext(i);return o.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:c(e.components),o.createElement(i.Provider,{value:n},e.children)}},56126(e,n,t){t.r(n),t.d(n,{assets:()=>r,contentTitle:()=>l,default:()=>h,frontMatter:()=>c,metadata:()=>o,toc:()=>a});const o=JSON.parse('{"id":"script/Specializations/ConnectionHoses","title":"ConnectionHoses","description":"ConnectionHoses","source":"@site/../docs/script/Specializations/ConnectionHoses.md","sourceDirName":"script/Specializations","slug":"/script/Specializations/ConnectionHoses","permalink":"/FS25-Community-LUADOC/script/Specializations/ConnectionHoses","draft":false,"unlisted":false,"tags":[],"version":"current","lastUpdatedAt":1767161192000,"frontMatter":{},"sidebar":"docsSidebar","previous":{"title":"Combine","permalink":"/FS25-Community-LUADOC/script/Specializations/Combine"},"next":{"title":"ConveyorBelt","permalink":"/FS25-Community-LUADOC/script/Specializations/ConveyorBelt"}}');var s=t(74848),i=t(28453);const c={},l=void 0,r={},a=[{value:"ConnectionHoses",id:"connectionhoses",level:2},{value:"addHoseTargetNodes",id:"addhosetargetnodes",level:3},{value:"addHoseToDelayedMountings",id:"addhosetodelayedmountings",level:3},{value:"connectCustomHoseNode",id:"connectcustomhosenode",level:3},{value:"connectCustomHosesToAttacherVehicle",id:"connectcustomhosestoattachervehicle",level:3},{value:"connectHose",id:"connecthose",level:3},{value:"connectHosesToAttacherVehicle",id:"connecthosestoattachervehicle",level:3},{value:"connectHoseToSkipNode",id:"connecthosetoskipnode",level:3},{value:"consoleCommandTestSockets",id:"consolecommandtestsockets",level:3},{value:"consoleCommandTestToolConnection",id:"consolecommandtesttoolconnection",level:3},{value:"disconnectCustomHoseNode",id:"disconnectcustomhosenode",level:3},{value:"disconnectHose",id:"disconnecthose",level:3},{value:"getCenterPointAngle",id:"getcenterpointangle",level:3},{value:"getCenterPointAngleRegulation",id:"getcenterpointangleregulation",level:3},{value:"getClonedSkipHoseNode",id:"getclonedskiphosenode",level:3},{value:"getConnectionHoseConfigIndex",id:"getconnectionhoseconfigindex",level:3},{value:"getConnectionHosesByInputAttacherJoint",id:"getconnectionhosesbyinputattacherjoint",level:3},{value:"getConnectionTarget",id:"getconnectiontarget",level:3},{value:"getIsConnectionHoseUsed",id:"getisconnectionhoseused",level:3},{value:"getIsConnectionTargetUsed",id:"getisconnectiontargetused",level:3},{value:"getIsSkipNodeAvailable",id:"getisskipnodeavailable",level:3},{value:"initSpecialization",id:"initspecialization",level:3},{value:"iterateConnectionTargets",id:"iterateconnectiontargets",level:3},{value:"loadConnectionHosesFromXML",id:"loadconnectionhosesfromxml",level:3},{value:"loadCustomHosesFromXML",id:"loadcustomhosesfromxml",level:3},{value:"loadExtraDependentParts",id:"loadextradependentparts",level:3},{value:"loadHoseNode",id:"loadhosenode",level:3},{value:"loadHoseSkipNode",id:"loadhoseskipnode",level:3},{value:"loadHoseTargetNode",id:"loadhosetargetnode",level:3},{value:"loadToolConnectorHoseNode",id:"loadtoolconnectorhosenode",level:3},{value:"onDelete",id:"ondelete",level:3},{value:"onLoadFinished",id:"onloadfinished",level:3},{value:"onPostAttach",id:"onpostattach",level:3},{value:"onPostLoad",id:"onpostload",level:3},{value:"onPreDetach",id:"onpredetach",level:3},{value:"onPreLoad",id:"onpreload",level:3},{value:"onUpdateEnd",id:"onupdateend",level:3},{value:"onUpdateInterpolation",id:"onupdateinterpolation",level:3},{value:"prerequisitesPresent",id:"prerequisitespresent",level:3},{value:"registerConnectionHoseXMLPaths",id:"registerconnectionhosexmlpaths",level:3},{value:"registerCustomHoseNodesXMLPaths",id:"registercustomhosenodesxmlpaths",level:3},{value:"registerCustomHoseTargetNodesXMLPaths",id:"registercustomhosetargetnodesxmlpaths",level:3},{value:"registerEventListeners",id:"registereventlisteners",level:3},{value:"registerFunctions",id:"registerfunctions",level:3},{value:"registerHoseNodesXMLPaths",id:"registerhosenodesxmlpaths",level:3},{value:"registerHoseTargetNodesXMLPaths",id:"registerhosetargetnodesxmlpaths",level:3},{value:"registerOverwrittenFunctions",id:"registeroverwrittenfunctions",level:3},{value:"retryHoseSkipNodeConnections",id:"retryhoseskipnodeconnections",level:3},{value:"setConnectionHosesActive",id:"setconnectionhosesactive",level:3},{value:"updateAttachedConnectionHoses",id:"updateattachedconnectionhoses",level:3},{value:"updateConnectionHose",id:"updateconnectionhose",level:3},{value:"updateCustomHoseNode",id:"updatecustomhosenode",level:3},{value:"updateExtraDependentParts",id:"updateextradependentparts",level:3},{value:"updateToolConnectionHose",id:"updatetoolconnectionhose",level:3}];function d(e){const n={a:"a",blockquote:"blockquote",code:"code",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,i.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.h2,{id:"connectionhoses",children:"ConnectionHoses"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"Specialization for connection hoses between vehicles and tools"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Functions"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#addhosetargetnodes",children:"addHoseTargetNodes"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#addhosetodelayedmountings",children:"addHoseToDelayedMountings"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#connectcustomhosenode",children:"connectCustomHoseNode"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#connectcustomhosestoattachervehicle",children:"connectCustomHosesToAttacherVehicle"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#connecthose",children:"connectHose"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#connecthosestoattachervehicle",children:"connectHosesToAttacherVehicle"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#connecthosetoskipnode",children:"connectHoseToSkipNode"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#consolecommandtestsockets",children:"consoleCommandTestSockets"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#consolecommandtesttoolconnection",children:"consoleCommandTestToolConnection"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#disconnectcustomhosenode",children:"disconnectCustomHoseNode"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#disconnecthose",children:"disconnectHose"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#getcenterpointangle",children:"getCenterPointAngle"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#getcenterpointangleregulation",children:"getCenterPointAngleRegulation"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#getclonedskiphosenode",children:"getClonedSkipHoseNode"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#getconnectionhoseconfigindex",children:"getConnectionHoseConfigIndex"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#getconnectionhosesbyinputattacherjoint",children:"getConnectionHosesByInputAttacherJoint"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#getconnectiontarget",children:"getConnectionTarget"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#getisconnectionhoseused",children:"getIsConnectionHoseUsed"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#getisconnectiontargetused",children:"getIsConnectionTargetUsed"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#getisskipnodeavailable",children:"getIsSkipNodeAvailable"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#initspecialization",children:"initSpecialization"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#iterateconnectiontargets",children:"iterateConnectionTargets"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#loadconnectionhosesfromxml",children:"loadConnectionHosesFromXML"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#loadcustomhosesfromxml",children:"loadCustomHosesFromXML"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#loadextradependentparts",children:"loadExtraDependentParts"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#loadhosenode",children:"loadHoseNode"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#loadhoseskipnode",children:"loadHoseSkipNode"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#loadhosetargetnode",children:"loadHoseTargetNode"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#loadtoolconnectorhosenode",children:"loadToolConnectorHoseNode"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#ondelete",children:"onDelete"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#onloadfinished",children:"onLoadFinished"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#onpostattach",children:"onPostAttach"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#onpostload",children:"onPostLoad"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#onpredetach",children:"onPreDetach"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#onpreload",children:"onPreLoad"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#onupdateend",children:"onUpdateEnd"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#onupdateinterpolation",children:"onUpdateInterpolation"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#prerequisitespresent",children:"prerequisitesPresent"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#registerconnectionhosexmlpaths",children:"registerConnectionHoseXMLPaths"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#registercustomhosenodesxmlpaths",children:"registerCustomHoseNodesXMLPaths"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#registercustomhosetargetnodesxmlpaths",children:"registerCustomHoseTargetNodesXMLPaths"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#registereventlisteners",children:"registerEventListeners"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#registerfunctions",children:"registerFunctions"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#registerhosenodesxmlpaths",children:"registerHoseNodesXMLPaths"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#registerhosetargetnodesxmlpaths",children:"registerHoseTargetNodesXMLPaths"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#registeroverwrittenfunctions",children:"registerOverwrittenFunctions"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#retryhoseskipnodeconnections",children:"retryHoseSkipNodeConnections"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#setconnectionhosesactive",children:"setConnectionHosesActive"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#updateattachedconnectionhoses",children:"updateAttachedConnectionHoses"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#updateconnectionhose",children:"updateConnectionHose"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#updatecustomhosenode",children:"updateCustomHoseNode"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#updateextradependentparts",children:"updateExtraDependentParts"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#updatetoolconnectionhose",children:"updateToolConnectionHose"})}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"addhosetargetnodes",children:"addHoseTargetNodes"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Definition"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"addHoseTargetNodes()"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"any"}),(0,s.jsx)(n.th,{children:"xmlFile"})]})}),(0,s.jsx)(n.tbody,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"any"}),(0,s.jsx)(n.td,{children:"key"})]})})]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Code"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:"function ConnectionHoses:addHoseTargetNodes(xmlFile, key)\n    local spec = self.spec_connectionHoses\n\n    local addedTarget = false\n    xmlFile:iterate(key, function (_, targetKey)\n        local entry = { }\n        if self:loadHoseTargetNode(xmlFile, targetKey, entry) then\n            table.insert(spec.targetNodes, entry)\n            entry.index = #spec.targetNodes\n\n            if spec.targetNodesByType[entry.type ] = = nil then\n                spec.targetNodesByType[entry.type ] = { }\n            end\n\n            table.insert(spec.targetNodesByType[entry.type ], entry)\n            addedTarget = true\n        end\n    end )\n\n    -- return the index of the last added target\n    if addedTarget then\n        return #spec.targetNodes\n    end\n\n    return nil\nend\n\n"})}),"\n",(0,s.jsx)(n.h3,{id:"addhosetodelayedmountings",children:"addHoseToDelayedMountings"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Definition"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"addHoseToDelayedMountings()"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"any"}),(0,s.jsx)(n.th,{children:"sourceObject"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"any"}),(0,s.jsx)(n.td,{children:"sourceHose"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"any"}),(0,s.jsx)(n.td,{children:"targetObject"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"any"}),(0,s.jsx)(n.td,{children:"targetHose"})]})]})]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Code"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:"function ConnectionHoses:addHoseToDelayedMountings(sourceObject, sourceHose, targetObject, targetHose)\n    local spec = self.spec_connectionHoses\n\n    local toolConnectionHose = spec.targetNodeToToolConnection[targetHose.index]\n    if toolConnectionHose ~ = nil and(toolConnectionHose.delayedMounting = = nil or sourceHose.typedIndex = = toolConnectionHose.typedIndex) then\n        local retry = toolConnectionHose.delayedMounting = = nil\n        toolConnectionHose.delayedMounting = { sourceObject = sourceObject, sourceHose = sourceHose, targetObject = targetObject, targetHose = targetHose }\n\n        if retry then\n            self.rootVehicle:retryHoseSkipNodeConnections( true , sourceObject)\n        end\n    end\nend\n\n"})}),"\n",(0,s.jsx)(n.h3,{id:"connectcustomhosenode",children:"connectCustomHoseNode"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Definition"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"connectCustomHoseNode()"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"any"}),(0,s.jsx)(n.th,{children:"customHose"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"any"}),(0,s.jsx)(n.td,{children:"customTarget"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"any"}),(0,s.jsx)(n.td,{children:"targetObject"})]})]})]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Code"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:"function ConnectionHoses:connectCustomHoseNode(customHose, customTarget, targetObject)\n    self:updateCustomHoseNode(customHose, customTarget)\n\n    customHose.isActive = true\n    customTarget.isActive = true\n\n    customHose.connectedTarget = customTarget\n    customHose.connectedObject = targetObject\n    customTarget.connectedHose = customHose\n    customTarget.connectedObject = self\n\n    ObjectChangeUtil.setObjectChanges(customHose.objectChanges, true , customHose.objectChangesTarget, customHose.objectChangesTarget.setMovingToolDirty)\n    ObjectChangeUtil.setObjectChanges(customTarget.objectChanges, true , customTarget.objectChangesTarget, customTarget.objectChangesTarget.setMovingToolDirty)\n\n    if self.setMovingToolDirty ~ = nil then\n        self:setMovingToolDirty(customHose.node, true )\n    end\nend\n\n"})}),"\n",(0,s.jsx)(n.h3,{id:"connectcustomhosestoattachervehicle",children:"connectCustomHosesToAttacherVehicle"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Definition"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"connectCustomHosesToAttacherVehicle()"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"any"}),(0,s.jsx)(n.th,{children:"attacherVehicle"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"any"}),(0,s.jsx)(n.td,{children:"inputJointDescIndex"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"any"}),(0,s.jsx)(n.td,{children:"jointDescIndex"})]})]})]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Code"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:"function ConnectionHoses:connectCustomHosesToAttacherVehicle(attacherVehicle, inputJointDescIndex, jointDescIndex)\n    local spec = self.spec_connectionHoses\n    local customHoses = spec.customHosesByInputAttacher[inputJointDescIndex]\n    if customHoses ~ = nil then\n        for i = 1 , #customHoses do\n            local customHose = customHoses[i]\n            if not customHose.isActive then\n                if attacherVehicle.spec_connectionHoses ~ = nil then\n                    local customTargets = attacherVehicle.spec_connectionHoses.customHoseTargetsByAttacher[jointDescIndex]\n                    if customTargets ~ = nil then\n                        for j = 1 , #customTargets do\n                            local customTarget = customTargets[j]\n                            if not customTarget.isActive then\n                                if customHose.type = = customTarget.type\n                                    and customHose.specType = = customTarget.specType then\n                                    self:connectCustomHoseNode(customHose, customTarget, attacherVehicle)\n                                end\n                            end\n                        end\n                    end\n                end\n            end\n        end\n    end\n\n    local customTargets = spec.customHoseTargetsByInputAttacher[inputJointDescIndex]\n    if customTargets ~ = nil then\n        for i = 1 , #customTargets do\n            local customTarget = customTargets[i]\n            if not customTarget.isActive then\n                if attacherVehicle.spec_connectionHoses ~ = nil then\n                    customHoses = attacherVehicle.spec_connectionHoses.customHosesByAttacher[jointDescIndex]\n                    if customHoses ~ = nil then\n                        for j = 1 , #customHoses do\n                            local customHose = customHoses[j]\n                            if not customHose.isActive then\n                                if customHose.type = = customTarget.type\n                                    and customHose.specType = = customTarget.specType then\n                                    self:connectCustomHoseNode(customHose, customTarget, attacherVehicle)\n                                end\n                            end\n                        end\n                    end\n                end\n            end\n        end\n    end\nend\n\n"})}),"\n",(0,s.jsx)(n.h3,{id:"connecthose",children:"connectHose"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Definition"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"connectHose()"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"any"}),(0,s.jsx)(n.th,{children:"sourceHose"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"any"}),(0,s.jsx)(n.td,{children:"targetObject"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"any"}),(0,s.jsx)(n.td,{children:"targetHose"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"any"}),(0,s.jsx)(n.td,{children:"updateToolConnections"})]})]})]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Code"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:'function ConnectionHoses:connectHose(sourceHose, targetObject, targetHose, updateToolConnections)\n    local spec = self.spec_connectionHoses\n\n    local doConnect = false\n    if updateToolConnections ~ = nil and not updateToolConnections then\n        doConnect = true\n    else\n            if targetObject:updateToolConnectionHose( self , sourceHose, targetObject, targetHose, true ) then\n                doConnect = true\n            else\n                    -- on tool connections we wait until both ends are connected to a tool and then we connect the hoses\n                    targetObject:addHoseToDelayedMountings( self , sourceHose, targetObject, targetHose)\n                end\n            end\n\n            if doConnect then\n                targetHose.connectedObject = self\n                sourceHose.connectedObject = targetObject\n\n                sourceHose.targetHose = targetHose\n\n                local node, referenceNode\n                if sourceHose.adapterName ~ = nil then\n                    if sourceHose.adapterName ~ = "NONE" then\n                        node, referenceNode = g_connectionHoseManager:getClonedAdapterNode(targetHose.type , sourceHose.adapterName, self.customEnvironment)\n                    end\n                elseif targetHose.adapterName ~ = "NONE" then\n                        node, referenceNode = g_connectionHoseManager:getClonedAdapterNode(targetHose.type , targetHose.adapterName, self.customEnvironment)\n                    end\n\n                    if node ~ = nil then\n                        if sourceHose.adapterMaterial ~ = nil then\n                            sourceHose.adapterMaterial:apply(node, "connector_color_mat" )\n                        end\n\n                        link(g_connectionHoseManager:getSocketTarget(targetHose.socket, targetHose.node), node)\n                        setTranslation(node, 0 , 0 , 0 )\n                        setRotation(node, 0 , 0 , 0 )\n                        targetObject:addAllSubWashableNodes(node)\n\n                        targetHose.adapter.node = node\n                        targetHose.adapter.refNode = referenceNode\n                        targetHose.adapter.isLinked = true\n                    end\n\n                    sourceHose.targetNode = targetHose.adapter.refNode\n\n                    setVisibility(sourceHose.visibilityNode, true )\n                    setShaderParameter(sourceHose.hoseNode, "cv0" , 0 , 0 , - sourceHose.startStraightening, 1 , false )\n                    sourceHose.endStraightening = sourceHose.endStraighteningBase * targetHose.straighteningFactor\n                    sourceHose.endStraighteningDirection = targetHose.straighteningDirection or sourceHose.endStraighteningDirectionBase\n\n                    if sourceHose.dynamicLength then\n                        local hoseType = g_connectionHoseManager:getHoseTypeByName(sourceHose.type , self.customEnvironment)\n                        if hoseType ~ = nil then\n                            local material = g_connectionHoseManager:getHoseMaterialByName(hoseType, sourceHose.hoseType, self.customEnvironment)\n                            if material ~ = nil then\n                                local realLength, _, _, _ = getShaderParameter(sourceHose.hoseNode, "lengthAndDiameter" )\n                                local actualLength = calcDistanceFrom(sourceHose.hoseNode, sourceHose.targetNode)\n\n                                setShaderParameter(sourceHose.hoseNode, "uvScale" , (actualLength / realLength) * material.uvLengthScale, nil , nil , nil , false )\n                            end\n                        end\n                    end\n\n                    ObjectChangeUtil.setObjectChanges(targetHose.objectChanges, true , sourceHose.connectedObject, sourceHose.connectedObject.setMovingToolDirty)\n                    ObjectChangeUtil.setObjectChanges(sourceHose.objectChanges, true , targetHose.connectedObject, targetHose.connectedObject.setMovingToolDirty)\n\n                    g_connectionHoseManager:openSocket(sourceHose.socket)\n                    g_connectionHoseManager:openSocket(targetHose.socket)\n\n                    self:updateConnectionHose(sourceHose, 0 )\n\n                    if self.isClient then\n                        local sample = spec.samples.connect[sourceHose.type ]\n                        if sample ~ = nil then\n                            if not g_soundManager:getIsSamplePlaying(sample) then\n                                g_soundManager:playSample(sample)\n                            end\n                        end\n                    end\n\n                    table.insert(spec.updateableHoses, sourceHose)\n                    return true\n                end\n\n                return false\n            end\n\n'})}),"\n",(0,s.jsx)(n.h3,{id:"connecthosestoattachervehicle",children:"connectHosesToAttacherVehicle"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Definition"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"connectHosesToAttacherVehicle()"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"any"}),(0,s.jsx)(n.th,{children:"attacherVehicle"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"any"}),(0,s.jsx)(n.td,{children:"inputJointDescIndex"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"any"}),(0,s.jsx)(n.td,{children:"jointDescIndex"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"any"}),(0,s.jsx)(n.td,{children:"updateToolConnections"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"any"}),(0,s.jsx)(n.td,{children:"excludeVehicle"})]})]})]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Code"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:"function ConnectionHoses:connectHosesToAttacherVehicle(attacherVehicle, inputJointDescIndex, jointDescIndex, updateToolConnections, excludeVehicle)\n    if attacherVehicle.getConnectionTarget ~ = nil then\n        local hoses = self:getConnectionHosesByInputAttacherJoint(inputJointDescIndex)\n        for _, hose in ipairs(hoses) do\n            attacherVehicle:iterateConnectionTargets( function (target, isSkipNode)\n                if not self:getIsConnectionHoseUsed(hose) then\n                    if not isSkipNode then\n                        if self:connectHose(hose, attacherVehicle, target, updateToolConnections) then\n                            return false\n                        end\n                    else\n                            if self:connectHoseToSkipNode(hose, attacherVehicle, target) then\n                                return false\n                            end\n                        end\n\n                        return true\n                    end\n\n                    return false\n                end , jointDescIndex, hose.type , hose.specType)\n            end\n\n            --try to connect the hoses of attached implements, maybe the connection is now valid since we got another skip node\n            self:retryHoseSkipNodeConnections(updateToolConnections, excludeVehicle)\n        end\n    end\n\n"})}),"\n",(0,s.jsx)(n.h3,{id:"connecthosetoskipnode",children:"connectHoseToSkipNode"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Definition"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"connectHoseToSkipNode()"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"any"}),(0,s.jsx)(n.th,{children:"sourceHose"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"any"}),(0,s.jsx)(n.td,{children:"targetObject"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"any"}),(0,s.jsx)(n.td,{children:"skipNode"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"any"}),(0,s.jsx)(n.td,{children:"childHose"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"any"}),(0,s.jsx)(n.td,{children:"childVehicle"})]})]})]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Code"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:'function ConnectionHoses:connectHoseToSkipNode(sourceHose, targetObject, skipNode, childHose, childVehicle)\n    local spec = self.spec_connectionHoses\n\n    skipNode.connectedObject = self\n    sourceHose.connectedObject = targetObject\n\n    sourceHose.targetHose = skipNode\n    sourceHose.targetNode = skipNode.node\n\n    setVisibility(sourceHose.visibilityNode, true )\n    setShaderParameter(sourceHose.hoseNode, "cv0" , 0 , 0 , - sourceHose.startStraightening, 1 , false )\n\n    ObjectChangeUtil.setObjectChanges(sourceHose.objectChanges, true , self , self.setMovingToolDirty)\n\n    self:addAllSubWashableNodes(sourceHose.hoseNode)\n\n    sourceHose.childVehicle = childVehicle\n    sourceHose.childHose = childHose\n\n    if self.getAttacherVehicle ~ = nil then\n        local attacherVehicle1 = self:getAttacherVehicle()\n        if attacherVehicle1.getAttacherVehicle ~ = nil then\n            local attacherVehicle2 = attacherVehicle1:getAttacherVehicle()\n            if attacherVehicle2 ~ = nil then\n\n                local attacherJointIndex = attacherVehicle2:getAttacherJointIndexFromObject(attacherVehicle1)\n                local implement = attacherVehicle2:getImplementFromAttacherJointIndex(attacherJointIndex)\n\n                if implement.inputJointDescIndex = = skipNode.inputAttacherJointIndex then\n                    local firstValidTarget, isSkipNode = attacherVehicle2:getConnectionTarget(attacherJointIndex, skipNode.type , skipNode.specType)\n                    if firstValidTarget ~ = nil then\n                        local hose = attacherVehicle1:getClonedSkipHoseNode(sourceHose, skipNode)\n                        if not isSkipNode then\n                            attacherVehicle1:connectHose(hose, attacherVehicle2, firstValidTarget)\n                        else\n                                attacherVehicle1:connectHoseToSkipNode(hose, attacherVehicle2, firstValidTarget, sourceHose, attacherVehicle1)\n                            end\n\n                            if skipNode.parentHose ~ = nil then\n                                skipNode.parentVehicle:removeWashableNode(skipNode.parentHose.hoseNode)\n                                delete(skipNode.parentHose.hoseNode)\n                                table.removeElement(spec.updateableHoses, skipNode.parentHose.childHose)\n                            end\n                            skipNode.parentVehicle = attacherVehicle1\n                            skipNode.parentHose = hose\n\n                            sourceHose.parentVehicle = attacherVehicle1\n                            sourceHose.parentHose = hose\n\n                            hose.childVehicle = self\n                            hose.childHose = sourceHose\n\n                            attacherVehicle1:addAllSubWashableNodes(hose.hoseNode)\n                        else\n                                --same hose is still active, just update the relations\n                                if skipNode.parentHose ~ = nil then\n                                    sourceHose.parentVehicle = skipNode.parentVehicle\n                                    sourceHose.parentHose = skipNode.parentHose\n\n                                    sourceHose.parentHose.childVehicle = self\n                                    sourceHose.parentHose.childHose = sourceHose\n                                end\n                            end\n                        end\n                    end\n                end\n            end\n\n            table.insert(spec.updateableHoses, sourceHose)\n            return true\n        end\n\n'})}),"\n",(0,s.jsx)(n.h3,{id:"consolecommandtestsockets",children:"consoleCommandTestSockets"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Definition"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"consoleCommandTestSockets()"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"any"}),(0,s.jsx)(n.th,{children:"vehicle"})]})}),(0,s.jsx)(n.tbody,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"any"}),(0,s.jsx)(n.td,{children:"attacherJointIndex"})]})})]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Code"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:'function ConnectionHoses.consoleCommandTestSockets(vehicle, attacherJointIndex)\n    local spec = vehicle.spec_connectionHoses\n    if spec ~ = nil then\n        local colors = { }\n        colors[ "hydraulicIn" ] = Color.new( 0 , 1 , 0 )\n        colors[ "hydraulicOut" ] = Color.new( 0 , 0 , 1 )\n        colors[ "electric" ] = Color.new( 1 , 0 , 1 )\n        colors[ "airDoubleRed" ] = Color.new( 1 , 0 , 0 )\n        colors[ "airDoubleYellow" ] = Color.new( 1 , 1 , 0 )\n        colors[ "isobus" ] = Color.new( 1 , 1 , 1 )\n\n        local prefix = { }\n        prefix[ "hydraulicIn" ] = "in"\n        prefix[ "hydraulicOut" ] = "out"\n        prefix[ "electric" ] = "e"\n        prefix[ "airDoubleRed" ] = "red"\n        prefix[ "airDoubleYellow" ] = "yel"\n        prefix[ "isobus" ] = "iso"\n\n        local indexByType = { }\n        for index, targetHose in ipairs(spec.targetNodes) do\n            -- first remove the old debug nodes\n            if targetHose.socket ~ = nil then\n                g_connectionHoseManager:closeSocket(targetHose.socket)\n            end\n\n            if targetHose.debugNode ~ = nil then\n                delete(targetHose.debugNode)\n                targetHose.debugNode = nil\n            end\n\n            if targetHose.debugLine ~ = nil then\n                g_debugManager:removeElement(targetHose.debugLine)\n                targetHose.debugLine = nil\n            end\n\n            if targetHose.debugText ~ = nil then\n                g_debugManager:removeElement(targetHose.debugText)\n                targetHose.debugText = nil\n            end\n\n            if targetHose.objectChanges ~ = nil then\n                ObjectChangeUtil.setObjectChanges(targetHose.objectChanges, false , vehicle, vehicle.setMovingToolDirty)\n            end\n\n            if targetHose.attacherJointIndices[attacherJointIndex] ~ = nil then\n                if indexByType[targetHose.type ] = = nil then\n                    indexByType[targetHose.type ] = 0\n                end\n                indexByType[targetHose.type ] = indexByType[targetHose.type ] + 1\n\n                if targetHose.socket ~ = nil then\n                    g_connectionHoseManager:openSocket(targetHose.socket)\n                end\n\n                local node, referenceNode = g_connectionHoseManager:getClonedAdapterNode(targetHose.type , "DEFAULT" , vehicle.customEnvironment)\n                if node ~ = nil then\n                    local material = VehicleMaterial.new()\n                    material:setTemplateName( "plasticPainted" )\n                    material:setColor( 1 , 1 , 1 )\n                    material:apply(node)\n\n                    link(g_connectionHoseManager:getSocketTarget(targetHose.socket, targetHose.node), node)\n                    setTranslation(node, 0 , 0 , 0 )\n                    setRotation(node, 0 , 0 , 0 )\n\n                    targetHose.debugNode = node\n\n                    local attacherJointDesc = vehicle:getAttacherJointByJointDescIndex(attacherJointIndex)\n                    if attacherJointDesc ~ = nil then\n                        targetHose.debugLine = DebugLine.new():createWithStartAndEndNode(attacherJointDesc.jointTransform, referenceNode or node, false , true , 100 , true )\n                        targetHose.debugLine:setColors(colors[targetHose.type ], colors[targetHose.type ])\n                        g_debugManager:addElement(targetHose.debugLine, nil , nil , math.huge)\n\n                        targetHose.debugText = DebugText.new():createWithNode(referenceNode, prefix[targetHose.type ] .. tostring(indexByType[targetHose.type ]), 0.015 , true )\n                        targetHose.debugText.color = colors[targetHose.type ]\n                        g_debugManager:addElement(targetHose.debugText, nil , nil , math.huge)\n                    end\n                end\n\n                if targetHose.objectChanges ~ = nil then\n                    ObjectChangeUtil.setObjectChanges(targetHose.objectChanges, true , vehicle, vehicle.setMovingToolDirty)\n                end\n            end\n        end\n    end\nend\n\n'})}),"\n",(0,s.jsx)(n.h3,{id:"consolecommandtesttoolconnection",children:"consoleCommandTestToolConnection"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Definition"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"consoleCommandTestToolConnection()"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"any"}),(0,s.jsx)(n.th,{children:"vehicle"})]})}),(0,s.jsx)(n.tbody,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"any"}),(0,s.jsx)(n.td,{children:"toolConnectionIndex"})]})})]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Code"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:"function ConnectionHoses.consoleCommandTestToolConnection(vehicle, toolConnectionIndex)\n\n    local spec = vehicle.spec_connectionHoses\n    if spec ~ = nil then\n        local startColor = Color.new( 0 , 1 , 0 )\n        local betweenColor = Color.new( 0 , 0 , 1 )\n        local endColor = Color.new( 1 , 0 , 0 )\n\n        for _, targetHose in ipairs(spec.targetNodes) do\n            -- first remove the old debug nodes\n            if targetHose.socket ~ = nil then\n                g_connectionHoseManager:closeSocket(targetHose.socket)\n            end\n\n            if targetHose.debugElements ~ = nil then\n                for _, element in pairs(targetHose.debugElements) do\n                    g_debugManager:removeElement(element)\n                end\n\n                targetHose.debugElements = nil\n            end\n\n            if targetHose.debugText ~ = nil then\n                g_debugManager:removeElement(targetHose.debugText)\n                targetHose.debugText = nil\n            end\n\n            if targetHose.objectChanges ~ = nil then\n                ObjectChangeUtil.setObjectChanges(targetHose.objectChanges, false , vehicle, vehicle.setMovingToolDirty)\n            end\n        end\n\n        for i = 1 , #spec.toolConnectorHoses do\n            local toolConnectionHose = spec.toolConnectorHoses[i]\n\n            if toolConnectionHose.mountingNode ~ = nil then\n                setVisibility(toolConnectionHose.mountingNode, false )\n            end\n\n            ObjectChangeUtil.setObjectChanges(toolConnectionHose.objectChanges, false , toolConnectionHose.objectChangesTarget, toolConnectionHose.objectChangesTarget.setMovingToolDirty)\n\n            if toolConnectionHose.parentToolConnectionHose ~ = nil then\n                local parentToolConnectionHose = toolConnectionHose.parentToolConnectionHose\n                if parentToolConnectionHose.mountingNode ~ = nil then\n                    setVisibility(parentToolConnectionHose.mountingNode, false )\n                end\n\n                ObjectChangeUtil.setObjectChanges(parentToolConnectionHose.objectChanges, false , parentToolConnectionHose.objectChangesTarget, parentToolConnectionHose.objectChangesTarget.setMovingToolDirty)\n            end\n\n            if toolConnectionHose.debugElements ~ = nil then\n                for _, element in pairs(toolConnectionHose.debugElements) do\n                    g_debugManager:removeElement(element)\n                end\n\n                toolConnectionHose.debugElements = nil\n            end\n        end\n\n        local toolConnectionHose = spec.toolConnectorHoses[toolConnectionIndex]\n        if toolConnectionHose ~ = nil then\n            local startTarget = spec.targetNodes[toolConnectionHose.startTargetNodeIndex]\n            local endTarget = spec.targetNodes[toolConnectionHose.endTargetNodeIndex]\n\n            for _, attacherJointIndex in pairs(startTarget.attacherJointIndices) do\n                local attacherJointDesc = vehicle:getAttacherJointByJointDescIndex(attacherJointIndex)\n                if attacherJointDesc ~ = nil then\n                    local debugLine = DebugLine.new():createWithStartAndEndNode(attacherJointDesc.jointTransform, startTarget.node, false , false , 100 , true )\n                    debugLine:setColors(startColor, startColor)\n                    g_debugManager:addElement(debugLine, nil , nil , math.huge)\n\n                    local debugText = DebugText.new():createWithNode(attacherJointDesc.jointTransform, getName(attacherJointDesc.jointTransform), 0.01 , true )\n                    debugText.color = startColor\n                    g_debugManager:addElement(debugText, nil , nil , math.huge)\n\n                    if startTarget.debugElements = = nil then\n                        startTarget.debugElements = { }\n                    end\n\n                    table.insert(startTarget.debugElements, debugLine)\n                    table.insert(startTarget.debugElements, debugText)\n                end\n            end\n\n            for _, attacherJointIndex in pairs(endTarget.attacherJointIndices) do\n                local attacherJointDesc = vehicle:getAttacherJointByJointDescIndex(attacherJointIndex)\n                if attacherJointDesc ~ = nil then\n                    local debugLine = DebugLine.new():createWithStartAndEndNode(attacherJointDesc.jointTransform, endTarget.node, false , false , 100 , true )\n                    debugLine:setColors(endColor, endColor)\n                    g_debugManager:addElement(debugLine, nil , nil , math.huge)\n\n                    local debugText = DebugText.new():createWithNode(attacherJointDesc.jointTransform, getName(attacherJointDesc.jointTransform), 0.01 , true )\n                    debugText.color = endColor\n                    g_debugManager:addElement(debugText, nil , nil , math.huge)\n\n                    if endTarget.debugElements = = nil then\n                    endTarget.debugElements = { }\n                end\n\n                table.insert(endTarget.debugElements, debugLine)\n                table.insert(endTarget.debugElements, debugText)\n            end\n        end\n\n        local debugLine = DebugLine.new():createWithStartAndEndNode(startTarget.node, endTarget.node, false , true , 100 , true )\n        debugLine:setColors(betweenColor, betweenColor)\n        g_debugManager:addElement(debugLine, nil , nil , math.huge)\n\n        local debugTextStart = DebugText.new():createWithNode(startTarget.node, getName(startTarget.node), 0.01 , true )\n        debugTextStart.color = startColor\n        g_debugManager:addElement(debugTextStart, nil , nil , math.huge)\n\n        local debugTextEnd = DebugText.new():createWithNode(endTarget.node, getName(endTarget.node), 0.01 , true )\n        debugTextEnd.color = endColor\n        g_debugManager:addElement(debugTextEnd, nil , nil , math.huge)\n\n        if toolConnectionHose.debugElements = = nil then\n            toolConnectionHose.debugElements = { }\n        end\n\n        table.insert(toolConnectionHose.debugElements, debugLine)\n        table.insert(toolConnectionHose.debugElements, debugTextStart)\n        table.insert(toolConnectionHose.debugElements, debugTextEnd)\n\n        if toolConnectionHose.mountingNode ~ = nil then\n            setVisibility(toolConnectionHose.mountingNode, true )\n        end\n\n        ObjectChangeUtil.setObjectChanges(toolConnectionHose.objectChanges, true , toolConnectionHose.objectChangesTarget, toolConnectionHose.objectChangesTarget.setMovingToolDirty)\n\n        if toolConnectionHose.parentToolConnectionHose ~ = nil then\n            local parentToolConnectionHose = toolConnectionHose.parentToolConnectionHose\n            if parentToolConnectionHose.mountingNode ~ = nil then\n                setVisibility(parentToolConnectionHose.mountingNode, true )\n            end\n\n            ObjectChangeUtil.setObjectChanges(parentToolConnectionHose.objectChanges, true , parentToolConnectionHose.objectChangesTarget, parentToolConnectionHose.objectChangesTarget.setMovingToolDirty)\n        end\n    end\nend\nend\n\n"})}),"\n",(0,s.jsx)(n.h3,{id:"disconnectcustomhosenode",children:"disconnectCustomHoseNode"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Definition"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"disconnectCustomHoseNode()"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"any"}),(0,s.jsx)(n.th,{children:"customHose"})]})}),(0,s.jsx)(n.tbody,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"any"}),(0,s.jsx)(n.td,{children:"customTarget"})]})})]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Code"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:"function ConnectionHoses:disconnectCustomHoseNode(customHose, customTarget)\n    setTranslation(customHose.node, unpack(customHose.startTranslation))\n    setRotation(customHose.node, unpack(customHose.startRotation))\n\n    if self.setMovingToolDirty ~ = nil then\n        self:setMovingToolDirty(customHose.node, true )\n    end\n\n    customHose.isActive = false\n    customTarget.isActive = false\n\n    customHose.connectedTarget = nil\n    customHose.connectedObject = nil\n    customTarget.connectedHose = nil\n    customTarget.connectedObject = nil\n\n    ObjectChangeUtil.setObjectChanges(customHose.objectChanges, false , customHose.objectChangesTarget, customHose.objectChangesTarget.setMovingToolDirty)\n    ObjectChangeUtil.setObjectChanges(customTarget.objectChanges, false , customTarget.objectChangesTarget, customTarget.objectChangesTarget.setMovingToolDirty)\nend\n\n"})}),"\n",(0,s.jsx)(n.h3,{id:"disconnecthose",children:"disconnectHose"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Definition"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"disconnectHose()"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,s.jsx)(n.table,{children:(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"any"}),(0,s.jsx)(n.th,{children:"hose"})]})})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Code"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:"function ConnectionHoses:disconnectHose(hose)\n    local spec = self.spec_connectionHoses\n    local target = hose.targetHose\n    if target ~ = nil then\n        hose.connectedObject:updateToolConnectionHose( self , hose, hose.connectedObject, target, false )\n\n        local hoseHasSkipNodeTarget = target.isSkipNode ~ = nil and target.isSkipNode\n        local hoseIsFromSkipNodeTarget = hose.isClonedSkipNodeHose ~ = nil and hose.isClonedSkipNodeHose\n        if hoseHasSkipNodeTarget or hoseIsFromSkipNodeTarget then\n            --remove all skip node connections recursively in both directions\n            if hose.parentVehicle ~ = nil and hose.parentHose ~ = nil then\n                hose.parentHose.childVehicle = nil\n                hose.parentHose.childHose = nil\n                hose.parentVehicle:disconnectHose(hose.parentHose)\n            end\n\n            if hose.childVehicle ~ = nil and hose.childHose ~ = nil then\n                hose.childHose.parentVehicle = nil\n                hose.childHose.parentHose = nil\n                hose.childVehicle:disconnectHose(hose.childHose)\n            end\n\n            target.parentHose = nil\n        end\n\n        if target.adapter ~ = nil and target.adapter.isLinked ~ = nil and target.adapter.isLinked then\n            hose.connectedObject:removeAllSubWashableNodes(target.adapter.node)\n            delete(target.adapter.node)\n\n            target.adapter.node = target.node\n            target.adapter.refNode = target.node\n            target.adapter.isLinked = false\n        end\n\n        setVisibility(hose.visibilityNode, false )\n        ObjectChangeUtil.setObjectChanges(target.objectChanges, false , hose.connectedObject, hose.connectedObject.setMovingToolDirty)\n        ObjectChangeUtil.setObjectChanges(hose.objectChanges, false , target.connectedObject, target.connectedObject.setMovingToolDirty)\n\n        g_connectionHoseManager:closeSocket(hose.socket)\n        g_connectionHoseManager:closeSocket(target.socket)\n\n        target.connectedObject = nil\n        hose.connectedObject = nil\n        hose.targetHose = nil\n\n        table.removeElement(spec.updateableHoses, hose)\n\n        if self.isClient then\n            local sample = spec.samples.disconnect[hose.type ]\n            if sample ~ = nil then\n                if not g_soundManager:getIsSamplePlaying(sample) then\n                    g_soundManager:playSample(sample)\n                end\n            end\n        end\n    end\nend\n\n"})}),"\n",(0,s.jsx)(n.h3,{id:"getcenterpointangle",children:"getCenterPointAngle"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Definition"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"getCenterPointAngle()"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"any"}),(0,s.jsx)(n.th,{children:"node"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"any"}),(0,s.jsx)(n.td,{children:"cX"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"any"}),(0,s.jsx)(n.td,{children:"cY"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"any"}),(0,s.jsx)(n.td,{children:"cZ"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"any"}),(0,s.jsx)(n.td,{children:"eX"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"any"}),(0,s.jsx)(n.td,{children:"eY"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"any"}),(0,s.jsx)(n.td,{children:"eZ"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"any"}),(0,s.jsx)(n.td,{children:"useWorldSpace"})]})]})]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Code"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:"function ConnectionHoses:getCenterPointAngle(node, cX, cY, cZ, eX, eY, eZ, useWorldSpace)\n    local lengthStartToCenter = MathUtil.vector3Length(cX, cY, cZ)\n    local lengthCenterToEnd = math.abs( MathUtil.vector3Length(cX - eX, cY - eY, cZ - eZ))\n\n    local _, sY, _ = getWorldTranslation(node)\n    if useWorldSpace then\n        _, cY, _ = localToWorld(node, cX, cY, cZ)\n        _, eY, _ = localToWorld(node, eX, eY, eZ)\n    else\n            sY = 0\n        end\n\n        local lengthStartToCenter2 = sY - cY\n        local lengthCenterToEnd2 = eY - cY\n\n        local angle1 = math.acos(lengthStartToCenter2 / lengthStartToCenter)\n        local angle2 = math.acos(lengthCenterToEnd2 / lengthCenterToEnd)\n\n        return angle1, angle2\n    end\n\n"})}),"\n",(0,s.jsx)(n.h3,{id:"getcenterpointangleregulation",children:"getCenterPointAngleRegulation"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Definition"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"getCenterPointAngleRegulation()"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"any"}),(0,s.jsx)(n.th,{children:"node"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"any"}),(0,s.jsx)(n.td,{children:"cX"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"any"}),(0,s.jsx)(n.td,{children:"cY"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"any"}),(0,s.jsx)(n.td,{children:"cZ"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"any"}),(0,s.jsx)(n.td,{children:"eX"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"any"}),(0,s.jsx)(n.td,{children:"eY"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"any"}),(0,s.jsx)(n.td,{children:"eZ"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"any"}),(0,s.jsx)(n.td,{children:"angle1"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"any"}),(0,s.jsx)(n.td,{children:"angle2"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"any"}),(0,s.jsx)(n.td,{children:"targetAngle"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"any"}),(0,s.jsx)(n.td,{children:"useWorldSpace"})]})]})]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Code"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:"function ConnectionHoses:getCenterPointAngleRegulation(node, cX, cY, cZ, eX, eY, eZ, angle1, angle2, targetAngle, useWorldSpace)\n    local sX, sY, sZ = getWorldTranslation(node)\n    if useWorldSpace then\n        local _\n        cX, _, cZ = localToWorld(node, cX, cY, cZ)\n        eX, _, eZ = localToWorld(node, eX, eY, eZ)\n    else\n            sX, sY, sZ = 0 , 0 , 0\n        end\n\n        local startCenterLength = MathUtil.vector2Length(sX - cX, sZ - cZ)\n        local centerEndLength = MathUtil.vector2Length(eX - cX, eZ - cZ)\n\n        local pct = angle1 / (angle1 + angle2)\n        local alpha = math.pi * 0.5 - (pct * targetAngle)\n\n        local newY1 = math.tan(alpha) * startCenterLength\n        local newY2 = math.tan(alpha) * centerEndLength\n\n        local newY = (newY1 + newY2) / 2\n\n        if useWorldSpace then\n            return worldToLocal(node, cX, sY - newY, cZ)\n        else\n                return cX, sY - newY, cZ\n            end\n        end\n\n"})}),"\n",(0,s.jsx)(n.h3,{id:"getclonedskiphosenode",children:"getClonedSkipHoseNode"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Definition"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"getClonedSkipHoseNode()"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"any"}),(0,s.jsx)(n.th,{children:"sourceHose"})]})}),(0,s.jsx)(n.tbody,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"any"}),(0,s.jsx)(n.td,{children:"skipNode"})]})})]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Code"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:"function ConnectionHoses:getClonedSkipHoseNode(sourceHose, skipNode)\n    local clonedHose = { }\n\n    clonedHose.isClonedSkipNodeHose = true\n\n    clonedHose.type = sourceHose.type\n    clonedHose.specType = sourceHose.specType\n    clonedHose.hoseType = sourceHose.hoseType\n    clonedHose.node = skipNode.node\n\n    clonedHose.component = self:getParentComponent(skipNode.node)\n    clonedHose.lastVelY = 0\n    clonedHose.lastVelZ = 0\n    clonedHose.dampingRange = 0.05\n    clonedHose.dampingFactor = 50\n\n    clonedHose.minDeltaYComponent = self:getParentComponent(skipNode.node)\n    clonedHose.minDeltaY = math.huge\n\n    clonedHose.length = skipNode.length or sourceHose.length\n    clonedHose.diameter = sourceHose.diameter\n    clonedHose.isTwoPointHose = skipNode.isTwoPointHose\n\n    clonedHose.material = sourceHose.material\n\n    local hose, startStraightening, endStraightening, minCenterPointAngle = g_connectionHoseManager:getClonedHoseNode(clonedHose.type , clonedHose.hoseType, clonedHose.length, clonedHose.diameter, clonedHose.material, self.customEnvironment)\n\n    if hose ~ = nil then\n        link(clonedHose.node, hose)\n        setTranslation(hose, 0 , 0 , 0 )\n        setRotation(hose, 0 , 0 , 0 )\n\n        clonedHose.hoseNode = hose\n        clonedHose.visibilityNode = hose\n        clonedHose.startStraightening = startStraightening\n        clonedHose.endStraightening = endStraightening\n        clonedHose.endStraighteningBase = endStraightening\n        clonedHose.endStraighteningDirectionBase = { 0 , 0 , 1 }\n        clonedHose.endStraighteningDirection = clonedHose.endStraighteningDirectionBase\n        clonedHose.minCenterPointAngle = minCenterPointAngle\n\n        setVisibility(clonedHose.visibilityNode, false )\n    else\n            Logging.xmlWarning( self.xmlFile, \"Unable to find connection hose with length '%.2f' and diameter '%.2f' in '%s'\" , clonedHose.length, clonedHose.diameter, \"skipHoseClone\" )\n            return false\n        end\n\n        clonedHose.objectChanges = { }\n\n        return clonedHose\n    end\n\n"})}),"\n",(0,s.jsx)(n.h3,{id:"getconnectionhoseconfigindex",children:"getConnectionHoseConfigIndex"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Definition"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"getConnectionHoseConfigIndex()"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Code"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:"function ConnectionHoses:getConnectionHoseConfigIndex()\n    return 1\nend\n\n"})}),"\n",(0,s.jsx)(n.h3,{id:"getconnectionhosesbyinputattacherjoint",children:"getConnectionHosesByInputAttacherJoint"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Definition"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"getConnectionHosesByInputAttacherJoint()"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,s.jsx)(n.table,{children:(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"any"}),(0,s.jsx)(n.th,{children:"inputJointDescIndex"})]})})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Code"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:"function ConnectionHoses:getConnectionHosesByInputAttacherJoint(inputJointDescIndex)\n    local spec = self.spec_connectionHoses\n\n    if spec.hoseNodesByInputAttacher[inputJointDescIndex] ~ = nil then\n        return spec.hoseNodesByInputAttacher[inputJointDescIndex]\n    end\n\n    return { }\nend\n\n"})}),"\n",(0,s.jsx)(n.h3,{id:"getconnectiontarget",children:"getConnectionTarget"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Definition"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"getConnectionTarget()"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"any"}),(0,s.jsx)(n.th,{children:"attacherJointIndex"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"any"}),(0,s.jsx)(n.td,{children:"type"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"any"}),(0,s.jsx)(n.td,{children:"specType"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"any"}),(0,s.jsx)(n.td,{children:"excludeToolConnections"})]})]})]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Code"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:"function ConnectionHoses:getConnectionTarget(attacherJointIndex, type , specType, excludeToolConnections)\n    local spec = self.spec_connectionHoses\n    if #spec.targetNodes = = 0 and #spec.hoseSkipNodes = = 0 then\n        return nil\n    end\n\n    local nodes = spec.targetNodesByType[ type ]\n    if nodes ~ = nil then\n        for _, node in ipairs(nodes) do\n            if node.attacherJointIndices[attacherJointIndex] ~ = nil then\n                if node.specType = = specType then\n                    if not self:getIsConnectionTargetUsed(node) then\n                        local toolConnectionHose = spec.targetNodeToToolConnection[node.index]\n                        if toolConnectionHose ~ = nil and excludeToolConnections ~ = nil and excludeToolConnections then\n                            if toolConnectionHose.delayedMounting = = nil then\n                                return nil\n                            end\n                        end\n\n                        return node, false\n                    end\n                end\n            end\n        end\n    end\n\n    nodes = spec.hoseSkipNodeByType[ type ]\n    if nodes ~ = nil then\n        for _, node in ipairs(nodes) do\n            if node.specType = = specType then\n                if self:getIsSkipNodeAvailable(node) then\n                    return node, true\n                end\n            end\n        end\n    end\n\n    return nil\nend\n\n"})}),"\n",(0,s.jsx)(n.h3,{id:"getisconnectionhoseused",children:"getIsConnectionHoseUsed"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Definition"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"getIsConnectionHoseUsed()"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,s.jsx)(n.table,{children:(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"any"}),(0,s.jsx)(n.th,{children:"desc"})]})})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Code"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:"function ConnectionHoses:getIsConnectionHoseUsed(desc)\n    return desc.connectedObject ~ = nil\nend\n\n"})}),"\n",(0,s.jsx)(n.h3,{id:"getisconnectiontargetused",children:"getIsConnectionTargetUsed"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Definition"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"getIsConnectionTargetUsed()"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,s.jsx)(n.table,{children:(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"any"}),(0,s.jsx)(n.th,{children:"desc"})]})})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Code"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:"function ConnectionHoses:getIsConnectionTargetUsed(desc)\n    return desc.connectedObject ~ = nil\nend\n\n"})}),"\n",(0,s.jsx)(n.h3,{id:"getisskipnodeavailable",children:"getIsSkipNodeAvailable"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Definition"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"getIsSkipNodeAvailable()"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,s.jsx)(n.table,{children:(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"any"}),(0,s.jsx)(n.th,{children:"skipNode"})]})})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Code"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:"function ConnectionHoses:getIsSkipNodeAvailable(skipNode)\n    if self.getAttacherVehicle = = nil then\n        return false\n    end\n\n    local attacherVehicle = self:getAttacherVehicle()\n    if attacherVehicle ~ = nil then\n        local attacherJointIndex = attacherVehicle:getAttacherJointIndexFromObject( self )\n        local implement = attacherVehicle:getImplementFromAttacherJointIndex(attacherJointIndex)\n\n        if implement.inputJointDescIndex = = skipNode.inputAttacherJointIndex then\n            return attacherVehicle:getConnectionTarget(attacherJointIndex, skipNode.type , skipNode.specType, true ) ~ = nil and skipNode.parentHose = = nil\n        end\n    end\n\n    return false\nend\n\n"})}),"\n",(0,s.jsx)(n.h3,{id:"initspecialization",children:"initSpecialization"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Definition"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"initSpecialization()"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Code"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:'function ConnectionHoses.initSpecialization()\n    local schema = Vehicle.xmlSchema\n    schema:setXMLSpecializationType( "ConnectionHoses" )\n\n    schema:register(XMLValueType.FLOAT, "vehicle.connectionHoses#maxUpdateDistance" , "Max.distance to vehicle root to update connection hoses" , ConnectionHoses.DEFAULT_MAX_UPDATE_DISTANCE)\n\n    ConnectionHoses.registerConnectionHoseXMLPaths(schema, "vehicle.connectionHoses" )\n    ConnectionHoses.registerConnectionHoseXMLPaths(schema, "vehicle.connectionHoses.connectionHoseConfigurations.connectionHoseConfiguration(?)" )\n\n    SoundManager.registerSampleXMLPaths(schema, "vehicle.connectionHoses.sounds" , "connect(?)" )\n    schema:register(XMLValueType.STRING, "vehicle.connectionHoses.sounds.connect(?)#type" , "Connection hose type" )\n\n    SoundManager.registerSampleXMLPaths(schema, "vehicle.connectionHoses.sounds" , "disconnect(?)" )\n    schema:register(XMLValueType.STRING, "vehicle.connectionHoses.sounds.disconnect(?)#type" , "Connection hose type" )\n\n    schema:addDelayedRegistrationFunc( "Cylindered:movingTool" , function (cSchema, cKey)\n        cSchema:register(XMLValueType.VECTOR_N, cKey .. ".connectionHoses#customHoseIndices" , "Custom hoses to update" )\n        cSchema:register(XMLValueType.VECTOR_N, cKey .. ".connectionHoses#customTargetIndices" , "Custom hose targets to update" )\n        cSchema:register(XMLValueType.VECTOR_N, cKey .. ".connectionHoses#localHoseIndices" , "Local hoses to update" )\n    end )\n\n    schema:addDelayedRegistrationFunc( "Cylindered:movingPart" , function (cSchema, cKey)\n        cSchema:register(XMLValueType.VECTOR_N, cKey .. ".connectionHoses#customHoseIndices" , "Custom hoses to update" )\n        cSchema:register(XMLValueType.VECTOR_N, cKey .. ".connectionHoses#customTargetIndices" , "Custom hose targets to update" )\n        cSchema:register(XMLValueType.VECTOR_N, cKey .. ".connectionHoses#localHoseIndices" , "Local hoses to update" )\n    end )\n\n    schema:setXMLSpecializationType()\nend\n\n'})}),"\n",(0,s.jsx)(n.h3,{id:"iterateconnectiontargets",children:"iterateConnectionTargets"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Definition"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"iterateConnectionTargets()"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"any"}),(0,s.jsx)(n.th,{children:"func"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"any"}),(0,s.jsx)(n.td,{children:"attacherJointIndex"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"any"}),(0,s.jsx)(n.td,{children:"type"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"any"}),(0,s.jsx)(n.td,{children:"specType"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"any"}),(0,s.jsx)(n.td,{children:"excludeToolConnections"})]})]})]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Code"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:"function ConnectionHoses:iterateConnectionTargets(func, attacherJointIndex, type , specType, excludeToolConnections)\n    local spec = self.spec_connectionHoses\n    if #spec.targetNodes = = 0 and #spec.hoseSkipNodes = = 0 then\n        return nil\n    end\n\n    local nodes = spec.targetNodesByType[ type ]\n    if nodes ~ = nil then\n        for _, node in ipairs(nodes) do\n            if node.attacherJointIndices[attacherJointIndex] ~ = nil then\n                if node.specType = = specType then\n                    if not self:getIsConnectionTargetUsed(node) then\n                        local toolConnectionHose = spec.targetNodeToToolConnection[node.index]\n                        if toolConnectionHose ~ = nil and excludeToolConnections ~ = nil and excludeToolConnections then\n                            if toolConnectionHose.delayedMounting = = nil then\n                                return nil\n                            end\n                        end\n\n                        if not func(node, false ) then\n                            break\n                        end\n                    end\n                end\n            end\n        end\n    end\n\n    nodes = spec.hoseSkipNodeByType[ type ]\n    if nodes ~ = nil then\n        for _, node in ipairs(nodes) do\n            if node.specType = = specType then\n                if self:getIsSkipNodeAvailable(node) then\n                    if not func(node, true ) then\n                        break\n                    end\n                end\n            end\n        end\n    end\n\n    return nil\nend\n\n"})}),"\n",(0,s.jsx)(n.h3,{id:"loadconnectionhosesfromxml",children:"loadConnectionHosesFromXML"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Definition"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"loadConnectionHosesFromXML()"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"any"}),(0,s.jsx)(n.th,{children:"xmlFile"})]})}),(0,s.jsx)(n.tbody,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"any"}),(0,s.jsx)(n.td,{children:"key"})]})})]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Code"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:'function ConnectionHoses:loadConnectionHosesFromXML(xmlFile, key)\n    local spec = self.spec_connectionHoses\n\n    xmlFile:iterate(key .. ".skipNode" , function (_, hoseKey)\n        local entry = { }\n        if self:loadHoseSkipNode(xmlFile, hoseKey, entry) then\n            table.insert(spec.hoseSkipNodes, entry)\n\n            if spec.hoseSkipNodeByType[entry.type ] = = nil then\n                spec.hoseSkipNodeByType[entry.type ] = { }\n            end\n\n            table.insert(spec.hoseSkipNodeByType[entry.type ], entry)\n        end\n    end )\n\n    self:addHoseTargetNodes(xmlFile, key .. ".target" )\n\n    xmlFile:iterate(key .. ".toolConnectorHose" , function (_, hoseKey)\n        local entry = { }\n        if self:loadToolConnectorHoseNode(xmlFile, hoseKey, entry) then\n            table.insert(spec.toolConnectorHoses, entry)\n\n            spec.targetNodeToToolConnection[entry.startTargetNodeIndex] = entry\n            spec.targetNodeToToolConnection[entry.endTargetNodeIndex] = entry\n        end\n    end )\n\n    xmlFile:iterate(key .. ".hose" , function (_, hoseKey)\n        local entry = { }\n        if self:loadHoseNode(xmlFile, hoseKey, entry, true ) then\n            table.insert(spec.hoseNodes, entry)\n            entry.index = #spec.hoseNodes\n\n            for _, index in pairs(entry.inputAttacherJointIndices) do\n                if spec.hoseNodesByInputAttacher[index] = = nil then\n                    spec.hoseNodesByInputAttacher[index] = { }\n                end\n\n                table.insert(spec.hoseNodesByInputAttacher[index], entry)\n            end\n        end\n    end )\n\n    xmlFile:iterate(key .. ".localHose" , function (_, hoseKey)\n        local hose = { }\n        if self:loadHoseNode(xmlFile, hoseKey .. ".hose" , hose, false ) then\n\n            local target = { }\n            if self:loadHoseTargetNode(xmlFile, hoseKey .. ".target" , target) then\n                table.insert(spec.localHoseNodes, { hose = hose, target = target } )\n            end\n        end\n    end )\n\n    self:loadCustomHosesFromXML( true , spec.customHoses, spec.customHosesByAttacher, spec.customHosesByInputAttacher, xmlFile, key .. ".customHose" )\n\n    self:loadCustomHosesFromXML( false , spec.customHoseTargets, spec.customHoseTargetsByAttacher, spec.customHoseTargetsByInputAttacher, xmlFile, key .. ".customTarget" )\nend\n\n'})}),"\n",(0,s.jsx)(n.h3,{id:"loadcustomhosesfromxml",children:"loadCustomHosesFromXML"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Definition"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"loadCustomHosesFromXML()"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"any"}),(0,s.jsx)(n.th,{children:"isHose"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"any"}),(0,s.jsx)(n.td,{children:"targetTable"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"any"}),(0,s.jsx)(n.td,{children:"attacherJointMapping"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"any"}),(0,s.jsx)(n.td,{children:"inputAttacherJointMapping"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"any"}),(0,s.jsx)(n.td,{children:"xmlFile"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"any"}),(0,s.jsx)(n.td,{children:"key"})]})]})]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Code"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:'function ConnectionHoses:loadCustomHosesFromXML(isHose, targetTable, attacherJointMapping, inputAttacherJointMapping, xmlFile, key)\n    xmlFile:iterate(key, function (_, customKey)\n        local entry = { }\n        entry.node = xmlFile:getValue(customKey .. "#node" , nil , self.components, self.i3dMappings)\n        if entry.node ~ = nil then\n            entry.type = xmlFile:getValue(customKey .. "#type" )\n            if entry.type ~ = nil then\n                entry.type = string.upper(entry.type )\n\n                entry.inputAttacherJointIndices = { }\n                local inputAttacherJointIndices = xmlFile:getValue(customKey .. "#inputAttacherJointIndices" , nil , true )\n                if inputAttacherJointIndices ~ = nil then\n                    for _, v in ipairs(inputAttacherJointIndices) do\n                        entry.inputAttacherJointIndices[v] = v\n\n                        if inputAttacherJointMapping[v] = = nil then\n                            inputAttacherJointMapping[v] = { }\n                        end\n\n                        table.insert(inputAttacherJointMapping[v], entry)\n                    end\n                end\n\n                entry.attacherJointIndices = { }\n                local attacherJointIndices = xmlFile:getValue(customKey .. "#attacherJointIndices" , nil , true )\n                if attacherJointIndices ~ = nil then\n                    for _, v in ipairs(attacherJointIndices) do\n                        entry.attacherJointIndices[v] = v\n\n                        if attacherJointMapping[v] = = nil then\n                            attacherJointMapping[v] = { }\n                        end\n\n                        table.insert(attacherJointMapping[v], entry)\n                    end\n                end\n\n                if isHose then\n                    entry.isActiveDirty = xmlFile:getValue(customKey .. "#isActiveDirty" , false )\n                    if entry.isActiveDirty then\n                        table.insert( self.spec_connectionHoses.customHosesActiveDirty, entry)\n                    end\n\n                    entry.startTranslation = { getTranslation(entry.node) }\n                    entry.startRotation = { getRotation(entry.node) }\n                end\n\n                if next(entry.inputAttacherJointIndices) = = nil and next(entry.attacherJointIndices) = = nil then\n                    Logging.xmlWarning(xmlFile, "Missing inputAttacherJointIndices for custom hose \'%s\'" , customKey)\n                        return false\n                    end\n\n                    entry.objectChanges = { }\n                    ObjectChangeUtil.loadObjectChangeFromXML(xmlFile, customKey, entry.objectChanges, self.components, self )\n                    ObjectChangeUtil.setObjectChanges(entry.objectChanges, false , self , self.setMovingToolDirty, true )\n                    entry.objectChangesTarget = self\n\n                    entry.isActive = false\n\n                    table.insert(targetTable, entry)\n                else\n                        Logging.xmlWarning(xmlFile, "Missing type for custom hose \'%s\'" , customKey)\n                        end\n                    else\n                            Logging.xmlWarning(xmlFile, "Missing node for custom hose \'%s\'" , customKey)\n                            end\n                        end )\n                    end\n\n'})}),"\n",(0,s.jsx)(n.h3,{id:"loadextradependentparts",children:"loadExtraDependentParts"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Definition"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"loadExtraDependentParts()"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"any"}),(0,s.jsx)(n.th,{children:"superFunc"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"any"}),(0,s.jsx)(n.td,{children:"xmlFile"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"any"}),(0,s.jsx)(n.td,{children:"baseName"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"any"}),(0,s.jsx)(n.td,{children:"entry"})]})]})]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Code"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:'function ConnectionHoses:loadExtraDependentParts(superFunc, xmlFile, baseName, entry)\n    if not superFunc( self , xmlFile, baseName, entry) then\n        return false\n    end\n\n    local customHoseIndices = xmlFile:getValue(baseName .. ".connectionHoses#customHoseIndices" , nil , true )\n    if customHoseIndices ~ = nil and #customHoseIndices > 0 then\n        entry.customHoseIndices = customHoseIndices\n    end\n\n    local customTargetIndices = xmlFile:getValue(baseName .. ".connectionHoses#customTargetIndices" , nil , true )\n    if customTargetIndices ~ = nil and #customTargetIndices > 0 then\n        entry.customTargetIndices = customTargetIndices\n    end\n\n    local localHoseIndices = xmlFile:getValue(baseName .. ".connectionHoses#localHoseIndices" , nil , true )\n    if localHoseIndices ~ = nil and #localHoseIndices > 0 then\n        entry.localHoseIndices = localHoseIndices\n    end\n\n    return true\nend\n\n'})}),"\n",(0,s.jsx)(n.h3,{id:"loadhosenode",children:"loadHoseNode"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Definition"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"loadHoseNode()"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"any"}),(0,s.jsx)(n.th,{children:"xmlFile"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"any"}),(0,s.jsx)(n.td,{children:"hoseKey"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"any"}),(0,s.jsx)(n.td,{children:"entry"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"any"}),(0,s.jsx)(n.td,{children:"isBaseHose"})]})]})]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Code"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:'function ConnectionHoses:loadHoseNode(xmlFile, hoseKey, entry, isBaseHose)\n    XMLUtil.checkDeprecatedXMLElements(xmlFile, hoseKey .. "#color" , hoseKey .. "#materialTemplateName" ) -- FS22 to FS25\n    XMLUtil.checkDeprecatedXMLElements(xmlFile, hoseKey .. "#socketColor" , hoseKey .. "#socketMaterialTemplateName" ) -- FS22 to FS25\n\n    entry.inputAttacherJointIndices = { }\n\n    local inputAttacherJointIndices = xmlFile:getValue(hoseKey .. "#inputAttacherJointIndices" , nil , true )\n    if inputAttacherJointIndices ~ = nil then\n        for _, inputAttacherJointIndex in ipairs(inputAttacherJointIndices) do\n            entry.inputAttacherJointIndices[inputAttacherJointIndex] = inputAttacherJointIndex\n        end\n    end\n\n    local inputAttacherJointNodes = xmlFile:getValue(hoseKey .. "#inputAttacherJointNodes" , nil , self.components, self.i3dMappings, true )\n    if inputAttacherJointNodes ~ = nil then\n        for _, node in ipairs(inputAttacherJointNodes) do\n            local inputAttacherJointIndex = self:getInputAttacherJointIndexByNode(node)\n            if inputAttacherJointIndex ~ = nil then\n                entry.inputAttacherJointIndices[inputAttacherJointIndex] = inputAttacherJointIndex\n            end\n        end\n    end\n\n    entry.type = xmlFile:getValue(hoseKey .. "#type" )\n    entry.specType = xmlFile:getValue(hoseKey .. "#specType" )\n    if entry.type = = nil then\n        Logging.xmlWarning(xmlFile, "Missing type attribute in \'%s\'" , hoseKey)\n        return false\n    end\n\n    entry.hoseType = xmlFile:getValue(hoseKey .. "#hoseType" , "DEFAULT" )\n    entry.node = xmlFile:getValue(hoseKey .. "#node" , nil , self.components, self.i3dMappings)\n    if entry.node = = nil then\n        Logging.xmlWarning(xmlFile, "Missing node for connection hose \'%s\'" , hoseKey)\n            return false\n        end\n\n        if isBaseHose then\n            local spec = self.spec_connectionHoses\n            local type = entry.type .. (entry.specType or "" )\n            if spec.numHosesByType[ type ] = = nil then\n                spec.numHosesByType[ type ] = 0\n            end\n            spec.numHosesByType[ type ] = spec.numHosesByType[ type ] + 1\n            entry.typedIndex = spec.numHosesByType[ type ]\n        end\n\n        entry.isTwoPointHose = xmlFile:getValue(hoseKey .. "#isTwoPointHose" , false )\n        entry.isWorldSpaceHose = xmlFile:getValue(hoseKey .. "#isWorldSpaceHose" , true )\n\n        entry.component = self:getParentComponent(entry.node)\n        entry.lastVelY = 0\n        entry.lastVelZ = 0\n        entry.dampingRange = xmlFile:getValue(hoseKey .. "#dampingRange" , 0.05 )\n        entry.dampingFactor = xmlFile:getValue(hoseKey .. "#dampingFactor" , 50 )\n\n        entry.length = xmlFile:getValue(hoseKey .. "#length" , 3 )\n        entry.dynamicLength = xmlFile:getValue(hoseKey .. "#dynamicLength" , false )\n        entry.diameter = xmlFile:getValue(hoseKey .. "#diameter" , 0.02 )\n        entry.straighteningFactor = xmlFile:getValue(hoseKey .. "#straighteningFactor" , 1 )\n        entry.centerPointDropFactor = xmlFile:getValue(hoseKey .. "#centerPointDropFactor" , 1 )\n        entry.centerPointTension = xmlFile:getValue(hoseKey .. "#centerPointTension" , 0 )\n        entry.minCenterPointAngle = xmlFile:getValue(hoseKey .. "#minCenterPointAngle" )\n\n        entry.minCenterPointOffset = xmlFile:getValue(hoseKey .. "#minCenterPointOffset" , nil , true )\n        entry.maxCenterPointOffset = xmlFile:getValue(hoseKey .. "#maxCenterPointOffset" , nil , true )\n\n        if entry.minCenterPointOffset ~ = nil and entry.maxCenterPointOffset ~ = nil then\n            for i = 1 , 3 do\n                if entry.minCenterPointOffset[i] = = 0 then\n                    entry.minCenterPointOffset[i] = - math.huge\n                end\n\n                if entry.maxCenterPointOffset[i] = = 0 then\n                    entry.maxCenterPointOffset[i] = math.huge\n                end\n            end\n\n            for i = 1 , 3 do\n                if entry.maxCenterPointOffset[i] < entry.minCenterPointOffset[i] or entry.minCenterPointOffset[i] > entry.maxCenterPointOffset[i] then\n                    entry.minCenterPointOffset = nil\n                    entry.maxCenterPointOffset = nil\n                    Logging.xmlWarning(xmlFile, "Invalid centerPointOffset in \'%s\'.Max is smaller than min or min is greater than max." , hoseKey)\n                    break\n                end\n            end\n        end\n\n        entry.minDeltaY = xmlFile:getValue(hoseKey .. "#minDeltaY" , math.huge)\n        entry.minDeltaYComponent = xmlFile:getValue(hoseKey .. "#minDeltaYComponent" , entry.component, self.components, self.i3dMappings)\n\n        entry.material = xmlFile:getValue(hoseKey .. "#materialTemplateName" , nil , self.customEnvironment)\n        entry.adapterMaterial = xmlFile:getValue(hoseKey .. "#adapterMaterialTemplateName" , nil , self.customEnvironment)\n\n        entry.adapterName = xmlFile:getValue(hoseKey .. "#adapterType" )\n        entry.outgoingAdapter = xmlFile:getValue(hoseKey .. "#outgoingAdapter" )\n\n        entry.adapterNode = xmlFile:getValue(hoseKey .. "#adapterNode" , nil , self.components, self.i3dMappings)\n        if entry.adapterNode ~ = nil then\n            local node = g_connectionHoseManager:getClonedAdapterNode(entry.type , entry.adapterName or "DEFAULT" , self.customEnvironment, true )\n            if node ~ = nil then\n                if entry.adapterMaterial ~ = nil then\n                    entry.adapterMaterial:apply(node, "connector_color_mat" )\n                end\n\n                link(entry.adapterNode, node)\n            else\n                    Logging.xmlWarning(xmlFile, "Unable to find detached adapter for type \'%s\' in \'%s\'" , entry.adapterName or "DEFAULT" , hoseKey)\n                    end\n                end\n\n                local socketName = xmlFile:getValue(hoseKey .. "#socket" )\n                if socketName ~ = nil then\n                    local socketMaterial = xmlFile:getValue(hoseKey .. "#socketMaterialTemplateName" , nil , self.customEnvironment)\n                    entry.socket = g_connectionHoseManager:linkSocketToNode(socketName, entry.node, self.customEnvironment, socketMaterial)\n                    if entry.socket ~ = nil then\n                        setRotation(entry.socket.node, 0 , math.pi, 0 )\n                    end\n                end\n\n                local hose, startStraightening, endStraightening, minCenterPointAngle = g_connectionHoseManager:getClonedHoseNode(entry.type , entry.hoseType, entry.length, entry.diameter, entry.material, self.customEnvironment)\n\n                if hose ~ = nil then\n                    local outgoingNode, visibilityNode = g_connectionHoseManager:getSocketTarget(entry.socket, entry.node), hose\n                    local rx, ry, rz = 0 , 0 , 0\n                    if entry.outgoingAdapter ~ = nil then\n                        local node, referenceNode = g_connectionHoseManager:getClonedAdapterNode(entry.type , entry.outgoingAdapter, self.customEnvironment)\n                        if node ~ = nil then\n                            if entry.adapterMaterial ~ = nil then\n                                entry.adapterMaterial:apply(node, "connector_color_mat" )\n                            end\n\n                            link(outgoingNode, node)\n                            outgoingNode = referenceNode\n                            visibilityNode = node\n                            ry = math.pi\n\n                            if entry.socket = = nil then\n                                setRotation(node, 0 , ry, 0 )\n                            end\n                        else\n                                Logging.xmlWarning(xmlFile, "Unable to find adapter type \'%s\' in \'%s\'" , entry.outgoingAdapter, hoseKey)\n                            end\n                        end\n\n                        link(outgoingNode, hose)\n                        setTranslation(hose, 0 , 0 , 0 )\n                        setRotation(hose, rx, ry, rz)\n\n                        entry.hoseNode = hose\n                        entry.visibilityNode = visibilityNode\n                        entry.startStraightening = startStraightening * entry.straighteningFactor\n                        entry.endStraightening = endStraightening\n                        entry.endStraighteningBase = endStraightening\n                        entry.endStraighteningDirectionBase = { 0 , 0 , 1 }\n                        entry.endStraighteningDirection = entry.endStraighteningDirectionBase\n                        entry.minCenterPointAngle = entry.minCenterPointAngle or minCenterPointAngle\n\n                        setVisibility(entry.visibilityNode, false )\n                    else\n                            Logging.xmlWarning(xmlFile, "Unable to find connection hose with length \'%.2f\' and diameter \'%.2f\' in \'%s\'" , entry.length, entry.diameter, hoseKey)\n                            return false\n                        end\n\n                        entry.objectChanges = { }\n                        ObjectChangeUtil.loadObjectChangeFromXML(xmlFile, hoseKey, entry.objectChanges, self.components, self )\n                        ObjectChangeUtil.setObjectChanges(entry.objectChanges, false , self , self.setMovingToolDirty, true )\n\n                        return true\n                    end\n\n'})}),"\n",(0,s.jsx)(n.h3,{id:"loadhoseskipnode",children:"loadHoseSkipNode"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Definition"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"loadHoseSkipNode()"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"any"}),(0,s.jsx)(n.th,{children:"xmlFile"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"any"}),(0,s.jsx)(n.td,{children:"targetKey"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"any"}),(0,s.jsx)(n.td,{children:"entry"})]})]})]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Code"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:'function ConnectionHoses:loadHoseSkipNode(xmlFile, targetKey, entry)\n    entry.node = xmlFile:getValue(targetKey .. "#node" , nil , self.components, self.i3dMappings)\n\n    if entry.node = = nil then\n        Logging.xmlWarning(xmlFile, "Missing node for hose skip node \'%s\'" , targetKey)\n            return false\n        end\n\n        entry.inputAttacherJointIndex = xmlFile:getValue(targetKey .. "#inputAttacherJointIndex" , 1 )\n        entry.attacherJointIndex = xmlFile:getValue(targetKey .. "#attacherJointIndex" , 1 )\n\n        entry.type = xmlFile:getValue(targetKey .. "#type" )\n        entry.specType = xmlFile:getValue(targetKey .. "#specType" )\n\n        if entry.type = = nil then\n            Logging.xmlWarning(xmlFile, "Missing type for hose skip node \'%s\'" , targetKey)\n                return false\n            end\n\n            entry.length = xmlFile:getValue(targetKey .. "#length" )\n            entry.isTwoPointHose = xmlFile:getValue(targetKey .. "#isTwoPointHose" , false )\n\n            entry.isSkipNode = true\n\n            return true\n        end\n\n'})}),"\n",(0,s.jsx)(n.h3,{id:"loadhosetargetnode",children:"loadHoseTargetNode"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Definition"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"loadHoseTargetNode()"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"any"}),(0,s.jsx)(n.th,{children:"xmlFile"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"any"}),(0,s.jsx)(n.td,{children:"targetKey"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"any"}),(0,s.jsx)(n.td,{children:"entry"})]})]})]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Code"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:'function ConnectionHoses:loadHoseTargetNode(xmlFile, targetKey, entry)\n    XMLUtil.checkDeprecatedXMLElements(xmlFile, targetKey .. "#socketColor" , targetKey .. "#socketMaterialTemplateName" ) -- FS22 to FS25\n\n    entry.node = xmlFile:getValue(targetKey .. "#node" , nil , self.components, self.i3dMappings)\n\n    if entry.node = = nil then\n        Logging.xmlWarning(xmlFile, "Missing node for connection hose target \'%s\'" , targetKey)\n            return false\n        end\n\n        entry.attacherJointIndices = { }\n\n        local attacherJointIndices = xmlFile:getValue(targetKey .. "#attacherJointIndices" , nil , true )\n        if attacherJointIndices ~ = nil then\n            for _, attacherJointIndex in ipairs(attacherJointIndices) do\n                entry.attacherJointIndices[attacherJointIndex] = attacherJointIndex\n            end\n        end\n\n        local attacherJointNodes = xmlFile:getValue(targetKey .. "#attacherJointNodes" , nil , self.components, self.i3dMappings, true )\n        if attacherJointNodes ~ = nil then\n            for _, node in ipairs(attacherJointNodes) do\n                local attacherJointIndex = self:getAttacherJointIndexByNode(node)\n                if attacherJointIndex ~ = nil then\n                    entry.attacherJointIndices[attacherJointIndex] = attacherJointIndex\n                end\n            end\n        end\n\n        entry.type = xmlFile:getValue(targetKey .. "#type" )\n        entry.specType = xmlFile:getValue(targetKey .. "#specType" )\n        entry.straighteningFactor = xmlFile:getValue(targetKey .. "#straighteningFactor" , 1 )\n        entry.straighteningDirection = xmlFile:getValue(targetKey .. "#straighteningDirection" , nil , true )\n\n        local socketName = xmlFile:getValue(targetKey .. "#socket" )\n        if socketName ~ = nil then\n            local socketMaterial = xmlFile:getValue(targetKey .. "#socketMaterialTemplateName" , nil , self.customEnvironment)\n            entry.socket = g_connectionHoseManager:linkSocketToNode(socketName, entry.node, self.customEnvironment, socketMaterial)\n        end\n\n        if entry.type ~ = nil then\n            entry.adapterName = xmlFile:getValue(targetKey .. "#adapterType" , "DEFAULT" )\n\n            -- empty adapter with target node as reference\n            -- will be replaced with the real adapter on connecting\n            if entry.adapter = = nil then\n                entry.adapter = { }\n                entry.adapter.node = entry.node\n                entry.adapter.refNode = entry.node\n            end\n\n            entry.objectChanges = { }\n            ObjectChangeUtil.loadObjectChangeFromXML(xmlFile, targetKey, entry.objectChanges, self.components, self )\n            ObjectChangeUtil.setObjectChanges(entry.objectChanges, false , self , self.setMovingToolDirty, true )\n        else\n                Logging.xmlWarning(xmlFile, "Missing type for \'%s\'" , targetKey)\n                    return false\n                end\n\n                return true\n            end\n\n'})}),"\n",(0,s.jsx)(n.h3,{id:"loadtoolconnectorhosenode",children:"loadToolConnectorHoseNode"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Definition"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"loadToolConnectorHoseNode()"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"any"}),(0,s.jsx)(n.th,{children:"xmlFile"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"any"}),(0,s.jsx)(n.td,{children:"targetKey"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"any"}),(0,s.jsx)(n.td,{children:"entry"})]})]})]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Code"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:'function ConnectionHoses:loadToolConnectorHoseNode(xmlFile, targetKey, entry)\n    local spec = self.spec_connectionHoses\n\n    local key = string.format( "%s.startTarget" , targetKey)\n    entry.startTargetNodeIndex = self:addHoseTargetNodes(xmlFile, key)\n\n    if entry.startTargetNodeIndex = = nil then\n        Logging.xmlWarning(xmlFile, "startTarget is missing for tool connection hose \'%s\'" , targetKey)\n            return false\n        end\n\n        key = string.format( "%s.endTarget" , targetKey)\n        entry.endTargetNodeIndex = self:addHoseTargetNodes(xmlFile, key)\n\n        if entry.endTargetNodeIndex = = nil then\n            Logging.xmlWarning(xmlFile, "endTarget is missing for tool connection hose \'%s\'" , targetKey)\n                return false\n            end\n\n            local startTarget = spec.targetNodes[entry.startTargetNodeIndex]\n            local endTarget = spec.targetNodes[entry.endTargetNodeIndex]\n\n            for index, _ in pairs(startTarget.attacherJointIndices) do\n                if endTarget.attacherJointIndices[index] ~ = nil then\n                    Logging.xmlWarning(xmlFile, "Double usage of attacher joint index \'%d\' in \'%s\'" , index, targetKey)\n                end\n            end\n\n            entry.moveNodes = xmlFile:getValue(targetKey .. "#moveNodes" , true )\n            entry.additionalHose = xmlFile:getValue(targetKey .. "#additionalHose" , true )\n\n            -- make sure the two nodes are pointing towards each other\n            if entry.moveNodes then\n                local x1, y1, z1 = getTranslation(startTarget.node)\n                local x2, y2, z2 = getTranslation(endTarget.node)\n                local dirX, dirY, dirZ = MathUtil.vector3Normalize(x1 - x2, y1 - y2, z1 - z2)\n                local upX, upY, upZ = localDirectionToLocal(endTarget.node, getParent(endTarget.node), 0 , 1 , 0 )\n                if (dirX ~ = 0 or dirY ~ = 0 or dirZ ~ = 0 )\n                    and not MathUtil.isNan(dirX) and not MathUtil.isNan(dirY) and not MathUtil.isNan(dirZ) then\n                    setDirection(startTarget.node, - dirX, - dirY, - dirZ, upX, upY, upZ)\n                    setDirection(endTarget.node, dirX, dirY, dirZ, upX, upY, upZ)\n                end\n            end\n\n            entry.mountingNode = xmlFile:getValue(targetKey .. "#mountingNode" , nil , self.components, self.i3dMappings)\n\n            if entry.mountingNode ~ = nil then\n                setVisibility(entry.mountingNode, false )\n            end\n\n            entry.objectChanges = { }\n            ObjectChangeUtil.loadObjectChangeFromXML(xmlFile, targetKey, entry.objectChanges, self.components, self )\n            ObjectChangeUtil.setObjectChanges(entry.objectChanges, false , self , self.setMovingToolDirty, true )\n            entry.objectChangesTarget = self\n\n            local type = spec.targetNodes[entry.startTargetNodeIndex].type .. (spec.targetNodes[entry.startTargetNodeIndex].specType or "" )\n            if spec.numToolConnectionsByType[ type ] = = nil then\n                spec.numToolConnectionsByType[ type ] = 0\n            end\n            spec.numToolConnectionsByType[ type ] = spec.numToolConnectionsByType[ type ] + 1\n            entry.typedIndex = spec.numToolConnectionsByType[ type ]\n\n            entry.connected = false\n\n            return true\n        end\n\n'})}),"\n",(0,s.jsx)(n.h3,{id:"ondelete",children:"onDelete"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"Called on deleting"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Definition"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"onDelete()"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Code"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:"function ConnectionHoses:onDelete()\n    local spec = self.spec_connectionHoses\n    if spec.additionalSharedLoadRequestIds ~ = nil then\n        for i = 1 , #spec.additionalSharedLoadRequestIds do\n            g_i3DManager:releaseSharedI3DFile(spec.additionalSharedLoadRequestIds[i])\n        end\n\n        spec.additionalSharedLoadRequestIds = nil\n    end\n\n    if spec.toolConnectionHoseMounts ~ = nil then\n        for _, toolConnectionHoseMount in pairs(spec.toolConnectionHoseMounts) do\n            toolConnectionHoseMount:delete()\n        end\n        spec.toolConnectionHoseMounts = nil\n    end\n\n    if spec.samples ~ = nil then\n        g_soundManager:deleteSamples(spec.samples.connect)\n        g_soundManager:deleteSamples(spec.samples.disconnect)\n    end\nend\n\n"})}),"\n",(0,s.jsx)(n.h3,{id:"onloadfinished",children:"onLoadFinished"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Definition"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"onLoadFinished()"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,s.jsx)(n.table,{children:(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"any"}),(0,s.jsx)(n.th,{children:"savegame"})]})})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Code"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:"function ConnectionHoses:onLoadFinished(savegame)\n    local spec = self.spec_connectionHoses\n\n    -- connection local hoses\n    for _, localHoseNode in ipairs(spec.localHoseNodes) do\n        self:connectHose(localHoseNode.hose, self , localHoseNode.target, false )\n    end\nend\n\n"})}),"\n",(0,s.jsx)(n.h3,{id:"onpostattach",children:"onPostAttach"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Definition"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"onPostAttach()"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"any"}),(0,s.jsx)(n.th,{children:"attacherVehicle"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"any"}),(0,s.jsx)(n.td,{children:"inputJointDescIndex"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"any"}),(0,s.jsx)(n.td,{children:"jointDescIndex"})]})]})]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Code"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:"function ConnectionHoses:onPostAttach(attacherVehicle, inputJointDescIndex, jointDescIndex)\n    if self.spec_connectionHoses.connectionHosesActive then\n        self:connectHosesToAttacherVehicle(attacherVehicle, inputJointDescIndex, jointDescIndex)\n        self:connectCustomHosesToAttacherVehicle(attacherVehicle, inputJointDescIndex, jointDescIndex)\n    end\nend\n\n"})}),"\n",(0,s.jsx)(n.h3,{id:"onpostload",children:"onPostLoad"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Definition"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"onPostLoad()"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,s.jsx)(n.table,{children:(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"any"}),(0,s.jsx)(n.th,{children:"savegame"})]})})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Code"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:'function ConnectionHoses:onPostLoad(savegame)\n    local spec = self.spec_connectionHoses\n\n    local configKey = string.format( "vehicle.connectionHoses.connectionHoseConfigurations.connectionHoseConfiguration(%d)" , spec.configIndex - 1 )\n\n    self:loadConnectionHosesFromXML( self.xmlFile, "vehicle.connectionHoses" )\n\n    if self.xmlFile:hasProperty(configKey) then\n        self:loadConnectionHosesFromXML( self.xmlFile, configKey)\n    end\n\n    ConnectionHoses.registerAdditionalToolConnectionHoses( self )\n\n    spec.targetNodesAvailable = #spec.targetNodes > 0\n    spec.hoseNodesAvailable = #spec.hoseNodes > 0\n    spec.localHosesAvailable = #spec.localHoseNodes > 0\n    spec.skipNodesAvailable = #spec.hoseSkipNodes > 0\n    spec.activeDirtyCustomHosesAvailable = #spec.customHosesActiveDirty > 0\n\n    spec.updateableHoses = { }\n\n    if self.isClient then\n        local function loadSamplesFromKey(key)\n            local samples = { }\n            local i = 0\n            while true do\n                local actionKey = string.format( "%s(%d)" , key, i)\n                local baseKey = "vehicle.connectionHoses.sounds." .. actionKey\n                if not self.xmlFile:hasProperty(baseKey) then\n                    break\n                end\n\n                local sample = g_soundManager:loadSampleFromXML( self.xmlFile, "vehicle.connectionHoses.sounds" , actionKey, self.baseDirectory, self.components, 1 , AudioGroup.VEHICLE, self.i3dMappings, self )\n                if sample ~ = nil then\n                    local type = self.xmlFile:getValue(baseKey .. "#type" )\n\n                    local isValid = false\n                    for i, hose in ipairs(spec.hoseNodes) do\n                        if hose.type = = type then\n                            isValid = true\n                            break\n                        end\n                    end\n\n                    if isValid then\n                        samples[ type ] = sample\n                    else\n                            Logging.xmlWarning( self.xmlFile, "Failed load %s-sound with type %s.No hose with that type available." , key, type )\n                        end\n                    end\n\n                    i = i + 1\n                end\n\n                return samples\n            end\n\n            spec.samples = { }\n            spec.samples.connect = loadSamplesFromKey( "connect" )\n            spec.samples.disconnect = loadSamplesFromKey( "disconnect" )\n        end\n\n        if not self.isClient or( not spec.targetNodesAvailable and not spec.hoseNodesAvailable and not spec.localHosesAvailable and not spec.skipNodesAvailable and not spec.activeDirtyCustomHosesAvailable) then\n            SpecializationUtil.removeEventListener( self , "onUpdateInterpolation" , ConnectionHoses )\n        end\n    end\n\n'})}),"\n",(0,s.jsx)(n.h3,{id:"onpredetach",children:"onPreDetach"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Definition"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"onPreDetach()"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"any"}),(0,s.jsx)(n.th,{children:"attacherVehicle"})]})}),(0,s.jsx)(n.tbody,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"any"}),(0,s.jsx)(n.td,{children:"implement"})]})})]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Code"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:"function ConnectionHoses:onPreDetach(attacherVehicle, implement)\n    local spec = self.spec_connectionHoses\n\n    local inputJointDescIndex = self:getActiveInputAttacherJointDescIndex()\n\n    local hoses = self:getConnectionHosesByInputAttacherJoint(inputJointDescIndex)\n    for _, hose in ipairs(hoses) do\n        self:disconnectHose(hose)\n    end\n\n    for i = #spec.updateableHoses, 1 , - 1 do\n        local hose = spec.updateableHoses[i]\n        if hose.connectedObject = = attacherVehicle then\n            self:disconnectHose(hose)\n        end\n    end\n\n    -- remove delayed mounting if we detach the implement\n        local attacherVehicleSpec = attacherVehicle.spec_connectionHoses\n        if attacherVehicleSpec ~ = nil then\n            for _, toolConnector in pairs(attacherVehicleSpec.toolConnectorHoses) do\n                if toolConnector.delayedMounting ~ = nil then\n                    if toolConnector.delayedMounting.sourceObject = = self then\n                        toolConnector.delayedMounting = nil\n                    end\n                end\n            end\n        end\n\n        local customHoses = spec.customHosesByInputAttacher[inputJointDescIndex]\n        if customHoses ~ = nil then\n            for i = 1 , #customHoses do\n                local customHose = customHoses[i]\n                if customHose.isActive then\n                    self:disconnectCustomHoseNode(customHose, customHose.connectedTarget)\n                end\n            end\n        end\n\n        local customTargets = spec.customHoseTargetsByInputAttacher[inputJointDescIndex]\n        if customTargets ~ = nil then\n            for i = 1 , #customTargets do\n                local customTarget = customTargets[i]\n                if customTarget.isActive then\n                    self:disconnectCustomHoseNode(customTarget.connectedHose, customTarget)\n                end\n            end\n        end\n    end\n\n"})}),"\n",(0,s.jsx)(n.h3,{id:"onpreload",children:"onPreLoad"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Definition"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"onPreLoad()"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,s.jsx)(n.table,{children:(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"any"}),(0,s.jsx)(n.th,{children:"savegame"})]})})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Code"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:'function ConnectionHoses:onPreLoad(savegame)\n    local spec = self.spec_connectionHoses\n    spec.configIndex = self:getConnectionHoseConfigIndex()\n\n    spec.connectionHosesActive = true\n\n    spec.numHosesByType = { }\n    spec.numToolConnectionsByType = { }\n\n    spec.hoseSkipNodes = { }\n    spec.hoseSkipNodeByType = { }\n\n    spec.targetNodes = { }\n    spec.targetNodesByType = { }\n\n    spec.toolConnectorHoses = { }\n    spec.targetNodeToToolConnection = { }\n\n    spec.hoseNodes = { }\n    spec.hoseNodesByInputAttacher = { }\n\n    spec.localHoseNodes = { }\n\n    spec.customHoses = { }\n    spec.customHosesByAttacher = { }\n    spec.customHosesByInputAttacher = { }\n    spec.customHosesActiveDirty = { }\n\n    spec.customHoseTargets = { }\n    spec.customHoseTargetsByAttacher = { }\n    spec.customHoseTargetsByInputAttacher = { }\n\n    spec.additionalSharedLoadRequestIds = { }\n    spec.toolConnectionHoseMounts = { }\n\n    spec.maxUpdateDistance = self.xmlFile:getValue( "vehicle.connectionHoses#maxUpdateDistance" , ConnectionHoses.DEFAULT_MAX_UPDATE_DISTANCE)\nend\n\n'})}),"\n",(0,s.jsx)(n.h3,{id:"onupdateend",children:"onUpdateEnd"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Definition"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"onUpdateEnd()"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"any"}),(0,s.jsx)(n.th,{children:"dt"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"any"}),(0,s.jsx)(n.td,{children:"isActiveForInput"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"any"}),(0,s.jsx)(n.td,{children:"isActiveForInputIgnoreSelection"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"any"}),(0,s.jsx)(n.td,{children:"isSelected"})]})]})]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Code"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:"function ConnectionHoses:onUpdateEnd(dt, isActiveForInput, isActiveForInputIgnoreSelection, isSelected)\n    -- final update before the physics sleeps(self.currentUpdateDistance is 0 here)\n    ConnectionHoses.onUpdateInterpolation( self , dt, isActiveForInput, isActiveForInputIgnoreSelection, isSelected)\nend\n\n"})}),"\n",(0,s.jsx)(n.h3,{id:"onupdateinterpolation",children:"onUpdateInterpolation"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"Called after position interpolation update"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Definition"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"onUpdateInterpolation(float dt, boolean isActiveForInput, boolean isSelected, )"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"float"}),(0,s.jsx)(n.th,{children:"dt"}),(0,s.jsx)(n.th,{children:"time since last call in ms"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"boolean"}),(0,s.jsx)(n.td,{children:"isActiveForInput"}),(0,s.jsx)(n.td,{children:"true if vehicle is active for input"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"boolean"}),(0,s.jsx)(n.td,{children:"isSelected"}),(0,s.jsx)(n.td,{children:"true if vehicle is selected"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"any"}),(0,s.jsx)(n.td,{children:"isSelected"}),(0,s.jsx)(n.td,{})]})]})]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Code"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:"function ConnectionHoses:onUpdateInterpolation(dt, isActiveForInput, isActiveForInputIgnoreSelection, isSelected)\n    local spec = self.spec_connectionHoses\n    if self.currentUpdateDistance < spec.maxUpdateDistance then\n        for i = 1 , #spec.updateableHoses do\n            local hose = spec.updateableHoses[i]\n            if self.updateLoopIndex = = hose.connectedObject.updateLoopIndex then\n                self:updateConnectionHose(hose, i)\n            end\n        end\n\n        for i, customHose in ipairs(spec.customHosesActiveDirty) do\n            if customHose.isActive and customHose.connectedTarget ~ = nil then\n                if self.updateLoopIndex = = customHose.connectedObject.updateLoopIndex then\n                    self:updateCustomHoseNode(customHose, customHose.connectedTarget)\n                end\n            end\n        end\n\n        if self.getAttachedImplements ~ = nil then\n            local impements = self:getAttachedImplements()\n            for i = 1 , #impements do\n                local object = impements[i].object\n                if object.updateAttachedConnectionHoses ~ = nil then\n                    object:updateAttachedConnectionHoses( self )\n                end\n            end\n        end\n    end\nend\n\n"})}),"\n",(0,s.jsx)(n.h3,{id:"prerequisitespresent",children:"prerequisitesPresent"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Definition"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"prerequisitesPresent()"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,s.jsx)(n.table,{children:(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"any"}),(0,s.jsx)(n.th,{children:"specializations"})]})})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Code"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:"function ConnectionHoses.prerequisitesPresent(specializations)\n    return true\nend\n\n"})}),"\n",(0,s.jsx)(n.h3,{id:"registerconnectionhosexmlpaths",children:"registerConnectionHoseXMLPaths"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Definition"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"registerConnectionHoseXMLPaths()"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"any"}),(0,s.jsx)(n.th,{children:"schema"})]})}),(0,s.jsx)(n.tbody,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"any"}),(0,s.jsx)(n.td,{children:"basePath"})]})})]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Code"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:'function ConnectionHoses.registerConnectionHoseXMLPaths(schema, basePath)\n    schema:register(XMLValueType.NODE_INDEX, basePath .. ".skipNode(?)#node" , "Skip node" )\n    schema:register(XMLValueType.INT, basePath .. ".skipNode(?)#inputAttacherJointIndex" , "Input attacher joint index" , 1 )\n    schema:register(XMLValueType.INT, basePath .. ".skipNode(?)#attacherJointIndex" , "Attacher joint index" , 1 )\n    schema:register(XMLValueType.STRING, basePath .. ".skipNode(?)#type" , "Connection hose type" )\n    schema:register(XMLValueType.STRING, basePath .. ".skipNode(?)#specType" , "Connection hose specialization type(if defined it needs to match the type of the other tool)" )\n        schema:register(XMLValueType.FLOAT, basePath .. ".skipNode(?)#length" , "Hose length" )\n        schema:register(XMLValueType.BOOL, basePath .. ".skipNode(?)#isTwoPointHose" , "Is two point hose without sagging" , false )\n\n        ConnectionHoses.registerHoseTargetNodesXMLPaths(schema, basePath .. ".target(?)" )\n\n        schema:register(XMLValueType.NODE_INDEX, basePath .. ".toolConnectorHose(?)#mountingNode" , "Mounting node to toggle visibility" )\n        schema:register(XMLValueType.BOOL, basePath .. ".toolConnectorHose(?)#moveNodes" , "Defines if the start and end nodes are moved up depending on hose diameter" , true )\n        schema:register(XMLValueType.BOOL, basePath .. ".toolConnectorHose(?)#additionalHose" , "Defines if between start and end node a additional hose is created" , true )\n        ConnectionHoses.registerHoseTargetNodesXMLPaths(schema, basePath .. ".toolConnectorHose(?).startTarget(?)" )\n        ConnectionHoses.registerHoseTargetNodesXMLPaths(schema, basePath .. ".toolConnectorHose(?).endTarget(?)" )\n\n        ObjectChangeUtil.registerObjectChangeXMLPaths(schema, basePath .. ".toolConnectorHose(?)" )\n\n        ConnectionHoses.registerHoseNodesXMLPaths(schema, basePath .. ".hose(?)" )\n\n        ConnectionHoses.registerHoseNodesXMLPaths(schema, basePath .. ".localHose(?).hose" )\n        ConnectionHoses.registerHoseTargetNodesXMLPaths(schema, basePath .. ".localHose(?).target" )\n\n        ConnectionHoses.registerCustomHoseNodesXMLPaths(schema, basePath .. ".customHose(?)" )\n        ConnectionHoses.registerCustomHoseTargetNodesXMLPaths(schema, basePath .. ".customTarget(?)" )\n    end\n\n'})}),"\n",(0,s.jsx)(n.h3,{id:"registercustomhosenodesxmlpaths",children:"registerCustomHoseNodesXMLPaths"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Definition"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"registerCustomHoseNodesXMLPaths()"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"any"}),(0,s.jsx)(n.th,{children:"schema"})]})}),(0,s.jsx)(n.tbody,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"any"}),(0,s.jsx)(n.td,{children:"basePath"})]})})]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Code"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:'function ConnectionHoses.registerCustomHoseNodesXMLPaths(schema, basePath)\n    schema:register(XMLValueType.NODE_INDEX, basePath .. "#node" , "Target or source node" )\n    schema:register(XMLValueType.STRING, basePath .. "#type" , "Hose type which can be any string that needs to match between hose and target node" )\n    schema:register(XMLValueType.VECTOR_N, basePath .. "#inputAttacherJointIndices" , "Input attacher joint indices" )\n    schema:register(XMLValueType.VECTOR_N, basePath .. "#attacherJointIndices" , "Attacher joint indices" )\n    schema:register(XMLValueType.BOOL, basePath .. "#isActiveDirty" , "Custom hose is permanently updated" , false )\n\n    ObjectChangeUtil.registerObjectChangeXMLPaths(schema, basePath)\nend\n\n'})}),"\n",(0,s.jsx)(n.h3,{id:"registercustomhosetargetnodesxmlpaths",children:"registerCustomHoseTargetNodesXMLPaths"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Definition"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"registerCustomHoseTargetNodesXMLPaths()"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"any"}),(0,s.jsx)(n.th,{children:"schema"})]})}),(0,s.jsx)(n.tbody,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"any"}),(0,s.jsx)(n.td,{children:"basePath"})]})})]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Code"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:'function ConnectionHoses.registerCustomHoseTargetNodesXMLPaths(schema, basePath)\n    schema:register(XMLValueType.NODE_INDEX, basePath .. "#node" , "Target or source node" )\n    schema:register(XMLValueType.STRING, basePath .. "#type" , "Hose type which can be any string that needs to match between hose and target node" )\n    schema:register(XMLValueType.VECTOR_N, basePath .. "#inputAttacherJointIndices" , "Input attacher joint indices" )\n    schema:register(XMLValueType.VECTOR_N, basePath .. "#attacherJointIndices" , "Attacher joint indices" )\n\n    ObjectChangeUtil.registerObjectChangeXMLPaths(schema, basePath)\nend\n\n'})}),"\n",(0,s.jsx)(n.h3,{id:"registereventlisteners",children:"registerEventListeners"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Definition"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"registerEventListeners()"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,s.jsx)(n.table,{children:(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"any"}),(0,s.jsx)(n.th,{children:"vehicleType"})]})})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Code"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:'function ConnectionHoses.registerEventListeners(vehicleType)\n    SpecializationUtil.registerEventListener(vehicleType, "onPreLoad" , ConnectionHoses )\n    SpecializationUtil.registerEventListener(vehicleType, "onPostLoad" , ConnectionHoses )\n    SpecializationUtil.registerEventListener(vehicleType, "onLoadFinished" , ConnectionHoses )\n    SpecializationUtil.registerEventListener(vehicleType, "onDelete" , ConnectionHoses )\n    SpecializationUtil.registerEventListener(vehicleType, "onUpdateInterpolation" , ConnectionHoses )\n    SpecializationUtil.registerEventListener(vehicleType, "onUpdateEnd" , ConnectionHoses )\n    SpecializationUtil.registerEventListener(vehicleType, "onPostAttach" , ConnectionHoses )\n    SpecializationUtil.registerEventListener(vehicleType, "onPreDetach" , ConnectionHoses )\nend\n\n'})}),"\n",(0,s.jsx)(n.h3,{id:"registerfunctions",children:"registerFunctions"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Definition"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"registerFunctions()"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,s.jsx)(n.table,{children:(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"any"}),(0,s.jsx)(n.th,{children:"vehicleType"})]})})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Code"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:'function ConnectionHoses.registerFunctions(vehicleType)\n    SpecializationUtil.registerFunction(vehicleType, "getConnectionHoseConfigIndex" , ConnectionHoses.getConnectionHoseConfigIndex)\n    SpecializationUtil.registerFunction(vehicleType, "updateAttachedConnectionHoses" , ConnectionHoses.updateAttachedConnectionHoses)\n    SpecializationUtil.registerFunction(vehicleType, "updateConnectionHose" , ConnectionHoses.updateConnectionHose)\n    SpecializationUtil.registerFunction(vehicleType, "getCenterPointAngle" , ConnectionHoses.getCenterPointAngle)\n    SpecializationUtil.registerFunction(vehicleType, "getCenterPointAngleRegulation" , ConnectionHoses.getCenterPointAngleRegulation)\n    SpecializationUtil.registerFunction(vehicleType, "loadConnectionHosesFromXML" , ConnectionHoses.loadConnectionHosesFromXML)\n    SpecializationUtil.registerFunction(vehicleType, "loadHoseSkipNode" , ConnectionHoses.loadHoseSkipNode)\n    SpecializationUtil.registerFunction(vehicleType, "loadToolConnectorHoseNode" , ConnectionHoses.loadToolConnectorHoseNode)\n    SpecializationUtil.registerFunction(vehicleType, "addHoseTargetNodes" , ConnectionHoses.addHoseTargetNodes)\n    SpecializationUtil.registerFunction(vehicleType, "loadCustomHosesFromXML" , ConnectionHoses.loadCustomHosesFromXML)\n    SpecializationUtil.registerFunction(vehicleType, "loadHoseTargetNode" , ConnectionHoses.loadHoseTargetNode)\n    SpecializationUtil.registerFunction(vehicleType, "loadHoseNode" , ConnectionHoses.loadHoseNode)\n    SpecializationUtil.registerFunction(vehicleType, "getClonedSkipHoseNode" , ConnectionHoses.getClonedSkipHoseNode)\n    SpecializationUtil.registerFunction(vehicleType, "getConnectionTarget" , ConnectionHoses.getConnectionTarget)\n    SpecializationUtil.registerFunction(vehicleType, "iterateConnectionTargets" , ConnectionHoses.iterateConnectionTargets)\n    SpecializationUtil.registerFunction(vehicleType, "getIsConnectionTargetUsed" , ConnectionHoses.getIsConnectionTargetUsed)\n    SpecializationUtil.registerFunction(vehicleType, "getIsConnectionHoseUsed" , ConnectionHoses.getIsConnectionHoseUsed)\n    SpecializationUtil.registerFunction(vehicleType, "getIsSkipNodeAvailable" , ConnectionHoses.getIsSkipNodeAvailable)\n    SpecializationUtil.registerFunction(vehicleType, "getConnectionHosesByInputAttacherJoint" , ConnectionHoses.getConnectionHosesByInputAttacherJoint)\n    SpecializationUtil.registerFunction(vehicleType, "connectHose" , ConnectionHoses.connectHose)\n    SpecializationUtil.registerFunction(vehicleType, "disconnectHose" , ConnectionHoses.disconnectHose)\n    SpecializationUtil.registerFunction(vehicleType, "updateToolConnectionHose" , ConnectionHoses.updateToolConnectionHose)\n    SpecializationUtil.registerFunction(vehicleType, "addHoseToDelayedMountings" , ConnectionHoses.addHoseToDelayedMountings)\n    SpecializationUtil.registerFunction(vehicleType, "connectHoseToSkipNode" , ConnectionHoses.connectHoseToSkipNode)\n    SpecializationUtil.registerFunction(vehicleType, "connectHosesToAttacherVehicle" , ConnectionHoses.connectHosesToAttacherVehicle)\n    SpecializationUtil.registerFunction(vehicleType, "retryHoseSkipNodeConnections" , ConnectionHoses.retryHoseSkipNodeConnections)\n    SpecializationUtil.registerFunction(vehicleType, "connectCustomHosesToAttacherVehicle" , ConnectionHoses.connectCustomHosesToAttacherVehicle)\n    SpecializationUtil.registerFunction(vehicleType, "connectCustomHoseNode" , ConnectionHoses.connectCustomHoseNode)\n    SpecializationUtil.registerFunction(vehicleType, "updateCustomHoseNode" , ConnectionHoses.updateCustomHoseNode)\n    SpecializationUtil.registerFunction(vehicleType, "disconnectCustomHoseNode" , ConnectionHoses.disconnectCustomHoseNode)\n    SpecializationUtil.registerFunction(vehicleType, "setConnectionHosesActive" , ConnectionHoses.setConnectionHosesActive)\nend\n\n'})}),"\n",(0,s.jsx)(n.h3,{id:"registerhosenodesxmlpaths",children:"registerHoseNodesXMLPaths"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Definition"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"registerHoseNodesXMLPaths()"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"any"}),(0,s.jsx)(n.th,{children:"schema"})]})}),(0,s.jsx)(n.tbody,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"any"}),(0,s.jsx)(n.td,{children:"basePath"})]})})]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Code"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:'function ConnectionHoses.registerHoseNodesXMLPaths(schema, basePath)\n    schema:register(XMLValueType.VECTOR_N, basePath .. "#inputAttacherJointIndices" , "List of corresponding input attacher joint indices" )\n    schema:register(XMLValueType.NODE_INDICES, basePath .. "#inputAttacherJointNodes" , "List of corresponding input attacher joint nodes(i3dIdentifiers or paths separated by space)" )\n    schema:register(XMLValueType.STRING, basePath .. "#type" , "Hose type" )\n    schema:register(XMLValueType.STRING, basePath .. "#specType" , "Connection hose specialization type(if defined it needs to match the type of the other tool)" )\n        schema:register(XMLValueType.STRING, basePath .. "#hoseType" , "Hose material type" , "DEFAULT" )\n        schema:register(XMLValueType.NODE_INDEX, basePath .. "#node" , "Hose output node" )\n        schema:register(XMLValueType.BOOL, basePath .. "#isTwoPointHose" , "Is two point hose without sagging" , false )\n        schema:register(XMLValueType.BOOL, basePath .. "#isWorldSpaceHose" , "Sagging is calculated in world space or local space of hose node" , true )\n        schema:register(XMLValueType.STRING, basePath .. "#dampingRange" , "Damping range in meters" , 0.05 )\n        schema:register(XMLValueType.FLOAT, basePath .. "#dampingFactor" , "Damping factor" , 50 )\n        schema:register(XMLValueType.FLOAT, basePath .. "#length" , "Hose length" , 3 )\n        schema:register(XMLValueType.BOOL, basePath .. "#dynamicLength" , "Use will calculate the length on attach" , false )\n        schema:register(XMLValueType.FLOAT, basePath .. "#diameter" , "Hose diameter" , 0.02 )\n        schema:register(XMLValueType.FLOAT, basePath .. "#straighteningFactor" , "Straightening Factor" , 1 )\n        schema:register(XMLValueType.FLOAT, basePath .. "#centerPointDropFactor" , "Can be used to manipulate how much the hose will drop while it\'s getting shorter then set" , 1 )\n            schema:register(XMLValueType.FLOAT, basePath .. "#centerPointTension" , "Defines the tension on the center control point(0:default behavior)" , 0 )\n            schema:register(XMLValueType.ANGLE, basePath .. "#minCenterPointAngle" , "Min.angle of sagged curve" , "Defined on connectionHose xml, default 90 degree" )\n            schema:register(XMLValueType.VECTOR_TRANS, basePath .. "#minCenterPointOffset" , "Min.center point offset from hose node" , "unlimited" )\n            schema:register(XMLValueType.VECTOR_TRANS, basePath .. "#maxCenterPointOffset" , "Max.center point offset from hose node" , "unlimited" )\n            schema:register(XMLValueType.FLOAT, basePath .. "#minDeltaY" , "Min.delta Y from center point" )\n            schema:register(XMLValueType.NODE_INDEX, basePath .. "#minDeltaYComponent" , "Min.delta Y reference node" )\n            schema:register(XMLValueType.VEHICLE_MATERIAL, basePath .. "#materialTemplateName" , "Hose material" )\n            schema:registerAutoCompletionDataSource(basePath .. "#materialTemplateName" , "$data/shared/brandMaterialTemplates.xml" , "templates.template#name" )\n            schema:register(XMLValueType.VEHICLE_MATERIAL, basePath .. "#adapterMaterialTemplateName" , "Material of colorable part of adapter" )\n            schema:registerAutoCompletionDataSource(basePath .. "#adapterMaterialTemplateName" , "$data/shared/brandMaterialTemplates.xml" , "templates.template#name" )\n            schema:register(XMLValueType.STRING, basePath .. "#adapterType" , "Adapter type name" )\n            schema:register(XMLValueType.NODE_INDEX, basePath .. "#adapterNode" , "Link node for detached adapter" )\n                schema:register(XMLValueType.STRING, basePath .. "#outgoingAdapter" , "Adapter type that is used for outgoing connection hose" )\n                    schema:register(XMLValueType.STRING, basePath .. "#socket" , "Outgoing socket name to load" )\n                    schema:register(XMLValueType.VEHICLE_MATERIAL, basePath .. "#socketMaterialTemplateName" , "Socket custom material" )\n                    schema:registerAutoCompletionDataSource(basePath .. "#socketMaterialTemplateName" , "$data/shared/brandMaterialTemplates.xml" , "templates.template#name" )\n\n                    ObjectChangeUtil.registerObjectChangeXMLPaths(schema, basePath)\n                end\n\n'})}),"\n",(0,s.jsx)(n.h3,{id:"registerhosetargetnodesxmlpaths",children:"registerHoseTargetNodesXMLPaths"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Definition"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"registerHoseTargetNodesXMLPaths(XMLSchema schema, string basePath)"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"XMLSchema"}),(0,s.jsx)(n.th,{children:"schema"})]})}),(0,s.jsx)(n.tbody,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"string"}),(0,s.jsx)(n.td,{children:"basePath"})]})})]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Code"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:'function ConnectionHoses.registerHoseTargetNodesXMLPaths(schema, basePath)\n    schema:addDelayedRegistrationPath(basePath, "ConnectionHoses:targetNode" )\n\n    schema:register(XMLValueType.NODE_INDEX, basePath .. "#node" , "Target node" )\n    schema:register(XMLValueType.VECTOR_N, basePath .. "#attacherJointIndices" , "List of corresponding attacher joint indices" )\n    schema:register(XMLValueType.NODE_INDICES, basePath .. "#attacherJointNodes" , "List of corresponding attacher joint nodes(i3dIdentifiers or paths separated by space)" )\n    schema:register(XMLValueType.STRING, basePath .. "#type" , "Hose type" )\n    schema:registerAutoCompletionDataSource(basePath .. "#type" , "data/shared/connectionHoses/connectionHoses.xml" , "connectionHoses.connectionHoseTypes.connectionHoseType#name" )\n    schema:register(XMLValueType.STRING, basePath .. "#specType" , "Connection hose specialization type(if defined it needs to match the type of the other tool)" )\n        schema:register(XMLValueType.FLOAT, basePath .. "#straighteningFactor" , "Straightening Factor" , 1 )\n        schema:register(XMLValueType.VECTOR_ 3 , basePath .. "#straighteningDirection" , "Straightening direction" , "0 0 1" )\n        schema:register(XMLValueType.STRING, basePath .. "#socket" , "Socket name to load" )\n        schema:register(XMLValueType.VEHICLE_MATERIAL, basePath .. "#socketMaterialTemplateName" , "Socket custom material" )\n        schema:registerAutoCompletionDataSource(basePath .. "#socketMaterialTemplateName" , "$data/shared/brandMaterialTemplates.xml" , "templates.template#name" )\n        schema:register(XMLValueType.STRING, basePath .. "#adapterType" , "Adapter type to use" , "DEFAULT" )\n\n        ObjectChangeUtil.registerObjectChangeXMLPaths(schema, basePath)\n    end\n\n'})}),"\n",(0,s.jsx)(n.h3,{id:"registeroverwrittenfunctions",children:"registerOverwrittenFunctions"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Definition"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"registerOverwrittenFunctions()"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,s.jsx)(n.table,{children:(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"any"}),(0,s.jsx)(n.th,{children:"vehicleType"})]})})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Code"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:'function ConnectionHoses.registerOverwrittenFunctions(vehicleType)\n    SpecializationUtil.registerOverwrittenFunction(vehicleType, "loadExtraDependentParts" , ConnectionHoses.loadExtraDependentParts)\n    SpecializationUtil.registerOverwrittenFunction(vehicleType, "updateExtraDependentParts" , ConnectionHoses.updateExtraDependentParts)\nend\n\n'})}),"\n",(0,s.jsx)(n.h3,{id:"retryhoseskipnodeconnections",children:"retryHoseSkipNodeConnections"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Definition"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"retryHoseSkipNodeConnections()"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"any"}),(0,s.jsx)(n.th,{children:"updateToolConnections"})]})}),(0,s.jsx)(n.tbody,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"any"}),(0,s.jsx)(n.td,{children:"excludeVehicle"})]})})]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Code"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:"function ConnectionHoses:retryHoseSkipNodeConnections(updateToolConnections, excludeVehicle)\n    if self.getAttachedImplements ~ = nil then\n        local attachedImplements = self:getAttachedImplements()\n        for _, implement in ipairs(attachedImplements) do\n            local object = implement.object\n            if object ~ = excludeVehicle then\n                if object.connectHosesToAttacherVehicle ~ = nil then\n                    object:connectHosesToAttacherVehicle( self , implement.inputJointDescIndex, implement.jointDescIndex, updateToolConnections, excludeVehicle)\n                end\n            end\n        end\n    end\nend\n\n"})}),"\n",(0,s.jsx)(n.h3,{id:"setconnectionhosesactive",children:"setConnectionHosesActive"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Definition"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"setConnectionHosesActive()"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,s.jsx)(n.table,{children:(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"any"}),(0,s.jsx)(n.th,{children:"connectionHosesActive"})]})})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Code"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:"function ConnectionHoses:setConnectionHosesActive(connectionHosesActive)\n    local spec = self.spec_connectionHoses\n\n    if connectionHosesActive ~ = spec.connectionHosesActive then\n        spec.connectionHosesActive = connectionHosesActive\n\n        local attacherVehicle = self:getAttacherVehicle()\n        if attacherVehicle ~ = nil then\n            local implement = attacherVehicle:getImplementByObject( self )\n            if implement ~ = nil then\n                if connectionHosesActive then\n                    self:connectHosesToAttacherVehicle(attacherVehicle, implement.inputJointDescIndex, implement.jointDescIndex)\n                    self:connectCustomHosesToAttacherVehicle(attacherVehicle, implement.inputJointDescIndex, implement.jointDescIndex)\n                else\n                        ConnectionHoses.onPreDetach( self , attacherVehicle, implement)\n                    end\n                end\n            end\n        end\n    end\n\n"})}),"\n",(0,s.jsx)(n.h3,{id:"updateattachedconnectionhoses",children:"updateAttachedConnectionHoses"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Definition"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"updateAttachedConnectionHoses()"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,s.jsx)(n.table,{children:(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"any"}),(0,s.jsx)(n.th,{children:"attacherVehicle"})]})})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Code"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:"function ConnectionHoses:updateAttachedConnectionHoses(attacherVehicle)\n    local spec = self.spec_connectionHoses\n    for i = 1 , #spec.updateableHoses do\n        local hose = spec.updateableHoses[i]\n        if hose.connectedObject = = attacherVehicle then\n            if self.updateLoopIndex = = hose.connectedObject.updateLoopIndex then\n                self:updateConnectionHose(hose, i)\n            end\n        end\n    end\n\n    for i, customHose in ipairs(spec.customHosesActiveDirty) do\n        if customHose.isActive and customHose.connectedTarget ~ = nil then\n            if customHose.connectedObject = = attacherVehicle then\n                if self.updateLoopIndex = = customHose.connectedObject.updateLoopIndex then\n                    self:updateCustomHoseNode(customHose, customHose.connectedTarget)\n                end\n            end\n        end\n    end\nend\n\n"})}),"\n",(0,s.jsx)(n.h3,{id:"updateconnectionhose",children:"updateConnectionHose"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Definition"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"updateConnectionHose()"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"any"}),(0,s.jsx)(n.th,{children:"hose"})]})}),(0,s.jsx)(n.tbody,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"any"}),(0,s.jsx)(n.td,{children:"index"})]})})]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Code"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:'function ConnectionHoses:updateConnectionHose(hose, index)\n    -- determine control points for spline\n        local p0x, p0y, p0z = 0 , 0 , - hose.startStraightening\n        local p3x, p3y, p3z = localToLocal(hose.targetNode, hose.hoseNode, 0 , 0 , 0 )\n        local p4x, p4y, p4z = localToLocal(hose.targetNode, hose.hoseNode, hose.endStraighteningDirection[ 1 ] * hose.endStraightening, hose.endStraighteningDirection[ 2 ] * hose.endStraightening, hose.endStraighteningDirection[ 3 ] * hose.endStraightening)\n\n        -- default position of middle node\n        local p2x, p2y, p2z\n\n        if hose.isWorldSpaceHose then\n            local w1x, w1y, w1z = getWorldTranslation(hose.hoseNode)\n            local w2x, w2y, w2z = getWorldTranslation(hose.targetNode)\n\n            p2x = (w1x + w2x) / 2\n            p2y = (w1y + w2y) / 2\n            p2z = (w1z + w2z) / 2\n        else\n                p2x = p3x / 2\n                p2y = p3y / 2\n                p2z = p3z / 2\n            end\n\n            -- real distance between nodes\n            local d = MathUtil.vector3Length(p3x, p3y, p3z)\n\n            -- simple calculation of the center point -> low precision, high performance\n            local lengthDifference = math.max(hose.length - d, 0 ) * (hose.centerPointDropFactor or 1 )\n            local p2yStart = p2y\n            if not hose.isWorldSpaceHose then\n                local _\n                _, p2yStart, _ = localToWorld(hose.hoseNode, p2x, p2y, p2z)\n            end\n\n            p2y = p2y - math.max(lengthDifference, 0.04 * d)\n\n            if hose.isWorldSpaceHose then\n                if hose.minDeltaY ~ = math.huge then\n                    local x, y, z = worldToLocal(hose.minDeltaYComponent, p2x, p2y, p2z)\n                    local _, yTarget, _ = localToLocal(hose.hoseNode, hose.minDeltaYComponent, 0 , 0 , 0 )\n                    p2x, p2y, p2z = localToWorld(hose.minDeltaYComponent, x, math.max(y, yTarget + hose.minDeltaY), z)\n                end\n\n                p2x, p2y, p2z = worldToLocal(hose.hoseNode, p2x, p2y, p2z)\n            end\n\n            local angle1, angle2 = self:getCenterPointAngle(hose.hoseNode, p2x, p2y, p2z, p3x, p3y, p3z, hose.isWorldSpaceHose)\n            local centerPointAngle = angle1 + angle2\n            if centerPointAngle < hose.minCenterPointAngle then\n                p2x, p2y, p2z = self:getCenterPointAngleRegulation(hose.hoseNode, p2x, p2y, p2z, p3x, p3y, p3z, angle1, angle2, hose.minCenterPointAngle, hose.isWorldSpaceHose)\n            end\n\n            if hose.minCenterPointOffset ~ = nil and hose.maxCenterPointOffset ~ = nil then\n                p2x = math.clamp(p2x, hose.minCenterPointOffset[ 1 ], hose.maxCenterPointOffset[ 1 ])\n                p2y = math.clamp(p2y, hose.minCenterPointOffset[ 2 ], hose.maxCenterPointOffset[ 2 ])\n                p2z = math.clamp(p2z, hose.minCenterPointOffset[ 3 ], hose.maxCenterPointOffset[ 3 ])\n            end\n\n            -- manipulate by parent component Y and Z velocity\n            local newX, newY, newZ = getWorldTranslation(hose.component)\n            if hose.lastComponentPosition = = nil or hose.lastComponentVelocity = = nil then\n                hose.lastComponentPosition = { newX, newY, newZ }\n                hose.lastComponentVelocity = { newX, newY, newZ }\n            end\n\n            local newVelX, newVelY, newVelZ = newX - hose.lastComponentPosition[ 1 ], newY - hose.lastComponentPosition[ 2 ], newZ - hose.lastComponentPosition[ 3 ]\n            hose.lastComponentPosition[ 1 ], hose.lastComponentPosition[ 2 ], hose.lastComponentPosition[ 3 ] = newX, newY, newZ\n\n            local velX, velY, velZ = newVelX - hose.lastComponentVelocity[ 1 ], newVelY - hose.lastComponentVelocity[ 2 ], newVelZ - hose.lastComponentVelocity[ 3 ]\n            hose.lastComponentVelocity[ 1 ], hose.lastComponentVelocity[ 2 ], hose.lastComponentVelocity[ 3 ] = newVelX, newVelY, newVelZ\n\n            local worldX, worldY, worldZ = getWorldTranslation(hose.hoseNode)\n            local _\n            _, velY, velZ = worldToLocal(hose.hoseNode, worldX + velX, worldY + velY, worldZ + velZ)\n\n            local _, wp2y, _ = localToWorld(hose.hoseNode, p2x, p2y, p2z)\n            local realLengthDifference = p2yStart - wp2y\n            velY = math.clamp(velY * - hose.dampingFactor, - hose.dampingRange, hose.dampingRange) * realLengthDifference\n            velZ = math.clamp(velZ * - hose.dampingFactor, - hose.dampingRange, hose.dampingRange) * realLengthDifference\n\n            velY = velY * 0.1 + hose.lastVelY * 0.9\n            velZ = velZ * 0.1 + hose.lastVelZ * 0.9\n\n            hose.lastVelY = velY\n            hose.lastVelZ = velZ\n\n            p2x, p2y, p2z = p2x, p2y + velY, p2z + velZ\n\n            -- on two point hoses we set the center point to 0 and the shader creates a two point catmull rom\n            if hose.isTwoPointHose then\n                p2x, p2y, p2z = 0 , 0 , 0\n            end\n\n            -- apply to shader\n            setShaderParameter(hose.hoseNode, "cv2" , p2x, p2y, p2z, hose.centerPointTension or 0 , false ) -- center point\n            setShaderParameter(hose.hoseNode, "cv3" , p3x, p3y, p3z, 0 , false ) -- target point\n            setShaderParameter(hose.hoseNode, "cv4" , p4x, p4y, p4z, 1 , false ) -- straighter point\n\n            if VehicleDebug.state = = VehicleDebug.DEBUG_ATTACHER_JOINTS then\n                if self:getIsActiveForInput() then\n                    local realLength = MathUtil.vector3Length(p2x, p2y, p2z)\n                    realLength = realLength + MathUtil.vector3Length(p2x - p3x, p2y - p3y, p2z - p3z)\n                    renderText( 0.5 , 0.9 - index * 0.02 , 0.0175 , string.format( "hose %s:" , getName(hose.node)))\n                    renderText( 0.62 , 0.9 - index * 0.02 , 0.0175 , string.format( "directLength: %.2f configLength: %.2f realLength: %.2f angle: %.2f minAngle: %.2f" , d, hose.length, realLength, math.deg(centerPointAngle), math.deg(hose.minCenterPointAngle)))\n\n                    local x1,y1,z1 = localToWorld(hose.hoseNode, p0x, p0y, p0z)\n                    local x2,y2,z2 = localToWorld(hose.hoseNode, 0 , 0 , 0 )\n                    drawDebugLine(x1,y1,z1, 1 , 0 , 0 , x2,y2,z2, 0 , 1 , 0 )\n\n                    x1,y1,z1 = localToWorld(hose.hoseNode, 0 , 0 , 0 )\n                    x2,y2,z2 = localToWorld(hose.hoseNode, p2x, p2y, p2z)\n                    drawDebugLine(x1,y1,z1, 1 , 0 , 0 , x2,y2,z2, 0 , 1 , 0 )\n\n                    x1,y1,z1 = localToWorld(hose.hoseNode, p2x, p2y, p2z)\n                    x2,y2,z2 = localToWorld(hose.hoseNode, p3x, p3y, p3z)\n                    drawDebugLine(x1,y1,z1, 1 , 0 , 0 , x2,y2,z2, 0 , 1 , 0 )\n\n                    x1,y1,z1 = localToWorld(hose.hoseNode, p3x, p3y, p3z)\n                    x2,y2,z2 = localToWorld(hose.hoseNode, p4x, p4y, p4z)\n                    drawDebugLine(x1,y1,z1, 1 , 0 , 0 , x2,y2,z2, 0 , 1 , 0 )\n\n                    local x0,y0,z0 = localToWorld(hose.hoseNode, p0x, p0y, p0z)\n                    x1,y1,z1 = localToWorld(hose.hoseNode, 0 , 0 , 0 )\n                    x2,y2,z2 = localToWorld(hose.hoseNode, p2x, p2y, p2z)\n                    local x3,y3,z3 = localToWorld(hose.hoseNode, p3x, p3y, p3z)\n                    local x4,y4,z4 = localToWorld(hose.hoseNode, p4x, p4y, p4z)\n                    drawDebugPoint(x0,y0,z0, 1 , 0 , 0 , 1 )\n                    drawDebugPoint(x1,y1,z1, 1 , 0 , 0 , 1 )\n                    drawDebugPoint(x2,y2,z2, 1 , 0 , 0 , 1 )\n                    drawDebugPoint(x3,y3,z3, 1 , 0 , 0 , 1 )\n                    drawDebugPoint(x4,y4,z4, 1 , 0 , 0 , 1 )\n\n                    DebugGizmo.renderAtNode(hose.hoseNode, "hn" )\n                    DebugGizmo.renderAtNode(hose.targetNode, "tn" )\n\n                    if hose.minCenterPointOffset ~ = nil and hose.maxCenterPointOffset ~ = nil then\n                        local x, y, z = localToWorld(hose.hoseNode, 0 , 0 , 0 )\n                        local upX, upY, upZ = localDirectionToWorld(hose.hoseNode, 0 , 1 , 0 )\n                        local dirX, dirY, dirZ = localDirectionToWorld(hose.hoseNode, 0 , 0 , 1 )\n                        local sideDirX, sideDirY, sideDirZ = localDirectionToWorld(hose.hoseNode, 1 , 0 , 0 )\n\n                        local minX, maxX = math.clamp(hose.minCenterPointOffset[ 1 ], - 1 , 1 ), math.clamp(hose.maxCenterPointOffset[ 1 ], - 1 , 1 )\n                        local minY, maxY = math.clamp(hose.minCenterPointOffset[ 2 ], - 1 , 1 ), math.clamp(hose.maxCenterPointOffset[ 2 ], - 1 , 1 )\n                        local minZ, maxZ = math.clamp(hose.minCenterPointOffset[ 3 ], - 1 , 1 ), math.clamp(hose.maxCenterPointOffset[ 3 ], - 1 , 1 )\n\n                        if hose.minCenterPointOffset[ 3 ] ~ = - math.huge or hose.maxCenterPointOffset[ 3 ] ~ = math.huge then\n                            local cx, cy, cz = x + upX * (minY + maxY) * 0.5 , y + upY * (minY + maxY) * 0.5 , z + upZ * (minY + maxY) * 0.5\n                            cx, cy, cz = cx + sideDirX * (minX + maxX) * 0.5 , cy + sideDirY * (minX + maxX) * 0.5 , cz + sideDirZ * (minX + maxX) * 0.5\n\n                            local blue = Color.new( 0 , 0 , 1 , 0.1 )\n                            DebugPlane.newSimple( true , true , blue, false ):createFromPosAndDir(cx + dirX * minZ, cy + dirY * minZ, cz + dirZ * minZ, upX, upY, upZ, dirX, dirY, dirZ, maxX - minX, maxY - minY):draw()\n                            DebugPlane.newSimple( true , true , blue, false ):createFromPosAndDir(cx + dirX * maxZ, cy + dirY * maxZ, cz + dirZ * maxZ, upX, upY, upZ, dirX, dirY, dirZ, maxX - minX, maxY - minY):draw()\n                        end\n\n                        if hose.minCenterPointOffset[ 2 ] ~ = - math.huge or hose.maxCenterPointOffset[ 2 ] ~ = math.huge then\n                            local cx, cy, cz = x + dirX * (minZ + maxZ) * 0.5 , y + dirY * (minZ + maxZ) * 0.5 , z + dirZ * (minZ + maxZ) * 0.5\n                            cx, cy, cz = cx + sideDirX * (minX + maxX) * 0.5 , cy + sideDirY * (minX + maxX) * 0.5 , cz + sideDirZ * (minX + maxX) * 0.5\n\n                            local green = Color.new( 0 , 1 , 0 , 0.1 )\n                            DebugPlane.newSimple( true , true , green, false ):createFromPosAndDir(cx + upX * minY, cy + upY * minY, cz + upZ * minY, dirX, dirY, dirZ, upX, upY, upZ, maxX - minX, maxZ - minZ):draw()\n                            DebugPlane.newSimple( true , true , green, false ):createFromPosAndDir(cx + upX * maxY, cy + upY * maxY, cz + upZ * maxY, dirX, dirY, dirZ, upX, upY, upZ, maxX - minX, maxZ - minZ):draw()\n                        end\n\n                        if hose.minCenterPointOffset[ 1 ] ~ = - math.huge or hose.maxCenterPointOffset[ 1 ] ~ = math.huge then\n                            local cx, cy, cz = x + dirX * (minZ + maxZ) * 0.5 , y + dirY * (minZ + maxZ) * 0.5 , z + dirZ * (minZ + maxZ) * 0.5\n\n                            local red = Color.new( 1 , 0 , 0 , 0.1 )\n                            DebugPlane.newSimple( true , true , red, false ):createFromPosAndDir(cx + sideDirX * minX, cy + sideDirY * minX, cz + sideDirZ * minX, dirX, dirY, dirZ, sideDirX, sideDirY, sideDirZ, maxY - minY, maxZ - minZ):draw()\n                            DebugPlane.newSimple( true , true , red, false ):createFromPosAndDir(cx + sideDirX * maxX, cy + sideDirY * maxX, cz + sideDirZ * maxX, dirX, dirY, dirZ, sideDirX, sideDirY, sideDirZ, maxY - minY, maxZ - minZ):draw()\n                        end\n                    end\n\n                    if hose.minDeltaY ~ = math.huge and hose.minDeltaYComponent ~ = nil then\n                        local lx, _, lz = localToLocal(hose.hoseNode, hose.minDeltaYComponent, p2x, p2y, p2z)\n                        local _, ly, _ = localToLocal(hose.hoseNode, hose.minDeltaYComponent, 0 , 0 , 0 )\n                        local x, y, z = localToWorld(hose.minDeltaYComponent, lx, ly + hose.minDeltaY, lz)\n                        local upX, upY, upZ = localDirectionToWorld(hose.minDeltaYComponent, 0 , 1 , 0 )\n                        local dirX, dirY, dirZ = localDirectionToWorld(hose.minDeltaYComponent, 0 , 0 , 1 )\n\n                        DebugPlane.newSimple( true , true , Color.new( 0 , 1 , 0 , 0.1 ), false ):createFromPosAndDir(x, y, z, dirX, dirY, dirZ, upX, upY, upZ, 1 , 1 ):draw()\n                    end\n                end\n            end\n        end\n\n'})}),"\n",(0,s.jsx)(n.h3,{id:"updatecustomhosenode",children:"updateCustomHoseNode"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Definition"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"updateCustomHoseNode()"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"any"}),(0,s.jsx)(n.th,{children:"customHose"})]})}),(0,s.jsx)(n.tbody,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"any"}),(0,s.jsx)(n.td,{children:"customTarget"})]})})]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Code"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:"function ConnectionHoses:updateCustomHoseNode(customHose, customTarget)\n    setTranslation(customHose.node, localToLocal(customTarget.node, getParent(customHose.node), 0 , 0 , 0 ))\n    setRotation(customHose.node, localRotationToLocal(customTarget.node, getParent(customHose.node), 0 , 0 , 0 ))\n\n    if self.setMovingToolDirty ~ = nil then\n        self:setMovingToolDirty(customHose.node)\n    end\nend\n\n"})}),"\n",(0,s.jsx)(n.h3,{id:"updateextradependentparts",children:"updateExtraDependentParts"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Definition"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"updateExtraDependentParts()"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"any"}),(0,s.jsx)(n.th,{children:"superFunc"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"any"}),(0,s.jsx)(n.td,{children:"part"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"any"}),(0,s.jsx)(n.td,{children:"dt"})]})]})]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Code"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:"function ConnectionHoses:updateExtraDependentParts(superFunc, part, dt)\n    superFunc( self , part, dt)\n\n    if part.customHoseIndices ~ = nil then\n        local spec = self.spec_connectionHoses\n        for i = 1 , #part.customHoseIndices do\n            local customHoseIndex = part.customHoseIndices[i]\n            local customHose = spec.customHoses[customHoseIndex]\n            if customHose ~ = nil and customHose.isActive then\n                self:updateCustomHoseNode(customHose, customHose.connectedTarget)\n            end\n        end\n    end\n\n    if part.customTargetIndices ~ = nil then\n        local spec = self.spec_connectionHoses\n        for i = 1 , #part.customTargetIndices do\n            local customTargetIndex = part.customTargetIndices[i]\n            local customTarget = spec.customHoseTargets[customTargetIndex]\n            if customTarget ~ = nil and customTarget.isActive then\n                self:updateCustomHoseNode(customTarget.connectedHose, customTarget)\n            end\n        end\n    end\n\n    if part.localHoseIndices ~ = nil then\n        local spec = self.spec_connectionHoses\n        for i = 1 , #part.localHoseIndices do\n            local localHoseIndex = part.localHoseIndices[i]\n            local localHose = spec.localHoseNodes[localHoseIndex]\n            if localHose ~ = nil and localHose.hose.connectedObject ~ = nil then\n                self:updateConnectionHose(localHose.hose, localHoseIndex)\n            end\n        end\n    end\nend\n\n"})}),"\n",(0,s.jsx)(n.h3,{id:"updatetoolconnectionhose",children:"updateToolConnectionHose"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Definition"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"updateToolConnectionHose()"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"any"}),(0,s.jsx)(n.th,{children:"sourceObject"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"any"}),(0,s.jsx)(n.td,{children:"sourceHose"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"any"}),(0,s.jsx)(n.td,{children:"targetObject"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"any"}),(0,s.jsx)(n.td,{children:"targetHose"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"any"}),(0,s.jsx)(n.td,{children:"visibility"})]})]})]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Code"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:'function ConnectionHoses:updateToolConnectionHose(sourceObject, sourceHose, targetObject, targetHose, visibility)\n    local spec = self.spec_connectionHoses\n\n    local function setTargetNodeTranslation(hose)\n        if hose.originalNodeTranslation = = nil then\n            hose.originalNodeTranslation = { getTranslation(hose.node) }\n        else\n                setTranslation(hose.node, unpack(hose.originalNodeTranslation))\n            end\n            local wx, wy, wz = localToWorld(hose.node, 0 , sourceHose.diameter * 0.5 , 0 )\n            local lx, ly, lz = worldToLocal(getParent(hose.node), wx, wy, wz)\n            setTranslation(hose.node, lx, ly, lz)\n        end\n\n        local toolConnectionHose = spec.targetNodeToToolConnection[targetHose.index]\n        if toolConnectionHose ~ = nil then\n            local opositTargetIndex = toolConnectionHose.startTargetNodeIndex\n            if opositTargetIndex = = targetHose.index then\n                opositTargetIndex = toolConnectionHose.endTargetNodeIndex\n            end\n            local opositTarget = spec.targetNodes[opositTargetIndex]\n\n            if opositTarget ~ = nil then\n                if visibility and toolConnectionHose.delayedMounting ~ = nil and toolConnectionHose.delayedMounting.sourceHose.connectedObject = = nil then\n                    local differentSource = toolConnectionHose.delayedMounting.sourceObject ~ = sourceObject -- with the retryHoseSkipNodeConnections functionallity it can happen that the object is the same\n                    local sameType = toolConnectionHose.delayedMounting.sourceHose.type = = sourceHose.type\n                    and toolConnectionHose.delayedMounting.sourceHose.specType = = sourceHose.specType\n                    if differentSource and sameType then\n                        local x, y, z = localToLocal(targetHose.node, opositTarget.node, 0 , 0 , 0 )\n                        local length = MathUtil.vector3Length(x, y, z) - (toolConnectionHose.additionalHoseOffset or 0 ) * 2\n\n                        if toolConnectionHose.additionalHose then\n                            local hose, _, _, _ = g_connectionHoseManager:getClonedHoseNode(sourceHose.type , sourceHose.hoseType, length, sourceHose.diameter, sourceHose.material, self.customEnvironment)\n\n                            if hose ~ = nil then\n                                link(targetHose.node, hose)\n                                setTranslation(hose, 0 , 0 , toolConnectionHose.additionalHoseOffset or 0 )\n\n                                local dirX, dirY, dirZ = localToLocal(hose, opositTarget.node, 0 , 0 , 0 )\n                                if dirX ~ = 0 or dirY ~ = 0 or dirZ ~ = 0 then\n                                    setDirection(hose, dirX, dirY, dirZ, 0 , 0 , 1 )\n                                end\n\n                                local meshLength, diameterScale, _, _ = getShaderParameter(hose, "lengthAndDiameter" , 0 )\n                                setScale(hose, diameterScale, diameterScale, length / meshLength)\n\n                                -- catmull rom got issues with perfectly straight hoses, so we remove the shader variation from the mesh\n                                local materialId = getMaterial(hose, 0 )\n                                materialId = setMaterialCustomShaderVariation(materialId, "uvTransform" , false )\n                                setMaterial(hose, materialId, 0 )\n\n                                if toolConnectionHose.moveNodes then\n                                    setTargetNodeTranslation(targetHose)\n                                    setTargetNodeTranslation(opositTarget)\n                                end\n\n                                sourceObject:addAllSubWashableNodes(hose)\n\n                                toolConnectionHose.hoseNode = hose\n                                toolConnectionHose.hoseNodeObject = sourceObject\n                            else\n                                    return false\n                                end\n                            end\n\n                            if toolConnectionHose.additionalHoses ~ = nil then\n                                for _, additionalHoseNode in ipairs(toolConnectionHose.additionalHoses) do\n                                    local additionalLength = calcDistanceFrom(additionalHoseNode.startNode, additionalHoseNode.endNode)\n\n                                    local hose, _, _, _ = g_connectionHoseManager:getClonedHoseNode(sourceHose.type , sourceHose.hoseType, additionalLength, sourceHose.diameter, sourceHose.material, self.customEnvironment)\n                                    if hose ~ = nil then\n                                        link(additionalHoseNode.startNode, hose)\n                                        setTranslation(hose, 0 , 0 , 0 )\n\n                                        local dirX, dirY, dirZ = localToLocal(additionalHoseNode.endNode, additionalHoseNode.startNode, 0 , 0 , 0 )\n                                        if dirX ~ = 0 or dirY ~ = 0 or dirZ ~ = 0 then\n                                            setDirection(hose, dirX, dirY, dirZ, 0 , 0 , 1 )\n                                        end\n\n                                        local meshLength, diameterScale, _, _ = getShaderParameter(hose, "lengthAndDiameter" , 0 )\n                                        setScale(hose, diameterScale, diameterScale, additionalLength / meshLength)\n\n                                        -- catmull rom got issues with perfectly straight hoses, so we remove the shader variation from the mesh\n                                        local materialId = getMaterial(hose, 0 )\n                                        materialId = setMaterialCustomShaderVariation(materialId, "uvTransform" , false )\n                                        setMaterial(hose, materialId, 0 )\n\n                                        sourceObject:addAllSubWashableNodes(hose)\n\n                                        additionalHoseNode.hoseNode = hose\n                                        additionalHoseNode.hoseNodeObject = sourceObject\n                                    end\n                                end\n                            end\n\n                            toolConnectionHose.connected = true\n\n                            if toolConnectionHose.mountingNode ~ = nil then\n                                setVisibility(toolConnectionHose.mountingNode, true )\n                            end\n\n                            ObjectChangeUtil.setObjectChanges(toolConnectionHose.objectChanges, true , toolConnectionHose.objectChangesTarget, toolConnectionHose.objectChangesTarget.setMovingToolDirty)\n\n                            if toolConnectionHose.parentToolConnectionHose ~ = nil then\n                                local parentToolConnectionHose = toolConnectionHose.parentToolConnectionHose\n                                if parentToolConnectionHose.mountingNode ~ = nil then\n                                    setVisibility(parentToolConnectionHose.mountingNode, true )\n                                end\n\n                                ObjectChangeUtil.setObjectChanges(parentToolConnectionHose.objectChanges, true , parentToolConnectionHose.objectChangesTarget, parentToolConnectionHose.objectChangesTarget.setMovingToolDirty)\n                            end\n\n                            -- connect the first attached hose to the tool connection\n                            if toolConnectionHose.delayedMounting ~ = nil then\n                                toolConnectionHose.delayedUnmounting = { }\n                                table.insert(toolConnectionHose.delayedUnmounting, toolConnectionHose.delayedMounting)\n                                table.insert(toolConnectionHose.delayedUnmounting, { sourceObject = sourceObject, sourceHose = sourceHose, targetObject = targetObject, targetHose = targetHose } )\n\n                                local delayedHose = toolConnectionHose.delayedMounting\n                                toolConnectionHose.delayedMounting = nil\n                                delayedHose.sourceObject:connectHose(delayedHose.sourceHose, delayedHose.targetObject, delayedHose.targetHose, false )\n                                delayedHose.sourceObject:retryHoseSkipNodeConnections( false )\n                            end\n\n                            return true\n                        end\n                    else\n                            if toolConnectionHose.connected then\n                                toolConnectionHose.connected = false\n\n                                if toolConnectionHose.hoseNode ~ = nil then\n                                    toolConnectionHose.hoseNodeObject:removeAllSubWashableNodes(toolConnectionHose.hoseNode)\n\n                                    delete(toolConnectionHose.hoseNode)\n                                    toolConnectionHose.hoseNode = nil\n                                    toolConnectionHose.hoseNodeObject = nil\n                                end\n\n                                if toolConnectionHose.additionalHoses ~ = nil then\n                                    for _, additionalHoseNode in ipairs(toolConnectionHose.additionalHoses) do\n                                        if additionalHoseNode.hoseNode ~ = nil then\n                                            additionalHoseNode.hoseNodeObject:removeAllSubWashableNodes(additionalHoseNode.hoseNode)\n\n                                            delete(additionalHoseNode.hoseNode)\n                                            additionalHoseNode.hoseNode = nil\n                                            additionalHoseNode.hoseNodeObject = nil\n                                        end\n                                    end\n                                end\n\n                                if toolConnectionHose.mountingNode ~ = nil then\n                                    setVisibility(toolConnectionHose.mountingNode, false )\n                                end\n\n                                ObjectChangeUtil.setObjectChanges(toolConnectionHose.objectChanges, false , toolConnectionHose.objectChangesTarget, toolConnectionHose.objectChangesTarget.setMovingToolDirty)\n\n                                if toolConnectionHose.parentToolConnectionHose ~ = nil then\n                                    local parentToolConnectionHose = toolConnectionHose.parentToolConnectionHose\n                                    if not parentToolConnectionHose.connected then\n                                        if parentToolConnectionHose.mountingNode ~ = nil then\n                                            setVisibility(parentToolConnectionHose.mountingNode, false )\n                                        end\n\n                                        ObjectChangeUtil.setObjectChanges(parentToolConnectionHose.objectChanges, false , parentToolConnectionHose.objectChangesTarget, parentToolConnectionHose.objectChangesTarget.setMovingToolDirty)\n                                    end\n                                end\n\n                                -- remove the second hose connection from the tool connection\n                                -- but keep it as delayed mounting\n                                -- if is hose from skip node, completly remove it(will be recreated depending on sub attached tool)\n                                    if toolConnectionHose.delayedUnmounting ~ = nil then\n                                        for _, hose in ipairs(toolConnectionHose.delayedUnmounting) do\n                                            if sourceHose ~ = hose.sourceHose then\n                                                hose.sourceObject:disconnectHose(hose.sourceHose)\n                                                if hose.sourceHose.isClonedSkipNodeHose = = nil or not hose.sourceHose.isClonedSkipNodeHose then\n                                                    toolConnectionHose.delayedMounting = hose\n                                                end\n                                            end\n                                        end\n\n                                        toolConnectionHose.delayedUnmounting = nil\n                                    end\n                                end\n                            end\n                        end\n                    else\n                            return true\n                        end\n\n                        return false\n                    end\n\n'})})]})}function h(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}}}]);