"use strict";(globalThis.webpackChunkfs25_community_luadoc=globalThis.webpackChunkfs25_community_luadoc||[]).push([[33469],{28453(n,e,s){s.d(e,{R:()=>l,x:()=>t});var i=s(96540);const o={},r=i.createContext(o);function l(n){const e=i.useContext(r);return i.useMemo(function(){return"function"==typeof n?n(e):{...e,...n}},[e,n])}function t(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(o):n.components||o:l(n.components),i.createElement(r.Provider,{value:e},n.children)}},29846(n,e,s){s.r(e),s.d(e,{assets:()=>a,contentTitle:()=>t,default:()=>p,frontMatter:()=>l,metadata:()=>i,toc:()=>c});const i=JSON.parse('{"id":"script/Specializations/Suspensions","title":"Suspensions","description":"Suspensions","source":"@site/../docs/script/Specializations/Suspensions.md","sourceDirName":"script/Specializations","slug":"/script/Specializations/Suspensions","permalink":"/FS25-Community-LUADOC/script/Specializations/Suspensions","draft":false,"unlisted":false,"tags":[],"version":"current","lastUpdatedAt":1767161192000,"frontMatter":{},"sidebar":"docsSidebar","previous":{"title":"SupportVehicle","permalink":"/FS25-Community-LUADOC/script/Specializations/SupportVehicle"},"next":{"title":"Tedder","permalink":"/FS25-Community-LUADOC/script/Specializations/Tedder"}}');var o=s(74848),r=s(28453);const l={},t=void 0,a={},c=[{value:"Suspensions",id:"suspensions",level:2},{value:"getIsSuspensionNodeActive",id:"getissuspensionnodeactive",level:3},{value:"getSuspensionModfier",id:"getsuspensionmodfier",level:3},{value:"getSuspensionNodeFromIndex",id:"getsuspensionnodefromindex",level:3},{value:"initSpecialization",id:"initspecialization",level:3},{value:"loadSuspensionNodeFromXML",id:"loadsuspensionnodefromxml",level:3},{value:"onEnterVehicle",id:"onentervehicle",level:3},{value:"onLoad",id:"onload",level:3},{value:"onUpdate",id:"onupdate",level:3},{value:"onVehicleCharacterChanged",id:"onvehiclecharacterchanged",level:3},{value:"prerequisitesPresent",id:"prerequisitespresent",level:3},{value:"registerEventListeners",id:"registereventlisteners",level:3},{value:"registerFunctions",id:"registerfunctions",level:3},{value:"setSuspensionNodeCharacter",id:"setsuspensionnodecharacter",level:3},{value:"subCollisionErrorFunction",id:"subcollisionerrorfunction",level:3}];function d(n){const e={a:"a",blockquote:"blockquote",code:"code",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,r.R)(),...n.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(e.h2,{id:"suspensions",children:"Suspensions"}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Description"})}),"\n",(0,o.jsxs)(e.blockquote,{children:["\n",(0,o.jsx)(e.p,{children:"Specialization for non-wheel suspensions e.g. cabin, seat or player character suspension"}),"\n"]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Functions"})}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsx)(e.li,{children:(0,o.jsx)(e.a,{href:"#getissuspensionnodeactive",children:"getIsSuspensionNodeActive"})}),"\n",(0,o.jsx)(e.li,{children:(0,o.jsx)(e.a,{href:"#getsuspensionmodfier",children:"getSuspensionModfier"})}),"\n",(0,o.jsx)(e.li,{children:(0,o.jsx)(e.a,{href:"#getsuspensionnodefromindex",children:"getSuspensionNodeFromIndex"})}),"\n",(0,o.jsx)(e.li,{children:(0,o.jsx)(e.a,{href:"#initspecialization",children:"initSpecialization"})}),"\n",(0,o.jsx)(e.li,{children:(0,o.jsx)(e.a,{href:"#loadsuspensionnodefromxml",children:"loadSuspensionNodeFromXML"})}),"\n",(0,o.jsx)(e.li,{children:(0,o.jsx)(e.a,{href:"#onentervehicle",children:"onEnterVehicle"})}),"\n",(0,o.jsx)(e.li,{children:(0,o.jsx)(e.a,{href:"#onload",children:"onLoad"})}),"\n",(0,o.jsx)(e.li,{children:(0,o.jsx)(e.a,{href:"#onupdate",children:"onUpdate"})}),"\n",(0,o.jsx)(e.li,{children:(0,o.jsx)(e.a,{href:"#onvehiclecharacterchanged",children:"onVehicleCharacterChanged"})}),"\n",(0,o.jsx)(e.li,{children:(0,o.jsx)(e.a,{href:"#prerequisitespresent",children:"prerequisitesPresent"})}),"\n",(0,o.jsx)(e.li,{children:(0,o.jsx)(e.a,{href:"#registereventlisteners",children:"registerEventListeners"})}),"\n",(0,o.jsx)(e.li,{children:(0,o.jsx)(e.a,{href:"#registerfunctions",children:"registerFunctions"})}),"\n",(0,o.jsx)(e.li,{children:(0,o.jsx)(e.a,{href:"#setsuspensionnodecharacter",children:"setSuspensionNodeCharacter"})}),"\n",(0,o.jsx)(e.li,{children:(0,o.jsx)(e.a,{href:"#subcollisionerrorfunction",children:"subCollisionErrorFunction"})}),"\n"]}),"\n",(0,o.jsx)(e.h3,{id:"getissuspensionnodeactive",children:"getIsSuspensionNodeActive"}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Description"})}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Definition"})}),"\n",(0,o.jsxs)(e.blockquote,{children:["\n",(0,o.jsx)(e.p,{children:"getIsSuspensionNodeActive()"}),"\n"]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,o.jsx)(e.table,{children:(0,o.jsx)(e.thead,{children:(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.th,{children:"any"}),(0,o.jsx)(e.th,{children:"suspensionNode"})]})})}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Code"})}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-lua",children:"function Suspensions:getIsSuspensionNodeActive(suspensionNode)\n    return suspensionNode.node ~ = nil and suspensionNode.component ~ = nil\nend\n\n"})}),"\n",(0,o.jsx)(e.h3,{id:"getsuspensionmodfier",children:"getSuspensionModfier"}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Description"})}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Definition"})}),"\n",(0,o.jsxs)(e.blockquote,{children:["\n",(0,o.jsx)(e.p,{children:"getSuspensionModfier()"}),"\n"]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Code"})}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-lua",children:"function Suspensions:getSuspensionModfier()\n    local spec = self.spec_suspensions\n    local index = 1\n    -- try to get the seat suspension, normally on index 2(if no cabin suspension on index 1)\n        if #spec.suspensionNodes > = 2 and not spec.suspensionNodes[ 2 ].useCharacterTorso and not spec.suspensionNodes[ 2 ].isRotational then\n            index = 2\n        end\n\n        local suspensionNode = spec.suspensionNodes[index]\n        if suspensionNode ~ = nil then\n            if not suspensionNode.isRotational then\n                return suspensionNode.curTranslation[ 2 ]\n            end\n        end\n\n        return 0\n    end\n\n"})}),"\n",(0,o.jsx)(e.h3,{id:"getsuspensionnodefromindex",children:"getSuspensionNodeFromIndex"}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Description"})}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Definition"})}),"\n",(0,o.jsxs)(e.blockquote,{children:["\n",(0,o.jsx)(e.p,{children:"getSuspensionNodeFromIndex()"}),"\n"]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,o.jsx)(e.table,{children:(0,o.jsx)(e.thead,{children:(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.th,{children:"any"}),(0,o.jsx)(e.th,{children:"suspensionIndex"})]})})}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Code"})}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-lua",children:"function Suspensions:getSuspensionNodeFromIndex(suspensionIndex)\n    local spec = self.spec_suspensions\n    if spec.suspensionAvailable then\n        return self.spec_suspensions.suspensionNodes[suspensionIndex]\n    end\n\n    return nil\nend\n\n"})}),"\n",(0,o.jsx)(e.h3,{id:"initspecialization",children:"initSpecialization"}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Description"})}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Definition"})}),"\n",(0,o.jsxs)(e.blockquote,{children:["\n",(0,o.jsx)(e.p,{children:"initSpecialization()"}),"\n"]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Code"})}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-lua",children:'function Suspensions.initSpecialization()\n    local schema = Vehicle.xmlSchema\n    schema:setXMLSpecializationType( "Suspensions" )\n\n    local key = Suspensions.SUSPENSION_NODE_XML_KEY\n\n    schema:register(XMLValueType.NODE_INDEX, key .. "#node" , "Suspension node" )\n    schema:register(XMLValueType.BOOL, key .. "#useCharacterTorso" , "Use character torso instead of node" )\n    schema:register(XMLValueType.FLOAT, key .. "#weight" , "Weight in kg" , 500 )\n    schema:register(XMLValueType.VECTOR_ROT, key .. "#minRotation" , "Min.rotation" )\n    schema:register(XMLValueType.VECTOR_ROT, key .. "#maxRotation" , "Max.rotation" )\n    schema:register(XMLValueType.VECTOR_TRANS, key .. "#startTranslationOffset" , "Custom translation offset" )\n    schema:register(XMLValueType.VECTOR_TRANS, key .. "#minTranslation" , "Min.translation" )\n    schema:register(XMLValueType.VECTOR_TRANS, key .. "#maxTranslation" , "Max.translation" )\n    schema:register(XMLValueType.FLOAT, key .. "#maxVelocityDifference" , "Max.velocity difference" , 0.1 )\n    schema:register(XMLValueType.VECTOR_ 2 , key .. "#suspensionParametersX" , "Suspension parameters X" , "0 0" )\n    schema:register(XMLValueType.VECTOR_ 2 , key .. "#suspensionParametersY" , "Suspension parameters Y" , "0 0" )\n    schema:register(XMLValueType.VECTOR_ 2 , key .. "#suspensionParametersZ" , "Suspension parameters Z" , "0 0" )\n    schema:register(XMLValueType.BOOL, key .. "#inverseMovement" , "Invert movement" , false )\n    schema:register(XMLValueType.BOOL, key .. "#serverOnly" , "Suspension is only calculated on server side" , false )\n\n    schema:register(XMLValueType.FLOAT, "vehicle.suspensions#maxUpdateDistance" , "Max.distance to vehicle root to update suspension nodes" , Suspensions.DEFAULT_MAX_UPDATE_DISTANCE)\n\n    schema:setXMLSpecializationType()\nend\n\n'})}),"\n",(0,o.jsx)(e.h3,{id:"loadsuspensionnodefromxml",children:"loadSuspensionNodeFromXML"}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Description"})}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Definition"})}),"\n",(0,o.jsxs)(e.blockquote,{children:["\n",(0,o.jsx)(e.p,{children:"loadSuspensionNodeFromXML()"}),"\n"]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,o.jsxs)(e.table,{children:[(0,o.jsx)(e.thead,{children:(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.th,{children:"any"}),(0,o.jsx)(e.th,{children:"xmlFile"})]})}),(0,o.jsxs)(e.tbody,{children:[(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.td,{children:"any"}),(0,o.jsx)(e.td,{children:"key"})]}),(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.td,{children:"any"}),(0,o.jsx)(e.td,{children:"suspensionNode"})]})]})]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Code"})}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-lua",children:'function Suspensions:loadSuspensionNodeFromXML(xmlFile, key, suspensionNode)\n    suspensionNode.node = xmlFile:getValue(key .. "#node" , nil , self.components, self.i3dMappings)\n    if suspensionNode.node ~ = nil then\n        local component = self:getParentComponent(suspensionNode.node)\n        if component ~ = nil then\n            suspensionNode.component = component\n            suspensionNode.refNodeOffset = { localToLocal(suspensionNode.node, component, 0 , 0 , 0 ) }\n        end\n    end\n    suspensionNode.refNodeOffset = suspensionNode.refNodeOffset or { 0 , 0 , 0 }\n\n    suspensionNode.useCharacterTorso = xmlFile:getValue(key .. "#useCharacterTorso" , false )\n    if (suspensionNode.node ~ = nil and suspensionNode.component ~ = nil ) or suspensionNode.useCharacterTorso then\n        suspensionNode.weight = xmlFile:getValue(key .. "#weight" , 500 )\n\n        suspensionNode.minRotation = xmlFile:getValue(key .. "#minRotation" , nil , true )\n        suspensionNode.maxRotation = xmlFile:getValue(key .. "#maxRotation" , nil , true )\n        suspensionNode.isRotational = suspensionNode.minRotation ~ = nil and suspensionNode.maxRotation ~ = nil\n\n        if not suspensionNode.isRotational and not suspensionNode.useCharacterTorso then\n            suspensionNode.baseTranslation = { getTranslation(suspensionNode.node) }\n            suspensionNode.startTranslationOffset = xmlFile:getValue(key .. "#startTranslationOffset" , "0 0 0" , true )\n            for j = 1 , 3 do\n                suspensionNode.baseTranslation[j] = suspensionNode.baseTranslation[j] + suspensionNode.startTranslationOffset[j]\n            end\n\n            setTranslation(suspensionNode.node, suspensionNode.baseTranslation[ 1 ], suspensionNode.baseTranslation[ 2 ], suspensionNode.baseTranslation[ 3 ])\n\n            suspensionNode.minTranslation = xmlFile:getValue(key .. "#minTranslation" , nil , true )\n            suspensionNode.maxTranslation = xmlFile:getValue(key .. "#maxTranslation" , nil , true )\n\n            if suspensionNode.minTranslation = = nil or suspensionNode.maxTranslation = = nil then\n                Logging.xmlWarning(xmlFile, "suspension \'%s\' has neither rotational nor translational limits, ignoring" , key)\n                return false\n            end\n        end\n\n        suspensionNode.maxVelocityDifference = xmlFile:getValue(key .. "#maxVelocityDifference" , 0.1 )\n\n        local suspensionParametersX = xmlFile:getValue(key .. "#suspensionParametersX" , "0 0" , true )\n        local suspensionParametersY = xmlFile:getValue(key .. "#suspensionParametersY" , "0 0" , true )\n        local suspensionParametersZ = xmlFile:getValue(key .. "#suspensionParametersZ" , "0 0" , true )\n        suspensionNode.suspensionParameters = { }\n        suspensionNode.suspensionParameters[ 1 ] = { }\n        suspensionNode.suspensionParameters[ 2 ] = { }\n        suspensionNode.suspensionParameters[ 3 ] = { }\n        for j = 1 , 2 do\n            suspensionNode.suspensionParameters[ 1 ][j] = suspensionParametersX[j] * 1000\n            suspensionNode.suspensionParameters[ 2 ][j] = suspensionParametersY[j] * 1000\n            suspensionNode.suspensionParameters[ 3 ][j] = suspensionParametersZ[j] * 1000\n        end\n\n        suspensionNode.inverseMovement = xmlFile:getValue(key .. "#inverseMovement" , false )\n        suspensionNode.serverOnly = xmlFile:getValue(key .. "#serverOnly" , false )\n\n        suspensionNode.lastRefNodePosition = nil\n        suspensionNode.lastRefNodeVelocity = nil\n\n        suspensionNode.curRotation = { 0 , 0 , 0 }\n        suspensionNode.curRotationSpeed = { 0 , 0 , 0 }\n\n        suspensionNode.curTranslation = { 0 , 0 , 0 }\n        suspensionNode.curTranslationSpeed = { 0 , 0 , 0 }\n\n        suspensionNode.curAcc = { 0 , 0 , 0 }\n\n        return true\n    end\n\n    return false\nend\n\n'})}),"\n",(0,o.jsx)(e.h3,{id:"onentervehicle",children:"onEnterVehicle"}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Description"})}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Definition"})}),"\n",(0,o.jsxs)(e.blockquote,{children:["\n",(0,o.jsx)(e.p,{children:"onEnterVehicle()"}),"\n"]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,o.jsx)(e.table,{children:(0,o.jsx)(e.thead,{children:(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.th,{children:"any"}),(0,o.jsx)(e.th,{children:"isControlling"})]})})}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Code"})}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-lua",children:"function Suspensions:onEnterVehicle(isControlling)\n    if self.getVehicleCharacter ~ = nil then\n        local vehicleCharacter = self:getVehicleCharacter()\n        if vehicleCharacter ~ = nil then\n            local spec = self.spec_suspensions\n            for _, suspensionNode in ipairs(spec.suspensionNodes) do\n                self:setSuspensionNodeCharacter(suspensionNode, vehicleCharacter)\n            end\n        end\n    end\nend\n\n"})}),"\n",(0,o.jsx)(e.h3,{id:"onload",children:"onLoad"}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Description"})}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Definition"})}),"\n",(0,o.jsxs)(e.blockquote,{children:["\n",(0,o.jsx)(e.p,{children:"onLoad()"}),"\n"]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,o.jsx)(e.table,{children:(0,o.jsx)(e.thead,{children:(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.th,{children:"any"}),(0,o.jsx)(e.th,{children:"savegame"})]})})}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Code"})}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-lua",children:'function Suspensions:onLoad(savegame)\n    if self.isClient then\n        local spec = self.spec_suspensions\n\n        spec.suspensionNodes = { }\n\n        for _, key in self.xmlFile:iterator( "vehicle.suspensions.suspension" ) do\n            local suspensionNode = { }\n            if self:loadSuspensionNodeFromXML( self.xmlFile, key, suspensionNode) then\n                if not suspensionNode.serverOnly or self.isServer then\n                    --#debug if suspensionNode.node ~ = nil then\n                        --#debug I3DUtil.checkForChildCollisions(suspensionNode.node, Suspensions.subCollisionErrorFunction, self.xmlFile, getName(suspensionNode.node))\n                        --#debug end\n\n                        table.insert(spec.suspensionNodes, suspensionNode)\n                    end\n                end\n            end\n\n            spec.maxUpdateDistance = self.xmlFile:getValue( "vehicle.suspensions#maxUpdateDistance" , Suspensions.DEFAULT_MAX_UPDATE_DISTANCE)\n\n            if #spec.suspensionNodes > 0 then\n                spec.suspensionAvailable = true\n            end\n\n            if not Platform.gameplay.allowSuspensionNodes then\n                if self.xmlFile:hasProperty( "vehicle.suspensions" ) then\n                    Logging.xmlWarning( self.xmlFile, "Suspension nodes are not allowed on this platform" )\n                    spec.suspensionAvailable = false\n                    spec.suspensionNodes = { }\n                end\n            end\n        end\n\n        if not self.spec_suspensions.suspensionAvailable then\n            SpecializationUtil.removeEventListener( self , "onUpdate" , Suspensions )\n            SpecializationUtil.removeEventListener( self , "onEnterVehicle" , Suspensions )\n            SpecializationUtil.removeEventListener( self , "onVehicleCharacterChanged" , Suspensions )\n        end\n    end\n\n'})}),"\n",(0,o.jsx)(e.h3,{id:"onupdate",children:"onUpdate"}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Description"})}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Definition"})}),"\n",(0,o.jsxs)(e.blockquote,{children:["\n",(0,o.jsx)(e.p,{children:"onUpdate()"}),"\n"]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,o.jsxs)(e.table,{children:[(0,o.jsx)(e.thead,{children:(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.th,{children:"any"}),(0,o.jsx)(e.th,{children:"dt"})]})}),(0,o.jsxs)(e.tbody,{children:[(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.td,{children:"any"}),(0,o.jsx)(e.td,{children:"isActiveForInput"})]}),(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.td,{children:"any"}),(0,o.jsx)(e.td,{children:"isActiveForInputIgnoreSelection"})]}),(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.td,{children:"any"}),(0,o.jsx)(e.td,{children:"isSelected"})]})]})]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Code"})}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-lua",children:"function Suspensions:onUpdate(dt, isActiveForInput, isActiveForInputIgnoreSelection, isSelected)\n    local spec = self.spec_suspensions\n    if self.currentUpdateDistance < spec.maxUpdateDistance then\n        local timeDelta\n        if self.isServer then\n            timeDelta = 0.001 * g_physicsDt\n        else\n                timeDelta = 0.001 * dt\n            end\n\n            for _, suspension in ipairs(spec.suspensionNodes) do\n                if suspension.node ~ = nil and entityExists(suspension.node) then\n                    -- calc velocity diff\n                    suspension.curAcc[ 1 ], suspension.curAcc[ 2 ], suspension.curAcc[ 3 ] = 0 , 0 , 0\n\n                    if self:getIsSuspensionNodeActive(suspension) then\n                        local wx, wy, wz = localToWorld(suspension.component, unpack(suspension.refNodeOffset))\n\n                        if suspension.lastRefNodePosition = = nil then\n                            suspension.lastRefNodePosition = { wx, wy, wz }\n                            suspension.lastRefNodeVelocity = { 0 , 0 , 0 }\n                        end\n\n                        local direction = (suspension.inverseMovement and - 1 ) or 1\n\n                        local newVelX, newVelY, newVelZ = (wx - suspension.lastRefNodePosition[ 1 ]) / timeDelta * direction,\n                        (wy - suspension.lastRefNodePosition[ 2 ]) / timeDelta * direction,\n                        (wz - suspension.lastRefNodePosition[ 3 ]) / timeDelta * direction\n\n                        local oldVelX, oldVelY, oldVelZ = unpack(suspension.lastRefNodeVelocity)\n\n                        local velDiffX, velDiffY, velDiffZ = worldDirectionToLocal(getParent(suspension.node), newVelX - oldVelX, newVelY - oldVelY, newVelZ - oldVelZ)\n\n                        velDiffX = math.clamp(velDiffX, - suspension.maxVelocityDifference, suspension.maxVelocityDifference)\n                        velDiffY = math.clamp(velDiffY, - suspension.maxVelocityDifference, suspension.maxVelocityDifference)\n                        velDiffZ = math.clamp(velDiffZ, - suspension.maxVelocityDifference, suspension.maxVelocityDifference)\n\n                        if suspension.isRotational then\n                            if suspension.useCharacterTorso then\n                                suspension.curAcc[ 1 ], suspension.curAcc[ 2 ], suspension.curAcc[ 3 ] = MathUtil.crossProduct(velDiffX / timeDelta, velDiffY / timeDelta, velDiffZ / timeDelta, 1 , 0 , 0 )\n                            else\n                                    suspension.curAcc[ 1 ], suspension.curAcc[ 2 ], suspension.curAcc[ 3 ] = MathUtil.crossProduct(velDiffX / timeDelta, velDiffY / timeDelta, velDiffZ / timeDelta, 0 , 1 , 0 )\n                                end\n                            else\n                                    suspension.curAcc[ 1 ], suspension.curAcc[ 2 ], suspension.curAcc[ 3 ] = - velDiffX / timeDelta, - velDiffY / timeDelta, - velDiffZ / timeDelta\n                                end\n\n                                -- prepare for next tick\n                                    suspension.lastRefNodePosition[ 1 ] = wx\n                                    suspension.lastRefNodePosition[ 2 ] = wy\n                                    suspension.lastRefNodePosition[ 3 ] = wz\n\n                                    suspension.lastRefNodeVelocity[ 1 ] = newVelX\n                                    suspension.lastRefNodeVelocity[ 2 ] = newVelY\n                                    suspension.lastRefNodeVelocity[ 3 ] = newVelZ\n                                end\n\n                                -- update spring/damper system, F = F_ext - k*x - c*(dx/dt)\n                                -- using implicit euler for spring and damper, explicit euler for external force\n                                    for i = 1 , 3 do\n                                        local suspensionParameter = suspension.suspensionParameters[i]\n                                        if suspensionParameter[ 1 ] > 0 and suspensionParameter[ 2 ] > 0 then\n                                            local f = suspension.weight * suspension.curAcc[i]\n\n                                            local k = suspensionParameter[ 1 ]\n                                            local c = suspensionParameter[ 2 ]\n\n                                            if suspension.isRotational then\n                                                local x = suspension.curRotation[i]\n                                                local vx = suspension.curRotationSpeed[i]\n\n                                                local force = f - (k * x) - (c * vx)\n\n                                                -- 'Implicit Methods for Differential Equations' (Baraff), formula(4-6)\n                                                    local m = suspension.weight\n                                                    local h = timeDelta\n                                                    local numerator = h * (force + h * ( - k) * vx) / m\n                                                    local denumerator = 1 - (( - c) + h * ( - k)) * h / m\n                                                    local curRotationSpeed = vx + numerator / denumerator\n\n                                                    local newRotation = x + (curRotationSpeed * timeDelta)\n                                                    newRotation = math.clamp(newRotation, suspension.minRotation[i], suspension.maxRotation[i])\n\n                                                    suspension.curRotationSpeed[i] = (newRotation - x) / timeDelta\n                                                    suspension.curRotation[i] = newRotation\n                                                else\n                                                        local x = suspension.curTranslation[i]\n                                                        local vx = suspension.curTranslationSpeed[i]\n\n                                                        local force = f - (k * x) - (c * vx)\n\n                                                        -- 'Implicit Methods for Differential Equations' (Baraff), formula(4-6)\n                                                            local m = suspension.weight\n                                                            local h = timeDelta\n                                                            local numerator = h * (force + h * ( - k) * vx) / m\n                                                            local denumerator = 1 - (( - c) + h * ( - k)) * h / m\n                                                            local curTranslationSpeed = vx + numerator / denumerator\n\n                                                            local newTranslation = x + (curTranslationSpeed * timeDelta)\n                                                            newTranslation = math.clamp(newTranslation, suspension.minTranslation[i], suspension.maxTranslation[i])\n\n                                                            suspension.curTranslationSpeed[i] = (newTranslation - x) / timeDelta\n                                                            suspension.curTranslation[i] = newTranslation\n                                                        end\n                                                    end\n                                                end\n\n                                                if suspension.isRotational then\n                                                    setRotation(suspension.node, suspension.curRotation[ 1 ], suspension.curRotation[ 2 ], suspension.curRotation[ 3 ])\n                                                elseif suspension.minTranslation ~ = nil then\n                                                        setTranslation(suspension.node, suspension.baseTranslation[ 1 ] + suspension.curTranslation[ 1 ], suspension.baseTranslation[ 2 ] + suspension.curTranslation[ 2 ], suspension.baseTranslation[ 3 ] + suspension.curTranslation[ 3 ])\n                                                    end\n\n                                                    if self.setMovingToolDirty ~ = nil then\n                                                        self:setMovingToolDirty(suspension.node)\n                                                    end\n                                                elseif suspension.node ~ = nil then\n                                                        Logging.xmlError( self.xmlFile, \"Failed to update suspension node %d.Node does not exist anymore!\" , suspension.node)\n                                                        suspension.node = nil\n                                                    end\n                                                end\n                                            end\n                                        end\n\n"})}),"\n",(0,o.jsx)(e.h3,{id:"onvehiclecharacterchanged",children:"onVehicleCharacterChanged"}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Description"})}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Definition"})}),"\n",(0,o.jsxs)(e.blockquote,{children:["\n",(0,o.jsx)(e.p,{children:"onVehicleCharacterChanged()"}),"\n"]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,o.jsx)(e.table,{children:(0,o.jsx)(e.thead,{children:(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.th,{children:"any"}),(0,o.jsx)(e.th,{children:"character"})]})})}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Code"})}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-lua",children:"function Suspensions:onVehicleCharacterChanged(character)\n    local spec = self.spec_suspensions\n    for _, suspensionNode in ipairs(spec.suspensionNodes) do\n        if suspensionNode.useCharacterTorso then\n            if character ~ = nil then\n                self:setSuspensionNodeCharacter(suspensionNode, character)\n            else\n                    suspensionNode.node = nil\n                end\n            end\n        end\n    end\n\n"})}),"\n",(0,o.jsx)(e.h3,{id:"prerequisitespresent",children:"prerequisitesPresent"}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Description"})}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Definition"})}),"\n",(0,o.jsxs)(e.blockquote,{children:["\n",(0,o.jsx)(e.p,{children:"prerequisitesPresent()"}),"\n"]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,o.jsx)(e.table,{children:(0,o.jsx)(e.thead,{children:(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.th,{children:"any"}),(0,o.jsx)(e.th,{children:"specializations"})]})})}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Code"})}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-lua",children:"function Suspensions.prerequisitesPresent(specializations)\n    return true\nend\n\n"})}),"\n",(0,o.jsx)(e.h3,{id:"registereventlisteners",children:"registerEventListeners"}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Description"})}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Definition"})}),"\n",(0,o.jsxs)(e.blockquote,{children:["\n",(0,o.jsx)(e.p,{children:"registerEventListeners()"}),"\n"]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,o.jsx)(e.table,{children:(0,o.jsx)(e.thead,{children:(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.th,{children:"any"}),(0,o.jsx)(e.th,{children:"vehicleType"})]})})}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Code"})}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-lua",children:'function Suspensions.registerEventListeners(vehicleType)\n    SpecializationUtil.registerEventListener(vehicleType, "onLoad" , Suspensions )\n    SpecializationUtil.registerEventListener(vehicleType, "onUpdate" , Suspensions )\n    SpecializationUtil.registerEventListener(vehicleType, "onEnterVehicle" , Suspensions )\n    SpecializationUtil.registerEventListener(vehicleType, "onVehicleCharacterChanged" , Suspensions )\nend\n\n'})}),"\n",(0,o.jsx)(e.h3,{id:"registerfunctions",children:"registerFunctions"}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Description"})}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Definition"})}),"\n",(0,o.jsxs)(e.blockquote,{children:["\n",(0,o.jsx)(e.p,{children:"registerFunctions()"}),"\n"]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,o.jsx)(e.table,{children:(0,o.jsx)(e.thead,{children:(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.th,{children:"any"}),(0,o.jsx)(e.th,{children:"vehicleType"})]})})}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Code"})}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-lua",children:'function Suspensions.registerFunctions(vehicleType)\n    SpecializationUtil.registerFunction(vehicleType, "loadSuspensionNodeFromXML" , Suspensions.loadSuspensionNodeFromXML)\n    SpecializationUtil.registerFunction(vehicleType, "getSuspensionNodeFromIndex" , Suspensions.getSuspensionNodeFromIndex)\n    SpecializationUtil.registerFunction(vehicleType, "getIsSuspensionNodeActive" , Suspensions.getIsSuspensionNodeActive)\n    SpecializationUtil.registerFunction(vehicleType, "setSuspensionNodeCharacter" , Suspensions.setSuspensionNodeCharacter)\nend\n\n'})}),"\n",(0,o.jsx)(e.h3,{id:"setsuspensionnodecharacter",children:"setSuspensionNodeCharacter"}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Description"})}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Definition"})}),"\n",(0,o.jsxs)(e.blockquote,{children:["\n",(0,o.jsx)(e.p,{children:"setSuspensionNodeCharacter()"}),"\n"]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,o.jsxs)(e.table,{children:[(0,o.jsx)(e.thead,{children:(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.th,{children:"any"}),(0,o.jsx)(e.th,{children:"suspensionNode"})]})}),(0,o.jsx)(e.tbody,{children:(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.td,{children:"any"}),(0,o.jsx)(e.td,{children:"character"})]})})]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Code"})}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-lua",children:"function Suspensions:setSuspensionNodeCharacter(suspensionNode, character)\n    if suspensionNode.useCharacterTorso and character.playerModel ~ = nil then\n        suspensionNode.node = character.playerModel.thirdPersonSuspensionNode\n\n        if suspensionNode.node ~ = nil then\n            local component = self:getParentComponent(suspensionNode.node)\n            if component ~ = nil then\n                suspensionNode.refNodeOffset = { localToLocal(character.characterNode, component, 0 , 0 , 0 ) }\n                suspensionNode.component = component\n            end\n        end\n    end\nend\n\n"})}),"\n",(0,o.jsx)(e.h3,{id:"subcollisionerrorfunction",children:"subCollisionErrorFunction"}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Description"})}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Definition"})}),"\n",(0,o.jsxs)(e.blockquote,{children:["\n",(0,o.jsx)(e.p,{children:"subCollisionErrorFunction()"}),"\n"]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,o.jsxs)(e.table,{children:[(0,o.jsx)(e.thead,{children:(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.th,{children:"any"}),(0,o.jsx)(e.th,{children:"collisionNode"})]})}),(0,o.jsxs)(e.tbody,{children:[(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.td,{children:"any"}),(0,o.jsx)(e.td,{children:"xmlFile"})]}),(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.td,{children:"any"}),(0,o.jsx)(e.td,{children:"nodeName"})]})]})]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Code"})}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-lua",children:"function Suspensions.subCollisionErrorFunction(collisionNode, xmlFile, nodeName)\n    if getHasClassId(collisionNode, ClassIds.SHAPE) then\n        Logging.xmlError(xmlFile, \"Found collision '%s' as child of suspension node '%s'.This can cause the vehicle to never sleep!\" , getName(collisionNode), nodeName)\n    end\nend\n\n"})})]})}function p(n={}){const{wrapper:e}={...(0,r.R)(),...n.components};return e?(0,o.jsx)(e,{...n,children:(0,o.jsx)(d,{...n})}):d(n)}}}]);