"use strict";(globalThis.webpackChunkfs25_community_luadoc=globalThis.webpackChunkfs25_community_luadoc||[]).push([[84110],{22901(e,n,t){t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>l,default:()=>h,frontMatter:()=>r,metadata:()=>i,toc:()=>d});const i=JSON.parse('{"id":"script/Utils/ObjectChangeUtil","title":"ObjectChangeUtil","description":"ObjectChangeUtil","source":"@site/../docs/script/Utils/ObjectChangeUtil.md","sourceDirName":"script/Utils","slug":"/script/Utils/ObjectChangeUtil","permalink":"/FS25-Community-LUADOC/script/Utils/ObjectChangeUtil","draft":false,"unlisted":false,"tags":[],"version":"current","lastUpdatedAt":1767161192000,"frontMatter":{},"sidebar":"docsSidebar","previous":{"title":"MathUtil","permalink":"/FS25-Community-LUADOC/script/Utils/MathUtil"},"next":{"title":"ObjectPool","permalink":"/FS25-Community-LUADOC/script/Utils/ObjectPool"}}');var a=t(74848),s=t(28453);const r={},l=void 0,c={},d=[{value:"ObjectChangeUtil",id:"objectchangeutil",level:2},{value:"addAdditionalObjectChangeXMLPaths",id:"addadditionalobjectchangexmlpaths",level:3},{value:"loadObjectChangeFromXML",id:"loadobjectchangefromxml",level:3},{value:"loadValuesFromXML",id:"loadvaluesfromxml",level:3},{value:"registerObjectChangeSingleXMLPaths",id:"registerobjectchangesinglexmlpaths",level:3},{value:"registerObjectChangesXMLPaths",id:"registerobjectchangesxmlpaths",level:3},{value:"registerObjectChangeXMLPaths",id:"registerobjectchangexmlpaths",level:3},{value:"setObjectChange",id:"setobjectchange",level:3},{value:"setObjectChanges",id:"setobjectchanges",level:3},{value:"updateObjectChanges",id:"updateobjectchanges",level:3}];function o(e){const n={a:"a",blockquote:"blockquote",code:"code",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,s.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.h2,{id:"objectchangeutil",children:"ObjectChangeUtil"}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Functions"})}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.a,{href:"#addadditionalobjectchangexmlpaths",children:"addAdditionalObjectChangeXMLPaths"})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.a,{href:"#loadobjectchangefromxml",children:"loadObjectChangeFromXML"})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.a,{href:"#loadvaluesfromxml",children:"loadValuesFromXML"})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.a,{href:"#registerobjectchangesinglexmlpaths",children:"registerObjectChangeSingleXMLPaths"})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.a,{href:"#registerobjectchangesxmlpaths",children:"registerObjectChangesXMLPaths"})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.a,{href:"#registerobjectchangexmlpaths",children:"registerObjectChangeXMLPaths"})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.a,{href:"#setobjectchange",children:"setObjectChange"})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.a,{href:"#setobjectchanges",children:"setObjectChanges"})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.a,{href:"#updateobjectchanges",children:"updateObjectChanges"})}),"\n"]}),"\n",(0,a.jsx)(n.h3,{id:"addadditionalobjectchangexmlpaths",children:"addAdditionalObjectChangeXMLPaths"}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Description"})}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Definition"})}),"\n",(0,a.jsxs)(n.blockquote,{children:["\n",(0,a.jsx)(n.p,{children:"addAdditionalObjectChangeXMLPaths(XMLSchema schema, function func)"}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,a.jsxs)(n.table,{children:[(0,a.jsx)(n.thead,{children:(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.th,{children:"XMLSchema"}),(0,a.jsx)(n.th,{children:"schema"})]})}),(0,a.jsx)(n.tbody,{children:(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:"function"}),(0,a.jsx)(n.td,{children:"func"})]})})]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Code"})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-lua",children:'function ObjectChangeUtil.addAdditionalObjectChangeXMLPaths(schema, func)\n    schema:addDelayedRegistrationFunc( "ObjectChange" , func)\nend\n\n'})}),"\n",(0,a.jsx)(n.h3,{id:"loadobjectchangefromxml",children:"loadObjectChangeFromXML"}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Description"})}),"\n",(0,a.jsxs)(n.blockquote,{children:["\n",(0,a.jsx)(n.p,{children:"Load object change from xml"}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Definition"})}),"\n",(0,a.jsxs)(n.blockquote,{children:["\n",(0,a.jsx)(n.p,{children:"loadObjectChangeFromXML(XMLFile xmlFile, string key, table? objects, integer rootNode, table? parent)"}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,a.jsxs)(n.table,{children:[(0,a.jsx)(n.thead,{children:(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.th,{children:"XMLFile"}),(0,a.jsx)(n.th,{children:"xmlFile"}),(0,a.jsx)(n.th,{children:"instance of XMLFile"})]})}),(0,a.jsxs)(n.tbody,{children:[(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:"string"}),(0,a.jsx)(n.td,{children:"key"}),(0,a.jsx)(n.td,{children:"key"})]}),(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:"table?"}),(0,a.jsx)(n.td,{children:"objects"}),(0,a.jsx)(n.td,{children:"table to insert loaded objects to, if omitted new table will be created and returned if object changes could be loaded"})]}),(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:"integer"}),(0,a.jsx)(n.td,{children:"rootNode"}),(0,a.jsx)(n.td,{children:"id of root node"})]}),(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:"table?"}),(0,a.jsx)(n.td,{children:"parent"}),(0,a.jsx)(n.td,{children:"parent"})]})]})]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Return Values"})}),"\n\n\n\n\n\n\n\n\n",(0,a.jsx)(n.table,{children:(0,a.jsx)(n.thead,{children:(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.th,{children:"table?"}),(0,a.jsx)(n.th,{children:"objects"}),(0,a.jsx)(n.th,{children:"list with loaded object changes, 'objects' argument if provided, new table or nil otherwise"})]})})}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Code"})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-lua",children:'function ObjectChangeUtil.loadObjectChangeFromXML(xmlFile, key, objects, rootNode, parent)\n    for _, nodeKey in xmlFile:iterator(key .. ".objectChange" ) do\n        local i3dMappings\n        if parent ~ = nil then\n            i3dMappings = parent.i3dMappings\n        end\n        local node = xmlFile:getValue(nodeKey .. "#node" , nil , rootNode, i3dMappings)\n        if node ~ = nil then\n            local object = { }\n            object.node = node\n            ObjectChangeUtil.loadValuesFromXML(xmlFile, nodeKey, node, object, parent, rootNode, i3dMappings)\n            objects = objects or { }\n            table.insert(objects, object)\n        end\n    end\n\n    return objects\nend\n\n'})}),"\n",(0,a.jsx)(n.h3,{id:"loadvaluesfromxml",children:"loadValuesFromXML"}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Description"})}),"\n",(0,a.jsxs)(n.blockquote,{children:["\n",(0,a.jsx)(n.p,{children:"Load object values from xml"}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Definition"})}),"\n",(0,a.jsxs)(n.blockquote,{children:["\n",(0,a.jsx)(n.p,{children:"loadValuesFromXML(XMLFile xmlFile, string key, integer node, table object, table? parent, entityId? rootNode, table?\ni3dMappings)"}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,a.jsxs)(n.table,{children:[(0,a.jsx)(n.thead,{children:(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.th,{children:"XMLFile"}),(0,a.jsx)(n.th,{children:"xmlFile"}),(0,a.jsx)(n.th,{children:"instance of XMLFile"})]})}),(0,a.jsxs)(n.tbody,{children:[(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:"string"}),(0,a.jsx)(n.td,{children:"key"}),(0,a.jsx)(n.td,{children:"key"})]}),(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:"integer"}),(0,a.jsx)(n.td,{children:"node"}),(0,a.jsx)(n.td,{children:"node id to load from"})]}),(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:"table"}),(0,a.jsx)(n.td,{children:"object"}),(0,a.jsx)(n.td,{children:"table to insert loaded data"})]}),(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:"table?"}),(0,a.jsx)(n.td,{children:"parent"}),(0,a.jsx)(n.td,{children:"parent"})]}),(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:"entityId?"}),(0,a.jsx)(n.td,{children:"rootNode"}),(0,a.jsx)(n.td,{})]}),(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:"table?"}),(0,a.jsx)(n.td,{children:"i3dMappings"}),(0,a.jsx)(n.td,{})]})]})]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Code"})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-lua",children:'function ObjectChangeUtil.loadValuesFromXML(xmlFile, key, node, object, parent, rootNode, i3dMappings)\n    XMLUtil.checkDeprecatedXMLElements(xmlFile, "" , key .. "#collisionActive" , key .. "#compoundChildActive or #rigidBodyTypeActive" ) --FS17 to FS19\n    XMLUtil.checkDeprecatedXMLElements(xmlFile, "" , key .. "#collisionInactive" , key .. "#compoundChildInactive or #rigidBodyTypeInactive" ) --FS17 to FS19\n\n    object.parent = parent\n\n    object.interpolation = xmlFile:getValue(key .. "#interpolation" , false )\n    object.interpolationTime = xmlFile:getValue(key .. "#interpolationTime" , 1 )\n\n    object.values = { }\n\n    local entry = ObjectChangeUtil.loadValueType(object.values, xmlFile, key, "parentNode" , nil ,\n    function (parentNode)\n        local x, y, z = getWorldTranslation(node)\n        local rx, ry, rz = getWorldRotation(node)\n\n        link(parentNode, node)\n\n        setWorldTranslation(node, x, y, z)\n        setWorldRotation(node, rx, ry, rz)\n    end , false , nil , rootNode, i3dMappings)\n\n    if entry ~ = nil then\n        if entry.active = = nil then\n            entry.active = { getParent(object.node) }\n        end\n        if entry.inactive = = nil then\n            entry.inactive = { getParent(object.node) }\n        end\n    end\n\n    ObjectChangeUtil.loadValueType(object.values, xmlFile, key, "delete" ,\n    nil ,\n    function (doDelete)\n        if doDelete then\n            local parent = getParent(node)\n            local name = getName(node)\n            local deletedName = string.format( "%s_deletedByObjectChange" , name)\n            local index = getChildIndex(node)\n            local emptyTG = createTransformGroup(deletedName)\n            link(parent, emptyTG, index)\n            delete(node)\n        end\n    end ,\n    false )\n\n    ObjectChangeUtil.loadValueType(object.values, xmlFile, key, "translation" ,\n    function ()\n        return getTranslation(node)\n    end ,\n    function (x, y, z)\n        setTranslation(node, x, y, z)\n    end ,\n    true , nil , true )\n\n    ObjectChangeUtil.loadValueType(object.values, xmlFile, key, "rotation" ,\n    function ()\n        return getRotation(node)\n    end ,\n    function (x, y, z)\n        setRotation(node, x, y, z)\n    end ,\n    true , nil , true )\n\n    ObjectChangeUtil.loadValueType(object.values, xmlFile, key, "scale" ,\n    function ()\n        return getScale(node)\n    end ,\n    function (x, y, z)\n        setScale(node, x, y, z)\n    end ,\n    true , nil , true )\n\n    local shaderParameter = xmlFile:getValue(key .. "#shaderParameter" )\n    if shaderParameter ~ = nil then\n        local recursive = xmlFile:getValue(key .. "#shaderParameterSetRecursive" , false )\n        if not recursive then\n            if getHasClassId(node, ClassIds.SHAPE) then\n                if getHasShaderParameter(node, shaderParameter) then\n                    local sharedShaderParameter = xmlFile:getValue(key .. "#sharedShaderParameter" , false )\n\n                    ObjectChangeUtil.loadValueType(object.values, xmlFile, key, "shaderParameter" ,\n                    function ()\n                        return getShaderParameter(node, shaderParameter)\n                    end ,\n                    function (x, y, z, w)\n                        setShaderParameter(node, shaderParameter, x, y, z, w, sharedShaderParameter)\n                    end ,\n                    true , nil , true )\n                else\n                        Logging.xmlWarning(xmlFile, "Missing shader parameter \'%s\' on object \'%s\' in \'%s\'" , shaderParameter, getName(node), key)\n                    end\n                else\n                        Logging.xmlWarning(xmlFile, "Given node %q at %q is not a shape and cannot have a shaderParameter applied to it" , getName(node), key)\n                    end\n                else\n                        -- recursive\n                        if I3DUtil.getHasShaderParameterRec(node, shaderParameter) then\n                            ObjectChangeUtil.loadValueType(object.values, xmlFile, key, "shaderParameter" ,\n                            function ()\n                                return I3DUtil.getShaderParameterRec(node, shaderParameter)\n                            end ,\n                            function (x, y, z, w)\n                                setShaderParameterRecursive(node, shaderParameter, x, y, z, w, false )\n                            end ,\n                            true , nil , true )\n                        else\n                                Logging.xmlWarning(xmlFile, "Missing shader parameter \'%s\' on object \'%s\' or any of its children(recursive) in \'%s\'" , shaderParameter, getName(node), key)\n                            end\n                        end\n                    end\n\n                    local centerOfMassMaskActive = xmlFile:getString(key .. "#centerOfMassActive" )\n                    local centerOfMassMaskInactive = xmlFile:getString(key .. "#centerOfMassInactive" )\n                    if centerOfMassMaskActive ~ = nil or centerOfMassMaskInactive ~ = nil then\n                        centerOfMassMaskActive = (centerOfMassMaskActive or "" ):split( " " )\n                        centerOfMassMaskInactive = (centerOfMassMaskInactive or "" ):split( " " )\n\n                        object.centerOfMassMask = { 1 , 1 , 1 }\n                        object.centerOfMassMaskActive = false\n                        for i = 1 , 3 do\n                            if centerOfMassMaskActive ~ = nil and centerOfMassMaskActive[i] = = "-" then\n                                object.centerOfMassMask[i] = 0\n                                object.centerOfMassMaskActive = true\n                            end\n\n                            if centerOfMassMaskInactive ~ = nil and centerOfMassMaskInactive[i] = = "-" then\n                                object.centerOfMassMask[i] = 0\n                                object.centerOfMassMaskActive = true\n                            end\n                        end\n                    end\n\n                    ObjectChangeUtil.loadValueType(object.values, xmlFile, key, "centerOfMass" ,\n                    function ()\n                        return getCenterOfMass(node)\n                    end ,\n                    function (x, y, z)\n                        if object.centerOfMassMaskActive ~ = nil then\n                            local cx, cy, cz = getCenterOfMass(node)\n                            if object.centerOfMassMask[ 1 ] = = 0 then x = cx end\n                            if object.centerOfMassMask[ 2 ] = = 0 then y = cy end\n                            if object.centerOfMassMask[ 3 ] = = 0 then z = cz end\n                        end\n\n                        setCenterOfMass(node, x, y, z)\n                    end ,\n                    true , nil , true )\n\n                    ObjectChangeUtil.loadValueType(object.values, xmlFile, key, "mass" ,\n                    function ()\n                        return getMass(node)\n                    end ,\n                    function (value)\n                        setMass(node, value / 1000 )\n\n                        if parent ~ = nil and parent.components ~ = nil then\n                            for _, component in ipairs(parent.components) do\n                                if component.node = = object.node then\n                                    component.defaultMass = value / 1000\n                                    parent:setMassDirty()\n                                end\n                            end\n                        end\n                    end , true )\n\n                    ObjectChangeUtil.loadValueType(object.values, xmlFile, key, "visibility" , nil ,\n                    function (state)\n                        setVisibility(node, state)\n                    end , false )\n\n                    ObjectChangeUtil.loadValueType(object.values, xmlFile, key, "compoundChild" , nil ,\n                    function (state)\n                        setIsCompoundChild(node, state)\n                    end , false )\n\n                    local rigidBodyTypeActiveStr = xmlFile:getValue(key .. "#rigidBodyTypeActive" )\n                    if rigidBodyTypeActiveStr ~ = nil then\n                        object.rigidBodyTypeActive = RigidBodyType[ string.upper(rigidBodyTypeActiveStr)]\n\n                        local t = object.rigidBodyTypeActive\n                        if t ~ = RigidBodyType.STATIC and t ~ = RigidBodyType.DYNAMIC and t ~ = RigidBodyType.KINEMATIC and t ~ = RigidBodyType.NONE then\n                            Logging.xmlWarning(xmlFile, "Invalid rigidBodyTypeActive \'%s\' for object change node \'%s\'.Use \'Static\', \'Dynamic\', \'Kinematic\' or \'None\'!" , rigidBodyTypeActiveStr, key)\n                                object.rigidBodyTypeActive = nil\n                            end\n                        end\n\n                        local rigidBodyTypeInactiveStr = xmlFile:getValue(key .. "#rigidBodyTypeInactive" )\n                        if rigidBodyTypeInactiveStr ~ = nil then\n                            object.rigidBodyTypeInactive = RigidBodyType[ string.upper(rigidBodyTypeInactiveStr)]\n\n                            local t = object.rigidBodyTypeInactive\n                            if t ~ = RigidBodyType.STATIC and t ~ = RigidBodyType.DYNAMIC and t ~ = RigidBodyType.KINEMATIC and t ~ = RigidBodyType.NONE then\n                                Logging.xmlWarning(xmlFile, "Invalid rigidBodyTypeInactive \'%s\' for object change node \'%s\'.Use \'Static\', \'Dynamic\', \'Kinematic\' or \'None\'!" , rigidBodyTypeInactiveStr, key)\n                                    object.rigidBodyTypeInactive = nil\n                                end\n                            end\n\n                            if parent ~ = nil and parent.loadObjectChangeValuesFromXML ~ = nil then\n                                parent:loadObjectChangeValuesFromXML(xmlFile, key, node, object)\n                            end\n                        end\n\n'})}),"\n",(0,a.jsx)(n.h3,{id:"registerobjectchangesinglexmlpaths",children:"registerObjectChangeSingleXMLPaths"}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Description"})}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Definition"})}),"\n",(0,a.jsxs)(n.blockquote,{children:["\n",(0,a.jsx)(n.p,{children:"registerObjectChangeSingleXMLPaths(XMLSchema schema, string basePath)"}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,a.jsxs)(n.table,{children:[(0,a.jsx)(n.thead,{children:(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.th,{children:"XMLSchema"}),(0,a.jsx)(n.th,{children:"schema"})]})}),(0,a.jsx)(n.tbody,{children:(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:"string"}),(0,a.jsx)(n.td,{children:"basePath"})]})})]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Code"})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-lua",children:'function ObjectChangeUtil.registerObjectChangeSingleXMLPaths(schema, basePath)\n    schema:addDelayedRegistrationPath(basePath .. ".objectChange(?)" , "ObjectChange" )\n\n    schema:register(XMLValueType.NODE_INDEX, basePath .. ".objectChange(?)#node" , "Object change node" )\n    schema:register(XMLValueType.BOOL, basePath .. ".objectChange(?)#interpolation" , "Value will be interpolated" , false )\n    schema:register(XMLValueType.TIME, basePath .. ".objectChange(?)#interpolationTime" , "Time for interpolation" , 1 )\n\n        local positivStr = "%s if object change is active"\n            local negativeStr = "%s if object change is in active"\n\n                schema:register(XMLValueType.BOOL, basePath .. ".objectChange(?)#deleteActive" , string.format(positivStr, "delete" ))\n                schema:register(XMLValueType.BOOL, basePath .. ".objectChange(?)#deleteInactive" , string.format(positivStr, "delete" ))\n\n                schema:register(XMLValueType.BOOL, basePath .. ".objectChange(?)#visibilityActive" , string.format(positivStr, "visibility" ))\n                schema:register(XMLValueType.BOOL, basePath .. ".objectChange(?)#visibilityInactive" , string.format(negativeStr, "visibility" ))\n\n                schema:register(XMLValueType.VECTOR_TRANS, basePath .. ".objectChange(?)#translationActive" , string.format(positivStr, "translation" ))\n                schema:register(XMLValueType.VECTOR_TRANS, basePath .. ".objectChange(?)#translationInactive" , string.format(negativeStr, "translation" ))\n\n                schema:register(XMLValueType.VECTOR_ROT, basePath .. ".objectChange(?)#rotationActive" , string.format(positivStr, "rotation" ))\n                schema:register(XMLValueType.VECTOR_ROT, basePath .. ".objectChange(?)#rotationInactive" , string.format(negativeStr, "rotation" ))\n\n                schema:register(XMLValueType.VECTOR_SCALE, basePath .. ".objectChange(?)#scaleActive" , string.format(positivStr, "scale" ))\n                schema:register(XMLValueType.VECTOR_SCALE, basePath .. ".objectChange(?)#scaleInactive" , string.format(negativeStr, "scale" ))\n\n                schema:register(XMLValueType.STRING, basePath .. ".objectChange(?)#shaderParameter" , "Shader parameter name" )\n                schema:register(XMLValueType.VECTOR_ 4 , basePath .. ".objectChange(?)#shaderParameterActive" , string.format(positivStr, "shaderParameter" ))\n                schema:register(XMLValueType.VECTOR_ 4 , basePath .. ".objectChange(?)#shaderParameterInactive" , string.format(negativeStr, "shaderParameter" ))\n                schema:register(XMLValueType.BOOL, basePath .. ".objectChange(?)#sharedShaderParameter" , "Shader parameter is applied on all objects with the same material" , false )\n                schema:register(XMLValueType.BOOL, basePath .. ".objectChange(?)#shaderParameterSetRecursive" , "Shader parameter is applied to all child nodes recursively" , false )\n\n                schema:register(XMLValueType.FLOAT, basePath .. ".objectChange(?)#massActive" , string.format(positivStr, "mass" ))\n                schema:register(XMLValueType.FLOAT, basePath .. ".objectChange(?)#massInactive" , string.format(negativeStr, "mass" ))\n\n                schema:register(XMLValueType.VECTOR_ 3 , basePath .. ".objectChange(?)#centerOfMassActive" , string.format(positivStr, "center of mass" ))\n                schema:register(XMLValueType.VECTOR_ 3 , basePath .. ".objectChange(?)#centerOfMassInactive" , string.format(negativeStr, "center of mass" ))\n\n                schema:register(XMLValueType.BOOL, basePath .. ".objectChange(?)#compoundChildActive" , string.format(positivStr, "compound child state" ))\n                schema:register(XMLValueType.BOOL, basePath .. ".objectChange(?)#compoundChildInactive" , string.format(negativeStr, "compound child state" ))\n\n                schema:register(XMLValueType.STRING, basePath .. ".objectChange(?)#rigidBodyTypeActive" , string.format(positivStr, "rigid body type" ))\n                schema:register(XMLValueType.STRING, basePath .. ".objectChange(?)#rigidBodyTypeInactive" , string.format(negativeStr, "rigid body type" ))\n\n                schema:register(XMLValueType.NODE_INDEX, basePath .. ".objectChange(?)#parentNodeActive" , string.format(positivStr, "parent node" ))\n                schema:register(XMLValueType.NODE_INDEX, basePath .. ".objectChange(?)#parentNodeInactive" , string.format(negativeStr, "parent node" ))\n            end\n\n'})}),"\n",(0,a.jsx)(n.h3,{id:"registerobjectchangesxmlpaths",children:"registerObjectChangesXMLPaths"}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Description"})}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Definition"})}),"\n",(0,a.jsxs)(n.blockquote,{children:["\n",(0,a.jsx)(n.p,{children:"registerObjectChangesXMLPaths(XMLSchema schema, string basePath)"}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,a.jsxs)(n.table,{children:[(0,a.jsx)(n.thead,{children:(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.th,{children:"XMLSchema"}),(0,a.jsx)(n.th,{children:"schema"})]})}),(0,a.jsx)(n.tbody,{children:(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:"string"}),(0,a.jsx)(n.td,{children:"basePath"})]})})]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Code"})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-lua",children:'function ObjectChangeUtil.registerObjectChangesXMLPaths(schema, basePath)\n    schema:setXMLSharedRegistration( "ObjectChange_multiple" , basePath)\n    ObjectChangeUtil.registerObjectChangeSingleXMLPaths(schema, basePath .. ".objectChanges" )\n    schema:resetXMLSharedRegistration( "ObjectChange_multiple" , basePath)\nend\n\n'})}),"\n",(0,a.jsx)(n.h3,{id:"registerobjectchangexmlpaths",children:"registerObjectChangeXMLPaths"}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Description"})}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Definition"})}),"\n",(0,a.jsxs)(n.blockquote,{children:["\n",(0,a.jsx)(n.p,{children:"registerObjectChangeXMLPaths(XMLSchema schema, string basePath)"}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,a.jsxs)(n.table,{children:[(0,a.jsx)(n.thead,{children:(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.th,{children:"XMLSchema"}),(0,a.jsx)(n.th,{children:"schema"})]})}),(0,a.jsx)(n.tbody,{children:(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:"string"}),(0,a.jsx)(n.td,{children:"basePath"})]})})]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Code"})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-lua",children:'function ObjectChangeUtil.registerObjectChangeXMLPaths(schema, basePath)\n    schema:setXMLSharedRegistration( "ObjectChange_single" , basePath)\n    ObjectChangeUtil.registerObjectChangeSingleXMLPaths(schema, basePath)\n    schema:resetXMLSharedRegistration( "ObjectChange_single" , basePath)\nend\n\n'})}),"\n",(0,a.jsx)(n.h3,{id:"setobjectchange",children:"setObjectChange"}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Description"})}),"\n",(0,a.jsxs)(n.blockquote,{children:["\n",(0,a.jsx)(n.p,{children:"Set object change"}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Definition"})}),"\n",(0,a.jsxs)(n.blockquote,{children:["\n",(0,a.jsx)(n.p,{children:"setObjectChange(table object, boolean isActive, table target, function updateFunc, boolean? skipInterpolation)"}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,a.jsxs)(n.table,{children:[(0,a.jsx)(n.thead,{children:(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.th,{children:"table"}),(0,a.jsx)(n.th,{children:"object"}),(0,a.jsx)(n.th,{children:"objects to change"})]})}),(0,a.jsxs)(n.tbody,{children:[(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:"boolean"}),(0,a.jsx)(n.td,{children:"isActive"}),(0,a.jsx)(n.td,{children:"is active"})]}),(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:"table"}),(0,a.jsx)(n.td,{children:"target"}),(0,a.jsx)(n.td,{children:"target for updateFunc"})]}),(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:"function"}),(0,a.jsx)(n.td,{children:"updateFunc"}),(0,a.jsx)(n.td,{children:"function to update"})]}),(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:"boolean?"}),(0,a.jsx)(n.td,{children:"skipInterpolation"}),(0,a.jsx)(n.td,{})]})]})]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Code"})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-lua",children:"function ObjectChangeUtil.setObjectChange(object, isActive, target, updateFunc, skipInterpolation)\n    if isActive then\n        for i = 1 , #object.values do\n            local value = object.values[i]\n\n            if value.active ~ = nil then\n                if object.interpolation and value.interpolatable and not skipInterpolation then\n                    local interpolator = ValueInterpolator.new(object.node .. value.name, value.getFunc, value.setFunc, value.active, object.interpolationTime)\n                    if interpolator ~ = nil then\n                        interpolator:setUpdateFunc(updateFunc, target, object.node)\n                        interpolator:setDeleteListenerObject(object.parent)\n                    end\n                else\n                        if skipInterpolation then\n                            ValueInterpolator.removeInterpolator(object.node .. value.name)\n                        end\n\n                        value.setFunc( unpack(value.active))\n                    end\n                end\n            end\n\n            if object.rigidBodyTypeActive ~ = nil then\n                setRigidBodyType(object.node, object.rigidBodyTypeActive)\n            end\n        else\n                for i = 1 , #object.values do\n                    local value = object.values[i]\n\n                    if value.inactive ~ = nil then\n                        if object.interpolation and value.interpolatable and not skipInterpolation then\n                            local interpolator = ValueInterpolator.new(object.node .. value.name, value.getFunc, value.setFunc, value.inactive, object.interpolationTime)\n                            if interpolator ~ = nil then\n                                interpolator:setUpdateFunc(updateFunc, target, object.node)\n                                interpolator:setDeleteListenerObject(object.parent)\n                            end\n                        else\n                                if skipInterpolation then\n                                    ValueInterpolator.removeInterpolator(object.node .. value.name)\n                                end\n\n                                value.setFunc( unpack(value.inactive))\n                            end\n                        end\n                    end\n\n                    if object.rigidBodyTypeInactive ~ = nil then\n                        setRigidBodyType(object.node, object.rigidBodyTypeInactive)\n                    end\n                end\n                if target ~ = nil then\n                    if target.setObjectChangeValues ~ = nil then\n                        target:setObjectChangeValues(object, isActive)\n                    end\n                    if updateFunc ~ = nil then\n                        updateFunc(target, object.node)\n                    end\n                end\n            end\n\n"})}),"\n",(0,a.jsx)(n.h3,{id:"setobjectchanges",children:"setObjectChanges"}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Description"})}),"\n",(0,a.jsxs)(n.blockquote,{children:["\n",(0,a.jsx)(n.p,{children:"Set object changes"}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Definition"})}),"\n",(0,a.jsxs)(n.blockquote,{children:["\n",(0,a.jsx)(n.p,{children:"setObjectChanges(table objects, boolean isActive, table? target, function? updateFunc, boolean? skipInterpolation)"}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,a.jsxs)(n.table,{children:[(0,a.jsx)(n.thead,{children:(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.th,{children:"table"}),(0,a.jsx)(n.th,{children:"objects"}),(0,a.jsx)(n.th,{children:"objects to change"})]})}),(0,a.jsxs)(n.tbody,{children:[(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:"boolean"}),(0,a.jsx)(n.td,{children:"isActive"}),(0,a.jsx)(n.td,{children:"is active"})]}),(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:"table?"}),(0,a.jsx)(n.td,{children:"target"}),(0,a.jsx)(n.td,{children:"target for updateFunc"})]}),(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:"function?"}),(0,a.jsx)(n.td,{children:"updateFunc"}),(0,a.jsx)(n.td,{children:"function to update"})]}),(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:"boolean?"}),(0,a.jsx)(n.td,{children:"skipInterpolation"}),(0,a.jsx)(n.td,{})]})]})]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Code"})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-lua",children:"function ObjectChangeUtil.setObjectChanges(objects, isActive, target, updateFunc, skipInterpolation)\n    if objects ~ = nil then\n        for _, object in pairs(objects) do\n            ObjectChangeUtil.setObjectChange(object, isActive, target, updateFunc, skipInterpolation)\n        end\n    end\nend\n\n"})}),"\n",(0,a.jsx)(n.h3,{id:"updateobjectchanges",children:"updateObjectChanges"}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Description"})}),"\n",(0,a.jsxs)(n.blockquote,{children:["\n",(0,a.jsx)(n.p,{children:"Update object changes"}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Definition"})}),"\n",(0,a.jsxs)(n.blockquote,{children:["\n",(0,a.jsx)(n.p,{children:"updateObjectChanges(XMLFile xmlFile, string key, integer configIndex, integer rootNode, table parent)"}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,a.jsxs)(n.table,{children:[(0,a.jsx)(n.thead,{children:(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.th,{children:"XMLFile"}),(0,a.jsx)(n.th,{children:"xmlFile"}),(0,a.jsx)(n.th,{children:"instance of XMLFile"})]})}),(0,a.jsxs)(n.tbody,{children:[(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:"string"}),(0,a.jsx)(n.td,{children:"key"}),(0,a.jsx)(n.td,{children:"key"})]}),(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:"integer"}),(0,a.jsx)(n.td,{children:"configIndex"}),(0,a.jsx)(n.td,{children:"index of used config"})]}),(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:"integer"}),(0,a.jsx)(n.td,{children:"rootNode"}),(0,a.jsx)(n.td,{children:"id of root node"})]}),(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:"table"}),(0,a.jsx)(n.td,{children:"parent"}),(0,a.jsx)(n.td,{children:"parent"})]})]})]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Code"})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-lua",children:'function ObjectChangeUtil.updateObjectChanges(xmlFile, key, configIndex, rootNode, parent)\n    local i = 0\n    local activeI = (configIndex - 1 )\n    while true do\n        local objectChangeKey = string.format(key .. "(%d)" , i)\n        if not xmlFile:hasProperty(objectChangeKey) then\n            break\n        end\n        if i ~ = activeI then\n            local objects = ObjectChangeUtil.loadObjectChangeFromXML(xmlFile, objectChangeKey, nil , rootNode, parent)\n            ObjectChangeUtil.setObjectChanges(objects, false , parent)\n        end\n        i = i + 1\n    end\n\n    -- Set the active config last so that it can overwrite settings of inactive configurations\n    if i > activeI then\n        local objectChangeKey = string.format(key .. "(%d)" , activeI)\n        local objects = ObjectChangeUtil.loadObjectChangeFromXML(xmlFile, objectChangeKey, nil , rootNode, parent)\n        ObjectChangeUtil.setObjectChanges(objects, true , parent)\n    end\nend\n\n'})})]})}function h(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(o,{...e})}):o(e)}},28453(e,n,t){t.d(n,{R:()=>r,x:()=>l});var i=t(96540);const a={},s=i.createContext(a);function r(e){const n=i.useContext(s);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:r(e.components),i.createElement(s.Provider,{value:n},e.children)}}}]);