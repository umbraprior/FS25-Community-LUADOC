"use strict";(globalThis.webpackChunkfs25_community_luadoc=globalThis.webpackChunkfs25_community_luadoc||[]).push([[35981],{13986(e,n,l){l.r(n),l.d(n,{assets:()=>c,contentTitle:()=>r,default:()=>p,frontMatter:()=>s,metadata:()=>i,toc:()=>d});const i=JSON.parse('{"id":"script/Placement/PalletSpawner","title":"PalletSpawner","description":"PalletSpawner","source":"@site/../docs/script/Placement/PalletSpawner.md","sourceDirName":"script/Placement","slug":"/script/Placement/PalletSpawner","permalink":"/FS25-Community-LUADOC/script/Placement/PalletSpawner","draft":false,"unlisted":false,"tags":[],"version":"current","lastUpdatedAt":1767161192000,"frontMatter":{},"sidebar":"docsSidebar","previous":{"title":"PlaceableSystem","permalink":"/FS25-Community-LUADOC/script/Placeables/PlaceableSystem"},"next":{"title":"PlacementGrid2D","permalink":"/FS25-Community-LUADOC/script/Placement/PlacementGrid2D"}}');var a=l(74848),t=l(28453);const s={},r=void 0,c={},d=[{value:"PalletSpawner",id:"palletspawner",level:2},{value:"delete",id:"delete",level:3},{value:"getAllPallets",id:"getallpallets",level:3},{value:"getOrSpawnPallet",id:"getorspawnpallet",level:3},{value:"getSupportedFillTypes",id:"getsupportedfilltypes",level:3},{value:"load",id:"load",level:3},{value:"loadPalletFromFilename",id:"loadpalletfromfilename",level:3},{value:"new",id:"new",level:3},{value:"onFindExistingPallet",id:"onfindexistingpallet",level:3},{value:"onFindPallet",id:"onfindpallet",level:3},{value:"onFinishLoadingPallet",id:"onfinishloadingpallet",level:3},{value:"onSpawnSearchFinished",id:"onspawnsearchfinished",level:3},{value:"registerXMLPaths",id:"registerxmlpaths",level:3},{value:"spawnPallet",id:"spawnpallet",level:3},{value:"update",id:"update",level:3}];function o(e){const n={a:"a",blockquote:"blockquote",code:"code",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,t.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.h2,{id:"palletspawner",children:"PalletSpawner"}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Description"})}),"\n",(0,a.jsxs)(n.blockquote,{children:["\n",(0,a.jsx)(n.p,{children:"This class spawns pallets"}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Functions"})}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.a,{href:"#delete",children:"delete"})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.a,{href:"#getallpallets",children:"getAllPallets"})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.a,{href:"#getorspawnpallet",children:"getOrSpawnPallet"})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.a,{href:"#getsupportedfilltypes",children:"getSupportedFillTypes"})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.a,{href:"#load",children:"load"})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.a,{href:"#loadpalletfromfilename",children:"loadPalletFromFilename"})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.a,{href:"#new",children:"new"})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.a,{href:"#onfindexistingpallet",children:"onFindExistingPallet"})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.a,{href:"#onfindpallet",children:"onFindPallet"})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.a,{href:"#onfinishloadingpallet",children:"onFinishLoadingPallet"})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.a,{href:"#onspawnsearchfinished",children:"onSpawnSearchFinished"})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.a,{href:"#registerxmlpaths",children:"registerXMLPaths"})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.a,{href:"#spawnpallet",children:"spawnPallet"})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.a,{href:"#update",children:"update"})}),"\n"]}),"\n",(0,a.jsx)(n.h3,{id:"delete",children:"delete"}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Description"})}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Definition"})}),"\n",(0,a.jsxs)(n.blockquote,{children:["\n",(0,a.jsx)(n.p,{children:"delete()"}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Code"})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-lua",children:"function PalletSpawner:delete()\nend\n\n"})}),"\n",(0,a.jsx)(n.h3,{id:"getallpallets",children:"getAllPallets"}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Description"})}),"\n",(0,a.jsxs)(n.blockquote,{children:["\n",(0,a.jsx)(n.p,{children:"Get all pallets for given fillTypeId within the spawn places"}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Definition"})}),"\n",(0,a.jsxs)(n.blockquote,{children:["\n",(0,a.jsx)(n.p,{children:"getAllPallets(integer fillTypeId, function callbackFunc, table callbackTarget)"}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,a.jsxs)(n.table,{children:[(0,a.jsx)(n.thead,{children:(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.th,{children:"integer"}),(0,a.jsx)(n.th,{children:"fillTypeId"}),(0,a.jsx)(n.th,{children:"fillTypeId to be supported by the pallet"})]})}),(0,a.jsxs)(n.tbody,{children:[(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:"function"}),(0,a.jsx)(n.td,{children:"callbackFunc"}),(0,a.jsx)(n.td,{children:"callback function which will receive indexed list of pallet vehicle objects"})]}),(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:"table"}),(0,a.jsx)(n.td,{children:"callbackTarget"}),(0,a.jsx)(n.td,{children:"target for the callback function"})]})]})]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Code"})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-lua",children:'function PalletSpawner:getAllPallets(fillTypeId, callbackFunc, callbackTarget)\n    self.getAllPalletsFoundPallets = { }\n    self.getAllPalletsFilltype = fillTypeId\n\n    local spawnPlaces = self.fillTypeToSpawnPlaces[fillTypeId] or self.spawnPlaces\n    for i = 1 , #spawnPlaces do\n        local place = spawnPlaces[i]\n        local x = place.startX + place.width / 2 * place.dirX\n        local y = place.startY + place.width / 2 * place.dirY\n        local z = place.startZ + place.width / 2 * place.dirZ\n        overlapBox(x,y,z, place.rotX, place.rotY, place.rotZ, place.width / 2 , 1 , 1 , "onFindPallet" , self , CollisionFlag.VEHICLE + CollisionFlag.DYNAMIC_OBJECT, true , true , false , true )\n    end\n\n    callbackFunc(callbackTarget, table.toList( self.getAllPalletsFoundPallets), fillTypeId)\nend\n\n'})}),"\n",(0,a.jsx)(n.h3,{id:"getorspawnpallet",children:"getOrSpawnPallet"}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Description"})}),"\n",(0,a.jsxs)(n.blockquote,{children:["\n",(0,a.jsx)(n.p,{children:"Get pallet for given fillTypeId, searches spawnPlaces for existing non-full pallets, spawns a new one otherwise"}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Definition"})}),"\n",(0,a.jsxs)(n.blockquote,{children:["\n",(0,a.jsx)(n.p,{children:"getOrSpawnPallet(integer fillTypeId, function callback, table callbackTarget, )"}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,a.jsxs)(n.table,{children:[(0,a.jsx)(n.thead,{children:(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.th,{children:"integer"}),(0,a.jsx)(n.th,{children:"fillTypeId"}),(0,a.jsx)(n.th,{children:"fillTypeId to be supported by the pallet"})]})}),(0,a.jsxs)(n.tbody,{children:[(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:"function"}),(0,a.jsx)(n.td,{children:"callback"}),(0,a.jsx)(n.td,{children:"callback function which will receive pallet vehicle"})]}),(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:"table"}),(0,a.jsx)(n.td,{children:"callbackTarget"}),(0,a.jsx)(n.td,{children:"target for the callback function"})]}),(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:"any"}),(0,a.jsx)(n.td,{children:"callbackTarget"}),(0,a.jsx)(n.td,{})]})]})]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Code"})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-lua",children:'function PalletSpawner:getOrSpawnPallet(farmId, fillTypeId, callback, callbackTarget)\n    self.foundExistingPallet = nil\n    self.getOrSpawnPalletFilltype = fillTypeId\n\n    local spawnPlaces = self.fillTypeToSpawnPlaces[fillTypeId] or self.spawnPlaces\n\n    for i = 1 , #spawnPlaces do\n        local place = spawnPlaces[i]\n        local x = place.startX + place.width / 2 * place.dirX\n        local y = place.startY + place.width / 2 * place.dirY\n        local z = place.startZ + place.width / 2 * place.dirZ\n        overlapBox(x,y,z, place.rotX, place.rotY, place.rotZ, place.width / 2 , 1 , 1 , "onFindExistingPallet" , self , CollisionFlag.VEHICLE + CollisionFlag.DYNAMIC_OBJECT, true , true , false , true )\n    end\n\n    if self.foundExistingPallet ~ = nil then\n        callback(callbackTarget, self.foundExistingPallet, PalletSpawner.PALLET_ALREADY_PRESENT, fillTypeId)\n    else\n            self:spawnPallet(farmId, fillTypeId, callback, callbackTarget)\n        end\n    end\n\n'})}),"\n",(0,a.jsx)(n.h3,{id:"getsupportedfilltypes",children:"getSupportedFillTypes"}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Description"})}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Definition"})}),"\n",(0,a.jsxs)(n.blockquote,{children:["\n",(0,a.jsx)(n.p,{children:"getSupportedFillTypes()"}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Code"})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-lua",children:"function PalletSpawner:getSupportedFillTypes()\n    return self.fillTypeIdToPallet\nend\n\n"})}),"\n",(0,a.jsx)(n.h3,{id:"load",children:"load"}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Description"})}),"\n",(0,a.jsxs)(n.blockquote,{children:["\n",(0,a.jsx)(n.p,{children:"Loads data from xml"}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Definition"})}),"\n",(0,a.jsxs)(n.blockquote,{children:["\n",(0,a.jsx)(n.p,{children:"load(table components, table xmlFile, string key, string customEnv, table i3dMappings)"}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,a.jsxs)(n.table,{children:[(0,a.jsx)(n.thead,{children:(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.th,{children:"table"}),(0,a.jsx)(n.th,{children:"components"}),(0,a.jsx)(n.th,{children:"components"})]})}),(0,a.jsxs)(n.tbody,{children:[(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:"table"}),(0,a.jsx)(n.td,{children:"xmlFile"}),(0,a.jsx)(n.td,{children:"xml file object"})]}),(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:"string"}),(0,a.jsx)(n.td,{children:"key"}),(0,a.jsx)(n.td,{children:"xml key"})]}),(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:"string"}),(0,a.jsx)(n.td,{children:"customEnv"}),(0,a.jsx)(n.td,{children:"custom environment"})]}),(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:"table"}),(0,a.jsx)(n.td,{children:"i3dMappings"}),(0,a.jsx)(n.td,{children:"i3dMappings"})]})]})]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Return Values"})}),"\n\n\n\n\n\n\n\n\n",(0,a.jsx)(n.table,{children:(0,a.jsx)(n.thead,{children:(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.th,{children:"table"}),(0,a.jsx)(n.th,{children:"success"}),(0,a.jsx)(n.th,{children:"success"})]})})}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Code"})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-lua",children:'function PalletSpawner:load(components, xmlFile, key, customEnv, i3dMappings)\n    self.spawnPlaces = { }\n    self.fillTypeToSpawnPlaces = { }\n    local hasFillTypeSpawnPlaces = false\n\n    for _, spawnPlaceKey in xmlFile:iterator(key .. ".spawnPlaces.spawnPlace" ) do\n        local spawnPlace = PlacementUtil.loadPlaceFromXML(xmlFile, spawnPlaceKey, components, i3dMappings)\n\n        local fillTypes\n        local fillTypeCategories = xmlFile:getValue(spawnPlaceKey .. "#fillTypeCategories" )\n        local fillTypeNames = xmlFile:getValue(spawnPlaceKey .. "#fillTypes" )\n        if fillTypeCategories ~ = nil and fillTypeNames = = nil then\n            fillTypes = g_fillTypeManager:getFillTypesByCategoryNames(fillTypeCategories, "Warning:Palletspawner \'" .. xmlFile:getFilename() .. "\' has invalid fillTypeCategory \'%s\'." )\n        elseif fillTypeCategories = = nil and fillTypeNames ~ = nil then\n                fillTypes = g_fillTypeManager:getFillTypesByNames(fillTypeNames, "Warning:Palletspawner \'" .. xmlFile:getFilename() .. "\' has invalid fillType \'%s\'." )\n            end\n\n            if fillTypes ~ = nil then\n                hasFillTypeSpawnPlaces = true\n                for _, fillType in ipairs(fillTypes) do\n                    if self.fillTypeToSpawnPlaces[fillType] = = nil then\n                        self.fillTypeToSpawnPlaces[fillType] = { }\n                    end\n                    table.insert( self.fillTypeToSpawnPlaces[fillType], spawnPlace)\n                end\n            else\n                    table.insert( self.spawnPlaces, spawnPlace)\n                end\n            end\n\n            if # self.spawnPlaces = = 0 and not hasFillTypeSpawnPlaces then\n                Logging.xmlError(xmlFile, "No spawn place(s) defined for pallet spawner %s%s" , key, ".spawnPlaces" )\n                    return false\n                end\n\n                self.pallets = { }\n                self.fillTypeIdToPallet = { }\n\n                -- load default global pallets defined at fillTypes registration\n                for fillTypeId, fillType in pairs(g_fillTypeManager.indexToFillType) do\n                    if fillType.palletFilename then\n                        self:loadPalletFromFilename(fillType.palletFilename, fillTypeId)\n                    end\n                end\n\n                -- load pallets provided in xml file, will override fillType pallets\n                for _, palletKey in xmlFile:iterator(key .. ".pallets.pallet" ) do\n                    local palletFilename = Utils.getFilename(xmlFile:getValue(palletKey .. "#filename" ), self.baseDirectory)\n                    self:loadPalletFromFilename(palletFilename)\n                end\n\n                return true\n            end\n\n'})}),"\n",(0,a.jsx)(n.h3,{id:"loadpalletfromfilename",children:"loadPalletFromFilename"}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Description"})}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Definition"})}),"\n",(0,a.jsxs)(n.blockquote,{children:["\n",(0,a.jsx)(n.p,{children:"loadPalletFromFilename()"}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,a.jsxs)(n.table,{children:[(0,a.jsx)(n.thead,{children:(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.th,{children:"any"}),(0,a.jsx)(n.th,{children:"palletFilename"})]})}),(0,a.jsx)(n.tbody,{children:(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:"any"}),(0,a.jsx)(n.td,{children:"limitFillTypeId"})]})})]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Code"})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-lua",children:'function PalletSpawner:loadPalletFromFilename(palletFilename, limitFillTypeId)\n    if palletFilename ~ = nil then\n        local pallet = { }\n        pallet.filename = palletFilename\n        pallet.size = StoreItemUtil.getSizeValues(palletFilename, "vehicle" , 0 , { } )\n\n        local palletXmlFile = XMLFile.load( "palletXmlFilename" , palletFilename, Vehicle.xmlSchema)\n        if palletXmlFile = = nil then\n            return nil\n        end\n\n        local fillTypeNamesAndCategories = FillUnit.getFillTypeNamesFromXML(palletXmlFile)\n        pallet.capacity = FillUnit.getCapacityFromXml(palletXmlFile)\n        palletXmlFile:delete()\n\n        local fillTypes = { }\n        fillTypes = g_fillTypeManager:getFillTypesByCategoryNames(fillTypeNamesAndCategories.fillTypeCategoryNames, nil , fillTypes)\n        fillTypes = g_fillTypeManager:getFillTypesByNames(fillTypeNamesAndCategories.fillTypeNames, nil , fillTypes)\n\n        local hadMatchingFillType = false\n        for _, fillTypeId in ipairs(fillTypes) do\n            if limitFillTypeId = = nil or limitFillTypeId = = fillTypeId then\n                self.fillTypeIdToPallet[fillTypeId] = pallet\n                hadMatchingFillType = true\n            end\n        end\n\n        if hadMatchingFillType then\n            table.insert( self.pallets, pallet)\n            return pallet\n        end\n    end\n    return nil\nend\n\n'})}),"\n",(0,a.jsx)(n.h3,{id:"new",children:"new"}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Description"})}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Definition"})}),"\n",(0,a.jsxs)(n.blockquote,{children:["\n",(0,a.jsx)(n.p,{children:"new()"}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,a.jsxs)(n.table,{children:[(0,a.jsx)(n.thead,{children:(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.th,{children:"any"}),(0,a.jsx)(n.th,{children:"baseDirectory"})]})}),(0,a.jsx)(n.tbody,{children:(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:"any"}),(0,a.jsx)(n.td,{children:"customMt"})]})})]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Code"})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-lua",children:"function PalletSpawner.new(baseDirectory, customMt)\n    local self = setmetatable( { } , customMt or PalletSpawner _mt)\n\n    self.baseDirectory = baseDirectory\n    self.spawnQueue = { }\n    self.currentObjectToSpawn = nil\n    self.spawnOffsetY = Platform.gameplay.hasDynamicPallets and 0.2 or 0\n\n    return self\nend\n\n"})}),"\n",(0,a.jsx)(n.h3,{id:"onfindexistingpallet",children:"onFindExistingPallet"}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Description"})}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Definition"})}),"\n",(0,a.jsxs)(n.blockquote,{children:["\n",(0,a.jsx)(n.p,{children:"onFindExistingPallet()"}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,a.jsx)(n.table,{children:(0,a.jsx)(n.thead,{children:(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.th,{children:"any"}),(0,a.jsx)(n.th,{children:"node"})]})})}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Code"})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-lua",children:"function PalletSpawner:onFindExistingPallet(node)\n    local object = g_currentMission.nodeToObject[node]\n    if object ~ = nil and object.isa ~ = nil and object:isa( Vehicle ) and object.isPallet then\n        if object:getFillUnitSupportsFillType( 1 , self.getOrSpawnPalletFilltype) and object:getFillUnitFreeCapacity( 1 , self.getOrSpawnPalletFilltype) > 0 then\n            self.foundExistingPallet = object\n            return false -- stop callback reporting\n        end\n    end\n\n    return\nend\n\n"})}),"\n",(0,a.jsx)(n.h3,{id:"onfindpallet",children:"onFindPallet"}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Description"})}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Definition"})}),"\n",(0,a.jsxs)(n.blockquote,{children:["\n",(0,a.jsx)(n.p,{children:"onFindPallet()"}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,a.jsx)(n.table,{children:(0,a.jsx)(n.thead,{children:(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.th,{children:"any"}),(0,a.jsx)(n.th,{children:"node"})]})})}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Code"})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-lua",children:"function PalletSpawner:onFindPallet(node)\n    local object = g_currentMission.nodeToObject[node]\n    if object ~ = nil and object.isa ~ = nil and object:isa( Vehicle ) and object.isPallet then\n        local fillUnitIndex = object.spec_pallet.fillUnitIndex\n        if object:getFillUnitFillType(fillUnitIndex) = = self.getAllPalletsFilltype then\n            self.getAllPalletsFoundPallets[object] = true\n        end\n    end\nend\n\n"})}),"\n",(0,a.jsx)(n.h3,{id:"onfinishloadingpallet",children:"onFinishLoadingPallet"}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Description"})}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Definition"})}),"\n",(0,a.jsxs)(n.blockquote,{children:["\n",(0,a.jsx)(n.p,{children:"onFinishLoadingPallet()"}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,a.jsxs)(n.table,{children:[(0,a.jsx)(n.thead,{children:(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.th,{children:"any"}),(0,a.jsx)(n.th,{children:"vehicles"})]})}),(0,a.jsx)(n.tbody,{children:(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:"any"}),(0,a.jsx)(n.td,{children:"vehicleLoadState"})]})})]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Code"})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-lua",children:"function PalletSpawner:onFinishLoadingPallet(vehicles, vehicleLoadState)\n    local objectToSpawn = self.currentObjectToSpawn\n    local statusCode = vehicleLoadState = = VehicleLoadingState.OK and PalletSpawner.RESULT_SUCCESS or PalletSpawner.RESULT_ERROR_LOADING_PALLET\n    objectToSpawn.callback(objectToSpawn.callbackTarget, vehicles[ 1 ], statusCode, objectToSpawn.fillType)\n    self.currentObjectToSpawn = nil\n    table.remove( self.spawnQueue, 1 )\nend\n\n"})}),"\n",(0,a.jsx)(n.h3,{id:"onspawnsearchfinished",children:"onSpawnSearchFinished"}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Description"})}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Definition"})}),"\n",(0,a.jsxs)(n.blockquote,{children:["\n",(0,a.jsx)(n.p,{children:"onSpawnSearchFinished()"}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,a.jsx)(n.table,{children:(0,a.jsx)(n.thead,{children:(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.th,{children:"any"}),(0,a.jsx)(n.th,{children:"location"})]})})}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Code"})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-lua",children:'function PalletSpawner:onSpawnSearchFinished(location)\n    local objectToSpawn = self.currentObjectToSpawn\n    if location ~ = nil then\n        local terrainHeight = getTerrainHeightAtWorldPos(g_terrainNode, location.x, 0 , location.z)\n        -- ensure y is at least terrain height\n        -- using only terrain height + offset for pallets might be problematic if spawn area is on top of a mesh with collision\n            -- add saftey y offset to avoid pallets clipping into the ground/collision\n            location.y = math.max(terrainHeight + self.spawnOffsetY, location.y)\n\n            local data = VehicleLoadingData.new()\n            data:setFilename(objectToSpawn.pallet.filename)\n            data:setPosition(location.x, location.y, location.z)\n            data:setRotation(location.xRot, location.yRot, location.zRot)\n            data:setPropertyState(VehiclePropertyState.OWNED)\n            data:setOwnerFarmId(objectToSpawn.farmId)\n            data:setCustomParameter( "spawnEmpty" , true )\n\n            data:load( self.onFinishLoadingPallet, self )\n        else\n                -- unable to find space\n                objectToSpawn.callback(objectToSpawn.callbackTarget, nil , PalletSpawner.RESULT_NO_SPACE, objectToSpawn.fillType)\n                self.currentObjectToSpawn = nil\n                table.remove( self.spawnQueue, 1 )\n            end\n        end\n\n'})}),"\n",(0,a.jsx)(n.h3,{id:"registerxmlpaths",children:"registerXMLPaths"}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Description"})}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Definition"})}),"\n",(0,a.jsxs)(n.blockquote,{children:["\n",(0,a.jsx)(n.p,{children:"registerXMLPaths()"}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,a.jsxs)(n.table,{children:[(0,a.jsx)(n.thead,{children:(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.th,{children:"any"}),(0,a.jsx)(n.th,{children:"schema"})]})}),(0,a.jsx)(n.tbody,{children:(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:"any"}),(0,a.jsx)(n.td,{children:"basePath"})]})})]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Code"})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-lua",children:'function PalletSpawner.registerXMLPaths(schema, basePath)\n    schema:register(XMLValueType.STRING, basePath .. ".spawnPlaces.spawnPlace(?)#fillTypes" , "Supported filltypes for this spawnPlace" )\n        schema:register(XMLValueType.STRING, basePath .. ".spawnPlaces.spawnPlace(?)#fillTypeCategories" , "Supported filltype categories for this spawnPlace" )\n\n            PlacementUtil.registerXMLPaths(schema, basePath)\n\n            schema:register(XMLValueType.STRING, basePath .. ".pallets.pallet(?)#filename" , "Path to pallet xml file" )\n        end\n\n'})}),"\n",(0,a.jsx)(n.h3,{id:"spawnpallet",children:"spawnPallet"}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Description"})}),"\n",(0,a.jsxs)(n.blockquote,{children:["\n",(0,a.jsx)(n.p,{children:"Spawn and get pallet for given fillTypeId"}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Definition"})}),"\n",(0,a.jsxs)(n.blockquote,{children:["\n",(0,a.jsx)(n.p,{children:"spawnPallet(integer fillTypeId, function callback, table callbackTarget, )"}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,a.jsxs)(n.table,{children:[(0,a.jsx)(n.thead,{children:(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.th,{children:"integer"}),(0,a.jsx)(n.th,{children:"fillTypeId"}),(0,a.jsx)(n.th,{children:"fillTypeId to be supported by the pallet"})]})}),(0,a.jsxs)(n.tbody,{children:[(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:"function"}),(0,a.jsx)(n.td,{children:"callback"}),(0,a.jsx)(n.td,{children:"callback function which will receive pallet vehicle"})]}),(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:"table"}),(0,a.jsx)(n.td,{children:"callbackTarget"}),(0,a.jsx)(n.td,{children:"target for the callback function"})]}),(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:"any"}),(0,a.jsx)(n.td,{children:"callbackTarget"}),(0,a.jsx)(n.td,{})]})]})]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Code"})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-lua",children:"function PalletSpawner:spawnPallet(farmId, fillTypeId, callback, callbackTarget)\n    if not g_currentMission.slotSystem:getCanAddLimitedObjects(SlotSystem.LIMITED_OBJECT_PALLET, 1 ) then\n        callback(callbackTarget, nil , PalletSpawner.PALLET_LIMITED_REACHED, fillTypeId)\n        return\n    end\n\n    local pallet = self.fillTypeIdToPallet[fillTypeId]\n    if pallet ~ = nil then\n        table.insert( self.spawnQueue, { pallet = pallet, fillType = fillTypeId, farmId = farmId, callback = callback, callbackTarget = callbackTarget } )\n        g_currentMission:addUpdateable( self )\n    else\n            Logging.devError( \"PalletSpawner:no pallet for fillTypeId '%s'\" , fillTypeId)\n                callback(callbackTarget, nil , PalletSpawner.NO_PALLET_FOR_FILLTYPE, fillTypeId)\n            end\n        end\n\n"})}),"\n",(0,a.jsx)(n.h3,{id:"update",children:"update"}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Description"})}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Definition"})}),"\n",(0,a.jsxs)(n.blockquote,{children:["\n",(0,a.jsx)(n.p,{children:"update()"}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,a.jsx)(n.table,{children:(0,a.jsx)(n.thead,{children:(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.th,{children:"any"}),(0,a.jsx)(n.th,{children:"dt"})]})})}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Code"})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-lua",children:'function PalletSpawner:update(dt)\n    if # self.spawnQueue > 0 then\n        -- DebugUtil.renderTable(0.1, 0.88, 0.015, {{name = "palletSpawnerQueue", value = "# = " .. #self.spawnQueue}})\n\n        if self.currentObjectToSpawn = = nil then\n            self.currentObjectToSpawn = self.spawnQueue[ 1 ]\n\n            -- DebugUtil.renderTable(0.1, 0.85, 0.015, {{name = "currentPallet", value = self.currentObjectToSpawn.pallet.filename}})\n\n            local spawnPlaces = self.fillTypeToSpawnPlaces[ self.currentObjectToSpawn.fillType] or self.spawnPlaces\n            g_currentMission.placementManager:getPlaceAsync(spawnPlaces, self.currentObjectToSpawn.pallet.size, self.onSpawnSearchFinished, self , nil , self.spawnOffsetY, nil , nil )\n        end\n    else\n            g_currentMission:removeUpdateable( self ) -- dont update unless there are pallets to spawn\n        end\n    end\n\n'})})]})}function p(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(o,{...e})}):o(e)}},28453(e,n,l){l.d(n,{R:()=>s,x:()=>r});var i=l(96540);const a={},t=i.createContext(a);function s(e){const n=i.useContext(t);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:s(e.components),i.createElement(t.Provider,{value:n},e.children)}}}]);