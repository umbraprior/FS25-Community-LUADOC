"use strict";(globalThis.webpackChunkfs25_community_luadoc=globalThis.webpackChunkfs25_community_luadoc||[]).push([[96505],{28453(e,n,a){a.d(n,{R:()=>i,x:()=>l});var s=a(96540);const d={},r=s.createContext(d);function i(e){const n=s.useContext(r);return s.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(d):e.components||d:i(e.components),s.createElement(r.Provider,{value:n},e.children)}},52419(e,n,a){a.r(n),a.d(n,{assets:()=>o,contentTitle:()=>l,default:()=>c,frontMatter:()=>i,metadata:()=>s,toc:()=>t});const s=JSON.parse('{"id":"script/Specializations/Dashboard","title":"Dashboard","description":"Dashboard","source":"@site/../docs/script/Specializations/Dashboard.md","sourceDirName":"script/Specializations","slug":"/script/Specializations/Dashboard","permalink":"/FS25-Community-LUADOC/script/Specializations/Dashboard","draft":false,"unlisted":false,"tags":[],"version":"current","lastUpdatedAt":1767161192000,"frontMatter":{},"sidebar":"docsSidebar","previous":{"title":"CylinderedFoldable","permalink":"/FS25-Community-LUADOC/script/Specializations/CylinderedFoldable"},"next":{"title":"Dischargeable","permalink":"/FS25-Community-LUADOC/script/Specializations/Dischargeable"}}');var d=a(74848),r=a(28453);const i={},l=void 0,o={},t=[{value:"Dashboard",id:"dashboard",level:2},{value:"addDelayedRegistrationFunc",id:"adddelayedregistrationfunc",level:3},{value:"defaultDashboardStateFunc",id:"defaultdashboardstatefunc",level:3},{value:"getDashboardColor",id:"getdashboardcolor",level:3},{value:"getDashboardGroupByName",id:"getdashboardgroupbyname",level:3},{value:"getDashboardValue",id:"getdashboardvalue",level:3},{value:"getIsDashboardGroupActive",id:"getisdashboardgroupactive",level:3},{value:"initSpecialization",id:"initspecialization",level:3},{value:"loadDashboardCompoundFromExternalXML",id:"loaddashboardcompoundfromexternalxml",level:3},{value:"loadDashboardCompoundFromXML",id:"loaddashboardcompoundfromxml",level:3},{value:"loadDashboardFromXML",id:"loaddashboardfromxml",level:3},{value:"loadDashboardGroupFromXML",id:"loaddashboardgroupfromxml",level:3},{value:"loadDashboardsFromXML",id:"loaddashboardsfromxml",level:3},{value:"onDashboardCompoundLoaded",id:"ondashboardcompoundloaded",level:3},{value:"onDelete",id:"ondelete",level:3},{value:"onLoad",id:"onload",level:3},{value:"onPreInitComponentPlacement",id:"onpreinitcomponentplacement",level:3},{value:"onUpdate",id:"onupdate",level:3},{value:"onUpdateEnd",id:"onupdateend",level:3},{value:"onUpdateTick",id:"onupdatetick",level:3},{value:"prerequisitesPresent",id:"prerequisitespresent",level:3},{value:"registerDashboardValueType",id:"registerdashboardvaluetype",level:3},{value:"registerDashboardXMLPaths",id:"registerdashboardxmlpaths",level:3},{value:"registerDisplayType",id:"registerdisplaytype",level:3},{value:"registerEventListeners",id:"registereventlisteners",level:3},{value:"registerEvents",id:"registerevents",level:3},{value:"registerFunctions",id:"registerfunctions",level:3},{value:"setDashboardsDirty",id:"setdashboardsdirty",level:3},{value:"updateDashboards",id:"updatedashboards",level:3},{value:"updateDashboardValueType",id:"updatedashboardvaluetype",level:3},{value:"warningAttributes",id:"warningattributes",level:3}];function h(e){const n={a:"a",blockquote:"blockquote",code:"code",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,r.R)(),...e.components};return(0,d.jsxs)(d.Fragment,{children:[(0,d.jsx)(n.h2,{id:"dashboard",children:"Dashboard"}),"\n",(0,d.jsx)(n.p,{children:(0,d.jsx)(n.strong,{children:"Description"})}),"\n",(0,d.jsxs)(n.blockquote,{children:["\n",(0,d.jsx)(n.p,{children:"Specialization for dashboards/instrument panels with various types (number, animation, rotation, visibility, ...)"}),"\n"]}),"\n",(0,d.jsx)(n.p,{children:(0,d.jsx)(n.strong,{children:"Functions"})}),"\n",(0,d.jsxs)(n.ul,{children:["\n",(0,d.jsx)(n.li,{children:(0,d.jsx)(n.a,{href:"#adddelayedregistrationfunc",children:"addDelayedRegistrationFunc"})}),"\n",(0,d.jsx)(n.li,{children:(0,d.jsx)(n.a,{href:"#defaultdashboardstatefunc",children:"defaultDashboardStateFunc"})}),"\n",(0,d.jsx)(n.li,{children:(0,d.jsx)(n.a,{href:"#getdashboardcolor",children:"getDashboardColor"})}),"\n",(0,d.jsx)(n.li,{children:(0,d.jsx)(n.a,{href:"#getdashboardgroupbyname",children:"getDashboardGroupByName"})}),"\n",(0,d.jsx)(n.li,{children:(0,d.jsx)(n.a,{href:"#getdashboardvalue",children:"getDashboardValue"})}),"\n",(0,d.jsx)(n.li,{children:(0,d.jsx)(n.a,{href:"#getisdashboardgroupactive",children:"getIsDashboardGroupActive"})}),"\n",(0,d.jsx)(n.li,{children:(0,d.jsx)(n.a,{href:"#initspecialization",children:"initSpecialization"})}),"\n",(0,d.jsx)(n.li,{children:(0,d.jsx)(n.a,{href:"#loaddashboardcompoundfromexternalxml",children:"loadDashboardCompoundFromExternalXML"})}),"\n",(0,d.jsx)(n.li,{children:(0,d.jsx)(n.a,{href:"#loaddashboardcompoundfromxml",children:"loadDashboardCompoundFromXML"})}),"\n",(0,d.jsx)(n.li,{children:(0,d.jsx)(n.a,{href:"#loaddashboardfromxml",children:"loadDashboardFromXML"})}),"\n",(0,d.jsx)(n.li,{children:(0,d.jsx)(n.a,{href:"#loaddashboardgroupfromxml",children:"loadDashboardGroupFromXML"})}),"\n",(0,d.jsx)(n.li,{children:(0,d.jsx)(n.a,{href:"#loaddashboardsfromxml",children:"loadDashboardsFromXML"})}),"\n",(0,d.jsx)(n.li,{children:(0,d.jsx)(n.a,{href:"#ondashboardcompoundloaded",children:"onDashboardCompoundLoaded"})}),"\n",(0,d.jsx)(n.li,{children:(0,d.jsx)(n.a,{href:"#ondelete",children:"onDelete"})}),"\n",(0,d.jsx)(n.li,{children:(0,d.jsx)(n.a,{href:"#onload",children:"onLoad"})}),"\n",(0,d.jsx)(n.li,{children:(0,d.jsx)(n.a,{href:"#onpreinitcomponentplacement",children:"onPreInitComponentPlacement"})}),"\n",(0,d.jsx)(n.li,{children:(0,d.jsx)(n.a,{href:"#onupdate",children:"onUpdate"})}),"\n",(0,d.jsx)(n.li,{children:(0,d.jsx)(n.a,{href:"#onupdateend",children:"onUpdateEnd"})}),"\n",(0,d.jsx)(n.li,{children:(0,d.jsx)(n.a,{href:"#onupdatetick",children:"onUpdateTick"})}),"\n",(0,d.jsx)(n.li,{children:(0,d.jsx)(n.a,{href:"#prerequisitespresent",children:"prerequisitesPresent"})}),"\n",(0,d.jsx)(n.li,{children:(0,d.jsx)(n.a,{href:"#registerdashboardvaluetype",children:"registerDashboardValueType"})}),"\n",(0,d.jsx)(n.li,{children:(0,d.jsx)(n.a,{href:"#registerdashboardxmlpaths",children:"registerDashboardXMLPaths"})}),"\n",(0,d.jsx)(n.li,{children:(0,d.jsx)(n.a,{href:"#registerdisplaytype",children:"registerDisplayType"})}),"\n",(0,d.jsx)(n.li,{children:(0,d.jsx)(n.a,{href:"#registereventlisteners",children:"registerEventListeners"})}),"\n",(0,d.jsx)(n.li,{children:(0,d.jsx)(n.a,{href:"#registerevents",children:"registerEvents"})}),"\n",(0,d.jsx)(n.li,{children:(0,d.jsx)(n.a,{href:"#registerfunctions",children:"registerFunctions"})}),"\n",(0,d.jsx)(n.li,{children:(0,d.jsx)(n.a,{href:"#setdashboardsdirty",children:"setDashboardsDirty"})}),"\n",(0,d.jsx)(n.li,{children:(0,d.jsx)(n.a,{href:"#updatedashboards",children:"updateDashboards"})}),"\n",(0,d.jsx)(n.li,{children:(0,d.jsx)(n.a,{href:"#updatedashboardvaluetype",children:"updateDashboardValueType"})}),"\n",(0,d.jsx)(n.li,{children:(0,d.jsx)(n.a,{href:"#warningattributes",children:"warningAttributes"})}),"\n"]}),"\n",(0,d.jsx)(n.h3,{id:"adddelayedregistrationfunc",children:"addDelayedRegistrationFunc"}),"\n",(0,d.jsx)(n.p,{children:(0,d.jsx)(n.strong,{children:"Description"})}),"\n",(0,d.jsx)(n.p,{children:(0,d.jsx)(n.strong,{children:"Definition"})}),"\n",(0,d.jsxs)(n.blockquote,{children:["\n",(0,d.jsx)(n.p,{children:"addDelayedRegistrationFunc()"}),"\n"]}),"\n",(0,d.jsx)(n.p,{children:(0,d.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,d.jsxs)(n.table,{children:[(0,d.jsx)(n.thead,{children:(0,d.jsxs)(n.tr,{children:[(0,d.jsx)(n.th,{children:"any"}),(0,d.jsx)(n.th,{children:"schema"})]})}),(0,d.jsx)(n.tbody,{children:(0,d.jsxs)(n.tr,{children:[(0,d.jsx)(n.td,{children:"any"}),(0,d.jsx)(n.td,{children:"func"})]})})]}),"\n",(0,d.jsx)(n.p,{children:(0,d.jsx)(n.strong,{children:"Code"})}),"\n",(0,d.jsx)(n.pre,{children:(0,d.jsx)(n.code,{className:"language-lua",children:'function Dashboard.addDelayedRegistrationFunc(schema, func)\n    schema:addDelayedRegistrationFunc( "Dashboard" , func)\n\n    if Dashboard.compoundsXMLSchema = = nil then\n        Dashboard.compoundsXMLSchema = XMLSchema.new( "dashboardCompounds" )\n    end\n\n    Dashboard.compoundsXMLSchema:addDelayedRegistrationFunc( "Dashboard" , func)\nend\n\n'})}),"\n",(0,d.jsx)(n.h3,{id:"defaultdashboardstatefunc",children:"defaultDashboardStateFunc"}),"\n",(0,d.jsx)(n.p,{children:(0,d.jsx)(n.strong,{children:"Description"})}),"\n",(0,d.jsx)(n.p,{children:(0,d.jsx)(n.strong,{children:"Definition"})}),"\n",(0,d.jsxs)(n.blockquote,{children:["\n",(0,d.jsx)(n.p,{children:"defaultDashboardStateFunc()"}),"\n"]}),"\n",(0,d.jsx)(n.p,{children:(0,d.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,d.jsxs)(n.table,{children:[(0,d.jsx)(n.thead,{children:(0,d.jsxs)(n.tr,{children:[(0,d.jsx)(n.th,{children:"any"}),(0,d.jsx)(n.th,{children:"dashboard"})]})}),(0,d.jsxs)(n.tbody,{children:[(0,d.jsxs)(n.tr,{children:[(0,d.jsx)(n.td,{children:"any"}),(0,d.jsx)(n.td,{children:"newValue"})]}),(0,d.jsxs)(n.tr,{children:[(0,d.jsx)(n.td,{children:"any"}),(0,d.jsx)(n.td,{children:"minValue"})]}),(0,d.jsxs)(n.tr,{children:[(0,d.jsx)(n.td,{children:"any"}),(0,d.jsx)(n.td,{children:"maxValue"})]}),(0,d.jsxs)(n.tr,{children:[(0,d.jsx)(n.td,{children:"any"}),(0,d.jsx)(n.td,{children:"isActive"})]})]})]}),"\n",(0,d.jsx)(n.p,{children:(0,d.jsx)(n.strong,{children:"Code"})}),"\n",(0,d.jsx)(n.pre,{children:(0,d.jsx)(n.code,{className:"language-lua",children:"function Dashboard:defaultDashboardStateFunc(dashboard, newValue, minValue, maxValue, isActive)\n    local typeData = Dashboard.TYPE_DATA[dashboard.displayTypeIndex]\n    typeData.updateFunc( self , dashboard, newValue, minValue, maxValue, isActive)\nend\n\n"})}),"\n",(0,d.jsx)(n.h3,{id:"getdashboardcolor",children:"getDashboardColor"}),"\n",(0,d.jsx)(n.p,{children:(0,d.jsx)(n.strong,{children:"Description"})}),"\n",(0,d.jsx)(n.p,{children:(0,d.jsx)(n.strong,{children:"Definition"})}),"\n",(0,d.jsxs)(n.blockquote,{children:["\n",(0,d.jsx)(n.p,{children:"getDashboardColor()"}),"\n"]}),"\n",(0,d.jsx)(n.p,{children:(0,d.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,d.jsxs)(n.table,{children:[(0,d.jsx)(n.thead,{children:(0,d.jsxs)(n.tr,{children:[(0,d.jsx)(n.th,{children:"any"}),(0,d.jsx)(n.th,{children:"xmlFile"})]})}),(0,d.jsxs)(n.tbody,{children:[(0,d.jsxs)(n.tr,{children:[(0,d.jsx)(n.td,{children:"any"}),(0,d.jsx)(n.td,{children:"colorStr"})]}),(0,d.jsxs)(n.tr,{children:[(0,d.jsx)(n.td,{children:"any"}),(0,d.jsx)(n.td,{children:"customEnvironment"})]})]})]}),"\n",(0,d.jsx)(n.p,{children:(0,d.jsx)(n.strong,{children:"Code"})}),"\n",(0,d.jsx)(n.pre,{children:(0,d.jsx)(n.code,{className:"language-lua",children:"function Dashboard.getDashboardColor(xmlFile, colorStr, customEnvironment)\n    if colorStr = = nil then\n        return nil\n    end\n\n    if Dashboard.COLORS[ string.upper(colorStr)] ~ = nil then\n        return Dashboard.COLORS[ string.upper(colorStr)]\n    end\n\n    local brandColor = g_vehicleMaterialManager:getMaterialTemplateColorByName(colorStr, customEnvironment)\n    if brandColor ~ = nil then\n        return brandColor\n    end\n\n    local vector = string.getVector(colorStr)\n    if vector ~ = nil and #vector > = 3 then\n        if #vector = = 3 then\n            vector[ 4 ] = 1\n        end\n\n        return vector\n    end\n\n    Logging.xmlWarning(xmlFile, \"Unable to resolve color '%s'\" , colorStr)\n\n    return nil\nend\n\n"})}),"\n",(0,d.jsx)(n.h3,{id:"getdashboardgroupbyname",children:"getDashboardGroupByName"}),"\n",(0,d.jsx)(n.p,{children:(0,d.jsx)(n.strong,{children:"Description"})}),"\n",(0,d.jsx)(n.p,{children:(0,d.jsx)(n.strong,{children:"Definition"})}),"\n",(0,d.jsxs)(n.blockquote,{children:["\n",(0,d.jsx)(n.p,{children:"getDashboardGroupByName()"}),"\n"]}),"\n",(0,d.jsx)(n.p,{children:(0,d.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,d.jsx)(n.table,{children:(0,d.jsx)(n.thead,{children:(0,d.jsxs)(n.tr,{children:[(0,d.jsx)(n.th,{children:"any"}),(0,d.jsx)(n.th,{children:"name"})]})})}),"\n",(0,d.jsx)(n.p,{children:(0,d.jsx)(n.strong,{children:"Code"})}),"\n",(0,d.jsx)(n.pre,{children:(0,d.jsx)(n.code,{className:"language-lua",children:"function Dashboard:getDashboardGroupByName(name)\n    return self.spec_dashboard.groups[name]\nend\n\n"})}),"\n",(0,d.jsx)(n.h3,{id:"getdashboardvalue",children:"getDashboardValue"}),"\n",(0,d.jsx)(n.p,{children:(0,d.jsx)(n.strong,{children:"Description"})}),"\n",(0,d.jsx)(n.p,{children:(0,d.jsx)(n.strong,{children:"Definition"})}),"\n",(0,d.jsxs)(n.blockquote,{children:["\n",(0,d.jsx)(n.p,{children:"getDashboardValue()"}),"\n"]}),"\n",(0,d.jsx)(n.p,{children:(0,d.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,d.jsxs)(n.table,{children:[(0,d.jsx)(n.thead,{children:(0,d.jsxs)(n.tr,{children:[(0,d.jsx)(n.th,{children:"any"}),(0,d.jsx)(n.th,{children:"valueObject"})]})}),(0,d.jsxs)(n.tbody,{children:[(0,d.jsxs)(n.tr,{children:[(0,d.jsx)(n.td,{children:"any"}),(0,d.jsx)(n.td,{children:"valueFunc"})]}),(0,d.jsxs)(n.tr,{children:[(0,d.jsx)(n.td,{children:"any"}),(0,d.jsx)(n.td,{children:"dashboard"})]})]})]}),"\n",(0,d.jsx)(n.p,{children:(0,d.jsx)(n.strong,{children:"Code"})}),"\n",(0,d.jsx)(n.pre,{children:(0,d.jsx)(n.code,{className:"language-lua",children:'function Dashboard:getDashboardValue(valueObject, valueFunc, dashboard)\n    if type(valueFunc) = = "number" or type(valueFunc) = = "boolean" then\n        return valueFunc\n    elseif type(valueFunc) = = "function" then\n            return valueFunc(valueObject, dashboard)\n        end\n\n        local object = valueObject[valueFunc]\n        if type(object) = = "function" then\n            return valueObject[valueFunc](valueObject, dashboard)\n        elseif type(object) = = "number" or type(object) = = "boolean" then\n                return object\n            end\n\n            return nil\n        end\n\n'})}),"\n",(0,d.jsx)(n.h3,{id:"getisdashboardgroupactive",children:"getIsDashboardGroupActive"}),"\n",(0,d.jsx)(n.p,{children:(0,d.jsx)(n.strong,{children:"Description"})}),"\n",(0,d.jsx)(n.p,{children:(0,d.jsx)(n.strong,{children:"Definition"})}),"\n",(0,d.jsxs)(n.blockquote,{children:["\n",(0,d.jsx)(n.p,{children:"getIsDashboardGroupActive()"}),"\n"]}),"\n",(0,d.jsx)(n.p,{children:(0,d.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,d.jsx)(n.table,{children:(0,d.jsx)(n.thead,{children:(0,d.jsxs)(n.tr,{children:[(0,d.jsx)(n.th,{children:"any"}),(0,d.jsx)(n.th,{children:"group"})]})})}),"\n",(0,d.jsx)(n.p,{children:(0,d.jsx)(n.strong,{children:"Code"})}),"\n",(0,d.jsx)(n.pre,{children:(0,d.jsx)(n.code,{className:"language-lua",children:"function Dashboard:getIsDashboardGroupActive(group)\n    return true\nend\n\n"})}),"\n",(0,d.jsx)(n.h3,{id:"initspecialization",children:"initSpecialization"}),"\n",(0,d.jsx)(n.p,{children:(0,d.jsx)(n.strong,{children:"Description"})}),"\n",(0,d.jsx)(n.p,{children:(0,d.jsx)(n.strong,{children:"Definition"})}),"\n",(0,d.jsxs)(n.blockquote,{children:["\n",(0,d.jsx)(n.p,{children:"initSpecialization()"}),"\n"]}),"\n",(0,d.jsx)(n.p,{children:(0,d.jsx)(n.strong,{children:"Code"})}),"\n",(0,d.jsx)(n.pre,{children:(0,d.jsx)(n.code,{className:"language-lua",children:'function Dashboard.initSpecialization()\n    local schema = Vehicle.xmlSchema\n    schema:setXMLSpecializationType( "Dashboard" )\n\n    Dashboard.registerDashboardXMLPaths(schema, "vehicle.dashboard.default" )\n    schema:register(XMLValueType.STRING, Dashboard.GROUP_XML_KEY .. "#name" , "Dashboard group name" )\n\n    schema:register(XMLValueType.FLOAT, "vehicle.dashboard#maxUpdateDistance" , "Max.distance to vehicle root to update connection hoses" , Dashboard.DEFAULT_MAX_UPDATE_DISTANCE)\n    schema:register(XMLValueType.FLOAT, "vehicle.dashboard#maxUpdateDistanceCritical" , "Max.distance to vehicle root to update critical connection hoses(All with type \'ROT\')" , Dashboard.DEFAULT_MAX_UPDATE_DISTANCE_CRITICAL)\n    schema:register(XMLValueType.TIME, "vehicle.dashboard#tickIntervall" , "If defined the low priority dashboard will get updated at this interval(otherwise every second frame)" )\n\n    schema:register(XMLValueType.NODE_INDEX, "vehicle.dashboard.compounds.compound(?)#linkNode" , "Link node for dashboard compound" )\n        schema:register(XMLValueType.STRING, "vehicle.dashboard.compounds.compound(?)#filename" , "Path to compound xml file" )\n        schema:register(XMLValueType.STRING, "vehicle.dashboard.compounds.compound(?)#name" , "Name of dashboard compound to load" )\n        schema:register(XMLValueType.STRING_LIST, "vehicle.dashboard.compounds.compound(?)#configIds" , "Configuration identifiers(the given configuations will be enabled, separated by whitespace)" )\n        schema:register(XMLValueType.STRING, "vehicle.dashboard.compounds.compound(?).configurationDependency(?)#configName" , "Name of the vehicle config" )\n        schema:register(XMLValueType.INT, "vehicle.dashboard.compounds.compound(?).configurationDependency(?)#configIndex" , "Index of the vehicle config" )\n        schema:register(XMLValueType.BOOL, "vehicle.dashboard.compounds.compound(?).configurationDependency(?)#useCompound" , "Use dashboard compound only when the defined configuration is set" , false )\n        schema:register(XMLValueType.STRING_LIST, "vehicle.dashboard.compounds.compound(?).configurationDependency(?)#additionalConfigIds" , "Dashboard config ids to be used when this vehicle config is active" )\n        schema:register(XMLValueType.STRING_LIST, "vehicle.dashboard.compounds.compound(?).configurationDependency(?)#disabledConfigIds" , "Dashboard config ids to be used when this vehicle config is active" )\n\n        schema:setXMLSpecializationType()\n\n        if Dashboard.compoundsXMLSchema = = nil then\n            Dashboard.compoundsXMLSchema = XMLSchema.new( "dashboardCompounds" )\n        end\n\n        Dashboard.compoundsXMLSchema:register(XMLValueType.NODE_INDEX, "dashboardCompounds.dashboardCompound(?)#node" , "Root node in i3d file to load" )\n        Dashboard.compoundsXMLSchema:register(XMLValueType.STRING, "dashboardCompounds.dashboardCompound(?)#filename" , "Path to i3d file" )\n        Dashboard.compoundsXMLSchema:register(XMLValueType.STRING, "dashboardCompounds.dashboardCompound(?)#name" , "Name of dashboard compound" )\n        I3DUtil.registerI3dMappingXMLPaths( Dashboard.compoundsXMLSchema, "dashboardCompounds" )\n        Dashboard.registerDashboardXMLPaths( Dashboard.compoundsXMLSchema, "dashboardCompounds.dashboardCompound(?)" )\n\n        Dashboard.compoundsXMLSchema:register(XMLValueType.STRING, "dashboardCompounds.dashboardCompound(?).configuration(?)#id" , "Identifier of the configuration" )\n        Dashboard.registerDashboardXMLPaths( Dashboard.compoundsXMLSchema, "dashboardCompounds.dashboardCompound(?).configuration(?)" )\n        ObjectChangeUtil.registerObjectChangeXMLPaths( Dashboard.compoundsXMLSchema, "dashboardCompounds.dashboardCompound(?).configuration(?)" )\n    end\n\n'})}),"\n",(0,d.jsx)(n.h3,{id:"loaddashboardcompoundfromexternalxml",children:"loadDashboardCompoundFromExternalXML"}),"\n",(0,d.jsx)(n.p,{children:(0,d.jsx)(n.strong,{children:"Description"})}),"\n",(0,d.jsx)(n.p,{children:(0,d.jsx)(n.strong,{children:"Definition"})}),"\n",(0,d.jsxs)(n.blockquote,{children:["\n",(0,d.jsx)(n.p,{children:"loadDashboardCompoundFromExternalXML()"}),"\n"]}),"\n",(0,d.jsx)(n.p,{children:(0,d.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,d.jsxs)(n.table,{children:[(0,d.jsx)(n.thead,{children:(0,d.jsxs)(n.tr,{children:[(0,d.jsx)(n.th,{children:"any"}),(0,d.jsx)(n.th,{children:"dashboardXMLFile"})]})}),(0,d.jsxs)(n.tbody,{children:[(0,d.jsxs)(n.tr,{children:[(0,d.jsx)(n.td,{children:"any"}),(0,d.jsx)(n.td,{children:"compound"})]}),(0,d.jsxs)(n.tr,{children:[(0,d.jsx)(n.td,{children:"any"}),(0,d.jsx)(n.td,{children:"compoundKey"})]}),(0,d.jsxs)(n.tr,{children:[(0,d.jsx)(n.td,{children:"any"}),(0,d.jsx)(n.td,{children:"components"})]})]})]}),"\n",(0,d.jsx)(n.p,{children:(0,d.jsx)(n.strong,{children:"Code"})}),"\n",(0,d.jsx)(n.pre,{children:(0,d.jsx)(n.code,{className:"language-lua",children:'function Dashboard:loadDashboardCompoundFromExternalXML(dashboardXMLFile, compound, compoundKey, components)\n    local node = dashboardXMLFile:getValue(compoundKey .. "#node" , nil , components, compound.i3dMappings)\n    if node ~ = nil then\n        link(compound.linkNode, node)\n        setTranslation(node, 0 , 0 , 0 )\n        setRotation(node, 0 , 0 , 0 )\n\n        self:loadDashboardsFromXML(dashboardXMLFile, compoundKey, nil , components, compound.i3dMappings, node)\n\n        for _, configKey in dashboardXMLFile:iterator(compoundKey .. ".configuration" ) do\n            local isActive = false\n            local id = dashboardXMLFile:getValue(configKey .. "#id" )\n            if id ~ = nil and compound.configIds ~ = nil then\n                for _, _id in ipairs(compound.configIds) do\n                    if string.lower(id) = = string.lower(_id) then\n                        isActive = true\n                    end\n                end\n            end\n\n            local objects = { }\n            ObjectChangeUtil.loadObjectChangeFromXML(dashboardXMLFile, configKey, objects, components, compound)\n            ObjectChangeUtil.setObjectChanges(objects, isActive, compound)\n\n            if isActive then\n                self:loadDashboardsFromXML(dashboardXMLFile, configKey, nil , components, compound.i3dMappings, node)\n            end\n        end\n    else\n            Logging.xmlWarning(dashboardXMLFile, "Unable to find node for compound at \'%s\'" , compoundKey)\n                return false\n            end\n\n            return true\n        end\n\n'})}),"\n",(0,d.jsx)(n.h3,{id:"loaddashboardcompoundfromxml",children:"loadDashboardCompoundFromXML"}),"\n",(0,d.jsx)(n.p,{children:(0,d.jsx)(n.strong,{children:"Description"})}),"\n",(0,d.jsx)(n.p,{children:(0,d.jsx)(n.strong,{children:"Definition"})}),"\n",(0,d.jsxs)(n.blockquote,{children:["\n",(0,d.jsx)(n.p,{children:"loadDashboardCompoundFromXML()"}),"\n"]}),"\n",(0,d.jsx)(n.p,{children:(0,d.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,d.jsxs)(n.table,{children:[(0,d.jsx)(n.thead,{children:(0,d.jsxs)(n.tr,{children:[(0,d.jsx)(n.th,{children:"any"}),(0,d.jsx)(n.th,{children:"xmlFile"})]})}),(0,d.jsxs)(n.tbody,{children:[(0,d.jsxs)(n.tr,{children:[(0,d.jsx)(n.td,{children:"any"}),(0,d.jsx)(n.td,{children:"key"})]}),(0,d.jsxs)(n.tr,{children:[(0,d.jsx)(n.td,{children:"any"}),(0,d.jsx)(n.td,{children:"compound"})]})]})]}),"\n",(0,d.jsx)(n.p,{children:(0,d.jsx)(n.strong,{children:"Code"})}),"\n",(0,d.jsx)(n.pre,{children:(0,d.jsx)(n.code,{className:"language-lua",children:'function Dashboard:loadDashboardCompoundFromXML(xmlFile, key, compound)\n    compound.linkNode = xmlFile:getValue(key .. "#linkNode" , nil , self.components, self.i3dMappings)\n    if compound.linkNode = = nil then\n        return false\n    end\n\n    compound.filename = xmlFile:getValue(key .. "#filename" )\n    if compound.filename ~ = nil then\n        compound.filename = Utils.getFilename(compound.filename, self.baseDirectory)\n    else\n            return false\n        end\n\n        if compound.filename ~ = nil then\n            compound.name = xmlFile:getValue(key .. "#name" )\n\n            compound.configIds = xmlFile:getValue(key .. "#configIds" , nil , true )\n\n            local isAllowed = true\n            for _, configDependencyKey in xmlFile:iterator(key .. ".configurationDependency" ) do\n                local configName = xmlFile:getValue(configDependencyKey .. "#configName" )\n                local configIndex = xmlFile:getValue(configDependencyKey .. "#configIndex" )\n                if configName ~ = nil and configIndex ~ = nil then\n                    if self.configurations[configName] = = configIndex then\n                        local configIds = xmlFile:getValue(configDependencyKey .. "#additionalConfigIds" , nil , true )\n                        if configIds ~ = nil then\n                            for _, _configId in ipairs(configIds) do\n                                table.insert(compound.configIds, _configId)\n                            end\n                        end\n\n                        configIds = xmlFile:getValue(configDependencyKey .. "#disabledConfigIds" , nil , true )\n                        if configIds ~ = nil then\n                            for _, _configId in ipairs(configIds) do\n                                for i = #compound.configIds, 1 , - 1 do\n                                    if compound.configIds[i] = = _configId then\n                                        table.remove(compound.configIds, i)\n                                    end\n                                end\n                            end\n                        end\n                    else\n                            local useCompound = xmlFile:getValue(configDependencyKey .. "#useCompound" , false )\n                            if useCompound then\n                                isAllowed = false\n                            end\n                        end\n                    end\n                end\n\n                if compound.name ~ = nil then\n                    if isAllowed then\n                        local dashboardXMLFile = XMLFile.load( "dashboardCompoundsXML" , compound.filename, Dashboard.compoundsXMLSchema)\n                        if dashboardXMLFile ~ = nil then\n                            local compoundKey\n                            dashboardXMLFile:iterate( "dashboardCompounds.dashboardCompound" , function (index, _compoundKey)\n                                if dashboardXMLFile:getValue(_compoundKey .. "#name" ) = = compound.name then\n                                    compoundKey = _compoundKey\n                                    return\n                                end\n                            end )\n\n                            if compoundKey ~ = nil then\n                                local i3dFilename = dashboardXMLFile:getValue(compoundKey .. "#filename" )\n                                if i3dFilename ~ = nil then\n                                    i3dFilename = Utils.getFilename(i3dFilename, self.baseDirectory)\n                                end\n\n                                if i3dFilename = = nil then\n                                    Logging.xmlWarning(dashboardXMLFile, "Missing filename for compound \'%s\'" , compound.name)\n                                        return false\n                                    end\n\n                                    local arguments = {\n                                    dashboardXMLFile = dashboardXMLFile,\n                                    compound = compound,\n                                    compoundKey = compoundKey,\n                                    }\n                                    local sharedLoadRequestId = self:loadSubSharedI3DFile(i3dFilename, false , false , self.onDashboardCompoundLoaded, self , arguments)\n                                    table.insert( self.spec_dashboard.sharedLoadRequestIds, sharedLoadRequestId)\n                                    return true\n                                else\n                                        Logging.xmlWarning(dashboardXMLFile, "Unable to find compound by name \'%s\'" , compound.name)\n                                        dashboardXMLFile:delete()\n                                        return false\n                                    end\n                                end\n                            end\n                        else\n                                Logging.xmlWarning(xmlFile, "Missing name in \'%s\'" , key)\n                                return false\n                            end\n                        end\n\n                        return false\n                    end\n\n'})}),"\n",(0,d.jsx)(n.h3,{id:"loaddashboardfromxml",children:"loadDashboardFromXML"}),"\n",(0,d.jsx)(n.p,{children:(0,d.jsx)(n.strong,{children:"Description"})}),"\n",(0,d.jsx)(n.p,{children:(0,d.jsx)(n.strong,{children:"Definition"})}),"\n",(0,d.jsxs)(n.blockquote,{children:["\n",(0,d.jsx)(n.p,{children:"loadDashboardFromXML()"}),"\n"]}),"\n",(0,d.jsx)(n.p,{children:(0,d.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,d.jsxs)(n.table,{children:[(0,d.jsx)(n.thead,{children:(0,d.jsxs)(n.tr,{children:[(0,d.jsx)(n.th,{children:"any"}),(0,d.jsx)(n.th,{children:"xmlFile"})]})}),(0,d.jsxs)(n.tbody,{children:[(0,d.jsxs)(n.tr,{children:[(0,d.jsx)(n.td,{children:"any"}),(0,d.jsx)(n.td,{children:"key"})]}),(0,d.jsxs)(n.tr,{children:[(0,d.jsx)(n.td,{children:"any"}),(0,d.jsx)(n.td,{children:"dashboard"})]}),(0,d.jsxs)(n.tr,{children:[(0,d.jsx)(n.td,{children:"any"}),(0,d.jsx)(n.td,{children:"valueType"})]}),(0,d.jsxs)(n.tr,{children:[(0,d.jsx)(n.td,{children:"any"}),(0,d.jsx)(n.td,{children:"components"})]}),(0,d.jsxs)(n.tr,{children:[(0,d.jsx)(n.td,{children:"any"}),(0,d.jsx)(n.td,{children:"i3dMappings"})]}),(0,d.jsxs)(n.tr,{children:[(0,d.jsx)(n.td,{children:"any"}),(0,d.jsx)(n.td,{children:"parentNode"})]})]})]}),"\n",(0,d.jsx)(n.p,{children:(0,d.jsx)(n.strong,{children:"Code"})}),"\n",(0,d.jsx)(n.pre,{children:(0,d.jsx)(n.code,{className:"language-lua",children:'function Dashboard:loadDashboardFromXML(xmlFile, key, dashboard, valueType, components, i3dMappings, parentNode)\n    dashboard.valueType = valueType\n\n    if valueType ~ = nil then\n        if valueType.isa = = nil or not valueType:isa( DashboardValueType ) then\n            Logging.error( "Deprecated call of Dashboard:loadDashboardFromXML.Needs to be called with DashboardValueType object or nil." )\n            printCallstack()\n            return false\n        end\n\n        local valueTypeName = xmlFile:getValue(key .. "#valueType" )\n        if valueTypeName ~ = dashboard.valueType.name and valueTypeName ~ = dashboard.valueType.fullName then\n            return false\n        end\n    end\n\n    local displayType = xmlFile:getValue(key .. "#displayType" )\n    if displayType ~ = nil then\n        local displayTypeIndex = Dashboard.TYPES[ string.upper(displayType)]\n\n        if displayTypeIndex ~ = nil then\n            dashboard.displayTypeIndex = displayTypeIndex\n        else\n                Logging.xmlWarning(xmlFile, "Unknown displayType \'%s\' for dashboard \'%s\'" , displayType, key)\n                    return false\n                end\n            else\n                    Logging.xmlWarning(xmlFile, "Missing displayType for dashboard \'%s\'" , key)\n                        return false\n                    end\n\n                    dashboard.doInterpolation = xmlFile:getValue(key .. "#doInterpolation" , false )\n                    dashboard.isCritical = xmlFile:getValue(key .. "#isCritical" )\n                    dashboard.useStateChange = xmlFile:getValue(key .. "#useStateChange" , false )\n                    if dashboard.useStateChange then\n                        dashboard.stateChangeValue = xmlFile:getValue(key .. "#stateChangeValue" )\n                        dashboard.stateChangeTime = xmlFile:getValue(key .. "#stateChangeTime" , 0.2 )\n                        dashboard.stateChangeLastValue = nil\n                        dashboard.stateChangeEndTime = - math.huge\n                    end\n                    dashboard.idleValue = xmlFile:getValue(key .. "#idleValue" , (valueType ~ = nil and valueType.idleValue or 0 ) or 0 )\n                    dashboard.lastInterpolationValue = dashboard.idleValue\n                    dashboard.offsetValue = xmlFile:getValue(key .. "#offsetValue" )\n                    dashboard.scaleFactor = xmlFile:getValue(key .. "#scaleFactor" )\n\n                    dashboard.minActiveValue = xmlFile:getValue(key .. "#minActiveValue" )\n                    dashboard.maxActiveValue = xmlFile:getValue(key .. "#maxActiveValue" )\n\n                    if xmlFile:hasProperty(key .. ".valueMapping" ) then\n                        dashboard.valueMapping = AnimCurve.new(linearInterpolator1)\n                        for _, valueMappingKey in xmlFile:iterator(key .. ".valueMapping" ) do\n                            local sourceValue = xmlFile:getValue(valueMappingKey .. "#sourceValue" )\n                            local dashboardValue = xmlFile:getValue(valueMappingKey .. "#dashboardValue" )\n                            if sourceValue ~ = nil and dashboardValue ~ = nil then\n                                dashboard.valueMapping:addKeyframe( { dashboardValue, time = sourceValue } )\n                            end\n                        end\n\n                        if dashboard.valueMapping.numKeyframes = = 0 then\n                            dashboard.valueMapping = nil\n                        end\n                    end\n\n                    dashboard.groups = { }\n                    local groupsStr = xmlFile:getValue(key .. "#groups" )\n                    if groupsStr ~ = nil then\n                        local groups = string.split(groupsStr, " " )\n                        for _, name in ipairs(groups) do\n                            local group = self:getDashboardGroupByName(name)\n                            if group ~ = nil then\n                                table.insert(dashboard.groups, group)\n                            else\n                                    Logging.xmlWarning(xmlFile, "Unable to find dashboard group \'%s\' for dashboard \'%s\'" , name, key)\n                                    end\n                                end\n                            end\n\n                            if valueType ~ = nil and valueType.stateFunction ~ = nil then\n                                dashboard.stateFunc = valueType.stateFunction\n                            else\n                                    dashboard.stateFunc = Dashboard.defaultDashboardStateFunc\n                                end\n\n                                local interpolationSpeed\n                                if valueType ~ = nil then\n                                    interpolationSpeed = valueType:getInterpolationSpeed(dashboard)\n                                end\n                                dashboard.interpolationSpeed = xmlFile:getValue(key .. "#interpolationSpeed" , interpolationSpeed or 0.005 )\n\n                                local typeData = Dashboard.TYPE_DATA[dashboard.displayTypeIndex]\n                                if typeData ~ = nil then\n                                    if not typeData.loadFunc( self , xmlFile, key, dashboard, components, i3dMappings, parentNode) then\n                                        return false\n                                    end\n                                else\n                                        return false\n                                    end\n\n                                    if valueType ~ = nil and valueType.loadFunction ~ = nil then\n                                        if not valueType.loadFunction( self , xmlFile, key, dashboard, components, i3dMappings, parentNode) then\n                                            return false\n                                        end\n                                    end\n\n                                    dashboard.lastValue = nil\n\n                                    return true\n                                end\n\n'})}),"\n",(0,d.jsx)(n.h3,{id:"loaddashboardgroupfromxml",children:"loadDashboardGroupFromXML"}),"\n",(0,d.jsx)(n.p,{children:(0,d.jsx)(n.strong,{children:"Description"})}),"\n",(0,d.jsx)(n.p,{children:(0,d.jsx)(n.strong,{children:"Definition"})}),"\n",(0,d.jsxs)(n.blockquote,{children:["\n",(0,d.jsx)(n.p,{children:"loadDashboardGroupFromXML()"}),"\n"]}),"\n",(0,d.jsx)(n.p,{children:(0,d.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,d.jsxs)(n.table,{children:[(0,d.jsx)(n.thead,{children:(0,d.jsxs)(n.tr,{children:[(0,d.jsx)(n.th,{children:"any"}),(0,d.jsx)(n.th,{children:"xmlFile"})]})}),(0,d.jsxs)(n.tbody,{children:[(0,d.jsxs)(n.tr,{children:[(0,d.jsx)(n.td,{children:"any"}),(0,d.jsx)(n.td,{children:"key"})]}),(0,d.jsxs)(n.tr,{children:[(0,d.jsx)(n.td,{children:"any"}),(0,d.jsx)(n.td,{children:"group"})]})]})]}),"\n",(0,d.jsx)(n.p,{children:(0,d.jsx)(n.strong,{children:"Code"})}),"\n",(0,d.jsx)(n.pre,{children:(0,d.jsx)(n.code,{className:"language-lua",children:"function Dashboard:loadDashboardGroupFromXML(xmlFile, key, group)\n    group.name = xmlFile:getValue(key .. \"#name\" )\n    if group.name = = nil then\n        Logging.xmlWarning( self.xmlFile, \"Missing name for dashboard group '%s'\" , key)\n            return false\n        end\n\n        if self:getDashboardGroupByName(group.name) ~ = nil then\n            Logging.xmlWarning( self.xmlFile, \"Duplicated dashboard group name '%s' for group '%s'\" , group.name, key)\n                return false\n            end\n\n            group.isActive = false\n\n            return true\n        end\n\n"})}),"\n",(0,d.jsx)(n.h3,{id:"loaddashboardsfromxml",children:"loadDashboardsFromXML"}),"\n",(0,d.jsx)(n.p,{children:(0,d.jsx)(n.strong,{children:"Description"})}),"\n",(0,d.jsx)(n.p,{children:(0,d.jsx)(n.strong,{children:"Definition"})}),"\n",(0,d.jsxs)(n.blockquote,{children:["\n",(0,d.jsx)(n.p,{children:"loadDashboardsFromXML()"}),"\n"]}),"\n",(0,d.jsx)(n.p,{children:(0,d.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,d.jsxs)(n.table,{children:[(0,d.jsx)(n.thead,{children:(0,d.jsxs)(n.tr,{children:[(0,d.jsx)(n.th,{children:"any"}),(0,d.jsx)(n.th,{children:"xmlFile"})]})}),(0,d.jsxs)(n.tbody,{children:[(0,d.jsxs)(n.tr,{children:[(0,d.jsx)(n.td,{children:"any"}),(0,d.jsx)(n.td,{children:"key"})]}),(0,d.jsxs)(n.tr,{children:[(0,d.jsx)(n.td,{children:"any"}),(0,d.jsx)(n.td,{children:"dashboardValueType"})]}),(0,d.jsxs)(n.tr,{children:[(0,d.jsx)(n.td,{children:"any"}),(0,d.jsx)(n.td,{children:"components"})]}),(0,d.jsxs)(n.tr,{children:[(0,d.jsx)(n.td,{children:"any"}),(0,d.jsx)(n.td,{children:"i3dMappings"})]}),(0,d.jsxs)(n.tr,{children:[(0,d.jsx)(n.td,{children:"any"}),(0,d.jsx)(n.td,{children:"parentNode"})]})]})]}),"\n",(0,d.jsx)(n.p,{children:(0,d.jsx)(n.strong,{children:"Code"})}),"\n",(0,d.jsx)(n.pre,{children:(0,d.jsx)(n.code,{className:"language-lua",children:"function Dashboard:loadDashboardsFromXML(xmlFile, key, dashboardValueType, components, i3dMappings, parentNode)\n    if self.isClient then\n        local spec = self.spec_dashboard\n\n        xmlFile:iterate(key .. \".dashboard\" , function (index, dashboardKey)\n            local valueTypeName = xmlFile:getValue(dashboardKey .. \"#valueType\" )\n\n            local dashboardValueTypeToUse = dashboardValueType\n            local numMatches = 0\n            if dashboardValueTypeToUse = = nil and valueTypeName ~ = nil then\n                for _, _dashboardValueType in ipairs(spec.dashboardValueTypes) do\n                    if valueTypeName = = _dashboardValueType.name or valueTypeName = = _dashboardValueType.fullName then\n                        dashboardValueTypeToUse = _dashboardValueType\n                        numMatches = numMatches + 1\n                    end\n                end\n            end\n\n            if numMatches > 1 and dashboardValueTypeToUse.xmlKey = = nil then\n                Logging.xmlWarning(xmlFile, \"Dashboard valueType name '%s' is used in multiple specializations.Please specify with specialization prefix. (e.g. 'motorized.rpm')\" , valueTypeName)\n            end\n\n            if valueTypeName ~ = nil and dashboardValueTypeToUse = = nil then\n                Logging.xmlWarning(xmlFile, \"Unknown dashboard valueType '%s' for dashboard '%s'\" , valueTypeName, dashboardKey)\n                    return\n                end\n\n                local dashboard = { }\n                if self:loadDashboardFromXML(xmlFile, dashboardKey, dashboard, dashboardValueTypeToUse, components or self.components, i3dMappings or self.i3dMappings, parentNode) then\n                    local typeData = Dashboard.TYPE_DATA[dashboard.displayTypeIndex]\n                    local isCritical = typeData.isCritical\n                    if dashboard.isCritical ~ = nil then\n                        isCritical = dashboard.isCritical\n                    end\n\n                    if isCritical and((dashboardValueTypeToUse ~ = nil and dashboardValueTypeToUse.pollUpdate) or dashboard.doInterpolation) then\n                        table.insert(spec.criticalDashboards, dashboard)\n                    else\n                            if (dashboardValueTypeToUse ~ = nil and not dashboardValueTypeToUse.pollUpdate) and not dashboard.doInterpolation then\n                                local fullName = dashboardValueTypeToUse.fullName\n                                if spec.dashboardsByValueType[fullName] = = nil then\n                                    spec.dashboardsByValueType[fullName] = { }\n                                    spec.dashboardsByValueTypeDirty[fullName] = false\n                                end\n                                table.insert(spec.dashboardsByValueType[fullName], dashboard)\n                            else\n                                    if dashboardValueTypeToUse = = nil then\n                                        table.insert(spec.groupDashboards, dashboard)\n                                    else\n                                            table.insert(spec.tickDashboards, dashboard)\n                                        end\n                                    end\n                                end\n\n                                spec.numDashboards = spec.numDashboards + 1\n                            end\n                        end )\n                    end\n\n                    return true\n                end\n\n"})}),"\n",(0,d.jsx)(n.h3,{id:"ondashboardcompoundloaded",children:"onDashboardCompoundLoaded"}),"\n",(0,d.jsx)(n.p,{children:(0,d.jsx)(n.strong,{children:"Description"})}),"\n",(0,d.jsx)(n.p,{children:(0,d.jsx)(n.strong,{children:"Definition"})}),"\n",(0,d.jsxs)(n.blockquote,{children:["\n",(0,d.jsx)(n.p,{children:"onDashboardCompoundLoaded()"}),"\n"]}),"\n",(0,d.jsx)(n.p,{children:(0,d.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,d.jsxs)(n.table,{children:[(0,d.jsx)(n.thead,{children:(0,d.jsxs)(n.tr,{children:[(0,d.jsx)(n.th,{children:"any"}),(0,d.jsx)(n.th,{children:"i3dNode"})]})}),(0,d.jsxs)(n.tbody,{children:[(0,d.jsxs)(n.tr,{children:[(0,d.jsx)(n.td,{children:"any"}),(0,d.jsx)(n.td,{children:"failedReason"})]}),(0,d.jsxs)(n.tr,{children:[(0,d.jsx)(n.td,{children:"any"}),(0,d.jsx)(n.td,{children:"args"})]})]})]}),"\n",(0,d.jsx)(n.p,{children:(0,d.jsx)(n.strong,{children:"Code"})}),"\n",(0,d.jsx)(n.pre,{children:(0,d.jsx)(n.code,{className:"language-lua",children:'function Dashboard:onDashboardCompoundLoaded(i3dNode, failedReason, args)\n    local dashboardXMLFile = args.dashboardXMLFile\n    local compound = args.compound\n    local compoundKey = args.compoundKey\n\n    if i3dNode ~ = 0 then\n        local components = { }\n        for i = 1 , getNumOfChildren(i3dNode) do\n            table.insert(components, { node = getChildAt(i3dNode, i - 1 ) } )\n        end\n\n        compound.i3dMappings = { }\n        I3DUtil.loadI3DMapping(dashboardXMLFile, "dashboardCompounds" , components, compound.i3dMappings, nil )\n\n        self:loadDashboardCompoundFromExternalXML(dashboardXMLFile, compound, compoundKey, components)\n\n        delete(i3dNode)\n    end\n\n    dashboardXMLFile:delete()\nend\n\n'})}),"\n",(0,d.jsx)(n.h3,{id:"ondelete",children:"onDelete"}),"\n",(0,d.jsx)(n.p,{children:(0,d.jsx)(n.strong,{children:"Description"})}),"\n",(0,d.jsxs)(n.blockquote,{children:["\n",(0,d.jsx)(n.p,{children:"Called on deleting"}),"\n"]}),"\n",(0,d.jsx)(n.p,{children:(0,d.jsx)(n.strong,{children:"Definition"})}),"\n",(0,d.jsxs)(n.blockquote,{children:["\n",(0,d.jsx)(n.p,{children:"onDelete()"}),"\n"]}),"\n",(0,d.jsx)(n.p,{children:(0,d.jsx)(n.strong,{children:"Code"})}),"\n",(0,d.jsx)(n.pre,{children:(0,d.jsx)(n.code,{className:"language-lua",children:"function Dashboard:onDelete()\n    local spec = self.spec_dashboard\n\n    if spec.sharedLoadRequestIds ~ = nil then\n        for _, sharedLoadRequestId in ipairs(spec.sharedLoadRequestIds) do\n            g_i3DManager:releaseSharedI3DFile(sharedLoadRequestId)\n        end\n        spec.sharedLoadRequestIds = nil\n    end\nend\n\n"})}),"\n",(0,d.jsx)(n.h3,{id:"onload",children:"onLoad"}),"\n",(0,d.jsx)(n.p,{children:(0,d.jsx)(n.strong,{children:"Description"})}),"\n",(0,d.jsx)(n.p,{children:(0,d.jsx)(n.strong,{children:"Definition"})}),"\n",(0,d.jsxs)(n.blockquote,{children:["\n",(0,d.jsx)(n.p,{children:"onLoad()"}),"\n"]}),"\n",(0,d.jsx)(n.p,{children:(0,d.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,d.jsx)(n.table,{children:(0,d.jsx)(n.thead,{children:(0,d.jsxs)(n.tr,{children:[(0,d.jsx)(n.th,{children:"any"}),(0,d.jsx)(n.th,{children:"savegame"})]})})}),"\n",(0,d.jsx)(n.p,{children:(0,d.jsx)(n.strong,{children:"Code"})}),"\n",(0,d.jsx)(n.pre,{children:(0,d.jsx)(n.code,{className:"language-lua",children:'function Dashboard:onLoad(savegame)\n    local spec = self.spec_dashboard\n\n    spec.dashboards = { } -- backward compatibility\n\n    spec.groupDashboards = { } -- dashboards that are only toggle with the group and never change the values\n    spec.dashboardsByValueType = { } -- dashboards by type that are updated based on events from otehr specializations\n    spec.dashboardsByValueTypeDirty = { } -- dirty state of each value type, so the dashboards are updated when we get into the update range again\n\n    spec.tickDashboards = { } -- low prio dashboards that are updated in tick\n    spec.criticalDashboards = { } -- high prio dashboards that are updated each frame(e.g.pedal rotations)\n\n    spec.numDashboards = 0\n\n    spec.groups = { }\n    spec.sortedGroups = { }\n    spec.groupUpdateIndex = 1\n    spec.hasGroups = false\n    spec.dashboardTypesLoaded = false\n\n    spec.dashboardValueTypes = { }\n    spec.sharedLoadRequestIds = { }\n\n    local i = 0\n    while true do\n        local baseKey = string.format( "%s.groups.group(%d)" , "vehicle.dashboard" , i)\n        if not self.xmlFile:hasProperty(baseKey) then\n            break\n        end\n\n        local group = { }\n        if self:loadDashboardGroupFromXML( self.xmlFile, baseKey, group) then\n            spec.groups[group.name] = group\n            table.insert(spec.sortedGroups, group)\n            spec.hasGroups = true\n        end\n\n        i = i + 1\n    end\n\n    spec.isDirty = false\n    spec.isDirtyTick = false\n\n    spec.tickIntervall = self.xmlFile:getValue( "vehicle.dashboard#tickIntervall" )\n    spec.timeSinceLastTick = 0\n\n    spec.maxUpdateDistance = self.xmlFile:getValue( "vehicle.dashboard#maxUpdateDistance" , Dashboard.DEFAULT_MAX_UPDATE_DISTANCE)\n    spec.maxUpdateDistanceCritical = self.xmlFile:getValue( "vehicle.dashboard#maxUpdateDistanceCritical" , Dashboard.DEFAULT_MAX_UPDATE_DISTANCE_CRITICAL)\n    spec.lastUpdateDistance = math.huge\nend\n\n'})}),"\n",(0,d.jsx)(n.h3,{id:"onpreinitcomponentplacement",children:"onPreInitComponentPlacement"}),"\n",(0,d.jsx)(n.p,{children:(0,d.jsx)(n.strong,{children:"Description"})}),"\n",(0,d.jsx)(n.p,{children:(0,d.jsx)(n.strong,{children:"Definition"})}),"\n",(0,d.jsxs)(n.blockquote,{children:["\n",(0,d.jsx)(n.p,{children:"onPreInitComponentPlacement()"}),"\n"]}),"\n",(0,d.jsx)(n.p,{children:(0,d.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,d.jsx)(n.table,{children:(0,d.jsx)(n.thead,{children:(0,d.jsxs)(n.tr,{children:[(0,d.jsx)(n.th,{children:"any"}),(0,d.jsx)(n.th,{children:"savegame"})]})})}),"\n",(0,d.jsx)(n.p,{children:(0,d.jsx)(n.strong,{children:"Code"})}),"\n",(0,d.jsx)(n.pre,{children:(0,d.jsx)(n.code,{className:"language-lua",children:'function Dashboard:onPreInitComponentPlacement(savegame)\n    -- load dashboards in onPreInitComponentPlacement, so we get all the value types that are registered in onPostLoad\n\n    local spec = self.spec_dashboard\n\n    if self.isClient then\n        SpecializationUtil.raiseEvent( self , "onRegisterDashboardValueTypes" )\n\n        spec.dashboardTypesLoaded = true\n        self:loadDashboardsFromXML( self.xmlFile, "vehicle.dashboard.default" )\n\n        for _, dashboardValueType in ipairs(spec.dashboardValueTypes) do\n            dashboardValueType:loadFromXML( self.xmlFile, self )\n        end\n\n        spec.dashboardCompounds = { }\n        self.xmlFile:iterate( "vehicle.dashboard.compounds.compound" , function (index, compoundKey)\n            local dashboardCompound = { }\n            if self:loadDashboardCompoundFromXML( self.xmlFile, compoundKey, dashboardCompound) then\n                table.insert(spec.dashboardCompounds, dashboardCompound)\n            end\n        end )\n    end\n\n    if not self.isClient or spec.numDashboards = = 0 then\n        SpecializationUtil.removeEventListener( self , "onUpdate" , Dashboard )\n        SpecializationUtil.removeEventListener( self , "onUpdateTick" , Dashboard )\n    end\nend\n\n'})}),"\n",(0,d.jsx)(n.h3,{id:"onupdate",children:"onUpdate"}),"\n",(0,d.jsx)(n.p,{children:(0,d.jsx)(n.strong,{children:"Description"})}),"\n",(0,d.jsx)(n.p,{children:(0,d.jsx)(n.strong,{children:"Definition"})}),"\n",(0,d.jsxs)(n.blockquote,{children:["\n",(0,d.jsx)(n.p,{children:"onUpdate()"}),"\n"]}),"\n",(0,d.jsx)(n.p,{children:(0,d.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,d.jsxs)(n.table,{children:[(0,d.jsx)(n.thead,{children:(0,d.jsxs)(n.tr,{children:[(0,d.jsx)(n.th,{children:"any"}),(0,d.jsx)(n.th,{children:"dt"})]})}),(0,d.jsxs)(n.tbody,{children:[(0,d.jsxs)(n.tr,{children:[(0,d.jsx)(n.td,{children:"any"}),(0,d.jsx)(n.td,{children:"isActiveForInput"})]}),(0,d.jsxs)(n.tr,{children:[(0,d.jsx)(n.td,{children:"any"}),(0,d.jsx)(n.td,{children:"isActiveForInputIgnoreSelection"})]}),(0,d.jsxs)(n.tr,{children:[(0,d.jsx)(n.td,{children:"any"}),(0,d.jsx)(n.td,{children:"isSelected"})]})]})]}),"\n",(0,d.jsx)(n.p,{children:(0,d.jsx)(n.strong,{children:"Code"})}),"\n",(0,d.jsx)(n.pre,{children:(0,d.jsx)(n.code,{className:"language-lua",children:"function Dashboard:onUpdate(dt, isActiveForInput, isActiveForInputIgnoreSelection, isSelected)\n    if self.isClient then\n        local spec = self.spec_dashboard\n\n        if spec.hasGroups then\n            local group = spec.sortedGroups[spec.groupUpdateIndex]\n            if self:getIsDashboardGroupActive(group) ~ = group.isActive then\n                group.isActive = not group.isActive\n\n                -- force update of all dashboards\n                self:updateDashboards(spec.groupDashboards, dt, true )\n                self:updateDashboards(spec.tickDashboards, dt, true )\n                self:updateDashboards(spec.criticalDashboards, dt, true )\n                for _, dashboards in pairs(spec.dashboardsByValueType) do\n                    self:updateDashboards(dashboards, dt, true )\n                end\n            end\n\n            spec.groupUpdateIndex = spec.groupUpdateIndex + 1\n            if spec.groupUpdateIndex > #spec.sortedGroups then\n                spec.groupUpdateIndex = 1\n            end\n        end\n\n        if self.currentUpdateDistance < spec.maxUpdateDistanceCritical or spec.isDirty then\n            self:updateDashboards(spec.criticalDashboards, dt)\n\n            spec.isDirty = false\n        end\n\n        if spec.isDirtyTick then\n            self:raiseActive()\n        end\n    end\nend\n\n"})}),"\n",(0,d.jsx)(n.h3,{id:"onupdateend",children:"onUpdateEnd"}),"\n",(0,d.jsx)(n.p,{children:(0,d.jsx)(n.strong,{children:"Description"})}),"\n",(0,d.jsx)(n.p,{children:(0,d.jsx)(n.strong,{children:"Definition"})}),"\n",(0,d.jsxs)(n.blockquote,{children:["\n",(0,d.jsx)(n.p,{children:"onUpdateEnd()"}),"\n"]}),"\n",(0,d.jsx)(n.p,{children:(0,d.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,d.jsxs)(n.table,{children:[(0,d.jsx)(n.thead,{children:(0,d.jsxs)(n.tr,{children:[(0,d.jsx)(n.th,{children:"any"}),(0,d.jsx)(n.th,{children:"dt"})]})}),(0,d.jsxs)(n.tbody,{children:[(0,d.jsxs)(n.tr,{children:[(0,d.jsx)(n.td,{children:"any"}),(0,d.jsx)(n.td,{children:"isActiveForInput"})]}),(0,d.jsxs)(n.tr,{children:[(0,d.jsx)(n.td,{children:"any"}),(0,d.jsx)(n.td,{children:"isActiveForInputIgnoreSelection"})]}),(0,d.jsxs)(n.tr,{children:[(0,d.jsx)(n.td,{children:"any"}),(0,d.jsx)(n.td,{children:"isSelected"})]})]})]}),"\n",(0,d.jsx)(n.p,{children:(0,d.jsx)(n.strong,{children:"Code"})}),"\n",(0,d.jsx)(n.pre,{children:(0,d.jsx)(n.code,{className:"language-lua",children:"function Dashboard:onUpdateEnd(dt, isActiveForInput, isActiveForInputIgnoreSelection, isSelected)\n    if self.isClient then\n        local spec = self.spec_dashboard\n        self:updateDashboards(spec.tickDashboards, dt, true )\n        self:updateDashboards(spec.criticalDashboards, dt, true )\n    end\nend\n\n"})}),"\n",(0,d.jsx)(n.h3,{id:"onupdatetick",children:"onUpdateTick"}),"\n",(0,d.jsx)(n.p,{children:(0,d.jsx)(n.strong,{children:"Description"})}),"\n",(0,d.jsx)(n.p,{children:(0,d.jsx)(n.strong,{children:"Definition"})}),"\n",(0,d.jsxs)(n.blockquote,{children:["\n",(0,d.jsx)(n.p,{children:"onUpdateTick()"}),"\n"]}),"\n",(0,d.jsx)(n.p,{children:(0,d.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,d.jsxs)(n.table,{children:[(0,d.jsx)(n.thead,{children:(0,d.jsxs)(n.tr,{children:[(0,d.jsx)(n.th,{children:"any"}),(0,d.jsx)(n.th,{children:"dt"})]})}),(0,d.jsxs)(n.tbody,{children:[(0,d.jsxs)(n.tr,{children:[(0,d.jsx)(n.td,{children:"any"}),(0,d.jsx)(n.td,{children:"isActiveForInput"})]}),(0,d.jsxs)(n.tr,{children:[(0,d.jsx)(n.td,{children:"any"}),(0,d.jsx)(n.td,{children:"isActiveForInputIgnoreSelection"})]}),(0,d.jsxs)(n.tr,{children:[(0,d.jsx)(n.td,{children:"any"}),(0,d.jsx)(n.td,{children:"isSelected"})]})]})]}),"\n",(0,d.jsx)(n.p,{children:(0,d.jsx)(n.strong,{children:"Code"})}),"\n",(0,d.jsx)(n.pre,{children:(0,d.jsx)(n.code,{className:"language-lua",children:"function Dashboard:onUpdateTick(dt, isActiveForInput, isActiveForInputIgnoreSelection, isSelected)\n    if self.isClient then\n        local spec = self.spec_dashboard\n        if self.currentUpdateDistance < spec.maxUpdateDistance or spec.isDirtyTick then\n            local updateAllowed = true\n            if spec.tickIntervall ~ = nil then\n                spec.timeSinceLastTick = spec.timeSinceLastTick + dt\n                if spec.timeSinceLastTick < spec.tickIntervall then\n                    updateAllowed = false\n                else\n                        spec.timeSinceLastTick = 0\n                    end\n                end\n\n                if updateAllowed then\n                    self:updateDashboards(spec.tickDashboards, dt)\n                    spec.isDirtyTick = false\n                end\n            end\n\n            if self.currentUpdateDistance < spec.maxUpdateDistance then\n                for valueType, dashboards in pairs(spec.dashboardsByValueType) do\n                    if spec.dashboardsByValueTypeDirty[valueType] then\n                        self:updateDashboards(dashboards, dt, true )\n                        spec.dashboardsByValueTypeDirty[valueType] = false\n                    end\n                end\n            end\n        end\n    end\n\n"})}),"\n",(0,d.jsx)(n.h3,{id:"prerequisitespresent",children:"prerequisitesPresent"}),"\n",(0,d.jsx)(n.p,{children:(0,d.jsx)(n.strong,{children:"Description"})}),"\n",(0,d.jsx)(n.p,{children:(0,d.jsx)(n.strong,{children:"Definition"})}),"\n",(0,d.jsxs)(n.blockquote,{children:["\n",(0,d.jsx)(n.p,{children:"prerequisitesPresent()"}),"\n"]}),"\n",(0,d.jsx)(n.p,{children:(0,d.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,d.jsx)(n.table,{children:(0,d.jsx)(n.thead,{children:(0,d.jsxs)(n.tr,{children:[(0,d.jsx)(n.th,{children:"any"}),(0,d.jsx)(n.th,{children:"specializations"})]})})}),"\n",(0,d.jsx)(n.p,{children:(0,d.jsx)(n.strong,{children:"Code"})}),"\n",(0,d.jsx)(n.pre,{children:(0,d.jsx)(n.code,{className:"language-lua",children:"function Dashboard.prerequisitesPresent(specializations)\n    return true\nend\n\n"})}),"\n",(0,d.jsx)(n.h3,{id:"registerdashboardvaluetype",children:"registerDashboardValueType"}),"\n",(0,d.jsx)(n.p,{children:(0,d.jsx)(n.strong,{children:"Description"})}),"\n",(0,d.jsx)(n.p,{children:(0,d.jsx)(n.strong,{children:"Definition"})}),"\n",(0,d.jsxs)(n.blockquote,{children:["\n",(0,d.jsx)(n.p,{children:"registerDashboardValueType()"}),"\n"]}),"\n",(0,d.jsx)(n.p,{children:(0,d.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,d.jsx)(n.table,{children:(0,d.jsx)(n.thead,{children:(0,d.jsxs)(n.tr,{children:[(0,d.jsx)(n.th,{children:"any"}),(0,d.jsx)(n.th,{children:"dashboardValueType"})]})})}),"\n",(0,d.jsx)(n.p,{children:(0,d.jsx)(n.strong,{children:"Code"})}),"\n",(0,d.jsx)(n.pre,{children:(0,d.jsx)(n.code,{className:"language-lua",children:"function Dashboard:registerDashboardValueType(dashboardValueType)\n    local spec = self.spec_dashboard\n    table.insert(spec.dashboardValueTypes, dashboardValueType)\n\n    if spec.dashboardTypesLoaded then\n        dashboardValueType:loadFromXML( self.xmlFile, self )\n    end\nend\n\n"})}),"\n",(0,d.jsx)(n.h3,{id:"registerdashboardxmlpaths",children:"registerDashboardXMLPaths"}),"\n",(0,d.jsx)(n.p,{children:(0,d.jsx)(n.strong,{children:"Description"})}),"\n",(0,d.jsx)(n.p,{children:(0,d.jsx)(n.strong,{children:"Definition"})}),"\n",(0,d.jsxs)(n.blockquote,{children:["\n",(0,d.jsx)(n.p,{children:"registerDashboardXMLPaths(XMLSchema schema, string basePath, array availableValueTypes)"}),"\n"]}),"\n",(0,d.jsx)(n.p,{children:(0,d.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,d.jsxs)(n.table,{children:[(0,d.jsx)(n.thead,{children:(0,d.jsxs)(n.tr,{children:[(0,d.jsx)(n.th,{children:"XMLSchema"}),(0,d.jsx)(n.th,{children:"schema"}),(0,d.jsx)(n.th,{children:"XMLSchema instance"})]})}),(0,d.jsxs)(n.tbody,{children:[(0,d.jsxs)(n.tr,{children:[(0,d.jsx)(n.td,{children:"string"}),(0,d.jsx)(n.td,{children:"basePath"}),(0,d.jsx)(n.td,{})]}),(0,d.jsxs)(n.tr,{children:[(0,d.jsx)(n.td,{children:"array"}),(0,d.jsx)(n.td,{children:"availableValueTypes"}),(0,d.jsx)(n.td,{children:"list of allowed valueTypes"})]})]})]}),"\n",(0,d.jsx)(n.p,{children:(0,d.jsx)(n.strong,{children:"Code"})}),"\n",(0,d.jsx)(n.pre,{children:(0,d.jsx)(n.code,{className:"language-lua",children:'function Dashboard.registerDashboardXMLPaths(schema, basePath, availableValueTypes)\n    schema:register(XMLValueType.STRING, basePath .. ".dashboard(?)#valueType" , "Value type name" , nil , nil , availableValueTypes)\n    schema:register(XMLValueType.STRING, basePath .. ".dashboard(?)#displayType" , "Display type name" , nil , nil , table.toList( Dashboard.TYPES))\n    schema:register(XMLValueType.BOOL, basePath .. ".dashboard(?)#doInterpolation" , "Do interpolation" , false )\n    schema:register(XMLValueType.BOOL, basePath .. ".dashboard(?)#isCritical" , "Defines if dashboard update is critical and should be done every frame" , "automatically based on type" )\n        schema:register(XMLValueType.BOOL, basePath .. ".dashboard(?)#useStateChange" , "Dashboard is active for a defined amount of time when the source value changes" , false )\n            schema:register(XMLValueType.TIME, basePath .. ".dashboard(?)#stateChangeTime" , "Defines how long the dashboard is active when the state changes(seconds)" , 0.2 )\n            schema:register(XMLValueType.FLOAT, basePath .. ".dashboard(?)#stateChangeValue" , "Defines the dashboard value which triggers the state change.If not defined, any state change will trigger it" )\n            schema:register(XMLValueType.FLOAT, basePath .. ".dashboard(?)#interpolationSpeed" , "Interpolation speed" , 0.005 )\n            schema:register(XMLValueType.FLOAT, basePath .. ".dashboard(?)#idleValue" , "Idle value" , 0 )\n            schema:register(XMLValueType.FLOAT, basePath .. ".dashboard(?)#offsetValue" , "Offset the value by the given amount" , 0 )\n            schema:register(XMLValueType.FLOAT, basePath .. ".dashboard(?)#scaleFactor" , "Scale the value by the given factor" , 1 )\n\n            schema:register(XMLValueType.FLOAT, basePath .. ".dashboard(?)#minActiveValue" , "Min.value to activate this dashboard" )\n            schema:register(XMLValueType.FLOAT, basePath .. ".dashboard(?)#maxActiveValue" , "Max.value to activate this dashboard" )\n\n            schema:register(XMLValueType.FLOAT, basePath .. ".dashboard(?).valueMapping(?)#sourceValue" , "Source value" )\n            schema:register(XMLValueType.FLOAT, basePath .. ".dashboard(?).valueMapping(?)#dashboardValue" , "Value to be used for dashboard at this source value" )\n\n                schema:register(XMLValueType.STRING, basePath .. ".dashboard(?)#groups" , "List of groups" )\n\n                schema:register(XMLValueType.NODE_INDEX, basePath .. ".dashboard(?)#node" , "Node" )\n\n                schema:register(XMLValueType.FLOAT, basePath .. ".dashboard(?)#warningThresholdMin" , "(WARNING) Threshold min." )\n                schema:register(XMLValueType.FLOAT, basePath .. ".dashboard(?)#warningThresholdMax" , "(WARNING) Threshold max." )\n\n                for _, typeData in pairs( Dashboard.TYPE_DATA) do\n                    typeData.schemaFunc(schema, basePath)\n                end\n\n                schema:addDelayedRegistrationPath(basePath .. ".dashboard(?)" , "Dashboard" )\n            end\n\n'})}),"\n",(0,d.jsx)(n.h3,{id:"registerdisplaytype",children:"registerDisplayType"}),"\n",(0,d.jsx)(n.p,{children:(0,d.jsx)(n.strong,{children:"Description"})}),"\n",(0,d.jsx)(n.p,{children:(0,d.jsx)(n.strong,{children:"Definition"})}),"\n",(0,d.jsxs)(n.blockquote,{children:["\n",(0,d.jsx)(n.p,{children:"registerDisplayType()"}),"\n"]}),"\n",(0,d.jsx)(n.p,{children:(0,d.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,d.jsxs)(n.table,{children:[(0,d.jsx)(n.thead,{children:(0,d.jsxs)(n.tr,{children:[(0,d.jsx)(n.th,{children:"any"}),(0,d.jsx)(n.th,{children:"typeIndex"})]})}),(0,d.jsxs)(n.tbody,{children:[(0,d.jsxs)(n.tr,{children:[(0,d.jsx)(n.td,{children:"any"}),(0,d.jsx)(n.td,{children:"isCritical"})]}),(0,d.jsxs)(n.tr,{children:[(0,d.jsx)(n.td,{children:"any"}),(0,d.jsx)(n.td,{children:"schemaFunc"})]}),(0,d.jsxs)(n.tr,{children:[(0,d.jsx)(n.td,{children:"any"}),(0,d.jsx)(n.td,{children:"loadFunc"})]}),(0,d.jsxs)(n.tr,{children:[(0,d.jsx)(n.td,{children:"any"}),(0,d.jsx)(n.td,{children:"updateFunc"})]})]})]}),"\n",(0,d.jsx)(n.p,{children:(0,d.jsx)(n.strong,{children:"Code"})}),"\n",(0,d.jsx)(n.pre,{children:(0,d.jsx)(n.code,{className:"language-lua",children:"function Dashboard.registerDisplayType(typeIndex, isCritical, schemaFunc, loadFunc, updateFunc)\n    local typeData = { }\n    typeData.isCritical = isCritical\n    typeData.schemaFunc = schemaFunc\n    typeData.loadFunc = loadFunc\n    typeData.updateFunc = updateFunc\n\n    Dashboard.TYPE_DATA[typeIndex] = typeData\nend\n\n"})}),"\n",(0,d.jsx)(n.h3,{id:"registereventlisteners",children:"registerEventListeners"}),"\n",(0,d.jsx)(n.p,{children:(0,d.jsx)(n.strong,{children:"Description"})}),"\n",(0,d.jsx)(n.p,{children:(0,d.jsx)(n.strong,{children:"Definition"})}),"\n",(0,d.jsxs)(n.blockquote,{children:["\n",(0,d.jsx)(n.p,{children:"registerEventListeners()"}),"\n"]}),"\n",(0,d.jsx)(n.p,{children:(0,d.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,d.jsx)(n.table,{children:(0,d.jsx)(n.thead,{children:(0,d.jsxs)(n.tr,{children:[(0,d.jsx)(n.th,{children:"any"}),(0,d.jsx)(n.th,{children:"vehicleType"})]})})}),"\n",(0,d.jsx)(n.p,{children:(0,d.jsx)(n.strong,{children:"Code"})}),"\n",(0,d.jsx)(n.pre,{children:(0,d.jsx)(n.code,{className:"language-lua",children:'function Dashboard.registerEventListeners(vehicleType)\n    SpecializationUtil.registerEventListener(vehicleType, "onLoad" , Dashboard )\n    SpecializationUtil.registerEventListener(vehicleType, "onPreInitComponentPlacement" , Dashboard )\n    SpecializationUtil.registerEventListener(vehicleType, "onDelete" , Dashboard )\n    SpecializationUtil.registerEventListener(vehicleType, "onUpdate" , Dashboard )\n    SpecializationUtil.registerEventListener(vehicleType, "onUpdateTick" , Dashboard )\n    SpecializationUtil.registerEventListener(vehicleType, "onUpdateEnd" , Dashboard )\nend\n\n'})}),"\n",(0,d.jsx)(n.h3,{id:"registerevents",children:"registerEvents"}),"\n",(0,d.jsx)(n.p,{children:(0,d.jsx)(n.strong,{children:"Description"})}),"\n",(0,d.jsx)(n.p,{children:(0,d.jsx)(n.strong,{children:"Definition"})}),"\n",(0,d.jsxs)(n.blockquote,{children:["\n",(0,d.jsx)(n.p,{children:"registerEvents()"}),"\n"]}),"\n",(0,d.jsx)(n.p,{children:(0,d.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,d.jsx)(n.table,{children:(0,d.jsx)(n.thead,{children:(0,d.jsxs)(n.tr,{children:[(0,d.jsx)(n.th,{children:"any"}),(0,d.jsx)(n.th,{children:"vehicleType"})]})})}),"\n",(0,d.jsx)(n.p,{children:(0,d.jsx)(n.strong,{children:"Code"})}),"\n",(0,d.jsx)(n.pre,{children:(0,d.jsx)(n.code,{className:"language-lua",children:'function Dashboard.registerEvents(vehicleType)\n    SpecializationUtil.registerEvent(vehicleType, "onRegisterDashboardValueTypes" )\nend\n\n'})}),"\n",(0,d.jsx)(n.h3,{id:"registerfunctions",children:"registerFunctions"}),"\n",(0,d.jsx)(n.p,{children:(0,d.jsx)(n.strong,{children:"Description"})}),"\n",(0,d.jsx)(n.p,{children:(0,d.jsx)(n.strong,{children:"Definition"})}),"\n",(0,d.jsxs)(n.blockquote,{children:["\n",(0,d.jsx)(n.p,{children:"registerFunctions()"}),"\n"]}),"\n",(0,d.jsx)(n.p,{children:(0,d.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,d.jsx)(n.table,{children:(0,d.jsx)(n.thead,{children:(0,d.jsxs)(n.tr,{children:[(0,d.jsx)(n.th,{children:"any"}),(0,d.jsx)(n.th,{children:"vehicleType"})]})})}),"\n",(0,d.jsx)(n.p,{children:(0,d.jsx)(n.strong,{children:"Code"})}),"\n",(0,d.jsx)(n.pre,{children:(0,d.jsx)(n.code,{className:"language-lua",children:'function Dashboard.registerFunctions(vehicleType)\n    SpecializationUtil.registerFunction(vehicleType, "registerDashboardValueType" , Dashboard.registerDashboardValueType)\n    SpecializationUtil.registerFunction(vehicleType, "updateDashboards" , Dashboard.updateDashboards)\n    SpecializationUtil.registerFunction(vehicleType, "updateDashboardValueType" , Dashboard.updateDashboardValueType)\n    SpecializationUtil.registerFunction(vehicleType, "loadDashboardGroupFromXML" , Dashboard.loadDashboardGroupFromXML)\n    SpecializationUtil.registerFunction(vehicleType, "getIsDashboardGroupActive" , Dashboard.getIsDashboardGroupActive)\n    SpecializationUtil.registerFunction(vehicleType, "getDashboardGroupByName" , Dashboard.getDashboardGroupByName)\n    SpecializationUtil.registerFunction(vehicleType, "loadDashboardCompoundFromXML" , Dashboard.loadDashboardCompoundFromXML)\n    SpecializationUtil.registerFunction(vehicleType, "onDashboardCompoundLoaded" , Dashboard.onDashboardCompoundLoaded)\n    SpecializationUtil.registerFunction(vehicleType, "loadDashboardCompoundFromExternalXML" , Dashboard.loadDashboardCompoundFromExternalXML)\n    SpecializationUtil.registerFunction(vehicleType, "loadDashboardsFromXML" , Dashboard.loadDashboardsFromXML)\n    SpecializationUtil.registerFunction(vehicleType, "loadDashboardFromXML" , Dashboard.loadDashboardFromXML)\n    SpecializationUtil.registerFunction(vehicleType, "setDashboardsDirty" , Dashboard.setDashboardsDirty)\n    SpecializationUtil.registerFunction(vehicleType, "getDashboardValue" , Dashboard.getDashboardValue)\nend\n\n'})}),"\n",(0,d.jsx)(n.h3,{id:"setdashboardsdirty",children:"setDashboardsDirty"}),"\n",(0,d.jsx)(n.p,{children:(0,d.jsx)(n.strong,{children:"Description"})}),"\n",(0,d.jsx)(n.p,{children:(0,d.jsx)(n.strong,{children:"Definition"})}),"\n",(0,d.jsxs)(n.blockquote,{children:["\n",(0,d.jsx)(n.p,{children:"setDashboardsDirty()"}),"\n"]}),"\n",(0,d.jsx)(n.p,{children:(0,d.jsx)(n.strong,{children:"Code"})}),"\n",(0,d.jsx)(n.pre,{children:(0,d.jsx)(n.code,{className:"language-lua",children:"function Dashboard:setDashboardsDirty()\n    self.spec_dashboard.isDirty = true\n    self.spec_dashboard.isDirtyTick = true\n\n    self:raiseActive()\nend\n\n"})}),"\n",(0,d.jsx)(n.h3,{id:"updatedashboards",children:"updateDashboards"}),"\n",(0,d.jsx)(n.p,{children:(0,d.jsx)(n.strong,{children:"Description"})}),"\n",(0,d.jsx)(n.p,{children:(0,d.jsx)(n.strong,{children:"Definition"})}),"\n",(0,d.jsxs)(n.blockquote,{children:["\n",(0,d.jsx)(n.p,{children:"updateDashboards()"}),"\n"]}),"\n",(0,d.jsx)(n.p,{children:(0,d.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,d.jsxs)(n.table,{children:[(0,d.jsx)(n.thead,{children:(0,d.jsxs)(n.tr,{children:[(0,d.jsx)(n.th,{children:"any"}),(0,d.jsx)(n.th,{children:"dashboards"})]})}),(0,d.jsxs)(n.tbody,{children:[(0,d.jsxs)(n.tr,{children:[(0,d.jsx)(n.td,{children:"any"}),(0,d.jsx)(n.td,{children:"dt"})]}),(0,d.jsxs)(n.tr,{children:[(0,d.jsx)(n.td,{children:"any"}),(0,d.jsx)(n.td,{children:"force"})]})]})]}),"\n",(0,d.jsx)(n.p,{children:(0,d.jsx)(n.strong,{children:"Code"})}),"\n",(0,d.jsx)(n.pre,{children:(0,d.jsx)(n.code,{className:"language-lua",children:"function Dashboard:updateDashboards(dashboards, dt, force)\n    for i = 1 , #dashboards do\n        local dashboard = dashboards[i]\n        local isActive = true\n        for j = 1 , #dashboard.groups do\n            if not dashboard.groups[j].isActive then\n                isActive = false\n                break\n            end\n        end\n\n        if dashboard.valueType ~ = nil then\n            local value, min , max , center, isNumber = dashboard.valueType:getValue(dashboard)\n\n            if dashboard.useStateChange then\n                if value ~ = dashboard.stateChangeLastValue then\n                    dashboard.stateChangeLastValue = value\n\n                    if not isNumber then\n                        value = value and 1 or 0\n                    end\n\n                    if dashboard.stateChangeValue = = nil or value = = dashboard.stateChangeValue then\n                        dashboard.stateChangeEndTime = g_ time + dashboard.stateChangeTime\n                    end\n                end\n\n                if dashboard.stateChangeEndTime > g_ time then\n                    value = 1\n                else\n                        value = 0\n                    end\n                    isNumber = true\n                end\n\n                if dashboard.minActiveValue ~ = nil then\n                    if value < dashboard.minActiveValue then\n                        isActive = false\n                    end\n                end\n\n                if dashboard.maxActiveValue ~ = nil then\n                    if value > dashboard.maxActiveValue then\n                        isActive = false\n                    end\n                end\n\n                if isNumber then\n                    if dashboard.scaleFactor ~ = nil then\n                        value = value * dashboard.scaleFactor\n                    end\n\n                    if dashboard.offsetValue ~ = nil then\n                        value = value + dashboard.offsetValue\n                    end\n\n                    if dashboard.valueMapping ~ = nil then\n                        value = dashboard.valueMapping:get(value)\n                    end\n                end\n\n                if not isActive then\n                    if isNumber then\n                        value = dashboard.idleValue\n                    else\n                            value = dashboard.idleValue > 0.5\n                        end\n                    end\n\n                    if dashboard.doInterpolation then\n                        -- convert boolean values to number, so we can interpolate it\n                        if not isNumber then\n                            value = value and 1 or 0\n                        end\n\n                        if value ~ = dashboard.lastInterpolationValue then\n                            local dir = math.sign(value - dashboard.lastInterpolationValue)\n                            local limitFunc = math.min\n                            if dir < 0 then\n                                limitFunc = math.max\n                            end\n\n                            value = limitFunc(dashboard.lastInterpolationValue + dashboard.interpolationSpeed * dir * dt, value)\n                            dashboard.lastInterpolationValue = value\n                        end\n                    end\n\n                    if value ~ = dashboard.lastValue or force then\n                        dashboard.lastValue = value\n\n                        if isNumber then\n                            -- for idle values while not active we ignore the limits\n\n                                if min ~ = nil then\n                                    if dashboard.doInterpolation then\n                                        min = math.min( min , dashboard.idleValue)\n                                    end\n\n                                    value = math.max( min , value)\n                                end\n\n                                if max ~ = nil and isActive then\n                                    if dashboard.doInterpolation then\n                                        max = math.max( max , dashboard.idleValue)\n                                    end\n\n                                    value = math.min( max , value)\n                                end\n\n                                if center ~ = nil then\n                                    local maxValue = math.max( math.abs( min ), math.abs( max ))\n                                    if value < center then\n                                        value = - value / min * maxValue\n                                    elseif value > center then\n                                            value = value / max * maxValue\n                                        end\n\n                                        max = maxValue\n                                        min = - maxValue\n                                    end\n                                end\n\n                                dashboard.stateFunc( self , dashboard, value, min , max , isActive)\n                            end\n                        elseif force then\n                                dashboard.stateFunc( self , dashboard, true , nil , nil , isActive)\n                            end\n                        end\n                    end\n\n"})}),"\n",(0,d.jsx)(n.h3,{id:"updatedashboardvaluetype",children:"updateDashboardValueType"}),"\n",(0,d.jsx)(n.p,{children:(0,d.jsx)(n.strong,{children:"Description"})}),"\n",(0,d.jsx)(n.p,{children:(0,d.jsx)(n.strong,{children:"Definition"})}),"\n",(0,d.jsxs)(n.blockquote,{children:["\n",(0,d.jsx)(n.p,{children:"updateDashboardValueType()"}),"\n"]}),"\n",(0,d.jsx)(n.p,{children:(0,d.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,d.jsx)(n.table,{children:(0,d.jsx)(n.thead,{children:(0,d.jsxs)(n.tr,{children:[(0,d.jsx)(n.th,{children:"any"}),(0,d.jsx)(n.th,{children:"valueTypeName"})]})})}),"\n",(0,d.jsx)(n.p,{children:(0,d.jsx)(n.strong,{children:"Code"})}),"\n",(0,d.jsx)(n.pre,{children:(0,d.jsx)(n.code,{className:"language-lua",children:"function Dashboard:updateDashboardValueType(valueTypeName)\n    self.spec_dashboard.dashboardsByValueTypeDirty[valueTypeName] = true\nend\n\n"})}),"\n",(0,d.jsx)(n.h3,{id:"warningattributes",children:"warningAttributes"}),"\n",(0,d.jsx)(n.p,{children:(0,d.jsx)(n.strong,{children:"Description"})}),"\n",(0,d.jsx)(n.p,{children:(0,d.jsx)(n.strong,{children:"Definition"})}),"\n",(0,d.jsxs)(n.blockquote,{children:["\n",(0,d.jsx)(n.p,{children:"warningAttributes()"}),"\n"]}),"\n",(0,d.jsx)(n.p,{children:(0,d.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,d.jsxs)(n.table,{children:[(0,d.jsx)(n.thead,{children:(0,d.jsxs)(n.tr,{children:[(0,d.jsx)(n.th,{children:"any"}),(0,d.jsx)(n.th,{children:"self"})]})}),(0,d.jsxs)(n.tbody,{children:[(0,d.jsxs)(n.tr,{children:[(0,d.jsx)(n.td,{children:"any"}),(0,d.jsx)(n.td,{children:"xmlFile"})]}),(0,d.jsxs)(n.tr,{children:[(0,d.jsx)(n.td,{children:"any"}),(0,d.jsx)(n.td,{children:"key"})]}),(0,d.jsxs)(n.tr,{children:[(0,d.jsx)(n.td,{children:"any"}),(0,d.jsx)(n.td,{children:"dashboard"})]}),(0,d.jsxs)(n.tr,{children:[(0,d.jsx)(n.td,{children:"any"}),(0,d.jsx)(n.td,{children:"isActive"})]})]})]}),"\n",(0,d.jsx)(n.p,{children:(0,d.jsx)(n.strong,{children:"Code"})}),"\n",(0,d.jsx)(n.pre,{children:(0,d.jsx)(n.code,{className:"language-lua",children:'function Dashboard.warningAttributes( self , xmlFile, key, dashboard, isActive)\n    dashboard.warningThresholdMin = xmlFile:getValue(key .. "#warningThresholdMin" , - math.huge)\n    dashboard.warningThresholdMax = xmlFile:getValue(key .. "#warningThresholdMax" , math.huge)\n\n    return true\nend\n\n'})})]})}function c(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,d.jsx)(n,{...e,children:(0,d.jsx)(h,{...e})}):h(e)}}}]);