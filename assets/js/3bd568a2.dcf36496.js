"use strict";(globalThis.webpackChunkfs25_community_luadoc=globalThis.webpackChunkfs25_community_luadoc||[]).push([[35078],{14400(n,e,t){t.r(e),t.d(e,{assets:()=>s,contentTitle:()=>a,default:()=>h,frontMatter:()=>r,metadata:()=>i,toc:()=>d});const i=JSON.parse('{"id":"script/Specializations/Cylindered","title":"Cylindered","description":"Cylindered","source":"@site/../docs/script/Specializations/Cylindered.md","sourceDirName":"script/Specializations","slug":"/script/Specializations/Cylindered","permalink":"/FS25-Community-LUADOC/script/Specializations/Cylindered","draft":false,"unlisted":false,"tags":[],"version":"current","lastUpdatedAt":1767161192000,"frontMatter":{},"sidebar":"docsSidebar","previous":{"title":"Cutter","permalink":"/FS25-Community-LUADOC/script/Specializations/Cutter"},"next":{"title":"CylinderedFoldable","permalink":"/FS25-Community-LUADOC/script/Specializations/CylinderedFoldable"}}');var o=t(74848),l=t(28453);const r={},a=void 0,s={},d=[{value:"Cylindered",id:"cylindered",level:2},{value:"actionEventInput",id:"actioneventinput",level:3},{value:"allowLoadMovingToolStates",id:"allowloadmovingtoolstates",level:3},{value:"checkMovingPartDirtyUpdateNode",id:"checkmovingpartdirtyupdatenode",level:3},{value:"getAdditionalSchemaText",id:"getadditionalschematext",level:3},{value:"getConsumingLoad",id:"getconsumingload",level:3},{value:"getDischargeNodeEmptyFactor",id:"getdischargenodeemptyfactor",level:3},{value:"getDoConsumePtoPower",id:"getdoconsumeptopower",level:3},{value:"getIsDynamicMountGrabOpened",id:"getisdynamicmountgrabopened",level:3},{value:"getIsMovingPartActive",id:"getismovingpartactive",level:3},{value:"getIsMovingToolActive",id:"getismovingtoolactive",level:3},{value:"getMovingPartByNode",id:"getmovingpartbynode",level:3},{value:"getMovingToolByNode",id:"getmovingtoolbynode",level:3},{value:"getMovingToolDashboardState",id:"getmovingtooldashboardstate",level:3},{value:"getMovingToolMoveValue",id:"getmovingtoolmovevalue",level:3},{value:"getMovingToolState",id:"getmovingtoolstate",level:3},{value:"getShovelNodeIsActive",id:"getshovelnodeisactive",level:3},{value:"getTranslatingPartByNode",id:"gettranslatingpartbynode",level:3},{value:"getWearMultiplier",id:"getwearmultiplier",level:3},{value:"initSpecialization",id:"initspecialization",level:3},{value:"isDetachAllowed",id:"isdetachallowed",level:3},{value:"limitInterpolator",id:"limitinterpolator",level:3},{value:"loadActionSoundsFromXML",id:"loadactionsoundsfromxml",level:3},{value:"loadCopyLocalDirectionParts",id:"loadcopylocaldirectionparts",level:3},{value:"loadDependentAnimations",id:"loaddependentanimations",level:3},{value:"loadDependentAttacherJoints",id:"loaddependentattacherjoints",level:3},{value:"loadDependentComponentJoints",id:"loaddependentcomponentjoints",level:3},{value:"loadDependentMovingTools",id:"loaddependentmovingtools",level:3},{value:"loadDependentParts",id:"loaddependentparts",level:3},{value:"loadDependentTranslatingParts",id:"loaddependenttranslatingparts",level:3},{value:"loadDependentWheels",id:"loaddependentwheels",level:3},{value:"loadDischargeNode",id:"loaddischargenode",level:3},{value:"loadDynamicMountGrabFromXML",id:"loaddynamicmountgrabfromxml",level:3},{value:"loadEasyArmControlFromXML",id:"loadeasyarmcontrolfromxml",level:3},{value:"loadExtraDependentParts",id:"loadextradependentparts",level:3},{value:"loadMovingPartFromXML",id:"loadmovingpartfromxml",level:3},{value:"loadMovingPartsFromXML",id:"loadmovingpartsfromxml",level:3},{value:"loadMovingToolFromXML",id:"loadmovingtoolfromxml",level:3},{value:"loadMovingToolsFromXML",id:"loadmovingtoolsfromxml",level:3},{value:"loadObjectChangeValuesFromXML",id:"loadobjectchangevaluesfromxml",level:3},{value:"loadRotationBasedLimits",id:"loadrotationbasedlimits",level:3},{value:"loadShovelNode",id:"loadshovelnode",level:3},{value:"movingToolDashboardAttributes",id:"movingtooldashboardattributes",level:3},{value:"onAIImplementStart",id:"onaiimplementstart",level:3},{value:"onAnimationPartChanged",id:"onanimationpartchanged",level:3},{value:"onDeactivate",id:"ondeactivate",level:3},{value:"onDelete",id:"ondelete",level:3},{value:"onDraw",id:"ondraw",level:3},{value:"onLoad",id:"onload",level:3},{value:"onLoadFinished",id:"onloadfinished",level:3},{value:"onMovingPartSoundEvent",id:"onmovingpartsoundevent",level:3},{value:"onPostAttach",id:"onpostattach",level:3},{value:"onPostLoad",id:"onpostload",level:3},{value:"onPostUpdate",id:"onpostupdate",level:3},{value:"onPostUpdateTick",id:"onpostupdatetick",level:3},{value:"onReadStream",id:"onreadstream",level:3},{value:"onReadUpdateStream",id:"onreadupdatestream",level:3},{value:"onRegisterActionEvents",id:"onregisteractionevents",level:3},{value:"onRegisterAnimationValueTypes",id:"onregisteranimationvaluetypes",level:3},{value:"onRegisterDashboardValueTypes",id:"onregisterdashboardvaluetypes",level:3},{value:"onSelect",id:"onselect",level:3},{value:"onUnselect",id:"onunselect",level:3},{value:"onUpdate",id:"onupdate",level:3},{value:"onUpdateEnd",id:"onupdateend",level:3},{value:"onUpdateTick",id:"onupdatetick",level:3},{value:"onVehicleSettingChanged",id:"onvehiclesettingchanged",level:3},{value:"onWriteStream",id:"onwritestream",level:3},{value:"onWriteUpdateStream",id:"onwriteupdatestream",level:3},{value:"prerequisitesPresent",id:"prerequisitespresent",level:3},{value:"registerCopyLocalDirectionXMLPaths",id:"registercopylocaldirectionxmlpaths",level:3},{value:"registerDependentAnimationXMLPaths",id:"registerdependentanimationxmlpaths",level:3},{value:"registerDependentComponentJointXMLPaths",id:"registerdependentcomponentjointxmlpaths",level:3},{value:"registerDependentMovingToolXMLPaths",id:"registerdependentmovingtoolxmlpaths",level:3},{value:"registerEasyArmControlXMLPaths",id:"registereasyarmcontrolxmlpaths",level:3},{value:"registerEventListeners",id:"registereventlisteners",level:3},{value:"registerEvents",id:"registerevents",level:3},{value:"registerFunctions",id:"registerfunctions",level:3},{value:"registerMovingPartXMLPaths",id:"registermovingpartxmlpaths",level:3},{value:"registerMovingToolXMLPaths",id:"registermovingtoolxmlpaths",level:3},{value:"registerOverwrittenFunctions",id:"registeroverwrittenfunctions",level:3},{value:"registerSoundXMLPaths",id:"registersoundxmlpaths",level:3},{value:"resolveDependentPartData",id:"resolvedependentpartdata",level:3},{value:"saveToXMLFile",id:"savetoxmlfile",level:3},{value:"setAbsoluteToolRotation",id:"setabsolutetoolrotation",level:3},{value:"setAbsoluteToolTranslation",id:"setabsolutetooltranslation",level:3},{value:"setComponentJointFrame",id:"setcomponentjointframe",level:3},{value:"setDelayedData",id:"setdelayeddata",level:3},{value:"setDirty",id:"setdirty",level:3},{value:"setEasyControlForcedTransMove",id:"seteasycontrolforcedtransmove",level:3},{value:"setIsEasyControlActive",id:"setiseasycontrolactive",level:3},{value:"setMovingPartReferenceNode",id:"setmovingpartreferencenode",level:3},{value:"setMovingToolDirty",id:"setmovingtooldirty",level:3},{value:"setObjectChangeValues",id:"setobjectchangevalues",level:3},{value:"setToolAnimation",id:"settoolanimation",level:3},{value:"setToolRotation",id:"settoolrotation",level:3},{value:"setToolTranslation",id:"settooltranslation",level:3},{value:"updateAttacherJoints",id:"updateattacherjoints",level:3},{value:"updateComponentJoints",id:"updatecomponentjoints",level:3},{value:"updateControlGroups",id:"updatecontrolgroups",level:3},{value:"updateCylinderedInitial",id:"updatecylinderedinitial",level:3},{value:"updateDelayedTool",id:"updatedelayedtool",level:3},{value:"updateDependentAnimations",id:"updatedependentanimations",level:3},{value:"updateDependentToolLimits",id:"updatedependenttoollimits",level:3},{value:"updateDirtyMovingParts",id:"updatedirtymovingparts",level:3},{value:"updateEasyControl",id:"updateeasycontrol",level:3},{value:"updateExtraDependentParts",id:"updateextradependentparts",level:3},{value:"updateMovingPart",id:"updatemovingpart",level:3},{value:"updateMovingPartByNode",id:"updatemovingpartbynode",level:3},{value:"updateMovingToolSoundEvents",id:"updatemovingtoolsoundevents",level:3},{value:"updateRotationBasedLimits",id:"updaterotationbasedlimits",level:3},{value:"updateWheels",id:"updatewheels",level:3}];function c(n){const e={a:"a",blockquote:"blockquote",code:"code",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,l.R)(),...n.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(e.h2,{id:"cylindered",children:"Cylindered"}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Description"})}),"\n",(0,o.jsxs)(e.blockquote,{children:["\n",(0,o.jsx)(e.p,{children:"Specialization for vehicles with dependent movable parts (e.g. cylinders)"}),"\n"]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Functions"})}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsx)(e.li,{children:(0,o.jsx)(e.a,{href:"#actioneventinput",children:"actionEventInput"})}),"\n",(0,o.jsx)(e.li,{children:(0,o.jsx)(e.a,{href:"#allowloadmovingtoolstates",children:"allowLoadMovingToolStates"})}),"\n",(0,o.jsx)(e.li,{children:(0,o.jsx)(e.a,{href:"#checkmovingpartdirtyupdatenode",children:"checkMovingPartDirtyUpdateNode"})}),"\n",(0,o.jsx)(e.li,{children:(0,o.jsx)(e.a,{href:"#getadditionalschematext",children:"getAdditionalSchemaText"})}),"\n",(0,o.jsx)(e.li,{children:(0,o.jsx)(e.a,{href:"#getconsumingload",children:"getConsumingLoad"})}),"\n",(0,o.jsx)(e.li,{children:(0,o.jsx)(e.a,{href:"#getdischargenodeemptyfactor",children:"getDischargeNodeEmptyFactor"})}),"\n",(0,o.jsx)(e.li,{children:(0,o.jsx)(e.a,{href:"#getdoconsumeptopower",children:"getDoConsumePtoPower"})}),"\n",(0,o.jsx)(e.li,{children:(0,o.jsx)(e.a,{href:"#getisdynamicmountgrabopened",children:"getIsDynamicMountGrabOpened"})}),"\n",(0,o.jsx)(e.li,{children:(0,o.jsx)(e.a,{href:"#getismovingpartactive",children:"getIsMovingPartActive"})}),"\n",(0,o.jsx)(e.li,{children:(0,o.jsx)(e.a,{href:"#getismovingtoolactive",children:"getIsMovingToolActive"})}),"\n",(0,o.jsx)(e.li,{children:(0,o.jsx)(e.a,{href:"#getmovingpartbynode",children:"getMovingPartByNode"})}),"\n",(0,o.jsx)(e.li,{children:(0,o.jsx)(e.a,{href:"#getmovingtoolbynode",children:"getMovingToolByNode"})}),"\n",(0,o.jsx)(e.li,{children:(0,o.jsx)(e.a,{href:"#getmovingtooldashboardstate",children:"getMovingToolDashboardState"})}),"\n",(0,o.jsx)(e.li,{children:(0,o.jsx)(e.a,{href:"#getmovingtoolmovevalue",children:"getMovingToolMoveValue"})}),"\n",(0,o.jsx)(e.li,{children:(0,o.jsx)(e.a,{href:"#getmovingtoolstate",children:"getMovingToolState"})}),"\n",(0,o.jsx)(e.li,{children:(0,o.jsx)(e.a,{href:"#getshovelnodeisactive",children:"getShovelNodeIsActive"})}),"\n",(0,o.jsx)(e.li,{children:(0,o.jsx)(e.a,{href:"#gettranslatingpartbynode",children:"getTranslatingPartByNode"})}),"\n",(0,o.jsx)(e.li,{children:(0,o.jsx)(e.a,{href:"#getwearmultiplier",children:"getWearMultiplier"})}),"\n",(0,o.jsx)(e.li,{children:(0,o.jsx)(e.a,{href:"#initspecialization",children:"initSpecialization"})}),"\n",(0,o.jsx)(e.li,{children:(0,o.jsx)(e.a,{href:"#isdetachallowed",children:"isDetachAllowed"})}),"\n",(0,o.jsx)(e.li,{children:(0,o.jsx)(e.a,{href:"#limitinterpolator",children:"limitInterpolator"})}),"\n",(0,o.jsx)(e.li,{children:(0,o.jsx)(e.a,{href:"#loadactionsoundsfromxml",children:"loadActionSoundsFromXML"})}),"\n",(0,o.jsx)(e.li,{children:(0,o.jsx)(e.a,{href:"#loadcopylocaldirectionparts",children:"loadCopyLocalDirectionParts"})}),"\n",(0,o.jsx)(e.li,{children:(0,o.jsx)(e.a,{href:"#loaddependentanimations",children:"loadDependentAnimations"})}),"\n",(0,o.jsx)(e.li,{children:(0,o.jsx)(e.a,{href:"#loaddependentattacherjoints",children:"loadDependentAttacherJoints"})}),"\n",(0,o.jsx)(e.li,{children:(0,o.jsx)(e.a,{href:"#loaddependentcomponentjoints",children:"loadDependentComponentJoints"})}),"\n",(0,o.jsx)(e.li,{children:(0,o.jsx)(e.a,{href:"#loaddependentmovingtools",children:"loadDependentMovingTools"})}),"\n",(0,o.jsx)(e.li,{children:(0,o.jsx)(e.a,{href:"#loaddependentparts",children:"loadDependentParts"})}),"\n",(0,o.jsx)(e.li,{children:(0,o.jsx)(e.a,{href:"#loaddependenttranslatingparts",children:"loadDependentTranslatingParts"})}),"\n",(0,o.jsx)(e.li,{children:(0,o.jsx)(e.a,{href:"#loaddependentwheels",children:"loadDependentWheels"})}),"\n",(0,o.jsx)(e.li,{children:(0,o.jsx)(e.a,{href:"#loaddischargenode",children:"loadDischargeNode"})}),"\n",(0,o.jsx)(e.li,{children:(0,o.jsx)(e.a,{href:"#loaddynamicmountgrabfromxml",children:"loadDynamicMountGrabFromXML"})}),"\n",(0,o.jsx)(e.li,{children:(0,o.jsx)(e.a,{href:"#loadeasyarmcontrolfromxml",children:"loadEasyArmControlFromXML"})}),"\n",(0,o.jsx)(e.li,{children:(0,o.jsx)(e.a,{href:"#loadextradependentparts",children:"loadExtraDependentParts"})}),"\n",(0,o.jsx)(e.li,{children:(0,o.jsx)(e.a,{href:"#loadmovingpartfromxml",children:"loadMovingPartFromXML"})}),"\n",(0,o.jsx)(e.li,{children:(0,o.jsx)(e.a,{href:"#loadmovingpartsfromxml",children:"loadMovingPartsFromXML"})}),"\n",(0,o.jsx)(e.li,{children:(0,o.jsx)(e.a,{href:"#loadmovingtoolfromxml",children:"loadMovingToolFromXML"})}),"\n",(0,o.jsx)(e.li,{children:(0,o.jsx)(e.a,{href:"#loadmovingtoolsfromxml",children:"loadMovingToolsFromXML"})}),"\n",(0,o.jsx)(e.li,{children:(0,o.jsx)(e.a,{href:"#loadobjectchangevaluesfromxml",children:"loadObjectChangeValuesFromXML"})}),"\n",(0,o.jsx)(e.li,{children:(0,o.jsx)(e.a,{href:"#loadrotationbasedlimits",children:"loadRotationBasedLimits"})}),"\n",(0,o.jsx)(e.li,{children:(0,o.jsx)(e.a,{href:"#loadshovelnode",children:"loadShovelNode"})}),"\n",(0,o.jsx)(e.li,{children:(0,o.jsx)(e.a,{href:"#movingtooldashboardattributes",children:"movingToolDashboardAttributes"})}),"\n",(0,o.jsx)(e.li,{children:(0,o.jsx)(e.a,{href:"#onaiimplementstart",children:"onAIImplementStart"})}),"\n",(0,o.jsx)(e.li,{children:(0,o.jsx)(e.a,{href:"#onanimationpartchanged",children:"onAnimationPartChanged"})}),"\n",(0,o.jsx)(e.li,{children:(0,o.jsx)(e.a,{href:"#ondeactivate",children:"onDeactivate"})}),"\n",(0,o.jsx)(e.li,{children:(0,o.jsx)(e.a,{href:"#ondelete",children:"onDelete"})}),"\n",(0,o.jsx)(e.li,{children:(0,o.jsx)(e.a,{href:"#ondraw",children:"onDraw"})}),"\n",(0,o.jsx)(e.li,{children:(0,o.jsx)(e.a,{href:"#onload",children:"onLoad"})}),"\n",(0,o.jsx)(e.li,{children:(0,o.jsx)(e.a,{href:"#onloadfinished",children:"onLoadFinished"})}),"\n",(0,o.jsx)(e.li,{children:(0,o.jsx)(e.a,{href:"#onmovingpartsoundevent",children:"onMovingPartSoundEvent"})}),"\n",(0,o.jsx)(e.li,{children:(0,o.jsx)(e.a,{href:"#onpostattach",children:"onPostAttach"})}),"\n",(0,o.jsx)(e.li,{children:(0,o.jsx)(e.a,{href:"#onpostload",children:"onPostLoad"})}),"\n",(0,o.jsx)(e.li,{children:(0,o.jsx)(e.a,{href:"#onpostupdate",children:"onPostUpdate"})}),"\n",(0,o.jsx)(e.li,{children:(0,o.jsx)(e.a,{href:"#onpostupdatetick",children:"onPostUpdateTick"})}),"\n",(0,o.jsx)(e.li,{children:(0,o.jsx)(e.a,{href:"#onreadstream",children:"onReadStream"})}),"\n",(0,o.jsx)(e.li,{children:(0,o.jsx)(e.a,{href:"#onreadupdatestream",children:"onReadUpdateStream"})}),"\n",(0,o.jsx)(e.li,{children:(0,o.jsx)(e.a,{href:"#onregisteractionevents",children:"onRegisterActionEvents"})}),"\n",(0,o.jsx)(e.li,{children:(0,o.jsx)(e.a,{href:"#onregisteranimationvaluetypes",children:"onRegisterAnimationValueTypes"})}),"\n",(0,o.jsx)(e.li,{children:(0,o.jsx)(e.a,{href:"#onregisterdashboardvaluetypes",children:"onRegisterDashboardValueTypes"})}),"\n",(0,o.jsx)(e.li,{children:(0,o.jsx)(e.a,{href:"#onselect",children:"onSelect"})}),"\n",(0,o.jsx)(e.li,{children:(0,o.jsx)(e.a,{href:"#onunselect",children:"onUnselect"})}),"\n",(0,o.jsx)(e.li,{children:(0,o.jsx)(e.a,{href:"#onupdate",children:"onUpdate"})}),"\n",(0,o.jsx)(e.li,{children:(0,o.jsx)(e.a,{href:"#onupdateend",children:"onUpdateEnd"})}),"\n",(0,o.jsx)(e.li,{children:(0,o.jsx)(e.a,{href:"#onupdatetick",children:"onUpdateTick"})}),"\n",(0,o.jsx)(e.li,{children:(0,o.jsx)(e.a,{href:"#onvehiclesettingchanged",children:"onVehicleSettingChanged"})}),"\n",(0,o.jsx)(e.li,{children:(0,o.jsx)(e.a,{href:"#onwritestream",children:"onWriteStream"})}),"\n",(0,o.jsx)(e.li,{children:(0,o.jsx)(e.a,{href:"#onwriteupdatestream",children:"onWriteUpdateStream"})}),"\n",(0,o.jsx)(e.li,{children:(0,o.jsx)(e.a,{href:"#prerequisitespresent",children:"prerequisitesPresent"})}),"\n",(0,o.jsx)(e.li,{children:(0,o.jsx)(e.a,{href:"#registercopylocaldirectionxmlpaths",children:"registerCopyLocalDirectionXMLPaths"})}),"\n",(0,o.jsx)(e.li,{children:(0,o.jsx)(e.a,{href:"#registerdependentanimationxmlpaths",children:"registerDependentAnimationXMLPaths"})}),"\n",(0,o.jsx)(e.li,{children:(0,o.jsx)(e.a,{href:"#registerdependentcomponentjointxmlpaths",children:"registerDependentComponentJointXMLPaths"})}),"\n",(0,o.jsx)(e.li,{children:(0,o.jsx)(e.a,{href:"#registerdependentmovingtoolxmlpaths",children:"registerDependentMovingToolXMLPaths"})}),"\n",(0,o.jsx)(e.li,{children:(0,o.jsx)(e.a,{href:"#registereasyarmcontrolxmlpaths",children:"registerEasyArmControlXMLPaths"})}),"\n",(0,o.jsx)(e.li,{children:(0,o.jsx)(e.a,{href:"#registereventlisteners",children:"registerEventListeners"})}),"\n",(0,o.jsx)(e.li,{children:(0,o.jsx)(e.a,{href:"#registerevents",children:"registerEvents"})}),"\n",(0,o.jsx)(e.li,{children:(0,o.jsx)(e.a,{href:"#registerfunctions",children:"registerFunctions"})}),"\n",(0,o.jsx)(e.li,{children:(0,o.jsx)(e.a,{href:"#registermovingpartxmlpaths",children:"registerMovingPartXMLPaths"})}),"\n",(0,o.jsx)(e.li,{children:(0,o.jsx)(e.a,{href:"#registermovingtoolxmlpaths",children:"registerMovingToolXMLPaths"})}),"\n",(0,o.jsx)(e.li,{children:(0,o.jsx)(e.a,{href:"#registeroverwrittenfunctions",children:"registerOverwrittenFunctions"})}),"\n",(0,o.jsx)(e.li,{children:(0,o.jsx)(e.a,{href:"#registersoundxmlpaths",children:"registerSoundXMLPaths"})}),"\n",(0,o.jsx)(e.li,{children:(0,o.jsx)(e.a,{href:"#resolvedependentpartdata",children:"resolveDependentPartData"})}),"\n",(0,o.jsx)(e.li,{children:(0,o.jsx)(e.a,{href:"#savetoxmlfile",children:"saveToXMLFile"})}),"\n",(0,o.jsx)(e.li,{children:(0,o.jsx)(e.a,{href:"#setabsolutetoolrotation",children:"setAbsoluteToolRotation"})}),"\n",(0,o.jsx)(e.li,{children:(0,o.jsx)(e.a,{href:"#setabsolutetooltranslation",children:"setAbsoluteToolTranslation"})}),"\n",(0,o.jsx)(e.li,{children:(0,o.jsx)(e.a,{href:"#setcomponentjointframe",children:"setComponentJointFrame"})}),"\n",(0,o.jsx)(e.li,{children:(0,o.jsx)(e.a,{href:"#setdelayeddata",children:"setDelayedData"})}),"\n",(0,o.jsx)(e.li,{children:(0,o.jsx)(e.a,{href:"#setdirty",children:"setDirty"})}),"\n",(0,o.jsx)(e.li,{children:(0,o.jsx)(e.a,{href:"#seteasycontrolforcedtransmove",children:"setEasyControlForcedTransMove"})}),"\n",(0,o.jsx)(e.li,{children:(0,o.jsx)(e.a,{href:"#setiseasycontrolactive",children:"setIsEasyControlActive"})}),"\n",(0,o.jsx)(e.li,{children:(0,o.jsx)(e.a,{href:"#setmovingpartreferencenode",children:"setMovingPartReferenceNode"})}),"\n",(0,o.jsx)(e.li,{children:(0,o.jsx)(e.a,{href:"#setmovingtooldirty",children:"setMovingToolDirty"})}),"\n",(0,o.jsx)(e.li,{children:(0,o.jsx)(e.a,{href:"#setobjectchangevalues",children:"setObjectChangeValues"})}),"\n",(0,o.jsx)(e.li,{children:(0,o.jsx)(e.a,{href:"#settoolanimation",children:"setToolAnimation"})}),"\n",(0,o.jsx)(e.li,{children:(0,o.jsx)(e.a,{href:"#settoolrotation",children:"setToolRotation"})}),"\n",(0,o.jsx)(e.li,{children:(0,o.jsx)(e.a,{href:"#settooltranslation",children:"setToolTranslation"})}),"\n",(0,o.jsx)(e.li,{children:(0,o.jsx)(e.a,{href:"#updateattacherjoints",children:"updateAttacherJoints"})}),"\n",(0,o.jsx)(e.li,{children:(0,o.jsx)(e.a,{href:"#updatecomponentjoints",children:"updateComponentJoints"})}),"\n",(0,o.jsx)(e.li,{children:(0,o.jsx)(e.a,{href:"#updatecontrolgroups",children:"updateControlGroups"})}),"\n",(0,o.jsx)(e.li,{children:(0,o.jsx)(e.a,{href:"#updatecylinderedinitial",children:"updateCylinderedInitial"})}),"\n",(0,o.jsx)(e.li,{children:(0,o.jsx)(e.a,{href:"#updatedelayedtool",children:"updateDelayedTool"})}),"\n",(0,o.jsx)(e.li,{children:(0,o.jsx)(e.a,{href:"#updatedependentanimations",children:"updateDependentAnimations"})}),"\n",(0,o.jsx)(e.li,{children:(0,o.jsx)(e.a,{href:"#updatedependenttoollimits",children:"updateDependentToolLimits"})}),"\n",(0,o.jsx)(e.li,{children:(0,o.jsx)(e.a,{href:"#updatedirtymovingparts",children:"updateDirtyMovingParts"})}),"\n",(0,o.jsx)(e.li,{children:(0,o.jsx)(e.a,{href:"#updateeasycontrol",children:"updateEasyControl"})}),"\n",(0,o.jsx)(e.li,{children:(0,o.jsx)(e.a,{href:"#updateextradependentparts",children:"updateExtraDependentParts"})}),"\n",(0,o.jsx)(e.li,{children:(0,o.jsx)(e.a,{href:"#updatemovingpart",children:"updateMovingPart"})}),"\n",(0,o.jsx)(e.li,{children:(0,o.jsx)(e.a,{href:"#updatemovingpartbynode",children:"updateMovingPartByNode"})}),"\n",(0,o.jsx)(e.li,{children:(0,o.jsx)(e.a,{href:"#updatemovingtoolsoundevents",children:"updateMovingToolSoundEvents"})}),"\n",(0,o.jsx)(e.li,{children:(0,o.jsx)(e.a,{href:"#updaterotationbasedlimits",children:"updateRotationBasedLimits"})}),"\n",(0,o.jsx)(e.li,{children:(0,o.jsx)(e.a,{href:"#updatewheels",children:"updateWheels"})}),"\n"]}),"\n",(0,o.jsx)(e.h3,{id:"actioneventinput",children:"actionEventInput"}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Description"})}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Definition"})}),"\n",(0,o.jsxs)(e.blockquote,{children:["\n",(0,o.jsx)(e.p,{children:"actionEventInput()"}),"\n"]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,o.jsxs)(e.table,{children:[(0,o.jsx)(e.thead,{children:(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.th,{children:"any"}),(0,o.jsx)(e.th,{children:"self"})]})}),(0,o.jsxs)(e.tbody,{children:[(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.td,{children:"any"}),(0,o.jsx)(e.td,{children:"actionName"})]}),(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.td,{children:"any"}),(0,o.jsx)(e.td,{children:"inputValue"})]}),(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.td,{children:"any"}),(0,o.jsx)(e.td,{children:"callbackState"})]}),(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.td,{children:"any"}),(0,o.jsx)(e.td,{children:"isAnalog"})]}),(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.td,{children:"any"}),(0,o.jsx)(e.td,{children:"isMouse"})]})]})]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Code"})}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-lua",children:"function Cylindered.actionEventInput( self , actionName, inputValue, callbackState, isAnalog, isMouse)\n    local spec = self.spec_cylindered\n    local tool = spec.movingTools[callbackState]\n\n    if tool ~ = nil then\n        tool.lastInputTime = g_ time\n\n        local move\n        if tool.invertAxis then\n            move = - inputValue\n        else\n                move = inputValue\n            end\n\n            move = move * g_gameSettings:getValue(GameSettings.SETTING.VEHICLE_ARM_SENSITIVITY)\n            if isMouse then\n                -- revert dt scaling for mouse input\n                    move = move * 16.666 / g_currentDt * tool.mouseSpeedFactor\n\n                    -- allow only the input of the highest mouse axis value\n                    -- lock the move of the lower mouse axis value until it is higher than 0.75 or the value is higher than the doubled value of the other tool\n                    if tool.moveLocked then\n                        if math.abs(inputValue) < 0.75 then\n                            if math.abs(move) > math.abs(tool.lockTool.move) * 2 then\n                                tool.moveLocked = false\n                            else\n                                    move = 0\n                                end\n                            else\n                                    tool.moveLocked = false\n                                end\n                            else\n                                    local checkOtherTools = function (tools)\n                                        for tool2Index, tool2 in ipairs(tools) do\n                                            if tool2Index ~ = callbackState then\n                                                if tool2.move ~ = nil and tool2.move ~ = 0 then\n                                                    if math.abs(move) > math.abs(tool2.move) then\n                                                        tool2.move = 0\n                                                        tool2.moveToSend = 0\n                                                        tool2.moveLocked = true\n                                                        tool2.lockTool = tool\n                                                    else\n                                                            move = 0\n                                                            tool.moveLocked = true\n                                                            tool.lockTool = tool2\n                                                        end\n                                                    end\n                                                end\n                                            end\n                                        end\n\n                                        checkOtherTools(spec.movingTools)\n\n                                        if self.getAttachedImplements ~ = nil then\n                                            for _, implement in pairs( self:getAttachedImplements()) do\n                                                local vehicle = implement.object\n                                                if vehicle.spec_cylindered ~ = nil then\n                                                    checkOtherTools(vehicle.spec_cylindered.movingTools)\n                                                end\n                                            end\n                                        end\n                                    end\n                                end\n\n                                if move ~ = tool.move then\n                                    tool.move = move\n                                end\n\n                                if tool.move ~ = tool.moveToSend then\n                                    tool.moveToSend = tool.move\n                                    self:raiseDirtyFlags(spec.cylinderedInputDirtyFlag)\n                                end\n\n                                tool.smoothedMove = tool.smoothedMove * 0.9 + move * 0.1\n                            end\n                        end\n\n"})}),"\n",(0,o.jsx)(e.h3,{id:"allowloadmovingtoolstates",children:"allowLoadMovingToolStates"}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Description"})}),"\n",(0,o.jsxs)(e.blockquote,{children:["\n",(0,o.jsx)(e.p,{children:"Returns if loading of moving tool stats from savegame is allowed"}),"\n"]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Definition"})}),"\n",(0,o.jsxs)(e.blockquote,{children:["\n",(0,o.jsx)(e.p,{children:"allowLoadMovingToolStates()"}),"\n"]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,o.jsx)(e.table,{children:(0,o.jsx)(e.thead,{children:(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.th,{children:"any"}),(0,o.jsx)(e.th,{children:"superFunc"})]})})}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Return Values"})}),"\n\n\n\n\n\n\n\n\n",(0,o.jsx)(e.table,{children:(0,o.jsx)(e.thead,{children:(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.th,{children:"any"}),(0,o.jsx)(e.th,{children:"isAllowed"}),(0,o.jsx)(e.th,{children:"is allowed"})]})})}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Code"})}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-lua",children:"function Cylindered:allowLoadMovingToolStates(superFunc)\n    return true\nend\n\n"})}),"\n",(0,o.jsx)(e.h3,{id:"checkmovingpartdirtyupdatenode",children:"checkMovingPartDirtyUpdateNode"}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Description"})}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Definition"})}),"\n",(0,o.jsxs)(e.blockquote,{children:["\n",(0,o.jsx)(e.p,{children:"checkMovingPartDirtyUpdateNode()"}),"\n"]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,o.jsxs)(e.table,{children:[(0,o.jsx)(e.thead,{children:(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.th,{children:"any"}),(0,o.jsx)(e.th,{children:"node"})]})}),(0,o.jsx)(e.tbody,{children:(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.td,{children:"any"}),(0,o.jsx)(e.td,{children:"movingPart"})]})})]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Code"})}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-lua",children:"function Cylindered:checkMovingPartDirtyUpdateNode(node, movingPart)\nend\n\n"})}),"\n",(0,o.jsx)(e.h3,{id:"getadditionalschematext",children:"getAdditionalSchemaText"}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Description"})}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Definition"})}),"\n",(0,o.jsxs)(e.blockquote,{children:["\n",(0,o.jsx)(e.p,{children:"getAdditionalSchemaText()"}),"\n"]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,o.jsx)(e.table,{children:(0,o.jsx)(e.thead,{children:(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.th,{children:"any"}),(0,o.jsx)(e.th,{children:"superFunc"})]})})}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Code"})}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-lua",children:"function Cylindered:getAdditionalSchemaText(superFunc)\n    local t = superFunc( self )\n    if self.isClient then\n        if self:getIsActiveForInput( true ) then\n            local spec = self.spec_cylindered\n            if #spec.controlGroupNames > 1 and spec.currentControlGroupIndex ~ = 0 then\n                t = tostring(spec.currentControlGroupIndex)\n            end\n        end\n    end\n\n    return t\nend\n\n"})}),"\n",(0,o.jsx)(e.h3,{id:"getconsumingload",children:"getConsumingLoad"}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Description"})}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Definition"})}),"\n",(0,o.jsxs)(e.blockquote,{children:["\n",(0,o.jsx)(e.p,{children:"getConsumingLoad()"}),"\n"]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,o.jsx)(e.table,{children:(0,o.jsx)(e.thead,{children:(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.th,{children:"any"}),(0,o.jsx)(e.th,{children:"superFunc"})]})})}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Code"})}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-lua",children:"function Cylindered:getConsumingLoad(superFunc)\n    local value, count = superFunc( self )\n\n    local spec = self.spec_cylindered\n    local loadPercentage = math.max(spec.powerConsumingTimer / spec.powerConsumingActiveTimeOffset, 0 )\n    return value + loadPercentage, count + 1\nend\n\n"})}),"\n",(0,o.jsx)(e.h3,{id:"getdischargenodeemptyfactor",children:"getDischargeNodeEmptyFactor"}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Description"})}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Definition"})}),"\n",(0,o.jsxs)(e.blockquote,{children:["\n",(0,o.jsx)(e.p,{children:"getDischargeNodeEmptyFactor()"}),"\n"]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,o.jsxs)(e.table,{children:[(0,o.jsx)(e.thead,{children:(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.th,{children:"any"}),(0,o.jsx)(e.th,{children:"superFunc"})]})}),(0,o.jsx)(e.tbody,{children:(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.td,{children:"any"}),(0,o.jsx)(e.td,{children:"dischargeNode"})]})})]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Code"})}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-lua",children:"function Cylindered:getDischargeNodeEmptyFactor(superFunc, dischargeNode)\n    if dischargeNode.movingToolActivation = = nil then\n        return superFunc( self , dischargeNode)\n    else\n            local spec = self.spec_cylindered\n            local movingToolActivation = dischargeNode.movingToolActivation\n\n            local currentSpeed = superFunc( self , dischargeNode)\n\n            local movingTool = spec.nodesToMovingTools[movingToolActivation.node]\n            local state = math.clamp( Cylindered.getMovingToolState( self , movingTool), 0 , 1 )\n            if movingToolActivation.isInverted then\n                state = math.abs(state - 1 )\n            end\n\n            state = math.max(state - movingToolActivation.openOffset, 0 ) / movingToolActivation.openOffsetInv\n            local speedFactor = math.clamp(state / movingToolActivation.openFactor, 0 , 1 )\n\n            return currentSpeed * speedFactor\n        end\n    end\n\n"})}),"\n",(0,o.jsx)(e.h3,{id:"getdoconsumeptopower",children:"getDoConsumePtoPower"}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Description"})}),"\n",(0,o.jsxs)(e.blockquote,{children:["\n",(0,o.jsx)(e.p,{children:"Returns if should consume pto power"}),"\n"]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Definition"})}),"\n",(0,o.jsxs)(e.blockquote,{children:["\n",(0,o.jsx)(e.p,{children:"getDoConsumePtoPower()"}),"\n"]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,o.jsx)(e.table,{children:(0,o.jsx)(e.thead,{children:(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.th,{children:"any"}),(0,o.jsx)(e.th,{children:"superFunc"})]})})}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Return Values"})}),"\n\n\n\n\n\n\n\n\n",(0,o.jsx)(e.table,{children:(0,o.jsx)(e.thead,{children:(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.th,{children:"any"}),(0,o.jsx)(e.th,{children:"consume"}),(0,o.jsx)(e.th,{children:"consumePtoPower"})]})})}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Code"})}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-lua",children:"function Cylindered:getDoConsumePtoPower(superFunc)\n    return superFunc( self ) or self.spec_cylindered.powerConsumingTimer > 0\nend\n\n"})}),"\n",(0,o.jsx)(e.h3,{id:"getisdynamicmountgrabopened",children:"getIsDynamicMountGrabOpened"}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Description"})}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Definition"})}),"\n",(0,o.jsxs)(e.blockquote,{children:["\n",(0,o.jsx)(e.p,{children:"getIsDynamicMountGrabOpened()"}),"\n"]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,o.jsxs)(e.table,{children:[(0,o.jsx)(e.thead,{children:(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.th,{children:"any"}),(0,o.jsx)(e.th,{children:"superFunc"})]})}),(0,o.jsx)(e.tbody,{children:(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.td,{children:"any"}),(0,o.jsx)(e.td,{children:"grab"})]})})]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Code"})}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-lua",children:"function Cylindered:getIsDynamicMountGrabOpened(superFunc, grab)\n    local isActive = superFunc( self , grab)\n    if not isActive or grab.movingToolActivation = = nil then\n        return isActive\n    end\n\n    local spec = self.spec_cylindered\n    local movingToolActivation = grab.movingToolActivation\n    local movingTool = spec.nodesToMovingTools[movingToolActivation.node]\n    local state = Cylindered.getMovingToolState( self , movingTool)\n    if movingToolActivation.isInverted then\n        state = math.abs(state - 1 )\n    end\n\n    return state > movingToolActivation.openFactor\nend\n\n"})}),"\n",(0,o.jsx)(e.h3,{id:"getismovingpartactive",children:"getIsMovingPartActive"}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Description"})}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Definition"})}),"\n",(0,o.jsxs)(e.blockquote,{children:["\n",(0,o.jsx)(e.p,{children:"getIsMovingPartActive()"}),"\n"]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,o.jsx)(e.table,{children:(0,o.jsx)(e.thead,{children:(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.th,{children:"any"}),(0,o.jsx)(e.th,{children:"movingPart"})]})})}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Code"})}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-lua",children:"function Cylindered:getIsMovingPartActive(movingPart)\n    return movingPart.isActive\nend\n\n"})}),"\n",(0,o.jsx)(e.h3,{id:"getismovingtoolactive",children:"getIsMovingToolActive"}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Description"})}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Definition"})}),"\n",(0,o.jsxs)(e.blockquote,{children:["\n",(0,o.jsx)(e.p,{children:"getIsMovingToolActive()"}),"\n"]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,o.jsx)(e.table,{children:(0,o.jsx)(e.thead,{children:(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.th,{children:"any"}),(0,o.jsx)(e.th,{children:"movingTool"})]})})}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Code"})}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-lua",children:"function Cylindered:getIsMovingToolActive(movingTool)\n    return movingTool.isActive and movingTool.hasRequiredConfigurations\nend\n\n"})}),"\n",(0,o.jsx)(e.h3,{id:"getmovingpartbynode",children:"getMovingPartByNode"}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Description"})}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Definition"})}),"\n",(0,o.jsxs)(e.blockquote,{children:["\n",(0,o.jsx)(e.p,{children:"getMovingPartByNode()"}),"\n"]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,o.jsx)(e.table,{children:(0,o.jsx)(e.thead,{children:(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.th,{children:"any"}),(0,o.jsx)(e.th,{children:"node"})]})})}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Code"})}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-lua",children:"function Cylindered:getMovingPartByNode(node)\n    return self.spec_cylindered.nodesToMovingParts[node]\nend\n\n"})}),"\n",(0,o.jsx)(e.h3,{id:"getmovingtoolbynode",children:"getMovingToolByNode"}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Description"})}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Definition"})}),"\n",(0,o.jsxs)(e.blockquote,{children:["\n",(0,o.jsx)(e.p,{children:"getMovingToolByNode()"}),"\n"]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,o.jsx)(e.table,{children:(0,o.jsx)(e.thead,{children:(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.th,{children:"any"}),(0,o.jsx)(e.th,{children:"node"})]})})}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Code"})}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-lua",children:"function Cylindered:getMovingToolByNode(node)\n    return self.spec_cylindered.nodesToMovingTools[node]\nend\n\n"})}),"\n",(0,o.jsx)(e.h3,{id:"getmovingtooldashboardstate",children:"getMovingToolDashboardState"}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Description"})}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Definition"})}),"\n",(0,o.jsxs)(e.blockquote,{children:["\n",(0,o.jsx)(e.p,{children:"getMovingToolDashboardState()"}),"\n"]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,o.jsxs)(e.table,{children:[(0,o.jsx)(e.thead,{children:(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.th,{children:"any"}),(0,o.jsx)(e.th,{children:"self"})]})}),(0,o.jsx)(e.tbody,{children:(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.td,{children:"any"}),(0,o.jsx)(e.td,{children:"dashboard"})]})})]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Code"})}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-lua",children:"function Cylindered.getMovingToolDashboardState( self , dashboard)\n    local vehicle = self\n\n    if dashboard.attacherJointNodes ~ = nil then\n        if dashboard.attacherJointIndices = = nil then\n            dashboard.attacherJointIndices = { }\n        end\n\n        for _, node in ipairs(dashboard.attacherJointNodes) do\n            local index = self:getAttacherJointIndexByNode(node)\n            if index ~ = nil then\n                table.insert(dashboard.attacherJointIndices, index)\n            end\n        end\n\n        dashboard.attacherJointNodes = nil\n        if #dashboard.attacherJointIndices = = 0 then\n            dashboard.attacherJointIndices = nil\n        end\n    end\n\n    if dashboard.attacherJointIndices ~ = nil then\n        vehicle = nil\n        for _, index in ipairs(dashboard.attacherJointIndices) do\n            local implement = self:getImplementFromAttacherJointIndex(index)\n            if implement ~ = nil then\n                vehicle = implement.object\n                break\n            end\n        end\n    end\n\n    if vehicle ~ = nil then\n        local spec = vehicle.spec_cylindered\n        if spec ~ = nil then\n            for _, movingTool in ipairs(spec.movingTools) do\n                if movingTool.axis = = dashboard.axis then\n                    local isSelectedGroup = movingTool.controlGroupIndex = = 0 or movingTool.controlGroupIndex = = spec.currentControlGroupIndex\n                    local easyArmControlActive = false\n                    if spec.easyArmControl ~ = nil then\n                        easyArmControlActive = spec.easyArmControl.state\n                    end\n                    local canBeControlled = (easyArmControlActive and movingTool.easyArmControlActive) or( not easyArmControlActive and not movingTool.isEasyControlTarget)\n                    if isSelectedGroup and canBeControlled then\n                        return(movingTool.smoothedMove + 1 ) / 2\n                    end\n                end\n            end\n        end\n    end\n\n    return 0.5\nend\n\n"})}),"\n",(0,o.jsx)(e.h3,{id:"getmovingtoolmovevalue",children:"getMovingToolMoveValue"}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Description"})}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Definition"})}),"\n",(0,o.jsxs)(e.blockquote,{children:["\n",(0,o.jsx)(e.p,{children:"getMovingToolMoveValue()"}),"\n"]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,o.jsx)(e.table,{children:(0,o.jsx)(e.thead,{children:(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.th,{children:"any"}),(0,o.jsx)(e.th,{children:"movingTool"})]})})}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Code"})}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-lua",children:"function Cylindered:getMovingToolMoveValue(movingTool)\n    return movingTool.move + movingTool.externalMove\nend\n\n"})}),"\n",(0,o.jsx)(e.h3,{id:"getmovingtoolstate",children:"getMovingToolState"}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Description"})}),"\n",(0,o.jsxs)(e.blockquote,{children:["\n",(0,o.jsx)(e.p,{children:"Returns moving tool state"}),"\n"]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Definition"})}),"\n",(0,o.jsxs)(e.blockquote,{children:["\n",(0,o.jsx)(e.p,{children:"getMovingToolState(table tool, )"}),"\n"]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,o.jsxs)(e.table,{children:[(0,o.jsx)(e.thead,{children:(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.th,{children:"table"}),(0,o.jsx)(e.th,{children:"tool"}),(0,o.jsx)(e.th,{children:"tool"})]})}),(0,o.jsx)(e.tbody,{children:(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.td,{children:"any"}),(0,o.jsx)(e.td,{children:"tool"}),(0,o.jsx)(e.td,{})]})})]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Return Values"})}),"\n\n\n\n\n\n\n\n\n",(0,o.jsx)(e.table,{children:(0,o.jsx)(e.thead,{children:(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.th,{children:"any"}),(0,o.jsx)(e.th,{children:"state"}),(0,o.jsx)(e.th,{children:"state of moving tool [0..1]"})]})})}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Code"})}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-lua",children:"function Cylindered.getMovingToolState( self , tool)\n    local state = 0\n    if tool.rotMax ~ = nil and tool.rotMin ~ = nil then\n        state = (tool.curRot[tool.rotationAxis] - tool.rotMin) / (tool.rotMax - tool.rotMin)\n    elseif tool.rotSpeed ~ = nil then\n            state = tool.curRot[tool.rotationAxis]\n        elseif tool.transMax ~ = nil and tool.transMin ~ = nil then\n                state = (tool.curTrans[tool.translationAxis] - tool.transMin) / (tool.transMax - tool.transMin)\n            elseif tool.transSpeed ~ = nil then\n                    state = tool.curTrans[tool.translationAxis]\n                elseif tool.animName ~ = nil then\n                        return self:getAnimationTime(tool.animName)\n                    end\n\n                    return state\n                end\n\n"})}),"\n",(0,o.jsx)(e.h3,{id:"getshovelnodeisactive",children:"getShovelNodeIsActive"}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Description"})}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Definition"})}),"\n",(0,o.jsxs)(e.blockquote,{children:["\n",(0,o.jsx)(e.p,{children:"getShovelNodeIsActive()"}),"\n"]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,o.jsxs)(e.table,{children:[(0,o.jsx)(e.thead,{children:(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.th,{children:"any"}),(0,o.jsx)(e.th,{children:"superFunc"})]})}),(0,o.jsx)(e.tbody,{children:(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.td,{children:"any"}),(0,o.jsx)(e.td,{children:"shovelNode"})]})})]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Code"})}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-lua",children:"function Cylindered:getShovelNodeIsActive(superFunc, shovelNode)\n    local isActive = superFunc( self , shovelNode)\n    if not isActive or shovelNode.movingToolActivation = = nil then\n        return isActive\n    end\n\n    local spec = self.spec_cylindered\n    local movingToolActivation = shovelNode.movingToolActivation\n    local movingTool = spec.nodesToMovingTools[movingToolActivation.node]\n    local state = Cylindered.getMovingToolState( self , movingTool)\n    if movingToolActivation.isInverted then\n        state = math.abs(state - 1 )\n    end\n\n    return state > movingToolActivation.openFactor\nend\n\n"})}),"\n",(0,o.jsx)(e.h3,{id:"gettranslatingpartbynode",children:"getTranslatingPartByNode"}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Description"})}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Definition"})}),"\n",(0,o.jsxs)(e.blockquote,{children:["\n",(0,o.jsx)(e.p,{children:"getTranslatingPartByNode()"}),"\n"]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,o.jsx)(e.table,{children:(0,o.jsx)(e.thead,{children:(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.th,{children:"any"}),(0,o.jsx)(e.th,{children:"node"})]})})}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Code"})}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-lua",children:"function Cylindered:getTranslatingPartByNode(node)\n    local spec = self.spec_cylindered\n    for i = 1 , #spec.movingParts do\n        local part = spec.movingParts[i]\n        if part.translatingParts ~ = nil then\n            for j = 1 , part.numTranslatingParts do\n                if part.translatingParts[j].node = = node then\n                    return part.translatingParts[j]\n                end\n            end\n        end\n    end\n\n    return nil\nend\n\n"})}),"\n",(0,o.jsx)(e.h3,{id:"getwearmultiplier",children:"getWearMultiplier"}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Description"})}),"\n",(0,o.jsxs)(e.blockquote,{children:["\n",(0,o.jsx)(e.p,{children:"Returns current wear multiplier"}),"\n"]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Definition"})}),"\n",(0,o.jsxs)(e.blockquote,{children:["\n",(0,o.jsx)(e.p,{children:"getWearMultiplier()"}),"\n"]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,o.jsx)(e.table,{children:(0,o.jsx)(e.thead,{children:(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.th,{children:"any"}),(0,o.jsx)(e.th,{children:"superFunc"})]})})}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Return Values"})}),"\n\n\n\n\n\n\n\n\n",(0,o.jsx)(e.table,{children:(0,o.jsx)(e.thead,{children:(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.th,{children:"any"}),(0,o.jsx)(e.th,{children:"wearMultiplier"}),(0,o.jsx)(e.th,{children:"current wear multiplier"})]})})}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Code"})}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-lua",children:"function Cylindered:getWearMultiplier(superFunc)\n    local spec = self.spec_cylindered\n    local multiplier = superFunc( self )\n\n    if spec.isHydraulicSamplePlaying then\n        multiplier = multiplier + self:getWorkWearMultiplier()\n    end\n\n    return multiplier\nend\n\n"})}),"\n",(0,o.jsx)(e.h3,{id:"initspecialization",children:"initSpecialization"}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Description"})}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Definition"})}),"\n",(0,o.jsxs)(e.blockquote,{children:["\n",(0,o.jsx)(e.p,{children:"initSpecialization()"}),"\n"]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Code"})}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-lua",children:'function Cylindered.initSpecialization()\n    g_vehicleConfigurationManager:addConfigurationType( "cylindered" , g_i18n:getText( "shop_configuration" ), "cylindered" , VehicleConfigurationItem )\n\n    local schema = Vehicle.xmlSchema\n\n    schema:setXMLSpecializationType( "Cylindered" )\n\n    schema:register(XMLValueType.TIME, "vehicle.cylindered.movingTools#powerConsumingActiveTimeOffset" , "Power consumer deactivation delay.After the moving tool has not been moved this long it will no longer consume power." , 5 )\n\n    Cylindered.registerSoundXMLPaths(schema, "vehicle.cylindered.sounds" )\n    Cylindered.registerSoundXMLPaths(schema, "vehicle.cylindered.cylinderedConfigurations.cylinderedConfiguration(?).sounds" )\n\n    for _, toolKey in ipairs( Cylindered.MOVING_TOOLS_XML_KEYS) do\n        Cylindered.registerMovingToolXMLPaths(schema, toolKey .. ".movingTool(?)" )\n        Cylindered.registerEasyArmControlXMLPaths(schema, toolKey .. ".easyArmControl" )\n\n        schema:register(XMLValueType.L10N_STRING, toolKey .. ".controlGroups.controlGroup(?)#name" , "Control group name" )\n    end\n\n    for _, partKey in ipairs( Cylindered.MOVING_PART_XML_KEYS) do\n        Cylindered.registerMovingPartXMLPaths(schema, partKey)\n    end\n\n    schema:addDelayedRegistrationFunc( "Cylindered:movingPart" , function (cSchema, cKey)\n        cSchema:register(XMLValueType.INT, cKey .. "#inputAttacherJointIndex" , "Input Attacher Joint Index [1 .. n]" )\n    end )\n\n    for _, dashboardKey in ipairs( Cylindered.DASHBOARD_XML_KEYS) do\n        Dashboard.registerDashboardXMLPaths(schema, dashboardKey, { "movingTool" } )\n        schema:register(XMLValueType.STRING, dashboardKey .. ".dashboard(?)#axis" , "Moving tool input action name" )\n        schema:register(XMLValueType.INT, dashboardKey .. ".dashboard(?)#attacherJointIndex" , "Index of attacher joint that has to be connected" )\n        schema:register(XMLValueType.NODE_INDEX, dashboardKey .. ".dashboard(?)#attacherJointNode" , "Node of attacher joint that has to be connected" )\n        schema:register(XMLValueType.NODE_INDICES, dashboardKey .. ".dashboard(?)#attacherJointNodes" , "List of attacher joints nodes that has to be connected(on of them)" )\n    end\n\n    ObjectChangeUtil.addAdditionalObjectChangeXMLPaths(schema, function (_schema, key)\n        _schema:register(XMLValueType.ANGLE, key .. "#movingToolRotMaxActive" , "Moving tool max.rotation if object change active" )\n            _schema:register(XMLValueType.ANGLE, key .. "#movingToolRotMaxInactive" , "Moving tool max.rotation if object change inactive" )\n                _schema:register(XMLValueType.ANGLE, key .. "#movingToolRotMinActive" , "Moving tool min.rotation if object change active" )\n                    _schema:register(XMLValueType.ANGLE, key .. "#movingToolRotMinInactive" , "Moving tool min.rotation if object change inactive" )\n\n                        _schema:register(XMLValueType.ANGLE, key .. "#movingToolStartRotActive" , "Moving tool start rotation if object change inactive" )\n                            _schema:register(XMLValueType.ANGLE, key .. "#movingToolStartRotInactive" , "Moving tool start rotation if object change inactive" )\n\n                                _schema:register(XMLValueType.FLOAT, key .. "#movingToolTransMaxActive" , "Moving tool max.translation if object change active" )\n                                    _schema:register(XMLValueType.FLOAT, key .. "#movingToolTransMaxInactive" , "Moving tool max.translation if object change inactive" )\n                                        _schema:register(XMLValueType.FLOAT, key .. "#movingToolTransMinActive" , "Moving tool min.translation if object change active" )\n                                            _schema:register(XMLValueType.FLOAT, key .. "#movingToolTransMinInactive" , "Moving tool min.translation if object change inactive" )\n\n                                                _schema:register(XMLValueType.FLOAT, key .. "#movingToolStartTransActive" , "Moving tool start translation if object change inactive" )\n                                                    _schema:register(XMLValueType.FLOAT, key .. "#movingToolStartTransInactive" , "Moving tool start translation if object change inactive" )\n\n                                                        _schema:register(XMLValueType.BOOL, key .. "#movingPartUpdateActive" , "moving part active state if object change active" )\n                                                            _schema:register(XMLValueType.BOOL, key .. "#movingPartUpdateInactive" , "moving part active state if object change inactive" )\n                                                            end )\n\n                                                            schema:register(XMLValueType.NODE_INDEX, Dischargeable.DISCHARGE_NODE_XML_PATH .. ".movingToolActivation#node" , "Moving tool node" )\n                                                            schema:register(XMLValueType.BOOL, Dischargeable.DISCHARGE_NODE_XML_PATH .. ".movingToolActivation#isInverted" , "Activation is inverted" , false )\n                                                            schema:register(XMLValueType.FLOAT, Dischargeable.DISCHARGE_NODE_XML_PATH .. ".movingToolActivation#openFactor" , "Open factor" , 1 )\n                                                            schema:register(XMLValueType.FLOAT, Dischargeable.DISCHARGE_NODE_XML_PATH .. ".movingToolActivation#openOffset" , "Open offset" , 0 )\n\n                                                            schema:register(XMLValueType.NODE_INDEX, Dischargeable.DISCHARGE_NODE_CONFIG_XML_PATH .. ".movingToolActivation#node" , "Moving tool node" )\n                                                            schema:register(XMLValueType.BOOL, Dischargeable.DISCHARGE_NODE_CONFIG_XML_PATH .. ".movingToolActivation#isInverted" , "Activation is inverted" , false )\n                                                            schema:register(XMLValueType.FLOAT, Dischargeable.DISCHARGE_NODE_CONFIG_XML_PATH .. ".movingToolActivation#openFactor" , "Open factor" , 1 )\n                                                            schema:register(XMLValueType.FLOAT, Dischargeable.DISCHARGE_NODE_CONFIG_XML_PATH .. ".movingToolActivation#openOffset" , "Open offset" , 0 )\n\n                                                            schema:register(XMLValueType.NODE_INDEX, Shovel.SHOVEL_NODE_XML_KEY .. ".movingToolActivation#node" , "Moving tool node" )\n                                                            schema:register(XMLValueType.BOOL, Shovel.SHOVEL_NODE_XML_KEY .. ".movingToolActivation#isInverted" , "Activation is inverted" , false )\n                                                            schema:register(XMLValueType.FLOAT, Shovel.SHOVEL_NODE_XML_KEY .. ".movingToolActivation#openFactor" , "Open factor" , 1 )\n\n                                                            schema:register(XMLValueType.NODE_INDEX, DynamicMountAttacher.DYNAMIC_MOUNT_GRAB_XML_PATH .. ".movingToolActivation#node" , "Moving tool node" )\n                                                            schema:register(XMLValueType.BOOL, DynamicMountAttacher.DYNAMIC_MOUNT_GRAB_XML_PATH .. ".movingToolActivation#isInverted" , "Activation is inverted" , false )\n                                                            schema:register(XMLValueType.FLOAT, DynamicMountAttacher.DYNAMIC_MOUNT_GRAB_XML_PATH .. ".movingToolActivation#openFactor" , "Open factor" , 1 )\n\n                                                            schema:addDelayedRegistrationFunc( "AnimatedVehicle:part" , function (cSchema, cKey)\n                                                                cSchema:register(XMLValueType.NODE_INDEX, cKey .. "#startReferencePoint" , "Start reference point" )\n                                                                cSchema:register(XMLValueType.NODE_INDEX, cKey .. "#endReferencePoint" , "End reference point" )\n                                                            end )\n\n                                                            schema:setXMLSpecializationType()\n\n                                                            local schemaSavegame = Vehicle.xmlSchemaSavegame\n                                                            schemaSavegame:register(XMLValueType.FLOAT, "vehicles.vehicle(?).cylindered.movingTool(?)#translation" , "Current translation value" )\n                                                            schemaSavegame:register(XMLValueType.ANGLE, "vehicles.vehicle(?).cylindered.movingTool(?)#rotation" , "Current rotation in rad" )\n                                                            schemaSavegame:register(XMLValueType.FLOAT, "vehicles.vehicle(?).cylindered.movingTool(?)#animationTime" , "Current animation time" )\n                                                        end\n\n'})}),"\n",(0,o.jsx)(e.h3,{id:"isdetachallowed",children:"isDetachAllowed"}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Description"})}),"\n",(0,o.jsxs)(e.blockquote,{children:["\n",(0,o.jsx)(e.p,{children:"Returns true if detach is allowed"}),"\n"]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Definition"})}),"\n",(0,o.jsxs)(e.blockquote,{children:["\n",(0,o.jsx)(e.p,{children:"isDetachAllowed(function superFunc)"}),"\n"]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,o.jsx)(e.table,{children:(0,o.jsx)(e.thead,{children:(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.th,{children:"function"}),(0,o.jsx)(e.th,{children:"superFunc"})]})})}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Return Values"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,o.jsxs)(e.table,{children:[(0,o.jsx)(e.thead,{children:(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.th,{children:"function"}),(0,o.jsx)(e.th,{children:"detachAllowed"}),(0,o.jsx)(e.th,{children:"detach is allowed"})]})}),(0,o.jsx)(e.tbody,{children:(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.td,{children:"function"}),(0,o.jsx)(e.td,{children:"warning"}),(0,o.jsx)(e.td,{children:"[optional] warning text to display"})]})})]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Code"})}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-lua",children:"function Cylindered:isDetachAllowed(superFunc)\n    local spec = self.spec_cylindered\n    if spec.detachLockNodes ~ = nil then\n        for entry, data in pairs(spec.detachLockNodes) do\n            local node = entry.node\n            local rot = select(entry.rotationAxis, getRotation(node))\n\n            if data.detachingRotMinLimit ~ = nil and rot < data.detachingRotMinLimit then\n                return false , nil\n            end\n            if data.detachingRotMaxLimit ~ = nil and rot > data.detachingRotMaxLimit then\n                return false , nil\n            end\n\n            local trans = select(entry.translationAxis, getTranslation(node))\n            if data.detachingTransMinLimit ~ = nil and trans < data.detachingTransMinLimit then\n                return false , nil\n            end\n            if data.detachingTransMaxLimit ~ = nil and trans > data.detachingTransMaxLimit then\n                return false , nil\n            end\n        end\n    end\n\n    return superFunc( self )\nend\n\n"})}),"\n",(0,o.jsx)(e.h3,{id:"limitinterpolator",children:"limitInterpolator"}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Description"})}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Definition"})}),"\n",(0,o.jsxs)(e.blockquote,{children:["\n",(0,o.jsx)(e.p,{children:"limitInterpolator()"}),"\n"]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,o.jsxs)(e.table,{children:[(0,o.jsx)(e.thead,{children:(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.th,{children:"any"}),(0,o.jsx)(e.th,{children:"first"})]})}),(0,o.jsxs)(e.tbody,{children:[(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.td,{children:"any"}),(0,o.jsx)(e.td,{children:"second"})]}),(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.td,{children:"any"}),(0,o.jsx)(e.td,{children:"alpha"})]})]})]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Code"})}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-lua",children:"function Cylindered.limitInterpolator(first, second, alpha)\n    local oneMinusAlpha = 1 - alpha\n\n    local rotMin = nil\n    local rotMax = nil\n    local transMin = nil\n    local transMax = nil\n\n    if first.rotMin ~ = nil and second.rotMin ~ = nil then\n        rotMin = first.rotMin * alpha + second.rotMin * oneMinusAlpha\n    end\n    if first.rotMax ~ = nil and second.rotMax ~ = nil then\n        rotMax = first.rotMax * alpha + second.rotMax * oneMinusAlpha\n    end\n    if first.transMin ~ = nil and second.transMin ~ = nil then\n        transMin = first.minTrans * alpha + second.transMin * oneMinusAlpha\n    end\n    if first.transMax ~ = nil and second.transMax ~ = nil then\n        transMax = first.transMax * alpha + second.transMax * oneMinusAlpha\n    end\n\n    return rotMin, rotMax, transMin, transMax\nend\n\n"})}),"\n",(0,o.jsx)(e.h3,{id:"loadactionsoundsfromxml",children:"loadActionSoundsFromXML"}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Description"})}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Definition"})}),"\n",(0,o.jsxs)(e.blockquote,{children:["\n",(0,o.jsx)(e.p,{children:"loadActionSoundsFromXML()"}),"\n"]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,o.jsxs)(e.table,{children:[(0,o.jsx)(e.thead,{children:(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.th,{children:"any"}),(0,o.jsx)(e.th,{children:"xmlFile"})]})}),(0,o.jsx)(e.tbody,{children:(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.td,{children:"any"}),(0,o.jsx)(e.td,{children:"key"})]})})]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Code"})}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-lua",children:'function Cylindered:loadActionSoundsFromXML(xmlFile, key)\n    local spec = self.spec_cylindered\n\n    local i = 0\n    while true do\n        local actionKey = string.format( "actionSound(%d)" , i)\n        local baseKey = key .. "." .. actionKey\n        if not xmlFile:hasProperty(baseKey) then\n            break\n        end\n\n        local sample = g_soundManager:loadSampleFromXML(xmlFile, key, actionKey, self.baseDirectory, self.components, 0 , AudioGroup.VEHICLE, self.i3dMappings, self )\n\n        if sample ~ = nil then\n            local actionNamesStr = xmlFile:getValue(baseKey .. "#actionNames" )\n            local actionNames = string.split(actionNamesStr:trim(), " " )\n\n            local nodesStr = xmlFile:getValue(baseKey .. "#nodes" )\n            local nodes = string.split(nodesStr, " " )\n\n            for l = 1 , #nodes do\n                nodes[l] = I3DUtil.indexToObject( self.components, nodes[l], self.i3dMappings)\n            end\n\n            for j = 1 , #actionNames do\n                local actionName = actionNames[j]\n                actionName = "SOUND_ACTION_" .. string.upper(actionName)\n                local action = Cylindered [actionName]\n                if action ~ = nil then\n                    for l = 1 , #nodes do\n                        local node = nodes[l]\n                        if node ~ = nil then\n                            if spec.nodesToSamples[node] = = nil then\n                                spec.nodesToSamples[node] = { }\n                            end\n\n                            if spec.nodesToSamples[node][action] = = nil then\n                                spec.nodesToSamples[node][action] = { }\n                            end\n\n                            local part = self:getMovingPartByNode(node) or self:getTranslatingPartByNode(node) or self:getMovingToolByNode(node)\n                            if part ~ = nil then\n                                part.samplesByAction = spec.nodesToSamples[node]\n                            else\n                                    Logging.xmlWarning(xmlFile, "Unable to find movingPart or translatingPart for node \'%s\' in %s" , getName(node), baseKey)\n                                    end\n\n                                    table.insert(spec.nodesToSamples[node][action], sample)\n                                end\n                            end\n                        else\n                                Logging.xmlWarning(xmlFile, "Unable to find sound action \'%s\' for sound \'%s\'" , actionName, baseKey)\n                                end\n                            end\n\n                            sample.dropOffFactor = xmlFile:getValue(baseKey .. ".pitch#dropOffFactor" , 1 )\n                            sample.dropOffTime = xmlFile:getValue(baseKey .. ".pitch#dropOffTime" , 0 ) * 1000\n\n                            sample.actionNames = actionNames\n                            sample.nodes = nodes\n\n                            table.insert(spec.actionSamples, sample)\n                        end\n\n                        i = i + 1\n                    end\n                end\n\n'})}),"\n",(0,o.jsx)(e.h3,{id:"loadcopylocaldirectionparts",children:"loadCopyLocalDirectionParts"}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Description"})}),"\n",(0,o.jsxs)(e.blockquote,{children:["\n",(0,o.jsx)(e.p,{children:"Load copy local direction parts from xml"}),"\n"]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Definition"})}),"\n",(0,o.jsxs)(e.blockquote,{children:["\n",(0,o.jsx)(e.p,{children:"loadCopyLocalDirectionParts(XMLFile xmlFile, string baseName, table entry)"}),"\n"]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,o.jsxs)(e.table,{children:[(0,o.jsx)(e.thead,{children:(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.th,{children:"XMLFile"}),(0,o.jsx)(e.th,{children:"xmlFile"}),(0,o.jsx)(e.th,{children:"XMLFile instance"})]})}),(0,o.jsxs)(e.tbody,{children:[(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.td,{children:"string"}),(0,o.jsx)(e.td,{children:"baseName"}),(0,o.jsx)(e.td,{children:"base name"})]}),(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.td,{children:"table"}),(0,o.jsx)(e.td,{children:"entry"}),(0,o.jsx)(e.td,{children:"entry to add"})]})]})]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Code"})}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-lua",children:'function Cylindered:loadCopyLocalDirectionParts(xmlFile, baseName, entry)\n    entry.copyLocalDirectionParts = { }\n\n    for _, copyLocalDirectionPartKey in xmlFile:iterator(baseName .. ".copyLocalDirectionPart" ) do\n\n        XMLUtil.checkDeprecatedXMLElements(xmlFile, copyLocalDirectionPartKey .. "#index" , copyLocalDirectionPartKey .. "#node" ) --FS15 to FS17\n\n        local node = xmlFile:getValue(copyLocalDirectionPartKey .. "#node" , nil , self.components, self.i3dMappings)\n        if node ~ = nil then\n            local copyLocalDirectionPart = { }\n            copyLocalDirectionPart.node = node\n            copyLocalDirectionPart.dirScale = xmlFile:getValue(copyLocalDirectionPartKey .. "#dirScale" , nil , true )\n            copyLocalDirectionPart.upScale = xmlFile:getValue(copyLocalDirectionPartKey .. "#upScale" , nil , true )\n\n            if copyLocalDirectionPart.dirScale = = nil then\n                Logging.xmlWarning(xmlFile, "Missing values for \'%s\'" , copyLocalDirectionPartKey .. "#dirScale" )\n                    continue\n                end\n                if copyLocalDirectionPart.upScale = = nil then\n                    Logging.xmlWarning(xmlFile, "Missing values for \'%s\'" , copyLocalDirectionPartKey .. "#upScale" )\n                        continue\n                    end\n\n                    self:loadDependentComponentJoints(xmlFile, copyLocalDirectionPartKey, copyLocalDirectionPart)\n\n                    table.insert(entry.copyLocalDirectionParts, copyLocalDirectionPart)\n                end\n            end\n        end\n\n'})}),"\n",(0,o.jsx)(e.h3,{id:"loaddependentanimations",children:"loadDependentAnimations"}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Description"})}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Definition"})}),"\n",(0,o.jsxs)(e.blockquote,{children:["\n",(0,o.jsx)(e.p,{children:"loadDependentAnimations()"}),"\n"]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,o.jsxs)(e.table,{children:[(0,o.jsx)(e.thead,{children:(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.th,{children:"any"}),(0,o.jsx)(e.th,{children:"xmlFile"})]})}),(0,o.jsxs)(e.tbody,{children:[(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.td,{children:"any"}),(0,o.jsx)(e.td,{children:"baseName"})]}),(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.td,{children:"any"}),(0,o.jsx)(e.td,{children:"entry"})]})]})]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Code"})}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-lua",children:'function Cylindered:loadDependentAnimations(xmlFile, baseName, entry)\n    entry.dependentAnimations = { }\n\n    local i = 0\n    while true do\n        local baseKey = string.format( "%s.dependentAnimation(%d)" , baseName, i)\n        if not xmlFile:hasProperty(baseKey) then\n            break\n        end\n\n        local animationName = xmlFile:getValue(baseKey .. "#name" )\n        if animationName ~ = nil then\n            local dependentAnimation = { }\n            dependentAnimation.name = animationName\n            dependentAnimation.lastPos = 0\n\n            dependentAnimation.translationAxis = xmlFile:getValue(baseKey .. "#translationAxis" )\n            dependentAnimation.rotationAxis = xmlFile:getValue(baseKey .. "#rotationAxis" )\n\n            dependentAnimation.node = entry.node\n            local useTranslatingPartIndex = xmlFile:getValue(baseKey .. "#useTranslatingPartIndex" )\n            if useTranslatingPartIndex ~ = nil then\n                if entry.translatingParts[useTranslatingPartIndex] ~ = nil then\n                    dependentAnimation.node = entry.translatingParts[useTranslatingPartIndex].node\n                end\n            end\n\n            dependentAnimation.minValue = xmlFile:getValue(baseKey .. "#minValue" )\n            dependentAnimation.maxValue = xmlFile:getValue(baseKey .. "#maxValue" )\n            if dependentAnimation.rotationAxis ~ = nil then\n                dependentAnimation.minValue = MathUtil.degToRad(dependentAnimation.minValue)\n                dependentAnimation.maxValue = MathUtil.degToRad(dependentAnimation.maxValue)\n            end\n\n            dependentAnimation.invert = xmlFile:getValue(baseKey .. "#invert" , false )\n\n            table.insert(entry.dependentAnimations, dependentAnimation)\n        end\n\n        i = i + 1\n    end\nend\n\n'})}),"\n",(0,o.jsx)(e.h3,{id:"loaddependentattacherjoints",children:"loadDependentAttacherJoints"}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Description"})}),"\n",(0,o.jsxs)(e.blockquote,{children:["\n",(0,o.jsx)(e.p,{children:"Load attacher joints from xml"}),"\n"]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Definition"})}),"\n",(0,o.jsxs)(e.blockquote,{children:["\n",(0,o.jsx)(e.p,{children:"loadDependentAttacherJoints(XMLFile xmlFile, string baseName, table entry)"}),"\n"]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,o.jsxs)(e.table,{children:[(0,o.jsx)(e.thead,{children:(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.th,{children:"XMLFile"}),(0,o.jsx)(e.th,{children:"xmlFile"}),(0,o.jsx)(e.th,{children:"XMLFile instance"})]})}),(0,o.jsxs)(e.tbody,{children:[(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.td,{children:"string"}),(0,o.jsx)(e.td,{children:"baseName"}),(0,o.jsx)(e.td,{children:"base name"})]}),(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.td,{children:"table"}),(0,o.jsx)(e.td,{children:"entry"}),(0,o.jsx)(e.td,{children:"entry to add"})]})]})]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Code"})}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-lua",children:'function Cylindered:loadDependentAttacherJoints(xmlFile, baseName, entry)\n    XMLUtil.checkDeprecatedXMLElements(xmlFile, baseName .. "#jointIndices" , baseName .. ".attacherJoint#jointIndices" ) --FS15 to FS17\n\n    local indices = xmlFile:getValue(baseName .. ".attacherJoint#jointIndices" , nil , true )\n    if indices ~ = nil then\n        local ignoreWarning = xmlFile:getValue(baseName .. ".attacherJoint#ignoreWarning" , false )\n\n        entry.attacherJoints = { }\n\n        local availableAttacherJoints\n        if self.getAttacherJoints ~ = nil then\n            availableAttacherJoints = self:getAttacherJoints()\n        end\n        if availableAttacherJoints ~ = nil then\n            for i = 1 , #indices do\n                if availableAttacherJoints[indices[i]] ~ = nil then\n                    table.insert(entry.attacherJoints, availableAttacherJoints[indices[i]])\n                elseif not ignoreWarning then\n                        Logging.xmlWarning(xmlFile, "Invalid attacher joint index \'%s\' for \'%s\'!" , indices[i], baseName)\n                        end\n                    end\n                end\n            end\n\n            XMLUtil.checkDeprecatedXMLElements(xmlFile, baseName .. "#inputAttacherJoint" , baseName .. ".inputAttacherJoint#value" ) --FS15 to FS17\n\n            entry.inputAttacherJoint = xmlFile:getValue(baseName .. ".inputAttacherJoint#value" , false )\n        end\n\n'})}),"\n",(0,o.jsx)(e.h3,{id:"loaddependentcomponentjoints",children:"loadDependentComponentJoints"}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Description"})}),"\n",(0,o.jsxs)(e.blockquote,{children:["\n",(0,o.jsx)(e.p,{children:"Load component joints from xml"}),"\n"]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Definition"})}),"\n",(0,o.jsxs)(e.blockquote,{children:["\n",(0,o.jsx)(e.p,{children:"loadDependentComponentJoints(XMLFile xmlFile, string baseName, table entry)"}),"\n"]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,o.jsxs)(e.table,{children:[(0,o.jsx)(e.thead,{children:(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.th,{children:"XMLFile"}),(0,o.jsx)(e.th,{children:"xmlFile"}),(0,o.jsx)(e.th,{children:"XMLFile instance"})]})}),(0,o.jsxs)(e.tbody,{children:[(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.td,{children:"string"}),(0,o.jsx)(e.td,{children:"baseName"}),(0,o.jsx)(e.td,{children:"base name"})]}),(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.td,{children:"table"}),(0,o.jsx)(e.td,{children:"entry"}),(0,o.jsx)(e.td,{children:"entry to add"})]})]})]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Code"})}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-lua",children:'function Cylindered:loadDependentComponentJoints(xmlFile, baseName, entry)\n    if not self.isServer then\n        return\n    end\n\n    entry.componentJoints = { }\n\n    XMLUtil.checkDeprecatedXMLElements(xmlFile, baseName .. "#componentJointIndex" , baseName .. ".componentJoint#index" ) --FS15 to FS17\n    XMLUtil.checkDeprecatedXMLElements(xmlFile, baseName .. "#anchorActor" , baseName .. ".componentJoint#anchorActor" ) --FS15 to FS17\n\n    local i = 0\n    while true do\n        local key = baseName .. string.format( ".componentJoint(%d)" , i)\n        if not xmlFile:hasProperty(key) then\n            break\n        end\n        local index = xmlFile:getValue(key .. "#index" )\n        if index ~ = nil and self.componentJoints[index] ~ = nil then\n            local anchorActor = xmlFile:getValue(key .. "#anchorActor" , 0 )\n\n            local componentJoint = self.componentJoints[index]\n\n            local jointEntry = { }\n            jointEntry.componentJoint = componentJoint\n            jointEntry.anchorActor = anchorActor\n            jointEntry.index = index\n\n            local jointNode = componentJoint.jointNode\n            if jointEntry.anchorActor = = 1 then\n                jointNode = componentJoint.jointNodeActor1\n            end\n\n            local node = self.components[componentJoint.componentIndices[ 2 ]].node\n            jointEntry.x, jointEntry.y, jointEntry.z = localToLocal(node, jointNode, 0 , 0 , 0 )\n            jointEntry.upX, jointEntry.upY, jointEntry.upZ = localDirectionToLocal(node, jointNode, 0 , 1 , 0 )\n            jointEntry.dirX, jointEntry.dirY, jointEntry.dirZ = localDirectionToLocal(node, jointNode, 0 , 0 , 1 )\n\n            table.insert(entry.componentJoints, jointEntry)\n        elseif not xmlFile:getValue(key .. "#ignoreWarning" ) then\n                Logging.xmlWarning(xmlFile, "Invalid index for \'%s\'" , key)\n                end\n\n                i = i + 1\n            end\n        end\n\n'})}),"\n",(0,o.jsx)(e.h3,{id:"loaddependentmovingtools",children:"loadDependentMovingTools"}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Description"})}),"\n",(0,o.jsxs)(e.blockquote,{children:["\n",(0,o.jsx)(e.p,{children:"Load dependent moving tools from xml"}),"\n"]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Definition"})}),"\n",(0,o.jsxs)(e.blockquote,{children:["\n",(0,o.jsx)(e.p,{children:"loadDependentMovingTools(XMLFile xmlFile, string baseName, table entry)"}),"\n"]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,o.jsxs)(e.table,{children:[(0,o.jsx)(e.thead,{children:(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.th,{children:"XMLFile"}),(0,o.jsx)(e.th,{children:"xmlFile"}),(0,o.jsx)(e.th,{children:"XMLFile instance"})]})}),(0,o.jsxs)(e.tbody,{children:[(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.td,{children:"string"}),(0,o.jsx)(e.td,{children:"baseName"}),(0,o.jsx)(e.td,{children:"base name"})]}),(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.td,{children:"table"}),(0,o.jsx)(e.td,{children:"entry"}),(0,o.jsx)(e.td,{children:"entry to add"})]})]})]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Code"})}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-lua",children:'function Cylindered:loadDependentMovingTools(xmlFile, baseName, entry)\n    entry.dependentMovingTools = { }\n\n    local j = 0\n    while true do\n        local refBaseName = baseName .. string.format( ".dependentMovingTool(%d)" , j)\n        if not xmlFile:hasProperty(refBaseName) then\n            break\n        end\n\n        XMLUtil.checkDeprecatedXMLElements(xmlFile, refBaseName .. "#index" , refBaseName .. "#index" ) --FS17 to FS19\n\n        local node = xmlFile:getValue(refBaseName .. "#node" , nil , self.components, self.i3dMappings)\n        local speedScale = xmlFile:getValue(refBaseName .. "#speedScale" )\n        local requiresMovement = xmlFile:getValue(refBaseName .. "#requiresMovement" , false )\n        local axis = xmlFile:getValue(refBaseName .. "#axis" , 1 )\n\n        local rotationBasedLimits = AnimCurve.new( Cylindered.limitInterpolator)\n        local found = false\n        local i = 0\n        while true do\n            local key = string.format( "%s.limit(%d)" , refBaseName .. ".rotationBasedLimits" , i)\n            if not xmlFile:hasProperty(key) then\n                break\n            end\n\n            local keyFrame = self:loadRotationBasedLimits(xmlFile, key, entry)\n            if keyFrame ~ = nil then\n                rotationBasedLimits:addKeyframe(keyFrame)\n                found = true\n            end\n            i = i + 1\n        end\n        if not found then\n            rotationBasedLimits = nil\n        end\n\n        local minTransLimits = xmlFile:getValue(refBaseName .. "#minTransLimits" , nil , true )\n        local maxTransLimits = xmlFile:getValue(refBaseName .. "#maxTransLimits" , nil , true )\n        local minRotLimits = xmlFile:getValue(refBaseName .. "#minRotLimits" , nil , true )\n        local maxRotLimits = xmlFile:getValue(refBaseName .. "#maxRotLimits" , nil , true )\n        if node ~ = nil and(rotationBasedLimits ~ = nil or speedScale ~ = nil or minTransLimits ~ = nil or maxTransLimits ~ = nil or minRotLimits ~ = nil or maxRotLimits ~ = nil ) then\n            local dependentTool = { }\n            dependentTool.node = node\n            dependentTool.axis = axis\n            dependentTool.rotation = { 0 , 0 , 0 }\n            dependentTool.rotationBasedLimits = rotationBasedLimits\n            dependentTool.speedScale = speedScale\n            dependentTool.requiresMovement = requiresMovement\n            dependentTool.minTransLimits = minTransLimits\n            dependentTool.maxTransLimits = maxTransLimits\n            dependentTool.minRotLimits = minRotLimits\n            dependentTool.maxRotLimits = maxRotLimits\n            table.insert(entry.dependentMovingTools, dependentTool)\n        end\n\n        j = j + 1\n    end\nend\n\n'})}),"\n",(0,o.jsx)(e.h3,{id:"loaddependentparts",children:"loadDependentParts"}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Description"})}),"\n",(0,o.jsxs)(e.blockquote,{children:["\n",(0,o.jsx)(e.p,{children:"Load dependent parts from xml"}),"\n"]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Definition"})}),"\n",(0,o.jsxs)(e.blockquote,{children:["\n",(0,o.jsx)(e.p,{children:"loadDependentParts(XMLFile xmlFile, string baseName, table entry)"}),"\n"]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,o.jsxs)(e.table,{children:[(0,o.jsx)(e.thead,{children:(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.th,{children:"XMLFile"}),(0,o.jsx)(e.th,{children:"xmlFile"}),(0,o.jsx)(e.th,{children:"XMLFile instance"})]})}),(0,o.jsxs)(e.tbody,{children:[(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.td,{children:"string"}),(0,o.jsx)(e.td,{children:"baseName"}),(0,o.jsx)(e.td,{children:"base name"})]}),(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.td,{children:"table"}),(0,o.jsx)(e.td,{children:"entry"}),(0,o.jsx)(e.td,{children:"entry to add"})]})]})]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Code"})}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-lua",children:'function Cylindered:loadDependentParts(xmlFile, baseName, entry)\n    entry.dependentPartData = { }\n\n    xmlFile:iterate(baseName .. ".dependentPart" , function (_, key)\n        XMLUtil.checkDeprecatedXMLElements(xmlFile, key .. "#index" , key .. "#node" ) --FS17 to FS19\n\n        local dependentPart = { }\n        dependentPart.node = xmlFile:getValue(key .. "#node" , nil , self.components, self.i3dMappings)\n        if dependentPart.node ~ = nil then\n            dependentPart.maxUpdateDistance = xmlFile:getValue(key .. "#maxUpdateDistance" , "-" )\n            if dependentPart.maxUpdateDistance = = "-" then\n                dependentPart.maxUpdateDistance = math.huge\n            else\n                    dependentPart.maxUpdateDistance = tonumber(dependentPart.maxUpdateDistance)\n                end\n\n                dependentPart.part = nil\n\n                table.insert(entry.dependentPartData, dependentPart)\n            end\n        end )\n    end\n\n'})}),"\n",(0,o.jsx)(e.h3,{id:"loaddependenttranslatingparts",children:"loadDependentTranslatingParts"}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Description"})}),"\n",(0,o.jsxs)(e.blockquote,{children:["\n",(0,o.jsx)(e.p,{children:"Load translating parts"}),"\n"]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Definition"})}),"\n",(0,o.jsxs)(e.blockquote,{children:["\n",(0,o.jsx)(e.p,{children:"loadDependentTranslatingParts(XMLFile xmlFile, string baseName, table entry)"}),"\n"]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,o.jsxs)(e.table,{children:[(0,o.jsx)(e.thead,{children:(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.th,{children:"XMLFile"}),(0,o.jsx)(e.th,{children:"xmlFile"}),(0,o.jsx)(e.th,{children:"XMLFile instance"})]})}),(0,o.jsxs)(e.tbody,{children:[(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.td,{children:"string"}),(0,o.jsx)(e.td,{children:"baseName"}),(0,o.jsx)(e.td,{children:"base name"})]}),(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.td,{children:"table"}),(0,o.jsx)(e.td,{children:"entry"}),(0,o.jsx)(e.td,{children:"entry to add"})]})]})]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Code"})}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-lua",children:'function Cylindered:loadDependentTranslatingParts(xmlFile, baseName, entry)\n    entry.translatingParts = { }\n    if entry.hasReferencePoints then\n        entry.divideTranslatingDistance = xmlFile:getValue(baseName .. "#divideTranslatingDistance" , true )\n        entry.translatingPartsDivider = 0\n\n        local j = 0\n        while true do\n            local refBaseName = baseName .. string.format( ".translatingPart(%d)" , j)\n            if not xmlFile:hasProperty(refBaseName) then\n                break\n            end\n\n            XMLUtil.checkDeprecatedXMLElements(xmlFile, refBaseName .. "#index" , refBaseName .. "#node" ) --FS15 to FS17\n\n            local node = xmlFile:getValue(refBaseName .. "#node" , nil , self.components, self.i3dMappings)\n            if node ~ = nil then\n                local transEntry = { }\n                transEntry.node = node\n                local x, y, z = getTranslation(node)\n                transEntry.startPos = { x, y, z }\n                transEntry.lastZ = z\n\n                local _, refZ\n                if entry.referencePoint ~ = nil then\n                    _, _, refZ = worldToLocal(node, getWorldTranslation(entry.referencePoint))\n                else\n                        refZ = 0\n                        for i, referencePoint in ipairs(entry.referencePoints) do\n                            _, _, z = worldToLocal(node, getWorldTranslation(referencePoint))\n                            refZ = refZ + z\n                        end\n\n                        refZ = refZ / entry.numReferencePoints\n                    end\n\n                    transEntry.referenceDistance = xmlFile:getValue(refBaseName .. "#referenceDistance" , refZ)\n\n                    transEntry.minZTrans = xmlFile:getValue(refBaseName .. "#minZTrans" )\n                    transEntry.maxZTrans = xmlFile:getValue(refBaseName .. "#maxZTrans" )\n\n                    transEntry.divideTranslatingDistance = xmlFile:getValue(refBaseName .. "#divideTranslatingDistance" , entry.divideTranslatingDistance)\n                    if transEntry.divideTranslatingDistance then\n                        entry.translatingPartsDivider = entry.translatingPartsDivider + 1\n                    end\n\n                    table.insert(entry.translatingParts, transEntry)\n                end\n\n                j = j + 1\n            end\n\n            entry.translatingPartsDivider = math.max(entry.translatingPartsDivider, 1 )\n            entry.numTranslatingParts = #entry.translatingParts\n        end\n    end\n\n'})}),"\n",(0,o.jsx)(e.h3,{id:"loaddependentwheels",children:"loadDependentWheels"}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Description"})}),"\n",(0,o.jsxs)(e.blockquote,{children:["\n",(0,o.jsx)(e.p,{children:"Load wheels from xml"}),"\n"]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Definition"})}),"\n",(0,o.jsxs)(e.blockquote,{children:["\n",(0,o.jsx)(e.p,{children:"loadDependentWheels(XMLFile xmlFile, string baseName, table entry)"}),"\n"]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,o.jsxs)(e.table,{children:[(0,o.jsx)(e.thead,{children:(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.th,{children:"XMLFile"}),(0,o.jsx)(e.th,{children:"xmlFile"}),(0,o.jsx)(e.th,{children:"XMLFile instance"})]})}),(0,o.jsxs)(e.tbody,{children:[(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.td,{children:"string"}),(0,o.jsx)(e.td,{children:"baseName"}),(0,o.jsx)(e.td,{children:"base name"})]}),(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.td,{children:"table"}),(0,o.jsx)(e.td,{children:"entry"}),(0,o.jsx)(e.td,{children:"entry to add"})]})]})]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Code"})}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-lua",children:'function Cylindered:loadDependentWheels(xmlFile, baseName, entry)\n    if SpecializationUtil.hasSpecialization( Wheels , self.specializations) then\n        local indices = xmlFile:getValue(baseName .. "#wheelIndices" , nil , true )\n        if indices ~ = nil then\n            entry.wheels = { }\n            for _,wheelIndex in pairs(indices) do\n                local wheel = self:getWheelFromWheelIndex(wheelIndex)\n                if wheel ~ = nil then\n                    table.insert(entry.wheels, wheel)\n                else\n                        Logging.xmlWarning(xmlFile, "Invalid wheelIndex \'%s\' for \'%s\'!" , wheelIndex, baseName)\n                        end\n                    end\n                end\n\n                local wheelNodesStr = xmlFile:getValue(baseName .. "#wheelNodes" )\n                if wheelNodesStr ~ = nil and wheelNodesStr ~ = "" then\n                    entry.wheels = entry.wheels or { }\n                    local wheelNodes = string.split(wheelNodesStr, " " )\n                    for i = 1 , #wheelNodes do\n                        local wheel = self:getWheelByWheelNode(wheelNodes[i])\n                        if wheel ~ = nil then\n                            table.insert(entry.wheels, wheel)\n                        else\n                                Logging.xmlWarning(xmlFile, "Invalid wheelNode \'%s\' for \'%s\'!" , wheelNodes[i], baseName)\n                                end\n                            end\n                        end\n                    end\n                end\n\n'})}),"\n",(0,o.jsx)(e.h3,{id:"loaddischargenode",children:"loadDischargeNode"}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Description"})}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Definition"})}),"\n",(0,o.jsxs)(e.blockquote,{children:["\n",(0,o.jsx)(e.p,{children:"loadDischargeNode()"}),"\n"]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,o.jsxs)(e.table,{children:[(0,o.jsx)(e.thead,{children:(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.th,{children:"any"}),(0,o.jsx)(e.th,{children:"superFunc"})]})}),(0,o.jsxs)(e.tbody,{children:[(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.td,{children:"any"}),(0,o.jsx)(e.td,{children:"xmlFile"})]}),(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.td,{children:"any"}),(0,o.jsx)(e.td,{children:"key"})]}),(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.td,{children:"any"}),(0,o.jsx)(e.td,{children:"entry"})]})]})]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Code"})}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-lua",children:'function Cylindered:loadDischargeNode(superFunc, xmlFile, key, entry)\n    if not superFunc( self , xmlFile, key, entry) then\n        return false\n    end\n\n    local baseKey = key .. ".movingToolActivation"\n\n    if xmlFile:hasProperty(baseKey) then\n        entry.movingToolActivation = { }\n        entry.movingToolActivation.node = xmlFile:getValue(baseKey .. "#node" , nil , self.components, self.i3dMappings)\n        entry.movingToolActivation.isInverted = xmlFile:getValue(baseKey .. "#isInverted" , false )\n        entry.movingToolActivation.openFactor = xmlFile:getValue(baseKey .. "#openFactor" , 1 )\n        entry.movingToolActivation.openOffset = xmlFile:getValue(baseKey .. "#openOffset" , 0 )\n        entry.movingToolActivation.openOffsetInv = 1 - entry.movingToolActivation.openOffset\n    end\n\n    return true\nend\n\n'})}),"\n",(0,o.jsx)(e.h3,{id:"loaddynamicmountgrabfromxml",children:"loadDynamicMountGrabFromXML"}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Description"})}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Definition"})}),"\n",(0,o.jsxs)(e.blockquote,{children:["\n",(0,o.jsx)(e.p,{children:"loadDynamicMountGrabFromXML()"}),"\n"]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,o.jsxs)(e.table,{children:[(0,o.jsx)(e.thead,{children:(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.th,{children:"any"}),(0,o.jsx)(e.th,{children:"superFunc"})]})}),(0,o.jsxs)(e.tbody,{children:[(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.td,{children:"any"}),(0,o.jsx)(e.td,{children:"xmlFile"})]}),(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.td,{children:"any"}),(0,o.jsx)(e.td,{children:"key"})]}),(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.td,{children:"any"}),(0,o.jsx)(e.td,{children:"entry"})]})]})]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Code"})}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-lua",children:'function Cylindered:loadDynamicMountGrabFromXML(superFunc, xmlFile, key, entry)\n    if not superFunc( self , xmlFile, key, entry) then\n        return false\n    end\n\n    local baseKey = key .. ".movingToolActivation"\n    if not xmlFile:hasProperty(baseKey) then\n        return true\n    end\n\n    entry.movingToolActivation = { }\n    entry.movingToolActivation.node = xmlFile:getValue(baseKey .. "#node" , nil , self.components, self.i3dMappings)\n    entry.movingToolActivation.isInverted = xmlFile:getValue(baseKey .. "#isInverted" , false )\n    entry.movingToolActivation.openFactor = xmlFile:getValue(baseKey .. "#openFactor" , 1 )\n\n    return true\nend\n\n'})}),"\n",(0,o.jsx)(e.h3,{id:"loadeasyarmcontrolfromxml",children:"loadEasyArmControlFromXML"}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Description"})}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Definition"})}),"\n",(0,o.jsxs)(e.blockquote,{children:["\n",(0,o.jsx)(e.p,{children:"loadEasyArmControlFromXML()"}),"\n"]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,o.jsxs)(e.table,{children:[(0,o.jsx)(e.thead,{children:(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.th,{children:"any"}),(0,o.jsx)(e.th,{children:"xmlFile"})]})}),(0,o.jsxs)(e.tbody,{children:[(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.td,{children:"any"}),(0,o.jsx)(e.td,{children:"key"})]}),(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.td,{children:"any"}),(0,o.jsx)(e.td,{children:"easyArmControl"})]})]})]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Code"})}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-lua",children:'function Cylindered:loadEasyArmControlFromXML(xmlFile, key, easyArmControl)\n    XMLUtil.checkDeprecatedXMLElements(xmlFile, key .. ".xRotationNodes#maxDistance" ) --FS19 to FS22\n    XMLUtil.checkDeprecatedXMLElements(xmlFile, key .. ".xRotationNodes#transRotRatio" ) --FS19 to FS22\n\n    easyArmControl.rootNode = xmlFile:getValue(key .. "#rootNode" , nil , self.components, self.i3dMappings)\n    easyArmControl.targetNodeY = xmlFile:getValue(key .. "#node" , nil , self.components, self.i3dMappings)\n    easyArmControl.targetNodeZ = xmlFile:getValue(key .. "#targetNodeZ" , easyArmControl.targetNodeY, self.components, self.i3dMappings)\n    easyArmControl.state = false\n\n    if easyArmControl.targetNodeZ ~ = nil and easyArmControl.targetNodeY ~ = nil then\n        local targetYTool = self:getMovingToolByNode(easyArmControl.targetNodeY)\n        local targetZTool = self:getMovingToolByNode(easyArmControl.targetNodeZ)\n        if targetYTool ~ = nil and targetZTool ~ = nil then\n            easyArmControl.targetNode = easyArmControl.targetNodeZ\n            if getParent(easyArmControl.targetNodeY) = = easyArmControl.targetNodeZ then\n                easyArmControl.targetNode = easyArmControl.targetNodeY\n            end\n            easyArmControl.targetRefNode = xmlFile:getValue(key .. "#refNode" , nil , self.components, self.i3dMappings)\n            easyArmControl.lastValidPositionY = { getTranslation(easyArmControl.targetNodeY) }\n            easyArmControl.lastValidPositionZ = { getTranslation(easyArmControl.targetNodeZ) }\n\n            easyArmControl.moveSpeed = xmlFile:getValue(key .. ".targetMovement#speed" , 1 ) / 1000\n            easyArmControl.moveAcceleration = xmlFile:getValue(key .. ".targetMovement#acceleration" , 50 ) / ( 1000 * 1000 )\n            easyArmControl.lastSpeedY = 0\n            easyArmControl.lastSpeedZ = 0\n\n            easyArmControl.minTransMoveRatio = xmlFile:getValue(key .. ".zTranslationNodes#minMoveRatio" , 0.2 )\n            easyArmControl.maxTransMoveRatio = xmlFile:getValue(key .. ".zTranslationNodes#maxMoveRatio" , 0.8 )\n            easyArmControl.transMoveRatioMinDir = xmlFile:getValue(key .. ".zTranslationNodes#moveRatioMinDir" , 0 )\n            easyArmControl.transMoveRatioMaxDir = xmlFile:getValue(key .. ".zTranslationNodes#moveRatioMaxDir" , 1 )\n            easyArmControl.allowNegativeTrans = xmlFile:getValue(key .. ".zTranslationNodes#allowNegativeTrans" , false )\n            easyArmControl.minNegativeTrans = xmlFile:getValue(key .. ".zTranslationNodes#minNegativeTrans" , 0 )\n\n            easyArmControl.forcedTransMove = nil\n\n            easyArmControl.zTranslationNodes = { }\n            local maxTrans = 0\n            xmlFile:iterate(key .. ".zTranslationNodes.zTranslationNode" , function (_, transKey)\n                local node = xmlFile:getValue(transKey .. "#node" , nil , self.components, self.i3dMappings)\n                if node ~ = nil then\n                    local movingTool = self:getMovingToolByNode(node)\n                    if movingTool ~ = nil then\n                        local maxDistance = math.abs(movingTool.transMin - movingTool.transMax)\n                        maxTrans = maxTrans + maxDistance\n                        movingTool.easyArmControlActive = false\n                        table.insert(easyArmControl.zTranslationNodes, { node = node, movingTool = movingTool, maxDistance = maxDistance, transFactor = 0 , startTranslation = { getTranslation(node) } } )\n                    end\n                end\n            end )\n\n            for _, translationNode in ipairs(easyArmControl.zTranslationNodes) do\n                translationNode.transFactor = translationNode.maxDistance / maxTrans\n            end\n\n            easyArmControl.xRotationNodes = { }\n            for i = 1 , 2 do\n                local xRotKey = string.format( "%s.xRotationNodes.xRotationNode%d" , key, i)\n                if not xmlFile:hasProperty(xRotKey) then\n                    Logging.xmlWarning(xmlFile, "Missing second xRotation node for easy control!" )\n                        return false\n                    end\n\n                    XMLUtil.checkDeprecatedXMLElements(xmlFile, xRotKey .. "#refNode" ) --FS19 to FS22\n\n                    local node = xmlFile:getValue(xRotKey .. "#node" , nil , self.components, self.i3dMappings)\n                    if node ~ = nil then\n                        local movingTool = self:getMovingToolByNode(node)\n                        if movingTool ~ = nil then\n                            movingTool.easyArmControlActive = false\n                            table.insert(easyArmControl.xRotationNodes, { node = node, movingTool = movingTool, startRotation = { getRotation(node) } } )\n                        end\n                    end\n                end\n\n                if #easyArmControl.xRotationNodes ~ = 2 then\n                    Logging.xmlWarning(xmlFile, "Easy arm control requires two x rotation nodes! Only %d given. (%s)" , #easyArmControl.xRotationNodes, key)\n                    return false\n                end\n\n                if easyArmControl.targetRefNode ~ = nil then\n                    local xOffset, yOffset, _ = localToLocal(easyArmControl.targetRefNode, easyArmControl.xRotationNodes[ 2 ].node, 0 , 0 , 0 )\n                    if math.abs(xOffset) > 0.0001 or math.abs(yOffset) > 0.0001 then\n                        Logging.xmlWarning(xmlFile, "Invalid position of \'%s\'.Offset to second xRotation node is not 0 on X or Y axis(x: %f y: %f)" , key .. "#refNode" , xOffset, yOffset)\n                        return false\n                    end\n                end\n\n                local xOffset, yOffset, _ = localToLocal(easyArmControl.xRotationNodes[ 2 ].node, easyArmControl.xRotationNodes[ 1 ].node, 0 , 0 , 0 )\n                if math.abs(xOffset) > 0.0001 or math.abs(yOffset) > 0.0001 then\n                    Logging.xmlWarning(xmlFile, "Invalid position of xRotationNode2.Offset to second xRotationNode1 is not 0 on X or Y axis(x: %f y: %f)" , xOffset, yOffset)\n                    return false\n                end\n\n                local rootOffset = calcDistanceFrom(easyArmControl.rootNode, easyArmControl.xRotationNodes[ 1 ].node)\n                if rootOffset > 0.05 then\n                    Logging.xmlWarning(xmlFile, "Distance between easyArmControl rootNode and xRotationNode1 is to big(%.2f).They should be at the same position." , rootOffset)\n                    return false\n                end\n\n                easyArmControl.maxTotalDistance = xmlFile:getValue(key .. "#maxTotalDistance" )\n                if easyArmControl.maxTotalDistance = = nil then\n                    -- move nodes to the max length state\n                    for i = 1 , #easyArmControl.xRotationNodes do\n                        local xRotationNode = easyArmControl.xRotationNodes[i]\n                        local curRot = { getRotation(xRotationNode.node) }\n                        curRot[xRotationNode.movingTool.rotationAxis] = xRotationNode.movingTool.rotMin\n                        setRotation(xRotationNode.node, curRot[ 1 ], curRot[ 2 ], curRot[ 3 ])\n                    end\n\n                    for i = 1 , #easyArmControl.zTranslationNodes do\n                        local zTranslationNode = easyArmControl.zTranslationNodes[i]\n                        local curTrans = { getTranslation(zTranslationNode.node) }\n                        curTrans[zTranslationNode.movingTool.translationAxis] = zTranslationNode.movingTool.transMax\n                        setTranslation(zTranslationNode.node, curTrans[ 1 ], curTrans[ 2 ], curTrans[ 3 ])\n                    end\n\n                    -- calculate max distances\n                    easyArmControl.maxTotalDistance = calcDistanceFrom(easyArmControl.rootNode, easyArmControl.targetRefNode)\n                    easyArmControl.maxTransDistance = calcDistanceFrom(easyArmControl.xRotationNodes[#easyArmControl.xRotationNodes].node, easyArmControl.targetRefNode)\n\n                    -- reset nodes again to previous states\n                    for i = 1 , #easyArmControl.xRotationNodes do\n                        local xRotationNode = easyArmControl.xRotationNodes[i]\n                        setRotation(xRotationNode.node, xRotationNode.startRotation[ 1 ], xRotationNode.startRotation[ 2 ], xRotationNode.startRotation[ 3 ])\n                    end\n\n                    for i = 1 , #easyArmControl.zTranslationNodes do\n                        local zTranslationNode = easyArmControl.zTranslationNodes[i]\n                        setTranslation(zTranslationNode.node, zTranslationNode.startTranslation[ 1 ], zTranslationNode.startTranslation[ 2 ], zTranslationNode.startTranslation[ 3 ])\n                    end\n                end\n            else\n                    Logging.xmlError(xmlFile, "Missing moving tools for easy control targets!" )\n                        return false\n                    end\n                else\n                        Logging.xmlError(xmlFile, "Missing easy control targets!" )\n                        return false\n                    end\n\n                    return true\n                end\n\n'})}),"\n",(0,o.jsx)(e.h3,{id:"loadextradependentparts",children:"loadExtraDependentParts"}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Description"})}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Definition"})}),"\n",(0,o.jsxs)(e.blockquote,{children:["\n",(0,o.jsx)(e.p,{children:"loadExtraDependentParts()"}),"\n"]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,o.jsxs)(e.table,{children:[(0,o.jsx)(e.thead,{children:(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.th,{children:"any"}),(0,o.jsx)(e.th,{children:"xmlFile"})]})}),(0,o.jsxs)(e.tbody,{children:[(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.td,{children:"any"}),(0,o.jsx)(e.td,{children:"baseName"})]}),(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.td,{children:"any"}),(0,o.jsx)(e.td,{children:"entry"})]})]})]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Code"})}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-lua",children:"function Cylindered:loadExtraDependentParts(xmlFile, baseName, entry)\n    return true\nend\n\n"})}),"\n",(0,o.jsx)(e.h3,{id:"loadmovingpartfromxml",children:"loadMovingPartFromXML"}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Description"})}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Definition"})}),"\n",(0,o.jsxs)(e.blockquote,{children:["\n",(0,o.jsx)(e.p,{children:"loadMovingPartFromXML()"}),"\n"]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,o.jsxs)(e.table,{children:[(0,o.jsx)(e.thead,{children:(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.th,{children:"any"}),(0,o.jsx)(e.th,{children:"xmlFile"})]})}),(0,o.jsxs)(e.tbody,{children:[(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.td,{children:"any"}),(0,o.jsx)(e.td,{children:"key"})]}),(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.td,{children:"any"}),(0,o.jsx)(e.td,{children:"entry"})]})]})]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Code"})}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-lua",children:'function Cylindered:loadMovingPartFromXML(xmlFile, key, entry)\n    XMLUtil.checkDeprecatedXMLElements(xmlFile, key .. "#index" , key .. "#node" ) --FS17 to FS19\n\n    local node = xmlFile:getValue(key .. "#node" , nil , self.components, self.i3dMappings)\n    local referenceFrame = xmlFile:getValue(key .. "#referenceFrame" , nil , self.components, self.i3dMappings)\n    if node ~ = nil and referenceFrame ~ = nil then\n        entry.referencePoint = xmlFile:getValue(key .. "#referencePoint" , nil , self.components, self.i3dMappings)\n        entry.referencePoints = xmlFile:getValue(key .. "#referencePoints" , nil , self.components, self.i3dMappings, true )\n        entry.numReferencePoints = #entry.referencePoints\n        entry.hasReferencePoints = entry.numReferencePoints > 0 or entry.referencePoint ~ = nil\n\n        entry.node = node\n        entry.parent = getParent(node)\n        entry.referenceFrame = referenceFrame\n        entry.invertZ = xmlFile:getValue(key .. "#invertZ" , false )\n        entry.scaleZ = xmlFile:getValue(key .. "#scaleZ" , false )\n        entry.limitedAxis = xmlFile:getValue(key .. "#limitedAxis" )\n        entry.isActiveDirty = xmlFile:getValue(key .. "#isActiveDirty" , false )\n        entry.playSound = xmlFile:getValue(key .. "#playSound" , false )\n\n        entry.moveToReferenceFrame = xmlFile:getValue(key .. "#moveToReferenceFrame" , false )\n        if entry.moveToReferenceFrame then\n            local x,y,z = worldToLocal(referenceFrame, getWorldTranslation(node))\n            entry.referenceFrameOffset = { x,y,z }\n        end\n\n        if entry.referenceFrame = = entry.node then\n            Logging.xmlWarning(xmlFile, "Reference frame equals moving part node.This can lead to bad behaviours! Node \'%s\' in \'%s\'." , getName(entry.node), key)\n        end\n\n        entry.doLineAlignment = xmlFile:getValue(key .. "#doLineAlignment" , false )\n        entry.doInversedLineAlignment = xmlFile:getValue(key .. "#doInversedLineAlignment" , false )\n        entry.do3DLineAlignment = xmlFile:getValue(key .. "#do3DLineAlignment" , false )\n        entry.partLength = xmlFile:getValue(key .. ".orientationLine#partLength" , 0.5 )\n        entry.partLengthNode = xmlFile:getValue(key .. ".orientationLine#partLengthNode" , nil , self.components, self.i3dMappings)\n\n        entry.orientationLineNodes = { }\n        for _, pointKey in self.xmlFile:iterator(key .. ".orientationLine.lineNode" ) do\n            local lineNode = xmlFile:getValue(pointKey .. "#node" , nil , self.components, self.i3dMappings)\n            if lineNode ~ = nil then\n                if entry.doInversedLineAlignment then\n                    local _, _, zOffset = localToLocal(lineNode, entry.node, 0 , 0 , 0 )\n                    if zOffset < 0 then\n                        Logging.xmlWarning(xmlFile, "Local orientation line node \'%s\' is in negative Z direction to the movingPart node.This is not allowed! (%s)" , getName(lineNode), pointKey)\n                        continue\n                    end\n                end\n\n                table.insert(entry.orientationLineNodes, lineNode)\n            end\n        end\n\n        if entry.do3DLineAlignment then\n            if #entry.orientationLineNodes = = 2 then\n                entry.orientationLineTransNode = xmlFile:getValue(key .. ".orientationLine#referenceTransNode" , nil , self.components, self.i3dMappings)\n                if entry.orientationLineTransNode = = nil then\n                    Logging.xmlWarning(xmlFile, "Failed to load 3D line alignment from xml.Missing referenceTransNode! (movingPart \'%s\')" , getName(node))\n                    entry.do3DLineAlignment = false\n                end\n            else\n                    Logging.xmlWarning(xmlFile, "Failed to load 3D line alignment from xml.Requires exactly two line nodes! (movingPart \'%s\')" , getName(node))\n                    entry.do3DLineAlignment = false\n                end\n            end\n\n            entry.doDirectionAlignment = xmlFile:getValue(key .. "#doDirectionAlignment" , true )\n            entry.doRotationAlignment = xmlFile:getValue(key .. "#doRotationAlignment" , false )\n            entry.rotMultiplier = xmlFile:getValue(key .. "#rotMultiplier" , 0 )\n\n            if entry.doDirectionAlignment and entry.doRotationAlignment then\n                Logging.xmlWarning(xmlFile, "Direction alignment and rotation alignment used at the same time for movingPart \'%s\' in \'%s\'" , getName(node), key)\n                    return false\n                end\n\n                if entry.doDirectionAlignment and(entry.doLineAlignment or entry.doInversedLineAlignment or entry.do3DLineAlignment) then\n                    Logging.xmlWarning(xmlFile, "Direction alignment and line alignment used at the same time for movingPart \'%s\' in \'%s\'" , getName(node), key)\n                        return false\n                    end\n\n                    local minRot = xmlFile:getValue(key .. "#minRot" )\n                    local maxRot = xmlFile:getValue(key .. "#maxRot" )\n                    if minRot ~ = nil and maxRot ~ = nil then\n                        if entry.limitedAxis ~ = nil then\n                            entry.minRot = MathUtil.getValidLimit(minRot)\n                            entry.maxRot = MathUtil.getValidLimit(maxRot)\n                        else\n                                Logging.xmlWarning(xmlFile, "minRot/maxRot requires the use of limitedAxis in for movingPart \'%s\' in \'%s\'" , getName(node), key)\n                                end\n                            end\n                            entry.alignToWorldY = xmlFile:getValue(key .. "#alignToWorldY" , false )\n\n                            if entry.hasReferencePoints then\n                                local localReferencePoint = xmlFile:getValue(key .. "#localReferencePoint" , nil , self.components, self.i3dMappings)\n\n                                local refX, refY, refZ\n                                if entry.referencePoint ~ = nil then\n                                    refX, refY, refZ = worldToLocal(node, getWorldTranslation(entry.referencePoint))\n                                else\n                                        refX, refY, refZ = 0 , 0 , 0\n                                        for i, referencePoint in ipairs(entry.referencePoints) do\n                                            local x, y, z = worldToLocal(node, getWorldTranslation(referencePoint))\n                                            refX, refY, refZ = refX + x, refY + y, refZ + z\n                                        end\n\n                                        refX, refY, refZ = refX / entry.numReferencePoints, refY / entry.numReferencePoints, refZ / entry.numReferencePoints\n                                    end\n\n                                    local _\n                                    _, _, entry.smoothedDirectionScaleZOffset = worldToLocal(entry.node, refX, refY, refZ)\n\n                                    if localReferencePoint ~ = nil then\n                                        local x,y,z = worldToLocal(node, getWorldTranslation(localReferencePoint))\n\n                                        entry.referenceDistance = MathUtil.vector3Length(refX - x, refY - y, refZ - z)\n                                        entry.lastReferenceDistance = entry.referenceDistance\n                                        entry.localReferencePoint = { x, y, z }\n\n                                        local side = y * (refZ - z) - z * (refY - y)\n                                        entry.localReferenceAngleSide = side\n                                        entry.localReferencePointNode = localReferencePoint\n                                        entry.updateLocalReferenceDistance = xmlFile:getValue(key .. "#updateLocalReferenceDistance" , false )\n                                        entry.localReferenceTranslate = xmlFile:getValue(key .. "#localReferenceTranslate" , false )\n                                        if entry.localReferenceTranslate then\n                                            entry.localReferenceTranslation = { getTranslation(entry.node) }\n                                        end\n\n                                        entry.dynamicLocalReferenceDistance = xmlFile:getValue(key .. "#dynamicLocalReferenceDistance" , false )\n                                    else\n                                            entry.referenceDistance = 0\n                                            entry.localReferencePoint = { refX, refY, refZ }\n                                        end\n                                        entry.referenceDistanceThreshold = xmlFile:getValue(key .. "#referenceDistanceThreshold" , 0.0001 )\n\n                                        entry.useLocalOffset = xmlFile:getValue(key .. "#useLocalOffset" , false )\n                                        entry.referencePointOffset = xmlFile:getValue(key .. "#referencePointOffset" )\n\n                                        entry.referenceDistance = xmlFile:getValue(key .. "#referenceDistance" , entry.referenceDistance)\n\n                                        entry.referenceDistancePoint = xmlFile:getValue(key .. "#referenceDistancePoint" , nil , self.components, self.i3dMappings)\n\n                                        entry.localReferenceDistance = xmlFile:getValue(key .. "#localReferenceDistance" , MathUtil.vector2Length(entry.localReferencePoint[ 2 ], entry.localReferencePoint[ 3 ]))\n\n                                        self:loadDependentTranslatingParts(xmlFile, key, entry)\n                                    end\n\n                                    self:loadDependentMovingTools(xmlFile, key, entry)\n\n                                    -- direction threshold for updateing the moving tools of the vehicle is entered/active\n                                        entry.directionThreshold = xmlFile:getValue(key .. "#directionThreshold" , 0.0001 )\n                                        entry.directionThresholdActive = xmlFile:getValue(key .. "#directionThresholdActive" , 0.00001 )\n\n                                        if entry.doDirectionAlignment and not entry.hasReferencePoints then\n                                            entry.directionThreshold = 0\n                                            entry.directionThresholdActive = 0\n                                        end\n\n                                        entry.maxUpdateDistance = xmlFile:getValue(key .. "#maxUpdateDistance" , "-" )\n                                        if entry.maxUpdateDistance = = "-" then\n                                            entry.maxUpdateDistance = math.huge\n                                        else\n                                                entry.maxUpdateDistance = tonumber(entry.maxUpdateDistance)\n                                            end\n\n                                            if entry.isActiveDirty and(xmlFile:getString(key .. "#maxUpdateDistance" ) = = nil or entry.maxUpdateDistance = = nil ) then\n                                                Logging.xmlWarning(xmlFile, "No max.update distance set for isActiveDirty moving part \'%s\'! Use #maxUpdateDistance attribute." , getName(node))\n                                                end\n\n                                                entry.smoothedDirectionScale = xmlFile:getValue(key .. "#smoothedDirectionScale" , false )\n                                                entry.smoothedDirectionTime = 1 / (xmlFile:getValue(key .. "#smoothedDirectionTime" , 2 ))\n                                                entry.smoothedDirectionScaleAlpha = nil\n\n                                                if entry.smoothedDirectionScale then\n                                                    entry.initialDirection = { localDirectionToLocal(entry.node, getParent(entry.node), 0 , 0 , 1 ) }\n                                                end\n\n                                                entry.debug = xmlFile:getValue(key .. "#debug" , false )\n                                                if entry.debug then\n                                                    Logging.xmlWarning(xmlFile, "MovingPart debug enabled for moving part \'%s\'" , getName(node))\n                                                    end\n\n                                                    entry.lastDirection = { 0 , 0 , 0 }\n                                                    entry.lastUpVector = { 0 , 0 , 0 }\n\n                                                    entry.isDirty = false\n                                                    entry.isPart = true\n                                                    entry.isActive = true\n\n                                                    return true\n                                                end\n\n                                                return false\n                                            end\n\n'})}),"\n",(0,o.jsx)(e.h3,{id:"loadmovingpartsfromxml",children:"loadMovingPartsFromXML"}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Description"})}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Definition"})}),"\n",(0,o.jsxs)(e.blockquote,{children:["\n",(0,o.jsx)(e.p,{children:"loadMovingPartsFromXML()"}),"\n"]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,o.jsxs)(e.table,{children:[(0,o.jsx)(e.thead,{children:(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.th,{children:"any"}),(0,o.jsx)(e.th,{children:"xmlFile"})]})}),(0,o.jsx)(e.tbody,{children:(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.td,{children:"any"}),(0,o.jsx)(e.td,{children:"key"})]})})]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Code"})}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-lua",children:"function Cylindered:loadMovingPartsFromXML(xmlFile, key)\n    local spec = self.spec_cylindered\n\n    for _, partKey in xmlFile:iterator(key) do\n        local entry = { }\n        if self:loadMovingPartFromXML(xmlFile, partKey, entry) then\n            if spec.referenceNodes[entry.node] = = nil then\n                spec.referenceNodes[entry.node] = { }\n            end\n            if spec.nodesToMovingParts[entry.node] = = nil then\n                table.insert(spec.referenceNodes[entry.node], entry)\n\n                self:loadDependentParts(xmlFile, partKey, entry)\n                self:loadDependentComponentJoints(xmlFile, partKey, entry)\n                self:loadCopyLocalDirectionParts(xmlFile, partKey, entry)\n                self:loadExtraDependentParts(xmlFile, partKey, entry)\n                self:loadDependentAnimations(xmlFile, partKey, entry)\n\n                entry.key = partKey\n                table.insert(spec.movingParts, entry)\n\n                if entry.isActiveDirty then\n                    table.insert(spec.activeDirtyMovingParts, entry)\n                end\n\n                spec.nodesToMovingParts[entry.node] = entry\n            else\n                    Logging.xmlWarning(xmlFile, \"Moving part with node '%s' already exists!\" , getName(entry.node))\n                end\n            end\n        end\n    end\n\n"})}),"\n",(0,o.jsx)(e.h3,{id:"loadmovingtoolfromxml",children:"loadMovingToolFromXML"}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Description"})}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Definition"})}),"\n",(0,o.jsxs)(e.blockquote,{children:["\n",(0,o.jsx)(e.p,{children:"loadMovingToolFromXML()"}),"\n"]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,o.jsxs)(e.table,{children:[(0,o.jsx)(e.thead,{children:(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.th,{children:"any"}),(0,o.jsx)(e.th,{children:"xmlFile"})]})}),(0,o.jsxs)(e.tbody,{children:[(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.td,{children:"any"}),(0,o.jsx)(e.td,{children:"key"})]}),(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.td,{children:"any"}),(0,o.jsx)(e.td,{children:"entry"})]})]})]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Code"})}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-lua",children:'function Cylindered:loadMovingToolFromXML(xmlFile, key, entry)\n    local spec = self.spec_cylindered\n\n    XMLUtil.checkDeprecatedXMLElements(xmlFile, key .. "#index" , key .. "#node" ) --FS17 to FS19\n\n    local node = xmlFile:getValue(key .. "#node" , nil , self.components, self.i3dMappings)\n    if node ~ = nil then\n        entry.node = node\n\n        entry.externalMove = 0\n        entry.easyArmControlActive = true\n        entry.isEasyControlTarget = xmlFile:getValue(key .. "#isEasyControlTarget" , false )\n\n        entry.networkInterpolators = { }\n\n        -- rotation\n        XMLUtil.checkDeprecatedXMLElements(xmlFile, key .. "#rotSpeed" , key .. ".rotation#rotSpeed" ) --FS15 to FS17\n\n        local rotSpeed = xmlFile:getValue(key .. ".rotation#rotSpeed" )\n        if rotSpeed ~ = nil then\n            entry.rotSpeed = rotSpeed / 1000\n        end\n        local rotAcceleration = xmlFile:getValue(key .. ".rotation#rotAcceleration" )\n        if rotAcceleration ~ = nil then\n            entry.rotAcceleration = rotAcceleration / ( 1000 * 1000 )\n        end\n        entry.lastRotSpeed = 0\n        entry.rotMax = xmlFile:getValue(key .. ".rotation#rotMax" )\n        entry.rotMin = xmlFile:getValue(key .. ".rotation#rotMin" )\n        entry.syncMaxRotLimits = xmlFile:getValue(key .. ".rotation#syncMaxRotLimits" , false )\n        entry.syncMinRotLimits = xmlFile:getValue(key .. ".rotation#syncMinRotLimits" , false )\n        entry.rotSendNumBits = xmlFile:getValue(key .. ".rotation#rotSendNumBits" )\n        entry.attachRotMax = xmlFile:getValue(key .. ".rotation#attachRotMax" )\n        entry.attachRotMin = xmlFile:getValue(key .. ".rotation#attachRotMin" )\n\n        if entry.rotSendNumBits = = nil then\n            if entry.rotMin ~ = nil and entry.rotMax ~ = nil then\n                local range = entry.rotMax - entry.rotMin\n                local requiredMinValues = math.ceil(range / Cylindered.MOVING_TOOL_SEND_MIN_RESOLUTION)\n\n                local bitsToUse = 11\n                for i = 11 , 1 , - 1 do\n                    local availableValues = 2 ^ i - 1\n                    if requiredMinValues < = availableValues then\n                        bitsToUse = i\n                    end\n                end\n\n                entry.rotSendNumBits = bitsToUse\n            else\n                    entry.rotSendNumBits = 11 -- 0.35deg precision for 360deg rotation\n                    end\n                end\n\n                if entry.rotMin ~ = nil and entry.rotMax ~ = nil then\n                    if entry.rotMin > = entry.rotMax then\n                        Logging.xmlWarning(xmlFile, "Rotation min value is greater or equal to max value for movingTool \'%s\' in \'%s\'" , getName(node), key)\n                            return false\n                        end\n                    end\n\n                    -- translation\n                    XMLUtil.checkDeprecatedXMLElements(xmlFile, key .. "#transSpeed" , key .. ".rotation#transSpeed" ) --FS15 to FS17\n\n                    local transSpeed = xmlFile:getValue(key .. ".translation#transSpeed" )\n                    if transSpeed ~ = nil then\n                        entry.transSpeed = transSpeed / 1000\n                    end\n                    local transAcceleration = xmlFile:getValue(key .. ".translation#transAcceleration" )\n                    if transAcceleration ~ = nil then\n                        entry.transAcceleration = transAcceleration / ( 1000 * 1000 )\n                    end\n                    entry.lastTransSpeed = 0\n                    entry.transMax = xmlFile:getValue(key .. ".translation#transMax" )\n                    entry.transMin = xmlFile:getValue(key .. ".translation#transMin" )\n                    entry.attachTransMax = xmlFile:getValue(key .. ".translation#attachTransMax" )\n                    entry.attachTransMin = xmlFile:getValue(key .. ".translation#attachTransMin" )\n                    entry.playSound = xmlFile:getValue(key .. "#playSound" , false )\n\n                    if entry.transMin ~ = nil and entry.transMax ~ = nil then\n                        if entry.transMin > = entry.transMax then\n                            Logging.xmlWarning(xmlFile, "Translation min value is greater or equal to max value for movingTool \'%s\' in \'%s\'" , getName(node), key)\n                                return false\n                            end\n                        end\n\n                        entry.isConsumingPower = xmlFile:getValue(key .. "#isConsumingPower" , false )\n\n                        -- animation\n                        if SpecializationUtil.hasSpecialization( AnimatedVehicle , self.specializations) then\n                            local animSpeed = xmlFile:getValue(key .. ".animation#animSpeed" )\n                            if animSpeed ~ = nil then\n                                entry.animSpeed = animSpeed / 1000\n                            end\n                            local animAcceleration = xmlFile:getValue(key .. ".animation#animAcceleration" )\n                            if animAcceleration ~ = nil then\n                                entry.animAcceleration = animAcceleration / ( 1000 * 1000 )\n                            end\n                            entry.curAnimTime = 0\n                            entry.lastAnimSpeed = 0\n                            entry.animName = xmlFile:getValue(key .. ".animation#animName" )\n                            entry.animSendNumBits = xmlFile:getValue(key .. ".animation#animSendNumBits" , 8 )\n                            entry.animMaxTime = math.min(xmlFile:getValue(key .. ".animation#animMaxTime" , 1.0 ), 1.0 )\n                            entry.animMinTime = math.max(xmlFile:getValue(key .. ".animation#animMinTime" , 0.0 ), 0.0 )\n\n                            if entry.animMinTime > = entry.animMaxTime then\n                                Logging.xmlWarning(xmlFile, "Animation min value is greater or equal to max value for movingTool \'%s\' in \'%s\'" , getName(node), key)\n                                    return false\n                                end\n\n                                entry.animStartTime = xmlFile:getValue(key .. ".animation#animStartTime" )\n                                if entry.animStartTime ~ = nil then\n                                    entry.curAnimTime = entry.animStartTime\n                                end\n\n                                entry.networkInterpolators.animation = InterpolatorValue.new(entry.curAnimTime)\n                                entry.networkInterpolators.animation:setMinMax( 0 , 1 )\n\n                                entry.networkInterpolators.resetAnimInterpolation = false\n                            end\n\n                            XMLUtil.checkDeprecatedXMLElements(xmlFile, key .. ".controls#iconFilename" , key .. ".controls#iconName" ) --FS17 to FS19\n\n                            local iconName = xmlFile:getValue(key .. ".controls#iconName" )\n                            if iconName ~ = nil then\n                                if InputHelpElement.AXIS_ICON[iconName] = = nil then\n                                    -- add the mod name as a prefix to match axis icon loading name collision avoidance\n                                    iconName = ( self.customEnvironment or "" ) .. iconName\n                                end\n\n                                entry.axisActionIcon = iconName\n                            end\n\n                            entry.controlGroupIndex = xmlFile:getValue(key .. ".controls#groupIndex" , 0 )\n                            if entry.controlGroupIndex ~ = 0 then\n                                if spec.controlGroupNames[entry.controlGroupIndex] ~ = nil then\n                                    table.addElement(spec.controlGroups, entry.controlGroupIndex)\n                                else\n                                        Logging.xmlWarning(xmlFile, "ControlGroup \'%d\' not defined for \'%s\'!" , entry.controlGroupIndex, key)\n                                        end\n                                    end\n\n                                    entry.axis = xmlFile:getValue(key .. ".controls#axis" )\n                                    if entry.axis ~ = nil then\n                                        entry.axisActionIndex = InputAction[entry.axis]\n                                    end\n                                    entry.invertAxis = xmlFile:getValue(key .. ".controls#invertAxis" , false )\n                                    entry.mouseSpeedFactor = xmlFile:getValue(key .. ".controls#mouseSpeedFactor" , 1.0 )\n\n                                    if (entry.rotSpeed ~ = nil or entry.transSpeed ~ = nil or entry.animSpeed ~ = nil ) then\n                                        entry.dirtyFlag = self:getNextDirtyFlag()\n                                        entry.saving = xmlFile:getValue(key .. "#allowSaving" , true )\n                                    end\n\n                                    entry.aiActivePosition = xmlFile:getValue(key .. "#aiActivePosition" )\n\n                                    entry.isDirty = false\n                                    entry.isIntitialDirty = xmlFile:getValue(key .. "#isIntitialDirty" , true )\n\n                                    entry.rotationAxis = xmlFile:getValue(key .. ".rotation#rotationAxis" , 1 )\n                                    entry.translationAxis = xmlFile:getValue(key .. ".translation#translationAxis" , 3 )\n\n                                    local detachingRotMaxLimit = xmlFile:getValue(key .. ".rotation#detachingRotMaxLimit" )\n                                    local detachingRotMinLimit = xmlFile:getValue(key .. ".rotation#detachingRotMinLimit" )\n                                    local detachingTransMaxLimit = xmlFile:getValue(key .. ".translation#detachingTransMaxLimit" )\n                                    local detachingTransMinLimit = xmlFile:getValue(key .. ".translation#detachingTransMinLimit" )\n                                    if detachingRotMaxLimit ~ = nil or detachingRotMinLimit ~ = nil or detachingTransMaxLimit ~ = nil or detachingTransMinLimit ~ = nil then\n                                        if spec.detachLockNodes = = nil then\n                                            spec.detachLockNodes = { }\n                                        end\n\n                                        local detachLock = { }\n                                        detachLock.detachingRotMaxLimit = detachingRotMaxLimit\n                                        detachLock.detachingRotMinLimit = detachingRotMinLimit\n                                        detachLock.detachingTransMinLimit = detachingTransMinLimit\n                                        detachLock.detachingTransMaxLimit = detachingTransMaxLimit\n\n                                        spec.detachLockNodes[entry] = detachLock\n                                    end\n\n                                    entry.hasRequiredConfigurations = true\n                                    local requiredConfigurationName = xmlFile:getValue(key .. "#requiredConfigurationName" )\n                                    if requiredConfigurationName ~ = nil then\n                                        local requiredConfigurationIndices = xmlFile:getValue(key .. "#requiredConfigurationIndices" , nil , true )\n                                        if requiredConfigurationIndices ~ = nil then\n                                            entry.hasRequiredConfigurations = false\n                                            for i = 1 , #requiredConfigurationIndices do\n                                                if self.configurations[requiredConfigurationName] = = requiredConfigurationIndices[i] then\n                                                    entry.hasRequiredConfigurations = true\n                                                    break\n                                                end\n                                            end\n                                        end\n                                    end\n\n                                    local rx,ry,rz = getRotation(node)\n                                    entry.curRot = { rx,ry,rz }\n                                    local x,y,z = getTranslation(node)\n                                    entry.curTrans = { x,y,z }\n\n                                    entry.startRot = xmlFile:getValue(key .. ".rotation#startRot" )\n                                    entry.startTrans = xmlFile:getValue(key .. ".translation#startTrans" )\n\n                                    entry.move = 0\n                                    entry.moveToSend = 0\n\n                                    entry.smoothedMove = 0\n                                    entry.lastInputTime = 0\n\n                                    -- delayed node\n                                    XMLUtil.checkDeprecatedXMLElements(xmlFile, key .. "#delayedIndex" , key .. "#delayedNode" ) --FS17 to FS19\n\n                                    entry.delayedNode = xmlFile:getValue(key .. "#delayedNode" , nil , self.components, self.i3dMappings)\n                                    if entry.delayedNode ~ = nil then\n                                        entry.delayedFrames = xmlFile:getValue(key .. "#delayedFrames" , 3 )\n\n                                        entry.currentDelayedData = { rot = { rx, ry, rz } , trans = { x, y, z } }\n                                        entry.delayedHistroyData = { }\n                                        for i = 1 , entry.delayedFrames do\n                                            entry.delayedHistroyData[i] = { rot = { rx, ry, rz } , trans = { x, y, z } }\n                                        end\n\n                                        entry.delayedHistoryIndex = 0\n                                    end\n\n                                    entry.networkInterpolators.translation = InterpolatorValue.new(entry.curTrans[entry.translationAxis])\n                                    entry.networkInterpolators.translation:setMinMax(entry.transMin, entry.transMax)\n                                    entry.networkInterpolators.rotation = InterpolatorAngle.new(entry.curRot[entry.rotationAxis])\n                                    entry.networkInterpolators.rotation:setMinMax(entry.rotMin, entry.rotMax)\n                                    entry.networkTimeInterpolator = InterpolationTime.new( 1.2 )\n\n                                    entry.isTool = true\n\n                                    return true\n                                end\n\n                                return false\n                            end\n\n'})}),"\n",(0,o.jsx)(e.h3,{id:"loadmovingtoolsfromxml",children:"loadMovingToolsFromXML"}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Description"})}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Definition"})}),"\n",(0,o.jsxs)(e.blockquote,{children:["\n",(0,o.jsx)(e.p,{children:"loadMovingToolsFromXML()"}),"\n"]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,o.jsxs)(e.table,{children:[(0,o.jsx)(e.thead,{children:(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.th,{children:"any"}),(0,o.jsx)(e.th,{children:"xmlFile"})]})}),(0,o.jsx)(e.tbody,{children:(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.td,{children:"any"}),(0,o.jsx)(e.td,{children:"key"})]})})]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Code"})}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-lua",children:"function Cylindered:loadMovingToolsFromXML(xmlFile, key)\n    local spec = self.spec_cylindered\n\n    for _, toolKey in xmlFile:iterator(key) do\n        local entry = { }\n        if self:loadMovingToolFromXML(xmlFile, toolKey, entry) then\n            if spec.referenceNodes[entry.node] = = nil then\n                spec.referenceNodes[entry.node] = { }\n            end\n\n            if spec.nodesToMovingTools[entry.node] = = nil then\n                table.insert(spec.referenceNodes[entry.node], entry)\n\n                self:loadDependentMovingTools(xmlFile, toolKey, entry)\n                self:loadDependentParts(xmlFile, toolKey, entry)\n                self:loadDependentComponentJoints(xmlFile, toolKey, entry)\n                self:loadExtraDependentParts(xmlFile, toolKey, entry)\n                self:loadDependentAnimations(xmlFile, toolKey, entry)\n\n                entry.isActive = true\n                entry.key = toolKey\n                table.insert(spec.movingTools, entry)\n                spec.nodesToMovingTools[entry.node] = entry\n            else\n                    Logging.xmlWarning(xmlFile, \"Moving tool with node '%s' already exists!\" , getName(entry.node))\n                end\n            end\n        end\n    end\n\n"})}),"\n",(0,o.jsx)(e.h3,{id:"loadobjectchangevaluesfromxml",children:"loadObjectChangeValuesFromXML"}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Description"})}),"\n",(0,o.jsxs)(e.blockquote,{children:["\n",(0,o.jsx)(e.p,{children:"Load object change from xml"}),"\n"]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Definition"})}),"\n",(0,o.jsxs)(e.blockquote,{children:["\n",(0,o.jsx)(e.p,{children:"loadObjectChangeValuesFromXML(XMLFile xmlFile, string key, integer node, table object, )"}),"\n"]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,o.jsxs)(e.table,{children:[(0,o.jsx)(e.thead,{children:(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.th,{children:"XMLFile"}),(0,o.jsx)(e.th,{children:"xmlFile"}),(0,o.jsx)(e.th,{children:"XMLFile instance"})]})}),(0,o.jsxs)(e.tbody,{children:[(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.td,{children:"string"}),(0,o.jsx)(e.td,{children:"key"}),(0,o.jsx)(e.td,{children:"key"})]}),(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.td,{children:"integer"}),(0,o.jsx)(e.td,{children:"node"}),(0,o.jsx)(e.td,{children:"node id"})]}),(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.td,{children:"table"}),(0,o.jsx)(e.td,{children:"object"}),(0,o.jsx)(e.td,{children:"object"})]}),(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.td,{children:"any"}),(0,o.jsx)(e.td,{children:"object"}),(0,o.jsx)(e.td,{})]})]})]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Code"})}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-lua",children:'function Cylindered:loadObjectChangeValuesFromXML(superFunc, xmlFile, key, node, object)\n    superFunc( self , xmlFile, key, node, object)\n\n    local spec = self.spec_cylindered\n\n    if spec.nodesToMovingTools ~ = nil and spec.nodesToMovingTools[node] ~ = nil then\n        local movingTool = spec.nodesToMovingTools[node]\n        object.movingToolRotMaxActive = xmlFile:getValue(key .. "#movingToolRotMaxActive" , math.deg(movingTool.rotMax or 0 ))\n        object.movingToolRotMaxInactive = xmlFile:getValue(key .. "#movingToolRotMaxInactive" , math.deg(movingTool.rotMax or 0 ))\n        object.movingToolRotMinActive = xmlFile:getValue(key .. "#movingToolRotMinActive" , math.deg(movingTool.rotMin or 0 ))\n        object.movingToolRotMinInactive = xmlFile:getValue(key .. "#movingToolRotMinInactive" , math.deg(movingTool.rotMin or 0 ))\n\n        object.movingToolStartRotActive = xmlFile:getValue(key .. "#movingToolStartRotActive" )\n        object.movingToolStartRotInactive = xmlFile:getValue(key .. "#movingToolStartRotInactive" )\n\n        object.movingToolTransMaxActive = xmlFile:getValue(key .. "#movingToolTransMaxActive" , movingTool.transMax)\n        object.movingToolTransMaxInactive = xmlFile:getValue(key .. "#movingToolTransMaxInactive" , movingTool.transMax)\n        object.movingToolTransMinActive = xmlFile:getValue(key .. "#movingToolTransMinActive" , movingTool.transMin)\n        object.movingToolTransMinInactive = xmlFile:getValue(key .. "#movingToolTransMinInactive" , movingTool.transMin)\n\n        object.movingToolStartTransActive = xmlFile:getValue(key .. "#movingToolStartTransActive" )\n        object.movingToolStartTransInactive = xmlFile:getValue(key .. "#movingToolStartTransInactive" )\n    end\n\n    ObjectChangeUtil.loadValueType(object.values, xmlFile, key, "movingPartUpdate" , nil ,\n    function (state)\n        if self.getMovingPartByNode ~ = nil then\n            local movingPart = self:getMovingPartByNode(node)\n            if movingPart ~ = nil then\n                movingPart.isActive = state\n            end\n        end\n    end , false )\nend\n\n'})}),"\n",(0,o.jsx)(e.h3,{id:"loadrotationbasedlimits",children:"loadRotationBasedLimits"}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Description"})}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Definition"})}),"\n",(0,o.jsxs)(e.blockquote,{children:["\n",(0,o.jsx)(e.p,{children:"loadRotationBasedLimits()"}),"\n"]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,o.jsxs)(e.table,{children:[(0,o.jsx)(e.thead,{children:(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.th,{children:"any"}),(0,o.jsx)(e.th,{children:"xmlFile"})]})}),(0,o.jsxs)(e.tbody,{children:[(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.td,{children:"any"}),(0,o.jsx)(e.td,{children:"key"})]}),(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.td,{children:"any"}),(0,o.jsx)(e.td,{children:"tool"})]})]})]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Code"})}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-lua",children:'function Cylindered:loadRotationBasedLimits(xmlFile, key, tool)\n    local rotation = xmlFile:getValue(key .. "#rotation" )\n    local rotMin = xmlFile:getValue(key .. "#rotMin" )\n    local rotMax = xmlFile:getValue(key .. "#rotMax" )\n    local transMin = xmlFile:getValue(key .. "#transMin" )\n    local transMax = xmlFile:getValue(key .. "#transMax" )\n\n    if rotation ~ = nil and(rotMin ~ = nil or rotMax ~ = nil or transMin ~ = nil or transMax ~ = nil ) then\n        local time = rotation\n        if tool.rotMin ~ = nil and tool.rotMax ~ = nil then\n            -- normalize to moving tool range if we are inside a moving tool\n                time = (rotation - tool.rotMin) / (tool.rotMax - tool.rotMin)\n            end\n\n            return { rotMin = rotMin, rotMax = rotMax, transMin = transMin, transMax = transMax, time = time }\n        end\n\n        return nil\n    end\n\n'})}),"\n",(0,o.jsx)(e.h3,{id:"loadshovelnode",children:"loadShovelNode"}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Description"})}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Definition"})}),"\n",(0,o.jsxs)(e.blockquote,{children:["\n",(0,o.jsx)(e.p,{children:"loadShovelNode()"}),"\n"]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,o.jsxs)(e.table,{children:[(0,o.jsx)(e.thead,{children:(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.th,{children:"any"}),(0,o.jsx)(e.th,{children:"superFunc"})]})}),(0,o.jsxs)(e.tbody,{children:[(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.td,{children:"any"}),(0,o.jsx)(e.td,{children:"xmlFile"})]}),(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.td,{children:"any"}),(0,o.jsx)(e.td,{children:"key"})]}),(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.td,{children:"any"}),(0,o.jsx)(e.td,{children:"entry"})]})]})]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Code"})}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-lua",children:'function Cylindered:loadShovelNode(superFunc, xmlFile, key, entry)\n    if not superFunc( self , xmlFile, key, entry) then\n        return false\n    end\n\n    local baseKey = key .. ".movingToolActivation"\n    if not xmlFile:hasProperty(baseKey) then\n        return true\n    end\n\n    entry.movingToolActivation = { }\n    entry.movingToolActivation.node = xmlFile:getValue(baseKey .. "#node" , nil , self.components, self.i3dMappings)\n    entry.movingToolActivation.isInverted = xmlFile:getValue(baseKey .. "#isInverted" , false )\n    entry.movingToolActivation.openFactor = xmlFile:getValue(baseKey .. "#openFactor" , 1 )\n\n    return true\nend\n\n'})}),"\n",(0,o.jsx)(e.h3,{id:"movingtooldashboardattributes",children:"movingToolDashboardAttributes"}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Description"})}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Definition"})}),"\n",(0,o.jsxs)(e.blockquote,{children:["\n",(0,o.jsx)(e.p,{children:"movingToolDashboardAttributes()"}),"\n"]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,o.jsxs)(e.table,{children:[(0,o.jsx)(e.thead,{children:(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.th,{children:"any"}),(0,o.jsx)(e.th,{children:"self"})]})}),(0,o.jsxs)(e.tbody,{children:[(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.td,{children:"any"}),(0,o.jsx)(e.td,{children:"xmlFile"})]}),(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.td,{children:"any"}),(0,o.jsx)(e.td,{children:"key"})]}),(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.td,{children:"any"}),(0,o.jsx)(e.td,{children:"dashboard"})]}),(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.td,{children:"any"}),(0,o.jsx)(e.td,{children:"components"})]}),(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.td,{children:"any"}),(0,o.jsx)(e.td,{children:"i3dMappings"})]})]})]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Code"})}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-lua",children:'function Cylindered.movingToolDashboardAttributes( self , xmlFile, key, dashboard, components, i3dMappings)\n    dashboard.axis = xmlFile:getValue(key .. "#axis" )\n\n    if dashboard.axis = = nil then\n        Logging.xmlWarning(xmlFile, "Misssing axis attribute for dashboard \'%s\'" , key)\n            return false\n        end\n\n        local attacherJointIndex = xmlFile:getValue(key .. "#attacherJointIndex" )\n        if attacherJointIndex ~ = nil then\n            dashboard.attacherJointIndices = { }\n            table.insert(dashboard.attacherJointIndices, attacherJointIndex)\n        end\n\n        dashboard.attacherJointNode = xmlFile:getValue(key .. "#attacherJointNode" , nil , self.components, self.i3dMappings)\n        dashboard.attacherJointNodes = xmlFile:getValue(key .. "#attacherJointNodes" , nil , self.components, self.i3dMappings, true )\n        table.insert(dashboard.attacherJointNodes, dashboard.attacherJointNode)\n\n        if #dashboard.attacherJointNodes = = 0 then\n            dashboard.attacherJointNodes = nil\n        end\n\n        return true\n    end\n\n'})}),"\n",(0,o.jsx)(e.h3,{id:"onaiimplementstart",children:"onAIImplementStart"}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Description"})}),"\n",(0,o.jsxs)(e.blockquote,{children:["\n",(0,o.jsx)(e.p,{children:"Called when when the ai starts to work"}),"\n"]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Definition"})}),"\n",(0,o.jsxs)(e.blockquote,{children:["\n",(0,o.jsx)(e.p,{children:"onAIImplementStart()"}),"\n"]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Code"})}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-lua",children:"function Cylindered:onAIImplementStart()\n    local spec = self.spec_cylindered\n    for _, movingTool in ipairs(spec.movingTools) do\n        if movingTool.aiActivePosition ~ = nil then\n            movingTool.curTargetPosition = movingTool.aiActivePosition\n            movingTool.curTargetDirection = movingTool.curTargetPosition - Cylindered.getMovingToolState( self , movingTool)\n        end\n    end\nend\n\n"})}),"\n",(0,o.jsx)(e.h3,{id:"onanimationpartchanged",children:"onAnimationPartChanged"}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Description"})}),"\n",(0,o.jsxs)(e.blockquote,{children:["\n",(0,o.jsx)(e.p,{children:"Called when animation part has changed"}),"\n"]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Definition"})}),"\n",(0,o.jsxs)(e.blockquote,{children:["\n",(0,o.jsx)(e.p,{children:"onAnimationPartChanged()"}),"\n"]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,o.jsx)(e.table,{children:(0,o.jsx)(e.thead,{children:(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.th,{children:"any"}),(0,o.jsx)(e.th,{children:"node"})]})})}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Code"})}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-lua",children:"function Cylindered:onAnimationPartChanged(node)\n    self:setMovingToolDirty(node)\nend\n\n"})}),"\n",(0,o.jsx)(e.h3,{id:"ondeactivate",children:"onDeactivate"}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Description"})}),"\n",(0,o.jsxs)(e.blockquote,{children:["\n",(0,o.jsx)(e.p,{children:"Called on deactivate"}),"\n"]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Definition"})}),"\n",(0,o.jsxs)(e.blockquote,{children:["\n",(0,o.jsx)(e.p,{children:"onDeactivate()"}),"\n"]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Code"})}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-lua",children:"function Cylindered:onDeactivate()\n    if self.isClient then\n        local spec = self.spec_cylindered\n        g_soundManager:stopSample(spec.samples.hydraulic)\n        spec.isHydraulicSamplePlaying = false\n\n        -- reset the moving tool input values\n        for _, movingTool in ipairs(spec.movingTools) do\n            movingTool.move = 0\n            movingTool.externalMove = 0\n        end\n    end\nend\n\n"})}),"\n",(0,o.jsx)(e.h3,{id:"ondelete",children:"onDelete"}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Description"})}),"\n",(0,o.jsxs)(e.blockquote,{children:["\n",(0,o.jsx)(e.p,{children:"Called on deleting"}),"\n"]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Definition"})}),"\n",(0,o.jsxs)(e.blockquote,{children:["\n",(0,o.jsx)(e.p,{children:"onDelete()"}),"\n"]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Code"})}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-lua",children:"function Cylindered:onDelete()\n    local spec = self.spec_cylindered\n\n    g_soundManager:deleteSamples(spec.samples)\n    g_soundManager:deleteSamples(spec.actionSamples)\n\n    if spec.movingTools ~ = nil then\n        for _,movingTool in pairs(spec.movingTools) do\n            if movingTool.icon ~ = nil then\n                movingTool.icon:delete()\n                movingTool.icon = nil\n            end\n        end\n    end\nend\n\n"})}),"\n",(0,o.jsx)(e.h3,{id:"ondraw",children:"onDraw"}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Description"})}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Definition"})}),"\n",(0,o.jsxs)(e.blockquote,{children:["\n",(0,o.jsx)(e.p,{children:"onDraw()"}),"\n"]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,o.jsxs)(e.table,{children:[(0,o.jsx)(e.thead,{children:(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.th,{children:"any"}),(0,o.jsx)(e.th,{children:"isActiveForInput"})]})}),(0,o.jsxs)(e.tbody,{children:[(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.td,{children:"any"}),(0,o.jsx)(e.td,{children:"isActiveForInputIgnoreSelection"})]}),(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.td,{children:"any"}),(0,o.jsx)(e.td,{children:"isSelected"})]})]})]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Code"})}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-lua",children:'function Cylindered:onDraw(isActiveForInput, isActiveForInputIgnoreSelection, isSelected)\n    local spec = self.spec_cylindered\n    if #spec.controlGroupNames > 1 then\n        if isActiveForInputIgnoreSelection then\n            if spec.currentControlGroupIndex ~ = 0 then\n                g_currentMission:addExtraPrintText( string.format(g_i18n:getText( "action_selectedControlGroup" ), spec.controlGroupNames[spec.currentControlGroupIndex], spec.currentControlGroupIndex))\n            end\n        end\n    end\nend\n\n'})}),"\n",(0,o.jsx)(e.h3,{id:"onload",children:"onLoad"}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Description"})}),"\n",(0,o.jsxs)(e.blockquote,{children:["\n",(0,o.jsx)(e.p,{children:"Called on loading"}),"\n"]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Definition"})}),"\n",(0,o.jsxs)(e.blockquote,{children:["\n",(0,o.jsx)(e.p,{children:"onLoad(table savegame)"}),"\n"]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n",(0,o.jsx)(e.table,{children:(0,o.jsx)(e.thead,{children:(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.th,{children:"table"}),(0,o.jsx)(e.th,{children:"savegame"}),(0,o.jsx)(e.th,{children:"savegame"})]})})}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Code"})}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-lua",children:'function Cylindered:onLoad(savegame)\n    local spec = self.spec_cylindered\n\n    XMLUtil.checkDeprecatedXMLElements( self.xmlFile, "vehicle.movingParts" , "vehicle.cylindered.movingParts" ) --FS17 to FS19\n    XMLUtil.checkDeprecatedXMLElements( self.xmlFile, "vehicle.movingTools" , "vehicle.cylindered.movingTools" ) --FS17 to FS19\n    XMLUtil.checkDeprecatedXMLElements( self.xmlFile, "vehicle.cylinderedHydraulicSound" , "vehicle.cylindered.sounds.hydraulic" ) --FS17 to FS19\n\n    XMLUtil.checkDeprecatedXMLElements( self.xmlFile, "vehicle.cylindered.movingParts#isActiveDirtyTimeOffset" ) --FS19 to FS22\n\n    XMLUtil.checkDeprecatedXMLElements( self.xmlFile, "vehicle.cylindered.movingParts.sounds" , "vehicle.cylindered.sounds" ) --FS19 to FS22\n\n    local configurationId = self.configurations[ "cylindered" ] or 1\n    local configKey = string.format( "vehicle.cylindered.cylinderedConfigurations.cylinderedConfiguration(%d)" , configurationId - 1 )\n\n    spec.activeDirtyMovingParts = { }\n\n    spec.referenceNodes = { }\n    spec.nodesToMovingParts = { }\n    spec.movingParts = { }\n    self.anyMovingPartsDirty = false\n    spec.detachLockNodes = nil\n\n    self:loadMovingPartsFromXML( self.xmlFile, "vehicle.cylindered.movingParts.movingPart" )\n    self:loadMovingPartsFromXML( self.xmlFile, configKey .. ".movingParts.movingPart" )\n\n    if Cylindered.DIRTY_COLLISION_UPDATE_CHECK then\n        -- collect all active dirty moving parts which have directionThreshold not changed from xml\n        -- and check if any of these has collisions as children.If yes, print warning\n            local function collectDependentParts(part, target)\n                table.insert(target, part)\n\n                if part.dependentPartNodes ~ = nil then\n                    for l = 1 , #part.dependentPartNodes do\n                        local dependentMovingPart = spec.nodesToMovingParts[part.dependentPartNodes[l]]\n                        if dependentMovingPart ~ = nil then\n                            table.insert(target, dependentMovingPart)\n\n                            collectDependentParts(dependentMovingPart, target)\n                        end\n                    end\n                end\n            end\n\n            local function subCollisionErrorFunction(collisionNode, xmlFile, key)\n                if getHasClassId(collisionNode, ClassIds.SHAPE) then\n                    Logging.xmlError(xmlFile, "Found collision \'%s\' as child of isActiveDirty movingPart \'%s\'.This can cause the vehicle to never sleep!" , getName(collisionNode), key)\n                end\n            end\n\n            spec.realActiveDirtyParts = { }\n            for j = 1 , #spec.movingParts do\n                local movingPart = spec.movingParts[j]\n                if movingPart.isActiveDirty and movingPart.directionThreshold = = 0.0001 then\n                    collectDependentParts(movingPart, spec.realActiveDirtyParts)\n                end\n            end\n\n            for j = 1 , #spec.realActiveDirtyParts do\n                local part = spec.realActiveDirtyParts[j]\n                I3DUtil.checkForChildCollisions(part.node, subCollisionErrorFunction, self.xmlFile, getName(part.node))\n            end\n        end\n\n        spec.powerConsumingActiveTimeOffset = self.xmlFile:getValue( "vehicle.cylindered.movingTools#powerConsumingActiveTimeOffset" , 5 )\n        spec.powerConsumingTimer = - 1\n\n        -- find dependencies\n        for _, part in pairs(spec.movingParts) do\n            self:resolveDependentPartData(part.dependentPartData, spec.referenceNodes)\n        end\n\n        local function addMovingPart(part, newTable, allowDependentParts)\n            for _, addedPart in ipairs(newTable) do\n                if addedPart = = part then\n                    return\n                end\n            end\n\n            if part.isDependentPart = = true then\n                if allowDependentParts ~ = true then\n                    return\n                end\n            end\n\n            table.insert(newTable, part)\n\n            for _, depPart in pairs(part.dependentPartData) do\n                addMovingPart(depPart.part, newTable, true )\n            end\n        end\n\n        local newParts = { }\n        for _, part in ipairs(spec.movingParts) do\n            addMovingPart(part, newParts)\n        end\n        spec.movingParts = newParts\n\n        spec.controlGroups = { }\n        spec.controlGroupMapping = { }\n        spec.currentControlGroupIndex = 1\n        spec.controlGroupNames = { }\n\n        for _, toolKey in ipairs( Cylindered.MOVING_TOOLS_XML_KEYS) do\n            for _, groupKey in self.xmlFile:iterator(toolKey .. ".controlGroups.controlGroup" ) do\n                local name = self.xmlFile:getValue(groupKey .. "#name" , "" , self.customEnvironment, false )\n                if name ~ = nil then\n                    table.insert(spec.controlGroupNames, name)\n                end\n            end\n        end\n\n        spec.nodesToMovingTools = { }\n        spec.movingTools = { }\n\n        self:loadMovingToolsFromXML( self.xmlFile, "vehicle.cylindered.movingTools.movingTool" )\n        self:loadMovingToolsFromXML( self.xmlFile, configKey .. ".movingTools.movingTool" )\n\n        local function sort(a, b)\n            return a < b\n        end\n        table.sort(spec.controlGroups, sort )\n\n        for _, groupIndex in ipairs(spec.controlGroups) do\n            local subSelectionIndex = self:addSubselection(groupIndex)\n            spec.controlGroupMapping[subSelectionIndex] = groupIndex\n        end\n\n        for _, part in pairs(spec.movingTools) do\n            self:resolveDependentPartData(part.dependentPartData, spec.referenceNodes)\n\n            for j = #part.dependentMovingTools, 1 , - 1 do\n                local dependentTool = part.dependentMovingTools[j]\n                local tool = spec.nodesToMovingTools[dependentTool.node]\n                if tool ~ = nil then\n                    dependentTool.movingTool = tool\n                else\n                        Logging.xmlWarning( self.xmlFile, "Dependent moving tool \'%s\' not defined.Ignoring it!" , getName(dependentTool.node))\n                        table.remove(part.dependentMovingTools, j)\n                    end\n                end\n            end\n\n            for _, part in pairs(spec.movingParts) do\n                for j = #part.dependentMovingTools, 1 , - 1 do\n                    local dependentTool = part.dependentMovingTools[j]\n                    local tool = spec.nodesToMovingTools[dependentTool.node]\n                    if tool ~ = nil then\n                        dependentTool.movingTool = tool\n                    else\n                            Logging.xmlWarning( self.xmlFile, "Dependent moving tool \'%s\' not defined.Ignoring it!" , getName(dependentTool.node))\n                            table.remove(part.dependentMovingTools, j)\n                        end\n                    end\n                end\n\n                spec.referenceNodes = nil\n\n                local easyArmControlKey = configKey .. ".movingTools.easyArmControl"\n                if not self.xmlFile:hasProperty(easyArmControlKey) then\n                    easyArmControlKey = "vehicle.cylindered.movingTools.easyArmControl"\n                end\n\n                if self.xmlFile:hasProperty(easyArmControlKey) then\n                    local easyArmControl = { }\n                    if self:loadEasyArmControlFromXML( self.xmlFile, easyArmControlKey, easyArmControl) then\n                        spec.easyArmControl = easyArmControl\n                    end\n                end\n\n                if self.xmlFile:hasProperty(configKey) then\n                    local movingTool = DashboardValueType.new( "cylindered" , "movingTool" )\n                    movingTool:setXMLKey(configKey .. ".dashboards" )\n                    movingTool:setValue( self , Cylindered.getMovingToolDashboardState)\n                    movingTool:setRange( 0 , 1 )\n                    movingTool:setAdditionalFunctions( Cylindered.movingToolDashboardAttributes, nil )\n                    movingTool:setIdleValue( 0.5 )\n                    self:registerDashboardValueType(movingTool)\n                end\n\n                spec.samples = { }\n                spec.actionSamples = { }\n                if self.isClient then\n                    spec.samples.hydraulic = g_soundManager:loadSampleFromXML( self.xmlFile, configKey .. ".sounds" , "hydraulic" , self.baseDirectory, self.components, 0 , AudioGroup.VEHICLE, self.i3dMappings, self )\n                    if spec.samples.hydraulic = = nil then\n                        spec.samples.hydraulic = g_soundManager:loadSampleFromXML( self.xmlFile, "vehicle.cylindered.sounds" , "hydraulic" , self.baseDirectory, self.components, 0 , AudioGroup.VEHICLE, self.i3dMappings, self )\n                    end\n                    spec.isHydraulicSamplePlaying = false\n\n                    spec.nodesToSamples = { }\n                    spec.activeSamples = { }\n                    spec.endingSamples = { }\n                    spec.endingSamplesBySample = { }\n                    spec.startingSamples = { }\n                    spec.startingSamplesBySample = { }\n\n                    self:loadActionSoundsFromXML( self.xmlFile, "vehicle.cylindered.sounds" )\n                    self:loadActionSoundsFromXML( self.xmlFile, configKey .. ".sounds" )\n                end\n\n                spec.cylinderedDirtyFlag = self:getNextDirtyFlag()\n                spec.cylinderedInputDirtyFlag = self:getNextDirtyFlag()\n\n                self:registerVehicleSetting(GameSettings.SETTING.EASY_ARM_CONTROL, true )\n\n                spec.isLoading = true\n            end\n\n'})}),"\n",(0,o.jsx)(e.h3,{id:"onloadfinished",children:"onLoadFinished"}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Description"})}),"\n",(0,o.jsxs)(e.blockquote,{children:["\n",(0,o.jsx)(e.p,{children:"Called after loading"}),"\n"]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Definition"})}),"\n",(0,o.jsxs)(e.blockquote,{children:["\n",(0,o.jsx)(e.p,{children:"onLoadFinished(table savegame)"}),"\n"]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n",(0,o.jsx)(e.table,{children:(0,o.jsx)(e.thead,{children:(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.th,{children:"table"}),(0,o.jsx)(e.th,{children:"savegame"}),(0,o.jsx)(e.th,{children:"savegame"})]})})}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Code"})}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-lua",children:"function Cylindered:onLoadFinished(savegame)\n    local spec = self.spec_cylindered\n    spec.isLoading = false\n\n    for i = 1 , #spec.movingTools do\n        local tool = spec.movingTools[i]\n        if tool.delayedHistoryIndex ~ = nil and tool.delayedHistoryIndex > 0 then\n            self:updateDelayedTool(tool, true )\n        end\n    end\nend\n\n"})}),"\n",(0,o.jsx)(e.h3,{id:"onmovingpartsoundevent",children:"onMovingPartSoundEvent"}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Description"})}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Definition"})}),"\n",(0,o.jsxs)(e.blockquote,{children:["\n",(0,o.jsx)(e.p,{children:"onMovingPartSoundEvent()"}),"\n"]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,o.jsxs)(e.table,{children:[(0,o.jsx)(e.thead,{children:(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.th,{children:"any"}),(0,o.jsx)(e.th,{children:"part"})]})}),(0,o.jsxs)(e.tbody,{children:[(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.td,{children:"any"}),(0,o.jsx)(e.td,{children:"action"})]}),(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.td,{children:"any"}),(0,o.jsx)(e.td,{children:"type"})]})]})]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Code"})}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-lua",children:"function Cylindered:onMovingPartSoundEvent(part, action, type )\n    if part.samplesByAction ~ = nil then\n        local samples = part.samplesByAction[action]\n        if samples ~ = nil then\n            for i = 1 , #samples do\n                local sample = samples[i]\n\n                if type = = Cylindered.SOUND_TYPE_EVENT then\n                    if sample.loops = = 0 then\n                        sample.loops = 1\n                    end\n\n                    g_soundManager:playSample(sample)\n                elseif type = = Cylindered.SOUND_TYPE_CONTINUES then\n                        if not g_soundManager:getIsSamplePlaying(sample) then\n                            g_soundManager:playSample(sample)\n\n                            sample.lastActivationTime = g_ time\n                            sample.lastActivationPart = part\n\n                            local spec = self.spec_cylindered\n                            table.insert(spec.activeSamples, sample)\n                        else\n                                if sample.lastActivationPart = = part then\n                                    sample.lastActivationTime = g_ time\n                                end\n                            end\n                        elseif type = = Cylindered.SOUND_TYPE_ENDING then\n                                local spec = self.spec_cylindered\n                                if spec.endingSamplesBySample[sample] = = nil then\n                                    sample.lastActivationTime = g_ time\n\n                                    table.insert(spec.endingSamples, sample)\n                                    spec.endingSamplesBySample[sample] = sample\n                                else\n                                        sample.lastActivationTime = g_ time\n                                    end\n                                elseif type = = Cylindered.SOUND_TYPE_STARTING then\n                                        local spec = self.spec_cylindered\n                                        if spec.startingSamplesBySample[sample] = = nil then\n                                            if sample.loops = = 0 then\n                                                sample.loops = 1\n                                            end\n\n                                            g_soundManager:playSample(sample)\n\n                                            sample.lastActivationTime = g_ time\n\n                                            table.insert(spec.startingSamples, sample)\n                                            spec.startingSamplesBySample[sample] = sample\n                                        else\n                                                sample.lastActivationTime = g_ time\n                                            end\n                                        end\n                                    end\n                                end\n                            end\n                        end\n\n"})}),"\n",(0,o.jsx)(e.h3,{id:"onpostattach",children:"onPostAttach"}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Description"})}),"\n",(0,o.jsxs)(e.blockquote,{children:["\n",(0,o.jsx)(e.p,{children:"Called if vehicle gets attached"}),"\n"]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Definition"})}),"\n",(0,o.jsxs)(e.blockquote,{children:["\n",(0,o.jsx)(e.p,{children:"onPostAttach(table attacherVehicle, integer inputJointDescIndex, integer jointDescIndex)"}),"\n"]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,o.jsxs)(e.table,{children:[(0,o.jsx)(e.thead,{children:(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.th,{children:"table"}),(0,o.jsx)(e.th,{children:"attacherVehicle"}),(0,o.jsx)(e.th,{children:"attacher vehicle"})]})}),(0,o.jsxs)(e.tbody,{children:[(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.td,{children:"integer"}),(0,o.jsx)(e.td,{children:"inputJointDescIndex"}),(0,o.jsx)(e.td,{children:"index of input attacher joint"})]}),(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.td,{children:"integer"}),(0,o.jsx)(e.td,{children:"jointDescIndex"}),(0,o.jsx)(e.td,{children:"index of attacher joint it gets attached to"})]})]})]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Code"})}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-lua",children:"function Cylindered:onPostAttach(attacherVehicle, inputJointDescIndex, jointDescIndex)\n    local spec = self.spec_cylindered\n\n    for _, tool in ipairs(spec.movingTools) do\n        local changed = false\n        if tool.transSpeed ~ = nil then\n            local trans = tool.curTrans[tool.translationAxis]\n\n            local changedTrans = false\n            if tool.attachTransMax ~ = nil and trans > tool.attachTransMax then\n                trans = tool.attachTransMax\n                changedTrans = true\n            elseif tool.attachTransMin ~ = nil and trans < tool.attachTransMin then\n                    trans = tool.attachTransMin\n                    changedTrans = true\n                end\n                if changedTrans then\n                    tool.curTrans[tool.translationAxis] = trans\n                    setTranslation(tool.node, unpack(tool.curTrans))\n                    changed = true\n                end\n            end\n            if tool.rotSpeed ~ = nil then\n                local rot = tool.curRot[tool.rotationAxis]\n\n                local changedRot = false\n                if tool.attachRotMax ~ = nil and rot > tool.attachRotMax then\n                    rot = tool.attachRotMax\n                    changedRot = true\n                elseif tool.attachRotMin ~ = nil and rot < tool.attachRotMin then\n                        rot = tool.attachRotMin\n                        changedRot = true\n                    end\n                    if changedRot then\n                        tool.curRot[tool.rotationAxis] = rot\n                        setRotation(tool.node, unpack(tool.curRot))\n                        changed = true\n                    end\n                end\n                if changed then\n                    Cylindered.setDirty( self , tool)\n                end\n            end\n        end\n\n"})}),"\n",(0,o.jsx)(e.h3,{id:"onpostload",children:"onPostLoad"}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Description"})}),"\n",(0,o.jsxs)(e.blockquote,{children:["\n",(0,o.jsx)(e.p,{children:"Called after loading"}),"\n"]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Definition"})}),"\n",(0,o.jsxs)(e.blockquote,{children:["\n",(0,o.jsx)(e.p,{children:"onPostLoad(table savegame)"}),"\n"]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n",(0,o.jsx)(e.table,{children:(0,o.jsx)(e.thead,{children:(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.th,{children:"table"}),(0,o.jsx)(e.th,{children:"savegame"}),(0,o.jsx)(e.th,{children:"savegame"})]})})}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Code"})}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-lua",children:'function Cylindered:onPostLoad(savegame)\n    local spec = self.spec_cylindered\n\n    for _, tool in pairs(spec.movingTools) do\n        if self:getIsMovingToolActive(tool) then\n            if tool.startRot ~ = nil then\n                tool.curRot[tool.rotationAxis] = tool.startRot\n                setRotation(tool.node, unpack(tool.curRot))\n\n                SpecializationUtil.raiseEvent( self , "onMovingToolChanged" , tool, 0 , 0 )\n            end\n            if tool.startTrans ~ = nil then\n                tool.curTrans[tool.translationAxis] = tool.startTrans\n                setTranslation(tool.node, unpack(tool.curTrans))\n\n                SpecializationUtil.raiseEvent( self , "onMovingToolChanged" , tool, 0 , 0 )\n            end\n\n            if tool.animStartTime ~ = nil then\n                self:setAnimationTime(tool.animName, tool.animStartTime, nil , false )\n\n                SpecializationUtil.raiseEvent( self , "onMovingToolChanged" , tool, 0 , 0 )\n            end\n\n            if tool.delayedNode ~ = nil then\n                self:setDelayedData(tool, true )\n            end\n\n            if tool.isIntitialDirty then\n                Cylindered.setDirty( self , tool)\n            end\n        end\n    end\n\n    for _, part in pairs(spec.movingParts) do\n        self:loadDependentAttacherJoints( self.xmlFile, part.key, part)\n        self:loadDependentWheels( self.xmlFile, part.key, part)\n    end\n\n    for _, tool in pairs(spec.movingTools) do\n        self:loadDependentAttacherJoints( self.xmlFile, tool.key, tool)\n        self:loadDependentWheels( self.xmlFile, tool.key, tool)\n    end\n\n    if self:allowLoadMovingToolStates() then\n        if savegame ~ = nil and not savegame.resetVehicles then\n            local i = 0\n            for _, tool in ipairs(spec.movingTools) do\n                if tool.saving then\n                    if self:getIsMovingToolActive(tool) then\n                        local toolKey = string.format( "%s.cylindered.movingTool(%d)" , savegame.key, i)\n                        local changed = false\n                        if tool.transSpeed ~ = nil then\n                            local newTrans = savegame.xmlFile:getValue(toolKey .. "#translation" )\n                            if newTrans ~ = nil then\n                                if tool.transMax ~ = nil then\n                                    newTrans = math.min(newTrans, tool.transMax)\n                                end\n                                if tool.transMin ~ = nil then\n                                    newTrans = math.max(newTrans, tool.transMin)\n                                end\n                            end\n                            if newTrans ~ = nil and math.abs(newTrans - tool.curTrans[tool.translationAxis]) > 0.0001 then\n                                tool.curTrans = { getTranslation(tool.node) }\n                                tool.curTrans[tool.translationAxis] = newTrans\n                                setTranslation(tool.node, unpack(tool.curTrans))\n                                changed = true\n                            end\n                        end\n                        if tool.rotSpeed ~ = nil then\n                            local newRot = savegame.xmlFile:getValue(toolKey .. "#rotation" )\n                            if newRot ~ = nil then\n                                if tool.rotMax ~ = nil then\n                                    newRot = math.min(newRot, tool.rotMax)\n                                end\n                                if tool.rotMin ~ = nil then\n                                    newRot = math.max(newRot, tool.rotMin)\n                                end\n                            end\n                            if newRot ~ = nil and math.abs(newRot - tool.curRot[tool.rotationAxis]) > 0.0001 then\n                                tool.curRot = { getRotation(tool.node) }\n                                tool.curRot[tool.rotationAxis] = newRot\n                                setRotation(tool.node, unpack(tool.curRot))\n                                changed = true\n                            end\n                        end\n                        if tool.animSpeed ~ = nil then\n                            local animTime = savegame.xmlFile:getValue(toolKey .. "#animationTime" )\n                            if animTime ~ = nil then\n                                if tool.animMinTime ~ = nil then\n                                    animTime = math.max(animTime, tool.animMinTime)\n                                end\n                                if tool.animMaxTime ~ = nil then\n                                    animTime = math.min(animTime, tool.animMaxTime)\n                                end\n\n                                tool.curAnimTime = animTime\n                                self:setAnimationTime(tool.animName, animTime, true , false )\n                            end\n                        end\n                        if changed then\n                            Cylindered.setDirty( self , tool)\n\n                            SpecializationUtil.raiseEvent( self , "onMovingToolChanged" , tool, 0 , 0 )\n                        end\n\n                        if tool.delayedNode ~ = nil then\n                            self:setDelayedData(tool, true )\n                        end\n                    end\n                    i = i + 1\n                end\n\n                for _, dependentTool in pairs(tool.dependentMovingTools) do\n                    Cylindered.updateRotationBasedLimits( self , tool, dependentTool)\n                end\n            end\n        end\n    end\n\n    self:updateEasyControl( 9999 , true )\n    self:updateCylinderedInitial( false )\n\n    local hasTools, hasParts = #spec.movingTools > 0 , #spec.movingParts > 0\n    if not hasTools then\n        SpecializationUtil.removeEventListener( self , "onReadStream" , Cylindered )\n        SpecializationUtil.removeEventListener( self , "onWriteStream" , Cylindered )\n        SpecializationUtil.removeEventListener( self , "onReadUpdateStream" , Cylindered )\n        SpecializationUtil.removeEventListener( self , "onWriteUpdateStream" , Cylindered )\n        SpecializationUtil.removeEventListener( self , "onUpdate" , Cylindered )\n\n        if not hasParts then\n            SpecializationUtil.removeEventListener( self , "onUpdateTick" , Cylindered )\n            SpecializationUtil.removeEventListener( self , "onPostUpdate" , Cylindered )\n            SpecializationUtil.removeEventListener( self , "onPostUpdateTick" , Cylindered )\n        end\n    end\n\n    if not self.isClient or not hasTools then\n        SpecializationUtil.removeEventListener( self , "onDraw" , Cylindered )\n        SpecializationUtil.removeEventListener( self , "onRegisterActionEvents" , Cylindered )\n    end\n\n    -- check if functional nodes are included in moving parts with limited update distance\n        if g_isDevelopmentVersion then\n            local function checkPart(part)\n                I3DUtil.iterateRecursively(part.node, function (child, depth)\n                    self:checkMovingPartDirtyUpdateNode(child, part)\n                end )\n\n                if part.dependentPartData ~ = nil then\n                    for _, data in pairs(part.dependentPartData) do\n                        if data.part ~ = nil then\n                            checkPart(data.part)\n                        end\n                    end\n                end\n            end\n\n            for j = 1 , #spec.movingParts do\n                local movingPart = spec.movingParts[j]\n                if movingPart.isActiveDirty then\n                    if movingPart.maxUpdateDistance ~ = math.huge then\n                        checkPart(movingPart)\n                    end\n                end\n            end\n        end\n    end\n\n'})}),"\n",(0,o.jsx)(e.h3,{id:"onpostupdate",children:"onPostUpdate"}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Description"})}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Definition"})}),"\n",(0,o.jsxs)(e.blockquote,{children:["\n",(0,o.jsx)(e.p,{children:"onPostUpdate()"}),"\n"]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,o.jsxs)(e.table,{children:[(0,o.jsx)(e.thead,{children:(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.th,{children:"any"}),(0,o.jsx)(e.th,{children:"dt"})]})}),(0,o.jsxs)(e.tbody,{children:[(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.td,{children:"any"}),(0,o.jsx)(e.td,{children:"isActiveForInput"})]}),(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.td,{children:"any"}),(0,o.jsx)(e.td,{children:"isActiveForInputIgnoreSelection"})]}),(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.td,{children:"any"}),(0,o.jsx)(e.td,{children:"isSelected"})]})]})]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Code"})}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-lua",children:"function Cylindered:onPostUpdate(dt, isActiveForInput, isActiveForInputIgnoreSelection, isSelected)\n    local spec = self.spec_cylindered\n    for _, part in pairs(spec.activeDirtyMovingParts) do\n        if self.currentUpdateDistance < part.maxUpdateDistance then\n            Cylindered.setDirty( self , part)\n        end\n    end\n\n    self:updateDirtyMovingParts(dt, true )\nend\n\n"})}),"\n",(0,o.jsx)(e.h3,{id:"onpostupdatetick",children:"onPostUpdateTick"}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Description"})}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Definition"})}),"\n",(0,o.jsxs)(e.blockquote,{children:["\n",(0,o.jsx)(e.p,{children:"onPostUpdateTick()"}),"\n"]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,o.jsxs)(e.table,{children:[(0,o.jsx)(e.thead,{children:(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.th,{children:"any"}),(0,o.jsx)(e.th,{children:"dt"})]})}),(0,o.jsxs)(e.tbody,{children:[(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.td,{children:"any"}),(0,o.jsx)(e.td,{children:"isActiveForInput"})]}),(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.td,{children:"any"}),(0,o.jsx)(e.td,{children:"isActiveForInputIgnoreSelection"})]}),(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.td,{children:"any"}),(0,o.jsx)(e.td,{children:"isSelected"})]})]})]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Code"})}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-lua",children:"function Cylindered:onPostUpdateTick(dt, isActiveForInput, isActiveForInputIgnoreSelection, isSelected)\n    -- update the moving parts that have been set dirty in the updateTick, so they won't be one frame delayed\n    self:updateDirtyMovingParts(dt, false )\nend\n\n"})}),"\n",(0,o.jsx)(e.h3,{id:"onreadstream",children:"onReadStream"}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Description"})}),"\n",(0,o.jsxs)(e.blockquote,{children:["\n",(0,o.jsx)(e.p,{children:"Called on client side on join"}),"\n"]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Definition"})}),"\n",(0,o.jsxs)(e.blockquote,{children:["\n",(0,o.jsx)(e.p,{children:"onReadStream(integer streamId, Connection connection)"}),"\n"]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,o.jsxs)(e.table,{children:[(0,o.jsx)(e.thead,{children:(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.th,{children:"integer"}),(0,o.jsx)(e.th,{children:"streamId"}),(0,o.jsx)(e.th,{children:"streamId"})]})}),(0,o.jsx)(e.tbody,{children:(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.td,{children:"Connection"}),(0,o.jsx)(e.td,{children:"connection"}),(0,o.jsx)(e.td,{children:"connection"})]})})]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Code"})}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-lua",children:'function Cylindered:onReadStream(streamId, connection)\n    local spec = self.spec_cylindered\n\n    if connection:getIsServer() then\n        if streamReadBool(streamId) then\n            for i = 1 , #spec.movingTools do\n                local tool = spec.movingTools[i]\n                if tool.dirtyFlag ~ = nil then\n                    tool.networkTimeInterpolator:reset()\n                    if tool.transSpeed ~ = nil then\n                        local newTrans = streamReadFloat32(streamId)\n                        tool.curTrans[tool.translationAxis] = newTrans\n                        setTranslation(tool.node, unpack(tool.curTrans))\n                        tool.networkInterpolators.translation:setValue(tool.curTrans[tool.translationAxis])\n                    end\n                    if tool.rotSpeed ~ = nil then\n                        local newRot = streamReadFloat32(streamId)\n                        tool.curRot[tool.rotationAxis] = newRot\n                        setRotation(tool.node, unpack(tool.curRot))\n                        tool.networkInterpolators.rotation:setAngle(newRot)\n                    end\n                    if tool.animSpeed ~ = nil then\n                        local newAnimTime = streamReadFloat32(streamId)\n                        tool.curAnimTime = newAnimTime\n                        self:setAnimationTime(tool.animName, tool.curAnimTime, nil , false )\n                        tool.networkInterpolators.animation:setValue(newAnimTime)\n                    end\n                    if tool.delayedNode ~ = nil then\n                        self:setDelayedData(tool, true )\n                    end\n                    Cylindered.setDirty( self , tool)\n\n                    SpecializationUtil.raiseEvent( self , "onMovingToolChanged" , tool, 0 , 0 )\n                end\n            end\n        end\n    end\nend\n\n'})}),"\n",(0,o.jsx)(e.h3,{id:"onreadupdatestream",children:"onReadUpdateStream"}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Description"})}),"\n",(0,o.jsxs)(e.blockquote,{children:["\n",(0,o.jsx)(e.p,{children:"Called on on update"}),"\n"]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Definition"})}),"\n",(0,o.jsxs)(e.blockquote,{children:["\n",(0,o.jsx)(e.p,{children:"onReadUpdateStream(integer streamId, integer timestamp, table connection)"}),"\n"]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,o.jsxs)(e.table,{children:[(0,o.jsx)(e.thead,{children:(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.th,{children:"integer"}),(0,o.jsx)(e.th,{children:"streamId"}),(0,o.jsx)(e.th,{children:"stream ID"})]})}),(0,o.jsxs)(e.tbody,{children:[(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.td,{children:"integer"}),(0,o.jsx)(e.td,{children:"timestamp"}),(0,o.jsx)(e.td,{children:"timestamp"})]}),(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.td,{children:"table"}),(0,o.jsx)(e.td,{children:"connection"}),(0,o.jsx)(e.td,{children:"connection"})]})]})]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Code"})}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-lua",children:"function Cylindered:onReadUpdateStream(streamId, timestamp, connection)\n    local spec = self.spec_cylindered\n\n    -- if server, read input from client\n        if not connection:getIsServer() then\n            if streamReadBool(streamId) then\n                for _, tool in ipairs(spec.movingTools) do\n                    if tool.axisActionIndex ~ = nil then\n                        tool.move = (streamReadUIntN(streamId, 12 ) / 4095 * 2 - 1 ) * 5\n                        if math.abs(tool.move) < 0.01 then\n                            tool.move = 0\n                        end\n                    end\n                end\n            end\n        else\n                -- if client, read updated attributes\n                    if streamReadBool(streamId) then\n                        for _, tool in ipairs(spec.movingTools) do\n                            if tool.dirtyFlag ~ = nil then\n                                if streamReadBool(streamId) then\n                                    tool.networkTimeInterpolator:startNewPhaseNetwork()\n\n                                    if tool.transSpeed ~ = nil then\n                                        local newTrans = streamReadFloat32(streamId)\n                                        if math.abs(newTrans - tool.curTrans[tool.translationAxis]) > 0.0001 then\n                                            tool.networkInterpolators.translation:setTargetValue(newTrans)\n                                        end\n                                    end\n                                    if tool.rotSpeed ~ = nil then\n                                        local newRot\n                                        if tool.rotMin = = nil or tool.rotMax = = nil then\n                                            newRot = NetworkUtil.readCompressedAngle(streamId)\n                                        else\n                                                if tool.syncMinRotLimits then\n                                                    tool.rotMin = streamReadFloat32(streamId)\n                                                end\n                                                if tool.syncMaxRotLimits then\n                                                    tool.rotMax = streamReadFloat32(streamId)\n                                                end\n\n                                                tool.networkInterpolators.rotation:setMinMax(tool.rotMin, tool.rotMax)\n                                                newRot = NetworkUtil.readCompressedRange(streamId, tool.rotMin, tool.rotMax, tool.rotSendNumBits)\n                                            end\n                                            if math.abs(newRot - tool.curRot[tool.rotationAxis]) > 0.0001 then\n                                                tool.networkInterpolators.rotation:setTargetAngle(newRot)\n                                            end\n                                        end\n                                        if tool.animSpeed ~ = nil then\n                                            local resetAnimInterpolation = streamReadBool(streamId)\n\n                                            local newAnimTime = NetworkUtil.readCompressedRange(streamId, tool.animMinTime, tool.animMaxTime, tool.animSendNumBits)\n                                            if math.abs(newAnimTime - tool.curAnimTime) > 0.0001 then\n                                                tool.networkInterpolators.animation:setTargetValue(newAnimTime)\n\n                                                -- animation has been changed from outside of cylindered, so we reset the interpolation\n                                                if resetAnimInterpolation then\n                                                    tool.networkInterpolators.animation:setValue(newAnimTime)\n                                                end\n                                            end\n                                        end\n                                    end\n                                end\n                            end\n                        end\n                    end\n                end\n\n"})}),"\n",(0,o.jsx)(e.h3,{id:"onregisteractionevents",children:"onRegisterActionEvents"}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Description"})}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Definition"})}),"\n",(0,o.jsxs)(e.blockquote,{children:["\n",(0,o.jsx)(e.p,{children:"onRegisterActionEvents()"}),"\n"]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,o.jsxs)(e.table,{children:[(0,o.jsx)(e.thead,{children:(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.th,{children:"any"}),(0,o.jsx)(e.th,{children:"isActiveForInput"})]})}),(0,o.jsx)(e.tbody,{children:(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.td,{children:"any"}),(0,o.jsx)(e.td,{children:"isActiveForInputIgnoreSelection"})]})})]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Code"})}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-lua",children:"function Cylindered:onRegisterActionEvents(isActiveForInput, isActiveForInputIgnoreSelection)\n    if self.isClient then\n        local spec = self.spec_cylindered\n        self:clearActionEventsTable(spec.actionEvents)\n\n        -- no check for selection since movingTools can be controlled globally\n            -- sub selection moving tools always require the selection of the sub index\n            if isActiveForInputIgnoreSelection then\n                for i = 1 , #spec.movingTools do\n                    local movingTool = spec.movingTools[i]\n                    local isSelectedGroup = movingTool.controlGroupIndex = = 0 or movingTool.controlGroupIndex = = spec.currentControlGroupIndex\n                    local easyArmControlActive = g_gameSettings:getValue(GameSettings.SETTING.EASY_ARM_CONTROL)\n                    local canBeControlled = (easyArmControlActive and movingTool.easyArmControlActive) or( not easyArmControlActive and not movingTool.isEasyControlTarget)\n                    if movingTool.axisActionIndex ~ = nil and isSelectedGroup and canBeControlled then\n                        local _, actionEventId = self:addPoweredActionEvent(spec.actionEvents, movingTool.axisActionIndex, self , Cylindered.actionEventInput, true , false , true , true , i, movingTool.axisActionIcon)\n                        g_inputBinding:setActionEventTextPriority(actionEventId, GS_PRIO_NORMAL)\n                    end\n                end\n            end\n        end\n    end\n\n"})}),"\n",(0,o.jsx)(e.h3,{id:"onregisteranimationvaluetypes",children:"onRegisterAnimationValueTypes"}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Description"})}),"\n",(0,o.jsxs)(e.blockquote,{children:["\n",(0,o.jsx)(e.p,{children:"Called on pre load to register animation value types"}),"\n"]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Definition"})}),"\n",(0,o.jsxs)(e.blockquote,{children:["\n",(0,o.jsx)(e.p,{children:"onRegisterAnimationValueTypes()"}),"\n"]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Code"})}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-lua",children:'function Cylindered:onRegisterAnimationValueTypes()\n    self:registerAnimationValueType( "movingPartReferencePoint" , "" , "" , false , AnimationValueFloat ,\n    function (value, xmlFile, xmlKey)\n        value.node = xmlFile:getValue(xmlKey .. "#node" , nil , value.part.components, value.part.i3dMappings)\n\n        value.startReferencePoint = xmlFile:getValue(xmlKey .. "#startReferencePoint" , nil , value.part.components, value.part.i3dMappings)\n        value.endReferencePoint = xmlFile:getValue(xmlKey .. "#endReferencePoint" , nil , value.part.components, value.part.i3dMappings)\n\n        if value.node ~ = nil and value.startReferencePoint ~ = nil and value.endReferencePoint ~ = nil then\n            value:setWarningInformation( "node: " .. getName(value.node))\n            value:addCompareParameters( "node" )\n\n            value.animatedReferencePoint = createTransformGroup( "animatedReferencePoint_" .. getName(value.node))\n            link(getParent(value.node), value.animatedReferencePoint)\n            setWorldTranslation(value.animatedReferencePoint, getWorldTranslation(value.startReferencePoint))\n\n            value.startValue = { 0 }\n            value.endValue = { 1 }\n\n            return true\n        end\n\n        return false\n    end ,\n\n    function (value)\n        local startTime = value.startValue or value.endValue\n        if value.animation.currentSpeed < 0 then\n            startTime = value.endValue or value.startValue\n        end\n\n        return startTime[ 1 ]\n    end ,\n\n    function (value, alpha)\n        if value.movingPart = = nil then\n            value.movingPart = self:getMovingPartByNode(value.node)\n        end\n\n        local x1, y1, z1 = localToLocal(value.startReferencePoint, getParent(value.node), 0 , 0 , 0 )\n        local x2, y2, z2 = localToLocal(value.endReferencePoint, getParent(value.node), 0 , 0 , 0 )\n        local x, y, z = MathUtil.vector3Lerp(x1, y1, z1, x2, y2, z2, alpha)\n        setTranslation(value.animatedReferencePoint, x, y, z)\n\n        if value.movingPart ~ = nil then\n            if alpha = = 1 then\n                self:setMovingPartReferenceNode(value.movingPart, value.endReferencePoint)\n            elseif alpha = = 0 then\n                    self:setMovingPartReferenceNode(value.movingPart, value.startReferencePoint)\n                else\n                        self:setMovingPartReferenceNode(value.movingPart, value.animatedReferencePoint)\n                    end\n                end\n            end )\n        end\n\n'})}),"\n",(0,o.jsx)(e.h3,{id:"onregisterdashboardvaluetypes",children:"onRegisterDashboardValueTypes"}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Description"})}),"\n",(0,o.jsxs)(e.blockquote,{children:["\n",(0,o.jsx)(e.p,{children:"Called on post load to register dashboard value types"}),"\n"]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Definition"})}),"\n",(0,o.jsxs)(e.blockquote,{children:["\n",(0,o.jsx)(e.p,{children:"onRegisterDashboardValueTypes()"}),"\n"]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Code"})}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-lua",children:'function Cylindered:onRegisterDashboardValueTypes()\n    local movingTool = DashboardValueType.new( "cylindered" , "movingTool" )\n    movingTool:setValue( self , Cylindered.getMovingToolDashboardState)\n    movingTool:setRange( 0 , 1 )\n    movingTool:setAdditionalFunctions( Cylindered.movingToolDashboardAttributes, nil )\n    movingTool:setIdleValue( 0.5 )\n    self:registerDashboardValueType(movingTool)\nend\n\n'})}),"\n",(0,o.jsx)(e.h3,{id:"onselect",children:"onSelect"}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Description"})}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Definition"})}),"\n",(0,o.jsxs)(e.blockquote,{children:["\n",(0,o.jsx)(e.p,{children:"onSelect()"}),"\n"]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,o.jsx)(e.table,{children:(0,o.jsx)(e.thead,{children:(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.th,{children:"any"}),(0,o.jsx)(e.th,{children:"subSelectionIndex"})]})})}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Code"})}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-lua",children:"function Cylindered:onSelect(subSelectionIndex)\n    local spec = self.spec_cylindered\n    local controlGroupIndex = spec.controlGroupMapping[subSelectionIndex]\n    if controlGroupIndex ~ = nil then\n        spec.currentControlGroupIndex = controlGroupIndex\n    else\n            spec.currentControlGroupIndex = 0\n        end\n    end\n\n"})}),"\n",(0,o.jsx)(e.h3,{id:"onunselect",children:"onUnselect"}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Description"})}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Definition"})}),"\n",(0,o.jsxs)(e.blockquote,{children:["\n",(0,o.jsx)(e.p,{children:"onUnselect()"}),"\n"]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Code"})}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-lua",children:"function Cylindered:onUnselect()\n    local spec = self.spec_cylindered\n    spec.currentControlGroupIndex = 0\nend\n\n"})}),"\n",(0,o.jsx)(e.h3,{id:"onupdate",children:"onUpdate"}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Description"})}),"\n",(0,o.jsxs)(e.blockquote,{children:["\n",(0,o.jsx)(e.p,{children:"Called on update"}),"\n"]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Definition"})}),"\n",(0,o.jsxs)(e.blockquote,{children:["\n",(0,o.jsx)(e.p,{children:"onUpdate(float dt, boolean isActive, boolean isActiveForInput, boolean isSelected)"}),"\n"]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,o.jsxs)(e.table,{children:[(0,o.jsx)(e.thead,{children:(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.th,{children:"float"}),(0,o.jsx)(e.th,{children:"dt"}),(0,o.jsx)(e.th,{children:"time since last call in ms"})]})}),(0,o.jsxs)(e.tbody,{children:[(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.td,{children:"boolean"}),(0,o.jsx)(e.td,{children:"isActive"}),(0,o.jsx)(e.td,{children:"true if vehicle is active"})]}),(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.td,{children:"boolean"}),(0,o.jsx)(e.td,{children:"isActiveForInput"}),(0,o.jsx)(e.td,{children:"true if vehicle is active for input"})]}),(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.td,{children:"boolean"}),(0,o.jsx)(e.td,{children:"isSelected"}),(0,o.jsx)(e.td,{children:"true if vehicle is selected"})]})]})]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Code"})}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-lua",children:'function Cylindered:onUpdate(dt, isActiveForInput, isActiveForInputIgnoreSelection, isSelected)\n    local spec = self.spec_cylindered\n\n    spec.movingToolNeedsSound = false\n    spec.movingPartNeedsSound = false\n\n    self:updateEasyControl(dt)\n\n    if self.isServer then\n        for i = 1 , #spec.movingTools do\n            local tool = spec.movingTools[i]\n\n            local rotSpeed = 0\n            local transSpeed = 0\n            local animSpeed = 0\n\n            local move = self:getMovingToolMoveValue(tool)\n            tool.externalMove = 0 -- reset external move in any case, also if the movement is blocked, otherwise it will be summed up\n\n                if tool.curTargetPosition ~ = nil then\n                    local delta = math.abs( Cylindered.getMovingToolState( self , tool) - tool.curTargetPosition)\n                    if delta < 0.001 then\n                        tool.curTargetPosition = nil\n                        tool.curTargetDirection = nil\n                    else\n                            move = tool.curTargetDirection\n                        end\n                    end\n\n                    if math.abs(move) > 0 then\n                        if tool.rotSpeed ~ = nil then\n                            rotSpeed = move * tool.rotSpeed\n                            if tool.rotAcceleration ~ = nil and math.abs(rotSpeed - tool.lastRotSpeed) > = tool.rotAcceleration * dt then\n                                if rotSpeed > tool.lastRotSpeed then\n                                    rotSpeed = tool.lastRotSpeed + tool.rotAcceleration * dt\n                                else\n                                        rotSpeed = tool.lastRotSpeed - tool.rotAcceleration * dt\n                                    end\n                                end\n                            end\n                            if tool.transSpeed ~ = nil then\n                                transSpeed = move * tool.transSpeed\n                                if tool.transAcceleration ~ = nil and math.abs(transSpeed - tool.lastTransSpeed) > = tool.transAcceleration * dt then\n                                    if transSpeed > tool.lastTransSpeed then\n                                        transSpeed = tool.lastTransSpeed + tool.transAcceleration * dt\n                                    else\n                                            transSpeed = tool.lastTransSpeed - tool.transAcceleration * dt\n                                        end\n                                    end\n                                end\n                                if tool.animSpeed ~ = nil then\n                                    animSpeed = move * tool.animSpeed\n                                    if tool.animAcceleration ~ = nil and math.abs(animSpeed - tool.lastAnimSpeed) > = tool.animAcceleration * dt then\n                                        if animSpeed > tool.lastAnimSpeed then\n                                            animSpeed = tool.lastAnimSpeed + tool.animAcceleration * dt\n                                        else\n                                                animSpeed = tool.lastAnimSpeed - tool.animAcceleration * dt\n                                            end\n                                        end\n                                    end\n                                else\n                                        -- decelerate\n                                        if tool.rotAcceleration ~ = nil then\n                                            if tool.lastRotSpeed < 0 then\n                                                rotSpeed = math.min(tool.lastRotSpeed + tool.rotAcceleration * dt, 0 )\n                                            else\n                                                    rotSpeed = math.max(tool.lastRotSpeed - tool.rotAcceleration * dt, 0 )\n                                                end\n                                            end\n                                            if tool.transAcceleration ~ = nil then\n                                                if tool.lastTransSpeed < 0 then\n                                                    transSpeed = math.min(tool.lastTransSpeed + tool.transAcceleration * dt, 0 )\n                                                else\n                                                        transSpeed = math.max(tool.lastTransSpeed - tool.transAcceleration * dt, 0 )\n                                                    end\n                                                end\n                                                if tool.animAcceleration ~ = nil then\n                                                    if tool.lastAnimSpeed < 0 then\n                                                        animSpeed = math.min(tool.lastAnimSpeed + tool.animAcceleration * dt, 0 )\n                                                    else\n                                                            animSpeed = math.max(tool.lastAnimSpeed - tool.animAcceleration * dt, 0 )\n                                                        end\n                                                    end\n                                                end\n\n                                                local changed = false\n                                                if rotSpeed ~ = nil and rotSpeed ~ = 0 then\n                                                    changed = changed or Cylindered.setToolRotation( self , tool, rotSpeed, dt)\n                                                else\n                                                        tool.lastRotSpeed = 0\n                                                    end\n                                                    if transSpeed ~ = nil and transSpeed ~ = 0 then\n                                                        changed = changed or Cylindered.setToolTranslation( self , tool, transSpeed, dt)\n                                                    else\n                                                            tool.lastTransSpeed = 0\n                                                        end\n                                                        if animSpeed ~ = nil and animSpeed ~ = 0 then\n                                                            changed = changed or Cylindered.setToolAnimation( self , tool, animSpeed, dt)\n                                                        else\n                                                                tool.lastAnimSpeed = 0\n                                                            end\n\n                                                            for _, dependentTool in pairs(tool.dependentMovingTools) do\n                                                                if dependentTool.speedScale ~ = nil then\n                                                                    local isAllowed = true\n                                                                    if dependentTool.requiresMovement then\n                                                                        if not changed then\n                                                                            isAllowed = false\n                                                                        end\n                                                                    end\n\n                                                                    if isAllowed then\n                                                                        dependentTool.movingTool.externalMove = dependentTool.movingTool.externalMove + dependentTool.speedScale * tool.move\n                                                                    end\n                                                                end\n\n                                                                Cylindered.updateRotationBasedLimits( self , tool, dependentTool)\n\n                                                                self:updateDependentToolLimits(tool, dependentTool)\n                                                            end\n\n                                                            if changed then\n                                                                if tool.playSound then\n                                                                    spec.movingToolNeedsSound = true\n                                                                end\n                                                                Cylindered.setDirty( self , tool)\n                                                                tool.networkPositionIsDirty = true\n                                                                self:raiseDirtyFlags(tool.dirtyFlag)\n                                                                self:raiseDirtyFlags(spec.cylinderedDirtyFlag)\n\n                                                                -- keep moving tool at least 2 frames in a row network dirty, so the client will always recieve and set the final position of the tool\n                                                                tool.networkDirtyNextFrame = true\n\n                                                                if tool.isConsumingPower then\n                                                                    spec.powerConsumingTimer = spec.powerConsumingActiveTimeOffset\n                                                                end\n                                                            else\n                                                                    if tool.networkDirtyNextFrame then\n                                                                        self:raiseDirtyFlags(tool.dirtyFlag)\n                                                                        self:raiseDirtyFlags(spec.cylinderedDirtyFlag)\n                                                                        tool.networkDirtyNextFrame = nil\n                                                                    end\n                                                                end\n                                                            end\n                                                        else\n                                                                -- client side\n                                                                for i = 1 , #spec.movingTools do\n                                                                    local tool = spec.movingTools[i]\n\n                                                                    tool.networkTimeInterpolator:update(dt)\n                                                                    local interpolationAlpha = tool.networkTimeInterpolator:getAlpha()\n                                                                    local changed = false\n\n                                                                    if self:getIsMovingToolActive(tool) then\n                                                                        if tool.rotSpeed ~ = nil then\n                                                                            local newRot = tool.networkInterpolators.rotation:getInterpolatedValue(interpolationAlpha)\n                                                                            if math.abs(newRot - tool.curRot[tool.rotationAxis]) > 0.0001 then\n                                                                                changed = true\n                                                                                tool.curRot[tool.rotationAxis] = newRot\n                                                                                setRotation(tool.node, tool.curRot[ 1 ], tool.curRot[ 2 ], tool.curRot[ 3 ])\n                                                                            end\n                                                                        end\n\n                                                                        if tool.transSpeed ~ = nil then\n                                                                            local newTrans = tool.networkInterpolators.translation:getInterpolatedValue(interpolationAlpha)\n                                                                            if math.abs(newTrans - tool.curTrans[tool.translationAxis]) > 0.0001 then\n                                                                                changed = true\n                                                                                tool.curTrans[tool.translationAxis] = newTrans\n                                                                                setTranslation(tool.node, tool.curTrans[ 1 ], tool.curTrans[ 2 ], tool.curTrans[ 3 ])\n                                                                            end\n                                                                        end\n\n                                                                        if tool.animSpeed ~ = nil then\n                                                                            local newAnimTime = tool.networkInterpolators.animation:getInterpolatedValue(interpolationAlpha)\n                                                                            if math.abs(newAnimTime - tool.curAnimTime) > 0.0001 then\n                                                                                changed = true\n                                                                                tool.curAnimTime = newAnimTime\n                                                                                self:setAnimationTime(tool.animName, newAnimTime, nil , true )\n                                                                            end\n                                                                        end\n\n                                                                        if changed then\n                                                                            Cylindered.setDirty( self , tool)\n\n                                                                            SpecializationUtil.raiseEvent( self , "onMovingToolChanged" , tool, 0 , dt)\n                                                                        end\n                                                                    end\n\n                                                                    for _, dependentTool in pairs(tool.dependentMovingTools) do\n                                                                        if not dependentTool.movingTool.syncMinRotLimits or not dependentTool.movingTool.syncMaxRotLimits then\n                                                                            Cylindered.updateRotationBasedLimits( self , tool, dependentTool)\n                                                                            self:updateDependentToolLimits(tool, dependentTool)\n                                                                        end\n                                                                    end\n\n                                                                    if tool.networkTimeInterpolator:isInterpolating() then\n                                                                        self:raiseActive()\n                                                                    end\n                                                                end\n                                                            end\n\n                                                            for i = 1 , #spec.movingTools do\n                                                                local tool = spec.movingTools[i]\n                                                                if tool.delayedHistoryIndex ~ = nil and tool.delayedHistoryIndex > 0 then\n                                                                    self:updateDelayedTool(tool)\n                                                                end\n\n                                                                if tool.smoothedMove ~ = 0 then\n                                                                    if tool.lastInputTime + 50 < g_ time then\n                                                                        tool.smoothedMove = 0\n                                                                    end\n                                                                end\n                                                            end\n\n                                                            if spec.powerConsumingTimer > 0 then\n                                                                spec.powerConsumingTimer = spec.powerConsumingTimer - dt\n                                                            end\n\n                                                            if next(spec.activeSamples) ~ = nil then\n                                                                self:raiseActive()\n                                                            end\n                                                        end\n\n'})}),"\n",(0,o.jsx)(e.h3,{id:"onupdateend",children:"onUpdateEnd"}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Description"})}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Definition"})}),"\n",(0,o.jsxs)(e.blockquote,{children:["\n",(0,o.jsx)(e.p,{children:"onUpdateEnd()"}),"\n"]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,o.jsxs)(e.table,{children:[(0,o.jsx)(e.thead,{children:(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.th,{children:"any"}),(0,o.jsx)(e.th,{children:"dt"})]})}),(0,o.jsxs)(e.tbody,{children:[(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.td,{children:"any"}),(0,o.jsx)(e.td,{children:"isActiveForInput"})]}),(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.td,{children:"any"}),(0,o.jsx)(e.td,{children:"isActiveForInputIgnoreSelection"})]}),(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.td,{children:"any"}),(0,o.jsx)(e.td,{children:"isSelected"})]})]})]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Code"})}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-lua",children:"function Cylindered:onUpdateEnd(dt, isActiveForInput, isActiveForInputIgnoreSelection, isSelected)\n    -- force update of all moving parts independent of camera distance right before vehicles starts to sleep\n    -- so if we get into the moving part update distance agan we are already in the right state without waking up the vehicle\n        local spec = self.spec_cylindered\n        for _, part in pairs(spec.activeDirtyMovingParts) do\n            Cylindered.setDirty( self , part)\n        end\n\n        self:updateDirtyMovingParts(dt, true )\n    end\n\n"})}),"\n",(0,o.jsx)(e.h3,{id:"onupdatetick",children:"onUpdateTick"}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Description"})}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Definition"})}),"\n",(0,o.jsxs)(e.blockquote,{children:["\n",(0,o.jsx)(e.p,{children:"onUpdateTick()"}),"\n"]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,o.jsxs)(e.table,{children:[(0,o.jsx)(e.thead,{children:(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.th,{children:"any"}),(0,o.jsx)(e.th,{children:"dt"})]})}),(0,o.jsxs)(e.tbody,{children:[(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.td,{children:"any"}),(0,o.jsx)(e.td,{children:"isActiveForInput"})]}),(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.td,{children:"any"}),(0,o.jsx)(e.td,{children:"isActiveForInputIgnoreSelection"})]}),(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.td,{children:"any"}),(0,o.jsx)(e.td,{children:"isSelected"})]})]})]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Code"})}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-lua",children:"function Cylindered:onUpdateTick(dt, isActiveForInput, isActiveForInputIgnoreSelection, isSelected)\n    if self.isClient then\n        local spec = self.spec_cylindered\n        local movingToolStateChanged = false\n        for _, movingTool in pairs(spec.movingTools) do\n            if movingTool.axisActionIndex ~ = nil then\n                local isActive = self:getIsMovingToolActive(movingTool)\n                if isActive ~ = movingTool.lastIsActiveState then\n                    movingTool.lastIsActiveState = isActive\n                    movingToolStateChanged = true\n                end\n\n                -- check only movingTools from selected control group since the other movingTools action events are not registered\n                if spec.currentControlGroupIndex = = movingTool.controlGroupIndex then\n                    local actionEvent = spec.actionEvents[movingTool.axisActionIndex]\n                    if actionEvent ~ = nil then\n                        g_inputBinding:setActionEventActive(actionEvent.actionEventId, isActive)\n\n                        -- reset the move values if the action gets deactivate while still being pressed\n                            if not isActive then\n                                movingTool.move = 0\n                                if movingTool.move ~ = movingTool.moveToSend then\n                                    movingTool.moveToSend = movingTool.move\n                                    self:raiseDirtyFlags(spec.cylinderedInputDirtyFlag)\n                                end\n                            end\n                        end\n                    end\n                end\n            end\n\n            if movingToolStateChanged then\n                self:updateControlGroups()\n            end\n\n            for i = #spec.activeSamples, 1 , - 1 do\n                local sample = spec.activeSamples[i]\n                if sample.lastActivationTime + dt * 3 < g_ time then\n                    if sample.lastActivationTime + dt * 3 + sample.dropOffTime > = g_ time then\n                        if not sample.dropOffActive then\n                            sample.dropOffActive = true\n                            g_soundManager:setSamplePitchOffset(sample, g_soundManager:getCurrentSamplePitch(sample) * (sample.dropOffFactor - 1 ))\n                        end\n                    else\n                            sample.dropOffActive = false\n                            g_soundManager:setSamplePitchOffset(sample, 0 )\n                            g_soundManager:stopSample(sample)\n                            table.remove(spec.activeSamples, i)\n                        end\n                    end\n                end\n\n                for i = #spec.endingSamples, 1 , - 1 do\n                    local sample = spec.endingSamples[i]\n                    if sample.lastActivationTime + dt < g_ time then\n                        if sample.loops = = 0 then\n                            sample.loops = 1\n                        end\n\n                        g_soundManager:playSample(sample)\n                        table.remove(spec.endingSamples, i)\n                        spec.endingSamplesBySample[sample] = nil\n                    end\n                end\n\n                for i = #spec.startingSamples, 1 , - 1 do\n                    local sample = spec.startingSamples[i]\n                    if sample.lastActivationTime + dt < g_ time then\n                        table.remove(spec.startingSamples, i)\n                        spec.startingSamplesBySample[sample] = nil\n                    end\n                end\n            end\n        end\n\n"})}),"\n",(0,o.jsx)(e.h3,{id:"onvehiclesettingchanged",children:"onVehicleSettingChanged"}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Description"})}),"\n",(0,o.jsxs)(e.blockquote,{children:["\n",(0,o.jsx)(e.p,{children:"Called when vehicle settings change"}),"\n"]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Definition"})}),"\n",(0,o.jsxs)(e.blockquote,{children:["\n",(0,o.jsx)(e.p,{children:"onVehicleSettingChanged()"}),"\n"]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,o.jsxs)(e.table,{children:[(0,o.jsx)(e.thead,{children:(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.th,{children:"any"}),(0,o.jsx)(e.th,{children:"gameSettingId"})]})}),(0,o.jsx)(e.tbody,{children:(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.td,{children:"any"}),(0,o.jsx)(e.td,{children:"state"})]})})]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Code"})}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-lua",children:"function Cylindered:onVehicleSettingChanged(gameSettingId, state)\n    if gameSettingId = = GameSettings.SETTING.EASY_ARM_CONTROL then\n        self:setIsEasyControlActive(state)\n    end\nend\n\n"})}),"\n",(0,o.jsx)(e.h3,{id:"onwritestream",children:"onWriteStream"}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Description"})}),"\n",(0,o.jsxs)(e.blockquote,{children:["\n",(0,o.jsx)(e.p,{children:"Called on server side on join"}),"\n"]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Definition"})}),"\n",(0,o.jsxs)(e.blockquote,{children:["\n",(0,o.jsx)(e.p,{children:"onWriteStream(integer streamId, Connection connection)"}),"\n"]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,o.jsxs)(e.table,{children:[(0,o.jsx)(e.thead,{children:(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.th,{children:"integer"}),(0,o.jsx)(e.th,{children:"streamId"}),(0,o.jsx)(e.th,{children:"streamId"})]})}),(0,o.jsx)(e.tbody,{children:(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.td,{children:"Connection"}),(0,o.jsx)(e.td,{children:"connection"}),(0,o.jsx)(e.td,{children:"connection"})]})})]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Code"})}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-lua",children:"function Cylindered:onWriteStream(streamId, connection)\n    local spec = self.spec_cylindered\n\n    if not connection:getIsServer() then\n        if streamWriteBool(streamId, self:allowLoadMovingToolStates()) then\n            for i = 1 , #spec.movingTools do\n                local tool = spec.movingTools[i]\n                if tool.dirtyFlag ~ = nil then\n                    if tool.transSpeed ~ = nil then\n                        streamWriteFloat32(streamId, tool.curTrans[tool.translationAxis])\n                    end\n                    if tool.rotSpeed ~ = nil then\n                        streamWriteFloat32(streamId, tool.curRot[tool.rotationAxis])\n                    end\n                    if tool.animSpeed ~ = nil then\n                        tool.curAnimTime = self:getAnimationTime(tool.animName)\n                        streamWriteFloat32(streamId, tool.curAnimTime)\n                    end\n                end\n            end\n        end\n    end\nend\n\n"})}),"\n",(0,o.jsx)(e.h3,{id:"onwriteupdatestream",children:"onWriteUpdateStream"}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Description"})}),"\n",(0,o.jsxs)(e.blockquote,{children:["\n",(0,o.jsx)(e.p,{children:"Called on on update"}),"\n"]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Definition"})}),"\n",(0,o.jsxs)(e.blockquote,{children:["\n",(0,o.jsx)(e.p,{children:"onWriteUpdateStream(integer streamId, table connection, integer dirtyMask)"}),"\n"]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,o.jsxs)(e.table,{children:[(0,o.jsx)(e.thead,{children:(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.th,{children:"integer"}),(0,o.jsx)(e.th,{children:"streamId"}),(0,o.jsx)(e.th,{children:"stream ID"})]})}),(0,o.jsxs)(e.tbody,{children:[(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.td,{children:"table"}),(0,o.jsx)(e.td,{children:"connection"}),(0,o.jsx)(e.td,{children:"connection"})]}),(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.td,{children:"integer"}),(0,o.jsx)(e.td,{children:"dirtyMask"}),(0,o.jsx)(e.td,{children:"dirty mask"})]})]})]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Code"})}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-lua",children:"function Cylindered:onWriteUpdateStream(streamId, connection, dirtyMask)\n    local spec = self.spec_cylindered\n\n    -- if client, send input to server\n        if connection:getIsServer() then\n            if streamWriteBool(streamId, bit32.band(dirtyMask, spec.cylinderedInputDirtyFlag) ~ = 0 ) then\n                for _, tool in ipairs(spec.movingTools) do\n                    if tool.axisActionIndex ~ = nil then\n                        local value = ( math.clamp(tool.moveToSend / 5 , - 1 , 1 ) + 1 ) / 2 * 4095\n                        streamWriteUIntN(streamId, value, 12 )\n                    end\n                end\n            end\n        else\n                -- if server, send updated attributes\n                    if streamWriteBool(streamId, bit32.band(dirtyMask, spec.cylinderedDirtyFlag) ~ = 0 ) then\n                        for _, tool in ipairs(spec.movingTools) do\n                            if tool.dirtyFlag ~ = nil then\n                                if streamWriteBool(streamId, bit32.band(dirtyMask, tool.dirtyFlag) ~ = 0 and self:getIsMovingToolActive(tool)) then\n                                    if tool.transSpeed ~ = nil then\n                                        streamWriteFloat32(streamId, tool.curTrans[tool.translationAxis])\n                                    end\n                                    if tool.rotSpeed ~ = nil then\n                                        local rot = tool.curRot[tool.rotationAxis]\n                                        if tool.rotMin = = nil or tool.rotMax = = nil then\n                                            NetworkUtil.writeCompressedAngle(streamId, rot)\n                                        else\n                                                if tool.syncMinRotLimits then\n                                                    streamWriteFloat32(streamId, tool.rotMin)\n                                                end\n                                                if tool.syncMaxRotLimits then\n                                                    streamWriteFloat32(streamId, tool.rotMax)\n                                                end\n                                                NetworkUtil.writeCompressedRange(streamId, rot, tool.rotMin, tool.rotMax, tool.rotSendNumBits)\n                                            end\n                                        end\n                                        if tool.animSpeed ~ = nil then\n                                            local curAnimTime = self:getAnimationTime(tool.animName)\n                                            local hasChanged = math.abs(curAnimTime - tool.curAnimTime) > 0.001\n                                            streamWriteBool(streamId, hasChanged or tool.networkInterpolators.resetAnimInterpolation)\n                                            tool.networkInterpolators.resetAnimInterpolation = false\n\n                                            tool.curAnimTime = curAnimTime\n                                            NetworkUtil.writeCompressedRange(streamId, tool.curAnimTime, tool.animMinTime, tool.animMaxTime, tool.animSendNumBits)\n                                        end\n                                    end\n                                end\n                            end\n                        end\n                    end\n                end\n\n"})}),"\n",(0,o.jsx)(e.h3,{id:"prerequisitespresent",children:"prerequisitesPresent"}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Description"})}),"\n",(0,o.jsxs)(e.blockquote,{children:["\n",(0,o.jsx)(e.p,{children:"Checks if all prerequisite specializations are loaded"}),"\n"]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Definition"})}),"\n",(0,o.jsxs)(e.blockquote,{children:["\n",(0,o.jsx)(e.p,{children:"prerequisitesPresent(table specializations)"}),"\n"]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n",(0,o.jsx)(e.table,{children:(0,o.jsx)(e.thead,{children:(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.th,{children:"table"}),(0,o.jsx)(e.th,{children:"specializations"}),(0,o.jsx)(e.th,{children:"specializations"})]})})}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Return Values"})}),"\n\n\n\n\n\n\n\n\n",(0,o.jsx)(e.table,{children:(0,o.jsx)(e.thead,{children:(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.th,{children:"table"}),(0,o.jsx)(e.th,{children:"hasPrerequisite"}),(0,o.jsx)(e.th,{children:"true if all prerequisite specializations are loaded"})]})})}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Code"})}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-lua",children:"function Cylindered.prerequisitesPresent(specializations)\n    return SpecializationUtil.hasSpecialization( VehicleSettings , specializations)\nend\n\n"})}),"\n",(0,o.jsx)(e.h3,{id:"registercopylocaldirectionxmlpaths",children:"registerCopyLocalDirectionXMLPaths"}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Description"})}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Definition"})}),"\n",(0,o.jsxs)(e.blockquote,{children:["\n",(0,o.jsx)(e.p,{children:"registerCopyLocalDirectionXMLPaths()"}),"\n"]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,o.jsxs)(e.table,{children:[(0,o.jsx)(e.thead,{children:(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.th,{children:"any"}),(0,o.jsx)(e.th,{children:"schema"})]})}),(0,o.jsx)(e.tbody,{children:(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.td,{children:"any"}),(0,o.jsx)(e.td,{children:"basePath"})]})})]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Code"})}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-lua",children:'function Cylindered.registerCopyLocalDirectionXMLPaths(schema, basePath)\n    schema:register(XMLValueType.NODE_INDEX, basePath .. ".copyLocalDirectionPart(?)#node" , "Copy local direction part" )\n    schema:register(XMLValueType.VECTOR_ 3 , basePath .. ".copyLocalDirectionPart(?)#dirScale" , "Direction scale" )\n    schema:register(XMLValueType.VECTOR_ 3 , basePath .. ".copyLocalDirectionPart(?)#upScale" , "Up vector scale" )\n\n    Cylindered.registerDependentComponentJointXMLPaths(schema, basePath .. ".copyLocalDirectionPart(?)" )\nend\n\n'})}),"\n",(0,o.jsx)(e.h3,{id:"registerdependentanimationxmlpaths",children:"registerDependentAnimationXMLPaths"}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Description"})}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Definition"})}),"\n",(0,o.jsxs)(e.blockquote,{children:["\n",(0,o.jsx)(e.p,{children:"registerDependentAnimationXMLPaths()"}),"\n"]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,o.jsxs)(e.table,{children:[(0,o.jsx)(e.thead,{children:(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.th,{children:"any"}),(0,o.jsx)(e.th,{children:"schema"})]})}),(0,o.jsx)(e.tbody,{children:(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.td,{children:"any"}),(0,o.jsx)(e.td,{children:"basePath"})]})})]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Code"})}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-lua",children:'function Cylindered.registerDependentAnimationXMLPaths(schema, basePath)\n    schema:register(XMLValueType.STRING, basePath .. ".dependentAnimation(?)#name" , "Dependent animation name" )\n    schema:register(XMLValueType.INT, basePath .. ".dependentAnimation(?)#translationAxis" , "Translation axis" )\n    schema:register(XMLValueType.INT, basePath .. ".dependentAnimation(?)#rotationAxis" , "Rotation axis" )\n    schema:register(XMLValueType.INT, basePath .. ".dependentAnimation(?)#useTranslatingPartIndex" , "Use translation part index" )\n    schema:register(XMLValueType.FLOAT, basePath .. ".dependentAnimation(?)#minValue" , "Min.reference value" )\n    schema:register(XMLValueType.FLOAT, basePath .. ".dependentAnimation(?)#maxValue" , "Max.reference value" )\n    schema:register(XMLValueType.BOOL, basePath .. ".dependentAnimation(?)#invert" , "Invert reference value" , false )\nend\n\n'})}),"\n",(0,o.jsx)(e.h3,{id:"registerdependentcomponentjointxmlpaths",children:"registerDependentComponentJointXMLPaths"}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Description"})}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Definition"})}),"\n",(0,o.jsxs)(e.blockquote,{children:["\n",(0,o.jsx)(e.p,{children:"registerDependentComponentJointXMLPaths()"}),"\n"]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,o.jsxs)(e.table,{children:[(0,o.jsx)(e.thead,{children:(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.th,{children:"any"}),(0,o.jsx)(e.th,{children:"schema"})]})}),(0,o.jsx)(e.tbody,{children:(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.td,{children:"any"}),(0,o.jsx)(e.td,{children:"basePath"})]})})]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Code"})}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-lua",children:'function Cylindered.registerDependentComponentJointXMLPaths(schema, basePath)\n    schema:register(XMLValueType.INT, basePath .. ".componentJoint(?)#index" , "Dependent component joint index" )\n    schema:register(XMLValueType.BOOL, basePath .. ".componentJoint(?)#ignoreWarning" , "Ignore if the index could not be found(due to configurations for example)" , false )\n        schema:register(XMLValueType.INT, basePath .. ".componentJoint(?)#anchorActor" , "Dependent component anchor actor" )\n    end\n\n'})}),"\n",(0,o.jsx)(e.h3,{id:"registerdependentmovingtoolxmlpaths",children:"registerDependentMovingToolXMLPaths"}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Description"})}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Definition"})}),"\n",(0,o.jsxs)(e.blockquote,{children:["\n",(0,o.jsx)(e.p,{children:"registerDependentMovingToolXMLPaths()"}),"\n"]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,o.jsxs)(e.table,{children:[(0,o.jsx)(e.thead,{children:(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.th,{children:"any"}),(0,o.jsx)(e.th,{children:"schema"})]})}),(0,o.jsx)(e.tbody,{children:(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.td,{children:"any"}),(0,o.jsx)(e.td,{children:"basePath"})]})})]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Code"})}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-lua",children:'function Cylindered.registerDependentMovingToolXMLPaths(schema, basePath)\n    schema:register(XMLValueType.NODE_INDEX, basePath .. ".dependentMovingTool(?)#node" , "Dependent part" )\n    schema:register(XMLValueType.INT, basePath .. ".dependentMovingTool(?)#axis" , "Rotation axis of the moving part which is used as reference in the rotationBasedLimits" , 1 )\n    schema:register(XMLValueType.FLOAT, basePath .. ".dependentMovingTool(?)#speedScale" , "Speed scale" )\n    schema:register(XMLValueType.BOOL, basePath .. ".dependentMovingTool(?)#requiresMovement" , "Requires movement" , false )\n    schema:register(XMLValueType.ANGLE, basePath .. ".dependentMovingTool(?).rotationBasedLimits.limit(?)#rotation" , "Rotation" )\n    schema:register(XMLValueType.ANGLE, basePath .. ".dependentMovingTool(?).rotationBasedLimits.limit(?)#rotMin" , "Min.rotation" )\n    schema:register(XMLValueType.ANGLE, basePath .. ".dependentMovingTool(?).rotationBasedLimits.limit(?)#rotMax" , "Max.rotation" )\n    schema:register(XMLValueType.FLOAT, basePath .. ".dependentMovingTool(?).rotationBasedLimits.limit(?)#transMin" , "Min.translation" )\n    schema:register(XMLValueType.FLOAT, basePath .. ".dependentMovingTool(?).rotationBasedLimits.limit(?)#transMax" , "Max.translation" )\n    schema:register(XMLValueType.VECTOR_ 2 , basePath .. ".dependentMovingTool(?)#minTransLimits" , "Min.translation limits" )\n    schema:register(XMLValueType.VECTOR_ 2 , basePath .. ".dependentMovingTool(?)#maxTransLimits" , "Max.translation limits" )\n    schema:register(XMLValueType.VECTOR_ROT_ 2 , basePath .. ".dependentMovingTool(?)#minRotLimits" , "Min.rotation limits" )\n    schema:register(XMLValueType.VECTOR_ROT_ 2 , basePath .. ".dependentMovingTool(?)#maxRotLimits" , "Max.rotation limits" )\nend\n\n'})}),"\n",(0,o.jsx)(e.h3,{id:"registereasyarmcontrolxmlpaths",children:"registerEasyArmControlXMLPaths"}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Description"})}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Definition"})}),"\n",(0,o.jsxs)(e.blockquote,{children:["\n",(0,o.jsx)(e.p,{children:"registerEasyArmControlXMLPaths()"}),"\n"]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,o.jsxs)(e.table,{children:[(0,o.jsx)(e.thead,{children:(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.th,{children:"any"}),(0,o.jsx)(e.th,{children:"schema"})]})}),(0,o.jsx)(e.tbody,{children:(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.td,{children:"any"}),(0,o.jsx)(e.td,{children:"key"})]})})]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Code"})}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-lua",children:'function Cylindered.registerEasyArmControlXMLPaths(schema, key)\n    schema:register(XMLValueType.NODE_INDEX, key .. "#rootNode" , "Root node" )\n    schema:register(XMLValueType.NODE_INDEX, key .. "#node" , "Node" )\n    schema:register(XMLValueType.NODE_INDEX, key .. "#targetNodeZ" , "Z target node" )\n    schema:register(XMLValueType.NODE_INDEX, key .. "#refNode" , "Reference node" )\n    schema:register(XMLValueType.FLOAT, key .. "#maxTotalDistance" , "Max.total distance the arms can move from rootNode" , "automatically calculated" )\n    schema:register(XMLValueType.FLOAT, key .. ".targetMovement#speed" , "Target node move speed" , 1 )\n    schema:register(XMLValueType.FLOAT, key .. ".targetMovement#acceleration" , "Target node move acceleration" , 50 )\n    schema:register(XMLValueType.FLOAT, key .. ".zTranslationNodes#minMoveRatio" , "Min.ratio between translation and rotation movement [0:only rotation, 1:only translation]" , 0.2 )\n    schema:register(XMLValueType.FLOAT, key .. ".zTranslationNodes#maxMoveRatio" , "Max.ratio between translation and rotation movement [0:only rotation, 1:only translation]" , 0.8 )\n    schema:register(XMLValueType.FLOAT, key .. ".zTranslationNodes#moveRatioMinDir" , "Defines direction value when the translation parts start to move" , 0.0 )\n    schema:register(XMLValueType.FLOAT, key .. ".zTranslationNodes#moveRatioMaxDir" , "Defines direction value when the rotation parts stop to move" , 1.0 )\n    schema:register(XMLValueType.BOOL, key .. ".zTranslationNodes#allowNegativeTrans" , "Allow translation movement if translation parts are pointing towards the root node" , false )\n        schema:register(XMLValueType.FLOAT, key .. ".zTranslationNodes#minNegativeTrans" , "Min.translation percentage when moving the translation parts into negative direction while they are pointing towards the root node" , 0 )\n            schema:register(XMLValueType.NODE_INDEX, key .. ".zTranslationNodes.zTranslationNode(?)#node" , "Z translation node" )\n            schema:register(XMLValueType.NODE_INDEX, key .. ".xRotationNodes.xRotationNode1#node" , "X translation node" )\n            schema:register(XMLValueType.NODE_INDEX, key .. ".xRotationNodes.xRotationNode2#node" , "X translation node" )\n        end\n\n'})}),"\n",(0,o.jsx)(e.h3,{id:"registereventlisteners",children:"registerEventListeners"}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Description"})}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Definition"})}),"\n",(0,o.jsxs)(e.blockquote,{children:["\n",(0,o.jsx)(e.p,{children:"registerEventListeners()"}),"\n"]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,o.jsx)(e.table,{children:(0,o.jsx)(e.thead,{children:(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.th,{children:"any"}),(0,o.jsx)(e.th,{children:"vehicleType"})]})})}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Code"})}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-lua",children:'function Cylindered.registerEventListeners(vehicleType)\n    SpecializationUtil.registerEventListener(vehicleType, "onLoad" , Cylindered )\n    SpecializationUtil.registerEventListener(vehicleType, "onPostLoad" , Cylindered )\n    SpecializationUtil.registerEventListener(vehicleType, "onLoadFinished" , Cylindered )\n    SpecializationUtil.registerEventListener(vehicleType, "onRegisterDashboardValueTypes" , Cylindered )\n    SpecializationUtil.registerEventListener(vehicleType, "onDelete" , Cylindered )\n    SpecializationUtil.registerEventListener(vehicleType, "onReadStream" , Cylindered )\n    SpecializationUtil.registerEventListener(vehicleType, "onWriteStream" , Cylindered )\n    SpecializationUtil.registerEventListener(vehicleType, "onReadUpdateStream" , Cylindered )\n    SpecializationUtil.registerEventListener(vehicleType, "onWriteUpdateStream" , Cylindered )\n    SpecializationUtil.registerEventListener(vehicleType, "onUpdate" , Cylindered )\n    SpecializationUtil.registerEventListener(vehicleType, "onUpdateTick" , Cylindered )\n    SpecializationUtil.registerEventListener(vehicleType, "onUpdateEnd" , Cylindered )\n    SpecializationUtil.registerEventListener(vehicleType, "onPostUpdate" , Cylindered )\n    SpecializationUtil.registerEventListener(vehicleType, "onPostUpdateTick" , Cylindered )\n    SpecializationUtil.registerEventListener(vehicleType, "onDraw" , Cylindered )\n    SpecializationUtil.registerEventListener(vehicleType, "onRegisterActionEvents" , Cylindered )\n    SpecializationUtil.registerEventListener(vehicleType, "onPostAttach" , Cylindered )\n    SpecializationUtil.registerEventListener(vehicleType, "onSelect" , Cylindered )\n    SpecializationUtil.registerEventListener(vehicleType, "onUnselect" , Cylindered )\n    SpecializationUtil.registerEventListener(vehicleType, "onDeactivate" , Cylindered )\n    SpecializationUtil.registerEventListener(vehicleType, "onAnimationPartChanged" , Cylindered )\n    SpecializationUtil.registerEventListener(vehicleType, "onAIImplementStart" , Cylindered )\n    SpecializationUtil.registerEventListener(vehicleType, "onVehicleSettingChanged" , Cylindered )\n    SpecializationUtil.registerEventListener(vehicleType, "onRegisterAnimationValueTypes" , Cylindered )\nend\n\n'})}),"\n",(0,o.jsx)(e.h3,{id:"registerevents",children:"registerEvents"}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Description"})}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Definition"})}),"\n",(0,o.jsxs)(e.blockquote,{children:["\n",(0,o.jsx)(e.p,{children:"registerEvents()"}),"\n"]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,o.jsx)(e.table,{children:(0,o.jsx)(e.thead,{children:(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.th,{children:"any"}),(0,o.jsx)(e.th,{children:"vehicleType"})]})})}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Code"})}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-lua",children:'function Cylindered.registerEvents(vehicleType)\n    SpecializationUtil.registerEvent(vehicleType, "onMovingToolChanged" )\nend\n\n'})}),"\n",(0,o.jsx)(e.h3,{id:"registerfunctions",children:"registerFunctions"}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Description"})}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Definition"})}),"\n",(0,o.jsxs)(e.blockquote,{children:["\n",(0,o.jsx)(e.p,{children:"registerFunctions()"}),"\n"]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,o.jsx)(e.table,{children:(0,o.jsx)(e.thead,{children:(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.th,{children:"any"}),(0,o.jsx)(e.th,{children:"vehicleType"})]})})}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Code"})}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-lua",children:'function Cylindered.registerFunctions(vehicleType)\n    SpecializationUtil.registerFunction(vehicleType, "loadMovingPartsFromXML" , Cylindered.loadMovingPartsFromXML)\n    SpecializationUtil.registerFunction(vehicleType, "loadMovingPartFromXML" , Cylindered.loadMovingPartFromXML)\n    SpecializationUtil.registerFunction(vehicleType, "loadMovingToolsFromXML" , Cylindered.loadMovingToolsFromXML)\n    SpecializationUtil.registerFunction(vehicleType, "loadMovingToolFromXML" , Cylindered.loadMovingToolFromXML)\n    SpecializationUtil.registerFunction(vehicleType, "loadDependentMovingTools" , Cylindered.loadDependentMovingTools)\n    SpecializationUtil.registerFunction(vehicleType, "loadEasyArmControlFromXML" , Cylindered.loadEasyArmControlFromXML)\n    SpecializationUtil.registerFunction(vehicleType, "loadDependentParts" , Cylindered.loadDependentParts)\n    SpecializationUtil.registerFunction(vehicleType, "resolveDependentPartData" , Cylindered.resolveDependentPartData)\n    SpecializationUtil.registerFunction(vehicleType, "loadDependentComponentJoints" , Cylindered.loadDependentComponentJoints)\n    SpecializationUtil.registerFunction(vehicleType, "loadDependentAttacherJoints" , Cylindered.loadDependentAttacherJoints)\n    SpecializationUtil.registerFunction(vehicleType, "loadDependentWheels" , Cylindered.loadDependentWheels)\n    SpecializationUtil.registerFunction(vehicleType, "loadDependentTranslatingParts" , Cylindered.loadDependentTranslatingParts)\n    SpecializationUtil.registerFunction(vehicleType, "loadExtraDependentParts" , Cylindered.loadExtraDependentParts)\n    SpecializationUtil.registerFunction(vehicleType, "loadDependentAnimations" , Cylindered.loadDependentAnimations)\n    SpecializationUtil.registerFunction(vehicleType, "loadCopyLocalDirectionParts" , Cylindered.loadCopyLocalDirectionParts)\n    SpecializationUtil.registerFunction(vehicleType, "loadRotationBasedLimits" , Cylindered.loadRotationBasedLimits)\n    SpecializationUtil.registerFunction(vehicleType, "loadActionSoundsFromXML" , Cylindered.loadActionSoundsFromXML)\n    SpecializationUtil.registerFunction(vehicleType, "checkMovingPartDirtyUpdateNode" , Cylindered.checkMovingPartDirtyUpdateNode)\n    SpecializationUtil.registerFunction(vehicleType, "updateDirtyMovingParts" , Cylindered.updateDirtyMovingParts)\n    SpecializationUtil.registerFunction(vehicleType, "setMovingToolDirty" , Cylindered.setMovingToolDirty)\n    SpecializationUtil.registerFunction(vehicleType, "setMovingPartReferenceNode" , Cylindered.setMovingPartReferenceNode)\n    SpecializationUtil.registerFunction(vehicleType, "updateMovingPartByNode" , Cylindered.updateMovingPartByNode)\n    SpecializationUtil.registerFunction(vehicleType, "updateCylinderedInitial" , Cylindered.updateCylinderedInitial)\n    SpecializationUtil.registerFunction(vehicleType, "allowLoadMovingToolStates" , Cylindered.allowLoadMovingToolStates)\n    SpecializationUtil.registerFunction(vehicleType, "getMovingToolByNode" , Cylindered.getMovingToolByNode)\n    SpecializationUtil.registerFunction(vehicleType, "getMovingPartByNode" , Cylindered.getMovingPartByNode)\n    SpecializationUtil.registerFunction(vehicleType, "getTranslatingPartByNode" , Cylindered.getTranslatingPartByNode)\n    SpecializationUtil.registerFunction(vehicleType, "getIsMovingToolActive" , Cylindered.getIsMovingToolActive)\n    SpecializationUtil.registerFunction(vehicleType, "getIsMovingPartActive" , Cylindered.getIsMovingPartActive)\n    SpecializationUtil.registerFunction(vehicleType, "getMovingToolMoveValue" , Cylindered.getMovingToolMoveValue)\n    SpecializationUtil.registerFunction(vehicleType, "setDelayedData" , Cylindered.setDelayedData)\n    SpecializationUtil.registerFunction(vehicleType, "updateDelayedTool" , Cylindered.updateDelayedTool)\n    SpecializationUtil.registerFunction(vehicleType, "updateEasyControl" , Cylindered.updateEasyControl)\n    SpecializationUtil.registerFunction(vehicleType, "setIsEasyControlActive" , Cylindered.setIsEasyControlActive)\n    SpecializationUtil.registerFunction(vehicleType, "setEasyControlForcedTransMove" , Cylindered.setEasyControlForcedTransMove)\n    SpecializationUtil.registerFunction(vehicleType, "updateExtraDependentParts" , Cylindered.updateExtraDependentParts)\n    SpecializationUtil.registerFunction(vehicleType, "updateDependentAnimations" , Cylindered.updateDependentAnimations)\n    SpecializationUtil.registerFunction(vehicleType, "updateDependentToolLimits" , Cylindered.updateDependentToolLimits)\n    SpecializationUtil.registerFunction(vehicleType, "onMovingPartSoundEvent" , Cylindered.onMovingPartSoundEvent)\n    SpecializationUtil.registerFunction(vehicleType, "updateMovingToolSoundEvents" , Cylindered.updateMovingToolSoundEvents)\n    SpecializationUtil.registerFunction(vehicleType, "updateControlGroups" , Cylindered.updateControlGroups)\nend\n\n'})}),"\n",(0,o.jsx)(e.h3,{id:"registermovingpartxmlpaths",children:"registerMovingPartXMLPaths"}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Description"})}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Definition"})}),"\n",(0,o.jsxs)(e.blockquote,{children:["\n",(0,o.jsx)(e.p,{children:"registerMovingPartXMLPaths()"}),"\n"]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,o.jsxs)(e.table,{children:[(0,o.jsx)(e.thead,{children:(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.th,{children:"any"}),(0,o.jsx)(e.th,{children:"schema"})]})}),(0,o.jsx)(e.tbody,{children:(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.td,{children:"any"}),(0,o.jsx)(e.td,{children:"partKey"})]})})]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Code"})}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-lua",children:'function Cylindered.registerMovingPartXMLPaths(schema, partKey)\n    schema:addDelayedRegistrationPath(partKey, "Cylindered:movingPart" )\n\n    schema:register(XMLValueType.NODE_INDEX, partKey .. "#node" , "Node" )\n    schema:register(XMLValueType.NODE_INDEX, partKey .. "#referenceFrame" , "Reference frame" )\n    schema:register(XMLValueType.NODE_INDEX, partKey .. "#referencePoint" , "Reference point" )\n    schema:register(XMLValueType.NODE_INDICES, partKey .. "#referencePoints" , "List of reference points(average position will be used as reference)" )\n\n    schema:register(XMLValueType.BOOL, partKey .. "#invertZ" , "Invert Z axis" , false )\n    schema:register(XMLValueType.BOOL, partKey .. "#scaleZ" , "Allow Z axis scaling" , false )\n    schema:register(XMLValueType.INT, partKey .. "#limitedAxis" , "Limited axis" )\n    schema:register(XMLValueType.BOOL, partKey .. "#isActiveDirty" , "Part is permanently updated" , false )\n    schema:register(XMLValueType.BOOL, partKey .. "#playSound" , "Play hydraulic sound" , false )\n    schema:register(XMLValueType.BOOL, partKey .. "#moveToReferenceFrame" , "Move to reference frame" , false )\n    schema:register(XMLValueType.BOOL, partKey .. "#doLineAlignment" , "Do line alignment(line as ref point)" , false )\n    schema:register(XMLValueType.BOOL, partKey .. "#doInversedLineAlignment" , "Do inversed line alignment(line inside part and fixed ref point)" , false )\n    schema:register(XMLValueType.BOOL, partKey .. "#do3DLineAlignment" , "Do 3D line alignment(X and Y rotation is aligned to the given line - line is only allowed to have two points!)" , false )\n    schema:register(XMLValueType.FLOAT, partKey .. ".orientationLine#partLength" , "Part length(Distance from part to line)" , 0.5 )\n    schema:register(XMLValueType.NODE_INDEX, partKey .. ".orientationLine#referenceTransNode" , "Node that is moved to the current line position and at the same time is used a referencePoint for the directional alignment of the movingPart" )\n        schema:register(XMLValueType.NODE_INDEX, partKey .. ".orientationLine#partLengthNode" , "Node to measure the part length dynamically" )\n        schema:register(XMLValueType.NODE_INDEX, partKey .. ".orientationLine.lineNode(?)#node" , "Line node" )\n\n        schema:register(XMLValueType.BOOL, partKey .. "#doDirectionAlignment" , "Do direction alignment" , true )\n        schema:register(XMLValueType.BOOL, partKey .. "#doRotationAlignment" , "Do rotation alignment" , false )\n        schema:register(XMLValueType.FLOAT, partKey .. "#rotMultiplier" , "Rotation multiplier for rotation alignment" , 0 )\n\n            schema:register(XMLValueType.ANGLE, partKey .. "#minRot" , "Min.rotation for limited axis" )\n                schema:register(XMLValueType.ANGLE, partKey .. "#maxRot" , "Max.rotation for limited axis" )\n\n                    schema:register(XMLValueType.BOOL, partKey .. "#alignToWorldY" , "Align part to world Y axis" , false )\n                    schema:register(XMLValueType.NODE_INDEX, partKey .. "#localReferencePoint" , "Local reference point" )\n                    schema:register(XMLValueType.NODE_INDEX, partKey .. "#referenceDistancePoint" , "Z translation will be used as reference distance" )\n                    schema:register(XMLValueType.FLOAT, partKey .. "#referenceDistance" , "Reference distance to be used instead of the current distance in the i3d(distance between node and ref point - or local ref point and ref point)" )\n                    schema:register(XMLValueType.FLOAT, partKey .. "#localReferenceDistance" , "Predefined reference distance" , "calculated automatically" )\n                    schema:register(XMLValueType.BOOL, partKey .. "#updateLocalReferenceDistance" , "Update distance to local reference point" , false )\n                    schema:register(XMLValueType.BOOL, partKey .. "#dynamicLocalReferenceDistance" , "Local reference distance will be calculated based on the initial distance and the localReferencePoint direction" , false )\n                    schema:register(XMLValueType.BOOL, partKey .. "#localReferenceTranslate" , "Translate to local reference node" , false )\n                    schema:register(XMLValueType.FLOAT, partKey .. "#referenceDistanceThreshold" , "Distance threshold to update moving part while isActiveDirty" , 0.0001 )\n                        schema:register(XMLValueType.BOOL, partKey .. "#useLocalOffset" , "Use local offset" , false )\n                        schema:register(XMLValueType.FLOAT, partKey .. "#referencePointOffset" , "Offset to the reference point in Y alignment" )\n                        schema:register(XMLValueType.FLOAT, partKey .. "#directionThreshold" , "Direction threshold to update part if vehicle is inactive" , 0.0001 )\n                            schema:register(XMLValueType.FLOAT, partKey .. "#directionThresholdActive" , "Direction threshold to update part if vehicle is inactive" , 0.0001 )\n                                schema:register(XMLValueType.STRING, partKey .. "#maxUpdateDistance" , "Max.distance to vehicle root while isActiveDirty is set(\'-\' means unlimited)" )\n\n                                    schema:register(XMLValueType.BOOL, partKey .. "#smoothedDirectionScale" , "If moving part is deactivated e.g.due to folding limits the direction is slowly interpolated back to the start direction depending on #smoothedDirectionTime" , false )\n                                    schema:register(XMLValueType.TIME, partKey .. "#smoothedDirectionTime" , "Defines how low it takes until the part is back in original direction(sec.)" , 2 )\n\n                                    schema:register(XMLValueType.BOOL, partKey .. "#debug" , "Enables debug rendering for this part" , false )\n\n                                        schema:register(XMLValueType.NODE_INDEX, partKey .. ".dependentPart(?)#node" , "Dependent part" )\n                                        schema:register(XMLValueType.STRING, partKey .. ".dependentPart(?)#maxUpdateDistance" , "Max.distance to vehicle root to update dependent part(\'-\' means unlimited)" , "-" )\n\n                                        schema:register(XMLValueType.BOOL, partKey .. "#divideTranslatingDistance" , "If true all translating parts will move at the same time.If false they start to move in the order from the xml" , true )\n\n                                        schema:register(XMLValueType.NODE_INDEX, partKey .. ".translatingPart(?)#node" , "Translating part" )\n                                        schema:register(XMLValueType.FLOAT, partKey .. ".translatingPart(?)#referenceDistance" , "Reference distance" )\n                                        schema:register(XMLValueType.FLOAT, partKey .. ".translatingPart(?)#minZTrans" , "Min.Z Translation" )\n                                        schema:register(XMLValueType.FLOAT, partKey .. ".translatingPart(?)#maxZTrans" , "Max.Z Translation" )\n                                        schema:register(XMLValueType.BOOL, partKey .. ".translatingPart(?)#divideTranslatingDistance" , "Define individual division per translating part.E.g.one part is extending without division and two other parts extend afterwards at the same speed." , "movingPart#divideTranslatingDistance" )\n\n                                        schema:register(XMLValueType.VECTOR_N, partKey .. "#wheelIndices" , "List of wheel indices to update" )\n                                        schema:register(XMLValueType.STRING, partKey .. "#wheelNodes" , "List of wheel nodes to update" )\n                                        schema:register(XMLValueType.BOOL, partKey .. ".inputAttacherJoint#value" , "Update input attacher joint" )\n                                        schema:register(XMLValueType.VECTOR_N, partKey .. ".attacherJoint#jointIndices" , "List of attacher joints to update" )\n                                        schema:register(XMLValueType.BOOL, partKey .. ".attacherJoint#ignoreWarning" , "No warning is printed if the joint index is not available(due to configurations)" , false )\n\n                                            Cylindered.registerDependentComponentJointXMLPaths(schema, partKey)\n                                            Cylindered.registerCopyLocalDirectionXMLPaths(schema, partKey)\n                                            Cylindered.registerDependentAnimationXMLPaths(schema, partKey)\n                                            Cylindered.registerDependentMovingToolXMLPaths(schema, partKey)\n                                        end\n\n'})}),"\n",(0,o.jsx)(e.h3,{id:"registermovingtoolxmlpaths",children:"registerMovingToolXMLPaths"}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Description"})}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Definition"})}),"\n",(0,o.jsxs)(e.blockquote,{children:["\n",(0,o.jsx)(e.p,{children:"registerMovingToolXMLPaths()"}),"\n"]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,o.jsxs)(e.table,{children:[(0,o.jsx)(e.thead,{children:(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.th,{children:"any"}),(0,o.jsx)(e.th,{children:"schema"})]})}),(0,o.jsx)(e.tbody,{children:(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.td,{children:"any"}),(0,o.jsx)(e.td,{children:"toolKey"})]})})]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Code"})}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-lua",children:'function Cylindered.registerMovingToolXMLPaths(schema, toolKey)\n    schema:addDelayedRegistrationPath(toolKey, "Cylindered:movingTool" )\n\n    schema:register(XMLValueType.NODE_INDEX, toolKey .. "#node" , "Node" )\n    schema:register(XMLValueType.BOOL, toolKey .. "#isEasyControlTarget" , "Is easy control target" , false )\n\n    schema:register(XMLValueType.ANGLE, toolKey .. ".rotation#rotSpeed" , "Rotation speed" )\n    schema:register(XMLValueType.ANGLE, toolKey .. ".rotation#rotAcceleration" , "Rotation acceleration" )\n    schema:register(XMLValueType.INT, toolKey .. ".rotation#rotationAxis" , "Rotation axis" , 1 )\n    schema:register(XMLValueType.ANGLE, toolKey .. ".rotation#rotMax" , "Max.rotation" )\n    schema:register(XMLValueType.ANGLE, toolKey .. ".rotation#rotMin" , "Min.rotation" )\n    schema:register(XMLValueType.ANGLE, toolKey .. ".rotation#startRot" , "Start rotation" )\n    schema:register(XMLValueType.BOOL, toolKey .. ".rotation#syncMaxRotLimits" , "Synchronize max.rotation limits" , false )\n    schema:register(XMLValueType.BOOL, toolKey .. ".rotation#syncMinRotLimits" , "Synchronize min.rotation limits" , false )\n    schema:register(XMLValueType.INT, toolKey .. ".rotation#rotSendNumBits" , "Number of bits to synchronize" , "automatically calculated by rotation range" )\n    schema:register(XMLValueType.ANGLE, toolKey .. ".rotation#attachRotMax" , "Max.rotation value set during attach" )\n    schema:register(XMLValueType.ANGLE, toolKey .. ".rotation#attachRotMin" , "Min.rotation value set during attach" )\n    schema:register(XMLValueType.ANGLE, toolKey .. ".rotation#detachingRotMaxLimit" , "Max.rotation to detach vehicle" )\n    schema:register(XMLValueType.ANGLE, toolKey .. ".rotation#detachingRotMinLimit" , "Min.rotation to detach vehicle" )\n\n    schema:register(XMLValueType.FLOAT, toolKey .. ".translation#transSpeed" , "Translation speed" )\n    schema:register(XMLValueType.FLOAT, toolKey .. ".translation#transAcceleration" , "Translation acceleration" )\n    schema:register(XMLValueType.INT, toolKey .. ".translation#translationAxis" , "Translation axis" )\n    schema:register(XMLValueType.FLOAT, toolKey .. ".translation#transMax" , "Max.translation" )\n    schema:register(XMLValueType.FLOAT, toolKey .. ".translation#transMin" , "Min.translation" )\n    schema:register(XMLValueType.FLOAT, toolKey .. ".translation#startTrans" , "Start translation" )\n    schema:register(XMLValueType.FLOAT, toolKey .. ".translation#attachTransMax" , "Max.translation value set during attach" )\n    schema:register(XMLValueType.FLOAT, toolKey .. ".translation#attachTransMin" , "Min.translation value set during attach" )\n    schema:register(XMLValueType.FLOAT, toolKey .. ".translation#detachingTransMaxLimit" , "Max.translation to detach vehicle" )\n    schema:register(XMLValueType.FLOAT, toolKey .. ".translation#detachingTransMinLimit" , "Min.translation to detach vehicle" )\n\n    schema:register(XMLValueType.STRING, toolKey .. "#requiredConfigurationName" , "Name of configuration that is required to use this moving tool" )\n    schema:register(XMLValueType.VECTOR_N, toolKey .. "#requiredConfigurationIndices" , "List of configuration indices that are required to use this moving tool" )\n\n    schema:register(XMLValueType.BOOL, toolKey .. "#playSound" , "Play sound" , false )\n\n    schema:register(XMLValueType.STRING, toolKey .. ".animation#animName" , "Animation name" )\n    schema:register(XMLValueType.FLOAT, toolKey .. ".animation#animSpeed" , "Animation speed" )\n    schema:register(XMLValueType.FLOAT, toolKey .. ".animation#animAcceleration" , "Animation acceleration" )\n    schema:register(XMLValueType.INT, toolKey .. ".animation#animSendNumBits" , "Number of bits to synchronize" , 8 )\n    schema:register(XMLValueType.FLOAT, toolKey .. ".animation#animMaxTime" , "Animation max.time" , 1 )\n    schema:register(XMLValueType.FLOAT, toolKey .. ".animation#animMinTime" , "Animation min.time" , 0 )\n    schema:register(XMLValueType.FLOAT, toolKey .. ".animation#animStartTime" , "Animation start time" )\n\n    schema:register(XMLValueType.STRING, toolKey .. ".controls#iconName" , "Icon identifier" )\n    schema:registerAutoCompletionDataSource(toolKey .. ".controls#iconName" , "$dataS/axisIcons.xml" , "axisIcons.icon#name" )\n    schema:register(XMLValueType.INT, toolKey .. ".controls#groupIndex" , "Control group index" , 0 )\n    schema:register(XMLValueType.STRING, toolKey .. ".controls#axis" , "Input action name" )\n    schema:register(XMLValueType.BOOL, toolKey .. ".controls#invertAxis" , "Invert input axis" , false )\n    schema:register(XMLValueType.FLOAT, toolKey .. ".controls#mouseSpeedFactor" , "Mouse speed factor" , 1 )\n    schema:register(XMLValueType.BOOL, toolKey .. "#allowSaving" , "Allow saving" , true )\n    schema:register(XMLValueType.FLOAT, toolKey .. "#aiActivePosition" , "Position of the moving tool(trans, rot, anim) while the AI is active [0-1].Position will then be enforced when the AI starts to work." )\n\n        schema:register(XMLValueType.BOOL, toolKey .. "#isIntitialDirty" , "Is initial dirty" , true )\n        schema:register(XMLValueType.NODE_INDEX, toolKey .. "#delayedNode" , "Delayed node" )\n        schema:register(XMLValueType.INT, toolKey .. "#delayedFrames" , "Delayed frames" , 3 )\n\n        schema:register(XMLValueType.BOOL, toolKey .. "#isConsumingPower" , "While tool is moving the power consumer is set active" , false )\n\n        schema:register(XMLValueType.NODE_INDEX, toolKey .. ".dependentPart(?)#node" , "Dependent part" )\n        schema:register(XMLValueType.STRING, toolKey .. ".dependentPart(?)#maxUpdateDistance" , "Max.distance to vehicle root to update dependent part(\'-\' means unlimited)" , "-" )\n\n        schema:register(XMLValueType.VECTOR_N, toolKey .. "#wheelIndices" , "List of wheel indices to update" )\n        schema:register(XMLValueType.STRING, toolKey .. "#wheelNodes" , "List of wheel nodes to update" )\n        schema:register(XMLValueType.BOOL, toolKey .. ".inputAttacherJoint#value" , "Update input attacher joint" )\n        schema:register(XMLValueType.VECTOR_N, toolKey .. ".attacherJoint#jointIndices" , "List of attacher joints to update" )\n        schema:register(XMLValueType.BOOL, toolKey .. ".attacherJoint#ignoreWarning" , "No warning is printed if the joint index is not available(due to configurations)" , false )\n\n            schema:register(XMLValueType.INT, toolKey .. "#fillUnitIndex" , "Fill unit index" )\n            schema:register(XMLValueType.FLOAT, toolKey .. "#minFillLevel" , "Min.fill level" )\n            schema:register(XMLValueType.FLOAT, toolKey .. "#maxFillLevel" , "Max.fill level" )\n\n            schema:register(XMLValueType.FLOAT, toolKey .. "#foldMinLimit" , "Min.fold time" , 0 )\n            schema:register(XMLValueType.FLOAT, toolKey .. "#foldMaxLimit" , "Max.fold time" , 1 )\n\n            Cylindered.registerDependentComponentJointXMLPaths(schema, toolKey)\n            Cylindered.registerDependentAnimationXMLPaths(schema, toolKey)\n            Cylindered.registerDependentMovingToolXMLPaths(schema, toolKey)\n        end\n\n'})}),"\n",(0,o.jsx)(e.h3,{id:"registeroverwrittenfunctions",children:"registerOverwrittenFunctions"}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Description"})}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Definition"})}),"\n",(0,o.jsxs)(e.blockquote,{children:["\n",(0,o.jsx)(e.p,{children:"registerOverwrittenFunctions()"}),"\n"]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,o.jsx)(e.table,{children:(0,o.jsx)(e.thead,{children:(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.th,{children:"any"}),(0,o.jsx)(e.th,{children:"vehicleType"})]})})}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Code"})}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-lua",children:'function Cylindered.registerOverwrittenFunctions(vehicleType)\n    SpecializationUtil.registerOverwrittenFunction(vehicleType, "isDetachAllowed" , Cylindered.isDetachAllowed)\n    SpecializationUtil.registerOverwrittenFunction(vehicleType, "loadObjectChangeValuesFromXML" , Cylindered.loadObjectChangeValuesFromXML)\n    SpecializationUtil.registerOverwrittenFunction(vehicleType, "setObjectChangeValues" , Cylindered.setObjectChangeValues)\n    SpecializationUtil.registerOverwrittenFunction(vehicleType, "loadDischargeNode" , Cylindered.loadDischargeNode)\n    SpecializationUtil.registerOverwrittenFunction(vehicleType, "getDischargeNodeEmptyFactor" , Cylindered.getDischargeNodeEmptyFactor)\n    SpecializationUtil.registerOverwrittenFunction(vehicleType, "loadShovelNode" , Cylindered.loadShovelNode)\n    SpecializationUtil.registerOverwrittenFunction(vehicleType, "getShovelNodeIsActive" , Cylindered.getShovelNodeIsActive)\n    SpecializationUtil.registerOverwrittenFunction(vehicleType, "loadDynamicMountGrabFromXML" , Cylindered.loadDynamicMountGrabFromXML)\n    SpecializationUtil.registerOverwrittenFunction(vehicleType, "getIsDynamicMountGrabOpened" , Cylindered.getIsDynamicMountGrabOpened)\n    SpecializationUtil.registerOverwrittenFunction(vehicleType, "setComponentJointFrame" , Cylindered.setComponentJointFrame)\n    SpecializationUtil.registerOverwrittenFunction(vehicleType, "getAdditionalSchemaText" , Cylindered.getAdditionalSchemaText)\n    SpecializationUtil.registerOverwrittenFunction(vehicleType, "getWearMultiplier" , Cylindered.getWearMultiplier)\n    SpecializationUtil.registerOverwrittenFunction(vehicleType, "getDoConsumePtoPower" , Cylindered.getDoConsumePtoPower)\n    SpecializationUtil.registerOverwrittenFunction(vehicleType, "getConsumingLoad" , Cylindered.getConsumingLoad)\nend\n\n'})}),"\n",(0,o.jsx)(e.h3,{id:"registersoundxmlpaths",children:"registerSoundXMLPaths"}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Description"})}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Definition"})}),"\n",(0,o.jsxs)(e.blockquote,{children:["\n",(0,o.jsx)(e.p,{children:"registerSoundXMLPaths()"}),"\n"]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,o.jsxs)(e.table,{children:[(0,o.jsx)(e.thead,{children:(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.th,{children:"any"}),(0,o.jsx)(e.th,{children:"schema"})]})}),(0,o.jsx)(e.tbody,{children:(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.td,{children:"any"}),(0,o.jsx)(e.td,{children:"baseKey"})]})})]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Code"})}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-lua",children:'function Cylindered.registerSoundXMLPaths(schema, baseKey)\n    SoundManager.registerSampleXMLPaths(schema, baseKey, "hydraulic" )\n\n    SoundManager.registerSampleXMLPaths(schema, baseKey, "actionSound(?)" )\n    schema:register(XMLValueType.STRING, baseKey .. ".actionSound(?)#actionNames" , "Target actions on given nodes" )\n    schema:register(XMLValueType.STRING, baseKey .. ".actionSound(?)#nodes" , "Nodes that can activate this sound on given action events" )\n    schema:register(XMLValueType.FLOAT, baseKey .. ".actionSound(?).pitch#dropOffFactor" , "Factor that is applied to pitch while drop off time is active" , 1 )\n        schema:register(XMLValueType.FLOAT, baseKey .. ".actionSound(?).pitch#dropOffTime" , "After this time the sound will be deactivated" , 0 )\n    end\n\n'})}),"\n",(0,o.jsx)(e.h3,{id:"resolvedependentpartdata",children:"resolveDependentPartData"}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Description"})}),"\n",(0,o.jsxs)(e.blockquote,{children:["\n",(0,o.jsx)(e.p,{children:"Resolve loaded dependent part data into real moving parts and tools"}),"\n"]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Definition"})}),"\n",(0,o.jsxs)(e.blockquote,{children:["\n",(0,o.jsx)(e.p,{children:"resolveDependentPartData(table dependentPartData, table referenceNodes)"}),"\n"]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,o.jsxs)(e.table,{children:[(0,o.jsx)(e.thead,{children:(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.th,{children:"table"}),(0,o.jsx)(e.th,{children:"dependentPartData"}),(0,o.jsx)(e.th,{children:"dependentPartData"})]})}),(0,o.jsx)(e.tbody,{children:(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.td,{children:"table"}),(0,o.jsx)(e.td,{children:"referenceNodes"}),(0,o.jsx)(e.td,{children:"referenceNodes"})]})})]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Code"})}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-lua",children:"function Cylindered:resolveDependentPartData(dependentPartData, referenceNodes)\n    for _, dependentPart in pairs(dependentPartData) do\n        if dependentPart.part = = nil then\n            if referenceNodes[dependentPart.node] ~ = nil then\n                for j = 1 , #referenceNodes[dependentPart.node] do\n                    local depPart = referenceNodes[dependentPart.node][j]\n                    if j = = 1 then\n                        dependentPart.part = depPart\n                        depPart.isDependentPart = true\n                    else\n                            table.insert(dependentPartData, {\n                            node = dependentPart.node,\n                            maxUpdateDistance = dependentPart.maxUpdateDistance,\n                            part = depPart,\n                            } )\n\n                            depPart.isDependentPart = true\n                        end\n                    end\n                end\n            end\n        end\n\n        for j = #dependentPartData, 1 , - 1 do\n            local data = dependentPartData[j]\n            if data.part = = nil then\n                table.remove(dependentPartData, j)\n            end\n        end\n    end\n\n"})}),"\n",(0,o.jsx)(e.h3,{id:"savetoxmlfile",children:"saveToXMLFile"}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Description"})}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Definition"})}),"\n",(0,o.jsxs)(e.blockquote,{children:["\n",(0,o.jsx)(e.p,{children:"saveToXMLFile()"}),"\n"]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,o.jsxs)(e.table,{children:[(0,o.jsx)(e.thead,{children:(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.th,{children:"any"}),(0,o.jsx)(e.th,{children:"xmlFile"})]})}),(0,o.jsxs)(e.tbody,{children:[(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.td,{children:"any"}),(0,o.jsx)(e.td,{children:"key"})]}),(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.td,{children:"any"}),(0,o.jsx)(e.td,{children:"usedModNames"})]})]})]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Code"})}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-lua",children:'function Cylindered:saveToXMLFile(xmlFile, key, usedModNames)\n    local spec = self.spec_cylindered\n\n    local index = 0\n    for _, tool in ipairs(spec.movingTools) do\n        if tool.saving then\n            local toolKey = string.format( "%s.movingTool(%d)" , key, index)\n\n            if tool.transSpeed ~ = nil then\n                xmlFile:setValue(toolKey .. "#translation" , tool.curTrans[tool.translationAxis])\n            end\n            if tool.rotSpeed ~ = nil then\n                xmlFile:setValue(toolKey .. "#rotation" , tool.curRot[tool.rotationAxis])\n            end\n            if tool.animSpeed ~ = nil then\n                xmlFile:setValue(toolKey .. "#animationTime" , tool.curAnimTime)\n            end\n\n            index = index + 1\n        end\n    end\nend\n\n'})}),"\n",(0,o.jsx)(e.h3,{id:"setabsolutetoolrotation",children:"setAbsoluteToolRotation"}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Description"})}),"\n",(0,o.jsxs)(e.blockquote,{children:["\n",(0,o.jsx)(e.p,{children:"Set absolute tool rotation"}),"\n"]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Definition"})}),"\n",(0,o.jsxs)(e.blockquote,{children:["\n",(0,o.jsx)(e.p,{children:"setAbsoluteToolRotation(table tool, float rotation, boolean updateDelayedNodes, )"}),"\n"]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,o.jsxs)(e.table,{children:[(0,o.jsx)(e.thead,{children:(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.th,{children:"table"}),(0,o.jsx)(e.th,{children:"tool"}),(0,o.jsx)(e.th,{children:"tool"})]})}),(0,o.jsxs)(e.tbody,{children:[(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.td,{children:"float"}),(0,o.jsx)(e.td,{children:"rotation"}),(0,o.jsx)(e.td,{children:"rotation"})]}),(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.td,{children:"boolean"}),(0,o.jsx)(e.td,{children:"updateDelayedNodes"}),(0,o.jsx)(e.td,{children:"update delayed nodes"})]}),(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.td,{children:"any"}),(0,o.jsx)(e.td,{children:"updateDelayedNodes"}),(0,o.jsx)(e.td,{})]})]})]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Code"})}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-lua",children:"function Cylindered.setAbsoluteToolRotation( self , tool, rotation, updateDelayedNodes)\n    tool.curRot[ 1 ], tool.curRot[ 2 ], tool.curRot[ 3 ] = getRotation(tool.node)\n    local oldRot = tool.curRot[tool.rotationAxis]\n    if Cylindered.setToolRotation( self , tool, nil , 0 , rotation - oldRot) then\n        Cylindered.setDirty( self , tool)\n\n        if updateDelayedNodes ~ = nil and updateDelayedNodes then\n            self:updateDelayedTool(tool)\n        end\n\n        self:raiseDirtyFlags(tool.dirtyFlag)\n        self:raiseDirtyFlags( self.spec_cylindered.cylinderedDirtyFlag)\n    end\nend\n\n"})}),"\n",(0,o.jsx)(e.h3,{id:"setabsolutetooltranslation",children:"setAbsoluteToolTranslation"}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Description"})}),"\n",(0,o.jsxs)(e.blockquote,{children:["\n",(0,o.jsx)(e.p,{children:"Set absolute tool translation"}),"\n"]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Definition"})}),"\n",(0,o.jsxs)(e.blockquote,{children:["\n",(0,o.jsx)(e.p,{children:"setAbsoluteToolTranslation(table tool, float translation, )"}),"\n"]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,o.jsxs)(e.table,{children:[(0,o.jsx)(e.thead,{children:(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.th,{children:"table"}),(0,o.jsx)(e.th,{children:"tool"}),(0,o.jsx)(e.th,{children:"tool"})]})}),(0,o.jsxs)(e.tbody,{children:[(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.td,{children:"float"}),(0,o.jsx)(e.td,{children:"translation"}),(0,o.jsx)(e.td,{children:"translation"})]}),(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.td,{children:"any"}),(0,o.jsx)(e.td,{children:"translation"}),(0,o.jsx)(e.td,{})]})]})]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Code"})}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-lua",children:"function Cylindered.setAbsoluteToolTranslation( self , tool, translation)\n    tool.curTrans[ 1 ], tool.curTrans[ 2 ], tool.curTrans[ 3 ] = getTranslation(tool.node)\n    local oldTrans = tool.curTrans[tool.translationAxis]\n    if Cylindered.setToolTranslation( self , tool, nil , 0 , translation - oldTrans) then\n        Cylindered.setDirty( self , tool)\n\n        self:raiseDirtyFlags(tool.dirtyFlag)\n        self:raiseDirtyFlags( self.spec_cylindered.cylinderedDirtyFlag)\n    end\nend\n\n"})}),"\n",(0,o.jsx)(e.h3,{id:"setcomponentjointframe",children:"setComponentJointFrame"}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Description"})}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Definition"})}),"\n",(0,o.jsxs)(e.blockquote,{children:["\n",(0,o.jsx)(e.p,{children:"setComponentJointFrame()"}),"\n"]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,o.jsxs)(e.table,{children:[(0,o.jsx)(e.thead,{children:(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.th,{children:"any"}),(0,o.jsx)(e.th,{children:"superFunc"})]})}),(0,o.jsxs)(e.tbody,{children:[(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.td,{children:"any"}),(0,o.jsx)(e.td,{children:"jointDesc"})]}),(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.td,{children:"any"}),(0,o.jsx)(e.td,{children:"anchorActor"})]})]})]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Code"})}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-lua",children:"function Cylindered:setComponentJointFrame(superFunc, jointDesc, anchorActor)\n    superFunc( self , jointDesc, anchorActor)\n\n    -- update the joint to component offset\n    local spec = self.spec_cylindered\n    for _, movingTool in ipairs(spec.movingTools) do\n        for _, componentJoint in ipairs(movingTool.componentJoints) do\n            local componentJointDesc = self.componentJoints[componentJoint.index]\n\n            local jointNode = componentJointDesc.jointNode\n            if componentJoint.anchorActor = = 1 then\n                jointNode = componentJointDesc.jointNodeActor1\n            end\n\n            local node = self.components[componentJointDesc.componentIndices[ 2 ]].node\n            componentJoint.x, componentJoint.y, componentJoint.z = localToLocal(node, jointNode, 0 , 0 , 0 )\n            componentJoint.upX, componentJoint.upY, componentJoint.upZ = localDirectionToLocal(node, jointNode, 0 , 1 , 0 )\n            componentJoint.dirX, componentJoint.dirY, componentJoint.dirZ = localDirectionToLocal(node, jointNode, 0 , 0 , 1 )\n        end\n    end\nend\n\n"})}),"\n",(0,o.jsx)(e.h3,{id:"setdelayeddata",children:"setDelayedData"}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Description"})}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Definition"})}),"\n",(0,o.jsxs)(e.blockquote,{children:["\n",(0,o.jsx)(e.p,{children:"setDelayedData()"}),"\n"]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,o.jsxs)(e.table,{children:[(0,o.jsx)(e.thead,{children:(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.th,{children:"any"}),(0,o.jsx)(e.th,{children:"tool"})]})}),(0,o.jsx)(e.tbody,{children:(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.td,{children:"any"}),(0,o.jsx)(e.td,{children:"immediate"})]})})]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Code"})}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-lua",children:"function Cylindered:setDelayedData(tool, immediate)\n    local x, y, z = getTranslation(tool.node)\n    local rx, ry, rz = getRotation(tool.node)\n\n    tool.delayedHistroyData[tool.delayedFrames] = { rot = { rx, ry, rz } , trans = { x, y, z } }\n    if immediate then\n        for i = 1 , tool.delayedFrames - 1 do\n            tool.delayedHistroyData[i] = tool.delayedHistroyData[tool.delayedFrames]\n        end\n    end\n\n    tool.delayedHistoryIndex = tool.delayedFrames\nend\n\n"})}),"\n",(0,o.jsx)(e.h3,{id:"setdirty",children:"setDirty"}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Description"})}),"\n",(0,o.jsxs)(e.blockquote,{children:["\n",(0,o.jsx)(e.p,{children:"Set dirty"}),"\n"]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Definition"})}),"\n",(0,o.jsxs)(e.blockquote,{children:["\n",(0,o.jsx)(e.p,{children:"setDirty(table part, )"}),"\n"]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,o.jsxs)(e.table,{children:[(0,o.jsx)(e.thead,{children:(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.th,{children:"table"}),(0,o.jsx)(e.th,{children:"part"}),(0,o.jsx)(e.th,{children:"part to set dirty"})]})}),(0,o.jsx)(e.tbody,{children:(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.td,{children:"any"}),(0,o.jsx)(e.td,{children:"part"}),(0,o.jsx)(e.td,{})]})})]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Code"})}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-lua",children:"function Cylindered.setDirty( self , part)\n    if not part.isDirty or self.spec_cylindered.isLoading then -- during loading we always allow setting dirty since we do not reset it\n        part.isDirty = true\n        self.anyMovingPartsDirty = true\n\n        if part.delayedNode ~ = nil then\n            self:setDelayedData(part)\n        end\n\n        -- on moving tools we update the wheels and attacher joints on dirty since the are updated from external influences(e.g.animations)\n        -- on moving parts the part is updated first and then the wheels and attacher joints are updated\n        if part.isTool then\n            Cylindered.updateAttacherJoints( self , part)\n            Cylindered.updateWheels( self , part)\n        end\n\n        for _, data in pairs(part.dependentPartData) do\n            if self.currentUpdateDistance < data.maxUpdateDistance then\n                Cylindered.setDirty( self , data.part)\n            end\n        end\n    end\nend\n\n"})}),"\n",(0,o.jsx)(e.h3,{id:"seteasycontrolforcedtransmove",children:"setEasyControlForcedTransMove"}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Description"})}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Definition"})}),"\n",(0,o.jsxs)(e.blockquote,{children:["\n",(0,o.jsx)(e.p,{children:"setEasyControlForcedTransMove()"}),"\n"]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,o.jsx)(e.table,{children:(0,o.jsx)(e.thead,{children:(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.th,{children:"any"}),(0,o.jsx)(e.th,{children:"value"})]})})}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Code"})}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-lua",children:"function Cylindered:setEasyControlForcedTransMove(value)\n    local spec = self.spec_cylindered\n    local easyArmControl = spec.easyArmControl\n    if easyArmControl ~ = nil then\n        easyArmControl.forcedTransMove = value\n    end\nend\n\n"})}),"\n",(0,o.jsx)(e.h3,{id:"setiseasycontrolactive",children:"setIsEasyControlActive"}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Description"})}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Definition"})}),"\n",(0,o.jsxs)(e.blockquote,{children:["\n",(0,o.jsx)(e.p,{children:"setIsEasyControlActive()"}),"\n"]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,o.jsx)(e.table,{children:(0,o.jsx)(e.thead,{children:(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.th,{children:"any"}),(0,o.jsx)(e.th,{children:"state"})]})})}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Code"})}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-lua",children:"function Cylindered:setIsEasyControlActive(state)\n    local spec = self.spec_cylindered\n    local easyArmControl = spec.easyArmControl\n    if easyArmControl ~ = nil then\n        if self.isServer then\n            if easyArmControl ~ = nil then\n                local targetYTool = self:getMovingToolByNode(easyArmControl.targetNodeY)\n                local targetZTool = self:getMovingToolByNode(easyArmControl.targetNodeZ)\n\n                if state then\n                    local origin = getParent(easyArmControl.targetNodeY)\n                    if origin = = easyArmControl.targetNodeZ then\n                        origin = getParent(easyArmControl.targetNodeZ)\n                    end\n\n                    local _, y, _ = localToLocal(easyArmControl.targetRefNode, origin, 0 , 0 , 0 )\n                    local _, oldY, _ = getTranslation(easyArmControl.targetNodeY)\n                    if Cylindered.setToolTranslation( self , targetYTool, nil , 0 , y - oldY) then\n                        Cylindered.setDirty( self , targetYTool)\n                    end\n\n                    local z\n                    _, _, z = localToLocal(easyArmControl.targetRefNode, origin, 0 , 0 , 0 )\n                    local _, _, oldZ = getTranslation(easyArmControl.targetNodeZ)\n                    if Cylindered.setToolTranslation( self , targetZTool, nil , 0 , z - oldZ) then\n                        Cylindered.setDirty( self , targetZTool)\n                    end\n\n                    easyArmControl.lastValidPositionY[ 1 ], easyArmControl.lastValidPositionY[ 2 ], easyArmControl.lastValidPositionY[ 3 ] = getTranslation(easyArmControl.targetNodeY)\n                    easyArmControl.lastValidPositionZ[ 1 ], easyArmControl.lastValidPositionZ[ 2 ], easyArmControl.lastValidPositionZ[ 3 ] = getTranslation(easyArmControl.targetNodeZ)\n\n                    self:raiseDirtyFlags(spec.cylinderedDirtyFlag)\n                end\n\n                easyArmControl.state = state\n            end\n        else\n                easyArmControl.state = state\n            end\n        end\n\n        self:requestActionEventUpdate()\n    end\n\n"})}),"\n",(0,o.jsx)(e.h3,{id:"setmovingpartreferencenode",children:"setMovingPartReferenceNode"}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Description"})}),"\n",(0,o.jsxs)(e.blockquote,{children:["\n",(0,o.jsx)(e.p,{children:"Sets the reference point of a moving part to a defined node (if no reference node is given, it will be set to the\nvalue loaded from XML)"}),"\n"]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Definition"})}),"\n",(0,o.jsxs)(e.blockquote,{children:["\n",(0,o.jsx)(e.p,{children:"setMovingPartReferenceNode(integer movingPartNode, integer referenceNode, )"}),"\n"]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,o.jsxs)(e.table,{children:[(0,o.jsx)(e.thead,{children:(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.th,{children:"integer"}),(0,o.jsx)(e.th,{children:"movingPartNode"}),(0,o.jsx)(e.th,{children:"node of moving part"})]})}),(0,o.jsxs)(e.tbody,{children:[(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.td,{children:"integer"}),(0,o.jsx)(e.td,{children:"referenceNode"}),(0,o.jsx)(e.td,{children:"node of reference point"})]}),(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.td,{children:"any"}),(0,o.jsx)(e.td,{children:"isActiveDirty"}),(0,o.jsx)(e.td,{})]})]})]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Code"})}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-lua",children:"function Cylindered:setMovingPartReferenceNode(movingPartNode, referenceNode, isActiveDirty)\n    local spec = self.spec_cylindered\n\n    local movingPart = self:getMovingPartByNode(movingPartNode)\n    if movingPart ~ = nil then\n        if movingPart.referencePointOrig = = nil then\n            movingPart.referencePointOrig = movingPart.referencePoint\n        end\n\n        if referenceNode ~ = movingPart.referencePoint and movingPart.smoothedDirectionScale then\n            movingPart.smoothedDirectionScaleAlpha = 0\n\n            local dx, dy, dz = localDirectionToLocal(movingPart.node, getParent(movingPart.node), 0 , 0 , 1 )\n            movingPart.initialDirection[ 1 ], movingPart.initialDirection[ 2 ], movingPart.initialDirection[ 3 ] = dx, dy, dz\n\n            if movingPart.hasReferencePoints then\n                if movingPart.numTranslatingParts > 0 then\n                    local refX, refY, refZ = getWorldTranslation(movingPart.referencePoint)\n\n                    local _\n                    _, _, movingPart.smoothedDirectionScaleZOffset = worldToLocal(movingPart.node, refX, refY, refZ)\n                end\n            end\n\n            if not movingPart.isActiveDirty then\n                table.addElement(spec.activeDirtyMovingParts, movingPart)\n                movingPart.smoothedDirectionScaleTempDirty = true\n            end\n        end\n\n        if referenceNode = = nil then\n            movingPart.referencePoint = movingPart.referencePointOrig\n        else\n                movingPart.referencePoint = referenceNode\n            end\n\n            if isActiveDirty ~ = nil and not movingPart.smoothedDirectionScaleTempDirty then\n                if isActiveDirty then\n                    table.addElement(spec.activeDirtyMovingParts, movingPart)\n                else\n                        if not movingPart.isActiveDirty then\n                            table.removeElement(spec.activeDirtyMovingParts, movingPart)\n                        end\n                    end\n                end\n\n                Cylindered.updateMovingPart( self , movingPart, false , true , true )\n                self:updateExtraDependentParts(movingPart, 99999 )\n                self:updateDependentAnimations(movingPart, 99999 )\n\n                -- if any dependent parts use the same reference point in the xml, we update it as well\n                    for _, data in pairs(movingPart.dependentPartData) do\n                        if (data.part.referencePointOrig or data.part.referencePoint) = = movingPart.referencePointOrig then\n                            self:setMovingPartReferenceNode(data.part.node, referenceNode, isActiveDirty)\n                        end\n                    end\n                end\n            end\n\n"})}),"\n",(0,o.jsx)(e.h3,{id:"setmovingtooldirty",children:"setMovingToolDirty"}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Description"})}),"\n",(0,o.jsxs)(e.blockquote,{children:["\n",(0,o.jsx)(e.p,{children:"Set moving tool dirty"}),"\n"]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Definition"})}),"\n",(0,o.jsxs)(e.blockquote,{children:["\n",(0,o.jsx)(e.p,{children:"setMovingToolDirty(integer node, boolean forceUpdate, float dt)"}),"\n"]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,o.jsxs)(e.table,{children:[(0,o.jsx)(e.thead,{children:(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.th,{children:"integer"}),(0,o.jsx)(e.th,{children:"node"}),(0,o.jsx)(e.th,{children:"node id"})]})}),(0,o.jsxs)(e.tbody,{children:[(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.td,{children:"boolean"}),(0,o.jsx)(e.td,{children:"forceUpdate"}),(0,o.jsx)(e.td,{children:"force immediate update of moving tool and dependent parts"})]}),(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.td,{children:"float"}),(0,o.jsx)(e.td,{children:"dt"}),(0,o.jsx)(e.td,{children:"time since last call (only if forceUpdate is set)"})]})]})]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Code"})}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-lua",children:"function Cylindered:setMovingToolDirty(node, forceUpdate, dt)\n    local spec = self.spec_cylindered\n\n    local tool = spec.nodesToMovingTools[node]\n    if tool ~ = nil then\n        -- update curTrans and curRot values + moving tool action sounds\n        if tool.transSpeed ~ = nil then\n            local oldTrans = tool.curTrans[tool.translationAxis]\n            tool.curTrans[ 1 ], tool.curTrans[ 2 ], tool.curTrans[ 3 ] = getTranslation(tool.node)\n            local newTrans = tool.curTrans[tool.translationAxis]\n\n            local diff = newTrans - oldTrans\n            if math.abs(diff) > 0.0001 then\n                self:updateMovingToolSoundEvents(tool, diff > 0 , math.abs(newTrans - (tool.transMax or math.huge)) < 0.0001 or math.abs(newTrans - (tool.transMin or math.huge)) < 0.0001 , math.abs(oldTrans - (tool.transMax or math.huge)) < 0.0001 or math.abs(oldTrans - (tool.transMin or math.huge)) < 0.0001 )\n            end\n        end\n\n        if tool.rotSpeed ~ = nil then\n            local oldRot = tool.curRot[tool.rotationAxis]\n            tool.curRot[ 1 ], tool.curRot[ 2 ], tool.curRot[ 3 ] = getRotation(tool.node)\n            local newRot = tool.curRot[tool.rotationAxis]\n\n            local diff = newRot - oldRot\n            if math.abs(diff) > 0.0001 then\n                self:updateMovingToolSoundEvents(tool, diff > 0 , math.abs(newRot - (tool.rotMax or math.huge)) < 0.0001 or math.abs(newRot - (tool.rotMin or math.huge)) < 0.0001 , math.abs(oldRot - (tool.rotMax or math.huge)) < 0.0001 or math.abs(oldRot - (tool.rotMin or math.huge)) < 0.0001 )\n            end\n        end\n\n        Cylindered.setDirty( self , tool)\n\n        if not self.isServer and self.isClient then\n            tool.networkInterpolators.translation:setValue(tool.curTrans[tool.translationAxis])\n            tool.networkInterpolators.rotation:setAngle(tool.curRot[tool.rotationAxis])\n        end\n\n        if forceUpdate or( self.finishedFirstUpdate and not self.isActive) then\n            self:updateDirtyMovingParts(dt or g_currentDt, true )\n        end\n    end\nend\n\n"})}),"\n",(0,o.jsx)(e.h3,{id:"setobjectchangevalues",children:"setObjectChangeValues"}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Description"})}),"\n",(0,o.jsxs)(e.blockquote,{children:["\n",(0,o.jsx)(e.p,{children:"Sets object change values"}),"\n"]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Definition"})}),"\n",(0,o.jsxs)(e.blockquote,{children:["\n",(0,o.jsx)(e.p,{children:"setObjectChangeValues(table object, boolean isActive, )"}),"\n"]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,o.jsxs)(e.table,{children:[(0,o.jsx)(e.thead,{children:(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.th,{children:"table"}),(0,o.jsx)(e.th,{children:"object"}),(0,o.jsx)(e.th,{children:"object"})]})}),(0,o.jsxs)(e.tbody,{children:[(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.td,{children:"boolean"}),(0,o.jsx)(e.td,{children:"isActive"}),(0,o.jsx)(e.td,{children:"is active"})]}),(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.td,{children:"any"}),(0,o.jsx)(e.td,{children:"isActive"}),(0,o.jsx)(e.td,{})]})]})]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Code"})}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-lua",children:"function Cylindered:setObjectChangeValues(superFunc, object, isActive)\n    superFunc( self , object, isActive)\n\n    local spec = self.spec_cylindered\n\n    if spec.nodesToMovingTools ~ = nil and spec.nodesToMovingTools[object.node] ~ = nil then\n        local movingTool = spec.nodesToMovingTools[object.node]\n        if isActive then\n            movingTool.rotMax = object.movingToolRotMaxActive\n            movingTool.rotMin = object.movingToolRotMinActive\n            movingTool.transMax = object.movingToolTransMaxActive\n            movingTool.transMin = object.movingToolTransMinActive\n\n            movingTool.startRot = object.movingToolStartRotActive or movingTool.startRot\n            movingTool.startTrans = object.movingToolStartTransActive or movingTool.startTrans\n        else\n                movingTool.rotMax = object.movingToolRotMaxInactive\n                movingTool.rotMin = object.movingToolRotMinInactive\n                movingTool.transMax = object.movingToolTransMaxInactive\n                movingTool.transMin = object.movingToolTransMinInactive\n\n                movingTool.startRot = object.movingToolStartRotInactive or movingTool.startRot\n                movingTool.startTrans = object.movingToolStartTransInactive or movingTool.startTrans\n            end\n        end\n    end\n\n"})}),"\n",(0,o.jsx)(e.h3,{id:"settoolanimation",children:"setToolAnimation"}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Description"})}),"\n",(0,o.jsxs)(e.blockquote,{children:["\n",(0,o.jsx)(e.p,{children:"Set tool animation"}),"\n"]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Definition"})}),"\n",(0,o.jsxs)(e.blockquote,{children:["\n",(0,o.jsx)(e.p,{children:"setToolAnimation(table tool, float animSpeed, float dt, )"}),"\n"]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,o.jsxs)(e.table,{children:[(0,o.jsx)(e.thead,{children:(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.th,{children:"table"}),(0,o.jsx)(e.th,{children:"tool"}),(0,o.jsx)(e.th,{children:"tool"})]})}),(0,o.jsxs)(e.tbody,{children:[(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.td,{children:"float"}),(0,o.jsx)(e.td,{children:"animSpeed"}),(0,o.jsx)(e.td,{children:"animation speed"})]}),(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.td,{children:"float"}),(0,o.jsx)(e.td,{children:"dt"}),(0,o.jsx)(e.td,{children:"time since last call in ms"})]}),(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.td,{children:"any"}),(0,o.jsx)(e.td,{children:"dt"}),(0,o.jsx)(e.td,{})]})]})]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Return Values"})}),"\n\n\n\n\n\n\n\n\n",(0,o.jsx)(e.table,{children:(0,o.jsx)(e.thead,{children:(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.th,{children:"any"}),(0,o.jsx)(e.th,{children:"changed"}),(0,o.jsx)(e.th,{children:"animation changed"})]})})}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Code"})}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-lua",children:'function Cylindered.setToolAnimation( self , tool, animSpeed, dt)\n    local curAnimTime = self:getAnimationTime(tool.animName)\n    if math.abs(curAnimTime - tool.curAnimTime) > 0.001 then\n        tool.networkInterpolators.resetAnimInterpolation = true\n    end\n\n    tool.curAnimTime = curAnimTime\n\n    local newAnimTime = tool.curAnimTime + animSpeed * dt\n    local oldAnimTime = tool.curAnimTime\n\n    if tool.animMaxTime ~ = nil then\n        newAnimTime = math.min(newAnimTime, tool.animMaxTime)\n    end\n    if tool.animMinTime ~ = nil then\n        newAnimTime = math.max(newAnimTime, tool.animMinTime)\n    end\n    local diff = newAnimTime - tool.curAnimTime\n    if dt ~ = 0 then\n        tool.lastAnimSpeed = diff / dt\n    end\n    if math.abs(diff) > 0.0001 then\n        tool.curAnimTime = newAnimTime\n        self:setAnimationTime(tool.animName, newAnimTime, nil , true )\n\n        self:updateMovingToolSoundEvents(tool, diff > 0 , newAnimTime = = tool.animMaxTime or newAnimTime = = tool.animMinTime or newAnimTime = = 0 or newAnimTime = = 1 , oldAnimTime = = tool.animMaxTime or oldAnimTime = = tool.animMinTime or oldAnimTime = = 0 or oldAnimTime = = 1 )\n\n        SpecializationUtil.raiseEvent( self , "onMovingToolChanged" , tool, animSpeed, dt)\n        return true\n    end\n\n    return false\nend\n\n'})}),"\n",(0,o.jsx)(e.h3,{id:"settoolrotation",children:"setToolRotation"}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Description"})}),"\n",(0,o.jsxs)(e.blockquote,{children:["\n",(0,o.jsx)(e.p,{children:"Set tool rotation"}),"\n"]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Definition"})}),"\n",(0,o.jsxs)(e.blockquote,{children:["\n",(0,o.jsx)(e.p,{children:"setToolRotation(table tool, float rotSpeed, float dt, float delta, )"}),"\n"]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,o.jsxs)(e.table,{children:[(0,o.jsx)(e.thead,{children:(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.th,{children:"table"}),(0,o.jsx)(e.th,{children:"tool"}),(0,o.jsx)(e.th,{children:"tool"})]})}),(0,o.jsxs)(e.tbody,{children:[(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.td,{children:"float"}),(0,o.jsx)(e.td,{children:"rotSpeed"}),(0,o.jsx)(e.td,{children:"rotation speed"})]}),(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.td,{children:"float"}),(0,o.jsx)(e.td,{children:"dt"}),(0,o.jsx)(e.td,{children:"time since last call in ms"})]}),(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.td,{children:"float"}),(0,o.jsx)(e.td,{children:"delta"}),(0,o.jsx)(e.td,{children:"delta rotation"})]}),(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.td,{children:"any"}),(0,o.jsx)(e.td,{children:"delta"}),(0,o.jsx)(e.td,{})]})]})]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Return Values"})}),"\n\n\n\n\n\n\n\n\n",(0,o.jsx)(e.table,{children:(0,o.jsx)(e.thead,{children:(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.th,{children:"any"}),(0,o.jsx)(e.th,{children:"changed"}),(0,o.jsx)(e.th,{children:"rotation changed"})]})})}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Code"})}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-lua",children:'function Cylindered.setToolRotation( self , tool, rotSpeed, dt, delta)\n    --#debug if VehicleDebug.cylinderedUpdateDebugState and self:getIsActiveForInput() then\n        --#debug DebugGizmo.renderAtNode(tool.node, "Tool: " .. getName(tool.node), true)\n        --#debug end\n\n        tool.curRot[ 1 ], tool.curRot[ 2 ], tool.curRot[ 3 ] = getRotation(tool.node)\n        local newRot = tool.curRot[tool.rotationAxis]\n        local oldRot = newRot\n        if rotSpeed ~ = nil then\n            newRot = newRot + rotSpeed * dt\n        else\n                newRot = newRot + delta\n            end\n            if tool.rotMax ~ = nil then\n                newRot = math.min(newRot, tool.rotMax)\n            end\n            if tool.rotMin ~ = nil then\n                newRot = math.max(newRot, tool.rotMin)\n            end\n            local diff = newRot - tool.curRot[tool.rotationAxis]\n            if rotSpeed ~ = nil then\n                if dt ~ = 0 then\n                    tool.lastRotSpeed = diff / dt\n                end\n            end\n\n            if math.abs(diff) > 0.0001 then\n                -- wrap if not limited\n                    if tool.rotMin = = nil and tool.rotMax = = nil then\n                        if newRot > 2 * math.pi then\n                            newRot = newRot - 2 * math.pi\n                        end\n                        if newRot < 0 then\n                            newRot = newRot + 2 * math.pi\n                        end\n                    end\n                    tool.curRot[tool.rotationAxis] = newRot\n                    setRotation(tool.node, tool.curRot[ 1 ], tool.curRot[ 2 ], tool.curRot[ 3 ])\n\n                    self:updateMovingToolSoundEvents(tool, diff > 0 , newRot = = tool.rotMax or newRot = = tool.rotMin, oldRot = = tool.rotMax or oldRot = = tool.rotMin)\n\n                    SpecializationUtil.raiseEvent( self , "onMovingToolChanged" , tool, rotSpeed, dt)\n\n                    return true\n                end\n\n                return false\n            end\n\n'})}),"\n",(0,o.jsx)(e.h3,{id:"settooltranslation",children:"setToolTranslation"}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Description"})}),"\n",(0,o.jsxs)(e.blockquote,{children:["\n",(0,o.jsx)(e.p,{children:"Set tool translation"}),"\n"]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Definition"})}),"\n",(0,o.jsxs)(e.blockquote,{children:["\n",(0,o.jsx)(e.p,{children:"setToolTranslation(table tool, float transSpeed, float dt, , )"}),"\n"]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,o.jsxs)(e.table,{children:[(0,o.jsx)(e.thead,{children:(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.th,{children:"table"}),(0,o.jsx)(e.th,{children:"tool"}),(0,o.jsx)(e.th,{children:"tool"})]})}),(0,o.jsxs)(e.tbody,{children:[(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.td,{children:"float"}),(0,o.jsx)(e.td,{children:"transSpeed"}),(0,o.jsx)(e.td,{children:"translation speed"})]}),(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.td,{children:"float"}),(0,o.jsx)(e.td,{children:"dt"}),(0,o.jsx)(e.td,{children:"time since last call in ms"})]}),(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.td,{children:"any"}),(0,o.jsx)(e.td,{children:"dt"}),(0,o.jsx)(e.td,{})]}),(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.td,{children:"any"}),(0,o.jsx)(e.td,{children:"delta"}),(0,o.jsx)(e.td,{})]})]})]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Return Values"})}),"\n\n\n\n\n\n\n\n\n",(0,o.jsx)(e.table,{children:(0,o.jsx)(e.thead,{children:(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.th,{children:"any"}),(0,o.jsx)(e.th,{children:"changed"}),(0,o.jsx)(e.th,{children:"translation changed"})]})})}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Code"})}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-lua",children:'function Cylindered.setToolTranslation( self , tool, transSpeed, dt, delta)\n    --#debug if VehicleDebug.cylinderedUpdateDebugState and self:getIsActiveForInput() then\n        --#debug DebugGizmo.renderAtNode(tool.node, "Tool: " .. getName(tool.node), true)\n        --#debug end\n\n        tool.curTrans[ 1 ], tool.curTrans[ 2 ], tool.curTrans[ 3 ] = getTranslation(tool.node)\n        local newTrans = tool.curTrans[tool.translationAxis]\n        local oldTrans = newTrans\n        if transSpeed ~ = nil then\n            newTrans = newTrans + transSpeed * dt\n        else\n                newTrans = newTrans + delta\n            end\n            if tool.transMax ~ = nil then\n                newTrans = math.min(newTrans, tool.transMax)\n            end\n            if tool.transMin ~ = nil then\n                newTrans = math.max(newTrans, tool.transMin)\n            end\n            local diff = newTrans - oldTrans\n            if dt ~ = 0 then\n                tool.lastTransSpeed = diff / dt\n            end\n            if math.abs(diff) > 0.0001 then\n                tool.curTrans[tool.translationAxis] = newTrans\n                setTranslation(tool.node, tool.curTrans[ 1 ], tool.curTrans[ 2 ], tool.curTrans[ 3 ])\n\n                self:updateMovingToolSoundEvents(tool, diff > 0 , newTrans = = tool.transMax or newTrans = = tool.transMin, oldTrans = = tool.transMax or oldTrans = = tool.transMin)\n\n                SpecializationUtil.raiseEvent( self , "onMovingToolChanged" , tool, transSpeed, dt)\n\n                return true\n            end\n\n            return false\n        end\n\n'})}),"\n",(0,o.jsx)(e.h3,{id:"updateattacherjoints",children:"updateAttacherJoints"}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Description"})}),"\n",(0,o.jsxs)(e.blockquote,{children:["\n",(0,o.jsx)(e.p,{children:"Update attacher joints"}),"\n"]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Definition"})}),"\n",(0,o.jsxs)(e.blockquote,{children:["\n",(0,o.jsx)(e.p,{children:"updateAttacherJoints(table entry, )"}),"\n"]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,o.jsxs)(e.table,{children:[(0,o.jsx)(e.thead,{children:(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.th,{children:"table"}),(0,o.jsx)(e.th,{children:"entry"}),(0,o.jsx)(e.th,{children:"entry"})]})}),(0,o.jsx)(e.tbody,{children:(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.td,{children:"any"}),(0,o.jsx)(e.td,{children:"entry"}),(0,o.jsx)(e.td,{})]})})]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Code"})}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-lua",children:"function Cylindered.updateAttacherJoints( self , entry)\n    if self.isServer then\n        if entry.attacherJoints ~ = nil then\n            for _,joint in ipairs(entry.attacherJoints) do\n                if joint.jointIndex ~ = 0 then\n                    setJointFrame(joint.jointIndex, 0 , joint.jointTransform)\n                end\n            end\n        end\n\n        if entry.inputAttacherJoint then\n            if self.getAttacherVehicle ~ = nil then\n                local attacherVehicle = self:getAttacherVehicle()\n                if attacherVehicle ~ = nil then\n\n                    local attacherJoints = attacherVehicle:getAttacherJoints()\n                    if attacherJoints ~ = nil then\n\n                        local jointDescIndex = attacherVehicle:getAttacherJointIndexFromObject( self )\n                        if jointDescIndex ~ = nil then\n                            local jointDesc = attacherJoints[jointDescIndex]\n\n                            local inputAttacherJoint = self:getActiveInputAttacherJoint()\n                            if inputAttacherJoint ~ = nil then\n                                local xNew = jointDesc.jointOrigTrans[ 1 ] + jointDesc.jointPositionOffset[ 1 ]\n                                local yNew = jointDesc.jointOrigTrans[ 2 ] + jointDesc.jointPositionOffset[ 2 ]\n                                local zNew = jointDesc.jointOrigTrans[ 3 ] + jointDesc.jointPositionOffset[ 3 ]\n\n                                -- transform offset position to world coord and to jointTransform coord to get position offset dependend on angle and position\n                                local ox, oy, oz = getTranslation(jointDesc.jointTransform)\n                                setTranslation(jointDesc.jointTransform, unpack(jointDesc.jointOrigTrans))\n                                local x, y, z = localToWorld(getParent(jointDesc.jointTransform), xNew, yNew, zNew)\n                                local x1, y1, z1 = worldToLocal(jointDesc.jointTransform, x, y, z)\n                                setTranslation(jointDesc.jointTransform, ox, oy, oz)\n\n                                -- transform it to implement position and angle\n                                x, y, z = localToWorld(inputAttacherJoint.node, x1, y1, z1)\n                                local x2, y2, z2 = worldToLocal(getParent(inputAttacherJoint.node), x, y, z)\n                                setTranslation(inputAttacherJoint.node, x2, y2, z2)\n\n                                setJointFrame(jointDesc.jointIndex, 1 , inputAttacherJoint.node)\n\n                                setTranslation(inputAttacherJoint.node, unpack(inputAttacherJoint.jointOrigTrans))\n                            end\n                        end\n                    end\n                end\n            end\n        end\n    end\nend\n\n"})}),"\n",(0,o.jsx)(e.h3,{id:"updatecomponentjoints",children:"updateComponentJoints"}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Description"})}),"\n",(0,o.jsxs)(e.blockquote,{children:["\n",(0,o.jsx)(e.p,{children:"Update component joints"}),"\n"]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Definition"})}),"\n",(0,o.jsxs)(e.blockquote,{children:["\n",(0,o.jsx)(e.p,{children:"updateComponentJoints(table entry, boolean placeComponents, )"}),"\n"]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,o.jsxs)(e.table,{children:[(0,o.jsx)(e.thead,{children:(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.th,{children:"table"}),(0,o.jsx)(e.th,{children:"entry"}),(0,o.jsx)(e.th,{children:"entry"})]})}),(0,o.jsxs)(e.tbody,{children:[(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.td,{children:"boolean"}),(0,o.jsx)(e.td,{children:"placeComponents"}),(0,o.jsx)(e.td,{children:"place components"})]}),(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.td,{children:"any"}),(0,o.jsx)(e.td,{children:"placeComponents"}),(0,o.jsx)(e.td,{})]})]})]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Code"})}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-lua",children:"function Cylindered.updateComponentJoints( self , entry, placeComponents)\n    if self.isServer then\n        if entry.componentJoints ~ = nil then\n            for _,joint in ipairs(entry.componentJoints) do\n                local componentJoint = joint.componentJoint\n\n                local jointNode = componentJoint.jointNode\n                if joint.anchorActor = = 1 then\n                    jointNode = componentJoint.jointNodeActor1\n                end\n\n                if placeComponents then\n                    local node = self.components[componentJoint.componentIndices[ 2 ]].node\n                    local x,y,z = localToWorld(jointNode, joint.x, joint.y, joint.z)\n                    local upX,upY,upZ = localDirectionToWorld(jointNode, joint.upX,joint.upY,joint.upZ)\n                    local dirX,dirY,dirZ = localDirectionToWorld(jointNode, joint.dirX,joint.dirY,joint.dirZ)\n                    setWorldTranslation(node, x,y,z)\n                    I3DUtil.setWorldDirection(node, dirX,dirY,dirZ, upX,upY,upZ)\n                end\n\n                self:setComponentJointFrame(componentJoint, joint.anchorActor)\n            end\n        end\n    end\nend\n\n"})}),"\n",(0,o.jsx)(e.h3,{id:"updatecontrolgroups",children:"updateControlGroups"}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Description"})}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Definition"})}),"\n",(0,o.jsxs)(e.blockquote,{children:["\n",(0,o.jsx)(e.p,{children:"updateControlGroups()"}),"\n"]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Code"})}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-lua",children:"function Cylindered:updateControlGroups()\n    local spec = self.spec_cylindered\n\n    self:clearSubselections()\n    for k, _ in pairs(spec.controlGroupMapping) do\n        spec.controlGroupMapping[k] = nil\n    end\n\n    for _, groupIndex in ipairs(spec.controlGroups) do\n        local isActive = false\n        for _, movingTool in pairs(spec.movingTools) do\n            if movingTool.axisActionIndex ~ = nil and movingTool.controlGroupIndex = = groupIndex then\n                if movingTool.lastIsActiveState then\n                    isActive = true\n                    break\n                end\n            end\n        end\n\n        if isActive then\n            local subSelectionIndex = self:addSubselection(groupIndex)\n            spec.controlGroupMapping[subSelectionIndex] = groupIndex\n        end\n    end\n\n    self.rootVehicle:updateSelectableObjects()\n    local vehicle = self.rootVehicle:getSelectedVehicle()\n    if vehicle = = self then\n        self.rootVehicle:setSelectedVehicle( self , 99999 , false )\n    end\nend\n\n"})}),"\n",(0,o.jsx)(e.h3,{id:"updatecylinderedinitial",children:"updateCylinderedInitial"}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Description"})}),"\n",(0,o.jsxs)(e.blockquote,{children:["\n",(0,o.jsx)(e.p,{children:"Initial update of cylindered"}),"\n"]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Definition"})}),"\n",(0,o.jsxs)(e.blockquote,{children:["\n",(0,o.jsx)(e.p,{children:"updateCylinderedInitial(boolean placeComponents, )"}),"\n"]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,o.jsxs)(e.table,{children:[(0,o.jsx)(e.thead,{children:(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.th,{children:"boolean"}),(0,o.jsx)(e.th,{children:"placeComponents"}),(0,o.jsx)(e.th,{children:"place components"})]})}),(0,o.jsx)(e.tbody,{children:(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.td,{children:"any"}),(0,o.jsx)(e.td,{children:"keepDirty"}),(0,o.jsx)(e.td,{})]})})]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Code"})}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-lua",children:"function Cylindered:updateCylinderedInitial(placeComponents, keepDirty)\n    if placeComponents = = nil then\n        placeComponents = true\n    end\n\n    if keepDirty = = nil then\n        keepDirty = false\n    end\n\n    local spec = self.spec_cylindered\n\n    for _, part in pairs(spec.activeDirtyMovingParts) do\n        Cylindered.setDirty( self , part)\n    end\n\n    for _, tool in ipairs(spec.movingTools) do\n        if tool.isDirty then\n            Cylindered.updateWheels( self , tool)\n            if self.isServer then\n                Cylindered.updateComponentJoints( self , tool, placeComponents)\n            end\n            tool.isDirty = false or keepDirty\n        end\n\n        self:updateExtraDependentParts(tool, 9999 )\n        self:updateDependentAnimations(tool, 9999 )\n    end\n\n    for _, part in ipairs(spec.movingParts) do\n        local isActive = self:getIsMovingPartActive(part)\n        if isActive or part.smoothedDirectionScale and part.smoothedDirectionScaleAlpha ~ = 0 then\n            if part.isDirty then\n                Cylindered.updateMovingPart( self , part, placeComponents, nil , isActive, false )\n                Cylindered.updateWheels( self , part)\n                part.isDirty = false or keepDirty\n            end\n\n            self:updateExtraDependentParts(part, 9999 )\n            self:updateDependentAnimations(part, 9999 )\n        end\n    end\nend\n\n"})}),"\n",(0,o.jsx)(e.h3,{id:"updatedelayedtool",children:"updateDelayedTool"}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Description"})}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Definition"})}),"\n",(0,o.jsxs)(e.blockquote,{children:["\n",(0,o.jsx)(e.p,{children:"updateDelayedTool()"}),"\n"]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,o.jsxs)(e.table,{children:[(0,o.jsx)(e.thead,{children:(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.th,{children:"any"}),(0,o.jsx)(e.th,{children:"tool"})]})}),(0,o.jsx)(e.tbody,{children:(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.td,{children:"any"}),(0,o.jsx)(e.td,{children:"forceLastPosition"})]})})]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Code"})}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-lua",children:'function Cylindered:updateDelayedTool(tool, forceLastPosition)\n    local spec = self.spec_cylindered\n\n    if forceLastPosition ~ = nil and forceLastPosition then\n        for i = 1 , tool.delayedFrames - 1 do\n            tool.delayedHistroyData[i] = tool.delayedHistroyData[tool.delayedFrames]\n        end\n    end\n\n    local currentData = tool.delayedHistroyData[ 1 ]\n    for i = 1 , tool.delayedFrames - 1 do\n        tool.delayedHistroyData[i] = tool.delayedHistroyData[i + 1 ]\n    end\n\n    setRotation(tool.delayedNode, unpack(currentData.rot))\n    setTranslation(tool.delayedNode, unpack(currentData.trans))\n\n    -- local r, _, _ = getRotation(tool.node)\n    -- log(string.format("%s: %.2f | %s: %.2f", getName(tool.node), math.deg(r), getName(tool.delayedNode), math.deg(currentData.rot[1])))\n\n    tool.delayedHistoryIndex = tool.delayedHistoryIndex - 1\n\n    local movingPart = spec.nodesToMovingParts[tool.delayedNode]\n    local movingTool = spec.nodesToMovingTools[tool.delayedNode]\n    if movingPart ~ = nil then\n        Cylindered.setDirty( self , movingPart)\n    end\n    if spec.nodesToMovingTools[tool.delayedNode] ~ = nil then\n        Cylindered.setDirty( self , movingTool)\n    end\nend\n\n'})}),"\n",(0,o.jsx)(e.h3,{id:"updatedependentanimations",children:"updateDependentAnimations"}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Description"})}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Definition"})}),"\n",(0,o.jsxs)(e.blockquote,{children:["\n",(0,o.jsx)(e.p,{children:"updateDependentAnimations()"}),"\n"]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,o.jsxs)(e.table,{children:[(0,o.jsx)(e.thead,{children:(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.th,{children:"any"}),(0,o.jsx)(e.th,{children:"part"})]})}),(0,o.jsx)(e.tbody,{children:(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.td,{children:"any"}),(0,o.jsx)(e.td,{children:"dt"})]})})]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Code"})}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-lua",children:"function Cylindered:updateDependentAnimations(part, dt)\n    if #part.dependentAnimations > 0 then\n        for _, dependentAnimation in ipairs(part.dependentAnimations) do\n            local pos = 0\n            if dependentAnimation.translationAxis ~ = nil then\n                local translationAxisValue = select(dependentAnimation.translationAxis, getTranslation(dependentAnimation.node))\n                pos = (translationAxisValue - dependentAnimation.minValue) / (dependentAnimation.maxValue - dependentAnimation.minValue)\n            end\n\n            if dependentAnimation.rotationAxis ~ = nil then\n                local rotationAxisValue = select(dependentAnimation.rotationAxis, getRotation(dependentAnimation.node))\n                pos = (rotationAxisValue - dependentAnimation.minValue) / (dependentAnimation.maxValue - dependentAnimation.minValue)\n            end\n\n            pos = math.clamp(pos, 0 , 1 )\n            if dependentAnimation.invert then\n                pos = 1 - pos\n            end\n            dependentAnimation.lastPos = pos\n\n            self:setAnimationTime(dependentAnimation.name, pos, true , true )\n        end\n    end\nend\n\n"})}),"\n",(0,o.jsx)(e.h3,{id:"updatedependenttoollimits",children:"updateDependentToolLimits"}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Description"})}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Definition"})}),"\n",(0,o.jsxs)(e.blockquote,{children:["\n",(0,o.jsx)(e.p,{children:"updateDependentToolLimits()"}),"\n"]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,o.jsxs)(e.table,{children:[(0,o.jsx)(e.thead,{children:(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.th,{children:"any"}),(0,o.jsx)(e.th,{children:"tool"})]})}),(0,o.jsx)(e.tbody,{children:(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.td,{children:"any"}),(0,o.jsx)(e.td,{children:"dependentTool"})]})})]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Code"})}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-lua",children:"function Cylindered:updateDependentToolLimits(tool, dependentTool)\n    if dependentTool.minTransLimits ~ = nil or dependentTool.maxTransLimits ~ = nil then\n        local state = Cylindered.getMovingToolState( self , tool)\n        if dependentTool.minTransLimits ~ = nil then\n            dependentTool.movingTool.transMin = MathUtil.lerp(dependentTool.minTransLimits[ 1 ], dependentTool.minTransLimits[ 2 ], 1 - state)\n        end\n        if dependentTool.maxTransLimits ~ = nil then\n            dependentTool.movingTool.transMax = MathUtil.lerp(dependentTool.maxTransLimits[ 1 ], dependentTool.maxTransLimits[ 2 ], 1 - state)\n        end\n        local transLimitChanged = Cylindered.setToolTranslation( self , dependentTool.movingTool, 0 , 0 )\n        if transLimitChanged then\n            Cylindered.setDirty( self , dependentTool.movingTool)\n        end\n    end\n\n    if dependentTool.minRotLimits ~ = nil or dependentTool.maxRotLimits ~ = nil then\n        local state = Cylindered.getMovingToolState( self , tool)\n        if dependentTool.minRotLimits ~ = nil then\n            dependentTool.movingTool.rotMin = MathUtil.lerp(dependentTool.minRotLimits[ 1 ], dependentTool.minRotLimits[ 2 ], 1 - state)\n        end\n        if dependentTool.maxRotLimits ~ = nil then\n            dependentTool.movingTool.rotMax = MathUtil.lerp(dependentTool.maxRotLimits[ 1 ], dependentTool.maxRotLimits[ 2 ], 1 - state)\n        end\n\n        dependentTool.movingTool.networkInterpolators.rotation:setMinMax(dependentTool.movingTool.rotMin, dependentTool.movingTool.rotMax)\n\n        local rotLimitChanged = Cylindered.setToolRotation( self , dependentTool.movingTool, 0 , 0 )\n        if rotLimitChanged then\n            Cylindered.setDirty( self , dependentTool.movingTool)\n        end\n    end\nend\n\n"})}),"\n",(0,o.jsx)(e.h3,{id:"updatedirtymovingparts",children:"updateDirtyMovingParts"}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Description"})}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Definition"})}),"\n",(0,o.jsxs)(e.blockquote,{children:["\n",(0,o.jsx)(e.p,{children:"updateDirtyMovingParts()"}),"\n"]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,o.jsxs)(e.table,{children:[(0,o.jsx)(e.thead,{children:(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.th,{children:"any"}),(0,o.jsx)(e.th,{children:"dt"})]})}),(0,o.jsx)(e.tbody,{children:(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.td,{children:"any"}),(0,o.jsx)(e.td,{children:"updateSound"})]})})]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Code"})}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-lua",children:"function Cylindered:updateDirtyMovingParts(dt, updateSound)\n    local spec = self.spec_cylindered\n\n    for i = 1 , #spec.movingTools do\n        local tool = spec.movingTools[i]\n        if tool.isDirty then\n            if tool.playSound then\n                spec.movingToolNeedsSound = true\n            end\n            Cylindered.updateWheels( self , tool)\n            if self.isServer then\n                -- update component joint\n                Cylindered.updateComponentJoints( self , tool, false )\n            end\n            self:updateExtraDependentParts(tool, dt)\n            self:updateDependentAnimations(tool, dt)\n            tool.isDirty = false\n        end\n    end\n\n    if self.anyMovingPartsDirty then\n        for i = 1 , #spec.movingParts do\n            local part = spec.movingParts[i]\n            if part.isDirty then\n                local isActive = self:getIsMovingPartActive(part)\n                if isActive or part.smoothedDirectionScale and part.smoothedDirectionScaleAlpha ~ = 0 then\n                    Cylindered.updateMovingPart( self , part, false , nil , isActive)\n                    self:updateExtraDependentParts(part, dt)\n                    self:updateDependentAnimations(part, dt)\n                    if part.playSound then\n                        spec.cylinderedHydraulicSoundPartNumber = i\n                        spec.movingPartNeedsSound = true\n                    end\n                end\n            else\n                    if spec.isClient and spec.cylinderedHydraulicSoundPartNumber = = i then\n                        spec.movingPartNeedsSound = false\n                    end\n                end\n            end\n            self.anyMovingPartsDirty = false\n        end\n\n        if updateSound then\n            if self.isClient then\n                if spec.movingToolNeedsSound or spec.movingPartNeedsSound then\n                    if not spec.isHydraulicSamplePlaying then\n                        g_soundManager:playSample(spec.samples.hydraulic)\n                        spec.isHydraulicSamplePlaying = true\n                    end\n                    self:raiseActive()\n                else\n                        if spec.isHydraulicSamplePlaying then\n                            g_soundManager:stopSample(spec.samples.hydraulic)\n                            spec.isHydraulicSamplePlaying = false\n                        end\n                    end\n                end\n            end\n        end\n\n"})}),"\n",(0,o.jsx)(e.h3,{id:"updateeasycontrol",children:"updateEasyControl"}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Description"})}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Definition"})}),"\n",(0,o.jsxs)(e.blockquote,{children:["\n",(0,o.jsx)(e.p,{children:"updateEasyControl()"}),"\n"]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,o.jsxs)(e.table,{children:[(0,o.jsx)(e.thead,{children:(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.th,{children:"any"}),(0,o.jsx)(e.th,{children:"dt"})]})}),(0,o.jsx)(e.tbody,{children:(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.td,{children:"any"}),(0,o.jsx)(e.td,{children:"updateDelayedNodes"})]})})]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Code"})}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-lua",children:'function Cylindered:updateEasyControl(dt, updateDelayedNodes)\n    local spec = self.spec_cylindered\n    local easyArmControl = spec.easyArmControl\n    if easyArmControl ~ = nil then\n        local targetYTool = self:getMovingToolByNode(easyArmControl.targetNodeY)\n        local targetZTool = self:getMovingToolByNode(easyArmControl.targetNodeZ)\n\n        local moveInputY = self:getMovingToolMoveValue(targetYTool)\n        local moveInputZ = self:getMovingToolMoveValue(targetZTool)\n\n        local hasChanged = false\n        if moveInputY ~ = 0 or moveInputZ ~ = 0 then\n            hasChanged = true\n\n            if (moveInputY ~ = 0 and targetYTool.isConsumingPower) or(moveInputZ ~ = 0 and targetZTool.isConsumingPower) then\n                spec.powerConsumingTimer = spec.powerConsumingActiveTimeOffset\n            end\n        end\n\n        if self.isServer and easyArmControl.state and hasChanged then\n            local transSpeedY = moveInputY * easyArmControl.moveSpeed\n            if easyArmControl.moveAcceleration ~ = nil and math.abs(transSpeedY - easyArmControl.lastSpeedY) > = easyArmControl.moveAcceleration * dt then\n                if transSpeedY > easyArmControl.lastSpeedY then\n                    transSpeedY = easyArmControl.lastSpeedY + easyArmControl.moveAcceleration * dt\n                else\n                        transSpeedY = easyArmControl.lastSpeedY - easyArmControl.moveAcceleration * dt\n                    end\n                end\n\n                local transSpeedZ = moveInputZ * easyArmControl.moveSpeed\n                if easyArmControl.moveAcceleration ~ = nil and math.abs(transSpeedZ - easyArmControl.lastSpeedZ) > = easyArmControl.moveAcceleration * dt then\n                    if transSpeedZ > easyArmControl.lastSpeedZ then\n                        transSpeedZ = easyArmControl.lastSpeedZ + easyArmControl.moveAcceleration * dt\n                    else\n                            transSpeedZ = easyArmControl.lastSpeedZ - easyArmControl.moveAcceleration * dt\n                        end\n                    end\n\n                    easyArmControl.lastSpeedY = transSpeedY\n                    local moveY = transSpeedY * dt\n\n                    easyArmControl.lastSpeedZ = transSpeedZ\n                    local moveZ = transSpeedZ * dt\n\n                    -- target world position\n                    local worldTargetDirX, worldTargetDirY, worldTargetDirZ = localDirectionToWorld(easyArmControl.rootNode, 0 , moveY, moveZ)\n                    local worldTargetX, worldTargetY, worldTargetZ = getWorldTranslation(easyArmControl.targetRefNode)\n                    worldTargetX, worldTargetY, worldTargetZ = worldTargetX + worldTargetDirX, worldTargetY + worldTargetDirY, worldTargetZ + worldTargetDirZ\n\n                    -- limit target position to max distance radius\n                    local locTargetX, locTargetY, locTargetZ = worldToLocal(easyArmControl.rootNode, worldTargetX, worldTargetY, worldTargetZ)\n                    local distanceToTarget = MathUtil.vector3Length(locTargetX, locTargetY, locTargetZ)\n\n                    local targetExceedFactor = easyArmControl.maxTotalDistance / distanceToTarget\n                    if targetExceedFactor < 1 then\n                        locTargetX, locTargetY, locTargetZ = locTargetX * targetExceedFactor, locTargetY * targetExceedFactor, locTargetZ * targetExceedFactor\n                        worldTargetX, worldTargetY, worldTargetZ = localToWorld(easyArmControl.rootNode, locTargetX, locTargetY, locTargetZ)\n\n                        distanceToTarget = easyArmControl.maxTotalDistance\n                    end\n\n                    -- distance from arm1 to arm2 and arm2 to end node\n                    local circleDistance1 = MathUtil.vector3Length(localToLocal(easyArmControl.xRotationNodes[ 2 ].node, easyArmControl.xRotationNodes[ 1 ].node, 0 , 0 , 0 ))\n                    local _, _, circleDistance2 = localToLocal(easyArmControl.targetRefNode, easyArmControl.xRotationNodes[ 2 ].node, 0 , 0 , 0 )\n\n                    -- circle center positions\n                    local circle1X, circle1Y, circle1Z = localToLocal(easyArmControl.xRotationNodes[ 1 ].node, easyArmControl.rootNode, 0 , 0 , 0 )\n                    local circle2X, circle2Y, circle2Z = worldToLocal(easyArmControl.rootNode, worldTargetX, worldTargetY, worldTargetZ)\n\n                    --#debug local c1xw, c1yw, c1zw = localToWorld(easyArmControl.rootNode, circle1X, circle1Y, circle1Z)\n                    --#debug DebugGizmo.renderAtPositionSimple(c1xw, c1yw, c1zw, "c1")\n                    --#debug local c2xw, c2yw, c2zw = localToWorld(easyArmControl.rootNode, circle2X, circle2Y, circle2Z)\n                    --#debug DebugGizmo.renderAtPositionSimple(c2xw, c2yw, c2zw, "c2")\n\n                    --#debug DebugGizmo.renderAtPositionSimple(c2xw, c2yw - 0.5, c2zw, string.format("move: %.2f %.2f", moveY / dt * 1000, moveZ / dt * 1000))\n\n                    local numZTranslationNodes = #easyArmControl.zTranslationNodes\n                    if numZTranslationNodes > 0 then\n                        -- get angle between input direction and translatio node direction\n                        local inputDirY, inputDirZ = MathUtil.vector2Normalize( math.abs(moveY), math.abs(moveZ))\n                        if moveY = = 0 and moveZ = = 0 then\n                            inputDirY, inputDirZ = 0 , 0\n                        end\n                        local transDirX, transDirY, transDirZ = localDirectionToWorld(easyArmControl.zTranslationNodes[ 1 ].node, 0 , 0 , 1 )\n                        transDirX, transDirY, transDirZ = worldDirectionToLocal(easyArmControl.rootNode, transDirX, transDirY, transDirZ)\n\n                        local difference = math.acos( MathUtil.dotProduct( 0 , inputDirY, inputDirZ, 0 , transDirY, transDirZ))\n                        if difference > ( math.pi * 0.5 ) then\n                            difference = - difference + math.pi\n                        end\n\n                        -- move translation parts\n                        local rotTransRatio = 1 - (difference / ( math.pi * 0.5 )) -- 1:only trans / 0:only rot\n                        rotTransRatio = (rotTransRatio - easyArmControl.transMoveRatioMinDir) / (easyArmControl.transMoveRatioMaxDir - easyArmControl.transMoveRatioMinDir)\n                        rotTransRatio = math.clamp(rotTransRatio, easyArmControl.minTransMoveRatio, easyArmControl.maxTransMoveRatio)\n\n                        local _, _, targetZOffset = worldToLocal(easyArmControl.xRotationNodes[ 2 ].node, worldTargetX, worldTargetY, worldTargetZ)\n                        local zDifference = targetZOffset - circleDistance2\n\n                        local minTransPct = 0\n                        if not easyArmControl.allowNegativeTrans then\n                            if transDirZ < 0 then\n                                -- move the translation parts to the min position\n                                if zDifference > 0 then\n                                    rotTransRatio = - 2\n                                end\n\n                                minTransPct = easyArmControl.minNegativeTrans * - transDirZ\n                            end\n                        end\n\n                        local transMove = zDifference * rotTransRatio\n\n                        --#debug DebugGizmo.renderAtPositionSimple(c2xw, c2yw - 1, c2zw, string.format("transDirZ %.2f\\n rotTransRatio: %.2f\\n transMove: %.3f\\n zDifference: %.3f\\n", transDirZ, rotTransRatio, transMove / dt * 1000, zDifference / dt * 1000))\n\n                        for i = 1 , numZTranslationNodes do\n                            local zTranslationNode = easyArmControl.zTranslationNodes[i]\n                            local movingTool = zTranslationNode.movingTool\n\n                            local delta = transMove / numZTranslationNodes\n                            if easyArmControl.forcedTransMove ~ = nil then\n                                delta = easyArmControl.forcedTransMove * movingTool.transSpeed * dt\n                                easyArmControl.forcedTransMove = nil\n                            end\n\n                            local currentTrans = movingTool.curTrans[movingTool.translationAxis]\n                            local transMin = (movingTool.transMax - movingTool.transMin) * minTransPct + movingTool.transMin\n                            local newTrans = math.clamp(currentTrans + delta, transMin, movingTool.transMax)\n                            local newDelta = newTrans - currentTrans\n\n                            Cylindered.setAbsoluteToolTranslation( self , movingTool, currentTrans + newDelta)\n\n                            --#debug DebugGizmo.renderAtNode(zTranslationNode.node, "trans" .. tostring(i))\n                        end\n\n                        circleDistance2 = MathUtil.vector3Length(worldToLocal(easyArmControl.xRotationNodes[ 2 ].node, getWorldTranslation(easyArmControl.targetRefNode)))\n                    end\n\n                    --#debug DebugUtil.drawDebugCircleAtNode(easyArmControl.rootNode, circleDistance1, 200, {1, 1, 1, 1}, true, {0, circle1Y, circle1Z})\n                    --#debug DebugUtil.drawDebugCircleAtNode(easyArmControl.rootNode, circleDistance2, 200, {1, 0, 1, 1}, true, {0, circle2Y, circle2Z})\n\n                    -- calculate intersections\n                    local ix, iy, i2x, i2y = MathUtil.getCircleCircleIntersection(circle1Z, circle1Y, circleDistance1, circle2Z, circle2Y, circleDistance2)\n                    if ix ~ = nil and iy ~ = nil then\n                        local node1Tool = easyArmControl.xRotationNodes[ 1 ].movingTool\n                        local node2Tool = easyArmControl.xRotationNodes[ 2 ].movingTool\n\n                        -- rotation node 1\n                        local node1Rotation = - math.atan2(iy, ix)\n                        local node1RotationClamped = math.clamp(node1Rotation, node1Tool.rotMin, node1Tool.rotMax)\n                        local node1Overrun = 0 -- node1Rotation - node1RotationClamped\n\n                        Cylindered.setAbsoluteToolRotation( self , easyArmControl.xRotationNodes[ 1 ].movingTool, node1RotationClamped, updateDelayedNodes)\n\n                        -- rotation node 2\n                        local node2Rotation = math.pi - math.acos((circleDistance1 * circleDistance1 + circleDistance2 * circleDistance2 - distanceToTarget * distanceToTarget) / ( 2 * circleDistance1 * circleDistance2))\n                        local node2RotationClamped = math.clamp(node2Rotation + node1Overrun, node2Tool.rotMin, node2Tool.rotMax)\n                        local node2Overrun = node2Rotation - node2RotationClamped\n\n                        Cylindered.setAbsoluteToolRotation( self , easyArmControl.xRotationNodes[ 2 ].movingTool, node2RotationClamped, updateDelayedNodes)\n\n                        -- rotation node 1\n                        node1RotationClamped = math.clamp(node1RotationClamped + node2Overrun * 0.5 , node1Tool.rotMin, node1Tool.rotMax)\n                        Cylindered.setAbsoluteToolRotation( self , easyArmControl.xRotationNodes[ 1 ].movingTool, node1RotationClamped, updateDelayedNodes)\n\n                        -- debug\n                        --#debug local dx0, dy0, dz0 = localToWorld(easyArmControl.rootNode, 0, 0, 0)\n                        --#debug local dx1, dy1, dz1 = localToWorld(easyArmControl.rootNode, 0, iy, ix)\n                        --#debug local dx2, dy2, dz2 = localToWorld(easyArmControl.rootNode, 0, i2y, i2x)\n                        --#debug DebugGizmo.renderAtPositionSimple(dx1, dy1, dz1, "i1")\n                        --#debug DebugGizmo.renderAtPositionSimple(dx2, dy2, dz2, "i2")\n                        --#debug drawDebugLine(dx0, dy0, dz0, 1, 0, 0, worldTargetX, worldTargetY, worldTargetZ, 1, 0, 0) -- root to target\n                        --#debug drawDebugLine(dx0, dy0, dz0, 1, 1, 0, dx1, dy1, dz1, 1, 1, 0) -- root to i1\n                        --#debug drawDebugLine(dx1, dy1, dz1, 1, 1, 0, worldTargetX, worldTargetY, worldTargetZ, 1, 1, 0) -- i1 to target\n\n                        --#debug DebugUtil.drawDebugCircleAtNode(easyArmControl.rootNode, easyArmControl.maxTotalDistance, 200, {0, 1, 0, 1}, true)\n                        --#debug if easyArmControl.maxTransDistance ~ = nil then\n                            --#debug DebugUtil.drawDebugCircleAtNode(easyArmControl.xRotationNodes[2].node, easyArmControl.maxTransDistance, 200, {0, 1, 0, 1}, true)\n                            --#debug end\n                        end\n                    end\n                end\n            end\n\n'})}),"\n",(0,o.jsx)(e.h3,{id:"updateextradependentparts",children:"updateExtraDependentParts"}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Description"})}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Definition"})}),"\n",(0,o.jsxs)(e.blockquote,{children:["\n",(0,o.jsx)(e.p,{children:"updateExtraDependentParts()"}),"\n"]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,o.jsxs)(e.table,{children:[(0,o.jsx)(e.thead,{children:(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.th,{children:"any"}),(0,o.jsx)(e.th,{children:"part"})]})}),(0,o.jsx)(e.tbody,{children:(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.td,{children:"any"}),(0,o.jsx)(e.td,{children:"dt"})]})})]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Code"})}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-lua",children:"function Cylindered:updateExtraDependentParts(part, dt)\nend\n\n"})}),"\n",(0,o.jsx)(e.h3,{id:"updatemovingpart",children:"updateMovingPart"}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Description"})}),"\n",(0,o.jsxs)(e.blockquote,{children:["\n",(0,o.jsx)(e.p,{children:"Update moving part"}),"\n"]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Definition"})}),"\n",(0,o.jsxs)(e.blockquote,{children:["\n",(0,o.jsx)(e.p,{children:"updateMovingPart(table part, boolean? placeComponents, boolean? updateDependentParts, boolean? isActive, , )"}),"\n"]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,o.jsxs)(e.table,{children:[(0,o.jsx)(e.thead,{children:(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.th,{children:"table"}),(0,o.jsx)(e.th,{children:"part"}),(0,o.jsx)(e.th,{children:"part"})]})}),(0,o.jsxs)(e.tbody,{children:[(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.td,{children:"boolean?"}),(0,o.jsx)(e.td,{children:"placeComponents"}),(0,o.jsx)(e.td,{children:"place components"})]}),(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.td,{children:"boolean?"}),(0,o.jsx)(e.td,{children:"updateDependentParts"}),(0,o.jsx)(e.td,{children:"update dependent parts"})]}),(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.td,{children:"boolean?"}),(0,o.jsx)(e.td,{children:"isActive"}),(0,o.jsx)(e.td,{children:"moving part is active (default: true)"})]}),(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.td,{children:"any"}),(0,o.jsx)(e.td,{children:"isActive"}),(0,o.jsx)(e.td,{})]}),(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.td,{children:"any"}),(0,o.jsx)(e.td,{children:"updateSounds"}),(0,o.jsx)(e.td,{})]})]})]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Code"})}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-lua",children:'function Cylindered.updateMovingPart( self , part, placeComponents, updateDependentParts, isActive, updateSounds)\n    --#debug if VehicleDebug.cylinderedUpdateDebugState and self:getIsActiveForInput() then\n        --#debug DebugGizmo.renderAtNode(part.node, "Part: " .. getName(part.node), true)\n        --#debug end\n\n        -- the local reference point must be referenceDistance away from the referencePoint\n        local refX, refY, refZ\n        local dirX, dirY, dirZ = 0 , 0 , 0\n        local changed, applyDirection = false , false\n        if part.hasReferencePoints then\n            if part.moveToReferenceFrame then\n                local x,y,z = localToLocal(part.referenceFrame, getParent(part.node), part.referenceFrameOffset[ 1 ], part.referenceFrameOffset[ 2 ], part.referenceFrameOffset[ 3 ])\n                setTranslation(part.node, x,y,z)\n                changed = true\n            end\n\n            if part.referencePoint ~ = nil then\n                refX, refY, refZ = getWorldTranslation(part.referencePoint)\n            else\n                    refX, refY, refZ = 0 , 0 , 0\n                    for i, referencePoint in ipairs(part.referencePoints) do\n                        local x, y, z = getWorldTranslation(referencePoint)\n                        refX, refY, refZ = refX + x, refY + y, refZ + z\n                    end\n\n                    refX, refY, refZ = refX / part.numReferencePoints, refY / part.numReferencePoints, refZ / part.numReferencePoints\n                end\n\n                if part.referenceDistance = = 0 then\n                    if part.useLocalOffset then\n                        local lx, ly, lz = worldToLocal(part.node, refX, refY, refZ)\n                        dirX, dirY, dirZ = localDirectionToWorld(part.node, lx - part.localReferencePoint[ 1 ], ly - part.localReferencePoint[ 2 ], lz)\n                    elseif part.referencePointOffset ~ = nil then\n                            local offset = math.abs(part.referencePointOffset)\n                            local direction = math.sign(part.referencePointOffset)\n\n                            local x, y, z = getWorldTranslation(part.node)\n                            --#debug drawDebugPoint(x, y, z, 0, 1, 0, 1, false)\n\n                            local _, y1, z1 = localToLocal(part.node, part.referenceFrame, 0 , 0 , 0 )\n                            local _, y2, z2 = localToLocal(part.referencePoint, part.referenceFrame, 0 , 0 , 0 )\n\n                            --#debug local wx2, wy2, wz2 = localToWorld(part.referenceFrame, 0, y2, z2)\n                            --#debug drawDebugPoint(wx2, wy2, wz2, 0, 1, 0, 1, false)\n\n                            local a = MathUtil.vector2Length(y2 - y1, z2 - z1)\n                            if a > offset then\n                                local b = math.sqrt(a ^ 2 - offset ^ 2 )\n                                local rotOffset = math.atan(offset / b)\n\n                                --#debug DebugUtil.drawDebugCircleAtNode(part.referenceFrame, offset, 25, nil, true, {0, y2, z2})\n\n                                local rot = MathUtil.getYRotationFromDirection(y2 - y1, z2 - z1)\n                                local tDirY, tDirZ = MathUtil.getDirectionFromYRotation(rot + rotOffset * direction)\n\n                                local ty, tz = y1 + tDirY * b, z1 + tDirZ * b\n                                refX, refY, refZ = localToWorld(part.referenceFrame, 0 , ty, tz)\n\n                                --#debug drawDebugPoint(refX, refY, refZ, 0, 1, 0, 1, false)\n                                --#debug drawDebugLine(x, y, z, 0, 1, 0, refX, refY, refZ, 0, 1, 0, false)\n\n                                dirX, dirY, dirZ = refX - x, refY - y, refZ - z\n                            end\n                        else\n                                local x, y, z = getWorldTranslation(part.node)\n                                dirX, dirY, dirZ = refX - x, refY - y, refZ - z\n                            end\n                        else\n                                if part.updateLocalReferenceDistance then\n                                    local _,y,z = worldToLocal(part.node, getWorldTranslation(part.localReferencePointNode))\n                                    part.localReferenceDistance = MathUtil.vector2Length(y, z)\n                                end\n                                if part.referenceDistancePoint ~ = nil then\n                                    local _,_,z = worldToLocal(part.node, getWorldTranslation(part.referenceDistancePoint))\n                                    part.referenceDistance = z\n                                end\n\n                                if part.localReferenceTranslate then\n                                    local _, ly, lz = worldToLocal(part.node, refX, refY, refZ)\n\n                                    -- calculate line-circle intersection\n                                    if math.abs(ly) < part.referenceDistance then\n                                        local dz = math.sqrt(part.referenceDistance * part.referenceDistance - ly * ly)\n\n                                        local z1 = (lz - dz) - part.localReferenceDistance\n                                        local z2 = (lz + dz) - part.localReferenceDistance\n                                        if math.abs(z2) < math.abs(z1) then\n                                            z1 = z2\n                                        end\n                                        local parentNode = getParent(part.node)\n                                        local tx,ty,tz = unpack(part.localReferenceTranslation)\n                                        local _, _, coz = localToLocal(parentNode, part.node, tx,ty,tz)\n                                        local ox,oy,oz = localDirectionToLocal(part.node, parentNode, 0 , 0 ,z1 - coz)\n                                        setTranslation(part.node, tx + ox,ty + oy,tz + oz)\n                                        changed = true\n                                    end\n                                else\n                                        local r1 = part.localReferenceDistance\n                                        local r2 = part.referenceDistance\n\n                                        if part.dynamicLocalReferenceDistance then\n                                            local _, y1, z1 = worldToLocal(part.node, getWorldTranslation(part.localReferencePointNode))\n                                            local _, y2, z2 = worldToLocal(part.node, localToWorld(part.localReferencePointNode, 0 , 0 , part.referenceDistance))\n\n                                            r2 = MathUtil.vector2Length(y1 - y2, z1 - z2)\n                                        end\n\n                                        local _, ly, lz = worldToLocal(part.node, refX, refY, refZ)\n                                        --print("intersect: " .. ly .. " " .. lz)\n                                        local ix, iy, i2x, i2y = MathUtil.getCircleCircleIntersection( 0 , 0 , r1, ly, lz, r2)\n\n                                        local allowUpdate = true\n                                        if part.referenceDistanceThreshold > 0 then\n                                            local lRefX, lRefY, lRefZ = getWorldTranslation(part.localReferencePointNode)\n                                            local currentDistance = MathUtil.vector3Length(refX - lRefX, refY - lRefY, refZ - lRefZ)\n                                            if math.abs(currentDistance - part.referenceDistance) < part.referenceDistanceThreshold then\n                                                allowUpdate = false\n                                            end\n                                        end\n\n                                        if allowUpdate and ix ~ = nil then\n                                            if i2x ~ = nil then\n                                                -- use the point which as the same angle side as the original configuration\n                                                local side = ix * (lz - iy) - iy * (ly - ix)\n                                                if (side < 0 ) ~ = (part.localReferenceAngleSide < 0 ) then\n                                                    iy = i2y\n                                                    ix = i2x\n                                                end\n                                            end\n                                            dirX, dirY, dirZ = localDirectionToWorld(part.node, 0 , ix, iy)\n                                            changed = true\n                                        end\n                                    end\n                                end\n\n                                if part.doInversedLineAlignment then\n                                    if part.doInversedLineAlignmentRoot = = nil then\n                                        part.doInversedLineAlignmentRoot = createTransformGroup( "inversedLineAlignmentRoot" )\n                                        link(getParent(part.node), part.doInversedLineAlignmentRoot, getChildIndex(part.node))\n                                        setTranslation(part.doInversedLineAlignmentRoot, getTranslation(part.node))\n                                        setRotation(part.doInversedLineAlignmentRoot, getRotation(part.node))\n                                        link(part.doInversedLineAlignmentRoot, part.node)\n                                        setTranslation(part.node, 0 , 0 , 0 )\n                                        setRotation(part.node, 0 , 0 , 0 )\n                                    end\n\n                                    for i = 1 , #part.orientationLineNodes - 1 do\n                                        local startNode = part.orientationLineNodes[i]\n                                        local endNode = part.orientationLineNodes[i + 1 ]\n\n                                        local _, sy, sz = localToLocal(startNode, part.node, 0 , 0 , 0 )\n                                        local _, ey, ez = localToLocal(endNode, part.node, 0 , 0 , 0 )\n\n                                        local minLength = MathUtil.vector2Length(sy, sz)\n                                        local maxLength = MathUtil.vector2Length(ey, ez)\n\n                                        local rootX, rootY, rootZ = getWorldTranslation(part.doInversedLineAlignmentRoot)\n                                        local targetLength = MathUtil.vector3Length(refX - rootX, refY - rootY, refZ - rootZ)\n\n                                        if not MathUtil.getIsOutOfBounds(targetLength, minLength, maxLength) then\n                                            local alpha = (targetLength - minLength) / (maxLength - minLength)\n\n                                            local ty = MathUtil.lerp(sy, ey, alpha)\n                                            local tz = MathUtil.lerp(sz, ez, alpha)\n\n                                            -- alignment root always pointing to reference point\n                                            -- actual moving part is adjusting to local offset to current target point on the line\n\n                                            local upX, upY, upZ = localDirectionToWorld(part.referenceFrame, 0 , 1 , 0 )\n\n                                            dirX, dirY, dirZ = localDirectionToWorld(part.doInversedLineAlignmentRoot, 0 , - ty, tz)\n                                            I3DUtil.setWorldDirection(part.node, dirX, dirY, dirZ, upX, upY, upZ, part.limitedAxis, part.minRot, part.maxRot)\n\n                                            local x, y, z = getWorldTranslation(part.doInversedLineAlignmentRoot)\n                                            dirX, dirY, dirZ = refX - x, refY - y, refZ - z\n                                            I3DUtil.setWorldDirection(part.doInversedLineAlignmentRoot, dirX, dirY, dirZ, upX, upY, upZ, part.limitedAxis, part.minRot, part.maxRot)\n\n                                            --#debug local rx, ry, rz = getWorldTranslation(part.doInversedLineAlignmentRoot)\n                                            --#debug drawDebugLine(rx, ry, rz, 1, 0, 1, rx + dirX * targetLength, ry + dirY * targetLength, rz + dirZ * targetLength, 1, 0, 1, true)\n\n                                            --#debug local tx\n                                            --#debug tx, ty, tz = localToWorld(part.node, 0, ty, tz)\n                                            --#debug drawDebugPoint(tx, ty, tz, 1, 0, 0, 1, true)\n                                            --#debug drawDebugPoint(refX, refY, refZ, 1, 0, 1, 1, true)\n                                            --#debug Utils.renderTextAtWorldPosition(tx, ty + 0.02, tz, string.format("%.2f(min%.2f, max%.2f, tar%.2f)", alpha, minLength, maxLength, targetLength), getCorrectTextSize(0.008))\n\n                                            changed = true\n                                            break\n                                        end\n                                    end\n                                end\n                            else\n                                    if part.alignToWorldY then\n                                        dirX, dirY, dirZ = localDirectionToWorld(getRootNode(), 0 , 1 , 0 )\n\n                                        local lDX, lDY, lDZ = worldDirectionToLocal(part.referenceFrame, dirX, dirY, dirZ)\n                                        if lDZ < 0 then\n                                            lDZ = - lDZ\n                                        end\n                                        dirX, dirY, dirZ = localDirectionToWorld(part.referenceFrame, lDX, lDY, lDZ)\n\n                                        changed = true\n                                    elseif part.doDirectionAlignment then\n                                            dirX, dirY, dirZ = localDirectionToWorld(part.referenceFrame, 0 , 0 , 1 )\n                                            changed = true\n                                        end\n                                        if part.moveToReferenceFrame then\n                                            local x,y,z = localToLocal(part.referenceFrame, getParent(part.node), part.referenceFrameOffset[ 1 ], part.referenceFrameOffset[ 2 ], part.referenceFrameOffset[ 3 ])\n                                            setTranslation(part.node, x,y,z)\n                                            changed = true\n                                        end\n\n                                        if part.doLineAlignment then\n                                            local foundPoint = false\n                                            for i = 1 , #part.orientationLineNodes - 1 do\n                                                local startNode = part.orientationLineNodes[i]\n                                                local endNode = part.orientationLineNodes[i + 1 ]\n\n                                                local _, sy, sz = localToLocal(startNode, part.referenceFrame, 0 , 0 , 0 )\n                                                local _, ey, ez = localToLocal(endNode, part.referenceFrame, 0 , 0 , 0 )\n                                                local _, cy, cz = localToLocal(part.node, part.referenceFrame, 0 , 0 , 0 )\n\n                                                local partLength = part.partLength\n                                                if part.partLengthNode ~ = nil then\n                                                    partLength = calcDistanceFrom(part.node, part.partLengthNode)\n                                                end\n\n                                                local hasIntersection, i1y, i1z, i2y, i2z = MathUtil.getCircleLineIntersection(cy, cz, partLength, sy, sz, ey, ez)\n                                                if hasIntersection then\n                                                    local targetY, targetZ\n                                                    if i1y ~ = nil and i1z ~ = nil then\n                                                        targetY, targetZ = i1y, i1z\n                                                        foundPoint = true\n                                                    elseif i2y ~ = nil and i2z ~ = nil then\n                                                            targetY, targetZ = i2y, i2z\n                                                            foundPoint = true\n                                                        end\n\n                                                        if foundPoint and not MathUtil.isNan(targetY) and not MathUtil.isNan(targetZ) then\n                                                            dirX, dirY, dirZ = localDirectionToWorld(part.referenceFrame, 0 , targetY, targetZ)\n\n                                                            changed = true\n                                                            applyDirection = true\n                                                            break\n                                                        end\n                                                    end\n                                                end\n                                            end\n\n                                            if part.do3DLineAlignment then\n                                                local partLength = part.partLength\n                                                if part.partLengthNode ~ = nil then\n                                                    partLength = calcDistanceFrom(part.node, part.partLengthNode)\n                                                end\n\n                                                local startNode = part.orientationLineNodes[ 1 ]\n                                                local endNode = part.orientationLineNodes[ 2 ]\n\n                                                local x, y, z = getWorldTranslation(part.node)\n\n                                                local sx, sy, sz = getWorldTranslation(startNode)\n                                                local ex, ey, ez = getWorldTranslation(endNode)\n\n                                                local startDistance = MathUtil.vector3Length(sx - x, sy - y, sz - z)\n                                                local endDistance = MathUtil.vector3Length(ex - x, ey - y, ez - z)\n\n                                                local alpha = math.clamp( MathUtil.inverseLerp(startDistance, endDistance, partLength), 0 , 1 )\n\n                                                local rx, ry, rz = MathUtil.vector3Lerp(sx, sy, sz, ex, ey, ez, alpha)\n\n                                                --#debug drawDebugLine(sx, sy, sz, 1, 1, 0, ex, ey, ez, 1, 1, 0, true)\n                                                --#debug drawDebugPoint(rx, ry, rz, 0, 1, 0, 1, true)\n\n                                                dirX, dirY, dirZ = MathUtil.vector3Normalize(rx - x, ry - y, rz - z)\n\n                                                setWorldTranslation(part.orientationLineTransNode, rx, ry, rz)\n                                                applyDirection = true\n                                            end\n                                        end\n\n                                        --#debug for i = 1, #part.orientationLineNodes-1 do\n                                            --#debug local startNode = part.orientationLineNodes[i]\n                                            --#debug local endNode = part.orientationLineNodes[i + 1]\n                                            --#debug local swx, swy, swz = getWorldTranslation(startNode)\n                                            --#debug local ewx, ewy, ewz = getWorldTranslation(endNode)\n                                            --#debug drawDebugLine(swx, swy, swz, 0, 1, 0, ewx, ewy, ewz, 0, 1, 0, true)\n                                            --#debug end\n\n                                            local zReferenceOffset = nil\n\n                                            if part.smoothedDirectionScale then\n                                                if part.smoothedDirectionScaleAlpha = = nil then\n                                                    part.smoothedDirectionScaleAlpha = isActive and 1 or 0\n                                                end\n\n                                                local dt = g_currentDt or 9999\n                                                if isActive then\n                                                    part.smoothedDirectionScaleAlpha = math.min(part.smoothedDirectionScaleAlpha + dt * part.smoothedDirectionTime, 1 )\n                                                else\n                                                        part.smoothedDirectionScaleAlpha = math.max(part.smoothedDirectionScaleAlpha - dt * part.smoothedDirectionTime, 0 )\n                                                    end\n\n                                                    local inDirX, inDirY, inDirZ = localDirectionToWorld(getParent(part.node), unpack(part.initialDirection))\n                                                    dirX, dirY, dirZ = MathUtil.vector3Lerp(inDirX, inDirY, inDirZ, dirX, dirY, dirZ, part.smoothedDirectionScaleAlpha)\n\n                                                    if part.hasReferencePoints then\n                                                        if part.numTranslatingParts > 0 then\n                                                            local _\n                                                            _, _, zReferenceOffset = worldToLocal(part.node, refX, refY, refZ)\n                                                            zReferenceOffset = MathUtil.lerp(part.smoothedDirectionScaleZOffset, zReferenceOffset, part.smoothedDirectionScaleAlpha)\n                                                        end\n                                                    end\n\n                                                    if part.smoothedDirectionScaleTempDirty and(part.smoothedDirectionScaleAlpha = = 0 or part.smoothedDirectionScaleAlpha = = 1 ) then\n                                                        table.removeElement( self.spec_cylindered.activeDirtyMovingParts, part)\n                                                        part.smoothedDirectionScaleTempDirty = false\n                                                    end\n                                                end\n\n                                                if (part.doDirectionAlignment or applyDirection) and(dirX ~ = 0 or dirY ~ = 0 or dirZ ~ = 0 ) then\n                                                    local upX, upY, upZ = localDirectionToWorld(part.referenceFrame, 0 , 1 , 0 )\n                                                    if part.invertZ then\n                                                        dirX = - dirX\n                                                        dirY = - dirY\n                                                        dirZ = - dirZ\n                                                    end\n\n                                                    local directionThreshold = part.directionThresholdActive\n                                                    if not self.isActive then\n                                                        if part.directionThreshold ~ = nil and part.directionThreshold > 0 then\n                                                            directionThreshold = part.directionThreshold\n                                                        end\n                                                    end\n\n                                                    local lDirX, lDirY, lDirZ = worldDirectionToLocal(part.parent, dirX, dirY, dirZ)\n                                                    local lastDirection, lastUpVector = part.lastDirection, part.lastUpVector\n                                                    if math.abs(lastDirection[ 1 ] - lDirX) > directionThreshold or\n                                                        math.abs(lastDirection[ 2 ] - lDirY) > directionThreshold or\n                                                        math.abs(lastDirection[ 3 ] - lDirZ) > directionThreshold or\n                                                        math.abs(lastUpVector[ 1 ] - upX) > directionThreshold or\n                                                        math.abs(lastUpVector[ 2 ] - upY) > directionThreshold or\n                                                        math.abs(lastUpVector[ 3 ] - upZ) > directionThreshold then\n\n                                                        I3DUtil.setWorldDirection(part.node, dirX, dirY, dirZ, upX, upY, upZ, part.limitedAxis, part.minRot, part.maxRot)\n\n                                                        if part.debug then\n                                                            local x, y, z = getWorldTranslation(part.node)\n                                                            drawDebugPoint(x, y, z, 1 , 0 , 0 , 1 , false )\n\n                                                            local length, _ = 1 , nil\n                                                            if part.hasReferencePoints then\n                                                                _, _, length = worldToLocal(part.node, refX, refY, refZ)\n                                                            end\n\n                                                            local nDirX, nDirY, nDirZ = MathUtil.vector3Normalize(dirX, dirY, dirZ)\n                                                            drawDebugLine(x, y, z, 1 , 0 , 0 , x + nDirX * length, y + nDirY * length, z + nDirZ * length, 0 , 1 , 0 , true )\n\n                                                            if part.referencePoint ~ = nil then\n                                                                x, y, z = getWorldTranslation(part.referencePoint)\n                                                                drawDebugPoint(x, y, z, 0 , 1 , 0 , 1 , false )\n\n                                                                drawDebugPoint(refX, refY, refZ, 0 , 0 , 1 , 1 , false )\n                                                            end\n                                                        end\n\n                                                        lastDirection[ 1 ], lastDirection[ 2 ], lastDirection[ 3 ] = lDirX, lDirY, lDirZ\n                                                        lastUpVector[ 1 ], lastUpVector[ 2 ], lastUpVector[ 3 ] = upX, upY, upZ\n\n                                                        changed = true\n                                                    else\n                                                            changed = false\n                                                        end\n\n                                                        if part.scaleZ and part.localReferenceDistance ~ = nil and part.localReferenceDistance ~ = 0 then\n                                                            local len = MathUtil.vector3Length(dirX, dirY, dirZ)\n                                                            setScale(part.node, 1 , 1 , len / part.localReferenceDistance)\n\n                                                            if part.debug then\n                                                                DebugGizmo.renderAtNode(part.node, string.format( "scale:%.2f" , len / part.localReferenceDistance))\n                                                            end\n                                                        end\n                                                    end\n\n                                                    if part.doRotationAlignment then\n                                                        local x, y, z = getRotation(part.referenceFrame)\n                                                        x, y, z = x * part.rotMultiplier, y * part.rotMultiplier, z * part.rotMultiplier\n                                                        local ox, oy, oz = getRotation(part.node)\n                                                        if math.abs(x - ox) > 0.0001 or math.abs(y - oy) > 0.0001 or math.abs(z - oz) > 0.0001 then\n                                                            setRotation(part.node, x, y, z)\n                                                            changed = true\n                                                        end\n                                                    end\n\n                                                    if part.hasReferencePoints then\n                                                        if part.numTranslatingParts > 0 then\n                                                            if zReferenceOffset = = nil then\n                                                                local _\n                                                                _, _, zReferenceOffset = worldToLocal(part.node, refX, refY, refZ)\n                                                            end\n\n                                                            for i = 1 , part.numTranslatingParts do\n                                                                local translatingPart = part.translatingParts[i]\n                                                                local newZ = zReferenceOffset - translatingPart.referenceDistance\n                                                                if part.translatingPartsDivider ~ = 1 and translatingPart.divideTranslatingDistance then\n                                                                    newZ = newZ / part.translatingPartsDivider\n                                                                end\n\n                                                                if translatingPart.minZTrans ~ = nil then\n                                                                    newZ = math.max(translatingPart.minZTrans, newZ)\n                                                                end\n\n                                                                if translatingPart.maxZTrans ~ = nil then\n                                                                    newZ = math.min(translatingPart.maxZTrans, newZ)\n                                                                end\n\n                                                                if not translatingPart.divideTranslatingDistance then\n                                                                    zReferenceOffset = zReferenceOffset - (newZ - translatingPart.startPos[ 3 ])\n                                                                end\n\n                                                                if part.referenceDistanceThreshold = = 0 or math.abs(translatingPart.lastZ - newZ) > part.referenceDistanceThreshold then\n                                                                    if updateSounds ~ = false then\n                                                                        if part.samplesByAction ~ = nil or translatingPart.samplesByAction ~ = nil then\n                                                                            if newZ ~ = translatingPart.lastZ then\n                                                                                if math.abs(translatingPart.lastZ - newZ) > 0.0001 then\n                                                                                    self:onMovingPartSoundEvent(part, Cylindered.SOUND_ACTION_TRANSLATING_END, Cylindered.SOUND_TYPE_ENDING)\n                                                                                    self:onMovingPartSoundEvent(translatingPart, Cylindered.SOUND_ACTION_TRANSLATING_END, Cylindered.SOUND_TYPE_ENDING)\n\n                                                                                    self:onMovingPartSoundEvent(part, Cylindered.SOUND_ACTION_TRANSLATING_START, Cylindered.SOUND_TYPE_STARTING)\n                                                                                    self:onMovingPartSoundEvent(translatingPart, Cylindered.SOUND_ACTION_TRANSLATING_START, Cylindered.SOUND_TYPE_STARTING)\n\n                                                                                    if newZ > translatingPart.lastZ + 0.0001 then\n                                                                                        self:onMovingPartSoundEvent(part, Cylindered.SOUND_ACTION_TRANSLATING_POS, Cylindered.SOUND_TYPE_CONTINUES)\n                                                                                        self:onMovingPartSoundEvent(translatingPart, Cylindered.SOUND_ACTION_TRANSLATING_POS, Cylindered.SOUND_TYPE_CONTINUES)\n\n                                                                                        self:onMovingPartSoundEvent(part, Cylindered.SOUND_ACTION_TRANSLATING_END_POS, Cylindered.SOUND_TYPE_ENDING)\n                                                                                        self:onMovingPartSoundEvent(translatingPart, Cylindered.SOUND_ACTION_TRANSLATING_END_POS, Cylindered.SOUND_TYPE_ENDING)\n\n                                                                                        self:onMovingPartSoundEvent(part, Cylindered.SOUND_ACTION_TRANSLATING_START_POS, Cylindered.SOUND_TYPE_STARTING)\n                                                                                        self:onMovingPartSoundEvent(translatingPart, Cylindered.SOUND_ACTION_TRANSLATING_START_POS, Cylindered.SOUND_TYPE_STARTING)\n                                                                                    elseif newZ < translatingPart.lastZ - 0.0001 then\n                                                                                            self:onMovingPartSoundEvent(part, Cylindered.SOUND_ACTION_TRANSLATING_NEG, Cylindered.SOUND_TYPE_CONTINUES)\n                                                                                            self:onMovingPartSoundEvent(translatingPart, Cylindered.SOUND_ACTION_TRANSLATING_NEG, Cylindered.SOUND_TYPE_CONTINUES)\n\n                                                                                            self:onMovingPartSoundEvent(part, Cylindered.SOUND_ACTION_TRANSLATING_END_NEG, Cylindered.SOUND_TYPE_ENDING)\n                                                                                            self:onMovingPartSoundEvent(translatingPart, Cylindered.SOUND_ACTION_TRANSLATING_END_NEG, Cylindered.SOUND_TYPE_ENDING)\n\n                                                                                            self:onMovingPartSoundEvent(part, Cylindered.SOUND_ACTION_TRANSLATING_START_NEG, Cylindered.SOUND_TYPE_STARTING)\n                                                                                            self:onMovingPartSoundEvent(translatingPart, Cylindered.SOUND_ACTION_TRANSLATING_START_NEG, Cylindered.SOUND_TYPE_STARTING)\n                                                                                        end\n                                                                                    end\n                                                                                end\n                                                                            end\n                                                                        end\n\n                                                                        translatingPart.lastZ = newZ\n                                                                        setTranslation(translatingPart.node, translatingPart.startPos[ 1 ], translatingPart.startPos[ 2 ], newZ)\n                                                                        changed = true\n                                                                    end\n                                                                end\n                                                            end\n                                                        end\n\n                                                        if changed then\n                                                            if part.copyLocalDirectionParts ~ = nil then\n                                                                for _,copyLocalDirectionPart in pairs(part.copyLocalDirectionParts) do\n                                                                    local dx,dy,dz = localDirectionToWorld(part.node, 0 , 0 , 1 )\n                                                                    dx,dy,dz = worldDirectionToLocal(getParent(part.node), dx,dy,dz)\n                                                                    dx = dx * copyLocalDirectionPart.dirScale[ 1 ]\n                                                                    dy = dy * copyLocalDirectionPart.dirScale[ 2 ]\n                                                                    dz = dz * copyLocalDirectionPart.dirScale[ 3 ]\n\n                                                                    local ux,uy,uz = localDirectionToWorld(part.node, 0 , 1 , 0 )\n                                                                    ux,uy,uz = worldDirectionToLocal(getParent(part.node), ux,uy,uz)\n                                                                    ux = ux * copyLocalDirectionPart.upScale[ 1 ]\n                                                                    uy = uy * copyLocalDirectionPart.upScale[ 2 ]\n                                                                    uz = uz * copyLocalDirectionPart.upScale[ 3 ]\n\n                                                                    setDirection(copyLocalDirectionPart.node, dx,dy,dz, ux,uy,uz)\n\n                                                                    if self.isServer then\n                                                                        Cylindered.updateComponentJoints( self , copyLocalDirectionPart, placeComponents)\n                                                                    end\n                                                                end\n                                                            end\n\n                                                            -- update component joint\n                                                            if self.isServer then\n                                                                Cylindered.updateComponentJoints( self , part, placeComponents)\n                                                                Cylindered.updateAttacherJoints( self , part)\n                                                                Cylindered.updateWheels( self , part)\n                                                            end\n\n                                                            Cylindered.updateWheels( self , part)\n\n                                                            for _, dependentTool in pairs(part.dependentMovingTools) do\n                                                                Cylindered.updateRotationBasedLimits( self , part, dependentTool)\n                                                            end\n                                                        end\n\n                                                        if updateDependentParts then\n                                                            for _, data in pairs(part.dependentPartData) do\n                                                                if self.currentUpdateDistance < data.maxUpdateDistance then\n                                                                    local dependentPart = data.part\n                                                                    local dependentIsActive = self:getIsMovingPartActive(dependentPart)\n                                                                    if dependentIsActive or dependentPart.smoothedDirectionScale and dependentPart.smoothedDirectionScaleAlpha ~ = 0 then\n                                                                        Cylindered.updateMovingPart( self , dependentPart, placeComponents, updateDependentParts, dependentIsActive)\n                                                                    end\n                                                                end\n                                                            end\n                                                        end\n\n                                                        part.isDirty = false\n                                                    end\n\n'})}),"\n",(0,o.jsx)(e.h3,{id:"updatemovingpartbynode",children:"updateMovingPartByNode"}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Description"})}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Definition"})}),"\n",(0,o.jsxs)(e.blockquote,{children:["\n",(0,o.jsx)(e.p,{children:"updateMovingPartByNode()"}),"\n"]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,o.jsxs)(e.table,{children:[(0,o.jsx)(e.thead,{children:(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.th,{children:"any"}),(0,o.jsx)(e.th,{children:"movingPartNode"})]})}),(0,o.jsx)(e.tbody,{children:(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.td,{children:"any"}),(0,o.jsx)(e.td,{children:"dt"})]})})]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Code"})}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-lua",children:"function Cylindered:updateMovingPartByNode(movingPartNode, dt)\n    local movingPart = self.spec_cylindered.nodesToMovingParts[movingPartNode]\n    if movingPart ~ = nil then\n        Cylindered.updateMovingPart( self , movingPart, false , true , true )\n\n        self:updateExtraDependentParts(movingPart, dt)\n        self:updateDependentAnimations(movingPart, dt)\n    end\nend\n\n"})}),"\n",(0,o.jsx)(e.h3,{id:"updatemovingtoolsoundevents",children:"updateMovingToolSoundEvents"}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Description"})}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Definition"})}),"\n",(0,o.jsxs)(e.blockquote,{children:["\n",(0,o.jsx)(e.p,{children:"updateMovingToolSoundEvents()"}),"\n"]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,o.jsxs)(e.table,{children:[(0,o.jsx)(e.thead,{children:(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.th,{children:"any"}),(0,o.jsx)(e.th,{children:"tool"})]})}),(0,o.jsxs)(e.tbody,{children:[(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.td,{children:"any"}),(0,o.jsx)(e.td,{children:"direction"})]}),(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.td,{children:"any"}),(0,o.jsx)(e.td,{children:"hitLimit"})]}),(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.td,{children:"any"}),(0,o.jsx)(e.td,{children:"wasAtLimit"})]})]})]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Code"})}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-lua",children:"function Cylindered:updateMovingToolSoundEvents(tool, direction, hitLimit, wasAtLimit)\n    if tool.samplesByAction ~ = nil then\n        self:onMovingPartSoundEvent(tool, Cylindered.SOUND_ACTION_TOOL_MOVE_END, Cylindered.SOUND_TYPE_ENDING)\n        self:onMovingPartSoundEvent(tool, Cylindered.SOUND_ACTION_TOOL_MOVE_START, Cylindered.SOUND_TYPE_STARTING)\n\n        if direction then\n            self:onMovingPartSoundEvent(tool, Cylindered.SOUND_ACTION_TOOL_MOVE_POS, Cylindered.SOUND_TYPE_CONTINUES)\n            self:onMovingPartSoundEvent(tool, Cylindered.SOUND_ACTION_TOOL_MOVE_END_POS, Cylindered.SOUND_TYPE_ENDING)\n            self:onMovingPartSoundEvent(tool, Cylindered.SOUND_ACTION_TOOL_MOVE_START_POS, Cylindered.SOUND_TYPE_STARTING)\n\n            if hitLimit then\n                self:onMovingPartSoundEvent(tool, Cylindered.SOUND_ACTION_TOOL_MOVE_END_POS_LIMIT, Cylindered.SOUND_TYPE_ENDING)\n            end\n\n            if wasAtLimit then\n                self:onMovingPartSoundEvent(tool, Cylindered.SOUND_ACTION_TOOL_MOVE_START_POS_LIMIT, Cylindered.SOUND_TYPE_STARTING)\n            end\n        else\n                self:onMovingPartSoundEvent(tool, Cylindered.SOUND_ACTION_TOOL_MOVE_NEG, Cylindered.SOUND_TYPE_CONTINUES)\n                self:onMovingPartSoundEvent(tool, Cylindered.SOUND_ACTION_TOOL_MOVE_END_NEG, Cylindered.SOUND_TYPE_ENDING)\n                self:onMovingPartSoundEvent(tool, Cylindered.SOUND_ACTION_TOOL_MOVE_START_NEG, Cylindered.SOUND_TYPE_STARTING)\n\n                if hitLimit then\n                    self:onMovingPartSoundEvent(tool, Cylindered.SOUND_ACTION_TOOL_MOVE_END_NEG_LIMIT, Cylindered.SOUND_TYPE_ENDING)\n                end\n\n                if wasAtLimit then\n                    self:onMovingPartSoundEvent(tool, Cylindered.SOUND_ACTION_TOOL_MOVE_START_NEG_LIMIT, Cylindered.SOUND_TYPE_STARTING)\n                end\n            end\n        end\n    end\n\n"})}),"\n",(0,o.jsx)(e.h3,{id:"updaterotationbasedlimits",children:"updateRotationBasedLimits"}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Description"})}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Definition"})}),"\n",(0,o.jsxs)(e.blockquote,{children:["\n",(0,o.jsx)(e.p,{children:"updateRotationBasedLimits()"}),"\n"]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,o.jsxs)(e.table,{children:[(0,o.jsx)(e.thead,{children:(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.th,{children:"any"}),(0,o.jsx)(e.th,{children:"self"})]})}),(0,o.jsxs)(e.tbody,{children:[(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.td,{children:"any"}),(0,o.jsx)(e.td,{children:"tool"})]}),(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.td,{children:"any"}),(0,o.jsx)(e.td,{children:"dependentTool"})]})]})]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Code"})}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-lua",children:"function Cylindered.updateRotationBasedLimits( self , tool, dependentTool)\n    if dependentTool.rotationBasedLimits ~ = nil then\n        local state\n        if tool.isTool then\n            state = Cylindered.getMovingToolState( self , tool)\n        else\n                dependentTool.rotation[ 1 ], dependentTool.rotation[ 2 ], dependentTool.rotation[ 3 ] = getRotation(tool.node)\n                state = dependentTool.rotation[dependentTool.axis]\n            end\n\n            local minRot, maxRot, minTrans, maxTrans = dependentTool.rotationBasedLimits:get(state)\n\n            if minRot ~ = nil then\n                dependentTool.movingTool.rotMin = minRot\n            end\n            if maxRot ~ = nil then\n                dependentTool.movingTool.rotMax = maxRot\n            end\n            if minTrans ~ = nil then\n                dependentTool.movingTool.transMin = minTrans\n            end\n            if maxTrans ~ = nil then\n                dependentTool.movingTool.transMax = maxTrans\n            end\n\n            if self.isServer then\n                local isDirty = false\n                if minRot ~ = nil or maxRot ~ = nil then\n                    isDirty = isDirty or Cylindered.setToolRotation( self , dependentTool.movingTool, 0 , 0 )\n                end\n                if minTrans ~ = nil or maxTrans ~ = nil then\n                    isDirty = isDirty or Cylindered.setToolTranslation( self , dependentTool.movingTool, 0 , 0 )\n                end\n\n                if isDirty then\n                    Cylindered.setDirty( self , dependentTool.movingTool)\n\n                    -- sync the new limited rotation values and also the new rotation limits\n                    self:raiseDirtyFlags(dependentTool.movingTool.dirtyFlag)\n                    self:raiseDirtyFlags( self.spec_cylindered.cylinderedDirtyFlag)\n                end\n            else\n                    -- on client side the onUpdate is taking care to keep the tool in it's limits if the interpolator is correctly set\n                        if minRot ~ = nil or maxRot ~ = nil then\n                            dependentTool.movingTool.networkInterpolators.rotation:setMinMax(dependentTool.movingTool.rotMin, dependentTool.movingTool.rotMax)\n                        end\n                    end\n                end\n            end\n\n"})}),"\n",(0,o.jsx)(e.h3,{id:"updatewheels",children:"updateWheels"}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Description"})}),"\n",(0,o.jsxs)(e.blockquote,{children:["\n",(0,o.jsx)(e.p,{children:"Update wheel of part"}),"\n"]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Definition"})}),"\n",(0,o.jsxs)(e.blockquote,{children:["\n",(0,o.jsx)(e.p,{children:"updateWheels(table part, )"}),"\n"]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,o.jsxs)(e.table,{children:[(0,o.jsx)(e.thead,{children:(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.th,{children:"table"}),(0,o.jsx)(e.th,{children:"part"}),(0,o.jsx)(e.th,{children:"part"})]})}),(0,o.jsx)(e.tbody,{children:(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.td,{children:"any"}),(0,o.jsx)(e.td,{children:"part"}),(0,o.jsx)(e.td,{})]})})]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Code"})}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-lua",children:"function Cylindered.updateWheels( self , part)\n    if part.wheels ~ = nil then\n        for _, wheel in pairs(part.wheels) do\n            wheel.physics:updateShapePosition()\n\n            for _, wheelChock in ipairs(wheel.wheelChocks) do\n                wheelChock:update()\n            end\n        end\n    end\nend\n\n"})})]})}function h(n={}){const{wrapper:e}={...(0,l.R)(),...n.components};return e?(0,o.jsx)(e,{...n,children:(0,o.jsx)(c,{...n})}):c(n)}},28453(n,e,t){t.d(e,{R:()=>r,x:()=>a});var i=t(96540);const o={},l=i.createContext(o);function r(n){const e=i.useContext(l);return i.useMemo(function(){return"function"==typeof n?n(e):{...e,...n}},[e,n])}function a(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(o):n.components||o:r(n.components),i.createElement(l.Provider,{value:e},n.children)}}}]);