"use strict";(globalThis.webpackChunkfs25_community_luadoc=globalThis.webpackChunkfs25_community_luadoc||[]).push([[18137],{28453(e,n,t){t.d(n,{R:()=>r,x:()=>l});var a=t(96540);const s={},c=a.createContext(s);function r(e){const n=a.useContext(c);return a.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:r(e.components),a.createElement(c.Provider,{value:n},e.children)}},78482(e,n,t){t.r(n),t.d(n,{assets:()=>i,contentTitle:()=>l,default:()=>j,frontMatter:()=>r,metadata:()=>a,toc:()=>o});const a=JSON.parse('{"id":"script/Specializations/PlaceableObjectStorage","title":"PlaceableObjectStorage","description":"PlaceableObjectStorage","source":"@site/../docs/script/Specializations/PlaceableObjectStorage.md","sourceDirName":"script/Specializations","slug":"/script/Specializations/PlaceableObjectStorage","permalink":"/FS25-Community-LUADOC/script/Specializations/PlaceableObjectStorage","draft":false,"unlisted":false,"tags":[],"version":"current","lastUpdatedAt":1767161192000,"frontMatter":{},"sidebar":"docsSidebar","previous":{"title":"PlaceableNewFence","permalink":"/FS25-Community-LUADOC/script/Specializations/PlaceableNewFence"},"next":{"title":"PlaceablePalletBuyingStation","permalink":"/FS25-Community-LUADOC/script/Specializations/PlaceablePalletBuyingStation"}}');var s=t(74848),c=t(28453);const r={},l=void 0,i={},o=[{value:"PlaceableObjectStorage",id:"placeableobjectstorage",level:2},{value:"addAbstactObjectToObjectStorage",id:"addabstactobjecttoobjectstorage",level:3},{value:"addObjectToObjectStorage",id:"addobjecttoobjectstorage",level:3},{value:"canBeSold",id:"canbesold",level:3},{value:"getHasPendingManualStoreObjects",id:"gethaspendingmanualstoreobjects",level:3},{value:"getIsBaleSupportedByUnloadTrigger",id:"getisbalesupportedbyunloadtrigger",level:3},{value:"getObjectStorageCanStoreObject",id:"getobjectstoragecanstoreobject",level:3},{value:"getObjectStorageObjectInfos",id:"getobjectstorageobjectinfos",level:3},{value:"getObjectStorageSupportsFillType",id:"getobjectstoragesupportsfilltype",level:3},{value:"getObjectStorageSupportsObject",id:"getobjectstoragesupportsobject",level:3},{value:"getSpecValueCapacity",id:"getspecvaluecapacity",level:3},{value:"getSpecValueFillTypes",id:"getspecvaluefilltypes",level:3},{value:"initSpecialization",id:"initspecialization",level:3},{value:"loadFromXMLFile",id:"loadfromxmlfile",level:3},{value:"loadSpecValueCapacity",id:"loadspecvaluecapacity",level:3},{value:"loadSpecValueFillTypes",id:"loadspecvaluefilltypes",level:3},{value:"onDelete",id:"ondelete",level:3},{value:"onLoad",id:"onload",level:3},{value:"onObjectFromStorageSpawned",id:"onobjectfromstoragespawned",level:3},{value:"onObjectStoragePlayerTriggerCallback",id:"onobjectstorageplayertriggercallback",level:3},{value:"onObjectStorageSpawnOverlapCallback",id:"onobjectstoragespawnoverlapcallback",level:3},{value:"onReadStream",id:"onreadstream",level:3},{value:"onReadUpdateStream",id:"onreadupdatestream",level:3},{value:"onUpdate",id:"onupdate",level:3},{value:"onWriteStream",id:"onwritestream",level:3},{value:"onWriteUpdateStream",id:"onwriteupdatestream",level:3},{value:"prerequisitesPresent",id:"prerequisitespresent",level:3},{value:"registerEventListeners",id:"registereventlisteners",level:3},{value:"registerFunctions",id:"registerfunctions",level:3},{value:"registerOverwrittenFunctions",id:"registeroverwrittenfunctions",level:3},{value:"registerSavegameXMLPaths",id:"registersavegamexmlpaths",level:3},{value:"registerXMLPaths",id:"registerxmlpaths",level:3},{value:"removeAbstractObjectFromStorage",id:"removeabstractobjectfromstorage",level:3},{value:"removeAbstractObjectsFromStorage",id:"removeabstractobjectsfromstorage",level:3},{value:"saveToXMLFile",id:"savetoxmlfile",level:3},{value:"setObjectStorageObjectInfosDirty",id:"setobjectstorageobjectinfosdirty",level:3},{value:"spawnNextObjectStorageObject",id:"spawnnextobjectstorageobject",level:3},{value:"storePendingManualObjects",id:"storependingmanualobjects",level:3},{value:"updateDirtyObjectStorageObjectInfos",id:"updatedirtyobjectstorageobjectinfos",level:3},{value:"updateInfo",id:"updateinfo",level:3},{value:"updateManualStoreActivatable",id:"updatemanualstoreactivatable",level:3},{value:"updateObjectStorageObjectInfos",id:"updateobjectstorageobjectinfos",level:3},{value:"updateObjectStorageVisualAreas",id:"updateobjectstoragevisualareas",level:3}];function d(e){const n={a:"a",blockquote:"blockquote",code:"code",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,c.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.h2,{id:"placeableobjectstorage",children:"PlaceableObjectStorage"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"Specialization for placeable object storages which can store bales and pallets"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Functions"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#addabstactobjecttoobjectstorage",children:"addAbstactObjectToObjectStorage"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#addobjecttoobjectstorage",children:"addObjectToObjectStorage"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#canbesold",children:"canBeSold"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#gethaspendingmanualstoreobjects",children:"getHasPendingManualStoreObjects"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#getisbalesupportedbyunloadtrigger",children:"getIsBaleSupportedByUnloadTrigger"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#getobjectstoragecanstoreobject",children:"getObjectStorageCanStoreObject"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#getobjectstorageobjectinfos",children:"getObjectStorageObjectInfos"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#getobjectstoragesupportsfilltype",children:"getObjectStorageSupportsFillType"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#getobjectstoragesupportsobject",children:"getObjectStorageSupportsObject"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#getspecvaluecapacity",children:"getSpecValueCapacity"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#getspecvaluefilltypes",children:"getSpecValueFillTypes"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#initspecialization",children:"initSpecialization"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#loadfromxmlfile",children:"loadFromXMLFile"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#loadspecvaluecapacity",children:"loadSpecValueCapacity"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#loadspecvaluefilltypes",children:"loadSpecValueFillTypes"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#ondelete",children:"onDelete"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#onload",children:"onLoad"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#onobjectfromstoragespawned",children:"onObjectFromStorageSpawned"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#onobjectstorageplayertriggercallback",children:"onObjectStoragePlayerTriggerCallback"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#onobjectstoragespawnoverlapcallback",children:"onObjectStorageSpawnOverlapCallback"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#onreadstream",children:"onReadStream"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#onreadupdatestream",children:"onReadUpdateStream"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#onupdate",children:"onUpdate"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#onwritestream",children:"onWriteStream"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#onwriteupdatestream",children:"onWriteUpdateStream"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#prerequisitespresent",children:"prerequisitesPresent"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#registereventlisteners",children:"registerEventListeners"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#registerfunctions",children:"registerFunctions"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#registeroverwrittenfunctions",children:"registerOverwrittenFunctions"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#registersavegamexmlpaths",children:"registerSavegameXMLPaths"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#registerxmlpaths",children:"registerXMLPaths"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#removeabstractobjectfromstorage",children:"removeAbstractObjectFromStorage"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#removeabstractobjectsfromstorage",children:"removeAbstractObjectsFromStorage"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#savetoxmlfile",children:"saveToXMLFile"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#setobjectstorageobjectinfosdirty",children:"setObjectStorageObjectInfosDirty"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#spawnnextobjectstorageobject",children:"spawnNextObjectStorageObject"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#storependingmanualobjects",children:"storePendingManualObjects"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#updatedirtyobjectstorageobjectinfos",children:"updateDirtyObjectStorageObjectInfos"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#updateinfo",children:"updateInfo"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#updatemanualstoreactivatable",children:"updateManualStoreActivatable"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#updateobjectstorageobjectinfos",children:"updateObjectStorageObjectInfos"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#updateobjectstoragevisualareas",children:"updateObjectStorageVisualAreas"})}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"addabstactobjecttoobjectstorage",children:"addAbstactObjectToObjectStorage"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Definition"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"addAbstactObjectToObjectStorage()"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,s.jsx)(n.table,{children:(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"any"}),(0,s.jsx)(n.th,{children:"abstractObject"})]})})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Code"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:"function PlaceableObjectStorage:addAbstactObjectToObjectStorage(abstractObject)\n    local spec = self.spec_objectStorage\n    table.insert(spec.storedObjects, abstractObject)\n    spec.numStoredObjects = #spec.storedObjects\nend\n\n"})}),"\n",(0,s.jsx)(n.h3,{id:"addobjecttoobjectstorage",children:"addObjectToObjectStorage"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Definition"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"addObjectToObjectStorage()"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"any"}),(0,s.jsx)(n.th,{children:"object"})]})}),(0,s.jsx)(n.tbody,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"any"}),(0,s.jsx)(n.td,{children:"loadedFromSavegame"})]})})]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Code"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:"function PlaceableObjectStorage:addObjectToObjectStorage(object, loadedFromSavegame)\n    local abstractObjectClass = PlaceableObjectStorage.ABSTRACT_OBJECTS_BY_CLASS_NAME[ClassUtil.getClassNameByObject(object)]\n    if abstractObjectClass ~ = nil then\n        local abstractObject = abstractObjectClass.new()\n        abstractObject:addToStorage( self , object, loadedFromSavegame)\n        self:addAbstactObjectToObjectStorage(abstractObject)\n    end\nend\n\n"})}),"\n",(0,s.jsx)(n.h3,{id:"canbesold",children:"canBeSold"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Definition"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"canBeSold()"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,s.jsx)(n.table,{children:(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"any"}),(0,s.jsx)(n.th,{children:"superFunc"})]})})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Code"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:"function PlaceableObjectStorage:canBeSold(superFunc)\n    local spec = self.spec_objectStorage\n    if #spec.objectInfos > 0 then\n        return true , spec.texts.warningNotEmpty\n    end\n\n    return superFunc( self )\nend\n\n"})}),"\n",(0,s.jsx)(n.h3,{id:"gethaspendingmanualstoreobjects",children:"getHasPendingManualStoreObjects"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Definition"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"getHasPendingManualStoreObjects()"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Code"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:"function PlaceableObjectStorage:getHasPendingManualStoreObjects()\n    local spec = self.spec_objectStorage\n    for object, num in pairs(spec.pendingObjects) do\n        if num > 0 then\n            local canStoreObject, _ = self:getObjectStorageCanStoreObject(object, true )\n            if not canStoreObject then\n                canStoreObject, _ = self:getObjectStorageCanStoreObject(object, false )\n                if canStoreObject then\n                    return true\n                end\n            end\n        end\n    end\n\n    return false\nend\n\n"})}),"\n",(0,s.jsx)(n.h3,{id:"getisbalesupportedbyunloadtrigger",children:"getIsBaleSupportedByUnloadTrigger"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"Function used by the bale loader to know if the bale is supported"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Definition"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"getIsBaleSupportedByUnloadTrigger()"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,s.jsx)(n.table,{children:(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"any"}),(0,s.jsx)(n.th,{children:"bale"})]})})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Code"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:"function PlaceableObjectStorage:getIsBaleSupportedByUnloadTrigger(bale)\n    return self:getObjectStorageSupportsObject(bale)\nend\n\n"})}),"\n",(0,s.jsx)(n.h3,{id:"getobjectstoragecanstoreobject",children:"getObjectStorageCanStoreObject"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"Returns if the object can currently be stored (this may change during the time the object is in the trigger)"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Definition"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"getObjectStorageCanStoreObject()"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"any"}),(0,s.jsx)(n.th,{children:"object"})]})}),(0,s.jsx)(n.tbody,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"any"}),(0,s.jsx)(n.td,{children:"automatically"})]})})]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Code"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:"function PlaceableObjectStorage:getObjectStorageCanStoreObject(object, automatically)\n    local spec = self.spec_objectStorage\n\n    if spec.objectSpawn.isActive then\n        return false\n    end\n\n    if #spec.storedObjects > = spec.capacity then\n        return false , PlaceableObjectStorageErrorEvent.ERROR_STORAGE_IS_FULL\n    end\n\n    if #spec.supportedObjects > 0 then\n        local isSupported = false\n        local filename = object.configFileName or object.xmlFilename\n        for i = 1 , #spec.supportedObjects do\n            local supportedObject = spec.supportedObjects[i]\n            if filename:endsWith(supportedObject.filename) then\n                isSupported = true\n\n                local storedAmount = 0\n                for j = 1 , #spec.storedObjects do\n                    local objectFilename = spec.storedObjects[j]:getXMLFilename()\n                    if objectFilename = = filename then\n                        storedAmount = storedAmount + 1\n                    end\n                end\n\n                if storedAmount > = supportedObject.amount then\n                    return false , PlaceableObjectStorageErrorEvent.ERROR_MAX_AMOUNT_FOR_OBJECT_REACHED\n                end\n            end\n        end\n\n        if not isSupported then\n            return false , PlaceableObjectStorageErrorEvent.ERROR_OBJECT_NOT_SUPPORTED\n        end\n    end\n\n    local abstractObjectClass = PlaceableObjectStorage.ABSTRACT_OBJECTS_BY_CLASS_NAME[ClassUtil.getClassNameByObject(object)]\n    if abstractObjectClass ~ = nil then\n        if not abstractObjectClass.canStoreObject( self , object) then\n            return false\n        end\n\n        if automatically then\n            if not abstractObjectClass.canStoreObjectAutomatically( self , object) then\n                return false\n            end\n        end\n    end\n\n    return true\nend\n\n"})}),"\n",(0,s.jsx)(n.h3,{id:"getobjectstorageobjectinfos",children:"getObjectStorageObjectInfos"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Definition"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"getObjectStorageObjectInfos()"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Code"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:"function PlaceableObjectStorage:getObjectStorageObjectInfos()\n    return self.spec_objectStorage.objectInfos\nend\n\n"})}),"\n",(0,s.jsx)(n.h3,{id:"getobjectstoragesupportsfilltype",children:"getObjectStorageSupportsFillType"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Definition"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"getObjectStorageSupportsFillType()"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,s.jsx)(n.table,{children:(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"any"}),(0,s.jsx)(n.th,{children:"fillTypeIndex"})]})})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Code"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:"function PlaceableObjectStorage:getObjectStorageSupportsFillType(fillTypeIndex)\n    local spec = self.spec_objectStorage\n    if fillTypeIndex = = nil or fillTypeIndex = = FillType.UNKNOWN then\n        return #spec.supportedFillTypes = = 0\n    else\n            local found = #spec.supportedFillTypes = = 0\n            for i = 1 , #spec.supportedFillTypes do\n                if fillTypeIndex = = spec.supportedFillTypes[i] then\n                    found = true\n                end\n            end\n\n            if not found then\n                return false\n            end\n        end\n\n        return true\n    end\n\n"})}),"\n",(0,s.jsx)(n.h3,{id:"getobjectstoragesupportsobject",children:"getObjectStorageSupportsObject"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"Returns if the object is supported at all"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Definition"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"getObjectStorageSupportsObject()"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,s.jsx)(n.table,{children:(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"any"}),(0,s.jsx)(n.th,{children:"object"})]})})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Code"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:"function PlaceableObjectStorage:getObjectStorageSupportsObject(object)\n    local spec = self.spec_objectStorage\n\n    local abstractObjectClass = PlaceableObjectStorage.ABSTRACT_OBJECTS_BY_CLASS_NAME[ClassUtil.getClassNameByObject(object)]\n    if abstractObjectClass ~ = nil then\n        if not abstractObjectClass.isObjectSupported( self , object) then\n            return false\n        end\n    end\n\n    for i = 1 , #spec.storedObjects do\n        if object = = spec.storedObjects[i]:getRealObject() then\n            return false\n        end\n    end\n\n    return true\nend\n\n"})}),"\n",(0,s.jsx)(n.h3,{id:"getspecvaluecapacity",children:"getSpecValueCapacity"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Definition"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"getSpecValueCapacity()"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"any"}),(0,s.jsx)(n.th,{children:"storeItem"})]})}),(0,s.jsx)(n.tbody,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"any"}),(0,s.jsx)(n.td,{children:"realItem"})]})})]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Code"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:'function PlaceableObjectStorage.getSpecValueCapacity(storeItem, realItem)\n    if storeItem.specs.objectStorageCapacity = = nil then\n        return nil\n    end\n\n    return string.format( "%d %s" , storeItem.specs.objectStorageCapacity, g_i18n:getText( "unit_pieces" ))\nend\n\n'})}),"\n",(0,s.jsx)(n.h3,{id:"getspecvaluefilltypes",children:"getSpecValueFillTypes"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Definition"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"getSpecValueFillTypes()"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"any"}),(0,s.jsx)(n.th,{children:"storeItem"})]})}),(0,s.jsx)(n.tbody,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"any"}),(0,s.jsx)(n.td,{children:"realItem"})]})})]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Code"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:"function PlaceableObjectStorage.getSpecValueFillTypes(storeItem, realItem)\n    local fillTypes = storeItem.specs.objectStorageFillTypes\n    if fillTypes = = nil or #fillTypes = = 0 then\n        return nil\n    end\n\n    return fillTypes\nend\n\n"})}),"\n",(0,s.jsx)(n.h3,{id:"initspecialization",children:"initSpecialization"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Definition"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"initSpecialization()"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Code"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:'function PlaceableObjectStorage.initSpecialization()\n    g_storeManager:addSpecType( "objectStorageCapacity" , "shopListAttributeIconCapacity" , PlaceableObjectStorage.loadSpecValueCapacity, PlaceableObjectStorage.getSpecValueCapacity, StoreSpecies.PLACEABLE)\n    g_storeManager:addSpecType( "objectStorageFillTypes" , "shopListAttributeIconFillTypes" , PlaceableObjectStorage.loadSpecValueFillTypes, PlaceableObjectStorage.getSpecValueFillTypes, StoreSpecies.PLACEABLE)\nend\n\n'})}),"\n",(0,s.jsx)(n.h3,{id:"loadfromxmlfile",children:"loadFromXMLFile"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Definition"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"loadFromXMLFile()"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"any"}),(0,s.jsx)(n.th,{children:"xmlFile"})]})}),(0,s.jsx)(n.tbody,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"any"}),(0,s.jsx)(n.td,{children:"key"})]})})]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Code"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:'function PlaceableObjectStorage:loadFromXMLFile(xmlFile, key)\n    xmlFile:iterate(key .. ".object" , function (index, objectKey)\n        local className = xmlFile:getValue(objectKey .. "#className" )\n        if className ~ = nil then\n            local abstractObjectClass = PlaceableObjectStorage.ABSTRACT_OBJECTS_BY_CLASS_NAME[className]\n            if abstractObjectClass ~ = nil then\n                abstractObjectClass.loadFromXMLFile( self , xmlFile, objectKey)\n            end\n        else\n                Logging.xmlWarning(xmlFile, "Unable to find object class \'%s\' for stored object in \'%s\'" , className, objectKey)\n                end\n            end )\n\n            self:setObjectStorageObjectInfosDirty()\n        end\n\n'})}),"\n",(0,s.jsx)(n.h3,{id:"loadspecvaluecapacity",children:"loadSpecValueCapacity"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Definition"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"loadSpecValueCapacity()"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"any"}),(0,s.jsx)(n.th,{children:"xmlFile"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"any"}),(0,s.jsx)(n.td,{children:"customEnvironment"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"any"}),(0,s.jsx)(n.td,{children:"baseDir"})]})]})]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Code"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:'function PlaceableObjectStorage.loadSpecValueCapacity(xmlFile, customEnvironment, baseDir)\n    if not xmlFile:hasProperty( "placeable.objectStorage" ) then\n        return nil\n    end\n\n    local totalCapacity = xmlFile:getValue( "placeable.objectStorage#capacity" , 250 )\n\n    local limitedObjectAmount = 0\n    xmlFile:iterate( "placeable.objectStorage.supportedObject" , function (index, objectKey)\n        if xmlFile:getValue(objectKey .. "#filename" ) ~ = nil then\n            limitedObjectAmount = limitedObjectAmount + xmlFile:getValue(objectKey .. "#amount" )\n        end\n    end )\n\n    if limitedObjectAmount > 0 then\n        totalCapacity = math.min(totalCapacity, limitedObjectAmount)\n    end\n\n    return totalCapacity\nend\n\n'})}),"\n",(0,s.jsx)(n.h3,{id:"loadspecvaluefilltypes",children:"loadSpecValueFillTypes"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Definition"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"loadSpecValueFillTypes()"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"any"}),(0,s.jsx)(n.th,{children:"xmlFile"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"any"}),(0,s.jsx)(n.td,{children:"customEnvironment"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"any"}),(0,s.jsx)(n.td,{children:"baseDir"})]})]})]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Code"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:'function PlaceableObjectStorage.loadSpecValueFillTypes(xmlFile, customEnvironment, baseDir)\n    local fillTypes = { }\n\n    xmlFile:iterate( "placeable.objectStorage.supportedObject" , function (index, objectKey)\n        local fillTypeName = xmlFile:getValue(objectKey .. "#fillType" )\n        if fillTypeName ~ = nil then\n            local fillTypeIndex = g_fillTypeManager:getFillTypeIndexByName( string.upper(fillTypeName))\n            if fillTypeIndex ~ = nil then\n                table.insert(fillTypes, fillTypeIndex)\n            end\n        end\n    end )\n\n    return fillTypes\nend\n\n'})}),"\n",(0,s.jsx)(n.h3,{id:"ondelete",children:"onDelete"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Definition"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"onDelete()"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Code"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:"function PlaceableObjectStorage:onDelete()\n    local spec = self.spec_objectStorage\n    if spec.playerTriggerNode ~ = nil then\n        removeTrigger(spec.playerTriggerNode)\n    end\n\n    if spec.objectTriggerNode ~ = nil then\n        removeTrigger(spec.objectTriggerNode)\n    end\n\n    if spec.storedObjects ~ = nil then\n        for i = #spec.storedObjects, 1 , - 1 do\n            spec.storedObjects[i]:delete()\n            spec.storedObjects[i] = nil\n        end\n    end\n\n    spec.numStoredObjects = 0\n\n    if spec.pendingObjects ~ = nil then\n        for object, _ in pairs(spec.pendingObjects) do\n            object:removeDeleteListener( self , PlaceableObjectStorage.onPendingObjectDelete)\n            spec.pendingObjects[object] = nil\n        end\n    end\n\n    g_currentMission.activatableObjectsSystem:removeActivatable(spec.activatable)\n    g_currentMission.activatableObjectsSystem:removeActivatable(spec.manualStoreActivatable)\nend\n\n"})}),"\n",(0,s.jsx)(n.h3,{id:"onload",children:"onLoad"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"Called on loading"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Definition"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"onLoad(table savegame)"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n",(0,s.jsx)(n.table,{children:(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"table"}),(0,s.jsx)(n.th,{children:"savegame"}),(0,s.jsx)(n.th,{children:"savegame"})]})})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Code"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:'function PlaceableObjectStorage:onLoad(savegame)\n    local spec = self.spec_objectStorage\n\n    spec.playerTriggerNode = self.xmlFile:getValue( "placeable.objectStorage.playerTrigger#node" , nil , self.components, self.i3dMappings)\n    if spec.playerTriggerNode ~ = nil then\n        addTrigger(spec.playerTriggerNode, "onObjectStoragePlayerTriggerCallback" , self )\n    else\n            Logging.xmlWarning( self.xmlFile, "Missing player trigger for object storage" )\n            end\n\n            if self.isServer then\n                spec.objectTriggerNode = self.xmlFile:getValue( "placeable.objectStorage.objectTrigger#node" , nil , self.components, self.i3dMappings)\n                if spec.objectTriggerNode ~ = nil then\n                    addTrigger(spec.objectTriggerNode, "onObjectStorageObjectTriggerCallback" , self )\n                else\n                        Logging.xmlWarning( self.xmlFile, "Missing object trigger for object storage" )\n                        end\n                    end\n\n                    spec.supportedFillTypes = g_fillTypeManager:getFillTypesFromXML( self.xmlFile, "placeable.objectStorage#fillTypeCategories" , "placeable.objectStorage#fillTypes" , false )\n\n                    spec.supportsBales = self.xmlFile:getValue( "placeable.objectStorage#supportsBales" , true )\n                    spec.supportsPallets = self.xmlFile:getValue( "placeable.objectStorage#supportsPallets" , true )\n\n                    spec.supportedObjects = { }\n                    self.xmlFile:iterate( "placeable.objectStorage.supportedObject" , function (index, objectKey)\n                        local entry = { }\n                        entry.filename = self.xmlFile:getValue(objectKey .. "#filename" )\n                        if entry.filename ~ = nil then\n                            entry.amount = self.xmlFile:getValue(objectKey .. "#amount" , math.huge)\n\n                            table.insert(spec.supportedObjects, entry)\n                        end\n                    end )\n\n                    spec.capacity = self.xmlFile:getValue( "placeable.objectStorage#capacity" , 250 )\n                    spec.maxLength = self.xmlFile:getValue( "placeable.objectStorage#maxLength" , math.huge)\n                    spec.maxHeight = self.xmlFile:getValue( "placeable.objectStorage#maxHeight" , math.huge)\n                    spec.maxWidth = self.xmlFile:getValue( "placeable.objectStorage#maxWidth" , math.huge)\n                    spec.maxUnloadAmount = self.xmlFile:getValue( "placeable.objectStorage#maxUnloadAmount" , 25 )\n\n                    spec.objectSpawn = { }\n                    spec.objectSpawn.isActive = false\n                    spec.objectSpawn.connection = nil\n                    spec.objectSpawn.objectInfoIndex = 1\n                    spec.objectSpawn.numObjectsToSpawn = 0\n                    spec.objectSpawn.overlapIsActive = false\n                    spec.objectSpawn.overlapObjectCount = 0\n                    spec.objectSpawn.nextSpawnPosition = { 0 , 0 , 0 }\n                    spec.objectSpawn.spawnAreaIndex = 1\n                    spec.objectSpawn.spawnAreaData = { 0 , 0 , 0 , 0 , 0 , 1 }\n                    spec.objectSpawn.spawnedObjects = { }\n\n                    spec.objectSpawn.area = { }\n                    self.xmlFile:iterate( "placeable.objectStorage.spawnAreas.spawnArea" , function (index, areaKey)\n                        local spawnArea = { }\n                        spawnArea.startNode = self.xmlFile:getValue(areaKey .. "#startNode" , nil , self.components, self.i3dMappings)\n                        spawnArea.endNode = self.xmlFile:getValue(areaKey .. "#endNode" , nil , self.components, self.i3dMappings)\n                        if spawnArea.startNode ~ = nil and spawnArea.endNode ~ = nil then\n                            local _\n                            spawnArea.sizeX, _, spawnArea.sizeZ = localToLocal(spawnArea.endNode, spawnArea.startNode, 0 , 0 , 0 )\n                            spawnArea.maxHeight = self.xmlFile:getValue(areaKey .. "#maxHeight" , 3 )\n                            table.insert(spec.objectSpawn.area, spawnArea)\n                        else\n                                Logging.xmlWarning( self.xmlFile, "Incomplete spawn area definition in \'%s\'" , areaKey)\n                            end\n                        end )\n\n                        spec.storageArea = { }\n                        spec.storageArea.spawnNode = createTransformGroup( "storageAreaSpawnNode" )\n                        link( self.rootNode, spec.storageArea.spawnNode)\n                        spec.storageArea.spawnAreaIndex = 1\n                        spec.storageArea.spawnAreaData = { 0 , 0 , 0 , 0 , 0 , 1 }\n                        spec.storageArea.area = { }\n                        self.xmlFile:iterate( "placeable.objectStorage.storageAreas.storageArea" , function (index, areaKey)\n                            local storageArea = { }\n                            storageArea.startNode = self.xmlFile:getValue(areaKey .. "#startNode" , nil , self.components, self.i3dMappings)\n                            storageArea.endNode = self.xmlFile:getValue(areaKey .. "#endNode" , nil , self.components, self.i3dMappings)\n                            if storageArea.startNode ~ = nil and storageArea.endNode ~ = nil then\n                                local _\n                                storageArea.sizeX, _, storageArea.sizeZ = localToLocal(storageArea.endNode, storageArea.startNode, 0 , 0 , 0 )\n                                storageArea.maxHeight = self.xmlFile:getValue(areaKey .. "#maxHeight" , 3 )\n                                table.insert(spec.storageArea.area, storageArea)\n                            else\n                                    Logging.xmlWarning( self.xmlFile, "Incomplete spawn area definition in \'%s\'" , areaKey)\n                                end\n                            end )\n\n                            spec.storedObjects = { }\n                            spec.objectInfos = { }\n                            spec.pendingObjects = { }\n\n                            spec.lastPendingManualObjectsState = false\n                            spec.numStoredObjects = 0\n\n                            spec.objectInfosUpdateTimer = 0\n                            spec.pendingVisualAreaUpdates = { }\n\n                            spec.texts = { }\n                            spec.texts.warningNotEmpty = g_i18n:getText( "info_objectStorageNotEmpty" )\n                            spec.texts.totalCapacity = g_i18n:getText( "ui_silos_totalCapacity" )\n                            spec.texts.otherElements = g_i18n:getText( "helpLine_IconOverview_Others" )\n\n                            spec.activatable = PlaceableObjectStorageActivatable.new( self )\n                            spec.manualStoreActivatable = PlaceableObjectStorageManualStoreActivatable.new( self )\n                            spec.dirtyFlag = self:getNextDirtyFlag()\n                        end\n\n'})}),"\n",(0,s.jsx)(n.h3,{id:"onobjectfromstoragespawned",children:"onObjectFromStorageSpawned"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Definition"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"onObjectFromStorageSpawned()"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"any"}),(0,s.jsx)(n.th,{children:"self"})]})}),(0,s.jsx)(n.tbody,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"any"}),(0,s.jsx)(n.td,{children:"spawnedObject"})]})})]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Code"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:"function PlaceableObjectStorage.onObjectFromStorageSpawned( self , spawnedObject)\n    local spec = self.spec_objectStorage\n    if spec.objectSpawn.isActive then\n        table.insert(spec.objectSpawn.spawnedObjects, spawnedObject)\n    end\nend\n\n"})}),"\n",(0,s.jsx)(n.h3,{id:"onobjectstorageplayertriggercallback",children:"onObjectStoragePlayerTriggerCallback"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Definition"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"onObjectStoragePlayerTriggerCallback()"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"any"}),(0,s.jsx)(n.th,{children:"triggerId"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"any"}),(0,s.jsx)(n.td,{children:"otherId"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"any"}),(0,s.jsx)(n.td,{children:"onEnter"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"any"}),(0,s.jsx)(n.td,{children:"onLeave"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"any"}),(0,s.jsx)(n.td,{children:"onStay"})]})]})]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Code"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:"function PlaceableObjectStorage:onObjectStoragePlayerTriggerCallback(triggerId, otherId, onEnter, onLeave, onStay)\n    if g_localPlayer ~ = nil and otherId = = g_localPlayer.rootNode then\n        local spec = self.spec_objectStorage\n        if onEnter then\n            g_currentMission.activatableObjectsSystem:addActivatable(spec.activatable)\n        elseif onLeave then\n                g_currentMission.activatableObjectsSystem:removeActivatable(spec.activatable)\n            end\n        end\n    end\n\n"})}),"\n",(0,s.jsx)(n.h3,{id:"onobjectstoragespawnoverlapcallback",children:"onObjectStorageSpawnOverlapCallback"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Definition"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"onObjectStorageSpawnOverlapCallback()"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,s.jsx)(n.table,{children:(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"any"}),(0,s.jsx)(n.th,{children:"objectId"})]})})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Code"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:"function PlaceableObjectStorage:onObjectStorageSpawnOverlapCallback(objectId)\n    local spec = self.spec_objectStorage\n    spec.objectSpawn.overlapIsActive = false\n    if objectId ~ = 0 and not getHasTrigger(objectId) then\n        local object = g_currentMission:getNodeObject(objectId)\n        if object ~ = nil then\n            for i = 1 , #spec.objectSpawn.spawnedObjects do\n                if object = = spec.objectSpawn.spawnedObjects[i] then\n                    return -- ignore slight collisions with just spawned objects\n                end\n            end\n        end\n\n        spec.objectSpawn.overlapObjectCount = spec.objectSpawn.overlapObjectCount + 1\n    end\nend\n\n"})}),"\n",(0,s.jsx)(n.h3,{id:"onreadstream",children:"onReadStream"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Definition"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"onReadStream()"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"any"}),(0,s.jsx)(n.th,{children:"streamId"})]})}),(0,s.jsx)(n.tbody,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"any"}),(0,s.jsx)(n.td,{children:"connection"})]})})]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Code"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:"function PlaceableObjectStorage:onReadStream(streamId, connection)\n    if connection:getIsServer() then\n        local spec = self.spec_objectStorage\n        spec.objectInfos = { }\n\n        local numObjectInfos = streamReadUIntN(streamId, PlaceableObjectStorage.NUM_BITS_OBJECT_INFO)\n        for i = 1 , numObjectInfos do\n            local objectInfo = { }\n            objectInfo.numObjects = streamReadUIntN(streamId, PlaceableObjectStorage.NUM_BITS_AMOUNT)\n            local abstractObjectId = streamReadUIntN(streamId, 2 )\n\n            local abstractObjectClass = PlaceableObjectStorage.ABSTRACT_OBJECTS_BY_ID[abstractObjectId]\n            objectInfo.objects = { abstractObjectClass.readStream(streamId, connection) }\n\n            table.insert(spec.objectInfos, objectInfo)\n        end\n\n        spec.numStoredObjects = 0\n        for i = 1 , #spec.objectInfos do\n            spec.numStoredObjects = spec.numStoredObjects + spec.objectInfos[i].numObjects\n        end\n\n        self:updateObjectStorageVisualAreas()\n    end\nend\n\n"})}),"\n",(0,s.jsx)(n.h3,{id:"onreadupdatestream",children:"onReadUpdateStream"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Definition"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"onReadUpdateStream()"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"any"}),(0,s.jsx)(n.th,{children:"streamId"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"any"}),(0,s.jsx)(n.td,{children:"timestamp"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"any"}),(0,s.jsx)(n.td,{children:"connection"})]})]})]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Code"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:"function PlaceableObjectStorage:onReadUpdateStream(streamId, timestamp, connection)\n    if connection:getIsServer() then\n        if streamReadBool(streamId) then\n            PlaceableObjectStorage.onReadStream( self , streamId, connection)\n        end\n\n        local spec = self.spec_objectStorage\n        if streamReadBool(streamId) then\n            g_currentMission.activatableObjectsSystem:addActivatable(spec.manualStoreActivatable)\n        else\n                g_currentMission.activatableObjectsSystem:removeActivatable(spec.manualStoreActivatable)\n            end\n        end\n    end\n\n"})}),"\n",(0,s.jsx)(n.h3,{id:"onupdate",children:"onUpdate"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Definition"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"onUpdate()"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,s.jsx)(n.table,{children:(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"any"}),(0,s.jsx)(n.th,{children:"dt"})]})})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Code"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:"function PlaceableObjectStorage:onUpdate(dt)\n    local spec = self.spec_objectStorage\n    if self.isServer then\n        if spec.objectSpawn.isActive then\n            if not spec.objectSpawn.overlapIsActive then\n                if spec.objectSpawn.overlapObjectCount = = 0 then\n                    local spawnArea = spec.objectSpawn.area[spec.objectSpawn.spawnAreaIndex]\n                    local objectInfo = spec.objectInfos[spec.objectSpawn.objectInfoIndex]\n                    local objectToSpawn = objectInfo.objects[ 1 ]\n\n                    local ox, oy, oz, _, _, _, _ = objectToSpawn:getSpawnInfo()\n                    local cx, cy, cz = localToWorld(spawnArea.startNode, spec.objectSpawn.nextSpawnPosition[ 1 ] + ox, spec.objectSpawn.nextSpawnPosition[ 2 ] + oy, spec.objectSpawn.nextSpawnPosition[ 3 ] + oz)\n                    local rx, ry, rz = getWorldRotation(spawnArea.startNode)\n\n                    if objectToSpawn ~ = nil then\n                        self:removeAbstractObjectFromStorage(objectToSpawn, cx, cy, cz, rx, ry, rz)\n                        table.remove(objectInfo.objects, 1 )\n                    end\n\n                    spec.objectSpawn.numObjectsToSpawn = spec.objectSpawn.numObjectsToSpawn - 1\n                end\n\n                self:spawnNextObjectStorageObject(spec.objectSpawn.overlapObjectCount = = 0 )\n            end\n\n            self:raiseActive()\n        end\n\n        for object, _ in pairs(spec.pendingObjects) do\n            local canStoreObject, _ = self:getObjectStorageCanStoreObject(object, true ) -- here we ignore the potential errorId provided - we only show it once entering the trigger\n            if canStoreObject then\n                self:addObjectToObjectStorage(object)\n                self:setObjectStorageObjectInfosDirty()\n\n                spec.pendingObjects[object] = nil\n                object:removeDeleteListener( self , PlaceableObjectStorage.onPendingObjectDelete)\n\n                self:updateManualStoreActivatable()\n            else\n                    self:raiseActive()\n                end\n            end\n        end\n\n        if spec.objectInfosUpdateTimer > 0 then\n            spec.objectInfosUpdateTimer = spec.objectInfosUpdateTimer - dt\n            if spec.objectInfosUpdateTimer < = 0 then\n                self:updateObjectStorageObjectInfos()\n                self:updateObjectStorageVisualAreas()\n                self:raiseDirtyFlags(spec.dirtyFlag)\n\n                spec.objectInfosUpdateTimer = 0\n            end\n            self:raiseActive()\n        end\n\n        for i = #spec.pendingVisualAreaUpdates, 1 , - 1 do\n            local pendingVisualAreaUpdate = spec.pendingVisualAreaUpdates[i]\n            if not pendingVisualAreaUpdate.spawnNextObjectInfo() then\n                table.remove(spec.pendingVisualAreaUpdates, i)\n            else\n                    self:raiseActive()\n                end\n            end\n        end\n\n"})}),"\n",(0,s.jsx)(n.h3,{id:"onwritestream",children:"onWriteStream"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Definition"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"onWriteStream()"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"any"}),(0,s.jsx)(n.th,{children:"streamId"})]})}),(0,s.jsx)(n.tbody,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"any"}),(0,s.jsx)(n.td,{children:"connection"})]})})]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Code"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:"function PlaceableObjectStorage:onWriteStream(streamId, connection)\n    if not connection:getIsServer() then\n        local spec = self.spec_objectStorage\n\n        local objectInfos = spec.objectInfos\n        streamWriteUIntN(streamId, #objectInfos, PlaceableObjectStorage.NUM_BITS_OBJECT_INFO)\n\n        for i = 1 , #objectInfos do\n            local objectInfo = objectInfos[i]\n            streamWriteUIntN(streamId, objectInfo.numObjects, PlaceableObjectStorage.NUM_BITS_AMOUNT)\n            streamWriteUIntN(streamId, objectInfo.objects[ 1 ].ABSTRACT_OBJECT_ID, 2 )\n            objectInfo.objects[ 1 ]:writeStream(streamId, connection)\n        end\n    end\nend\n\n"})}),"\n",(0,s.jsx)(n.h3,{id:"onwriteupdatestream",children:"onWriteUpdateStream"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Definition"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"onWriteUpdateStream()"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"any"}),(0,s.jsx)(n.th,{children:"streamId"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"any"}),(0,s.jsx)(n.td,{children:"connection"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"any"}),(0,s.jsx)(n.td,{children:"dirtyMask"})]})]})]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Code"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:"function PlaceableObjectStorage:onWriteUpdateStream(streamId, connection, dirtyMask)\n    if not connection:getIsServer() then\n        if streamWriteBool(streamId, bit32.band(dirtyMask, self.spec_objectStorage.dirtyFlag) ~ = 0 ) then\n            PlaceableObjectStorage.onWriteStream( self , streamId, connection)\n        end\n\n        streamWriteBool(streamId, self:getHasPendingManualStoreObjects())\n    end\nend\n\n"})}),"\n",(0,s.jsx)(n.h3,{id:"prerequisitespresent",children:"prerequisitesPresent"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"Checks if all prerequisite specializations are loaded"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Definition"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"prerequisitesPresent(table specializations)"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n",(0,s.jsx)(n.table,{children:(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"table"}),(0,s.jsx)(n.th,{children:"specializations"}),(0,s.jsx)(n.th,{children:"specializations"})]})})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Return Values"})}),"\n\n\n\n\n\n\n\n\n",(0,s.jsx)(n.table,{children:(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"table"}),(0,s.jsx)(n.th,{children:"hasPrerequisite"}),(0,s.jsx)(n.th,{children:"true if all prerequisite specializations are loaded"})]})})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Code"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:"function PlaceableObjectStorage.prerequisitesPresent(specializations)\n    return true\nend\n\n"})}),"\n",(0,s.jsx)(n.h3,{id:"registereventlisteners",children:"registerEventListeners"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Definition"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"registerEventListeners()"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,s.jsx)(n.table,{children:(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"any"}),(0,s.jsx)(n.th,{children:"placeableType"})]})})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Code"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:'function PlaceableObjectStorage.registerEventListeners(placeableType)\n    SpecializationUtil.registerEventListener(placeableType, "onLoad" , PlaceableObjectStorage )\n    SpecializationUtil.registerEventListener(placeableType, "onDelete" , PlaceableObjectStorage )\n    SpecializationUtil.registerEventListener(placeableType, "onReadStream" , PlaceableObjectStorage )\n    SpecializationUtil.registerEventListener(placeableType, "onWriteStream" , PlaceableObjectStorage )\n    SpecializationUtil.registerEventListener(placeableType, "onReadUpdateStream" , PlaceableObjectStorage )\n    SpecializationUtil.registerEventListener(placeableType, "onWriteUpdateStream" , PlaceableObjectStorage )\n    SpecializationUtil.registerEventListener(placeableType, "onUpdate" , PlaceableObjectStorage )\nend\n\n'})}),"\n",(0,s.jsx)(n.h3,{id:"registerfunctions",children:"registerFunctions"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Definition"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"registerFunctions()"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,s.jsx)(n.table,{children:(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"any"}),(0,s.jsx)(n.th,{children:"placeableType"})]})})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Code"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:'function PlaceableObjectStorage.registerFunctions(placeableType)\n    SpecializationUtil.registerFunction(placeableType, "getObjectStorageSupportsFillType" , PlaceableObjectStorage.getObjectStorageSupportsFillType)\n    SpecializationUtil.registerFunction(placeableType, "getObjectStorageSupportsObject" , PlaceableObjectStorage.getObjectStorageSupportsObject)\n    SpecializationUtil.registerFunction(placeableType, "getObjectStorageCanStoreObject" , PlaceableObjectStorage.getObjectStorageCanStoreObject)\n    SpecializationUtil.registerFunction(placeableType, "getIsBaleSupportedByUnloadTrigger" , PlaceableObjectStorage.getIsBaleSupportedByUnloadTrigger)\n    SpecializationUtil.registerFunction(placeableType, "addObjectToObjectStorage" , PlaceableObjectStorage.addObjectToObjectStorage)\n    SpecializationUtil.registerFunction(placeableType, "addAbstactObjectToObjectStorage" , PlaceableObjectStorage.addAbstactObjectToObjectStorage)\n    SpecializationUtil.registerFunction(placeableType, "removeAbstractObjectsFromStorage" , PlaceableObjectStorage.removeAbstractObjectsFromStorage)\n    SpecializationUtil.registerFunction(placeableType, "spawnNextObjectStorageObject" , PlaceableObjectStorage.spawnNextObjectStorageObject)\n    SpecializationUtil.registerFunction(placeableType, "removeAbstractObjectFromStorage" , PlaceableObjectStorage.removeAbstractObjectFromStorage)\n    SpecializationUtil.registerFunction(placeableType, "setObjectStorageObjectInfosDirty" , PlaceableObjectStorage.setObjectStorageObjectInfosDirty)\n    SpecializationUtil.registerFunction(placeableType, "updateDirtyObjectStorageObjectInfos" , PlaceableObjectStorage.updateDirtyObjectStorageObjectInfos)\n    SpecializationUtil.registerFunction(placeableType, "updateObjectStorageObjectInfos" , PlaceableObjectStorage.updateObjectStorageObjectInfos)\n    SpecializationUtil.registerFunction(placeableType, "getObjectStorageObjectInfos" , PlaceableObjectStorage.getObjectStorageObjectInfos)\n    SpecializationUtil.registerFunction(placeableType, "updateObjectStorageVisualAreas" , PlaceableObjectStorage.updateObjectStorageVisualAreas)\n    SpecializationUtil.registerFunction(placeableType, "getHasPendingManualStoreObjects" , PlaceableObjectStorage.getHasPendingManualStoreObjects)\n    SpecializationUtil.registerFunction(placeableType, "storePendingManualObjects" , PlaceableObjectStorage.storePendingManualObjects)\n    SpecializationUtil.registerFunction(placeableType, "updateManualStoreActivatable" , PlaceableObjectStorage.updateManualStoreActivatable)\n    SpecializationUtil.registerFunction(placeableType, "onObjectStoragePlayerTriggerCallback" , PlaceableObjectStorage.onObjectStoragePlayerTriggerCallback)\n    SpecializationUtil.registerFunction(placeableType, "onObjectStorageObjectTriggerCallback" , PlaceableObjectStorage.onObjectStorageObjectTriggerCallback)\n    SpecializationUtil.registerFunction(placeableType, "onObjectStorageSpawnOverlapCallback" , PlaceableObjectStorage.onObjectStorageSpawnOverlapCallback)\nend\n\n'})}),"\n",(0,s.jsx)(n.h3,{id:"registeroverwrittenfunctions",children:"registerOverwrittenFunctions"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Definition"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"registerOverwrittenFunctions()"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,s.jsx)(n.table,{children:(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"any"}),(0,s.jsx)(n.th,{children:"placeableType"})]})})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Code"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:'function PlaceableObjectStorage.registerOverwrittenFunctions(placeableType)\n    SpecializationUtil.registerOverwrittenFunction(placeableType, "canBeSold" , PlaceableObjectStorage.canBeSold)\n    SpecializationUtil.registerOverwrittenFunction(placeableType, "updateInfo" , PlaceableObjectStorage.updateInfo)\nend\n\n'})}),"\n",(0,s.jsx)(n.h3,{id:"registersavegamexmlpaths",children:"registerSavegameXMLPaths"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Definition"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"registerSavegameXMLPaths()"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"any"}),(0,s.jsx)(n.th,{children:"schema"})]})}),(0,s.jsx)(n.tbody,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"any"}),(0,s.jsx)(n.td,{children:"basePath"})]})})]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Code"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:'function PlaceableObjectStorage.registerSavegameXMLPaths(schema, basePath)\n    schema:register(XMLValueType.STRING, basePath .. ".object(?)#className" , "Object class name" )\n    for _, abstractObject in pairs( PlaceableObjectStorage.ABSTRACT_OBJECTS) do\n        abstractObject.registerXMLPaths(schema, basePath .. ".object(?)" )\n    end\nend\n\n'})}),"\n",(0,s.jsx)(n.h3,{id:"registerxmlpaths",children:"registerXMLPaths"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Definition"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"registerXMLPaths()"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"any"}),(0,s.jsx)(n.th,{children:"schema"})]})}),(0,s.jsx)(n.tbody,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"any"}),(0,s.jsx)(n.td,{children:"basePath"})]})})]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Code"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:'function PlaceableObjectStorage.registerXMLPaths(schema, basePath)\n    schema:setXMLSpecializationType( "ObjectStorage" )\n\n    schema:register(XMLValueType.NODE_INDEX, basePath .. ".objectStorage.playerTrigger#node" , "Player trigger node" )\n    schema:register(XMLValueType.NODE_INDEX, basePath .. ".objectStorage.objectTrigger#node" , "Object trigger node" )\n\n    schema:register(XMLValueType.STRING, basePath .. ".objectStorage#fillTypeCategories" , "List of supported fill type categories(if no fill types defined, all are allowed)" )\n        schema:register(XMLValueType.STRING, basePath .. ".objectStorage#fillTypes" , "List of supported fill types(if no fill types defined, all are allowed)" )\n\n            schema:register(XMLValueType.BOOL, basePath .. ".objectStorage#supportsBales" , "Bales can be stored" , true )\n            schema:register(XMLValueType.BOOL, basePath .. ".objectStorage#supportsPallets" , "Pallets can be stored" , true )\n\n            schema:register(XMLValueType.STRING, basePath .. ".objectStorage.supportedObject(?)#filename" , "End part of the xml filename that can be stored(pallet or bale)" )\n            schema:register(XMLValueType.INT, basePath .. ".objectStorage.supportedObject(?)#amount" , "Amount of this single object that can be stored(total capacity of the storage will still limit on top of this)" , "unlimited" )\n            schema:register(XMLValueType.STRING, basePath .. ".objectStorage.supportedObject(?)#fillType" , "FillType name to show in the shop" )\n\n            schema:register(XMLValueType.INT, basePath .. ".objectStorage#capacity" , "Max.capacity" , 250 )\n            schema:register(XMLValueType.FLOAT, basePath .. ".objectStorage#maxLength" , "Max.length of objects to store" , "unlimited" )\n            schema:register(XMLValueType.FLOAT, basePath .. ".objectStorage#maxHeight" , "Max.height of objects to store" , "unlimited" )\n            schema:register(XMLValueType.FLOAT, basePath .. ".objectStorage#maxWidth" , "Max.width of objects to store" , "unlimited" )\n\n            schema:register(XMLValueType.INT, basePath .. ".objectStorage#maxUnloadAmount" , "Max.amount of objects that can be unloaded at a time" , 25 )\n\n            schema:register(XMLValueType.NODE_INDEX, basePath .. ".objectStorage.spawnAreas.spawnArea(?)#startNode" , "Start node" )\n            schema:register(XMLValueType.NODE_INDEX, basePath .. ".objectStorage.spawnAreas.spawnArea(?)#endNode" , "End node" )\n            schema:register(XMLValueType.FLOAT, basePath .. ".objectStorage.spawnAreas.spawnArea(?)#maxHeight" , "Max.stacked height of spawned objects in the area" , 4 )\n\n            schema:register(XMLValueType.NODE_INDEX, basePath .. ".objectStorage.storageAreas.storageArea(?)#startNode" , "Start node" )\n            schema:register(XMLValueType.NODE_INDEX, basePath .. ".objectStorage.storageAreas.storageArea(?)#endNode" , "End node" )\n            schema:register(XMLValueType.FLOAT, basePath .. ".objectStorage.storageAreas.storageArea(?)#maxHeight" , "Max.stacked height of spawned objects in the area" , 4 )\n\n            schema:setXMLSpecializationType()\n        end\n\n'})}),"\n",(0,s.jsx)(n.h3,{id:"removeabstractobjectfromstorage",children:"removeAbstractObjectFromStorage"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Definition"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"removeAbstractObjectFromStorage()"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"any"}),(0,s.jsx)(n.th,{children:"abstractObject"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"any"}),(0,s.jsx)(n.td,{children:"x"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"any"}),(0,s.jsx)(n.td,{children:"y"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"any"}),(0,s.jsx)(n.td,{children:"z"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"any"}),(0,s.jsx)(n.td,{children:"rx"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"any"}),(0,s.jsx)(n.td,{children:"ry"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"any"}),(0,s.jsx)(n.td,{children:"rz"})]})]})]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Code"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:"function PlaceableObjectStorage:removeAbstractObjectFromStorage(abstractObject, x, y, z, rx, ry, rz)\n    local spec = self.spec_objectStorage\n\n    for i = 1 , #spec.storedObjects do\n        if spec.storedObjects[i] = = abstractObject then\n            table.remove(spec.storedObjects, i)\n            abstractObject:removeFromStorage( self , x, y, z, rx, ry, rz, PlaceableObjectStorage.onObjectFromStorageSpawned)\n        end\n    end\n\n    spec.numStoredObjects = #spec.storedObjects\nend\n\n"})}),"\n",(0,s.jsx)(n.h3,{id:"removeabstractobjectsfromstorage",children:"removeAbstractObjectsFromStorage"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Definition"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"removeAbstractObjectsFromStorage()"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"any"}),(0,s.jsx)(n.th,{children:"objectInfoIndex"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"any"}),(0,s.jsx)(n.td,{children:"amount"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"any"}),(0,s.jsx)(n.td,{children:"connection"})]})]})]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Code"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:"function PlaceableObjectStorage:removeAbstractObjectsFromStorage(objectInfoIndex, amount, connection)\n    local spec = self.spec_objectStorage\n    if not spec.objectSpawn.isActive then\n        -- do not allow spawning of new objects until the object infos are up to date\n            if spec.objectInfosUpdateTimer ~ = 0 then\n                return\n            end\n\n            -- in case the client is sending outdated data\n            if spec.objectInfos[objectInfoIndex] = = nil or amount > spec.objectInfos[objectInfoIndex].numObjects then\n                return\n            end\n\n            spec.objectSpawn.isActive = true\n            spec.objectSpawn.connection = connection\n            spec.objectSpawn.objectInfoIndex = objectInfoIndex\n            spec.objectSpawn.numObjectsToSpawn = amount\n            spec.objectSpawn.overlapIsActive = false\n            spec.objectSpawn.overlapObjectCount = 0\n            spec.objectSpawn.spawnAreaIndex = 1\n            spec.objectSpawn.spawnAreaData[ 1 ], spec.objectSpawn.spawnAreaData[ 2 ], spec.objectSpawn.spawnAreaData[ 3 ], spec.objectSpawn.spawnAreaData[ 4 ], spec.objectSpawn.spawnAreaData[ 5 ], spec.objectSpawn.spawnAreaData[ 6 ] = 0 , 0 , 0 , 0 , 0 , math.huge\n\n            for i = #spec.objectSpawn.spawnedObjects, 1 , - 1 do\n                spec.objectSpawn.spawnedObjects[i] = nil\n            end\n\n            self:spawnNextObjectStorageObject()\n        end\n    end\n\n"})}),"\n",(0,s.jsx)(n.h3,{id:"savetoxmlfile",children:"saveToXMLFile"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Definition"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"saveToXMLFile()"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"any"}),(0,s.jsx)(n.th,{children:"xmlFile"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"any"}),(0,s.jsx)(n.td,{children:"key"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"any"}),(0,s.jsx)(n.td,{children:"usedModNames"})]})]})]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Code"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:'function PlaceableObjectStorage:saveToXMLFile(xmlFile, key, usedModNames)\n    local spec = self.spec_objectStorage\n\n    for i = 1 , #spec.storedObjects do\n        local object = spec.storedObjects[i]\n\n        local objectKey = string.format( "%s.object(%d)" , key, i - 1 )\n        xmlFile:setValue(objectKey .. "#className" , object.REFERENCE_CLASS_NAME)\n\n        object:saveToXMLFile( self , xmlFile, objectKey)\n    end\nend\n\n'})}),"\n",(0,s.jsx)(n.h3,{id:"setobjectstorageobjectinfosdirty",children:"setObjectStorageObjectInfosDirty"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Definition"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"setObjectStorageObjectInfosDirty()"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Code"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:"function PlaceableObjectStorage:setObjectStorageObjectInfosDirty()\n    local spec = self.spec_objectStorage\n    spec.objectInfosUpdateTimer = 1000\n    self:raiseActive()\nend\n\n"})}),"\n",(0,s.jsx)(n.h3,{id:"spawnnextobjectstorageobject",children:"spawnNextObjectStorageObject"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Definition"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"spawnNextObjectStorageObject()"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,s.jsx)(n.table,{children:(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"any"}),(0,s.jsx)(n.th,{children:"lastSuccess"})]})})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Code"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:'function PlaceableObjectStorage:spawnNextObjectStorageObject(lastSuccess)\n    local spec = self.spec_objectStorage\n    local spawnErrorId\n\n    if spec.objectSpawn.numObjectsToSpawn > 0 then\n        local objectInfo = spec.objectInfos[spec.objectSpawn.objectInfoIndex]\n        local objectToSpawn = objectInfo.objects[ 1 ]\n\n        local limitedObjectId, errorId = objectToSpawn:getLimitedObjectId()\n        if limitedObjectId = = nil or g_currentMission.slotSystem:getCanAddLimitedObjects(limitedObjectId, 1 ) then\n            local _, _, _, width, height, length, maxStackHeight = objectToSpawn:getSpawnInfo()\n            if maxStackHeight > 1.001 then\n                maxStackHeight = math.huge -- if the object is stackable, the area defines how many can be stacked on top of each other\n                end\n\n                local areaIndex, spawnX, spawnY, spawnZ, offsetX, offsetY, offsetZ, nextOffsetX, nextOffsetZ, stackIndex = PlaceableObjectStorage.getNextSpawnAreaAndOffset(spec.objectSpawn.area, spec.objectSpawn.spawnAreaIndex, spec.objectSpawn.spawnAreaData[ 1 ], spec.objectSpawn.spawnAreaData[ 2 ], spec.objectSpawn.spawnAreaData[ 3 ], spec.objectSpawn.spawnAreaData[ 4 ], spec.objectSpawn.spawnAreaData[ 5 ], width, height, length, maxStackHeight, spec.objectSpawn.spawnAreaData[ 6 ], lastSuccess)\n                if areaIndex ~ = nil then\n                    spec.objectSpawn.spawnAreaIndex, spec.objectSpawn.spawnAreaData[ 1 ], spec.objectSpawn.spawnAreaData[ 2 ], spec.objectSpawn.spawnAreaData[ 3 ], spec.objectSpawn.spawnAreaData[ 4 ], spec.objectSpawn.spawnAreaData[ 5 ], spec.objectSpawn.spawnAreaData[ 6 ] = areaIndex, offsetX, offsetY, offsetZ, nextOffsetX, nextOffsetZ, stackIndex\n                    local spawnArea = spec.objectSpawn.area[spec.objectSpawn.spawnAreaIndex]\n                    local cx, cy, cz = localToWorld(spawnArea.startNode, spawnX, spawnY + height * 0.5 , spawnZ)\n                    local rx, ry, rz = getWorldRotation(spawnArea.startNode)\n\n                    spec.objectSpawn.nextSpawnPosition[ 1 ], spec.objectSpawn.nextSpawnPosition[ 2 ], spec.objectSpawn.nextSpawnPosition[ 3 ] = spawnX, spawnY, spawnZ\n\n                    spec.objectSpawn.overlapIsActive = true\n                    spec.objectSpawn.overlapObjectCount = 0\n                    overlapBoxAsync(cx, cy, cz, rx, ry, rz, width * 0.5 , height * 0.5 , length * 0.5 , "onObjectStorageSpawnOverlapCallback" , self , PlaceableObjectStorage.COLLISION_MASK, true , true , false , true )\n\n                    self:raiseActive()\n                    return\n                end\n            else\n                    spawnErrorId = errorId\n                end\n            end\n\n            if spec.objectSpawn.isActive then\n                if spec.objectSpawn.numObjectsToSpawn > 0 then\n                    if spec.objectSpawn.connection ~ = nil then\n                        if g_server ~ = nil then\n                            spec.objectSpawn.connection:sendEvent( PlaceableObjectStorageErrorEvent.new( self , spawnErrorId or PlaceableObjectStorageErrorEvent.ERROR_NOT_ENOUGH_SPACE))\n                        end\n                    end\n                end\n\n                spec.objectSpawn.isActive = false\n                spec.objectSpawn.connection = nil\n                spec.objectSpawn.objectInfoIndex = 1\n                spec.objectSpawn.numObjectsToSpawn = 0\n\n                for i = #spec.objectSpawn.spawnedObjects, 1 , - 1 do\n                    spec.objectSpawn.spawnedObjects[i] = nil\n                end\n\n                self:setObjectStorageObjectInfosDirty()\n            end\n        end\n\n'})}),"\n",(0,s.jsx)(n.h3,{id:"storependingmanualobjects",children:"storePendingManualObjects"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Definition"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"storePendingManualObjects()"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Code"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:"function PlaceableObjectStorage:storePendingManualObjects()\n    local spec = self.spec_objectStorage\n    for object, num in pairs(spec.pendingObjects) do\n        if num > 0 then\n            local canStoreObject, _ = self:getObjectStorageCanStoreObject(object, true )\n            if not canStoreObject then\n                canStoreObject, _ = self:getObjectStorageCanStoreObject(object, false )\n                if canStoreObject then\n                    self:addObjectToObjectStorage(object, false )\n                    self:setObjectStorageObjectInfosDirty()\n\n                    spec.pendingObjects[object] = nil\n                    object:removeDeleteListener( self , PlaceableObjectStorage.onPendingObjectDelete)\n                end\n            end\n        end\n    end\n\n    self:updateManualStoreActivatable()\nend\n\n"})}),"\n",(0,s.jsx)(n.h3,{id:"updatedirtyobjectstorageobjectinfos",children:"updateDirtyObjectStorageObjectInfos"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"Update infos if they are dirty"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Definition"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"updateDirtyObjectStorageObjectInfos()"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Code"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:"function PlaceableObjectStorage:updateDirtyObjectStorageObjectInfos()\n    local spec = self.spec_objectStorage\n    if spec.objectInfosUpdateTimer > 0 then -- still keep timer running for visual update and sync\n        self:updateObjectStorageObjectInfos()\n    end\nend\n\n"})}),"\n",(0,s.jsx)(n.h3,{id:"updateinfo",children:"updateInfo"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Definition"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"updateInfo()"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"any"}),(0,s.jsx)(n.th,{children:"superFunc"})]})}),(0,s.jsx)(n.tbody,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"any"}),(0,s.jsx)(n.td,{children:"infoTable"})]})})]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Code"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:'function PlaceableObjectStorage:updateInfo(superFunc, infoTable)\n    superFunc( self , infoTable)\n\n    local spec = self.spec_objectStorage\n\n    table.insert(infoTable, { title = spec.texts.totalCapacity, text = string.format( "%d / %d" , spec.numStoredObjects, spec.capacity) } )\n\n    local numObjectInfos = #spec.objectInfos\n    for i = 1 , math.min(numObjectInfos, PlaceableObjectStorage.MAX_HUD_INFO_ENTRIES) do\n        local objectInfo = spec.objectInfos[i]\n        if objectInfo.objects[ 1 ] ~ = nil then\n            local title = objectInfo.objects[ 1 ]:getDialogText()\n            if utf8Strlen(title) > 32 then\n                title = utf8Substr(title, 0 , 32 ) .. " .. ."\n            end\n            table.insert(infoTable, { title = title, text = tostring(objectInfo.numObjects) } )\n        end\n    end\n\n    if numObjectInfos > PlaceableObjectStorage.MAX_HUD_INFO_ENTRIES then\n        local sumOthers = 0\n        for i = PlaceableObjectStorage.MAX_HUD_INFO_ENTRIES + 1 , numObjectInfos do\n            sumOthers = sumOthers + spec.objectInfos[i].numObjects\n        end\n\n        table.insert(infoTable, { title = spec.texts.otherElements, text = tostring(sumOthers) } )\n    end\nend\n\n'})}),"\n",(0,s.jsx)(n.h3,{id:"updatemanualstoreactivatable",children:"updateManualStoreActivatable"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Definition"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"updateManualStoreActivatable()"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Code"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:"function PlaceableObjectStorage:updateManualStoreActivatable()\n    local spec = self.spec_objectStorage\n\n    local pendingManualObjectsState = self:getHasPendingManualStoreObjects()\n    if pendingManualObjectsState ~ = spec.lastPendingManualObjectsState then\n        spec.lastPendingManualObjectsState = pendingManualObjectsState\n        if pendingManualObjectsState then\n            g_currentMission.activatableObjectsSystem:addActivatable(spec.manualStoreActivatable)\n        else\n                g_currentMission.activatableObjectsSystem:removeActivatable(spec.manualStoreActivatable)\n            end\n\n            self:raiseDirtyFlags(spec.dirtyFlag)\n        end\n    end\n\n"})}),"\n",(0,s.jsx)(n.h3,{id:"updateobjectstorageobjectinfos",children:"updateObjectStorageObjectInfos"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Definition"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"updateObjectStorageObjectInfos()"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Code"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:"function PlaceableObjectStorage:updateObjectStorageObjectInfos()\n    local spec = self.spec_objectStorage\n\n    local objectInfos = { }\n\n    for i = 1 , #spec.storedObjects do\n        local object = spec.storedObjects[i]\n\n        local foundInfo = false\n        for j = 1 , #objectInfos do\n            local objectInfo = objectInfos[j]\n            if object:getIsIdentical(objectInfo.objects[ 1 ]) then\n                table.insert(objectInfo.objects, object)\n                objectInfo.numObjects = #objectInfo.objects\n                foundInfo = true\n            end\n        end\n\n        if not foundInfo then\n            local objectInfo = { }\n            objectInfo.objects = { object }\n            objectInfo.numObjects = 1\n            table.insert(objectInfos, objectInfo)\n        end\n    end\n\n    table.sort(objectInfos, function (a, b)\n        local _, _, _, widthA, _, _, _ = a.objects[ 1 ]:getSpawnInfo()\n        local _, _, _, widthB, _, _, _ = b.objects[ 1 ]:getSpawnInfo()\n        return widthA < widthB\n    end )\n\n    spec.objectInfos = objectInfos\nend\n\n"})}),"\n",(0,s.jsx)(n.h3,{id:"updateobjectstoragevisualareas",children:"updateObjectStorageVisualAreas"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Definition"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"updateObjectStorageVisualAreas()"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Code"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:'function PlaceableObjectStorage:updateObjectStorageVisualAreas()\n    local spec = self.spec_objectStorage\n\n    local area = spec.storageArea\n\n    local oldSpawnNode = area.spawnNode\n    area.spawnNode = createTransformGroup( "storageAreaSpawnNode" )\n    link( self.rootNode, area.spawnNode)\n    setVisibility(area.spawnNode, false )\n\n    local pendingVisualAreaUpdate = { }\n    pendingVisualAreaUpdate.oldSpawnNode = oldSpawnNode\n    pendingVisualAreaUpdate.newSpawnNode = area.spawnNode\n    pendingVisualAreaUpdate.objectInfosToSpawn = { }\n\n    pendingVisualAreaUpdate.spawnNextObjectInfo = function ()\n        if #pendingVisualAreaUpdate.objectInfosToSpawn > 0 then\n            local objectInfo = pendingVisualAreaUpdate.objectInfosToSpawn[ 1 ]\n            objectInfo.objects[ 1 ]:spawnVisualObjects(objectInfo.visualSpawnInfos)\n\n            table.remove(pendingVisualAreaUpdate.objectInfosToSpawn, 1 )\n\n            return true\n        else\n                delete(pendingVisualAreaUpdate.oldSpawnNode)\n\n                if entityExists(pendingVisualAreaUpdate.newSpawnNode) then\n                    setVisibility(pendingVisualAreaUpdate.newSpawnNode, true )\n                end\n\n                return false\n            end\n        end\n\n        area.spawnAreaIndex, area.spawnAreaData[ 1 ], area.spawnAreaData[ 2 ], area.spawnAreaData[ 3 ], area.spawnAreaData[ 4 ], area.spawnAreaData[ 5 ], area.spawnAreaData[ 6 ] = 1 , 0 , 0 , 0 , 0 , 0 , math.huge\n\n        for i = 1 , #spec.objectInfos do\n            local objectInfo = spec.objectInfos[i]\n            objectInfo.visualSpawnInfos = { }\n            area.spawnAreaData[ 6 ] = math.huge\n\n            local objectToSpawn = objectInfo.objects[ 1 ]\n            local ox, oy, oz, width, height, length, maxStackHeight = objectToSpawn:getSpawnInfo()\n            if maxStackHeight > 1.001 then\n                maxStackHeight = math.huge -- if the object is stackable, the area defines how many can be stacked on top of each other\n                end\n\n                for j = 1 , objectInfo.numObjects do\n                    local areaIndex, spawnX, spawnY, spawnZ, offsetX, offsetY, offsetZ, nextOffsetX, nextOffsetZ, stackIndex = PlaceableObjectStorage.getNextSpawnAreaAndOffset(area.area, area.spawnAreaIndex, area.spawnAreaData[ 1 ], area.spawnAreaData[ 2 ], area.spawnAreaData[ 3 ], area.spawnAreaData[ 4 ], area.spawnAreaData[ 5 ], width, height, length, maxStackHeight, area.spawnAreaData[ 6 ], true )\n                    if areaIndex ~ = nil then\n                        area.spawnAreaIndex, area.spawnAreaData[ 1 ], area.spawnAreaData[ 2 ], area.spawnAreaData[ 3 ], area.spawnAreaData[ 4 ], area.spawnAreaData[ 5 ], area.spawnAreaData[ 6 ] = areaIndex, offsetX, offsetY, offsetZ, nextOffsetX, nextOffsetZ, stackIndex\n\n                        local spawnArea = area.area[area.spawnAreaIndex]\n\n                        local cx, cy, cz = localToLocal(spawnArea.startNode, area.spawnNode, spawnX + ox, spawnY + oy, spawnZ + oz)\n                        local rx, ry, rz = localRotationToLocal(spawnArea.startNode, area.spawnNode, 0 , 0 , 0 )\n\n                        table.insert(objectInfo.visualSpawnInfos, { area.spawnNode, cx, cy, cz, rx, ry, rz } )\n                    end\n                end\n\n                if #objectInfo.visualSpawnInfos > 0 then\n                    table.insert(pendingVisualAreaUpdate.objectInfosToSpawn, objectInfo)\n                end\n            end\n\n            if pendingVisualAreaUpdate.spawnNextObjectInfo() then\n                table.insert(spec.pendingVisualAreaUpdates, pendingVisualAreaUpdate)\n                self:raiseActive()\n            end\n        end\n\n'})})]})}function j(e={}){const{wrapper:n}={...(0,c.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}}}]);