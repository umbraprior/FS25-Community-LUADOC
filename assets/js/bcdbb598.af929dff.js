"use strict";(globalThis.webpackChunkfs25_community_luadoc=globalThis.webpackChunkfs25_community_luadoc||[]).push([[57784],{28453(e,n,l){l.d(n,{R:()=>s,x:()=>d});var i=l(96540);const t={},r=i.createContext(t);function s(e){const n=i.useContext(r);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function d(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:s(e.components),i.createElement(r.Provider,{value:n},e.children)}},69439(e,n,l){l.r(n),l.d(n,{assets:()=>o,contentTitle:()=>d,default:()=>h,frontMatter:()=>s,metadata:()=>i,toc:()=>c});const i=JSON.parse('{"id":"script/Specializations/Leveler","title":"Leveler","description":"Leveler","source":"@site/../docs/script/Specializations/Leveler.md","sourceDirName":"script/Specializations","slug":"/script/Specializations/Leveler","permalink":"/FS25-Community-LUADOC/script/Specializations/Leveler","draft":false,"unlisted":false,"tags":[],"version":"current","lastUpdatedAt":1767161192000,"frontMatter":{},"sidebar":"docsSidebar","previous":{"title":"JigglingParts","permalink":"/FS25-Community-LUADOC/script/Specializations/JigglingParts"},"next":{"title":"LicensePlates","permalink":"/FS25-Community-LUADOC/script/Specializations/LicensePlates"}}');var t=l(74848),r=l(28453);const s={},d=void 0,o={},c=[{value:"Leveler",id:"leveler",level:2},{value:"getIsAttacherJointControlDampingAllowed",id:"getisattacherjointcontroldampingallowed",level:3},{value:"getIsLevelerPickupNodeActive",id:"getislevelerpickupnodeactive",level:3},{value:"initSpecialization",id:"initspecialization",level:3},{value:"loadLevelerNodeFromXML",id:"loadlevelernodefromxml",level:3},{value:"onDelete",id:"ondelete",level:3},{value:"onLevelerRaycastCallback",id:"onlevelerraycastcallback",level:3},{value:"onLoad",id:"onload",level:3},{value:"onReadUpdateStream",id:"onreadupdatestream",level:3},{value:"onUpdate",id:"onupdate",level:3},{value:"onWriteUpdateStream",id:"onwriteupdatestream",level:3},{value:"prerequisitesPresent",id:"prerequisitespresent",level:3},{value:"registerEventListeners",id:"registereventlisteners",level:3},{value:"registerFunctions",id:"registerfunctions",level:3},{value:"registerOverwrittenFunctions",id:"registeroverwrittenfunctions",level:3}];function a(e){const n={a:"a",blockquote:"blockquote",code:"code",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,r.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.h2,{id:"leveler",children:"Leveler"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Description"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"Specialization for levelers for distributing silage/chaff in bunker silos"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Functions"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#getisattacherjointcontroldampingallowed",children:"getIsAttacherJointControlDampingAllowed"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#getislevelerpickupnodeactive",children:"getIsLevelerPickupNodeActive"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#initspecialization",children:"initSpecialization"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#loadlevelernodefromxml",children:"loadLevelerNodeFromXML"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#ondelete",children:"onDelete"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#onlevelerraycastcallback",children:"onLevelerRaycastCallback"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#onload",children:"onLoad"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#onreadupdatestream",children:"onReadUpdateStream"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#onupdate",children:"onUpdate"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#onwriteupdatestream",children:"onWriteUpdateStream"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#prerequisitespresent",children:"prerequisitesPresent"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#registereventlisteners",children:"registerEventListeners"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#registerfunctions",children:"registerFunctions"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#registeroverwrittenfunctions",children:"registerOverwrittenFunctions"})}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"getisattacherjointcontroldampingallowed",children:"getIsAttacherJointControlDampingAllowed"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Description"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"Returns if damping is allowed"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Definition"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"getIsAttacherJointControlDampingAllowed()"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,t.jsx)(n.table,{children:(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"any"}),(0,t.jsx)(n.th,{children:"superFunc"})]})})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Return Values"})}),"\n\n\n\n\n\n\n\n\n",(0,t.jsx)(n.table,{children:(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"any"}),(0,t.jsx)(n.th,{children:"allowed"}),(0,t.jsx)(n.th,{children:"allowed"})]})})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Code"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:"function Leveler:getIsAttacherJointControlDampingAllowed(superFunc)\n    if not superFunc( self ) then\n        return false\n    end\n\n    for _, levelerNode in pairs( self.spec_leveler.nodes) do\n        local x, y, z = getWorldTranslation(levelerNode.node)\n        local _, height = DensityMapHeightUtil.getHeightAtWorldPos(x, y, z)\n        if height = = 0 then\n            return false\n        end\n    end\n\n    return true\nend\n\n"})}),"\n",(0,t.jsx)(n.h3,{id:"getislevelerpickupnodeactive",children:"getIsLevelerPickupNodeActive"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Description"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"Returns true if leveler pickup node is active"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Definition"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"getIsLevelerPickupNodeActive(table levelerNode)"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n",(0,t.jsx)(n.table,{children:(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"table"}),(0,t.jsx)(n.th,{children:"levelerNode"}),(0,t.jsx)(n.th,{children:"pickup node data"})]})})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Return Values"})}),"\n\n\n\n\n\n\n\n\n",(0,t.jsx)(n.table,{children:(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"table"}),(0,t.jsx)(n.th,{children:"isActive"}),(0,t.jsx)(n.th,{children:"pickup node is active"})]})})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Code"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:"function Leveler:getIsLevelerPickupNodeActive(levelerNode)\n    return self.getAttacherVehicle = = nil or self:getAttacherVehicle() ~ = nil\nend\n\n"})}),"\n",(0,t.jsx)(n.h3,{id:"initspecialization",children:"initSpecialization"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Description"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"Called on specialization initializing"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Definition"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"initSpecialization()"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Code"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:'function Leveler.initSpecialization()\n    local schema = Vehicle.xmlSchema\n    schema:setXMLSpecializationType( "Leveler" )\n\n    local basePath = Leveler.LEVELER_NODE_XML_KEY\n\n    schema:register(XMLValueType.NODE_INDEX, basePath .. "#node" , "Leveler node" )\n\n    schema:register(XMLValueType.FLOAT, basePath .. "#width" , "Width" )\n    schema:register(XMLValueType.FLOAT, basePath .. "#zOffset" , "Z axis offset" , 0 )\n    schema:register(XMLValueType.FLOAT, basePath .. "#yOffset" , "Y axis offset" , 0 )\n    schema:register(XMLValueType.FLOAT, basePath .. "#minDropWidth" , "Min.drop width" , "half of width" )\n    schema:register(XMLValueType.FLOAT, basePath .. "#maxDropWidth" , "Max.drop width" , "width value" )\n    schema:register(XMLValueType.FLOAT, basePath .. "#minDropDirOffset" , "Min.drop direction offset" , 0.7 )\n    schema:register(XMLValueType.FLOAT, basePath .. "#maxDropDirOffset" , "Max.drop direction offset" , 0.7 )\n    schema:register(XMLValueType.INT, basePath .. "#numHeightLimitChecks" , "Number of height limit checks" , 6 )\n    schema:register(XMLValueType.BOOL, basePath .. "#alignToWorldY" , "Defines if the leveler node is aligned to worlds Y axis" , true )\n\n        schema:register(XMLValueType.BOOL, basePath .. ".smoothing#allowed" , "Leveler smoothes while driving backward" , true )\n            schema:register(XMLValueType.FLOAT, basePath .. ".smoothing#radius" , "Smooth ground radius" , 0.5 )\n            schema:register(XMLValueType.FLOAT, basePath .. ".smoothing#overlap" , "Radius overlap" , 1.7 )\n            schema:register(XMLValueType.INT, basePath .. ".smoothing#direction" , "Smooth direction(if set to \'0\' it smooths in both directions)" , - 1 )\n\n                schema:register(XMLValueType.INT, basePath .. "#fillUnitIndex" , "Fill unit index" , "Value of vehicle.leveler#fillUnitIndex" )\n\n                schema:register(XMLValueType.NODE_INDEX, basePath .. ".occlusionAreas.occlusionArea(?)#startNode" , "Start node" )\n                schema:register(XMLValueType.NODE_INDEX, basePath .. ".occlusionAreas.occlusionArea(?)#widthNode" , "Width node" )\n                schema:register(XMLValueType.NODE_INDEX, basePath .. ".occlusionAreas.occlusionArea(?)#heightNode" , "Height node" )\n\n                schema:register(XMLValueType.INT, "vehicle.leveler.pickUpDirection" , "Pick up direction" , 1 )\n                schema:register(XMLValueType.INT, "vehicle.leveler#fillUnitIndex" , "Fill unit index" )\n                schema:register(XMLValueType.FLOAT, "vehicle.leveler#maxFillLevelPerMS" , "Max.fill level change rate as reference for effect and force" , 20 )\n\n                    schema:register(XMLValueType.NODE_INDEX, "vehicle.leveler.force#node" , "Force node" )\n                    schema:register(XMLValueType.NODE_INDEX, "vehicle.leveler.force#directionNode" , "Force direction node" )\n                    schema:register(XMLValueType.FLOAT, "vehicle.leveler.force#maxForce" , "Max.force in kN" , 0 )\n                    schema:register(XMLValueType.INT, "vehicle.leveler.force#direction" , "Driving direction for applying force" , 1 )\n\n                        schema:register(XMLValueType.BOOL, "vehicle.leveler#ignoreFarmlandState" , "If set to true the farmland underneath the leveler does not need to be bought to actually work" , false )\n\n                        EffectManager.registerEffectXMLPaths(schema, "vehicle.leveler.effects" )\n\n                        schema:setXMLSpecializationType()\n                    end\n\n'})}),"\n",(0,t.jsx)(n.h3,{id:"loadlevelernodefromxml",children:"loadLevelerNodeFromXML"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Description"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"Loads leveler node from xml"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Definition"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"loadLevelerNodeFromXML(table levelerNode, XMLFile xmlFile, string key)"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"table"}),(0,t.jsx)(n.th,{children:"levelerNode"}),(0,t.jsx)(n.th,{children:"leveler node data"})]})}),(0,t.jsxs)(n.tbody,{children:[(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"XMLFile"}),(0,t.jsx)(n.td,{children:"xmlFile"}),(0,t.jsx)(n.td,{children:"XMLFile instance"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"string"}),(0,t.jsx)(n.td,{children:"key"}),(0,t.jsx)(n.td,{children:"key"})]})]})]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Return Values"})}),"\n\n\n\n\n\n\n\n\n",(0,t.jsx)(n.table,{children:(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"string"}),(0,t.jsx)(n.th,{children:"success"}),(0,t.jsx)(n.th,{children:"success"})]})})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Code"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:'function Leveler:loadLevelerNodeFromXML(levelerNode, xmlFile, key)\n    levelerNode.node = xmlFile:getValue(key .. "#node" , nil , self.components, self.i3dMappings)\n    if levelerNode.node ~ = nil then\n        local referenceFrame = createTransformGroup( "referenceFrame" )\n        link(getParent(levelerNode.node), referenceFrame)\n        setTranslation(referenceFrame, getTranslation(levelerNode.node))\n        setRotation(referenceFrame, getRotation(levelerNode.node))\n        levelerNode.referenceFrame = referenceFrame\n\n        levelerNode.zOffset = xmlFile:getValue(key .. "#zOffset" , 0 )\n        levelerNode.yOffset = xmlFile:getValue(key .. "#yOffset" , 0 )\n        levelerNode.width = xmlFile:getValue(key .. "#width" )\n        levelerNode.halfWidth = levelerNode.width * 0.5\n\n        levelerNode.minDropWidth = xmlFile:getValue(key .. "#minDropWidth" , levelerNode.width * 0.5 )\n        levelerNode.halfMinDropWidth = levelerNode.minDropWidth * 0.5\n        levelerNode.maxDropWidth = xmlFile:getValue(key .. "#maxDropWidth" , levelerNode.width)\n        levelerNode.halfMaxDropWidth = levelerNode.maxDropWidth * 0.5\n\n        levelerNode.minDropDirOffset = xmlFile:getValue(key .. "#minDropDirOffset" , 0.7 )\n        levelerNode.maxDropDirOffset = xmlFile:getValue(key .. "#maxDropDirOffset" , 0.7 )\n        levelerNode.numHeightLimitChecks = xmlFile:getValue(key .. "#numHeightLimitChecks" , 6 )\n        levelerNode.alignToWorldY = xmlFile:getValue(key .. "#alignToWorldY" , true )\n\n        levelerNode.occlusionAreas = { }\n\n        local i = 0\n        while true do\n            local baseKey = string.format( "%s.occlusionAreas.occlusionArea(%d)" , key, i)\n            if not xmlFile:hasProperty(baseKey) then\n                break\n            end\n\n            local entry = { }\n            entry.startNode = xmlFile:getValue(baseKey .. "#startNode" , nil , self.components, self.i3dMappings)\n            entry.widthNode = xmlFile:getValue(baseKey .. "#widthNode" , nil , self.components, self.i3dMappings)\n            entry.heightNode = xmlFile:getValue(baseKey .. "#heightNode" , nil , self.components, self.i3dMappings)\n\n            if entry.startNode ~ = nil and entry.widthNode ~ = nil and entry.heightNode ~ = nil then\n                table.insert(levelerNode.occlusionAreas, entry)\n            else\n                    Logging.xmlWarning(xmlFile, "Failed to load occlustion area \'%s\'.One or more nodes missing." , baseKey)\n                end\n\n                i = i + 1\n            end\n\n            levelerNode.allowsSmoothing = xmlFile:getValue(key .. ".smoothing#allowed" , true )\n            levelerNode.smoothGroundRadius = xmlFile:getValue(key .. ".smoothing#radius" , 0.5 )\n            levelerNode.smoothOverlap = xmlFile:getValue(key .. ".smoothing#overlap" , 1.7 )\n            levelerNode.smoothDirection = xmlFile:getValue(key .. ".smoothing#direction" , - 1 )\n\n            levelerNode.lineOffsetPickUp = nil\n            levelerNode.lineOffsetDrop = nil\n\n            levelerNode.lastPickUp = 0\n            levelerNode.lastDrop = 0\n\n            levelerNode.fillUnitIndex = xmlFile:getValue(key .. "#fillUnitIndex" , self.spec_leveler.fillUnitIndex)\n            if not self:getFillUnitExists(levelerNode.fillUnitIndex) then\n                Logging.xmlWarning( self.xmlFile, "Unknown fillUnitIndex \'%s\' for leveler" , tostring(levelerNode.fillUnitIndex))\n                    return false\n                end\n\n                return true\n            end\n\n            return false\n        end\n\n'})}),"\n",(0,t.jsx)(n.h3,{id:"ondelete",children:"onDelete"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Description"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"Called on deleting"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Definition"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"onDelete()"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Code"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:"function Leveler:onDelete()\n    local spec = self.spec_leveler\n\n    g_effectManager:deleteEffects(spec.effects)\nend\n\n"})}),"\n",(0,t.jsx)(n.h3,{id:"onlevelerraycastcallback",children:"onLevelerRaycastCallback"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Description"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"Callback used when raycast hits an object."}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Definition"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"onLevelerRaycastCallback(integer hitObjectId, float x, float y, float z, float distance, float nx, float ny, float nz,\ninteger subShapeIndex, integer shapeId, boolean isLast, )"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"integer"}),(0,t.jsx)(n.th,{children:"hitObjectId"}),(0,t.jsx)(n.th,{children:"scenegraph object id"})]})}),(0,t.jsxs)(n.tbody,{children:[(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"float"}),(0,t.jsx)(n.td,{children:"x"}),(0,t.jsx)(n.td,{children:"world x hit position"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"float"}),(0,t.jsx)(n.td,{children:"y"}),(0,t.jsx)(n.td,{children:"world y hit position"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"float"}),(0,t.jsx)(n.td,{children:"z"}),(0,t.jsx)(n.td,{children:"world z hit position"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"float"}),(0,t.jsx)(n.td,{children:"distance"}),(0,t.jsx)(n.td,{children:"distance at which the cast hit the object"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"float"}),(0,t.jsx)(n.td,{children:"nx"}),(0,t.jsx)(n.td,{children:"normal x direction"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"float"}),(0,t.jsx)(n.td,{children:"ny"}),(0,t.jsx)(n.td,{children:"normal y direction"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"float"}),(0,t.jsx)(n.td,{children:"nz"}),(0,t.jsx)(n.td,{children:"normal z direction"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"integer"}),(0,t.jsx)(n.td,{children:"subShapeIndex"}),(0,t.jsx)(n.td,{children:"sub shape index"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"integer"}),(0,t.jsx)(n.td,{children:"shapeId"}),(0,t.jsx)(n.td,{children:"id of shape"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"boolean"}),(0,t.jsx)(n.td,{children:"isLast"}),(0,t.jsx)(n.td,{children:"is last hit"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"any"}),(0,t.jsx)(n.td,{children:"isLast"}),(0,t.jsx)(n.td,{})]})]})]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Return Values"})}),"\n\n\n\n\n\n\n\n\n",(0,t.jsx)(n.table,{children:(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"any"}),(0,t.jsx)(n.th,{children:"return"}),(0,t.jsx)(n.th,{children:"false to stop raycast"})]})})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Code"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:"function Leveler.onLevelerRaycastCallback(levelerNode, hitObjectId, x, y, z, distance, nx, ny, nz, subShapeIndex, shapeId, isLast)\n    local self = levelerNode.vehicle\n    if self.isDeleted or self.isDeleting then\n        return\n    end\n\n    local spec = self.spec_leveler\n\n    if hitObjectId ~ = 0 then\n        if hitObjectId ~ = g_terrainNode then\n            levelerNode.raycastHitObject = true\n            --#debug drawDebugLine(x, y, z, 1, 0, 0, x, y + 1, z, 1, 0, 0, true)\n        end\n    end\n\n    if isLast then\n        if not levelerNode.raycastHitObject then\n            local fillLevel = self:getFillUnitFillLevel(levelerNode.fillUnitIndex)\n            if fillLevel > 0 then\n                local fillType = levelerNode.raycastLastFillType\n                local outerRadius = levelerNode.raycastLastRadius\n\n                local f = spec.lastFillLevelMovedPct\n                local width = MathUtil.lerp(levelerNode.halfMinDropWidth, levelerNode.halfMaxDropWidth, f)\n                local dropOffset = MathUtil.lerp(levelerNode.minDropDirOffset, levelerNode.maxDropDirOffset, f)\n\n                local terrainHeightUpdater = g_densityMapHeightManager:getTerrainDetailHeightUpdater()\n                if terrainHeightUpdater ~ = nil then\n                    for i = 1 , #levelerNode.occlusionAreas do\n                        local occlusionArea = levelerNode.occlusionAreas[i]\n\n                        local ox1, oy1, oz1 = getWorldTranslation(occlusionArea.startNode)\n                        local ox2, _, oz2 = getWorldTranslation(occlusionArea.widthNode)\n                        local ox3, _, oz3 = getWorldTranslation(occlusionArea.heightNode)\n\n                        local ox, oz, widthX, widthZ, heightX, heightZ = MathUtil.getXZWidthAndHeight(ox1, oz1, ox2, oz2, ox3, oz3)\n\n                        addDensityMapHeightOcclusionArea(terrainHeightUpdater, ox, oy1, oz, widthX, oy1, widthZ, heightX, oy1, heightZ, true )\n\n                        --#debug DebugUtil.drawDebugParallelogram(x, z, widthX, widthZ, heightX, heightZ, 0, 0.5, 0, 0, 0.1)\n                    end\n                end\n\n                local sx,sy,sz = localToWorld(levelerNode.node, - width, levelerNode.yOffset, levelerNode.zOffset + dropOffset)\n                local ex,ey,ez = localToWorld(levelerNode.node, width, levelerNode.yOffset, levelerNode.zOffset + dropOffset)\n                levelerNode.lastDrop2, levelerNode.lineOffsetDrop2 = DensityMapHeightUtil.tipToGroundAroundLine( self , fillLevel, fillType, sx,sy,sz, ex,ey,ez, 0 , outerRadius, levelerNode.lineOffsetDrop2, false , nil )\n\n                --#debug DebugUtil.drawDebugLine(sx,sy,sz, ex,ey,ez, 0, 1, 1, outerRadius)\n\n                if levelerNode.lastDrop2 > 0 then\n                    local leftOver = fillLevel - levelerNode.lastDrop2\n                    if leftOver < = g_densityMapHeightManager:getMinValidLiterValue(fillType) then\n                        levelerNode.lastDrop2 = fillLevel\n                        spec.litersToPickup = spec.litersToPickup + leftOver\n                    end\n                    self:addFillUnitFillLevel( self:getOwnerFarmId(), levelerNode.fillUnitIndex, - levelerNode.lastDrop2, fillType, ToolType.UNDEFINED, nil )\n                end\n            end\n        end\n    end\nend\n\n"})}),"\n",(0,t.jsx)(n.h3,{id:"onload",children:"onLoad"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Description"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"Called on loading"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Definition"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"onLoad(table savegame)"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n",(0,t.jsx)(n.table,{children:(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"table"}),(0,t.jsx)(n.th,{children:"savegame"}),(0,t.jsx)(n.th,{children:"savegame"})]})})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Code"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:'function Leveler:onLoad(savegame)\n    local spec = self.spec_leveler\n\n    XMLUtil.checkDeprecatedXMLElements( self.xmlFile, "vehicle.leveler.levelerNode#index" , "vehicle.leveler.levelerNode#node" ) -- FS17\n    XMLUtil.checkDeprecatedXMLElements( self.xmlFile, "vehicle.levelerEffects" , "vehicle.leveler.effects" ) -- FS17\n\n    XMLUtil.checkDeprecatedXMLElements( self.xmlFile, "vehicle.leveler.levelerNode(0)#minDropHeight" ) -- FS22\n    XMLUtil.checkDeprecatedXMLElements( self.xmlFile, "vehicle.leveler.levelerNode(0)#maxDropHeight" ) -- FS22\n\n    spec.pickUpDirection = self.xmlFile:getValue( "vehicle.leveler.pickUpDirection" , 1.0 )\n    spec.maxFillLevelPerMS = self.xmlFile:getValue( "vehicle.leveler#maxFillLevelPerMS" , 35 )\n    spec.fillUnitIndex = self.xmlFile:getValue( "vehicle.leveler#fillUnitIndex" )\n\n    spec.nodes = { }\n    local i = 0\n    while true do\n        local key = string.format( "vehicle.leveler.levelerNode(%d)" , i)\n        if not self.xmlFile:hasProperty(key) then\n            break\n        end\n\n        local levelerNode = { }\n        if self:loadLevelerNodeFromXML(levelerNode, self.xmlFile, key) then\n            levelerNode.vehicle = self\n            levelerNode.onLevelerRaycastCallback = self.onLevelerRaycastCallback\n            table.insert(spec.nodes, levelerNode)\n        end\n        i = i + 1\n    end\n\n    spec.litersToPickup = 0\n    spec.smoothAccumulation = 0\n\n    spec.lastFillLevelMoved = 0\n    spec.lastFillLevelMovedPct = 0\n    spec.lastFillLevelMovedTarget = 0\n    spec.lastFillLevelMovedBuffer = 0\n    spec.lastFillLevelMovedBufferTime = 300\n    spec.lastFillLevelMovedBufferTimer = 0\n\n    spec.forceNode = self.xmlFile:getValue( "vehicle.leveler.force#node" , nil , self.components, self.i3dMappings)\n    spec.forceDirNode = self.xmlFile:getValue( "vehicle.leveler.force#directionNode" , spec.forceNode, self.components, self.i3dMappings)\n\n    spec.maxForce = self.xmlFile:getValue( "vehicle.leveler.force#maxForce" , 0 ) -- kN\n    spec.lastForce = 0\n    spec.forceDir = self.xmlFile:getValue( "vehicle.leveler.force#direction" , 1 )\n\n    spec.ignoreFarmlandState = self.xmlFile:getValue( "vehicle.leveler#ignoreFarmlandState" , false )\n\n    if self.isClient then\n        spec.effects = g_effectManager:loadEffect( self.xmlFile, "vehicle.leveler.effects" , self.components, self , self.i3dMappings)\n    end\n\n    if #spec.nodes = = 0 then\n        SpecializationUtil.removeEventListener( self , "onUpdate" , Leveler )\n    end\n\n    spec.dirtyFlag = self:getNextDirtyFlag()\nend\n\n'})}),"\n",(0,t.jsx)(n.h3,{id:"onreadupdatestream",children:"onReadUpdateStream"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Description"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"Called on on update"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Definition"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"onReadUpdateStream(integer streamId, integer timestamp, table connection)"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"integer"}),(0,t.jsx)(n.th,{children:"streamId"}),(0,t.jsx)(n.th,{children:"stream ID"})]})}),(0,t.jsxs)(n.tbody,{children:[(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"integer"}),(0,t.jsx)(n.td,{children:"timestamp"}),(0,t.jsx)(n.td,{children:"timestamp"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"table"}),(0,t.jsx)(n.td,{children:"connection"}),(0,t.jsx)(n.td,{children:"connection"})]})]})]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Code"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:"function Leveler:onReadUpdateStream(streamId, timestamp, connection)\n    if connection:getIsServer() then\n        if streamReadBool(streamId) then\n            local spec = self.spec_leveler\n            spec.lastFillLevelMovedPct = streamReadUIntN(streamId, Leveler.LEVEL_NUM_BITS) / Leveler.LEVEL_MAX_VALUE\n        end\n    end\nend\n\n"})}),"\n",(0,t.jsx)(n.h3,{id:"onupdate",children:"onUpdate"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Description"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"Called on update"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Definition"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"onUpdate(float dt, boolean isActiveForInput, boolean isSelected, )"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"float"}),(0,t.jsx)(n.th,{children:"dt"}),(0,t.jsx)(n.th,{children:"time since last call in ms"})]})}),(0,t.jsxs)(n.tbody,{children:[(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"boolean"}),(0,t.jsx)(n.td,{children:"isActiveForInput"}),(0,t.jsx)(n.td,{children:"true if vehicle is active for input"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"boolean"}),(0,t.jsx)(n.td,{children:"isSelected"}),(0,t.jsx)(n.td,{children:"true if vehicle is selected"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"any"}),(0,t.jsx)(n.td,{children:"isSelected"}),(0,t.jsx)(n.td,{})]})]})]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Code"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:'function Leveler:onUpdate(dt, isActiveForInput, isActiveForInputIgnoreSelection, isSelected)\n    local spec = self.spec_leveler\n\n    if self.isClient then\n        local fillType = FillType.UNKNOWN\n        for _, levelerNode in pairs(spec.nodes) do\n            fillType = self:getFillUnitLastValidFillType(levelerNode.fillUnitIndex)\n            if fillType ~ = FillType.UNKNOWN then\n                break\n            end\n        end\n\n        if fillType ~ = FillType.UNKNOWN and spec.lastFillLevelMovedPct > 0 then\n            g_effectManager:setEffectTypeInfo(spec.effects, fillType)\n            g_effectManager:startEffects(spec.effects)\n\n            for _, effect in pairs(spec.effects) do\n                if effect:isa(LevelerEffect) or effect:isa(SnowPlowMotionPathEffect) then\n                    effect:setFillLevel(spec.lastFillLevelMovedPct)\n                    effect:setLastVehicleSpeed( self.movingDirection * self:getLastSpeed())\n                end\n            end\n        else\n                g_effectManager:stopEffects(spec.effects)\n            end\n        end\n\n        if self.isServer then\n            for _, levelerNode in pairs(spec.nodes) do\n                local x0,y0,z0 = localToWorld(levelerNode.node, - levelerNode.halfWidth, levelerNode.yOffset, levelerNode.maxDropDirOffset)\n                local x1,y1,z1 = localToWorld(levelerNode.node, levelerNode.halfWidth, levelerNode.yOffset, levelerNode.maxDropDirOffset)\n                if not spec.ignoreFarmlandState then\n                    local ownerFarmId = self:getOwnerFarmId()\n                    if not g_farmlandManager:getCanAccessLandAtWorldPosition(ownerFarmId, x0, z0) or\n                        not g_farmlandManager:getCanAccessLandAtWorldPosition(ownerFarmId, x1, z1) then\n                        break\n                    end\n                end\n\n                local pickedUpFillLevel = 0\n                local fillType = self:getFillUnitFillType(levelerNode.fillUnitIndex)\n                local fillLevel = self:getFillUnitFillLevel(levelerNode.fillUnitIndex)\n\n                if fillType = = FillType.UNKNOWN or fillLevel < g_densityMapHeightManager:getMinValidLiterValue(fillType) + 0.001 then\n                    local newFillType = DensityMapHeightUtil.getFillTypeAtLine(x0,y0,z0, x1,y1,z1, 0.5 * levelerNode.maxDropDirOffset)\n                    if newFillType ~ = FillType.UNKNOWN and newFillType ~ = fillType then\n                        if self:getFillUnitSupportsFillType(levelerNode.fillUnitIndex, newFillType) then\n                            self:addFillUnitFillLevel( self:getOwnerFarmId(), levelerNode.fillUnitIndex, - math.huge)\n                            fillType = newFillType\n                        end\n                    end\n                end\n                local heightType = g_densityMapHeightManager:getDensityMapHeightTypeByFillTypeIndex(fillType)\n\n                if fillType ~ = FillType.UNKNOWN and heightType ~ = nil then\n                    local innerRadius = 0.5\n                    local outerRadius = 2\n                    local capacity = self:getFillUnitCapacity(levelerNode.fillUnitIndex)\n\n                    -- limit the leveler node Y direction to the world Y(So the node + offset can be higher as the node but cannot dig into the ground when facing downwards)\n                    local dirY = 0\n                    if levelerNode.alignToWorldY then\n                        local dirX, dirZ\n                        dirX, dirY, dirZ = localDirectionToWorld(levelerNode.referenceFrame, 0 , 0 , 1 )\n                        I3DUtil.setWorldDirection(levelerNode.node, dirX, math.max(dirY, 0 ), dirZ, 0 , 1 , 0 )\n                    end\n                    --#debug DebugGizmo.renderAtNode(levelerNode.node, "levelerNode")\n\n                    -- pick up at node\n                    if self:getIsLevelerPickupNodeActive(levelerNode) then\n                        if spec.pickUpDirection = = self.movingDirection and self.lastSpeed > 0.0001 then\n                            local sx,sy,sz = localToWorld(levelerNode.node, - levelerNode.halfWidth, levelerNode.yOffset, levelerNode.zOffset)\n                            local ex,ey,ez = localToWorld(levelerNode.node, levelerNode.halfWidth, levelerNode.yOffset, levelerNode.zOffset)\n\n                            --#debug DebugUtil.drawDebugLine(sx, sy, sz, ex, ey, ez, 0, 1, 0)\n\n                            if dirY > = 0 then\n                                local _, sy2, _ = localToWorld(levelerNode.node, - levelerNode.halfWidth, levelerNode.yOffset, levelerNode.zOffset + innerRadius)\n                                local _, ey2, _ = localToWorld(levelerNode.node, levelerNode.halfWidth, levelerNode.yOffset, levelerNode.zOffset + innerRadius)\n\n                                sy = math.max(sy, sy2)\n                                ey = math.max(ey, ey2)\n                            end\n\n                            fillLevel = self:getFillUnitFillLevel(levelerNode.fillUnitIndex)\n                            local delta = - (capacity - fillLevel)\n                            local numHeightLimitChecks = levelerNode.numHeightLimitChecks\n                            if numHeightLimitChecks > 0 then\n                                local movementY = 0\n                                for i = 0 ,numHeightLimitChecks do\n                                    local t = i / numHeightLimitChecks\n                                    local xi = sx + (ex - sx) * t\n                                    local yi = sy + (ey - sy) * t\n                                    local zi = sz + (ez - sz) * t\n                                    local hi = DensityMapHeightUtil.getHeightAtWorldPos(xi,yi,zi)\n                                    movementY = math.max(movementY, hi - 0.05 - yi) -- limit to 5cm below surface\n                                end\n                                if movementY > 0 then\n                                    sy = sy + movementY\n                                    ey = ey + movementY\n                                end\n                            end\n\n                            levelerNode.lastPickUp, levelerNode.lineOffsetPickUp = DensityMapHeightUtil.tipToGroundAroundLine( self , delta, fillType, sx,sy,sz, ex,ey,ez, innerRadius, outerRadius, levelerNode.lineOffsetPickUp, true , nil )\n\n                            --#debug DebugUtil.drawDebugLine(sx, sy, sz, ex, ey, ez, 1, 0, 0, innerRadius)\n\n                            if levelerNode.lastPickUp < 0 then\n                                if self.notifiyBunkerSilo ~ = nil then\n                                    self:notifiyBunkerSilo(levelerNode.lastPickUp, fillType, (sx + ex) * 0.5 , (sy + ey) * 0.5 , (sz + ez) * 0.5 )\n                                end\n\n                                levelerNode.lastPickUp = levelerNode.lastPickUp + spec.litersToPickup\n                                spec.litersToPickup = 0\n\n                                self:addFillUnitFillLevel( self:getOwnerFarmId(), levelerNode.fillUnitIndex, - levelerNode.lastPickUp, fillType, ToolType.UNDEFINED, nil )\n                                pickedUpFillLevel = levelerNode.lastPickUp\n                            end\n                        end\n                    end\n\n                    local lastPickUpPerMS = - pickedUpFillLevel\n\n                    spec.lastFillLevelMovedBuffer = spec.lastFillLevelMovedBuffer + lastPickUpPerMS\n                    spec.lastFillLevelMovedBufferTimer = spec.lastFillLevelMovedBufferTimer + dt\n                    if spec.lastFillLevelMovedBufferTimer > spec.lastFillLevelMovedBufferTime then\n                        spec.lastFillLevelMovedTarget = spec.lastFillLevelMovedBuffer / spec.lastFillLevelMovedBufferTimer\n\n                        spec.lastFillLevelMovedBufferTimer = 0\n                        spec.lastFillLevelMovedBuffer = 0\n                    end\n\n                    if self.movingDirection < 0 and self.lastSpeed * 3600 > 0.5 then\n                        spec.lastFillLevelMovedBuffer = 0\n                    end\n\n                    -- drop at node\n                    fillLevel = self:getFillUnitFillLevel(levelerNode.fillUnitIndex)\n                    if fillLevel > 0 then\n                        local f = (fillLevel / capacity)\n                        local width = MathUtil.lerp(levelerNode.halfMinDropWidth, levelerNode.halfMaxDropWidth, f)\n\n                        local sx,sy,sz = localToWorld(levelerNode.node, - width, levelerNode.yOffset, levelerNode.zOffset)\n                        local ex,ey,ez = localToWorld(levelerNode.node, width, levelerNode.yOffset, levelerNode.zOffset)\n\n                        local yOffset = - 0.15\n\n                        levelerNode.lastDrop1, levelerNode.lineOffsetDrop1 = DensityMapHeightUtil.tipToGroundAroundLine( self , fillLevel, fillType, sx,sy + yOffset,sz, ex,ey + yOffset,ez, innerRadius, outerRadius, levelerNode.lineOffsetDrop1, true , nil )\n\n                        --#debug DebugUtil.drawDebugLine(sx,sy+yOffset,sz, ex,ey+yOffset,ez, 1, 1, 1, innerRadius)\n\n                        if levelerNode.lastDrop1 > 0 then\n                            local leftOver = fillLevel - levelerNode.lastDrop1\n                            if leftOver < = g_densityMapHeightManager:getMinValidLiterValue(fillType) then\n                                levelerNode.lastDrop1 = fillLevel\n                                spec.litersToPickup = spec.litersToPickup + leftOver\n                            end\n                            self:addFillUnitFillLevel( self:getOwnerFarmId(), levelerNode.fillUnitIndex, - levelerNode.lastDrop1, fillType, ToolType.UNDEFINED, nil )\n                        end\n                    end\n\n                    -- drop further at front\n                    fillLevel = self:getFillUnitFillLevel(levelerNode.fillUnitIndex)\n\n                    if fillLevel > 0 then\n                        local dropOffset = MathUtil.lerp(levelerNode.minDropDirOffset, levelerNode.maxDropDirOffset, spec.lastFillLevelMovedPct)\n\n                        local wx, wy, wz = localToWorld(levelerNode.node, 0 , levelerNode.yOffset, 0 )\n                        local tx, ty, tz = localToWorld(levelerNode.node, 0 , levelerNode.yOffset, levelerNode.zOffset + dropOffset)\n\n                        levelerNode.raycastLastFillType = fillType\n                        levelerNode.raycastLastRadius = outerRadius\n                        levelerNode.raycastHitObject = false\n                        local rDirX, rDirY, rDirZ = tx - wx, ty - wy, tz - wz\n                        local distance = MathUtil.vector3Length(rDirX, rDirY, rDirZ)\n                        rDirX, rDirY, rDirZ = MathUtil.vector3Normalize(rDirX, rDirY, rDirZ)\n                        raycastAllAsync(wx, wy, wz, rDirX, rDirY, rDirZ, distance, "onLevelerRaycastCallback" , levelerNode, Leveler.COLLISION_MASK)\n\n                        --#debug drawDebugLine(wx, wy, wz, 1, 0, 0, wx+rDirX*distance, wy+rDirY*distance, wz+rDirZ*distance, 0, 1, 0, true)\n                    end\n                else\n                        spec.lastFillLevelMovedBuffer = 0\n                        spec.lastFillLevelMovedTarget = 0\n                    end\n\n                    -- call fill level changed callack to inform bunker silo about change\n                    if pickedUpFillLevel < 0 and fillType ~ = FillType.UNKNOWN then\n                        self:notifiyBunkerSilo(pickedUpFillLevel, fillType)\n                    end\n\n                    if levelerNode.allowsSmoothing and(levelerNode.smoothDirection = = 0 or self.movingDirection = = levelerNode.smoothDirection) then\n                        local smoothAmount = 0\n                        if self.lastSpeedReal > 0.0002 then -- start smoothing if driving faster than 0.7km/h\n                            smoothAmount = spec.smoothAccumulation + math.max( self.lastMovedDistance * 0.5 , 0.0003 * dt) -- smooth 1.2m per meter driving or at least 0.3m/s\n                            local rounded = DensityMapHeightUtil.getRoundedHeightValue(smoothAmount)\n                            spec.smoothAccumulation = smoothAmount - rounded\n                        else\n                                spec.smoothAccumulation = 0\n                            end\n\n                            if smoothAmount > 0 then\n                                DensityMapHeightUtil.smoothAroundLine(levelerNode.node, levelerNode.width, levelerNode.smoothGroundRadius, levelerNode.smoothOverlap, smoothAmount, true )\n                            end\n                        end\n                    end\n\n                    local smoothFactor = 0.05\n                    if spec.lastFillLevelMovedTarget = = 0 then\n                        smoothFactor = 0.2\n                    end\n\n                    spec.lastFillLevelMoved = spec.lastFillLevelMoved * ( 1 - smoothFactor) + spec.lastFillLevelMovedTarget * smoothFactor\n                    if spec.lastFillLevelMoved < 0.005 then\n                        spec.lastFillLevelMoved = 0\n                    end\n\n                    local oldPercentage = spec.lastFillLevelMovedPct\n                    spec.lastFillLevelMovedPct = math.max( math.min(spec.lastFillLevelMoved / spec.maxFillLevelPerMS, 1 ), 0 )\n\n                    if spec.lastFillLevelMovedPct ~ = oldPercentage then\n                        self:raiseDirtyFlags(spec.dirtyFlag)\n                    end\n\n                    if spec.forceNode ~ = nil then\n                        if self.movingDirection = = spec.forceDir and spec.lastFillLevelMoved > 0 then\n                            spec.lastForce = - spec.maxForce * spec.lastFillLevelMovedPct\n                            local dx, dy, dz = localDirectionToWorld(spec.forceDirNode, 0 , 0 , spec.lastForce)\n                            local px, py, pz = getCenterOfMass(spec.forceNode)\n\n                            addForce(spec.forceNode, dx, dy, dz, px, py, pz, true )\n                        end\n                    end\n                end\n            end\n\n'})}),"\n",(0,t.jsx)(n.h3,{id:"onwriteupdatestream",children:"onWriteUpdateStream"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Description"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"Called on on update"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Definition"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"onWriteUpdateStream(integer streamId, table connection, integer dirtyMask)"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"integer"}),(0,t.jsx)(n.th,{children:"streamId"}),(0,t.jsx)(n.th,{children:"stream ID"})]})}),(0,t.jsxs)(n.tbody,{children:[(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"table"}),(0,t.jsx)(n.td,{children:"connection"}),(0,t.jsx)(n.td,{children:"connection"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"integer"}),(0,t.jsx)(n.td,{children:"dirtyMask"}),(0,t.jsx)(n.td,{children:"dirty mask"})]})]})]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Code"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:"function Leveler:onWriteUpdateStream(streamId, connection, dirtyMask)\n    if not connection:getIsServer() then\n        local spec = self.spec_leveler\n        if streamWriteBool(streamId, bit32.band(dirtyMask, spec.dirtyFlag) ~ = 0 ) then\n            streamWriteUIntN(streamId, spec.lastFillLevelMovedPct * Leveler.LEVEL_MAX_VALUE, Leveler.LEVEL_NUM_BITS)\n        end\n    end\nend\n\n"})}),"\n",(0,t.jsx)(n.h3,{id:"prerequisitespresent",children:"prerequisitesPresent"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Description"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"Checks if all prerequisite specializations are loaded"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Definition"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"prerequisitesPresent(table specializations)"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n",(0,t.jsx)(n.table,{children:(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"table"}),(0,t.jsx)(n.th,{children:"specializations"}),(0,t.jsx)(n.th,{children:"specializations"})]})})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Return Values"})}),"\n\n\n\n\n\n\n\n\n",(0,t.jsx)(n.table,{children:(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"table"}),(0,t.jsx)(n.th,{children:"hasPrerequisite"}),(0,t.jsx)(n.th,{children:"true if all prerequisite specializations are loaded"})]})})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Code"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:"function Leveler.prerequisitesPresent(specializations)\n    return SpecializationUtil.hasSpecialization( FillUnit , specializations) and SpecializationUtil.hasSpecialization( BunkerSiloInteractor , specializations)\nend\n\n"})}),"\n",(0,t.jsx)(n.h3,{id:"registereventlisteners",children:"registerEventListeners"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Description"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Definition"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"registerEventListeners()"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,t.jsx)(n.table,{children:(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"any"}),(0,t.jsx)(n.th,{children:"vehicleType"})]})})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Code"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:'function Leveler.registerEventListeners(vehicleType)\n    SpecializationUtil.registerEventListener(vehicleType, "onLoad" , Leveler )\n    SpecializationUtil.registerEventListener(vehicleType, "onDelete" , Leveler )\n    SpecializationUtil.registerEventListener(vehicleType, "onReadUpdateStream" , Leveler )\n    SpecializationUtil.registerEventListener(vehicleType, "onWriteUpdateStream" , Leveler )\n    SpecializationUtil.registerEventListener(vehicleType, "onUpdate" , Leveler )\nend\n\n'})}),"\n",(0,t.jsx)(n.h3,{id:"registerfunctions",children:"registerFunctions"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Description"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Definition"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"registerFunctions()"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,t.jsx)(n.table,{children:(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"any"}),(0,t.jsx)(n.th,{children:"vehicleType"})]})})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Code"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:'function Leveler.registerFunctions(vehicleType)\n    SpecializationUtil.registerFunction(vehicleType, "getIsLevelerPickupNodeActive" , Leveler.getIsLevelerPickupNodeActive)\n    SpecializationUtil.registerFunction(vehicleType, "loadLevelerNodeFromXML" , Leveler.loadLevelerNodeFromXML)\n    SpecializationUtil.registerFunction(vehicleType, "onLevelerRaycastCallback" , Leveler.onLevelerRaycastCallback)\nend\n\n'})}),"\n",(0,t.jsx)(n.h3,{id:"registeroverwrittenfunctions",children:"registerOverwrittenFunctions"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Description"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Definition"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"registerOverwrittenFunctions()"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,t.jsx)(n.table,{children:(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"any"}),(0,t.jsx)(n.th,{children:"vehicleType"})]})})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Code"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:'function Leveler.registerOverwrittenFunctions(vehicleType)\n    SpecializationUtil.registerOverwrittenFunction(vehicleType, "getIsAttacherJointControlDampingAllowed" , Leveler.getIsAttacherJointControlDampingAllowed)\nend\n\n'})})]})}function h(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(a,{...e})}):a(e)}}}]);