"use strict";(globalThis.webpackChunkfs25_community_luadoc=globalThis.webpackChunkfs25_community_luadoc||[]).push([[68133],{28453(e,n,s){s.d(n,{R:()=>i,x:()=>o});var t=s(96540);const l={},r=t.createContext(l);function i(e){const n=t.useContext(r);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(l):e.components||l:i(e.components),t.createElement(r.Provider,{value:n},e.children)}},73154(e,n,s){s.r(n),s.d(n,{assets:()=>c,contentTitle:()=>o,default:()=>h,frontMatter:()=>i,metadata:()=>t,toc:()=>a});const t=JSON.parse('{"id":"script/Wheels/WheelVisualPartConnector","title":"WheelVisualPartConnector","description":"WheelVisualPartConnector","source":"@site/../docs/script/Wheels/WheelVisualPartConnector.md","sourceDirName":"script/Wheels","slug":"/script/Wheels/WheelVisualPartConnector","permalink":"/FS25-Community-LUADOC/script/Wheels/WheelVisualPartConnector","draft":false,"unlisted":false,"tags":[],"version":"current","lastUpdatedAt":1767161192000,"frontMatter":{},"sidebar":"docsSidebar","previous":{"title":"WheelVisualPart","permalink":"/FS25-Community-LUADOC/script/Wheels/WheelVisualPart"},"next":{"title":"WheelVisualPartTire","permalink":"/FS25-Community-LUADOC/script/Wheels/WheelVisualPartTire"}}');var l=s(74848),r=s(28453);const i={},o=void 0,c={},a=[{value:"WheelVisualPartConnector",id:"wheelvisualpartconnector",level:2},{value:"loadFromXML",id:"loadfromxml",level:3},{value:"new",id:"new",level:3},{value:"registerXMLPaths",id:"registerxmlpaths",level:3},{value:"setNode",id:"setnode",level:3}];function d(e){const n={a:"a",blockquote:"blockquote",code:"code",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,r.R)(),...e.components};return(0,l.jsxs)(l.Fragment,{children:[(0,l.jsx)(n.h2,{id:"wheelvisualpartconnector",children:"WheelVisualPartConnector"}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Description"})}),"\n",(0,l.jsxs)(n.blockquote,{children:["\n",(0,l.jsx)(n.p,{children:"Visual tire that handles the tire deformation"}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Parent"})}),"\n",(0,l.jsxs)(n.blockquote,{children:["\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.a,{href:"?version=script&category=93&class=911",children:"WheelVisualPart"})}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Functions"})}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsx)(n.li,{children:(0,l.jsx)(n.a,{href:"#loadfromxml",children:"loadFromXML"})}),"\n",(0,l.jsx)(n.li,{children:(0,l.jsx)(n.a,{href:"#new",children:"new"})}),"\n",(0,l.jsx)(n.li,{children:(0,l.jsx)(n.a,{href:"#registerxmlpaths",children:"registerXMLPaths"})}),"\n",(0,l.jsx)(n.li,{children:(0,l.jsx)(n.a,{href:"#setnode",children:"setNode"})}),"\n"]}),"\n",(0,l.jsx)(n.h3,{id:"loadfromxml",children:"loadFromXML"}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Description"})}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Definition"})}),"\n",(0,l.jsxs)(n.blockquote,{children:["\n",(0,l.jsx)(n.p,{children:"loadFromXML()"}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,l.jsxs)(n.table,{children:[(0,l.jsx)(n.thead,{children:(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.th,{children:"any"}),(0,l.jsx)(n.th,{children:"xmlObject"})]})}),(0,l.jsx)(n.tbody,{children:(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{children:"any"}),(0,l.jsx)(n.td,{children:"key"})]})})]}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Code"})}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-lua",children:'function WheelVisualPartConnector:loadFromXML(xmlObject, key)\n    if not WheelVisualPartConnector:superClass().loadFromXML( self , xmlObject, key) then\n        return false\n    end\n\n    self.useWidthAndDiam = xmlObject:getValue(key .. "#useWidthAndDiam" , false )\n    self.usePosAndScale = xmlObject:getValue(key .. "#usePosAndScale" , false )\n\n    self.diameter = xmlObject:getValue(key .. "#diameter" )\n    self.additionalOffset = xmlObject:getValue(key .. "#offset" , 0 )\n    self.hookOffset = xmlObject:getValue(key .. "#hookOffset" )\n    self.width = xmlObject:getValue(key .. "#width" )\n\n    self.startPos = xmlObject:getValue(key .. "#startPos" )\n    self.endPos = xmlObject:getValue(key .. "#endPos" )\n    self.startPosOffset = xmlObject:getValue(key .. "#startPosOffset" )\n    self.endPosOffset = xmlObject:getValue(key .. "#endPosOffset" )\n\n    self.uniformScale = xmlObject:getValue(key .. "#uniformScale" )\n\n    return true\nend\n\n'})}),"\n",(0,l.jsx)(n.h3,{id:"new",children:"new"}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Description"})}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Definition"})}),"\n",(0,l.jsxs)(n.blockquote,{children:["\n",(0,l.jsx)(n.p,{children:"new()"}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,l.jsxs)(n.table,{children:[(0,l.jsx)(n.thead,{children:(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.th,{children:"any"}),(0,l.jsx)(n.th,{children:"name"})]})}),(0,l.jsxs)(n.tbody,{children:[(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{children:"any"}),(0,l.jsx)(n.td,{children:"visualWheel"})]}),(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{children:"any"}),(0,l.jsx)(n.td,{children:"linkNode"})]}),(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{children:"any"}),(0,l.jsx)(n.td,{children:"customMt"})]})]})]}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Code"})}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-lua",children:"function WheelVisualPartConnector.new(name, visualWheel, linkNode, customMt)\n    local self = WheelVisualPart.new(name, visualWheel, linkNode, WheelVisualPartConnector _mt)\n\n    return self\nend\n\n"})}),"\n",(0,l.jsx)(n.h3,{id:"registerxmlpaths",children:"registerXMLPaths"}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Description"})}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Definition"})}),"\n",(0,l.jsxs)(n.blockquote,{children:["\n",(0,l.jsx)(n.p,{children:"registerXMLPaths()"}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,l.jsxs)(n.table,{children:[(0,l.jsx)(n.thead,{children:(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.th,{children:"any"}),(0,l.jsx)(n.th,{children:"schema"})]})}),(0,l.jsxs)(n.tbody,{children:[(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{children:"any"}),(0,l.jsx)(n.td,{children:"key"})]}),(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{children:"any"}),(0,l.jsx)(n.td,{children:"name"})]})]})]}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Code"})}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-lua",children:'function WheelVisualPartConnector.registerXMLPaths(schema, key, name)\n    WheelVisualPart.registerXMLPaths(schema, key, name)\n\n    schema:register(XMLValueType.BOOL, key .. "#useWidthAndDiam" , "Use width and diameter from connector definition" , false )\n    schema:register(XMLValueType.BOOL, key .. "#usePosAndScale" , "Use position and scale from connector definition" , false )\n\n    schema:register(XMLValueType.FLOAT, key .. "#diameter" , "Diameter for shader(inch)" )\n        schema:register(XMLValueType.FLOAT, key .. "#offset" , "Additional connector X offset(m)" , 0 )\n        schema:register(XMLValueType.FLOAT, key .. "#hookOffset" , "Offset to the hook from the end of the connector outer rim(inch)" , "width of additional wheel" )\n        schema:register(XMLValueType.FLOAT, key .. "#width" , "Width for shader(inch)" )\n            schema:register(XMLValueType.FLOAT, key .. "#startPos" , "Start pos for shader(inch)" )\n                schema:register(XMLValueType.FLOAT, key .. "#endPos" , "End pos for shader(inch)" )\n                    schema:register(XMLValueType.FLOAT, key .. "#startPosOffset" , "Start pos offset for shader(inch) (will be added on top if it\'s automatically calculated)" )\n                        schema:register(XMLValueType.FLOAT, key .. "#endPosOffset" , "End pos offset for shader(inch) (will be added on top if it\'s automatically calculated)" )\n                            schema:register(XMLValueType.FLOAT, key .. "#uniformScale" , "Uniform scale for shader" )\n                            end\n\n'})}),"\n",(0,l.jsx)(n.h3,{id:"setnode",children:"setNode"}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Description"})}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Definition"})}),"\n",(0,l.jsxs)(n.blockquote,{children:["\n",(0,l.jsx)(n.p,{children:"setNode()"}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,l.jsx)(n.table,{children:(0,l.jsx)(n.thead,{children:(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.th,{children:"any"}),(0,l.jsx)(n.th,{children:"node"})]})})}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Code"})}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-lua",children:'function WheelVisualPartConnector:setNode(node)\n    WheelVisualPartConnector:superClass().setNode( self , node)\n\n    local connectedWheel = self.visualWheel.connectedVisualWheel\n    if connectedWheel ~ = nil then\n        setTranslation(node, localToLocal(connectedWheel.node, getParent(node), 0 , 0 , 0 ))\n\n        local offsetDirection = self.visualWheel.connectedVisualWheelOffsetDirection\n        local wheelWidthInch = MathUtil.mToInch( self.visualWheel.width)\n        local connectedWheelOffsetInch = MathUtil.mToInch( self.visualWheel.connectedVisualWheelOffset)\n        local connectedWheelWidthInch = MathUtil.mToInch(connectedWheel.width)\n\n        if not self.useWidthAndDiam then\n            self:setShaderParameterRec(node, "connectorPos" , 0 , wheelWidthInch + ( self.startPosOffset or 0 ), connectedWheelOffsetInch + ( self.endPosOffset or 0 ), self.hookOffset or wheelWidthInch)\n            self:setShaderParameterRec(node, "widthAndDiam" , nil , self.diameter or self.visualWheel.rimDiameter or 0 , nil , nil )\n        else\n                local connectorOffset = offsetDirection * ((( 0.5 * connectedWheelWidthInch + 0.5 * connectedWheelOffsetInch) * 0.0254 ) + self.additionalOffset) -- in meters\n                local connectorDiameter = self.diameter or self.visualWheel.rimDiameter or 0\n\n                local x, y, z = getTranslation(node)\n                setTranslation(node, x + connectorOffset, y, z)\n                self:setShaderParameterRec(node, "widthAndDiam" , self.width, connectorDiameter, nil , nil )\n            end\n\n            if self.usePosAndScale then\n                self:setShaderParameterRec(node, "connectorPosAndScale" , self.startPos, self.endPos, self.uniformScale, nil )\n            end\n        end\n    end\n\n'})})]})}function h(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,l.jsx)(n,{...e,children:(0,l.jsx)(d,{...e})}):d(e)}}}]);