"use strict";(globalThis.webpackChunkfs25_community_luadoc=globalThis.webpackChunkfs25_community_luadoc||[]).push([[99811],{28453(n,e,i){i.d(e,{R:()=>l,x:()=>s});var t=i(96540);const a={},r=t.createContext(a);function l(n){const e=t.useContext(r);return t.useMemo(function(){return"function"==typeof n?n(e):{...e,...n}},[e,n])}function s(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(a):n.components||a:l(n.components),t.createElement(r.Provider,{value:e},n.children)}},57253(n,e,i){i.r(e),i.d(e,{assets:()=>d,contentTitle:()=>s,default:()=>m,frontMatter:()=>l,metadata:()=>t,toc:()=>o});const t=JSON.parse('{"id":"script/Specializations/AnimatedVehicle","title":"AnimatedVehicle","description":"AnimatedVehicle","source":"@site/../docs/script/Specializations/AnimatedVehicle.md","sourceDirName":"script/Specializations","slug":"/script/Specializations/AnimatedVehicle","permalink":"/FS25-Community-LUADOC/script/Specializations/AnimatedVehicle","draft":false,"unlisted":false,"tags":[],"version":"current","lastUpdatedAt":1767161192000,"frontMatter":{},"sidebar":"docsSidebar","previous":{"title":"AIVehicleObstacle","permalink":"/FS25-Community-LUADOC/script/Specializations/AIVehicleObstacle"},"next":{"title":"ArticulatedAxis","permalink":"/FS25-Community-LUADOC/script/Specializations/ArticulatedAxis"}}');var a=i(74848),r=i(28453);const l={},s=void 0,d={},o=[{value:"AnimatedVehicle",id:"animatedvehicle",level:2},{value:"animPartSorter",id:"animpartsorter",level:3},{value:"animPartSorterReverse",id:"animpartsorterreverse",level:3},{value:"findCurrentPartIndex",id:"findcurrentpartindex",level:3},{value:"getAnimationByName",id:"getanimationbyname",level:3},{value:"getAnimationDuration",id:"getanimationduration",level:3},{value:"getAnimationExists",id:"getanimationexists",level:3},{value:"getAnimationSpeed",id:"getanimationspeed",level:3},{value:"getAnimationTime",id:"getanimationtime",level:3},{value:"getDurationToEndOfPart",id:"getdurationtoendofpart",level:3},{value:"getIsAnimationPlaying",id:"getisanimationplaying",level:3},{value:"getIsMovingPartActive",id:"getismovingpartactive",level:3},{value:"getIsMovingToolActive",id:"getismovingtoolactive",level:3},{value:"getIsSpeedRotatingPartActive",id:"getisspeedrotatingpartactive",level:3},{value:"getIsWorkAreaActive",id:"getisworkareaactive",level:3},{value:"getMovedLimitedValue",id:"getmovedlimitedvalue",level:3},{value:"getNextPartIsPlaying",id:"getnextpartisplaying",level:3},{value:"getNumOfActiveAnimations",id:"getnumofactiveanimations",level:3},{value:"getRealAnimationTime",id:"getrealanimationtime",level:3},{value:"initializeAnimationPart",id:"initializeanimationpart",level:3},{value:"initializeAnimationPartAttribute",id:"initializeanimationpartattribute",level:3},{value:"initializeAnimationParts",id:"initializeanimationparts",level:3},{value:"initSpecialization",id:"initspecialization",level:3},{value:"loadAnimation",id:"loadanimation",level:3},{value:"loadAnimationPart",id:"loadanimationpart",level:3},{value:"loadMovingPartFromXML",id:"loadmovingpartfromxml",level:3},{value:"loadMovingToolFromXML",id:"loadmovingtoolfromxml",level:3},{value:"loadSpeedRotatingPartFromXML",id:"loadspeedrotatingpartfromxml",level:3},{value:"loadStaticAnimationPart",id:"loadstaticanimationpart",level:3},{value:"loadStaticAnimationPartValues",id:"loadstaticanimationpartvalues",level:3},{value:"loadWorkAreaFromXML",id:"loadworkareafromxml",level:3},{value:"onDelete",id:"ondelete",level:3},{value:"onLoad",id:"onload",level:3},{value:"onPostLoad",id:"onpostload",level:3},{value:"onPreLoad",id:"onpreload",level:3},{value:"onRegisterAnimationValueTypes",id:"onregisteranimationvaluetypes",level:3},{value:"onUpdate",id:"onupdate",level:3},{value:"playAnimation",id:"playanimation",level:3},{value:"postInitializeAnimationPart",id:"postinitializeanimationpart",level:3},{value:"prerequisitesPresent",id:"prerequisitespresent",level:3},{value:"registerAnimationValueType",id:"registeranimationvaluetype",level:3},{value:"registerAnimationXMLPaths",id:"registeranimationxmlpaths",level:3},{value:"registerEventListeners",id:"registereventlisteners",level:3},{value:"registerEvents",id:"registerevents",level:3},{value:"registerFunctions",id:"registerfunctions",level:3},{value:"registerOverwrittenFunctions",id:"registeroverwrittenfunctions",level:3},{value:"resetAnimationPartValues",id:"resetanimationpartvalues",level:3},{value:"resetAnimationValues",id:"resetanimationvalues",level:3},{value:"setAnimationSpeed",id:"setanimationspeed",level:3},{value:"setAnimationStopTime",id:"setanimationstoptime",level:3},{value:"setAnimationTime",id:"setanimationtime",level:3},{value:"setMovedLimitedValues3",id:"setmovedlimitedvalues3",level:3},{value:"setMovedLimitedValues4",id:"setmovedlimitedvalues4",level:3},{value:"setMovedLimitedValuesN",id:"setmovedlimitedvaluesn",level:3},{value:"setRealAnimationTime",id:"setrealanimationtime",level:3},{value:"stopAnimation",id:"stopanimation",level:3},{value:"updateAnimation",id:"updateanimation",level:3},{value:"updateAnimationByName",id:"updateanimationbyname",level:3},{value:"updateAnimationCurrentTime",id:"updateanimationcurrenttime",level:3},{value:"updateAnimationPart",id:"updateanimationpart",level:3},{value:"updateAnimations",id:"updateanimations",level:3}];function c(n){const e={a:"a",blockquote:"blockquote",code:"code",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,r.R)(),...n.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(e.h2,{id:"animatedvehicle",children:"AnimatedVehicle"}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)(e.strong,{children:"Description"})}),"\n",(0,a.jsxs)(e.blockquote,{children:["\n",(0,a.jsx)(e.p,{children:"Specialization adding support for (keyframe)animations to vehicles"}),"\n"]}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)(e.strong,{children:"Functions"})}),"\n",(0,a.jsxs)(e.ul,{children:["\n",(0,a.jsx)(e.li,{children:(0,a.jsx)(e.a,{href:"#animpartsorter",children:"animPartSorter"})}),"\n",(0,a.jsx)(e.li,{children:(0,a.jsx)(e.a,{href:"#animpartsorterreverse",children:"animPartSorterReverse"})}),"\n",(0,a.jsx)(e.li,{children:(0,a.jsx)(e.a,{href:"#findcurrentpartindex",children:"findCurrentPartIndex"})}),"\n",(0,a.jsx)(e.li,{children:(0,a.jsx)(e.a,{href:"#getanimationbyname",children:"getAnimationByName"})}),"\n",(0,a.jsx)(e.li,{children:(0,a.jsx)(e.a,{href:"#getanimationduration",children:"getAnimationDuration"})}),"\n",(0,a.jsx)(e.li,{children:(0,a.jsx)(e.a,{href:"#getanimationexists",children:"getAnimationExists"})}),"\n",(0,a.jsx)(e.li,{children:(0,a.jsx)(e.a,{href:"#getanimationspeed",children:"getAnimationSpeed"})}),"\n",(0,a.jsx)(e.li,{children:(0,a.jsx)(e.a,{href:"#getanimationtime",children:"getAnimationTime"})}),"\n",(0,a.jsx)(e.li,{children:(0,a.jsx)(e.a,{href:"#getdurationtoendofpart",children:"getDurationToEndOfPart"})}),"\n",(0,a.jsx)(e.li,{children:(0,a.jsx)(e.a,{href:"#getisanimationplaying",children:"getIsAnimationPlaying"})}),"\n",(0,a.jsx)(e.li,{children:(0,a.jsx)(e.a,{href:"#getismovingpartactive",children:"getIsMovingPartActive"})}),"\n",(0,a.jsx)(e.li,{children:(0,a.jsx)(e.a,{href:"#getismovingtoolactive",children:"getIsMovingToolActive"})}),"\n",(0,a.jsx)(e.li,{children:(0,a.jsx)(e.a,{href:"#getisspeedrotatingpartactive",children:"getIsSpeedRotatingPartActive"})}),"\n",(0,a.jsx)(e.li,{children:(0,a.jsx)(e.a,{href:"#getisworkareaactive",children:"getIsWorkAreaActive"})}),"\n",(0,a.jsx)(e.li,{children:(0,a.jsx)(e.a,{href:"#getmovedlimitedvalue",children:"getMovedLimitedValue"})}),"\n",(0,a.jsx)(e.li,{children:(0,a.jsx)(e.a,{href:"#getnextpartisplaying",children:"getNextPartIsPlaying"})}),"\n",(0,a.jsx)(e.li,{children:(0,a.jsx)(e.a,{href:"#getnumofactiveanimations",children:"getNumOfActiveAnimations"})}),"\n",(0,a.jsx)(e.li,{children:(0,a.jsx)(e.a,{href:"#getrealanimationtime",children:"getRealAnimationTime"})}),"\n",(0,a.jsx)(e.li,{children:(0,a.jsx)(e.a,{href:"#initializeanimationpart",children:"initializeAnimationPart"})}),"\n",(0,a.jsx)(e.li,{children:(0,a.jsx)(e.a,{href:"#initializeanimationpartattribute",children:"initializeAnimationPartAttribute"})}),"\n",(0,a.jsx)(e.li,{children:(0,a.jsx)(e.a,{href:"#initializeanimationparts",children:"initializeAnimationParts"})}),"\n",(0,a.jsx)(e.li,{children:(0,a.jsx)(e.a,{href:"#initspecialization",children:"initSpecialization"})}),"\n",(0,a.jsx)(e.li,{children:(0,a.jsx)(e.a,{href:"#loadanimation",children:"loadAnimation"})}),"\n",(0,a.jsx)(e.li,{children:(0,a.jsx)(e.a,{href:"#loadanimationpart",children:"loadAnimationPart"})}),"\n",(0,a.jsx)(e.li,{children:(0,a.jsx)(e.a,{href:"#loadmovingpartfromxml",children:"loadMovingPartFromXML"})}),"\n",(0,a.jsx)(e.li,{children:(0,a.jsx)(e.a,{href:"#loadmovingtoolfromxml",children:"loadMovingToolFromXML"})}),"\n",(0,a.jsx)(e.li,{children:(0,a.jsx)(e.a,{href:"#loadspeedrotatingpartfromxml",children:"loadSpeedRotatingPartFromXML"})}),"\n",(0,a.jsx)(e.li,{children:(0,a.jsx)(e.a,{href:"#loadstaticanimationpart",children:"loadStaticAnimationPart"})}),"\n",(0,a.jsx)(e.li,{children:(0,a.jsx)(e.a,{href:"#loadstaticanimationpartvalues",children:"loadStaticAnimationPartValues"})}),"\n",(0,a.jsx)(e.li,{children:(0,a.jsx)(e.a,{href:"#loadworkareafromxml",children:"loadWorkAreaFromXML"})}),"\n",(0,a.jsx)(e.li,{children:(0,a.jsx)(e.a,{href:"#ondelete",children:"onDelete"})}),"\n",(0,a.jsx)(e.li,{children:(0,a.jsx)(e.a,{href:"#onload",children:"onLoad"})}),"\n",(0,a.jsx)(e.li,{children:(0,a.jsx)(e.a,{href:"#onpostload",children:"onPostLoad"})}),"\n",(0,a.jsx)(e.li,{children:(0,a.jsx)(e.a,{href:"#onpreload",children:"onPreLoad"})}),"\n",(0,a.jsx)(e.li,{children:(0,a.jsx)(e.a,{href:"#onregisteranimationvaluetypes",children:"onRegisterAnimationValueTypes"})}),"\n",(0,a.jsx)(e.li,{children:(0,a.jsx)(e.a,{href:"#onupdate",children:"onUpdate"})}),"\n",(0,a.jsx)(e.li,{children:(0,a.jsx)(e.a,{href:"#playanimation",children:"playAnimation"})}),"\n",(0,a.jsx)(e.li,{children:(0,a.jsx)(e.a,{href:"#postinitializeanimationpart",children:"postInitializeAnimationPart"})}),"\n",(0,a.jsx)(e.li,{children:(0,a.jsx)(e.a,{href:"#prerequisitespresent",children:"prerequisitesPresent"})}),"\n",(0,a.jsx)(e.li,{children:(0,a.jsx)(e.a,{href:"#registeranimationvaluetype",children:"registerAnimationValueType"})}),"\n",(0,a.jsx)(e.li,{children:(0,a.jsx)(e.a,{href:"#registeranimationxmlpaths",children:"registerAnimationXMLPaths"})}),"\n",(0,a.jsx)(e.li,{children:(0,a.jsx)(e.a,{href:"#registereventlisteners",children:"registerEventListeners"})}),"\n",(0,a.jsx)(e.li,{children:(0,a.jsx)(e.a,{href:"#registerevents",children:"registerEvents"})}),"\n",(0,a.jsx)(e.li,{children:(0,a.jsx)(e.a,{href:"#registerfunctions",children:"registerFunctions"})}),"\n",(0,a.jsx)(e.li,{children:(0,a.jsx)(e.a,{href:"#registeroverwrittenfunctions",children:"registerOverwrittenFunctions"})}),"\n",(0,a.jsx)(e.li,{children:(0,a.jsx)(e.a,{href:"#resetanimationpartvalues",children:"resetAnimationPartValues"})}),"\n",(0,a.jsx)(e.li,{children:(0,a.jsx)(e.a,{href:"#resetanimationvalues",children:"resetAnimationValues"})}),"\n",(0,a.jsx)(e.li,{children:(0,a.jsx)(e.a,{href:"#setanimationspeed",children:"setAnimationSpeed"})}),"\n",(0,a.jsx)(e.li,{children:(0,a.jsx)(e.a,{href:"#setanimationstoptime",children:"setAnimationStopTime"})}),"\n",(0,a.jsx)(e.li,{children:(0,a.jsx)(e.a,{href:"#setanimationtime",children:"setAnimationTime"})}),"\n",(0,a.jsx)(e.li,{children:(0,a.jsx)(e.a,{href:"#setmovedlimitedvalues",children:"setMovedLimitedValues3"})}),"\n",(0,a.jsx)(e.li,{children:(0,a.jsx)(e.a,{href:"#setmovedlimitedvalues",children:"setMovedLimitedValues4"})}),"\n",(0,a.jsx)(e.li,{children:(0,a.jsx)(e.a,{href:"#setmovedlimitedvaluesn",children:"setMovedLimitedValuesN"})}),"\n",(0,a.jsx)(e.li,{children:(0,a.jsx)(e.a,{href:"#setrealanimationtime",children:"setRealAnimationTime"})}),"\n",(0,a.jsx)(e.li,{children:(0,a.jsx)(e.a,{href:"#stopanimation",children:"stopAnimation"})}),"\n",(0,a.jsx)(e.li,{children:(0,a.jsx)(e.a,{href:"#updateanimation",children:"updateAnimation"})}),"\n",(0,a.jsx)(e.li,{children:(0,a.jsx)(e.a,{href:"#updateanimationbyname",children:"updateAnimationByName"})}),"\n",(0,a.jsx)(e.li,{children:(0,a.jsx)(e.a,{href:"#updateanimationcurrenttime",children:"updateAnimationCurrentTime"})}),"\n",(0,a.jsx)(e.li,{children:(0,a.jsx)(e.a,{href:"#updateanimationpart",children:"updateAnimationPart"})}),"\n",(0,a.jsx)(e.li,{children:(0,a.jsx)(e.a,{href:"#updateanimations",children:"updateAnimations"})}),"\n"]}),"\n",(0,a.jsx)(e.h3,{id:"animpartsorter",children:"animPartSorter"}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)(e.strong,{children:"Description"})}),"\n",(0,a.jsxs)(e.blockquote,{children:["\n",(0,a.jsx)(e.p,{children:"Returns true if anim parts are in the right order"}),"\n"]}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)(e.strong,{children:"Definition"})}),"\n",(0,a.jsxs)(e.blockquote,{children:["\n",(0,a.jsx)(e.p,{children:"animPartSorter(table a, table b)"}),"\n"]}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)(e.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,a.jsxs)(e.table,{children:[(0,a.jsx)(e.thead,{children:(0,a.jsxs)(e.tr,{children:[(0,a.jsx)(e.th,{children:"table"}),(0,a.jsx)(e.th,{children:"a"}),(0,a.jsx)(e.th,{children:"part a to check"})]})}),(0,a.jsx)(e.tbody,{children:(0,a.jsxs)(e.tr,{children:[(0,a.jsx)(e.td,{children:"table"}),(0,a.jsx)(e.td,{children:"b"}),(0,a.jsx)(e.td,{children:"part b to check"})]})})]}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)(e.strong,{children:"Return Values"})}),"\n\n\n\n\n\n\n\n\n",(0,a.jsx)(e.table,{children:(0,a.jsx)(e.thead,{children:(0,a.jsxs)(e.tr,{children:[(0,a.jsx)(e.th,{children:"table"}),(0,a.jsx)(e.th,{children:"rightOrder"}),(0,a.jsx)(e.th,{children:"returns true if parts are in right order"})]})})}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)(e.strong,{children:"Code"})}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-lua",children:"function AnimatedVehicle.animPartSorter(a, b)\n    if a.startTime < b.startTime then\n        return true\n    elseif a.startTime = = b.startTime then\n            return a.duration < b.duration\n        end\n        return false\n    end\n\n"})}),"\n",(0,a.jsx)(e.h3,{id:"animpartsorterreverse",children:"animPartSorterReverse"}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)(e.strong,{children:"Description"})}),"\n",(0,a.jsxs)(e.blockquote,{children:["\n",(0,a.jsx)(e.p,{children:"Returns true if anim parts are in the reverse right order"}),"\n"]}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)(e.strong,{children:"Definition"})}),"\n",(0,a.jsxs)(e.blockquote,{children:["\n",(0,a.jsx)(e.p,{children:"animPartSorterReverse(table a, table b)"}),"\n"]}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)(e.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,a.jsxs)(e.table,{children:[(0,a.jsx)(e.thead,{children:(0,a.jsxs)(e.tr,{children:[(0,a.jsx)(e.th,{children:"table"}),(0,a.jsx)(e.th,{children:"a"}),(0,a.jsx)(e.th,{children:"part a to check"})]})}),(0,a.jsx)(e.tbody,{children:(0,a.jsxs)(e.tr,{children:[(0,a.jsx)(e.td,{children:"table"}),(0,a.jsx)(e.td,{children:"b"}),(0,a.jsx)(e.td,{children:"part b to check"})]})})]}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)(e.strong,{children:"Return Values"})}),"\n\n\n\n\n\n\n\n\n",(0,a.jsx)(e.table,{children:(0,a.jsx)(e.thead,{children:(0,a.jsxs)(e.tr,{children:[(0,a.jsx)(e.th,{children:"table"}),(0,a.jsx)(e.th,{children:"rightOrder"}),(0,a.jsx)(e.th,{children:"returns true if parts are in reverse right order"})]})})}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)(e.strong,{children:"Code"})}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-lua",children:"function AnimatedVehicle.animPartSorterReverse(a, b)\n    local endTimeA = a.startTime + a.duration\n    local endTimeB = b.startTime + b.duration\n    if endTimeA > endTimeB then\n        return true\n    elseif endTimeA = = endTimeB then\n            return a.startTime > b.startTime\n        end\n        return false\n    end\n\n"})}),"\n",(0,a.jsx)(e.h3,{id:"findcurrentpartindex",children:"findCurrentPartIndex"}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)(e.strong,{children:"Description"})}),"\n",(0,a.jsxs)(e.blockquote,{children:["\n",(0,a.jsx)(e.p,{children:"Find current playing part"}),"\n"]}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)(e.strong,{children:"Definition"})}),"\n",(0,a.jsxs)(e.blockquote,{children:["\n",(0,a.jsx)(e.p,{children:"findCurrentPartIndex(table animation)"}),"\n"]}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)(e.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n",(0,a.jsx)(e.table,{children:(0,a.jsx)(e.thead,{children:(0,a.jsxs)(e.tr,{children:[(0,a.jsx)(e.th,{children:"table"}),(0,a.jsx)(e.th,{children:"animation"}),(0,a.jsx)(e.th,{children:"animation"})]})})}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)(e.strong,{children:"Return Values"})}),"\n\n\n\n\n\n\n\n\n",(0,a.jsx)(e.table,{children:(0,a.jsx)(e.thead,{children:(0,a.jsxs)(e.tr,{children:[(0,a.jsx)(e.th,{children:"table"}),(0,a.jsx)(e.th,{children:"index"}),(0,a.jsx)(e.th,{children:"of current playing part"})]})})}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)(e.strong,{children:"Code"})}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-lua",children:"function AnimatedVehicle.findCurrentPartIndex(animation)\n    if animation.currentSpeed > 0 then\n        -- find the first part that is being played at the current time\n        animation.currentPartIndex = #animation.parts + 1\n        for i, part in ipairs(animation.parts) do\n            if part.startTime + part.duration > = animation.currentTime then\n                animation.currentPartIndex = i\n                break\n            end\n        end\n    else\n            -- find the last part that is being played at the current time(the first in partsReverse)\n            animation.currentPartIndex = #animation.partsReverse + 1\n            for i, part in ipairs(animation.partsReverse) do\n                if part.startTime < = animation.currentTime then\n                    animation.currentPartIndex = i\n                    break\n                end\n            end\n        end\n    end\n\n"})}),"\n",(0,a.jsx)(e.h3,{id:"getanimationbyname",children:"getAnimationByName"}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)(e.strong,{children:"Description"})}),"\n",(0,a.jsxs)(e.blockquote,{children:["\n",(0,a.jsx)(e.p,{children:"Returns the animation by given name"}),"\n"]}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)(e.strong,{children:"Definition"})}),"\n",(0,a.jsxs)(e.blockquote,{children:["\n",(0,a.jsx)(e.p,{children:"getAnimationByName(string name)"}),"\n"]}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)(e.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n",(0,a.jsx)(e.table,{children:(0,a.jsx)(e.thead,{children:(0,a.jsxs)(e.tr,{children:[(0,a.jsx)(e.th,{children:"string"}),(0,a.jsx)(e.th,{children:"name"}),(0,a.jsx)(e.th,{children:"name of animation"})]})})}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)(e.strong,{children:"Return Values"})}),"\n\n\n\n\n\n\n\n\n",(0,a.jsx)(e.table,{children:(0,a.jsx)(e.thead,{children:(0,a.jsxs)(e.tr,{children:[(0,a.jsx)(e.th,{children:"string"}),(0,a.jsx)(e.th,{children:"animation"}),(0,a.jsx)(e.th,{children:"animation data"})]})})}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)(e.strong,{children:"Code"})}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-lua",children:"function AnimatedVehicle:getAnimationByName(name)\n    return self.spec_animatedVehicle.animations[name]\nend\n\n"})}),"\n",(0,a.jsx)(e.h3,{id:"getanimationduration",children:"getAnimationDuration"}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)(e.strong,{children:"Description"})}),"\n",(0,a.jsxs)(e.blockquote,{children:["\n",(0,a.jsx)(e.p,{children:"Returns duration of animation"}),"\n"]}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)(e.strong,{children:"Definition"})}),"\n",(0,a.jsxs)(e.blockquote,{children:["\n",(0,a.jsx)(e.p,{children:"getAnimationDuration(string name)"}),"\n"]}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)(e.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n",(0,a.jsx)(e.table,{children:(0,a.jsx)(e.thead,{children:(0,a.jsxs)(e.tr,{children:[(0,a.jsx)(e.th,{children:"string"}),(0,a.jsx)(e.th,{children:"name"}),(0,a.jsx)(e.th,{children:"name of animation"})]})})}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)(e.strong,{children:"Return Values"})}),"\n\n\n\n\n\n\n\n\n",(0,a.jsx)(e.table,{children:(0,a.jsx)(e.thead,{children:(0,a.jsxs)(e.tr,{children:[(0,a.jsx)(e.th,{children:"string"}),(0,a.jsx)(e.th,{children:"duration"}),(0,a.jsx)(e.th,{children:"duration in ms"})]})})}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)(e.strong,{children:"Code"})}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-lua",children:"function AnimatedVehicle:getAnimationDuration(name)\n    local spec = self.spec_animatedVehicle\n\n    local animation = spec.animations[name]\n    if animation ~ = nil then\n        return animation.duration\n    end\n    return 1\nend\n\n"})}),"\n",(0,a.jsx)(e.h3,{id:"getanimationexists",children:"getAnimationExists"}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)(e.strong,{children:"Description"})}),"\n",(0,a.jsxs)(e.blockquote,{children:["\n",(0,a.jsx)(e.p,{children:"Returns true if animation exits"}),"\n"]}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)(e.strong,{children:"Definition"})}),"\n",(0,a.jsxs)(e.blockquote,{children:["\n",(0,a.jsx)(e.p,{children:"getAnimationExists(string name)"}),"\n"]}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)(e.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n",(0,a.jsx)(e.table,{children:(0,a.jsx)(e.thead,{children:(0,a.jsxs)(e.tr,{children:[(0,a.jsx)(e.th,{children:"string"}),(0,a.jsx)(e.th,{children:"name"}),(0,a.jsx)(e.th,{children:"name of animation"})]})})}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)(e.strong,{children:"Return Values"})}),"\n\n\n\n\n\n\n\n\n",(0,a.jsx)(e.table,{children:(0,a.jsx)(e.thead,{children:(0,a.jsxs)(e.tr,{children:[(0,a.jsx)(e.th,{children:"string"}),(0,a.jsx)(e.th,{children:"exists"}),(0,a.jsx)(e.th,{children:"animation axists"})]})})}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)(e.strong,{children:"Code"})}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-lua",children:"function AnimatedVehicle:getAnimationExists(name)\n    local spec = self.spec_animatedVehicle\n\n    return spec.animations[name] ~ = nil\nend\n\n"})}),"\n",(0,a.jsx)(e.h3,{id:"getanimationspeed",children:"getAnimationSpeed"}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)(e.strong,{children:"Description"})}),"\n",(0,a.jsxs)(e.blockquote,{children:["\n",(0,a.jsx)(e.p,{children:"Returns speed of animation"}),"\n"]}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)(e.strong,{children:"Definition"})}),"\n",(0,a.jsxs)(e.blockquote,{children:["\n",(0,a.jsx)(e.p,{children:"getAnimationSpeed(string name)"}),"\n"]}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)(e.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n",(0,a.jsx)(e.table,{children:(0,a.jsx)(e.thead,{children:(0,a.jsxs)(e.tr,{children:[(0,a.jsx)(e.th,{children:"string"}),(0,a.jsx)(e.th,{children:"name"}),(0,a.jsx)(e.th,{children:"name of animation"})]})})}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)(e.strong,{children:"Return Values"})}),"\n\n\n\n\n\n\n\n\n",(0,a.jsx)(e.table,{children:(0,a.jsx)(e.thead,{children:(0,a.jsxs)(e.tr,{children:[(0,a.jsx)(e.th,{children:"string"}),(0,a.jsx)(e.th,{children:"speed"}),(0,a.jsx)(e.th,{children:"speed"})]})})}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)(e.strong,{children:"Code"})}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-lua",children:"function AnimatedVehicle:getAnimationSpeed(name)\n    local spec = self.spec_animatedVehicle\n\n    local animation = spec.animations[name]\n    if animation ~ = nil then\n        return animation.currentSpeed\n    end\n\n    return 0\nend\n\n"})}),"\n",(0,a.jsx)(e.h3,{id:"getanimationtime",children:"getAnimationTime"}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)(e.strong,{children:"Description"})}),"\n",(0,a.jsxs)(e.blockquote,{children:["\n",(0,a.jsx)(e.p,{children:"Returns animation time"}),"\n"]}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)(e.strong,{children:"Definition"})}),"\n",(0,a.jsxs)(e.blockquote,{children:["\n",(0,a.jsx)(e.p,{children:"getAnimationTime(string name)"}),"\n"]}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)(e.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n",(0,a.jsx)(e.table,{children:(0,a.jsx)(e.thead,{children:(0,a.jsxs)(e.tr,{children:[(0,a.jsx)(e.th,{children:"string"}),(0,a.jsx)(e.th,{children:"name"}),(0,a.jsx)(e.th,{children:"name of animation"})]})})}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)(e.strong,{children:"Return Values"})}),"\n\n\n\n\n\n\n\n\n",(0,a.jsx)(e.table,{children:(0,a.jsx)(e.thead,{children:(0,a.jsxs)(e.tr,{children:[(0,a.jsx)(e.th,{children:"string"}),(0,a.jsx)(e.th,{children:"animTime"}),(0,a.jsx)(e.th,{children:"animation time [0..1]"})]})})}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)(e.strong,{children:"Code"})}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-lua",children:"function AnimatedVehicle:getAnimationTime(name)\n    local spec = self.spec_animatedVehicle\n\n    local animation = spec.animations[name]\n    if animation ~ = nil and animation.duration > 0 then\n        return animation.currentTime / animation.duration\n    end\n\n    return 0\nend\n\n"})}),"\n",(0,a.jsx)(e.h3,{id:"getdurationtoendofpart",children:"getDurationToEndOfPart"}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)(e.strong,{children:"Description"})}),"\n",(0,a.jsxs)(e.blockquote,{children:["\n",(0,a.jsx)(e.p,{children:"Returns duration to the end of current part"}),"\n"]}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)(e.strong,{children:"Definition"})}),"\n",(0,a.jsxs)(e.blockquote,{children:["\n",(0,a.jsx)(e.p,{children:"getDurationToEndOfPart(table part, table anim)"}),"\n"]}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)(e.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,a.jsxs)(e.table,{children:[(0,a.jsx)(e.thead,{children:(0,a.jsxs)(e.tr,{children:[(0,a.jsx)(e.th,{children:"table"}),(0,a.jsx)(e.th,{children:"part"}),(0,a.jsx)(e.th,{children:"part"})]})}),(0,a.jsx)(e.tbody,{children:(0,a.jsxs)(e.tr,{children:[(0,a.jsx)(e.td,{children:"table"}),(0,a.jsx)(e.td,{children:"anim"}),(0,a.jsx)(e.td,{children:"animation"})]})})]}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)(e.strong,{children:"Return Values"})}),"\n\n\n\n\n\n\n\n\n",(0,a.jsx)(e.table,{children:(0,a.jsx)(e.thead,{children:(0,a.jsxs)(e.tr,{children:[(0,a.jsx)(e.th,{children:"table"}),(0,a.jsx)(e.th,{children:"duration"}),(0,a.jsx)(e.th,{children:"duration to end of current part"})]})})}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)(e.strong,{children:"Code"})}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-lua",children:"function AnimatedVehicle.getDurationToEndOfPart(part, anim)\n    if anim.currentSpeed > 0 then\n        return part.startTime + part.duration - anim.currentTime\n    else\n            return anim.currentTime - part.startTime\n        end\n    end\n\n"})}),"\n",(0,a.jsx)(e.h3,{id:"getisanimationplaying",children:"getIsAnimationPlaying"}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)(e.strong,{children:"Description"})}),"\n",(0,a.jsxs)(e.blockquote,{children:["\n",(0,a.jsx)(e.p,{children:"Returns true if animation is playing"}),"\n"]}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)(e.strong,{children:"Definition"})}),"\n",(0,a.jsxs)(e.blockquote,{children:["\n",(0,a.jsx)(e.p,{children:"getIsAnimationPlaying(string name)"}),"\n"]}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)(e.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n",(0,a.jsx)(e.table,{children:(0,a.jsx)(e.thead,{children:(0,a.jsxs)(e.tr,{children:[(0,a.jsx)(e.th,{children:"string"}),(0,a.jsx)(e.th,{children:"name"}),(0,a.jsx)(e.th,{children:"name of animation"})]})})}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)(e.strong,{children:"Return Values"})}),"\n\n\n\n\n\n\n\n\n",(0,a.jsx)(e.table,{children:(0,a.jsx)(e.thead,{children:(0,a.jsxs)(e.tr,{children:[(0,a.jsx)(e.th,{children:"string"}),(0,a.jsx)(e.th,{children:"isPlaying"}),(0,a.jsx)(e.th,{children:"animation is playing"})]})})}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)(e.strong,{children:"Code"})}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-lua",children:"function AnimatedVehicle:getIsAnimationPlaying(name)\n    local spec = self.spec_animatedVehicle\n    local animation = spec.animations[name]\n    return table.hasElement(spec.activeAnimations, animation)\nend\n\n"})}),"\n",(0,a.jsx)(e.h3,{id:"getismovingpartactive",children:"getIsMovingPartActive"}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)(e.strong,{children:"Description"})}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)(e.strong,{children:"Definition"})}),"\n",(0,a.jsxs)(e.blockquote,{children:["\n",(0,a.jsx)(e.p,{children:"getIsMovingPartActive()"}),"\n"]}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)(e.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,a.jsxs)(e.table,{children:[(0,a.jsx)(e.thead,{children:(0,a.jsxs)(e.tr,{children:[(0,a.jsx)(e.th,{children:"any"}),(0,a.jsx)(e.th,{children:"superFunc"})]})}),(0,a.jsx)(e.tbody,{children:(0,a.jsxs)(e.tr,{children:[(0,a.jsx)(e.td,{children:"any"}),(0,a.jsx)(e.td,{children:"movingPart"})]})})]}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)(e.strong,{children:"Code"})}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-lua",children:"function AnimatedVehicle:getIsMovingPartActive(superFunc, movingPart)\n    if movingPart.requiredAnimation ~ = nil then\n        local animationTime = self:getAnimationTime(movingPart.requiredAnimation)\n        if animationTime < movingPart.requiredAnimationMin or animationTime > movingPart.requiredAnimationMax then\n            return false\n        end\n    end\n\n    return superFunc( self , movingPart)\nend\n\n"})}),"\n",(0,a.jsx)(e.h3,{id:"getismovingtoolactive",children:"getIsMovingToolActive"}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)(e.strong,{children:"Description"})}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)(e.strong,{children:"Definition"})}),"\n",(0,a.jsxs)(e.blockquote,{children:["\n",(0,a.jsx)(e.p,{children:"getIsMovingToolActive()"}),"\n"]}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)(e.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,a.jsxs)(e.table,{children:[(0,a.jsx)(e.thead,{children:(0,a.jsxs)(e.tr,{children:[(0,a.jsx)(e.th,{children:"any"}),(0,a.jsx)(e.th,{children:"superFunc"})]})}),(0,a.jsx)(e.tbody,{children:(0,a.jsxs)(e.tr,{children:[(0,a.jsx)(e.td,{children:"any"}),(0,a.jsx)(e.td,{children:"movingTool"})]})})]}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)(e.strong,{children:"Code"})}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-lua",children:"function AnimatedVehicle:getIsMovingToolActive(superFunc, movingTool)\n    if movingTool.requiredAnimation ~ = nil then\n        local animationTime = self:getAnimationTime(movingTool.requiredAnimation)\n        if animationTime < movingTool.requiredAnimationMin or animationTime > movingTool.requiredAnimationMax then\n            return false\n        end\n    end\n\n    return superFunc( self , movingTool)\nend\n\n"})}),"\n",(0,a.jsx)(e.h3,{id:"getisspeedrotatingpartactive",children:"getIsSpeedRotatingPartActive"}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)(e.strong,{children:"Description"})}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)(e.strong,{children:"Definition"})}),"\n",(0,a.jsxs)(e.blockquote,{children:["\n",(0,a.jsx)(e.p,{children:"getIsSpeedRotatingPartActive()"}),"\n"]}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)(e.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,a.jsxs)(e.table,{children:[(0,a.jsx)(e.thead,{children:(0,a.jsxs)(e.tr,{children:[(0,a.jsx)(e.th,{children:"any"}),(0,a.jsx)(e.th,{children:"superFunc"})]})}),(0,a.jsx)(e.tbody,{children:(0,a.jsxs)(e.tr,{children:[(0,a.jsx)(e.td,{children:"any"}),(0,a.jsx)(e.td,{children:"speedRotatingPart"})]})})]}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)(e.strong,{children:"Code"})}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-lua",children:"function AnimatedVehicle:getIsSpeedRotatingPartActive(superFunc, speedRotatingPart)\n    if speedRotatingPart.animName ~ = nil then\n        local animTime = self:getAnimationTime(speedRotatingPart.animName)\n        if speedRotatingPart.animOuterRange then\n            if animTime > speedRotatingPart.animMinLimit or animTime < speedRotatingPart.animMaxLimit then\n                return false\n            end\n        else\n                if animTime > speedRotatingPart.animMaxLimit or animTime < speedRotatingPart.animMinLimit then\n                    return false\n                end\n            end\n        end\n\n        return superFunc( self , speedRotatingPart)\n    end\n\n"})}),"\n",(0,a.jsx)(e.h3,{id:"getisworkareaactive",children:"getIsWorkAreaActive"}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)(e.strong,{children:"Description"})}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)(e.strong,{children:"Definition"})}),"\n",(0,a.jsxs)(e.blockquote,{children:["\n",(0,a.jsx)(e.p,{children:"getIsWorkAreaActive()"}),"\n"]}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)(e.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,a.jsxs)(e.table,{children:[(0,a.jsx)(e.thead,{children:(0,a.jsxs)(e.tr,{children:[(0,a.jsx)(e.th,{children:"any"}),(0,a.jsx)(e.th,{children:"superFunc"})]})}),(0,a.jsx)(e.tbody,{children:(0,a.jsxs)(e.tr,{children:[(0,a.jsx)(e.td,{children:"any"}),(0,a.jsx)(e.td,{children:"workArea"})]})})]}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)(e.strong,{children:"Code"})}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-lua",children:"function AnimatedVehicle:getIsWorkAreaActive(superFunc, workArea)\n    if workArea.animName ~ = nil then\n        local animTime = self:getAnimationTime(workArea.animName)\n        if animTime > workArea.animMaxLimit or animTime < workArea.animMinLimit then\n            return false\n        end\n    end\n\n    return superFunc( self , workArea)\nend\n\n"})}),"\n",(0,a.jsx)(e.h3,{id:"getmovedlimitedvalue",children:"getMovedLimitedValue"}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)(e.strong,{children:"Description"})}),"\n",(0,a.jsxs)(e.blockquote,{children:["\n",(0,a.jsx)(e.p,{children:"Returns moved limited value"}),"\n"]}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)(e.strong,{children:"Definition"})}),"\n",(0,a.jsxs)(e.blockquote,{children:["\n",(0,a.jsx)(e.p,{children:"getMovedLimitedValue(float currentValue, float destValue, float speed, float dt)"}),"\n"]}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)(e.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,a.jsxs)(e.table,{children:[(0,a.jsx)(e.thead,{children:(0,a.jsxs)(e.tr,{children:[(0,a.jsx)(e.th,{children:"float"}),(0,a.jsx)(e.th,{children:"currentValue"}),(0,a.jsx)(e.th,{children:"current value"})]})}),(0,a.jsxs)(e.tbody,{children:[(0,a.jsxs)(e.tr,{children:[(0,a.jsx)(e.td,{children:"float"}),(0,a.jsx)(e.td,{children:"destValue"}),(0,a.jsx)(e.td,{children:"dest value"})]}),(0,a.jsxs)(e.tr,{children:[(0,a.jsx)(e.td,{children:"float"}),(0,a.jsx)(e.td,{children:"speed"}),(0,a.jsx)(e.td,{children:"speed"})]}),(0,a.jsxs)(e.tr,{children:[(0,a.jsx)(e.td,{children:"float"}),(0,a.jsx)(e.td,{children:"dt"}),(0,a.jsx)(e.td,{children:"time since last call in ms"})]})]})]}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)(e.strong,{children:"Return Values"})}),"\n\n\n\n\n\n\n\n\n",(0,a.jsx)(e.table,{children:(0,a.jsx)(e.thead,{children:(0,a.jsxs)(e.tr,{children:[(0,a.jsx)(e.th,{children:"float"}),(0,a.jsx)(e.th,{children:"ret"}),(0,a.jsx)(e.th,{children:"limited value"})]})})}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)(e.strong,{children:"Code"})}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-lua",children:"function AnimatedVehicle.getMovedLimitedValue(currentValue, destValue, speed, dt)\n    if destValue = = currentValue then\n        return currentValue\n    end\n\n    -- we are moving towards -inf, we need to check for the maximum\n        local limitF = destValue < currentValue and math.max or math.min\n        return limitF(currentValue + speed * dt, destValue)\n    end\n\n"})}),"\n",(0,a.jsx)(e.h3,{id:"getnextpartisplaying",children:"getNextPartIsPlaying"}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)(e.strong,{children:"Description"})}),"\n",(0,a.jsxs)(e.blockquote,{children:["\n",(0,a.jsx)(e.p,{children:"Get next part is playing"}),"\n"]}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)(e.strong,{children:"Definition"})}),"\n",(0,a.jsxs)(e.blockquote,{children:["\n",(0,a.jsx)(e.p,{children:"getNextPartIsPlaying(table nextPart, table prevPart, table anim, boolean default)"}),"\n"]}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)(e.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,a.jsxs)(e.table,{children:[(0,a.jsx)(e.thead,{children:(0,a.jsxs)(e.tr,{children:[(0,a.jsx)(e.th,{children:"table"}),(0,a.jsx)(e.th,{children:"nextPart"}),(0,a.jsx)(e.th,{children:"next part"})]})}),(0,a.jsxs)(e.tbody,{children:[(0,a.jsxs)(e.tr,{children:[(0,a.jsx)(e.td,{children:"table"}),(0,a.jsx)(e.td,{children:"prevPart"}),(0,a.jsx)(e.td,{children:"previous part"})]}),(0,a.jsxs)(e.tr,{children:[(0,a.jsx)(e.td,{children:"table"}),(0,a.jsx)(e.td,{children:"anim"}),(0,a.jsx)(e.td,{children:"animation"})]}),(0,a.jsxs)(e.tr,{children:[(0,a.jsx)(e.td,{children:"boolean"}),(0,a.jsx)(e.td,{children:"default"}),(0,a.jsx)(e.td,{children:"default value"})]})]})]}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)(e.strong,{children:"Return Values"})}),"\n\n\n\n\n\n\n\n\n",(0,a.jsx)(e.table,{children:(0,a.jsx)(e.thead,{children:(0,a.jsxs)(e.tr,{children:[(0,a.jsx)(e.th,{children:"boolean"}),(0,a.jsx)(e.th,{children:"isPlaying"}),(0,a.jsx)(e.th,{children:"next part is playing"})]})})}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)(e.strong,{children:"Code"})}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-lua",children:"function AnimatedVehicle.getNextPartIsPlaying(nextPart, prevPart, anim, default)\n    if anim.currentSpeed > 0 then\n        if nextPart ~ = nil then\n            return nextPart.startTime > anim.currentTime\n        end\n    else\n            if prevPart ~ = nil then\n                return prevPart.startTime + prevPart.duration < anim.currentTime\n            end\n        end\n        return default\n    end\n\n"})}),"\n",(0,a.jsx)(e.h3,{id:"getnumofactiveanimations",children:"getNumOfActiveAnimations"}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)(e.strong,{children:"Description"})}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)(e.strong,{children:"Definition"})}),"\n",(0,a.jsxs)(e.blockquote,{children:["\n",(0,a.jsx)(e.p,{children:"getNumOfActiveAnimations()"}),"\n"]}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)(e.strong,{children:"Code"})}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-lua",children:"function AnimatedVehicle:getNumOfActiveAnimations()\n    return self.spec_animatedVehicle.numActiveAnimations\nend\n\n"})}),"\n",(0,a.jsx)(e.h3,{id:"getrealanimationtime",children:"getRealAnimationTime"}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)(e.strong,{children:"Description"})}),"\n",(0,a.jsxs)(e.blockquote,{children:["\n",(0,a.jsx)(e.p,{children:"Returns real animation time"}),"\n"]}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)(e.strong,{children:"Definition"})}),"\n",(0,a.jsxs)(e.blockquote,{children:["\n",(0,a.jsx)(e.p,{children:"getRealAnimationTime(string name)"}),"\n"]}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)(e.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n",(0,a.jsx)(e.table,{children:(0,a.jsx)(e.thead,{children:(0,a.jsxs)(e.tr,{children:[(0,a.jsx)(e.th,{children:"string"}),(0,a.jsx)(e.th,{children:"name"}),(0,a.jsx)(e.th,{children:"name of animation"})]})})}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)(e.strong,{children:"Return Values"})}),"\n\n\n\n\n\n\n\n\n",(0,a.jsx)(e.table,{children:(0,a.jsx)(e.thead,{children:(0,a.jsxs)(e.tr,{children:[(0,a.jsx)(e.th,{children:"string"}),(0,a.jsx)(e.th,{children:"animTime"}),(0,a.jsx)(e.th,{children:"real animation time in ms"})]})})}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)(e.strong,{children:"Code"})}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-lua",children:"function AnimatedVehicle:getRealAnimationTime(name)\n    local spec = self.spec_animatedVehicle\n\n    local animation = spec.animations[name]\n    if animation ~ = nil then\n        return animation.currentTime\n    end\n    return 0\nend\n\n"})}),"\n",(0,a.jsx)(e.h3,{id:"initializeanimationpart",children:"initializeAnimationPart"}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)(e.strong,{children:"Description"})}),"\n",(0,a.jsxs)(e.blockquote,{children:["\n",(0,a.jsx)(e.p,{children:"Initialize part of animation"}),"\n"]}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)(e.strong,{children:"Definition"})}),"\n",(0,a.jsxs)(e.blockquote,{children:["\n",(0,a.jsx)(e.p,{children:"initializeAnimationPart(table part, , , )"}),"\n"]}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)(e.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,a.jsxs)(e.table,{children:[(0,a.jsx)(e.thead,{children:(0,a.jsxs)(e.tr,{children:[(0,a.jsx)(e.th,{children:"table"}),(0,a.jsx)(e.th,{children:"part"}),(0,a.jsx)(e.th,{children:"part"})]})}),(0,a.jsxs)(e.tbody,{children:[(0,a.jsxs)(e.tr,{children:[(0,a.jsx)(e.td,{children:"any"}),(0,a.jsx)(e.td,{children:"part"}),(0,a.jsx)(e.td,{})]}),(0,a.jsxs)(e.tr,{children:[(0,a.jsx)(e.td,{children:"any"}),(0,a.jsx)(e.td,{children:"i"}),(0,a.jsx)(e.td,{})]}),(0,a.jsxs)(e.tr,{children:[(0,a.jsx)(e.td,{children:"any"}),(0,a.jsx)(e.td,{children:"numParts"}),(0,a.jsx)(e.td,{})]})]})]}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)(e.strong,{children:"Code"})}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-lua",children:"function AnimatedVehicle:initializeAnimationPart(animation, part, i, numParts)\n    for index = 1 , #part.animationValues do\n        part.animationValues[index]:init(i, numParts)\n    end\nend\n\n"})}),"\n",(0,a.jsx)(e.h3,{id:"initializeanimationpartattribute",children:"initializeAnimationPartAttribute"}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)(e.strong,{children:"Description"})}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)(e.strong,{children:"Definition"})}),"\n",(0,a.jsxs)(e.blockquote,{children:["\n",(0,a.jsx)(e.p,{children:"initializeAnimationPartAttribute()"}),"\n"]}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)(e.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,a.jsxs)(e.table,{children:[(0,a.jsx)(e.thead,{children:(0,a.jsxs)(e.tr,{children:[(0,a.jsx)(e.th,{children:"any"}),(0,a.jsx)(e.th,{children:"self"})]})}),(0,a.jsxs)(e.tbody,{children:[(0,a.jsxs)(e.tr,{children:[(0,a.jsx)(e.td,{children:"any"}),(0,a.jsx)(e.td,{children:"animation"})]}),(0,a.jsxs)(e.tr,{children:[(0,a.jsx)(e.td,{children:"any"}),(0,a.jsx)(e.td,{children:"part"})]}),(0,a.jsxs)(e.tr,{children:[(0,a.jsx)(e.td,{children:"any"}),(0,a.jsx)(e.td,{children:"i"})]}),(0,a.jsxs)(e.tr,{children:[(0,a.jsx)(e.td,{children:"any"}),(0,a.jsx)(e.td,{children:"numParts"})]}),(0,a.jsxs)(e.tr,{children:[(0,a.jsx)(e.td,{children:"any"}),(0,a.jsx)(e.td,{children:"nextName"})]}),(0,a.jsxs)(e.tr,{children:[(0,a.jsx)(e.td,{children:"any"}),(0,a.jsx)(e.td,{children:"prevName"})]}),(0,a.jsxs)(e.tr,{children:[(0,a.jsx)(e.td,{children:"any"}),(0,a.jsx)(e.td,{children:"startName"})]}),(0,a.jsxs)(e.tr,{children:[(0,a.jsx)(e.td,{children:"any"}),(0,a.jsx)(e.td,{children:"endName"})]}),(0,a.jsxs)(e.tr,{children:[(0,a.jsx)(e.td,{children:"any"}),(0,a.jsx)(e.td,{children:"warningName"})]}),(0,a.jsxs)(e.tr,{children:[(0,a.jsx)(e.td,{children:"any"}),(0,a.jsx)(e.td,{children:"startName2"})]}),(0,a.jsxs)(e.tr,{children:[(0,a.jsx)(e.td,{children:"any"}),(0,a.jsx)(e.td,{children:"endName2"})]}),(0,a.jsxs)(e.tr,{children:[(0,a.jsx)(e.td,{children:"any"}),(0,a.jsx)(e.td,{children:"additionalCompareParam"})]})]})]}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)(e.strong,{children:"Code"})}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-lua",children:"function AnimatedVehicle.initializeAnimationPartAttribute( self , animation, part, i, numParts, nextName, prevName, startName, endName, warningName, startName2, endName2, additionalCompareParam)\n    -- find next part, check for overlapping, enter dependencies and set default start value if not already set\n        if part[endName] ~ = nil then\n            for j = i + 1 , numParts do\n                local part2 = animation.parts[j]\n\n                local additionalCompare = true\n                if additionalCompareParam ~ = nil then\n                    if part[additionalCompareParam] ~ = part2[additionalCompareParam] then\n                        additionalCompare = false\n                    end\n                end\n\n                -- check if the animations use the same range, if not they cannot collide\n                    local sameRequiredRange = true\n                    if part.requiredAnimation ~ = nil then\n                        if part.requiredAnimation = = part2.requiredAnimation then\n                            for n, v in ipairs(part.requiredAnimationRange) do\n                                if part2.requiredAnimationRange[n] ~ = v then\n                                    sameRequiredRange = false\n                                end\n                            end\n                        end\n                    end\n\n                    local sameConfiguration = true\n                    if part.requiredConfigurationName ~ = nil then\n                        if part.requiredConfigurationName = = part2.requiredConfigurationName then\n                            if part.requiredConfigurationIndex ~ = part2.requiredConfigurationIndex then\n                                sameConfiguration = false\n                            end\n                        end\n                    end\n\n                    if part.direction = = part2.direction and part.node = = part2.node and part2[endName] ~ = nil and additionalCompare and sameRequiredRange and sameConfiguration then\n                        if part.direction = = part2.direction and part.startTime + part.duration > part2.startTime + 0.001 then\n                            Logging.xmlWarning( self.xmlFile, \"Overlapping %s parts for node '%s' in animation '%s'\" , warningName, getName(part.node), animation.name)\n                            end\n                            part[nextName] = part2\n                            part2[prevName] = part\n                            if part2[startName] = = nil then\n                                part2[startName] = { unpack(part[endName]) }\n                            end\n                            if startName2 ~ = nil and endName2 ~ = nil then\n                                if part2[startName2] = = nil then\n                                    part2[startName2] = { unpack(part[endName2]) }\n                                end\n                            end\n\n                            break\n                        end\n                    end\n                end\n            end\n\n"})}),"\n",(0,a.jsx)(e.h3,{id:"initializeanimationparts",children:"initializeAnimationParts"}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)(e.strong,{children:"Description"})}),"\n",(0,a.jsxs)(e.blockquote,{children:["\n",(0,a.jsx)(e.p,{children:"Initialize parts of animation"}),"\n"]}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)(e.strong,{children:"Definition"})}),"\n",(0,a.jsxs)(e.blockquote,{children:["\n",(0,a.jsx)(e.p,{children:"initializeAnimationParts(table animation)"}),"\n"]}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)(e.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n",(0,a.jsx)(e.table,{children:(0,a.jsx)(e.thead,{children:(0,a.jsxs)(e.tr,{children:[(0,a.jsx)(e.th,{children:"table"}),(0,a.jsx)(e.th,{children:"animation"}),(0,a.jsx)(e.th,{children:"animation"})]})})}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)(e.strong,{children:"Code"})}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-lua",children:"function AnimatedVehicle:initializeAnimationParts(animation)\n    local numParts = #animation.parts\n\n    for i, part in ipairs(animation.parts) do\n        self:initializeAnimationPart(animation, part, i, numParts)\n    end\n\n    for i, part in ipairs(animation.parts) do\n        self:postInitializeAnimationPart(animation, part, i, numParts)\n    end\nend\n\n"})}),"\n",(0,a.jsx)(e.h3,{id:"initspecialization",children:"initSpecialization"}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)(e.strong,{children:"Description"})}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)(e.strong,{children:"Definition"})}),"\n",(0,a.jsxs)(e.blockquote,{children:["\n",(0,a.jsx)(e.p,{children:"initSpecialization()"}),"\n"]}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)(e.strong,{children:"Code"})}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-lua",children:'function AnimatedVehicle.initSpecialization()\n    g_vehicleConfigurationManager:addConfigurationType( "animation" , g_i18n:getText( "shop_configuration" ), "animations" , VehicleConfigurationItem )\n\n    local schema = Vehicle.xmlSchema\n    schema:setXMLSpecializationType( "AnimatedVehicle" )\n\n    AnimatedVehicle.registerAnimationXMLPaths(schema, "vehicle.animations.animation(?)" )\n    AnimatedVehicle.registerAnimationXMLPaths(schema, "vehicle.animations.animationConfigurations.animationConfiguration(?).animation(?)" )\n\n    schema:register(XMLValueType.STRING, SpeedRotatingParts.SPEED_ROTATING_PART_XML_KEY .. "#animName" , "Animation name" )\n    schema:register(XMLValueType.BOOL, SpeedRotatingParts.SPEED_ROTATING_PART_XML_KEY .. "#animOuterRange" , "Anim limit outer range" , false )\n    schema:register(XMLValueType.FLOAT, SpeedRotatingParts.SPEED_ROTATING_PART_XML_KEY .. "#animMinLimit" , "Min.anim limit" , 0 )\n    schema:register(XMLValueType.FLOAT, SpeedRotatingParts.SPEED_ROTATING_PART_XML_KEY .. "#animMaxLimit" , "Max.anim limit" , 1 )\n\n    schema:register(XMLValueType.STRING, WorkArea.WORK_AREA_XML_KEY .. "#animName" , "Animation name" )\n    schema:register(XMLValueType.FLOAT, WorkArea.WORK_AREA_XML_KEY .. "#animMinLimit" , "Min.anim limit" , 0 )\n    schema:register(XMLValueType.FLOAT, WorkArea.WORK_AREA_XML_KEY .. "#animMaxLimit" , "Max.anim limit" , 1 )\n\n    schema:register(XMLValueType.STRING, WorkArea.WORK_AREA_XML_CONFIG_KEY .. "#animName" , "Animation name" )\n    schema:register(XMLValueType.FLOAT, WorkArea.WORK_AREA_XML_CONFIG_KEY .. "#animMinLimit" , "Min.anim limit" , 0 )\n    schema:register(XMLValueType.FLOAT, WorkArea.WORK_AREA_XML_CONFIG_KEY .. "#animMaxLimit" , "Max.anim limit" , 1 )\n\n    schema:addDelayedRegistrationFunc( "Cylindered:movingTool" , function (cSchema, cKey)\n        cSchema:register(XMLValueType.STRING, cKey .. "#requiredAnimation" , "Name of the animation that needs to be in a certain range" )\n        cSchema:register(XMLValueType.FLOAT, cKey .. "#requiredAnimationMinTime" , "Min.time of the animation that is allowed for the movingTool update [0-1]" , 0 )\n            cSchema:register(XMLValueType.FLOAT, cKey .. "#requiredAnimationMaxTime" , "Max.time of the animation that is allowed for the movingTool update [0-1]" , 1 )\n            end )\n\n            schema:addDelayedRegistrationFunc( "Cylindered:movingPart" , function (cSchema, cKey)\n                cSchema:register(XMLValueType.STRING, cKey .. "#requiredAnimation" , "Name of the animation that needs to be in a certain range" )\n                cSchema:register(XMLValueType.FLOAT, cKey .. "#requiredAnimationMinTime" , "Min.time of the animation that is allowed for the movingPart update [0-1]" , 0 )\n                    cSchema:register(XMLValueType.FLOAT, cKey .. "#requiredAnimationMaxTime" , "Max.time of the animation that is allowed for the movingPart update [0-1]" , 1 )\n                    end )\n\n                    schema:setXMLSpecializationType()\n                end\n\n'})}),"\n",(0,a.jsx)(e.h3,{id:"loadanimation",children:"loadAnimation"}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)(e.strong,{children:"Description"})}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)(e.strong,{children:"Definition"})}),"\n",(0,a.jsxs)(e.blockquote,{children:["\n",(0,a.jsx)(e.p,{children:"loadAnimation()"}),"\n"]}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)(e.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,a.jsxs)(e.table,{children:[(0,a.jsx)(e.thead,{children:(0,a.jsxs)(e.tr,{children:[(0,a.jsx)(e.th,{children:"any"}),(0,a.jsx)(e.th,{children:"xmlFile"})]})}),(0,a.jsxs)(e.tbody,{children:[(0,a.jsxs)(e.tr,{children:[(0,a.jsx)(e.td,{children:"any"}),(0,a.jsx)(e.td,{children:"key"})]}),(0,a.jsxs)(e.tr,{children:[(0,a.jsx)(e.td,{children:"any"}),(0,a.jsx)(e.td,{children:"animation"})]}),(0,a.jsxs)(e.tr,{children:[(0,a.jsx)(e.td,{children:"any"}),(0,a.jsx)(e.td,{children:"components"})]})]})]}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)(e.strong,{children:"Code"})}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-lua",children:'function AnimatedVehicle:loadAnimation(xmlFile, key, animation, components)\n\n    local name = xmlFile:getValue(key .. "#name" )\n    if name ~ = nil then\n        animation.name = name\n        animation.parts = { }\n        animation.currentTime = 0\n        animation.previousTime = 0\n        animation.currentSpeed = 1\n        animation.looping = xmlFile:getValue(key .. "#looping" , false )\n        animation.resetOnStart = xmlFile:getValue(key .. "#resetOnStart" , true )\n        animation.soundVolumeFactor = xmlFile:getValue(key .. "#soundVolumeFactor" , 1 )\n        animation.isKeyframe = xmlFile:getValue(key .. "#isKeyframe" , false )\n\n        if animation.isKeyframe then\n            animation.curvesByNode = { }\n        end\n\n        local partI = 0\n        while true do\n            local partKey = key .. string.format( ".part(%d)" , partI)\n            if not xmlFile:hasProperty(partKey) then\n                break\n            end\n\n            local animationPart = { }\n            if not animation.isKeyframe then\n                if self:loadAnimationPart(xmlFile, partKey, animationPart, animation, components) then\n                    table.insert(animation.parts, animationPart)\n                end\n            else\n                    self:loadStaticAnimationPart(xmlFile, partKey, animationPart, animation, components)\n                end\n\n                partI = partI + 1\n            end\n\n            -- sort parts by start/end time\n            animation.partsReverse = { }\n            for _, part in ipairs(animation.parts) do\n                table.insert(animation.partsReverse, part)\n            end\n            table.sort(animation.parts, AnimatedVehicle.animPartSorter)\n            table.sort(animation.partsReverse, AnimatedVehicle.animPartSorterReverse)\n\n            self:initializeAnimationParts(animation)\n\n            animation.currentPartIndex = 1\n            animation.duration = 0\n            for _, part in ipairs(animation.parts) do\n                animation.duration = math.max(animation.duration, part.startTime + part.duration)\n            end\n            if animation.isKeyframe then\n                for node, curve in pairs(animation.curvesByNode) do\n                    animation.duration = math.max(animation.duration, curve.maxTime)\n                end\n            end\n\n            animation.startTime = xmlFile:getValue(key .. "#startAnimTime" , 0 )\n            animation.currentTime = animation.startTime * animation.duration\n\n            if self.isClient then\n                animation.samples = { }\n\n                local i = 0\n                while true do\n                    local soundKey = string.format( "sound(%d)" , i)\n                    local baseKey = key .. "." .. soundKey\n                    if not xmlFile:hasProperty(baseKey) then\n                        break\n                    end\n\n                    local sample = g_soundManager:loadSampleFromXML(xmlFile, key, soundKey, self.baseDirectory, components or self.components, 0 , AudioGroup.VEHICLE, self.i3dMappings, self )\n                    if sample ~ = nil then\n                        sample.startTime = xmlFile:getValue(baseKey .. "#startTime" , 0 )\n                        sample.endTime = xmlFile:getValue(baseKey .. "#endTime" )\n                        sample.direction = xmlFile:getValue(baseKey .. "#direction" , 0 )\n\n                        sample.startPitchScale = xmlFile:getValue(baseKey .. "#startPitchScale" )\n                        sample.endPitchScale = xmlFile:getValue(baseKey .. "#endPitchScale" )\n\n                        if (sample.startPitchScale ~ = nil and sample.endPitchScale = = nil ) or(sample.startPitchScale = = nil and sample.endPitchScale ~ = nil ) then\n                            sample.startPitchScale = nil\n                            sample.endPitchScale = nil\n                            Logging.xmlWarning(xmlFile, "Animation sound requires both, startPitchScale and endPitchScale, not only one. (%s)" , baseKey)\n                        end\n\n                        -- if no end time and no loop count is defined we play the sound only once\n                        if sample.endTime = = nil and sample.loops = = 0 then\n                            sample.loops = 1\n                        end\n\n                        g_soundManager:setSampleVolumeScale(sample, g_soundManager:getSampleVolumeScale(sample) * animation.soundVolumeFactor)\n\n                        table.insert(animation.samples, sample)\n                    end\n\n                    i = i + 1\n                end\n\n                xmlFile:iterate(key .. ".stopTimePosSound" , function (index, _)\n                    local sample = g_soundManager:loadSampleFromXML(xmlFile, key, string.format( "stopTimePosSound(%d)" , index - 1 ), self.baseDirectory, components or self.components, 1 , AudioGroup.VEHICLE, self.i3dMappings, self )\n                    if sample ~ = nil then\n                        animation.eventSamples = animation.eventSamples or { }\n                        animation.eventSamples.stopTimePos = animation.eventSamples.stopTimePos or { }\n                        table.insert(animation.eventSamples.stopTimePos, sample)\n                    end\n                end )\n\n                xmlFile:iterate(key .. ".stopTimeNegSound" , function (index, _)\n                    local sample = g_soundManager:loadSampleFromXML(xmlFile, key, string.format( "stopTimeNegSound(%d)" , index - 1 ), self.baseDirectory, components or self.components, 1 , AudioGroup.VEHICLE, self.i3dMappings, self )\n                    if sample ~ = nil then\n                        animation.eventSamples = animation.eventSamples or { }\n                        animation.eventSamples.stopTimeNeg = animation.eventSamples.stopTimeNeg or { }\n                        table.insert(animation.eventSamples.stopTimeNeg, sample)\n                    end\n                end )\n            end\n\n            return true\n        end\n\n        return false\n    end\n\n'})}),"\n",(0,a.jsx)(e.h3,{id:"loadanimationpart",children:"loadAnimationPart"}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)(e.strong,{children:"Description"})}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)(e.strong,{children:"Definition"})}),"\n",(0,a.jsxs)(e.blockquote,{children:["\n",(0,a.jsx)(e.p,{children:"loadAnimationPart()"}),"\n"]}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)(e.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,a.jsxs)(e.table,{children:[(0,a.jsx)(e.thead,{children:(0,a.jsxs)(e.tr,{children:[(0,a.jsx)(e.th,{children:"any"}),(0,a.jsx)(e.th,{children:"xmlFile"})]})}),(0,a.jsxs)(e.tbody,{children:[(0,a.jsxs)(e.tr,{children:[(0,a.jsx)(e.td,{children:"any"}),(0,a.jsx)(e.td,{children:"partKey"})]}),(0,a.jsxs)(e.tr,{children:[(0,a.jsx)(e.td,{children:"any"}),(0,a.jsx)(e.td,{children:"part"})]}),(0,a.jsxs)(e.tr,{children:[(0,a.jsx)(e.td,{children:"any"}),(0,a.jsx)(e.td,{children:"animation"})]}),(0,a.jsxs)(e.tr,{children:[(0,a.jsx)(e.td,{children:"any"}),(0,a.jsx)(e.td,{children:"components"})]})]})]}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)(e.strong,{children:"Code"})}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-lua",children:'function AnimatedVehicle:loadAnimationPart(xmlFile, partKey, part, animation, components)\n    local startTime = xmlFile:getValue(partKey .. "#startTime" )\n    local duration = xmlFile:getValue(partKey .. "#duration" )\n    local endTime = xmlFile:getValue(partKey .. "#endTime" )\n    local direction = math.sign(xmlFile:getValue(partKey .. "#direction" , 0 ))\n\n    part.components = components or self.components\n    part.i3dMappings = self.i3dMappings\n\n    part.animationValues = { }\n\n    local spec = self.spec_animatedVehicle\n    for _, animationValueType in pairs(spec.animationValueTypes) do\n        local animationValueObject = animationValueType.classObject.new( self , animation, part, animationValueType.startName, animationValueType.endName, animationValueType.name, animationValueType.initialUpdate, animationValueType.get, animationValueType.set, animationValueType.load)\n        if animationValueObject:load(xmlFile, partKey) then\n            table.insert(part.animationValues, animationValueObject)\n        end\n    end\n\n    local requiredAnimation = xmlFile:getValue(partKey .. "#requiredAnimation" )\n    local requiredAnimationRange = xmlFile:getValue(partKey .. "#requiredAnimationRange" , nil , true )\n\n    local requiredConfigurationName = xmlFile:getValue(partKey .. "#requiredConfigurationName" )\n    local requiredConfigurationIndex = xmlFile:getValue(partKey .. "#requiredConfigurationIndex" )\n\n    for i = 1 , #part.animationValues do\n        part.animationValues[i].requiredAnimation = requiredAnimation\n        part.animationValues[i]:addCompareParameters( "requiredAnimation" )\n\n        if requiredAnimationRange ~ = nil then\n            part.animationValues[i].requiredAnimationRange = string.format( "%.2f %.2f" , requiredAnimationRange[ 1 ], requiredAnimationRange[ 2 ])\n            part.animationValues[i]:addCompareParameters( "requiredAnimationRange" )\n        end\n\n        part.animationValues[i].requiredConfigurationName = requiredConfigurationName\n        part.animationValues[i]:addCompareParameters( "requiredConfigurationName" )\n        part.animationValues[i].requiredConfigurationIndex = requiredConfigurationIndex\n        part.animationValues[i]:addCompareParameters( "requiredConfigurationIndex" )\n    end\n\n    if #part.animationValues = = 0 then\n        return false\n    end\n\n    if startTime ~ = nil and(duration ~ = nil or endTime ~ = nil ) then\n        if endTime ~ = nil then\n            duration = endTime - startTime\n        end\n        part.startTime = startTime * 1000\n        part.duration = duration * 1000\n        part.direction = direction\n        part.requiredAnimation = requiredAnimation\n        part.requiredAnimationRange = requiredAnimationRange\n\n        part.requiredConfigurationName = requiredConfigurationName\n        part.requiredConfigurationIndex = requiredConfigurationIndex\n\n        return true\n    end\n\n    return false\nend\n\n'})}),"\n",(0,a.jsx)(e.h3,{id:"loadmovingpartfromxml",children:"loadMovingPartFromXML"}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)(e.strong,{children:"Description"})}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)(e.strong,{children:"Definition"})}),"\n",(0,a.jsxs)(e.blockquote,{children:["\n",(0,a.jsx)(e.p,{children:"loadMovingPartFromXML()"}),"\n"]}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)(e.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,a.jsxs)(e.table,{children:[(0,a.jsx)(e.thead,{children:(0,a.jsxs)(e.tr,{children:[(0,a.jsx)(e.th,{children:"any"}),(0,a.jsx)(e.th,{children:"superFunc"})]})}),(0,a.jsxs)(e.tbody,{children:[(0,a.jsxs)(e.tr,{children:[(0,a.jsx)(e.td,{children:"any"}),(0,a.jsx)(e.td,{children:"xmlFile"})]}),(0,a.jsxs)(e.tr,{children:[(0,a.jsx)(e.td,{children:"any"}),(0,a.jsx)(e.td,{children:"key"})]}),(0,a.jsxs)(e.tr,{children:[(0,a.jsx)(e.td,{children:"any"}),(0,a.jsx)(e.td,{children:"entry"})]})]})]}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)(e.strong,{children:"Code"})}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-lua",children:'function AnimatedVehicle:loadMovingPartFromXML(superFunc, xmlFile, key, entry)\n    if not superFunc( self , xmlFile, key, entry) then\n        return false\n    end\n\n    entry.requiredAnimation = xmlFile:getValue(key .. "#requiredAnimation" )\n    if entry.requiredAnimation ~ = nil then\n        entry.requiredAnimationMin = xmlFile:getValue(key .. "#requiredAnimationMinTime" , 0 )\n        entry.requiredAnimationMax = xmlFile:getValue(key .. "#requiredAnimationMaxTime" , 1 )\n    end\n\n    return true\nend\n\n'})}),"\n",(0,a.jsx)(e.h3,{id:"loadmovingtoolfromxml",children:"loadMovingToolFromXML"}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)(e.strong,{children:"Description"})}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)(e.strong,{children:"Definition"})}),"\n",(0,a.jsxs)(e.blockquote,{children:["\n",(0,a.jsx)(e.p,{children:"loadMovingToolFromXML()"}),"\n"]}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)(e.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,a.jsxs)(e.table,{children:[(0,a.jsx)(e.thead,{children:(0,a.jsxs)(e.tr,{children:[(0,a.jsx)(e.th,{children:"any"}),(0,a.jsx)(e.th,{children:"superFunc"})]})}),(0,a.jsxs)(e.tbody,{children:[(0,a.jsxs)(e.tr,{children:[(0,a.jsx)(e.td,{children:"any"}),(0,a.jsx)(e.td,{children:"xmlFile"})]}),(0,a.jsxs)(e.tr,{children:[(0,a.jsx)(e.td,{children:"any"}),(0,a.jsx)(e.td,{children:"key"})]}),(0,a.jsxs)(e.tr,{children:[(0,a.jsx)(e.td,{children:"any"}),(0,a.jsx)(e.td,{children:"entry"})]})]})]}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)(e.strong,{children:"Code"})}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-lua",children:'function AnimatedVehicle:loadMovingToolFromXML(superFunc, xmlFile, key, entry)\n    if not superFunc( self , xmlFile, key, entry) then\n        return false\n    end\n\n    entry.requiredAnimation = xmlFile:getValue(key .. "#requiredAnimation" )\n    if entry.requiredAnimation ~ = nil then\n        entry.requiredAnimationMin = xmlFile:getValue(key .. "#requiredAnimationMinTime" , 0 )\n        entry.requiredAnimationMax = xmlFile:getValue(key .. "#requiredAnimationMaxTime" , 1 )\n    end\n\n    return true\nend\n\n'})}),"\n",(0,a.jsx)(e.h3,{id:"loadspeedrotatingpartfromxml",children:"loadSpeedRotatingPartFromXML"}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)(e.strong,{children:"Description"})}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)(e.strong,{children:"Definition"})}),"\n",(0,a.jsxs)(e.blockquote,{children:["\n",(0,a.jsx)(e.p,{children:"loadSpeedRotatingPartFromXML()"}),"\n"]}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)(e.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,a.jsxs)(e.table,{children:[(0,a.jsx)(e.thead,{children:(0,a.jsxs)(e.tr,{children:[(0,a.jsx)(e.th,{children:"any"}),(0,a.jsx)(e.th,{children:"superFunc"})]})}),(0,a.jsxs)(e.tbody,{children:[(0,a.jsxs)(e.tr,{children:[(0,a.jsx)(e.td,{children:"any"}),(0,a.jsx)(e.td,{children:"speedRotatingPart"})]}),(0,a.jsxs)(e.tr,{children:[(0,a.jsx)(e.td,{children:"any"}),(0,a.jsx)(e.td,{children:"xmlFile"})]}),(0,a.jsxs)(e.tr,{children:[(0,a.jsx)(e.td,{children:"any"}),(0,a.jsx)(e.td,{children:"key"})]})]})]}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)(e.strong,{children:"Code"})}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-lua",children:'function AnimatedVehicle:loadSpeedRotatingPartFromXML(superFunc, speedRotatingPart, xmlFile, key)\n    if not superFunc( self , speedRotatingPart, xmlFile, key) then\n        return false\n    end\n\n    speedRotatingPart.animName = xmlFile:getValue(key .. "#animName" )\n    speedRotatingPart.animOuterRange = xmlFile:getValue(key .. "#animOuterRange" , false )\n    speedRotatingPart.animMinLimit = xmlFile:getValue(key .. "#animMinLimit" , 0 )\n    speedRotatingPart.animMaxLimit = xmlFile:getValue(key .. "#animMaxLimit" , 1 )\n\n    return true\nend\n\n'})}),"\n",(0,a.jsx)(e.h3,{id:"loadstaticanimationpart",children:"loadStaticAnimationPart"}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)(e.strong,{children:"Description"})}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)(e.strong,{children:"Definition"})}),"\n",(0,a.jsxs)(e.blockquote,{children:["\n",(0,a.jsx)(e.p,{children:"loadStaticAnimationPart()"}),"\n"]}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)(e.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,a.jsxs)(e.table,{children:[(0,a.jsx)(e.thead,{children:(0,a.jsxs)(e.tr,{children:[(0,a.jsx)(e.th,{children:"any"}),(0,a.jsx)(e.th,{children:"xmlFile"})]})}),(0,a.jsxs)(e.tbody,{children:[(0,a.jsxs)(e.tr,{children:[(0,a.jsx)(e.td,{children:"any"}),(0,a.jsx)(e.td,{children:"partKey"})]}),(0,a.jsxs)(e.tr,{children:[(0,a.jsx)(e.td,{children:"any"}),(0,a.jsx)(e.td,{children:"part"})]}),(0,a.jsxs)(e.tr,{children:[(0,a.jsx)(e.td,{children:"any"}),(0,a.jsx)(e.td,{children:"animation"})]}),(0,a.jsxs)(e.tr,{children:[(0,a.jsx)(e.td,{children:"any"}),(0,a.jsx)(e.td,{children:"components"})]})]})]}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)(e.strong,{children:"Code"})}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-lua",children:'function AnimatedVehicle:loadStaticAnimationPart(xmlFile, partKey, part, animation, components)\n    local node = xmlFile:getValue(partKey .. "#node" , nil , self.components, self.i3dMappings)\n    if node ~ = nil then\n        local time = xmlFile:getValue(partKey .. "#time" )\n        local startTime = xmlFile:getValue(partKey .. "#startTime" )\n        local endTime = xmlFile:getValue(partKey .. "#endTime" )\n\n        if animation.curvesByNode[node] = = nil then\n            animation.curvesByNode[node] = AnimCurve.new(linearInterpolatorTransRotScale)\n        end\n\n        local curve = animation.curvesByNode[node]\n\n        if time ~ = nil then\n            self:loadStaticAnimationPartValues(xmlFile, partKey, curve, node, "translation" , "rotation" , "scale" , time * 1000 , animation)\n        elseif startTime ~ = nil or endTime ~ = nil then\n                if startTime ~ = nil then\n                    startTime = startTime * 1000\n                    if curve.maxTime = = 0 or curve.maxTime ~ = startTime then\n                        self:loadStaticAnimationPartValues(xmlFile, partKey, curve, node, "startTrans" , "startRot" , "startScale" , startTime, animation)\n                    end\n                end\n                if endTime ~ = nil then\n                endTime = endTime * 1000\n                if curve.maxTime = = 0 or curve.maxTime ~ = endTime then\n                    self:loadStaticAnimationPartValues(xmlFile, partKey, curve, node, "endTrans" , "endRot" , "endScale" , endTime, animation)\n                end\n            end\n        end\n\n        --#debug local spec = self.spec_animatedVehicle\n        --#debug for _, animationValueType in pairs(spec.animationValueTypes) do\n            --#debug if animationValueType.name ~ = "translation" and animationValueType.name ~ = "rotation" and animationValueType.name ~ = "scale" then\n                --#debug if animationValueType.startName ~ = "" and xmlFile:getString(partKey .. "#" .. animationValueType.startName) ~ = nil then\n                    --#debug Logging.xmlWarning(xmlFile, "Keyframe animations only support translation, rotation and scale values! \'%s\'", partKey .. "#" .. animationValueType.startName)\n                    --#debug end\n                    --#debug\n                    --#debug if animationValueType.endName ~ = "" and xmlFile:getString(partKey .. "#" .. animationValueType.endName) ~ = nil then\n                        --#debug Logging.xmlWarning(xmlFile, "Keyframe animations only support translation, rotation and scale values! \'%s\'", partKey .. "#" .. animationValueType.endName)\n                        --#debug end\n                        --#debug end\n                        --#debug end\n                        --#debug\n                        --#debug if xmlFile:getValue(partKey .. "#direction", nil) ~ = nil then\n                            --#debug Logging.xmlWarning(xmlFile, "Keyframe animations do not support the direction attribute! \'%s\'", partKey)\n                                --#debug end\n                                --#debug\n                                --#debug if xmlFile:getValue(partKey .. "#duration", nil) ~ = nil then\n                                    --#debug Logging.xmlWarning(xmlFile, "Keyframe animations do not support the duration attribute! \'%s\'", partKey)\n                                        --#debug end\n\n                                        return true\n                                    end\n\n                                    return false\n                                end\n\n'})}),"\n",(0,a.jsx)(e.h3,{id:"loadstaticanimationpartvalues",children:"loadStaticAnimationPartValues"}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)(e.strong,{children:"Description"})}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)(e.strong,{children:"Definition"})}),"\n",(0,a.jsxs)(e.blockquote,{children:["\n",(0,a.jsx)(e.p,{children:"loadStaticAnimationPartValues()"}),"\n"]}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)(e.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,a.jsxs)(e.table,{children:[(0,a.jsx)(e.thead,{children:(0,a.jsxs)(e.tr,{children:[(0,a.jsx)(e.th,{children:"any"}),(0,a.jsx)(e.th,{children:"xmlFile"})]})}),(0,a.jsxs)(e.tbody,{children:[(0,a.jsxs)(e.tr,{children:[(0,a.jsx)(e.td,{children:"any"}),(0,a.jsx)(e.td,{children:"partKey"})]}),(0,a.jsxs)(e.tr,{children:[(0,a.jsx)(e.td,{children:"any"}),(0,a.jsx)(e.td,{children:"curve"})]}),(0,a.jsxs)(e.tr,{children:[(0,a.jsx)(e.td,{children:"any"}),(0,a.jsx)(e.td,{children:"node"})]}),(0,a.jsxs)(e.tr,{children:[(0,a.jsx)(e.td,{children:"any"}),(0,a.jsx)(e.td,{children:"transName"})]}),(0,a.jsxs)(e.tr,{children:[(0,a.jsx)(e.td,{children:"any"}),(0,a.jsx)(e.td,{children:"rotName"})]}),(0,a.jsxs)(e.tr,{children:[(0,a.jsx)(e.td,{children:"any"}),(0,a.jsx)(e.td,{children:"scaleName"})]}),(0,a.jsxs)(e.tr,{children:[(0,a.jsx)(e.td,{children:"any"}),(0,a.jsx)(e.td,{children:"time"})]}),(0,a.jsxs)(e.tr,{children:[(0,a.jsx)(e.td,{children:"any"}),(0,a.jsx)(e.td,{children:"animation"})]})]})]}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)(e.strong,{children:"Code"})}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-lua",children:'function AnimatedVehicle:loadStaticAnimationPartValues(xmlFile, partKey, curve, node, transName, rotName, scaleName, time , animation)\n    local hasTranslation, hasRotation, hasScale = false , false , false\n\n    local x, y, z = xmlFile:getValue(partKey .. "#" .. transName)\n    if x = = nil then\n        x, y, z = getTranslation(node)\n    else\n            hasTranslation = true\n        end\n\n        local rx, ry, rz = xmlFile:getValue(partKey .. "#" .. rotName)\n        if rx = = nil then\n            rx, ry, rz = getRotation(node)\n        else\n                hasRotation = true\n            end\n\n            local sx, sy, sz = xmlFile:getValue(partKey .. "#" .. scaleName)\n            if sx = = nil then\n                sx, sy, sz = getScale(node)\n            else\n                    hasScale = true\n                end\n\n                if hasTranslation or hasRotation or hasScale then\n                    if curve.hasTranslation = = nil or curve.hasRotation = = nil or curve.hasScale = = nil then\n                        curve.hasTranslation = hasTranslation\n                        curve.hasRotation = hasRotation\n                        curve.hasScale = hasScale\n                    else\n                            if curve.hasTranslation ~ = hasTranslation\n                                or curve.hasRotation ~ = hasRotation\n                                or curve.hasScale ~ = hasScale then\n                                Logging.xmlWarning(xmlFile, "All animation parts for node \'%s\' require the same attributes(translation/rotation/scale) in animation \'%s\'! \'%s\'" , getName(node), animation.name, partKey)\n                                end\n                            end\n                        end\n\n                        curve:addKeyframe( { x = x, y = y, z = z, rx = rx, ry = ry, rz = rz, sx = sx, sy = sy, sz = sz, time = time } )\n                    end\n\n'})}),"\n",(0,a.jsx)(e.h3,{id:"loadworkareafromxml",children:"loadWorkAreaFromXML"}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)(e.strong,{children:"Description"})}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)(e.strong,{children:"Definition"})}),"\n",(0,a.jsxs)(e.blockquote,{children:["\n",(0,a.jsx)(e.p,{children:"loadWorkAreaFromXML()"}),"\n"]}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)(e.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,a.jsxs)(e.table,{children:[(0,a.jsx)(e.thead,{children:(0,a.jsxs)(e.tr,{children:[(0,a.jsx)(e.th,{children:"any"}),(0,a.jsx)(e.th,{children:"superFunc"})]})}),(0,a.jsxs)(e.tbody,{children:[(0,a.jsxs)(e.tr,{children:[(0,a.jsx)(e.td,{children:"any"}),(0,a.jsx)(e.td,{children:"workArea"})]}),(0,a.jsxs)(e.tr,{children:[(0,a.jsx)(e.td,{children:"any"}),(0,a.jsx)(e.td,{children:"xmlFile"})]}),(0,a.jsxs)(e.tr,{children:[(0,a.jsx)(e.td,{children:"any"}),(0,a.jsx)(e.td,{children:"key"})]})]})]}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)(e.strong,{children:"Code"})}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-lua",children:'function AnimatedVehicle:loadWorkAreaFromXML(superFunc, workArea, xmlFile, key)\n    workArea.animName = xmlFile:getValue(key .. "#animName" )\n    workArea.animMinLimit = xmlFile:getValue(key .. "#animMinLimit" , 0 )\n    workArea.animMaxLimit = xmlFile:getValue(key .. "#animMaxLimit" , 1 )\n\n    return superFunc( self , workArea, xmlFile, key)\nend\n\n'})}),"\n",(0,a.jsx)(e.h3,{id:"ondelete",children:"onDelete"}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)(e.strong,{children:"Description"})}),"\n",(0,a.jsxs)(e.blockquote,{children:["\n",(0,a.jsx)(e.p,{children:"Called on deleting"}),"\n"]}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)(e.strong,{children:"Definition"})}),"\n",(0,a.jsxs)(e.blockquote,{children:["\n",(0,a.jsx)(e.p,{children:"onDelete()"}),"\n"]}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)(e.strong,{children:"Code"})}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-lua",children:"function AnimatedVehicle:onDelete()\n    local spec = self.spec_animatedVehicle\n    if self.isClient and spec.animations ~ = nil then\n        for _, animation in pairs(spec.animations) do\n            g_soundManager:deleteSamples(animation.samples)\n            if animation.eventSamples ~ = nil then\n                g_soundManager:deleteSamples(animation.eventSamples.stopTimePos)\n                g_soundManager:deleteSamples(animation.eventSamples.stopTimeNeg)\n            end\n        end\n    end\nend\n\n"})}),"\n",(0,a.jsx)(e.h3,{id:"onload",children:"onLoad"}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)(e.strong,{children:"Description"})}),"\n",(0,a.jsxs)(e.blockquote,{children:["\n",(0,a.jsx)(e.p,{children:"Called on loading"}),"\n"]}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)(e.strong,{children:"Definition"})}),"\n",(0,a.jsxs)(e.blockquote,{children:["\n",(0,a.jsx)(e.p,{children:"onLoad(table savegame)"}),"\n"]}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)(e.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n",(0,a.jsx)(e.table,{children:(0,a.jsx)(e.thead,{children:(0,a.jsxs)(e.tr,{children:[(0,a.jsx)(e.th,{children:"table"}),(0,a.jsx)(e.th,{children:"savegame"}),(0,a.jsx)(e.th,{children:"savegame"})]})})}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)(e.strong,{children:"Code"})}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-lua",children:'function AnimatedVehicle:onLoad(savegame)\n    local spec = self.spec_animatedVehicle\n\n    spec.animations = { }\n\n    for _, key in self.xmlFile:iterator( "vehicle.animations.animation" ) do\n        local animation = { }\n        if self:loadAnimation( self.xmlFile, key, animation) then\n            spec.animations[animation.name] = animation\n        end\n    end\n\n    local configurationId = self.configurations[ "animation" ] or 1\n    local configKey = string.format( "vehicle.animations.animationConfigurations.animationConfiguration(%d)" , configurationId - 1 )\n\n    if self.xmlFile:hasProperty(configKey) then\n        for _, key in self.xmlFile:iterator(configKey .. ".animation" ) do\n            local animation = { }\n            if self:loadAnimation( self.xmlFile, key, animation) then\n                spec.animations[animation.name] = animation\n            end\n        end\n    end\n\n    spec.activeAnimations = { }\n    spec.numActiveAnimations = 0\n    spec.fixedTimeSamplesDirtyDelay = 0\nend\n\n'})}),"\n",(0,a.jsx)(e.h3,{id:"onpostload",children:"onPostLoad"}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)(e.strong,{children:"Description"})}),"\n",(0,a.jsxs)(e.blockquote,{children:["\n",(0,a.jsx)(e.p,{children:"Called after loading"}),"\n"]}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)(e.strong,{children:"Definition"})}),"\n",(0,a.jsxs)(e.blockquote,{children:["\n",(0,a.jsx)(e.p,{children:"onPostLoad(table savegame)"}),"\n"]}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)(e.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n",(0,a.jsx)(e.table,{children:(0,a.jsx)(e.thead,{children:(0,a.jsxs)(e.tr,{children:[(0,a.jsx)(e.th,{children:"table"}),(0,a.jsx)(e.th,{children:"savegame"}),(0,a.jsx)(e.th,{children:"savegame"})]})})}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)(e.strong,{children:"Code"})}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-lua",children:'function AnimatedVehicle:onPostLoad(savegame)\n    local spec = self.spec_animatedVehicle\n    for name, animation in pairs(spec.animations) do\n        if animation.resetOnStart then\n            self:setAnimationTime(name, 1 , true , false )\n            self:setAnimationStopTime(name, animation.startTime)\n            self:playAnimation(name, - 1 , 1 , true , false )\n            AnimatedVehicle.updateAnimationByName( self , name, 9999999 , true )\n        end\n    end\n\n    if next(spec.animations) = = nil then\n        SpecializationUtil.removeEventListener( self , "onUpdate" , AnimatedVehicle )\n    end\nend\n\n'})}),"\n",(0,a.jsx)(e.h3,{id:"onpreload",children:"onPreLoad"}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)(e.strong,{children:"Description"})}),"\n",(0,a.jsxs)(e.blockquote,{children:["\n",(0,a.jsx)(e.p,{children:"Called on pre loading"}),"\n"]}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)(e.strong,{children:"Definition"})}),"\n",(0,a.jsxs)(e.blockquote,{children:["\n",(0,a.jsx)(e.p,{children:"onPreLoad(table savegame)"}),"\n"]}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)(e.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n",(0,a.jsx)(e.table,{children:(0,a.jsx)(e.thead,{children:(0,a.jsxs)(e.tr,{children:[(0,a.jsx)(e.th,{children:"table"}),(0,a.jsx)(e.th,{children:"savegame"}),(0,a.jsx)(e.th,{children:"savegame"})]})})}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)(e.strong,{children:"Code"})}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-lua",children:'function AnimatedVehicle:onPreLoad(savegame)\n    local spec = self.spec_animatedVehicle\n    spec.animationValueTypes = { }\n\n    SpecializationUtil.raiseEvent( self , "onRegisterAnimationValueTypes" )\nend\n\n'})}),"\n",(0,a.jsx)(e.h3,{id:"onregisteranimationvaluetypes",children:"onRegisterAnimationValueTypes"}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)(e.strong,{children:"Description"})}),"\n",(0,a.jsxs)(e.blockquote,{children:["\n",(0,a.jsx)(e.p,{children:"Called on pre load to register animation value types"}),"\n"]}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)(e.strong,{children:"Definition"})}),"\n",(0,a.jsxs)(e.blockquote,{children:["\n",(0,a.jsx)(e.p,{children:"onRegisterAnimationValueTypes()"}),"\n"]}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)(e.strong,{children:"Code"})}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-lua",children:'function AnimatedVehicle:onRegisterAnimationValueTypes()\n    local loadNodeFunction = function (value, xmlFile, xmlKey)\n        value.node = xmlFile:getValue(xmlKey .. "#node" , nil , value.part.components, value.part.i3dMappings)\n\n        if value.node ~ = nil then\n            value:setWarningInformation( "node: " .. getName(value.node))\n            value:addCompareParameters( "node" )\n\n            return true\n        end\n\n        return false\n    end\n\n    self:registerAnimationValueType( "rotation" , "startRot" , "endRot" , false , AnimationValueFloat , loadNodeFunction,\n    function (value)\n        return getRotation(value.node)\n    end ,\n\n    function (value, .. .)\n        setRotation(value.node, .. .)\n\n        SpecializationUtil.raiseEvent( self , "onAnimationPartChanged" , value.node)\n    end )\n\n    self:registerAnimationValueType( "translation" , "startTrans" , "endTrans" , false , AnimationValueFloat , loadNodeFunction,\n    function (value)\n        return getTranslation(value.node)\n    end ,\n\n    function (value, .. .)\n        setTranslation(value.node, .. .)\n\n        SpecializationUtil.raiseEvent( self , "onAnimationPartChanged" , value.node)\n    end )\n\n    self:registerAnimationValueType( "scale" , "startScale" , "endScale" , false , AnimationValueFloat , loadNodeFunction,\n    function (value)\n        return getScale(value.node)\n    end ,\n\n    function (value, .. .)\n        setScale(value.node, .. .)\n\n        SpecializationUtil.raiseEvent( self , "onAnimationPartChanged" , value.node)\n    end )\n\n    local updateShaderParameterMask = function (xmlFile, xmlKey, mask)\n        local customMask = false\n        local rawValues = xmlFile:getValue(xmlKey)\n        if rawValues ~ = nil then\n            for i = 1 , #rawValues do\n                if rawValues[i] = = "-" then\n                    mask[i] = 0\n                    customMask = true\n                end\n            end\n        end\n\n        return customMask\n    end\n\n    self:registerAnimationValueType( "shaderParameter" , "shaderStartValues" , "shaderEndValues" , false , AnimationValueFloat ,\n    function (value, xmlFile, xmlKey)\n        value.node = xmlFile:getValue(xmlKey .. "#node" , nil , value.part.components, value.part.i3dMappings)\n        value.shaderParameter = xmlFile:getValue(xmlKey .. "#shaderParameter" )\n        value.shaderParameterPrev = xmlFile:getValue(xmlKey .. "#shaderParameterPrev" )\n\n        if value.node ~ = nil and value.shaderParameter ~ = nil then\n            if getHasClassId(value.node, ClassIds.SHAPE) and getHasShaderParameter(value.node, value.shaderParameter) then\n                value:setWarningInformation( "node: " .. getName(value.node) .. "with shaderParam: " .. value.shaderParameter)\n                value:addCompareParameters( "node" , "shaderParameter" )\n\n                value.shaderParameterMask = { 1 , 1 , 1 , 1 }\n                value.customShaderParameterMask = updateShaderParameterMask(xmlFile, xmlKey .. "#shaderStartValues" , value.shaderParameterMask)\n                value.customShaderParameterMask = updateShaderParameterMask(xmlFile, xmlKey .. "#shaderEndValues" , value.shaderParameterMask) or value.customShaderParameterMask\n\n                if value.shaderParameterPrev ~ = nil then\n                    if not getHasShaderParameter(value.node, value.shaderParameterPrev) then\n                        Logging.xmlWarning(xmlFile, "Node \'%s\' has no shaderParameterPrev \'%s\' for animation part \'%s\'!" , getName(value.node), value.shaderParameterPrev, xmlKey)\n                            return false\n                        end\n                    else\n                            local prevName = "prev" .. string.upper( string.sub(value.shaderParameter, 1 , 1 )) .. string.sub(value.shaderParameter, 2 ) -- uppercase first letter of parameter name\n                            if getHasShaderParameter(value.node, prevName) then\n                                value.shaderParameterPrev = prevName\n                            end\n                        end\n\n                        return true\n                    else\n                            Logging.xmlWarning(xmlFile, "Node \'%s\' has no shaderParameter \'%s\' for animation part \'%s\'!" , getName(value.node), value.shaderParameter, xmlKey)\n                            end\n                        end\n\n                        return false\n                    end ,\n\n                    function (value)\n                        return getShaderParameter(value.node, value.shaderParameter)\n                    end ,\n\n                    function (value, x, y, z, w)\n                        if value.customShaderParameterMask then\n                            if value.shaderParameterMask[ 1 ] = = 0 then x = nil end\n                            if value.shaderParameterMask[ 2 ] = = 0 then y = nil end\n                            if value.shaderParameterMask[ 3 ] = = 0 then z = nil end\n                            if value.shaderParameterMask[ 4 ] = = 0 then w = nil end\n                        end\n\n                        if value.shaderParameterPrev ~ = nil then\n                            g_animationManager:setPrevShaderParameter(value.node, value.shaderParameter, x, y, z, w, false , value.shaderParameterPrev)\n                        else\n                                setShaderParameter(value.node, value.shaderParameter, x, y, z, w, false )\n                            end\n                        end )\n\n                        self:registerAnimationValueType( "visibility" , "visibility" , "" , false , AnimationValueBool , loadNodeFunction,\n                        function (value)\n                            return getVisibility(value.node)\n                        end ,\n\n                        function (value, .. .)\n                            setVisibility(value.node, .. .)\n                        end )\n\n                        self:registerAnimationValueType( "visibilityInter" , "startVisibility" , "endVisibility" , false , AnimationValueFloat ,\n                        function (value, xmlFile, xmlKey)\n                            value.node = xmlFile:getValue(xmlKey .. "#node" , nil , value.part.components, value.part.i3dMappings)\n                            if value.node ~ = nil and value.startValue ~ = nil and value.endValue ~ = nil then\n                                value:setWarningInformation( "node: " .. getName(value.node))\n                                value:addCompareParameters( "node" )\n\n                                return true\n                            end\n\n                            return false\n                        end ,\n                        function (value)\n                            if value.lastVisibilityValue ~ = nil then\n                                return value.lastVisibilityValue\n                            end\n\n                            return getVisibility(value.node) and 1 or 0\n                        end ,\n\n                        function (value, visibility)\n                            value.lastVisibilityValue = visibility\n                            setVisibility(value.node, visibility > = 0.5 )\n                        end )\n\n                        self:registerAnimationValueType( "animationClip" , "clipStartTime" , "clipEndTime" , true , AnimationValueFloat ,\n                        function (value, xmlFile, xmlKey)\n                            value.node = xmlFile:getValue(xmlKey .. "#node" , nil , value.part.components, value.part.i3dMappings)\n                            value.animationClip = xmlFile:getValue(xmlKey .. "#animationClip" )\n\n                            if value.node ~ = nil and value.animationClip ~ = nil then\n                                value.animationCharSet = getAnimCharacterSet(value.node)\n                                if value.animationCharSet ~ = 0 then\n                                    value.animationClipIndex = getAnimClipIndex(value.animationCharSet, value.animationClip)\n\n                                    value:setWarningInformation( "node: " .. getName(value.node) .. "with animationClip: " .. value.animationClip)\n                                    value:addCompareParameters( "node" , "animationClip" )\n\n                                    return true\n                                else\n                                        Logging.xmlWarning(xmlFile, "Unable to find animation clip \'%s\' on node \'%s\' in \'%s\'" , value.animationClip, getName(value.node), xmlKey)\n                                    end\n                                end\n\n                                return false\n                            end ,\n\n                            function (value)\n                                local oldClipIndex = getAnimTrackAssignedClip(value.animationCharSet, 0 )\n                                clearAnimTrackClip(value.animationCharSet, 0 )\n                                assignAnimTrackClip(value.animationCharSet, 0 , value.animationClipIndex)\n\n                                if oldClipIndex = = value.animationClipIndex then\n                                    return getAnimTrackTime(value.animationCharSet, 0 )\n                                end\n\n                                local startTime = value.startValue or value.endValue\n                                if value.animation.currentSpeed < 0 then\n                                    startTime = value.endValue or value.startValue\n                                end\n\n                                return startTime[ 1 ]\n                            end ,\n\n                            function (value, time )\n                                local oldClipIndex = getAnimTrackAssignedClip(value.animationCharSet, 0 )\n                                if oldClipIndex ~ = value.animationClipIndex then\n                                    clearAnimTrackClip(value.animationCharSet, 0 )\n                                    assignAnimTrackClip(value.animationCharSet, 0 , value.animationClipIndex)\n                                end\n\n                                enableAnimTrack(value.animationCharSet, 0 )\n                                setAnimTrackTime(value.animationCharSet, 0 , time , true )\n                                disableAnimTrack(value.animationCharSet, 0 )\n                            end )\n\n                            self:registerAnimationValueType( "dependentAnimation" , "dependentAnimationStartTime" , "dependentAnimationEndTime" , true , AnimationValueFloat ,\n                            function (value, xmlFile, xmlKey)\n                                value.dependentAnimation = xmlFile:getValue(xmlKey .. "#dependentAnimation" )\n\n                                if value.dependentAnimation ~ = nil then\n                                    value:setWarningInformation( "dependentAnimation: " .. value.dependentAnimation)\n                                    value:addCompareParameters( "dependentAnimation" )\n\n                                    return true\n                                end\n\n                                return false\n                            end ,\n\n                            function (value)\n                                return value.vehicle:getAnimationTime(value.dependentAnimation)\n                            end ,\n\n                            function (value, time )\n                                value.vehicle:setAnimationTime(value.dependentAnimation, time , true )\n                            end )\n\n                            if self.isServer then\n                                self:registerAnimationValueType( "rotLimit" , "" , "" , false , AnimationValueFloat ,\n                                function (value, xmlFile, xmlKey)\n                                    value.startRotLimit = xmlFile:getValue(xmlKey .. "#startRotLimit" , nil , true )\n                                    value.startRotMinLimit = xmlFile:getValue(xmlKey .. "#startRotMinLimit" , nil , true )\n                                    value.startRotMaxLimit = xmlFile:getValue(xmlKey .. "#startRotMaxLimit" , nil , true )\n\n                                    if value.startRotLimit ~ = nil then\n                                        if value.startRotMinLimit ~ = nil then\n                                            Logging.xmlWarning(xmlFile, "Invalid rotLimit definition. \'startRotMinLimit\' defined but overwritten by defined \'startRotLimit\'! (%s)" , xmlKey)\n                                        end\n                                        if value.startRotMaxLimit ~ = nil then\n                                            Logging.xmlWarning(xmlFile, "Invalid rotLimit definition. \'startRotMaxLimit\' defined but overwritten by defined \'startRotLimit\'! (%s)" , xmlKey)\n                                        end\n\n                                        value.startRotMinLimit = { - value.startRotLimit[ 1 ], - value.startRotLimit[ 2 ], - value.startRotLimit[ 3 ] }\n                                        value.startRotMaxLimit = { value.startRotLimit[ 1 ], value.startRotLimit[ 2 ], value.startRotLimit[ 3 ] }\n                                    end\n\n                                    value.endRotLimit = xmlFile:getValue(xmlKey .. "#endRotLimit" , nil , true )\n                                    value.endRotMinLimit = xmlFile:getValue(xmlKey .. "#endRotMinLimit" , nil , true )\n                                    value.endRotMaxLimit = xmlFile:getValue(xmlKey .. "#endRotMaxLimit" , nil , true )\n\n                                    if value.endRotLimit ~ = nil then\n                                        if value.endRotMinLimit ~ = nil then\n                                            Logging.xmlWarning(xmlFile, "Invalid rotLimit definition. \'endRotMinLimit\' defined but overwritten by defined \'endRotLimit\'! (%s)" , xmlKey)\n                                        end\n                                        if value.endRotMaxLimit ~ = nil then\n                                            Logging.xmlWarning(xmlFile, "Invalid rotLimit definition. \'endRotMaxLimit\' defined but overwritten by defined \'endRotLimit\'! (%s)" , xmlKey)\n                                        end\n\n                                        value.endRotMinLimit = { - value.endRotLimit[ 1 ], - value.endRotLimit[ 2 ], - value.endRotLimit[ 3 ] }\n                                        value.endRotMaxLimit = { value.endRotLimit[ 1 ], value.endRotLimit[ 2 ], value.endRotLimit[ 3 ] }\n                                    end\n\n                                    local componentJointIndex = xmlFile:getValue(xmlKey .. "#componentJointIndex" )\n                                    if componentJointIndex ~ = nil then\n                                        if componentJointIndex > = 1 then\n                                            value.componentJoint = value.vehicle.componentJoints[componentJointIndex]\n                                        end\n\n                                        if value.componentJoint = = nil then\n                                            Logging.xmlWarning(xmlFile, "Invalid componentJointIndex for animation part \'%s\'.Indexing starts with 1!" , xmlKey)\n                                                return false\n                                            end\n                                        end\n\n                                        if (value.endRotMinLimit ~ = nil and value.endRotMaxLimit = = nil ) or(value.endRotMinLimit = = nil and value.endRotMaxLimit ~ = nil ) then\n                                            Logging.xmlWarning(xmlFile, "Incomplete end trans limit for animation part \'%s\'." , xmlKey)\n                                            return false\n                                        end\n\n                                        if value.componentJoint ~ = nil and value.endRotMinLimit ~ = nil and value.endRotMaxLimit ~ = nil then\n                                            if value.startRotMinLimit ~ = nil and value.startRotMaxLimit ~ = nil then\n                                                value.startValue = { value.startRotMinLimit[ 1 ], value.startRotMinLimit[ 2 ], value.startRotMinLimit[ 3 ], value.startRotMaxLimit[ 1 ], value.startRotMaxLimit[ 2 ], value.startRotMaxLimit[ 3 ] }\n                                            end\n                                            if value.endRotMinLimit ~ = nil and value.endRotMaxLimit ~ = nil then\n                                                value.endValue = { value.endRotMinLimit[ 1 ], value.endRotMinLimit[ 2 ], value.endRotMinLimit[ 3 ], value.endRotMaxLimit[ 1 ], value.endRotMaxLimit[ 2 ], value.endRotMaxLimit[ 3 ] }\n                                            end\n\n                                            if value.endValue = = nil then\n                                                Logging.xmlWarning(xmlFile, "Missing end rot limit for animation part \'%s\'." , xmlKey)\n                                                return false\n                                            end\n\n                                            value.endName = "rotLimit" -- only for comparing parts\n                                                value:setWarningInformation( "componentJointIndex: " .. componentJointIndex)\n                                                value:addCompareParameters( "componentJoint" )\n\n                                                return true\n                                            end\n\n                                            return false\n                                        end ,\n\n                                        function (value)\n                                            return value.componentJoint.rotMinLimit[ 1 ], value.componentJoint.rotMinLimit[ 2 ], value.componentJoint.rotMinLimit[ 3 ], value.componentJoint.rotLimit[ 1 ], value.componentJoint.rotLimit[ 2 ], value.componentJoint.rotLimit[ 3 ]\n                                        end ,\n\n                                        function (value, minX, minY, minZ, maxX, maxY, maxZ)\n                                            value.vehicle:setComponentJointRotLimit(value.componentJoint, 1 , minX, maxX)\n                                            value.vehicle:setComponentJointRotLimit(value.componentJoint, 2 , minY, maxY)\n                                            value.vehicle:setComponentJointRotLimit(value.componentJoint, 3 , minZ, maxZ)\n                                        end )\n\n                                        self:registerAnimationValueType( "transLimit" , "" , "" , false , AnimationValueFloat ,\n                                        function (value, xmlFile, xmlKey)\n                                            value.startTransLimit = xmlFile:getValue(xmlKey .. "#startTransLimit" , nil , true )\n                                            value.startTransMinLimit = xmlFile:getValue(xmlKey .. "#startTransMinLimit" , nil , true )\n                                            value.startTransMaxLimit = xmlFile:getValue(xmlKey .. "#startTransMaxLimit" , nil , true )\n\n                                            if value.startTransLimit ~ = nil then\n                                                if value.startTransMinLimit ~ = nil then\n                                                    Logging.xmlWarning(xmlFile, "Invalid transLimit definition. \'startTransMinLimit\' defined but overwritten by defined \'startTransLimit\'! (%s)" , xmlKey)\n                                                end\n                                                if value.startTransMaxLimit ~ = nil then\n                                                    Logging.xmlWarning(xmlFile, "Invalid transLimit definition. \'startTransMaxLimit\' defined but overwritten by defined \'startTransLimit\'! (%s)" , xmlKey)\n                                                end\n\n                                                value.startTransMinLimit = { - value.startTransLimit[ 1 ], - value.startTransLimit[ 2 ], - value.startTransLimit[ 3 ] }\n                                                value.startTransMaxLimit = { value.startTransLimit[ 1 ], value.startTransLimit[ 2 ], value.startTransLimit[ 3 ] }\n                                            end\n\n                                            value.endTransLimit = xmlFile:getValue(xmlKey .. "#endTransLimit" , nil , true )\n                                            value.endTransMinLimit = xmlFile:getValue(xmlKey .. "#endTransMinLimit" , nil , true )\n                                            value.endTransMaxLimit = xmlFile:getValue(xmlKey .. "#endTransMaxLimit" , nil , true )\n\n                                            if value.endTransLimit ~ = nil then\n                                                if value.endTransMinLimit ~ = nil then\n                                                    Logging.xmlWarning(xmlFile, "Invalid transLimit definition. \'endTransMinLimit\' defined but overwritten by defined \'endTransLimit\'! (%s)" , xmlKey)\n                                                end\n                                                if value.endTransMaxLimit ~ = nil then\n                                                    Logging.xmlWarning(xmlFile, "Invalid transLimit definition. \'endTransMaxLimit\' defined but overwritten by defined \'endTransLimit\'! (%s)" , xmlKey)\n                                                end\n\n                                                value.endTransMinLimit = { - value.endTransLimit[ 1 ], - value.endTransLimit[ 2 ], - value.endTransLimit[ 3 ] }\n                                                value.endTransMaxLimit = { value.endTransLimit[ 1 ], value.endTransLimit[ 2 ], value.endTransLimit[ 3 ] }\n                                            end\n\n                                            local componentJointIndex = xmlFile:getValue(xmlKey .. "#componentJointIndex" )\n                                            if componentJointIndex ~ = nil then\n                                                if componentJointIndex > = 1 then\n                                                    value.componentJoint = value.vehicle.componentJoints[componentJointIndex]\n                                                end\n\n                                                if value.componentJoint = = nil then\n                                                    Logging.xmlWarning(xmlFile, "Invalid componentJointIndex for animation part \'%s\'.Indexing starts with 1!" , xmlKey)\n                                                        return false\n                                                    end\n                                                end\n\n                                                if (value.endTransMinLimit ~ = nil and value.endTransMaxLimit = = nil ) or(value.endTransMinLimit = = nil and value.endTransMaxLimit ~ = nil ) then\n                                                    Logging.xmlWarning(xmlFile, "Incomplete end trans limit for animation part \'%s\'." , xmlKey)\n                                                    return false\n                                                end\n\n                                                if value.componentJoint ~ = nil and value.endTransMinLimit ~ = nil and value.endTransMaxLimit ~ = nil then\n                                                    if value.startTransMinLimit ~ = nil and value.startTransMaxLimit ~ = nil then\n                                                        value.startValue = { value.startTransMinLimit[ 1 ], value.startTransMinLimit[ 2 ], value.startTransMinLimit[ 3 ], value.startTransMaxLimit[ 1 ], value.startTransMaxLimit[ 2 ], value.startTransMaxLimit[ 3 ] }\n                                                    end\n                                                    if value.endTransMinLimit ~ = nil and value.endTransMaxLimit ~ = nil then\n                                                        value.endValue = { value.endTransMinLimit[ 1 ], value.endTransMinLimit[ 2 ], value.endTransMinLimit[ 3 ], value.endTransMaxLimit[ 1 ], value.endTransMaxLimit[ 2 ], value.endTransMaxLimit[ 3 ] }\n                                                    end\n\n                                                    if value.endValue = = nil then\n                                                        Logging.xmlWarning(xmlFile, "Missing end trans limit for animation part \'%s\'." , xmlKey)\n                                                        return false\n                                                    end\n\n                                                    value.endName = "transLimit" -- only for comparing parts\n                                                        value:setWarningInformation( "componentJointIndex: " .. componentJointIndex)\n                                                        value:addCompareParameters( "componentJoint" )\n\n                                                        return true\n                                                    end\n\n                                                    return false\n                                                end ,\n\n                                                function (value)\n                                                    return value.componentJoint.transMinLimit[ 1 ], value.componentJoint.transMinLimit[ 2 ], value.componentJoint.transMinLimit[ 3 ], value.componentJoint.transLimit[ 1 ], value.componentJoint.transLimit[ 2 ], value.componentJoint.transLimit[ 3 ]\n                                                end ,\n\n                                                function (value, minX, minY, minZ, maxX, maxY, maxZ)\n                                                    value.vehicle:setComponentJointTransLimit(value.componentJoint, 1 , minX, maxX)\n                                                    value.vehicle:setComponentJointTransLimit(value.componentJoint, 2 , minY, maxY)\n                                                    value.vehicle:setComponentJointTransLimit(value.componentJoint, 3 , minZ, maxZ)\n                                                end )\n\n                                                self:registerAnimationValueType( "rotationLimitSpring" , "" , "" , false , AnimationValueFloat ,\n                                                function (value, xmlFile, xmlKey)\n                                                    value.startRotLimitSpring = xmlFile:getValue(xmlKey .. "#startRotLimitSpring" , nil , true )\n                                                    value.startRotLimitDamping = xmlFile:getValue(xmlKey .. "#startRotLimitDamping" , nil , true )\n\n                                                    value.endRotLimitSpring = xmlFile:getValue(xmlKey .. "#endRotLimitSpring" , nil , true )\n                                                    value.endRotLimitDamping = xmlFile:getValue(xmlKey .. "#endRotLimitDamping" , nil , true )\n\n                                                    local componentJointIndex = xmlFile:getValue(xmlKey .. "#componentJointIndex" )\n                                                    if componentJointIndex ~ = nil then\n                                                        if componentJointIndex > = 1 then\n                                                            value.componentJoint = value.vehicle.componentJoints[componentJointIndex]\n                                                        end\n\n                                                        if value.componentJoint = = nil then\n                                                            Logging.xmlWarning(xmlFile, "Invalid componentJointIndex for animation part \'%s\'.Indexing starts with 1!" , xmlKey)\n                                                                return false\n                                                            end\n                                                        end\n\n                                                        if value.componentJoint ~ = nil and(value.endRotLimitSpring ~ = nil or value.startRotLimitDamping ~ = nil ) then\n                                                            if value.startRotLimitSpring ~ = nil and value.startRotLimitDamping ~ = nil then\n                                                                value.startValue = { value.startRotLimitSpring[ 1 ], value.startRotLimitSpring[ 2 ], value.startRotLimitSpring[ 3 ], value.startRotLimitDamping[ 1 ], value.startRotLimitDamping[ 2 ], value.startRotLimitDamping[ 3 ] }\n                                                            end\n                                                            if value.endRotLimitSpring ~ = nil and value.endRotLimitDamping ~ = nil then\n                                                                value.endValue = { value.endRotLimitSpring[ 1 ], value.endRotLimitSpring[ 2 ], value.endRotLimitSpring[ 3 ], value.endRotLimitDamping[ 1 ], value.endRotLimitDamping[ 2 ], value.endRotLimitDamping[ 3 ] }\n                                                            end\n\n                                                            if value.endValue = = nil then\n                                                                Logging.xmlWarning(xmlFile, "Missing \'endRotLimitSpring\' or \'endRotLimitDamping\' for animation part \'%s\'." , xmlKey)\n                                                                    return false\n                                                                end\n\n                                                                value.endName = "rotationLimitSpring" -- only for comparing parts\n                                                                    value:setWarningInformation( "componentJointIndex: " .. componentJointIndex)\n                                                                    value:addCompareParameters( "componentJoint" )\n\n                                                                    return true\n                                                                end\n\n                                                                return false\n                                                            end ,\n\n                                                            function (value)\n                                                                return value.componentJoint.rotLimitSpring[ 1 ], value.componentJoint.rotLimitSpring[ 2 ], value.componentJoint.rotLimitSpring[ 3 ], value.componentJoint.rotLimitDamping[ 1 ], value.componentJoint.rotLimitDamping[ 2 ], value.componentJoint.rotLimitDamping[ 3 ]\n                                                            end ,\n\n                                                            function (value, spring1, spring2, spring3, damping1, damping2, damping3)\n                                                                value.componentJoint.rotLimitSpring[ 1 ], value.componentJoint.rotLimitSpring[ 2 ], value.componentJoint.rotLimitSpring[ 3 ] = spring1, spring2, spring3\n                                                                value.componentJoint.rotLimitDamping[ 1 ], value.componentJoint.rotLimitDamping[ 2 ], value.componentJoint.rotLimitDamping[ 3 ] = damping1, damping2, damping3\n                                                                if value.componentJoint.jointIndex ~ = nil then\n                                                                    for i = 1 , 3 do\n                                                                        setJointRotationLimitSpring(value.componentJoint.jointIndex, i - 1 , value.componentJoint.rotLimitSpring[i], value.componentJoint.rotLimitDamping[i])\n                                                                    end\n                                                                end\n                                                            end )\n\n                                                            self:registerAnimationValueType( "componentMass" , "startMass" , "endMass" , false , AnimationValueFloat ,\n                                                            function (value, xmlFile, xmlKey)\n                                                                local componentIndex = xmlFile:getValue(xmlKey .. "#componentIndex" )\n                                                                if componentIndex ~ = nil then\n                                                                    if componentIndex > = 1 then\n                                                                        value.component = value.vehicle.components[componentIndex]\n                                                                    end\n\n                                                                    if value.component = = nil then\n                                                                        Logging.xmlWarning(xmlFile, "Invalid component for animation part \'%s\'.Indexing starts with 1!" , xmlKey)\n                                                                            return false\n                                                                        end\n                                                                    end\n\n                                                                    if value.component ~ = nil then\n                                                                        value:setWarningInformation( "componentIndex: " .. componentIndex)\n                                                                        value:addCompareParameters( "component" )\n\n                                                                        return true\n                                                                    end\n\n                                                                    return false\n                                                                end ,\n\n                                                                function (value)\n                                                                    return getMass(value.component.node) * 1000\n                                                                end ,\n\n                                                                function (value, mass)\n                                                                    setMass(value.component.node, mass * 0.001 )\n                                                                end )\n\n                                                                self:registerAnimationValueType( "centerOfMass" , "startCenterOfMass" , "endCenterOfMass" , false , AnimationValueFloat ,\n                                                                function (value, xmlFile, xmlKey)\n                                                                    local componentIndex = xmlFile:getValue(xmlKey .. "#componentIndex" )\n                                                                    if componentIndex ~ = nil then\n                                                                        if componentIndex > = 1 then\n                                                                            value.component = value.vehicle.components[componentIndex]\n                                                                        end\n\n                                                                        if value.component = = nil then\n                                                                            Logging.xmlWarning(xmlFile, "Invalid component for animation part \'%s\'.Indexing starts with 1!" , xmlKey)\n                                                                                return false\n                                                                            end\n                                                                        end\n\n                                                                        if value.component ~ = nil then\n                                                                            value:setWarningInformation( "componentIndex: " .. componentIndex)\n                                                                            value:addCompareParameters( "component" )\n\n                                                                            return true\n                                                                        end\n\n                                                                        return false\n                                                                    end ,\n\n                                                                    function (value)\n                                                                        return getCenterOfMass(value.component.node)\n                                                                    end ,\n\n                                                                    function (value, x, y, z)\n                                                                        setCenterOfMass(value.component.node, x, y, z)\n                                                                    end )\n\n                                                                    self:registerAnimationValueType( "frictionVelocity" , "startFrictionVelocity" , "endFrictionVelocity" , false , AnimationValueFloat , loadNodeFunction,\n                                                                    function (value)\n                                                                        return value.lastFrictionVelocity or 0\n                                                                    end ,\n\n                                                                    function (value, velocity)\n                                                                        setFrictionVelocity(value.node, velocity)\n                                                                        value.lastFrictionVelocity = velocity\n\n                                                                        if value.origTransX = = nil then\n                                                                            value.origTransX, value.origTransY, value.origTransZ = getTranslation(value.node)\n                                                                        end\n                                                                        setTranslation(value.node, value.origTransX + math.random() * 0.001 , value.origTransY, value.origTransZ)\n                                                                    end )\n                                                                end\n\n                                                                self:registerAnimationValueType( "spline" , "startSplinePos" , "endSplinePos" , false , AnimationValueFloat ,\n                                                                function (value, xmlFile, xmlKey)\n                                                                    value.node = xmlFile:getValue(xmlKey .. "#node" , nil , value.part.components, value.part.i3dMappings)\n                                                                    value.spline = xmlFile:getValue(xmlKey .. "#spline" , nil , value.part.components, value.part.i3dMappings)\n\n                                                                    if value.node ~ = nil and value.spline ~ = nil then\n                                                                        value:setWarningInformation( "node:" .. getName(value.node) .. " with spline: " .. getName(value.spline))\n                                                                        value:addCompareParameters( "node" , "spline" )\n\n                                                                        return true\n                                                                    end\n\n                                                                    return false\n                                                                end ,\n\n                                                                function (value)\n                                                                    if value.lastSplineTime ~ = nil then\n                                                                        return value.lastSplineTime\n                                                                    end\n\n                                                                    local startTime = value.startValue or value.endValue\n                                                                    if value.animation.currentSpeed < 0 then\n                                                                        startTime = value.endValue or value.startValue\n                                                                    end\n\n                                                                    return startTime[ 1 ]\n                                                                end ,\n\n                                                                function (value, splineTime)\n                                                                    local x, y, z = getSplinePosition(value.spline, splineTime % 1 )\n                                                                    x, y, z = worldToLocal(getParent(value.node), x, y, z)\n                                                                    setTranslation(value.node, x, y, z)\n\n                                                                    value.lastSplineTime = splineTime\n\n                                                                    for _, part2 in ipairs(value.animation.parts) do\n                                                                        for index = 1 , #part2.animationValues do\n                                                                            local value2 = part2.animationValues[index]\n                                                                            if value2.node = = value.node then\n                                                                                if value2.name = = value.name then\n                                                                                    value2.lastSplineTime = splineTime\n                                                                                end\n                                                                            end\n                                                                        end\n                                                                    end\n                                                                end )\n\n                                                                self:registerAnimationValueType( "rollingGate" , "startGatePos" , "endGatePos" , false , AnimationValueFloat ,\n                                                                function (value, xmlFile, xmlKey)\n                                                                    if xmlFile:hasProperty(xmlKey .. ".rollingGateAnimation" ) then\n                                                                        local rollingGate = RollingGateAnimation.new()\n                                                                        if rollingGate:load(xmlFile, xmlKey .. ".rollingGateAnimation" , value.part.components, value.part.i3dMappings) then\n                                                                            value:setWarningInformation( "rollingGateAnimation:" .. getName(rollingGate.splineNode))\n\n                                                                            value.rollingGate = rollingGate\n\n                                                                            return true\n                                                                        end\n                                                                    end\n\n                                                                    return false\n                                                                end ,\n\n                                                                function (value)\n                                                                    return value.rollingGate.state\n                                                                end ,\n\n                                                                function (value, state)\n                                                                    value.rollingGate:setState(state)\n                                                                end )\n                                                            end\n\n'})}),"\n",(0,a.jsx)(e.h3,{id:"onupdate",children:"onUpdate"}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)(e.strong,{children:"Description"})}),"\n",(0,a.jsxs)(e.blockquote,{children:["\n",(0,a.jsx)(e.p,{children:"Called on update"}),"\n"]}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)(e.strong,{children:"Definition"})}),"\n",(0,a.jsxs)(e.blockquote,{children:["\n",(0,a.jsx)(e.p,{children:"onUpdate(float dt, boolean isActiveForInput, boolean isSelected, )"}),"\n"]}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)(e.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,a.jsxs)(e.table,{children:[(0,a.jsx)(e.thead,{children:(0,a.jsxs)(e.tr,{children:[(0,a.jsx)(e.th,{children:"float"}),(0,a.jsx)(e.th,{children:"dt"}),(0,a.jsx)(e.th,{children:"time since last call in ms"})]})}),(0,a.jsxs)(e.tbody,{children:[(0,a.jsxs)(e.tr,{children:[(0,a.jsx)(e.td,{children:"boolean"}),(0,a.jsx)(e.td,{children:"isActiveForInput"}),(0,a.jsx)(e.td,{children:"true if vehicle is active for input"})]}),(0,a.jsxs)(e.tr,{children:[(0,a.jsx)(e.td,{children:"boolean"}),(0,a.jsx)(e.td,{children:"isSelected"}),(0,a.jsx)(e.td,{children:"true if vehicle is selected"})]}),(0,a.jsxs)(e.tr,{children:[(0,a.jsx)(e.td,{children:"any"}),(0,a.jsx)(e.td,{children:"isSelected"}),(0,a.jsx)(e.td,{})]})]})]}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)(e.strong,{children:"Code"})}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-lua",children:"function AnimatedVehicle:onUpdate(dt, isActiveForInput, isActiveForInputIgnoreSelection, isSelected)\n    AnimatedVehicle.updateAnimations( self , dt)\n\n    local spec = self.spec_animatedVehicle\n    if spec.fixedTimeSamplesDirtyDelay > 0 then\n        spec.fixedTimeSamplesDirtyDelay = spec.fixedTimeSamplesDirtyDelay - 1\n        if spec.fixedTimeSamplesDirtyDelay < = 0 then\n            for _, animation in pairs(spec.animations) do\n                if not table.hasElement(spec.activeAnimations, animation) then\n                    if self.isClient then\n                        for i = 1 , #animation.samples do\n                            local sample = animation.samples[i]\n                            if g_soundManager:getIsSamplePlaying(sample) then\n                                if sample.loops = = 0 then\n                                    g_soundManager:stopSample(sample)\n                                end\n                            end\n                        end\n                    end\n                end\n            end\n\n            spec.fixedTimeSamplesDirtyDelay = 0\n        end\n    end\n\n    if spec.numActiveAnimations > 0 then\n        self:raiseActive()\n    end\nend\n\n"})}),"\n",(0,a.jsx)(e.h3,{id:"playanimation",children:"playAnimation"}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)(e.strong,{children:"Description"})}),"\n",(0,a.jsxs)(e.blockquote,{children:["\n",(0,a.jsx)(e.p,{children:"Play animation"}),"\n"]}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)(e.strong,{children:"Definition"})}),"\n",(0,a.jsxs)(e.blockquote,{children:["\n",(0,a.jsx)(e.p,{children:"playAnimation(string name, float speed, float animTime, boolean noEventSend, )"}),"\n"]}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)(e.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,a.jsxs)(e.table,{children:[(0,a.jsx)(e.thead,{children:(0,a.jsxs)(e.tr,{children:[(0,a.jsx)(e.th,{children:"string"}),(0,a.jsx)(e.th,{children:"name"}),(0,a.jsx)(e.th,{children:"name of animation"})]})}),(0,a.jsxs)(e.tbody,{children:[(0,a.jsxs)(e.tr,{children:[(0,a.jsx)(e.td,{children:"float"}),(0,a.jsx)(e.td,{children:"speed"}),(0,a.jsx)(e.td,{children:"speed"})]}),(0,a.jsxs)(e.tr,{children:[(0,a.jsx)(e.td,{children:"float"}),(0,a.jsx)(e.td,{children:"animTime"}),(0,a.jsx)(e.td,{children:"start time"})]}),(0,a.jsxs)(e.tr,{children:[(0,a.jsx)(e.td,{children:"boolean"}),(0,a.jsx)(e.td,{children:"noEventSend"}),(0,a.jsx)(e.td,{children:"no event send"})]}),(0,a.jsxs)(e.tr,{children:[(0,a.jsx)(e.td,{children:"any"}),(0,a.jsx)(e.td,{children:"allowSounds"}),(0,a.jsx)(e.td,{})]})]})]}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)(e.strong,{children:"Code"})}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-lua",children:'function AnimatedVehicle:playAnimation(name, speed, animTime, noEventSend, allowSounds)\n    local spec = self.spec_animatedVehicle\n\n    local animation = spec.animations[name]\n    if animation ~ = nil then\n        SpecializationUtil.raiseEvent( self , "onPlayAnimation" , name)\n\n        if speed = = nil then\n            speed = animation.currentSpeed\n        end\n\n        -- skip animation if speed is not set or 0 to allow skipping animations per xml speed attribute set to 0\n            if speed = = nil or speed = = 0 then\n                return\n            end\n\n            if animTime = = nil then\n                if self:getIsAnimationPlaying(name) then\n                    animTime = self:getAnimationTime(name)\n                elseif speed > 0 then\n                        animTime = 0\n                    else\n                            animTime = 1\n                        end\n                    end\n                    if noEventSend = = nil or noEventSend = = false then\n                        if g_server ~ = nil then\n                            g_server:broadcastEvent( AnimatedVehicleStartEvent.new( self , name, speed, animTime), nil , nil , self )\n                        else\n                                g_client:getServerConnection():sendEvent( AnimatedVehicleStartEvent.new( self , name, speed, animTime))\n                            end\n                        end\n\n                        if not table.hasElement(spec.activeAnimations, animation) then\n                            table.addElement(spec.activeAnimations, animation)\n                            spec.numActiveAnimations = spec.numActiveAnimations + 1\n                            SpecializationUtil.raiseEvent( self , "onStartAnimation" , name, speed)\n                        end\n                        animation.currentSpeed = speed\n                        animation.currentTime = animTime * animation.duration\n                        self:resetAnimationValues(animation)\n\n                        self:raiseActive()\n                    end\n                end\n\n'})}),"\n",(0,a.jsx)(e.h3,{id:"postinitializeanimationpart",children:"postInitializeAnimationPart"}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)(e.strong,{children:"Description"})}),"\n",(0,a.jsxs)(e.blockquote,{children:["\n",(0,a.jsx)(e.p,{children:"Post Initialize part of animation (normally used to set default start value if not set by the end value of the\nprevious part)"}),"\n"]}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)(e.strong,{children:"Definition"})}),"\n",(0,a.jsxs)(e.blockquote,{children:["\n",(0,a.jsx)(e.p,{children:"postInitializeAnimationPart(table part, , , )"}),"\n"]}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)(e.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,a.jsxs)(e.table,{children:[(0,a.jsx)(e.thead,{children:(0,a.jsxs)(e.tr,{children:[(0,a.jsx)(e.th,{children:"table"}),(0,a.jsx)(e.th,{children:"part"}),(0,a.jsx)(e.th,{children:"part"})]})}),(0,a.jsxs)(e.tbody,{children:[(0,a.jsxs)(e.tr,{children:[(0,a.jsx)(e.td,{children:"any"}),(0,a.jsx)(e.td,{children:"part"}),(0,a.jsx)(e.td,{})]}),(0,a.jsxs)(e.tr,{children:[(0,a.jsx)(e.td,{children:"any"}),(0,a.jsx)(e.td,{children:"i"}),(0,a.jsx)(e.td,{})]}),(0,a.jsxs)(e.tr,{children:[(0,a.jsx)(e.td,{children:"any"}),(0,a.jsx)(e.td,{children:"numParts"}),(0,a.jsx)(e.td,{})]})]})]}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)(e.strong,{children:"Code"})}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-lua",children:"function AnimatedVehicle:postInitializeAnimationPart(animation, part, i, numParts)\n    for index = 1 , #part.animationValues do\n        part.animationValues[index]:postInit()\n    end\nend\n\n"})}),"\n",(0,a.jsx)(e.h3,{id:"prerequisitespresent",children:"prerequisitesPresent"}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)(e.strong,{children:"Description"})}),"\n",(0,a.jsxs)(e.blockquote,{children:["\n",(0,a.jsx)(e.p,{children:"Checks if all prerequisite specializations are loaded"}),"\n"]}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)(e.strong,{children:"Definition"})}),"\n",(0,a.jsxs)(e.blockquote,{children:["\n",(0,a.jsx)(e.p,{children:"prerequisitesPresent(table specializations)"}),"\n"]}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)(e.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n",(0,a.jsx)(e.table,{children:(0,a.jsx)(e.thead,{children:(0,a.jsxs)(e.tr,{children:[(0,a.jsx)(e.th,{children:"table"}),(0,a.jsx)(e.th,{children:"specializations"}),(0,a.jsx)(e.th,{children:"specializations"})]})})}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)(e.strong,{children:"Return Values"})}),"\n\n\n\n\n\n\n\n\n",(0,a.jsx)(e.table,{children:(0,a.jsx)(e.thead,{children:(0,a.jsxs)(e.tr,{children:[(0,a.jsx)(e.th,{children:"table"}),(0,a.jsx)(e.th,{children:"hasPrerequisite"}),(0,a.jsx)(e.th,{children:"true if all prerequisite specializations are loaded"})]})})}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)(e.strong,{children:"Code"})}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-lua",children:"function AnimatedVehicle.prerequisitesPresent(specializations)\n    return true\nend\n\n"})}),"\n",(0,a.jsx)(e.h3,{id:"registeranimationvaluetype",children:"registerAnimationValueType"}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)(e.strong,{children:"Description"})}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)(e.strong,{children:"Definition"})}),"\n",(0,a.jsxs)(e.blockquote,{children:["\n",(0,a.jsx)(e.p,{children:"registerAnimationValueType()"}),"\n"]}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)(e.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,a.jsxs)(e.table,{children:[(0,a.jsx)(e.thead,{children:(0,a.jsxs)(e.tr,{children:[(0,a.jsx)(e.th,{children:"any"}),(0,a.jsx)(e.th,{children:"name"})]})}),(0,a.jsxs)(e.tbody,{children:[(0,a.jsxs)(e.tr,{children:[(0,a.jsx)(e.td,{children:"any"}),(0,a.jsx)(e.td,{children:"startName"})]}),(0,a.jsxs)(e.tr,{children:[(0,a.jsx)(e.td,{children:"any"}),(0,a.jsx)(e.td,{children:"endName"})]}),(0,a.jsxs)(e.tr,{children:[(0,a.jsx)(e.td,{children:"any"}),(0,a.jsx)(e.td,{children:"initialUpdate"})]}),(0,a.jsxs)(e.tr,{children:[(0,a.jsx)(e.td,{children:"any"}),(0,a.jsx)(e.td,{children:"classObject"})]}),(0,a.jsxs)(e.tr,{children:[(0,a.jsx)(e.td,{children:"any"}),(0,a.jsx)(e.td,{children:"load"})]}),(0,a.jsxs)(e.tr,{children:[(0,a.jsx)(e.td,{children:"any"}),(0,a.jsx)(e.td,{children:"get"})]}),(0,a.jsxs)(e.tr,{children:[(0,a.jsx)(e.td,{children:"any"}),(0,a.jsx)(e.td,{children:"set"})]})]})]}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)(e.strong,{children:"Code"})}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-lua",children:"function AnimatedVehicle:registerAnimationValueType(name, startName, endName, initialUpdate, classObject, load, get, set)\n    local spec = self.spec_animatedVehicle\n\n    if spec.animationValueTypes[name] = = nil then\n        local animationValueType = { }\n\n        animationValueType.classObject = classObject\n        animationValueType.name = name\n        animationValueType.startName = startName\n        animationValueType.endName = endName\n        animationValueType.initialUpdate = initialUpdate\n        animationValueType.load = load\n        animationValueType.get = get\n        animationValueType.set = set\n\n        spec.animationValueTypes[name] = animationValueType\n    end\nend\n\n"})}),"\n",(0,a.jsx)(e.h3,{id:"registeranimationxmlpaths",children:"registerAnimationXMLPaths"}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)(e.strong,{children:"Description"})}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)(e.strong,{children:"Definition"})}),"\n",(0,a.jsxs)(e.blockquote,{children:["\n",(0,a.jsx)(e.p,{children:"registerAnimationXMLPaths()"}),"\n"]}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)(e.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,a.jsxs)(e.table,{children:[(0,a.jsx)(e.thead,{children:(0,a.jsxs)(e.tr,{children:[(0,a.jsx)(e.th,{children:"any"}),(0,a.jsx)(e.th,{children:"schema"})]})}),(0,a.jsx)(e.tbody,{children:(0,a.jsxs)(e.tr,{children:[(0,a.jsx)(e.td,{children:"any"}),(0,a.jsx)(e.td,{children:"basePath"})]})})]}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)(e.strong,{children:"Code"})}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-lua",children:'function AnimatedVehicle.registerAnimationXMLPaths(schema, basePath)\n    schema:register(XMLValueType.STRING, basePath .. "#name" , "Name of animation" )\n    schema:register(XMLValueType.BOOL, basePath .. "#looping" , "Animation is looping" , false )\n    schema:register(XMLValueType.BOOL, basePath .. "#resetOnStart" , "Animation is reset while loading the vehicle" , true )\n        schema:register(XMLValueType.FLOAT, basePath .. "#startAnimTime" , "Animation is set to this time if resetOnStart is set" , 0 )\n            schema:register(XMLValueType.FLOAT, basePath .. "#soundVolumeFactor" , "Sound volume factor that is applied for all sounds in this animation" , 1 )\n                schema:register(XMLValueType.BOOL, basePath .. "#isKeyframe" , "Is static keyframe animation instead of dynamically interpolating animation(Keyframe animations only support trans/rot/scale!)" , false )\n\n                schema:addDelayedRegistrationPath(basePath .. ".part(?)" , "AnimatedVehicle:part" )\n\n                schema:register(XMLValueType.NODE_INDEX, basePath .. ".part(?)#node" , "Part node" )\n                schema:register(XMLValueType.FLOAT, basePath .. ".part(?)#startTime" , "Start time" )\n                schema:register(XMLValueType.FLOAT, basePath .. ".part(?)#duration" , "Duration" )\n                schema:register(XMLValueType.FLOAT, basePath .. ".part(?)#endTime" , "End time" )\n                schema:register(XMLValueType.FLOAT, basePath .. ".part(?)#time" , "Keyframe time(only for keyframe animations)" )\n                    schema:register(XMLValueType.INT, basePath .. ".part(?)#direction" , "Part direction" , 0 )\n                    schema:register(XMLValueType.STRING, basePath .. ".part(?)#tangentType" , "Type of tangent to be used(linear, spline, step)" , "linear" )\n\n                    schema:register(XMLValueType.VECTOR_ROT, basePath .. ".part(?)#startRot" , "Start rotation" )\n                    schema:register(XMLValueType.VECTOR_ROT, basePath .. ".part(?)#endRot" , "End rotation" )\n                    schema:register(XMLValueType.VECTOR_TRANS, basePath .. ".part(?)#startTrans" , "Start translation" )\n                    schema:register(XMLValueType.VECTOR_TRANS, basePath .. ".part(?)#endTrans" , "End translation" )\n                    schema:register(XMLValueType.VECTOR_SCALE, basePath .. ".part(?)#startScale" , "Start scale" )\n                    schema:register(XMLValueType.VECTOR_SCALE, basePath .. ".part(?)#endScale" , "End scale" )\n                    schema:register(XMLValueType.BOOL, basePath .. ".part(?)#visibility" , "Visibility" )\n                    schema:register(XMLValueType.BOOL, basePath .. ".part(?)#startVisibility" , "Visibility at start time(switched in the middle)" )\n                    schema:register(XMLValueType.BOOL, basePath .. ".part(?)#endVisibility" , "Visibility at end time(switched in the middle)" )\n                    schema:register(XMLValueType.INT, basePath .. ".part(?)#componentJointIndex" , "Component joint index" )\n\n                    schema:register(XMLValueType.VECTOR_ROT, basePath .. ".part(?)#rotation" , "Rotation(only for keyframe animations)" )\n                        schema:register(XMLValueType.VECTOR_TRANS, basePath .. ".part(?)#translation" , "Translation(only for keyframe animations)" )\n                            schema:register(XMLValueType.VECTOR_SCALE, basePath .. ".part(?)#scale" , "Scale(only for keyframe animations)" )\n\n                                schema:register(XMLValueType.STRING, basePath .. ".part(?)#requiredAnimation" , "Required animation needs to be in a specific range to play part" )\n                                schema:register(XMLValueType.VECTOR_ 2 , basePath .. ".part(?)#requiredAnimationRange" , "Animation range of required animation" )\n\n                                schema:register(XMLValueType.STRING, basePath .. ".part(?)#requiredConfigurationName" , "This configuration needs to bet set to #requiredConfigurationIndex" )\n                                schema:register(XMLValueType.INT, basePath .. ".part(?)#requiredConfigurationIndex" , "Required configuration needs to be in this state to activate the animation part" )\n\n                                schema:register(XMLValueType.VECTOR_ROT, basePath .. ".part(?)#startRotLimit" , "Start rotation limit" )\n                                schema:register(XMLValueType.VECTOR_ROT, basePath .. ".part(?)#startRotMinLimit" , "Start rotation min limit" )\n                                schema:register(XMLValueType.VECTOR_ROT, basePath .. ".part(?)#startRotMaxLimit" , "Start rotation max limit" )\n\n                                schema:register(XMLValueType.VECTOR_ROT, basePath .. ".part(?)#endRotLimit" , "End rotation limit" )\n                                schema:register(XMLValueType.VECTOR_ROT, basePath .. ".part(?)#endRotMinLimit" , "End rotation min limit" )\n                                schema:register(XMLValueType.VECTOR_ROT, basePath .. ".part(?)#endRotMaxLimit" , "End rotation max limit" )\n\n                                schema:register(XMLValueType.VECTOR_TRANS, basePath .. ".part(?)#startTransLimit" , "Start translation limit" )\n                                schema:register(XMLValueType.VECTOR_TRANS, basePath .. ".part(?)#startTransMinLimit" , "Start translation min limit" )\n                                schema:register(XMLValueType.VECTOR_TRANS, basePath .. ".part(?)#startTransMaxLimit" , "Start translation max limit" )\n\n                                schema:register(XMLValueType.VECTOR_TRANS, basePath .. ".part(?)#endTransLimit" , "End translation limit" )\n                                schema:register(XMLValueType.VECTOR_TRANS, basePath .. ".part(?)#endTransMinLimit" , "End translation min limit" )\n                                schema:register(XMLValueType.VECTOR_TRANS, basePath .. ".part(?)#endTransMaxLimit" , "End translation max limit" )\n\n                                schema:register(XMLValueType.VECTOR_ 3 , basePath .. ".part(?)#startRotLimitSpring" , "Start rot limit spring" )\n                                schema:register(XMLValueType.VECTOR_ 3 , basePath .. ".part(?)#startRotLimitDamping" , "Start rot limit damping" )\n\n                                schema:register(XMLValueType.VECTOR_ 3 , basePath .. ".part(?)#endRotLimitSpring" , "End rot limit spring" )\n                                schema:register(XMLValueType.VECTOR_ 3 , basePath .. ".part(?)#endRotLimitDamping" , "End rot limit damping" )\n\n                                schema:register(XMLValueType.INT, basePath .. ".part(?)#componentIndex" , "Component index" )\n                                schema:register(XMLValueType.FLOAT, basePath .. ".part(?)#startMass" , "Start mass of component" )\n                                schema:register(XMLValueType.VECTOR_TRANS, basePath .. ".part(?)#startCenterOfMass" , "Start center of mass" )\n                                schema:register(XMLValueType.FLOAT, basePath .. ".part(?)#endMass" , "End mass of component" )\n                                schema:register(XMLValueType.VECTOR_TRANS, basePath .. ".part(?)#endCenterOfMass" , "End center of mass" )\n\n                                schema:register(XMLValueType.FLOAT, basePath .. ".part(?)#startFrictionVelocity" , "Start friction velocity applied to node" )\n                                schema:register(XMLValueType.FLOAT, basePath .. ".part(?)#endFrictionVelocity" , "End friction velocity applied to node" )\n\n                                schema:register(XMLValueType.STRING, basePath .. ".part(?)#shaderParameter" , "Shader parameter" )\n                                schema:register(XMLValueType.STRING, basePath .. ".part(?)#shaderParameterPrev" , "Shader parameter(prev)" )\n                                schema:register(XMLValueType.STRING_LIST, basePath .. ".part(?)#shaderStartValues" , "Start shader values" )\n                                schema:register(XMLValueType.STRING_LIST, basePath .. ".part(?)#shaderEndValues" , "End shader values" )\n\n                                schema:register(XMLValueType.STRING, basePath .. ".part(?)#animationClip" , "Animation clip name" )\n                                schema:register(XMLValueType.FLOAT, basePath .. ".part(?)#clipStartTime" , "Animation clip start time" )\n                                schema:register(XMLValueType.FLOAT, basePath .. ".part(?)#clipEndTime" , "Animation clip end time" )\n\n                                schema:register(XMLValueType.STRING, basePath .. ".part(?)#dependentAnimation" , "Dependent animation name" )\n                                schema:register(XMLValueType.FLOAT, basePath .. ".part(?)#dependentAnimationStartTime" , "Dependent animation start time" )\n                                schema:register(XMLValueType.FLOAT, basePath .. ".part(?)#dependentAnimationEndTime" , "Dependent animation end time" )\n\n                                schema:register(XMLValueType.NODE_INDEX, basePath .. ".part(?)#spline" , "Spline node" )\n                                schema:register(XMLValueType.FLOAT, basePath .. ".part(?)#startSplinePos" , "Start spline position" )\n                                schema:register(XMLValueType.FLOAT, basePath .. ".part(?)#endSplinePos" , "End spline position" )\n\n                                RollingGateAnimation.registerXMLPaths(schema, basePath .. ".part(?).rollingGateAnimation" )\n                                schema:register(XMLValueType.FLOAT, basePath .. ".part(?)#startGatePos" , "Start rolling gate position" )\n                                schema:register(XMLValueType.FLOAT, basePath .. ".part(?)#endGatePos" , "End rolling gate position" )\n\n                                SoundManager.registerSampleXMLPaths(schema, basePath, "sound(?)" )\n                                schema:register(XMLValueType.TIME, basePath .. ".sound(?)#startTime" , "Start play time" , 0 )\n                                schema:register(XMLValueType.TIME, basePath .. ".sound(?)#endTime" , "End play time for loops or used on opposite direction" )\n                                    schema:register(XMLValueType.INT, basePath .. ".sound(?)#direction" , "Direction to play the sound(0 = any direction)" , 0 )\n                                    schema:register(XMLValueType.FLOAT, basePath .. ".sound(?)#startPitchScale" , "Pitch scale at the start time" )\n                                    schema:register(XMLValueType.FLOAT, basePath .. ".sound(?)#endPitchScale" , "Pitch scale at the end time" )\n\n                                    SoundManager.registerSampleXMLPaths(schema, basePath, "stopTimePosSound(?)" )\n                                    SoundManager.registerSampleXMLPaths(schema, basePath, "stopTimeNegSound(?)" )\n                                end\n\n'})}),"\n",(0,a.jsx)(e.h3,{id:"registereventlisteners",children:"registerEventListeners"}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)(e.strong,{children:"Description"})}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)(e.strong,{children:"Definition"})}),"\n",(0,a.jsxs)(e.blockquote,{children:["\n",(0,a.jsx)(e.p,{children:"registerEventListeners()"}),"\n"]}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)(e.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,a.jsx)(e.table,{children:(0,a.jsx)(e.thead,{children:(0,a.jsxs)(e.tr,{children:[(0,a.jsx)(e.th,{children:"any"}),(0,a.jsx)(e.th,{children:"vehicleType"})]})})}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)(e.strong,{children:"Code"})}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-lua",children:'function AnimatedVehicle.registerEventListeners(vehicleType)\n    SpecializationUtil.registerEventListener(vehicleType, "onPreLoad" , AnimatedVehicle )\n    SpecializationUtil.registerEventListener(vehicleType, "onLoad" , AnimatedVehicle )\n    SpecializationUtil.registerEventListener(vehicleType, "onPostLoad" , AnimatedVehicle )\n    SpecializationUtil.registerEventListener(vehicleType, "onDelete" , AnimatedVehicle )\n    SpecializationUtil.registerEventListener(vehicleType, "onUpdate" , AnimatedVehicle )\n    SpecializationUtil.registerEventListener(vehicleType, "onRegisterAnimationValueTypes" , AnimatedVehicle )\nend\n\n'})}),"\n",(0,a.jsx)(e.h3,{id:"registerevents",children:"registerEvents"}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)(e.strong,{children:"Description"})}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)(e.strong,{children:"Definition"})}),"\n",(0,a.jsxs)(e.blockquote,{children:["\n",(0,a.jsx)(e.p,{children:"registerEvents()"}),"\n"]}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)(e.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,a.jsx)(e.table,{children:(0,a.jsx)(e.thead,{children:(0,a.jsxs)(e.tr,{children:[(0,a.jsx)(e.th,{children:"any"}),(0,a.jsx)(e.th,{children:"vehicleType"})]})})}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)(e.strong,{children:"Code"})}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-lua",children:'function AnimatedVehicle.registerEvents(vehicleType)\n    SpecializationUtil.registerEvent(vehicleType, "onRegisterAnimationValueTypes" )\n    SpecializationUtil.registerEvent(vehicleType, "onPlayAnimation" )\n    SpecializationUtil.registerEvent(vehicleType, "onStartAnimation" )\n    SpecializationUtil.registerEvent(vehicleType, "onUpdateAnimation" )\n    SpecializationUtil.registerEvent(vehicleType, "onFinishAnimation" )\n    SpecializationUtil.registerEvent(vehicleType, "onStopAnimation" )\n    SpecializationUtil.registerEvent(vehicleType, "onAnimationPartChanged" )\nend\n\n'})}),"\n",(0,a.jsx)(e.h3,{id:"registerfunctions",children:"registerFunctions"}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)(e.strong,{children:"Description"})}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)(e.strong,{children:"Definition"})}),"\n",(0,a.jsxs)(e.blockquote,{children:["\n",(0,a.jsx)(e.p,{children:"registerFunctions()"}),"\n"]}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)(e.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,a.jsx)(e.table,{children:(0,a.jsx)(e.thead,{children:(0,a.jsxs)(e.tr,{children:[(0,a.jsx)(e.th,{children:"any"}),(0,a.jsx)(e.th,{children:"vehicleType"})]})})}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)(e.strong,{children:"Code"})}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-lua",children:'function AnimatedVehicle.registerFunctions(vehicleType)\n    SpecializationUtil.registerFunction(vehicleType, "registerAnimationValueType" , AnimatedVehicle.registerAnimationValueType)\n    SpecializationUtil.registerFunction(vehicleType, "loadAnimation" , AnimatedVehicle.loadAnimation)\n    SpecializationUtil.registerFunction(vehicleType, "loadAnimationPart" , AnimatedVehicle.loadAnimationPart)\n    SpecializationUtil.registerFunction(vehicleType, "loadStaticAnimationPart" , AnimatedVehicle.loadStaticAnimationPart)\n    SpecializationUtil.registerFunction(vehicleType, "loadStaticAnimationPartValues" , AnimatedVehicle.loadStaticAnimationPartValues)\n    SpecializationUtil.registerFunction(vehicleType, "initializeAnimationParts" , AnimatedVehicle.initializeAnimationParts)\n    SpecializationUtil.registerFunction(vehicleType, "initializeAnimationPart" , AnimatedVehicle.initializeAnimationPart)\n    SpecializationUtil.registerFunction(vehicleType, "postInitializeAnimationPart" , AnimatedVehicle.postInitializeAnimationPart)\n    SpecializationUtil.registerFunction(vehicleType, "playAnimation" , AnimatedVehicle.playAnimation)\n    SpecializationUtil.registerFunction(vehicleType, "stopAnimation" , AnimatedVehicle.stopAnimation)\n    SpecializationUtil.registerFunction(vehicleType, "getAnimationExists" , AnimatedVehicle.getAnimationExists)\n    SpecializationUtil.registerFunction(vehicleType, "getAnimationByName" , AnimatedVehicle.getAnimationByName)\n    SpecializationUtil.registerFunction(vehicleType, "getIsAnimationPlaying" , AnimatedVehicle.getIsAnimationPlaying)\n    SpecializationUtil.registerFunction(vehicleType, "getRealAnimationTime" , AnimatedVehicle.getRealAnimationTime)\n    SpecializationUtil.registerFunction(vehicleType, "setRealAnimationTime" , AnimatedVehicle.setRealAnimationTime)\n    SpecializationUtil.registerFunction(vehicleType, "getAnimationTime" , AnimatedVehicle.getAnimationTime)\n    SpecializationUtil.registerFunction(vehicleType, "setAnimationTime" , AnimatedVehicle.setAnimationTime)\n    SpecializationUtil.registerFunction(vehicleType, "getAnimationDuration" , AnimatedVehicle.getAnimationDuration)\n    SpecializationUtil.registerFunction(vehicleType, "setAnimationSpeed" , AnimatedVehicle.setAnimationSpeed)\n    SpecializationUtil.registerFunction(vehicleType, "getAnimationSpeed" , AnimatedVehicle.getAnimationSpeed)\n    SpecializationUtil.registerFunction(vehicleType, "setAnimationStopTime" , AnimatedVehicle.setAnimationStopTime)\n    SpecializationUtil.registerFunction(vehicleType, "resetAnimationValues" , AnimatedVehicle.resetAnimationValues)\n    SpecializationUtil.registerFunction(vehicleType, "resetAnimationPartValues" , AnimatedVehicle.resetAnimationPartValues)\n    SpecializationUtil.registerFunction(vehicleType, "updateAnimationPart" , AnimatedVehicle.updateAnimationPart)\n    SpecializationUtil.registerFunction(vehicleType, "getNumOfActiveAnimations" , AnimatedVehicle.getNumOfActiveAnimations)\nend\n\n'})}),"\n",(0,a.jsx)(e.h3,{id:"registeroverwrittenfunctions",children:"registerOverwrittenFunctions"}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)(e.strong,{children:"Description"})}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)(e.strong,{children:"Definition"})}),"\n",(0,a.jsxs)(e.blockquote,{children:["\n",(0,a.jsx)(e.p,{children:"registerOverwrittenFunctions()"}),"\n"]}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)(e.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,a.jsx)(e.table,{children:(0,a.jsx)(e.thead,{children:(0,a.jsxs)(e.tr,{children:[(0,a.jsx)(e.th,{children:"any"}),(0,a.jsx)(e.th,{children:"vehicleType"})]})})}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)(e.strong,{children:"Code"})}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-lua",children:'function AnimatedVehicle.registerOverwrittenFunctions(vehicleType)\n    SpecializationUtil.registerOverwrittenFunction(vehicleType, "loadSpeedRotatingPartFromXML" , AnimatedVehicle.loadSpeedRotatingPartFromXML)\n    SpecializationUtil.registerOverwrittenFunction(vehicleType, "getIsSpeedRotatingPartActive" , AnimatedVehicle.getIsSpeedRotatingPartActive)\n    SpecializationUtil.registerOverwrittenFunction(vehicleType, "loadWorkAreaFromXML" , AnimatedVehicle.loadWorkAreaFromXML)\n    SpecializationUtil.registerOverwrittenFunction(vehicleType, "getIsWorkAreaActive" , AnimatedVehicle.getIsWorkAreaActive)\n    SpecializationUtil.registerOverwrittenFunction(vehicleType, "loadMovingToolFromXML" , AnimatedVehicle.loadMovingToolFromXML)\n    SpecializationUtil.registerOverwrittenFunction(vehicleType, "getIsMovingToolActive" , AnimatedVehicle.getIsMovingToolActive)\n    SpecializationUtil.registerOverwrittenFunction(vehicleType, "loadMovingPartFromXML" , AnimatedVehicle.loadMovingPartFromXML)\n    SpecializationUtil.registerOverwrittenFunction(vehicleType, "getIsMovingPartActive" , AnimatedVehicle.getIsMovingPartActive)\nend\n\n'})}),"\n",(0,a.jsx)(e.h3,{id:"resetanimationpartvalues",children:"resetAnimationPartValues"}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)(e.strong,{children:"Description"})}),"\n",(0,a.jsxs)(e.blockquote,{children:["\n",(0,a.jsx)(e.p,{children:"Resets animation part"}),"\n"]}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)(e.strong,{children:"Definition"})}),"\n",(0,a.jsxs)(e.blockquote,{children:["\n",(0,a.jsx)(e.p,{children:"resetAnimationPartValues(table part)"}),"\n"]}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)(e.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n",(0,a.jsx)(e.table,{children:(0,a.jsx)(e.thead,{children:(0,a.jsxs)(e.tr,{children:[(0,a.jsx)(e.th,{children:"table"}),(0,a.jsx)(e.th,{children:"part"}),(0,a.jsx)(e.th,{children:"part to reset"})]})})}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)(e.strong,{children:"Code"})}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-lua",children:"function AnimatedVehicle:resetAnimationPartValues(part)\n    for index = 1 , #part.animationValues do\n        part.animationValues[index]:reset()\n    end\nend\n\n"})}),"\n",(0,a.jsx)(e.h3,{id:"resetanimationvalues",children:"resetAnimationValues"}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)(e.strong,{children:"Description"})}),"\n",(0,a.jsxs)(e.blockquote,{children:["\n",(0,a.jsx)(e.p,{children:"Resets animation values"}),"\n"]}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)(e.strong,{children:"Definition"})}),"\n",(0,a.jsxs)(e.blockquote,{children:["\n",(0,a.jsx)(e.p,{children:"resetAnimationValues(table animation)"}),"\n"]}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)(e.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n",(0,a.jsx)(e.table,{children:(0,a.jsx)(e.thead,{children:(0,a.jsxs)(e.tr,{children:[(0,a.jsx)(e.th,{children:"table"}),(0,a.jsx)(e.th,{children:"animation"}),(0,a.jsx)(e.th,{children:"animation"})]})})}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)(e.strong,{children:"Code"})}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-lua",children:"function AnimatedVehicle:resetAnimationValues(animation)\n    AnimatedVehicle.findCurrentPartIndex(animation)\n    for _, part in ipairs(animation.parts) do\n        self:resetAnimationPartValues(part)\n    end\nend\n\n"})}),"\n",(0,a.jsx)(e.h3,{id:"setanimationspeed",children:"setAnimationSpeed"}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)(e.strong,{children:"Description"})}),"\n",(0,a.jsxs)(e.blockquote,{children:["\n",(0,a.jsx)(e.p,{children:"Sets speed of animation"}),"\n"]}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)(e.strong,{children:"Definition"})}),"\n",(0,a.jsxs)(e.blockquote,{children:["\n",(0,a.jsx)(e.p,{children:"setAnimationSpeed(string name, float speed)"}),"\n"]}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)(e.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,a.jsxs)(e.table,{children:[(0,a.jsx)(e.thead,{children:(0,a.jsxs)(e.tr,{children:[(0,a.jsx)(e.th,{children:"string"}),(0,a.jsx)(e.th,{children:"name"}),(0,a.jsx)(e.th,{children:"name of animation"})]})}),(0,a.jsx)(e.tbody,{children:(0,a.jsxs)(e.tr,{children:[(0,a.jsx)(e.td,{children:"float"}),(0,a.jsx)(e.td,{children:"speed"}),(0,a.jsx)(e.td,{children:"speed"})]})})]}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)(e.strong,{children:"Code"})}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-lua",children:"function AnimatedVehicle:setAnimationSpeed(name, speed)\n    local spec = self.spec_animatedVehicle\n\n    local animation = spec.animations[name]\n    if animation ~ = nil then\n        local speedReversed = false\n        if (animation.currentSpeed > 0 ) ~ = (speed > 0 ) then\n            speedReversed = true\n        end\n        animation.currentSpeed = speed\n        if self:getIsAnimationPlaying(name) and speedReversed then\n            self:resetAnimationValues(animation)\n        end\n    end\nend\n\n"})}),"\n",(0,a.jsx)(e.h3,{id:"setanimationstoptime",children:"setAnimationStopTime"}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)(e.strong,{children:"Description"})}),"\n",(0,a.jsxs)(e.blockquote,{children:["\n",(0,a.jsx)(e.p,{children:"Sets animation stop time"}),"\n"]}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)(e.strong,{children:"Definition"})}),"\n",(0,a.jsxs)(e.blockquote,{children:["\n",(0,a.jsx)(e.p,{children:"setAnimationStopTime(string name, float stopTime)"}),"\n"]}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)(e.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,a.jsxs)(e.table,{children:[(0,a.jsx)(e.thead,{children:(0,a.jsxs)(e.tr,{children:[(0,a.jsx)(e.th,{children:"string"}),(0,a.jsx)(e.th,{children:"name"}),(0,a.jsx)(e.th,{children:"name of animation"})]})}),(0,a.jsx)(e.tbody,{children:(0,a.jsxs)(e.tr,{children:[(0,a.jsx)(e.td,{children:"float"}),(0,a.jsx)(e.td,{children:"stopTime"}),(0,a.jsx)(e.td,{children:"stop time [0..1]"})]})})]}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)(e.strong,{children:"Code"})}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-lua",children:"function AnimatedVehicle:setAnimationStopTime(name, stopTime)\n    local spec = self.spec_animatedVehicle\n\n    local animation = spec.animations[name]\n    if animation ~ = nil then\n        animation.stopTime = stopTime * animation.duration\n    end\nend\n\n"})}),"\n",(0,a.jsx)(e.h3,{id:"setanimationtime",children:"setAnimationTime"}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)(e.strong,{children:"Description"})}),"\n",(0,a.jsxs)(e.blockquote,{children:["\n",(0,a.jsx)(e.p,{children:"Set animation time"}),"\n"]}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)(e.strong,{children:"Definition"})}),"\n",(0,a.jsxs)(e.blockquote,{children:["\n",(0,a.jsx)(e.p,{children:"setAnimationTime(string name, float animTime, boolean update, )"}),"\n"]}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)(e.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,a.jsxs)(e.table,{children:[(0,a.jsx)(e.thead,{children:(0,a.jsxs)(e.tr,{children:[(0,a.jsx)(e.th,{children:"string"}),(0,a.jsx)(e.th,{children:"name"}),(0,a.jsx)(e.th,{children:"name of animation"})]})}),(0,a.jsxs)(e.tbody,{children:[(0,a.jsxs)(e.tr,{children:[(0,a.jsx)(e.td,{children:"float"}),(0,a.jsx)(e.td,{children:"animTime"}),(0,a.jsx)(e.td,{children:"animation time [0..1]"})]}),(0,a.jsxs)(e.tr,{children:[(0,a.jsx)(e.td,{children:"boolean"}),(0,a.jsx)(e.td,{children:"update"}),(0,a.jsx)(e.td,{children:"update animation"})]}),(0,a.jsxs)(e.tr,{children:[(0,a.jsx)(e.td,{children:"any"}),(0,a.jsx)(e.td,{children:"playSounds"}),(0,a.jsx)(e.td,{})]})]})]}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)(e.strong,{children:"Code"})}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-lua",children:"function AnimatedVehicle:setAnimationTime(name, animTime, update, playSounds)\n    local spec = self.spec_animatedVehicle\n\n    if spec.animations = = nil then\n        printCallstack()\n    end\n\n    local animation = spec.animations[name]\n    if animation ~ = nil then\n        self:setRealAnimationTime(name, animTime * animation.duration, update, playSounds)\n    end\nend\n\n"})}),"\n",(0,a.jsx)(e.h3,{id:"setmovedlimitedvalues3",children:"setMovedLimitedValues3"}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)(e.strong,{children:"Description"})}),"\n",(0,a.jsxs)(e.blockquote,{children:["\n",(0,a.jsx)(e.p,{children:"Sets moved limited values (3)"}),"\n"]}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)(e.strong,{children:"Definition"})}),"\n",(0,a.jsxs)(e.blockquote,{children:["\n",(0,a.jsx)(e.p,{children:"setMovedLimitedValues3(table currentValues, table destValues, table speeds, float dt)"}),"\n"]}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)(e.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,a.jsxs)(e.table,{children:[(0,a.jsx)(e.thead,{children:(0,a.jsxs)(e.tr,{children:[(0,a.jsx)(e.th,{children:"table"}),(0,a.jsx)(e.th,{children:"currentValues"}),(0,a.jsx)(e.th,{children:"current values"})]})}),(0,a.jsxs)(e.tbody,{children:[(0,a.jsxs)(e.tr,{children:[(0,a.jsx)(e.td,{children:"table"}),(0,a.jsx)(e.td,{children:"destValues"}),(0,a.jsx)(e.td,{children:"dest values"})]}),(0,a.jsxs)(e.tr,{children:[(0,a.jsx)(e.td,{children:"table"}),(0,a.jsx)(e.td,{children:"speeds"}),(0,a.jsx)(e.td,{children:"speeds"})]}),(0,a.jsxs)(e.tr,{children:[(0,a.jsx)(e.td,{children:"float"}),(0,a.jsx)(e.td,{children:"dt"}),(0,a.jsx)(e.td,{children:"time since last call in ms"})]})]})]}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)(e.strong,{children:"Code"})}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-lua",children:"function AnimatedVehicle.setMovedLimitedValues3(currentValues, destValues, speeds, dt)\n    return AnimatedVehicle.setMovedLimitedValuesN( 3 , currentValues, destValues, speeds, dt)\nend\n\n"})}),"\n",(0,a.jsx)(e.h3,{id:"setmovedlimitedvalues4",children:"setMovedLimitedValues4"}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)(e.strong,{children:"Description"})}),"\n",(0,a.jsxs)(e.blockquote,{children:["\n",(0,a.jsx)(e.p,{children:"Sets moved limited values (4)"}),"\n"]}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)(e.strong,{children:"Definition"})}),"\n",(0,a.jsxs)(e.blockquote,{children:["\n",(0,a.jsx)(e.p,{children:"setMovedLimitedValues4(table currentValues, table destValues, table speeds, float dt)"}),"\n"]}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)(e.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,a.jsxs)(e.table,{children:[(0,a.jsx)(e.thead,{children:(0,a.jsxs)(e.tr,{children:[(0,a.jsx)(e.th,{children:"table"}),(0,a.jsx)(e.th,{children:"currentValues"}),(0,a.jsx)(e.th,{children:"current values"})]})}),(0,a.jsxs)(e.tbody,{children:[(0,a.jsxs)(e.tr,{children:[(0,a.jsx)(e.td,{children:"table"}),(0,a.jsx)(e.td,{children:"destValues"}),(0,a.jsx)(e.td,{children:"dest values"})]}),(0,a.jsxs)(e.tr,{children:[(0,a.jsx)(e.td,{children:"table"}),(0,a.jsx)(e.td,{children:"speeds"}),(0,a.jsx)(e.td,{children:"speeds"})]}),(0,a.jsxs)(e.tr,{children:[(0,a.jsx)(e.td,{children:"float"}),(0,a.jsx)(e.td,{children:"dt"}),(0,a.jsx)(e.td,{children:"time since last call in ms"})]})]})]}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)(e.strong,{children:"Code"})}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-lua",children:"function AnimatedVehicle.setMovedLimitedValues4(currentValues, destValues, speeds, dt)\n    return AnimatedVehicle.setMovedLimitedValuesN( 4 , currentValues, destValues, speeds, dt)\nend\n\n"})}),"\n",(0,a.jsx)(e.h3,{id:"setmovedlimitedvaluesn",children:"setMovedLimitedValuesN"}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)(e.strong,{children:"Description"})}),"\n",(0,a.jsxs)(e.blockquote,{children:["\n",(0,a.jsx)(e.p,{children:"Sets moved limited values on N values"}),"\n"]}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)(e.strong,{children:"Definition"})}),"\n",(0,a.jsxs)(e.blockquote,{children:["\n",(0,a.jsx)(e.p,{children:"setMovedLimitedValuesN(integer n, table currentValues, table destValues, table speeds, float dt)"}),"\n"]}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)(e.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,a.jsxs)(e.table,{children:[(0,a.jsx)(e.thead,{children:(0,a.jsxs)(e.tr,{children:[(0,a.jsx)(e.th,{children:"integer"}),(0,a.jsx)(e.th,{children:"n"}),(0,a.jsx)(e.th,{children:"number of values"})]})}),(0,a.jsxs)(e.tbody,{children:[(0,a.jsxs)(e.tr,{children:[(0,a.jsx)(e.td,{children:"table"}),(0,a.jsx)(e.td,{children:"currentValues"}),(0,a.jsx)(e.td,{children:"current values"})]}),(0,a.jsxs)(e.tr,{children:[(0,a.jsx)(e.td,{children:"table"}),(0,a.jsx)(e.td,{children:"destValues"}),(0,a.jsx)(e.td,{children:"dest values"})]}),(0,a.jsxs)(e.tr,{children:[(0,a.jsx)(e.td,{children:"table"}),(0,a.jsx)(e.td,{children:"speeds"}),(0,a.jsx)(e.td,{children:"speeds"})]}),(0,a.jsxs)(e.tr,{children:[(0,a.jsx)(e.td,{children:"float"}),(0,a.jsx)(e.td,{children:"dt"}),(0,a.jsx)(e.td,{children:"time since last call in ms"})]})]})]}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)(e.strong,{children:"Code"})}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-lua",children:"function AnimatedVehicle.setMovedLimitedValuesN(n, currentValues, destValues, speeds, dt)\n    local hasChanged = false\n    for i = 1 , n do\n        local newValue = AnimatedVehicle.getMovedLimitedValue(currentValues[i], destValues[i], speeds[i], dt)\n        if currentValues[i] ~ = newValue then\n            hasChanged = true\n            currentValues[i] = newValue\n        end\n    end\n    return hasChanged\nend\n\n"})}),"\n",(0,a.jsx)(e.h3,{id:"setrealanimationtime",children:"setRealAnimationTime"}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)(e.strong,{children:"Description"})}),"\n",(0,a.jsxs)(e.blockquote,{children:["\n",(0,a.jsx)(e.p,{children:"Set animation real time"}),"\n"]}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)(e.strong,{children:"Definition"})}),"\n",(0,a.jsxs)(e.blockquote,{children:["\n",(0,a.jsx)(e.p,{children:"setRealAnimationTime(string name, float animTime, boolean update, )"}),"\n"]}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)(e.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,a.jsxs)(e.table,{children:[(0,a.jsx)(e.thead,{children:(0,a.jsxs)(e.tr,{children:[(0,a.jsx)(e.th,{children:"string"}),(0,a.jsx)(e.th,{children:"name"}),(0,a.jsx)(e.th,{children:"name of animation"})]})}),(0,a.jsxs)(e.tbody,{children:[(0,a.jsxs)(e.tr,{children:[(0,a.jsx)(e.td,{children:"float"}),(0,a.jsx)(e.td,{children:"animTime"}),(0,a.jsx)(e.td,{children:"real animation time in ms"})]}),(0,a.jsxs)(e.tr,{children:[(0,a.jsx)(e.td,{children:"boolean"}),(0,a.jsx)(e.td,{children:"update"}),(0,a.jsx)(e.td,{children:"update animation"})]}),(0,a.jsxs)(e.tr,{children:[(0,a.jsx)(e.td,{children:"any"}),(0,a.jsx)(e.td,{children:"playSounds"}),(0,a.jsx)(e.td,{})]})]})]}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)(e.strong,{children:"Code"})}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-lua",children:"function AnimatedVehicle:setRealAnimationTime(name, animTime, update, playSounds)\n    local spec = self.spec_animatedVehicle\n\n    local animation = spec.animations[name]\n    if animation ~ = nil then\n        if update = = nil or update then\n            local currentSpeed = animation.currentSpeed\n            animation.currentSpeed = 1\n            if animation.currentTime > animTime then\n                animation.currentSpeed = - 1\n            end\n\n            self:resetAnimationValues(animation)\n\n            local dtToUse, _ = AnimatedVehicle.updateAnimationCurrentTime( self , animation, 99999999 , animTime)\n            AnimatedVehicle.updateAnimation( self , animation, dtToUse, true , true , playSounds)\n            animation.currentSpeed = currentSpeed\n        else\n                animation.currentTime = animTime\n            end\n        end\n    end\n\n"})}),"\n",(0,a.jsx)(e.h3,{id:"stopanimation",children:"stopAnimation"}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)(e.strong,{children:"Description"})}),"\n",(0,a.jsxs)(e.blockquote,{children:["\n",(0,a.jsx)(e.p,{children:"Stop animation"}),"\n"]}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)(e.strong,{children:"Definition"})}),"\n",(0,a.jsxs)(e.blockquote,{children:["\n",(0,a.jsx)(e.p,{children:"stopAnimation(string name, boolean noEventSend)"}),"\n"]}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)(e.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,a.jsxs)(e.table,{children:[(0,a.jsx)(e.thead,{children:(0,a.jsxs)(e.tr,{children:[(0,a.jsx)(e.th,{children:"string"}),(0,a.jsx)(e.th,{children:"name"}),(0,a.jsx)(e.th,{children:"name of animation"})]})}),(0,a.jsx)(e.tbody,{children:(0,a.jsxs)(e.tr,{children:[(0,a.jsx)(e.td,{children:"boolean"}),(0,a.jsx)(e.td,{children:"noEventSend"}),(0,a.jsx)(e.td,{children:"no event send"})]})})]}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)(e.strong,{children:"Code"})}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-lua",children:'function AnimatedVehicle:stopAnimation(name, noEventSend)\n    local spec = self.spec_animatedVehicle\n\n    if noEventSend = = nil or noEventSend = = false then\n        if g_server ~ = nil then\n            g_server:broadcastEvent( AnimatedVehicleStopEvent.new( self , name), nil , nil , self )\n        else\n                g_client:getServerConnection():sendEvent( AnimatedVehicleStopEvent.new( self , name))\n            end\n        end\n        local animation = spec.animations[name]\n        if animation ~ = nil then\n            SpecializationUtil.raiseEvent( self , "onStopAnimation" , name)\n            animation.stopTime = nil\n\n            if self.isClient then\n                for i = 1 , #animation.samples do\n                    local sample = animation.samples[i]\n                    if sample.loops = = 0 then\n                        g_soundManager:stopSample(sample)\n                    end\n                end\n            end\n        end\n\n        if table.hasElement(spec.activeAnimations, animation) then\n            table.removeElement(spec.activeAnimations, animation)\n            spec.numActiveAnimations = spec.numActiveAnimations - 1\n            SpecializationUtil.raiseEvent( self , "onFinishAnimation" , name)\n        end\n    end\n\n'})}),"\n",(0,a.jsx)(e.h3,{id:"updateanimation",children:"updateAnimation"}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)(e.strong,{children:"Description"})}),"\n",(0,a.jsxs)(e.blockquote,{children:["\n",(0,a.jsx)(e.p,{children:"Update animation"}),"\n"]}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)(e.strong,{children:"Definition"})}),"\n",(0,a.jsxs)(e.blockquote,{children:["\n",(0,a.jsx)(e.p,{children:"updateAnimation(table anim, float dtToUse, boolean stopAnimation, boolean fixedTimeUpdate, playSounds playSounds, )"}),"\n"]}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)(e.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,a.jsxs)(e.table,{children:[(0,a.jsx)(e.thead,{children:(0,a.jsxs)(e.tr,{children:[(0,a.jsx)(e.th,{children:"table"}),(0,a.jsx)(e.th,{children:"anim"}),(0,a.jsx)(e.th,{children:"animation"})]})}),(0,a.jsxs)(e.tbody,{children:[(0,a.jsxs)(e.tr,{children:[(0,a.jsx)(e.td,{children:"float"}),(0,a.jsx)(e.td,{children:"dtToUse"}),(0,a.jsx)(e.td,{children:"dt to use"})]}),(0,a.jsxs)(e.tr,{children:[(0,a.jsx)(e.td,{children:"boolean"}),(0,a.jsx)(e.td,{children:"stopAnimation"}),(0,a.jsx)(e.td,{children:"stop animation"})]}),(0,a.jsxs)(e.tr,{children:[(0,a.jsx)(e.td,{children:"boolean"}),(0,a.jsx)(e.td,{children:"fixedTimeUpdate"}),(0,a.jsx)(e.td,{children:"is a fixed time update (e.g. from setAnimationTime) -> no sound, no looping, fixed setting between start and end values"})]}),(0,a.jsxs)(e.tr,{children:[(0,a.jsx)(e.td,{children:"playSounds"}),(0,a.jsx)(e.td,{children:"playSounds"}),(0,a.jsx)(e.td,{children:"if true it still plays sounds while doing fixed time updates"})]}),(0,a.jsxs)(e.tr,{children:[(0,a.jsx)(e.td,{children:"any"}),(0,a.jsx)(e.td,{children:"playSounds"}),(0,a.jsx)(e.td,{})]})]})]}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)(e.strong,{children:"Code"})}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-lua",children:'function AnimatedVehicle.updateAnimation( self , anim, dtToUse, stopAnim, fixedTimeUpdate, playSounds)\n    local spec = self.spec_animatedVehicle\n    local isStopTimeStop = stopAnim\n\n    local numParts = #anim.parts\n    local parts = anim.parts\n    if anim.currentSpeed < 0 then\n        parts = anim.partsReverse\n    end\n\n    if dtToUse > 0 then\n        local hasChanged = false\n        local nothingToChangeYet = false\n\n        if not anim.isKeyframe then\n            for partI = anim.currentPartIndex, numParts do\n                local part = parts[partI]\n\n                local isInRange = true\n                if part.requiredAnimation ~ = nil then\n                    local time = self:getAnimationTime(part.requiredAnimation)\n                    if time < part.requiredAnimationRange[ 1 ] or time > part.requiredAnimationRange[ 2 ] then\n                        isInRange = false\n                    end\n                end\n\n                local sameConfiguration = true\n                if part.requiredConfigurationName ~ = nil then\n                    if self.configurations[part.requiredConfigurationName] ~ = nil then\n                        if self.configurations[part.requiredConfigurationName] ~ = part.requiredConfigurationIndex then\n                            sameConfiguration = false\n                        end\n                    end\n                end\n\n                if (part.direction = = 0 or((part.direction > 0 ) = = (anim.currentSpeed > = 0 ))) and isInRange and sameConfiguration then\n                    local durationToEnd = AnimatedVehicle.getDurationToEndOfPart(part, anim)\n\n                    -- is this part not playing yet?\n                    if durationToEnd > part.duration then\n                        nothingToChangeYet = true\n                        break\n                    end\n\n                    local realDt = dtToUse\n\n                    if anim.currentSpeed > 0 then\n                        local startT = anim.currentTime - dtToUse\n                        if startT < part.startTime then\n                            realDt = dtToUse - part.startTime + startT\n                        end\n                    else\n                            local startT = anim.currentTime + dtToUse\n                            local endTime = part.startTime + part.duration\n                            if startT > endTime then\n                                realDt = dtToUse - (startT - endTime)\n                            end\n                        end\n\n                        durationToEnd = durationToEnd + realDt\n\n                        if self:updateAnimationPart(anim, part, durationToEnd, dtToUse, realDt, fixedTimeUpdate) then\n                            hasChanged = true\n                        end\n                    end\n\n                    if partI = = anim.currentPartIndex then\n                        -- is this part finished?\n                        if (anim.currentSpeed > 0 and part.startTime + part.duration < anim.currentTime) or\n                            (anim.currentSpeed < = 0 and part.startTime > anim.currentTime)\n                            then\n                            self:resetAnimationPartValues(part)\n                            anim.currentPartIndex = anim.currentPartIndex + 1\n                        end\n                    end\n                end\n                if not nothingToChangeYet and not hasChanged and anim.currentPartIndex > = numParts then\n                    -- end the animation\n                    anim.previousTime = anim.currentTime\n                    if anim.currentSpeed > 0 then\n                        anim.currentTime = anim.duration\n                    else\n                            anim.currentTime = 0\n                        end\n                        stopAnim = true\n                    end\n                else\n                        for node, curve in pairs(anim.curvesByNode) do\n                            local x, y, z, rx, ry, rz, sx, sy, sz = curve:get(anim.currentTime)\n                            if curve.hasTranslation then\n                                setTranslation(node, x, y, z)\n                            end\n                            if curve.hasRotation then\n                                setRotation(node, rx, ry, rz)\n                            end\n                            if curve.hasScale then\n                                setScale(node, sx, sy, sz)\n                            end\n\n                            SpecializationUtil.raiseEvent( self , "onAnimationPartChanged" , node)\n                        end\n\n                        stopAnim = anim.currentTime < = 0 or anim.currentTime > = anim.duration\n                    end\n\n                    if table.hasElement(spec.activeAnimations, anim) or playSounds = = true then\n                        if fixedTimeUpdate ~ = true or playSounds = = true then\n                            for i = 1 , #anim.samples do\n                                local sample = anim.samples[i]\n                                if g_soundManager:getIsSamplePlaying(sample) then\n                                    if sample.endTime ~ = nil then\n                                        if sample.startPitchScale ~ = nil then\n                                            local alpha = MathUtil.inverseLerp(sample.startTime, sample.endTime, anim.currentTime)\n                                            sample.pitchScale = (sample.endPitchScale - sample.startPitchScale) * alpha + sample.startPitchScale\n                                        end\n\n                                        if anim.currentSpeed > 0 then\n                                            if anim.currentTime > sample.endTime then\n                                                g_soundManager:stopSample(sample)\n                                            end\n                                        else\n                                                if anim.currentTime < sample.startTime then\n                                                    g_soundManager:stopSample(sample)\n                                                end\n                                            end\n\n                                            -- if the direction does not match with the new animation direction, we stop the sound\n                                                if not(sample.direction = = 0 or((sample.direction > = 0 ) = = (anim.currentSpeed > = 0 ))) then\n                                                    g_soundManager:stopSample(sample)\n                                                end\n                                            end\n                                        else\n                                                if sample.direction = = 0 or((sample.direction > = 0 ) = = (anim.currentSpeed > = 0 )) then\n                                                    if sample.loops ~ = 0 then\n                                                        if sample.endTime ~ = nil then\n                                                            sample.readyToStart = anim.previousTime < sample.startTime or anim.previousTime > sample.endTime\n                                                        else\n                                                                if anim.currentSpeed < 0 then\n                                                                    sample.readyToStart = anim.previousTime > sample.startTime\n\n                                                                else\n                                                                        sample.readyToStart = anim.previousTime < sample.startTime\n                                                                    end\n                                                                end\n                                                            else\n                                                                    sample.readyToStart = true\n                                                                end\n\n                                                                local inRange = anim.currentTime > = sample.startTime\n                                                                if sample.endTime ~ = nil then\n                                                                    inRange = anim.currentTime > = sample.startTime and anim.currentTime < = sample.endTime\n                                                                else\n                                                                        if anim.currentSpeed < 0 then\n                                                                            inRange = anim.currentTime < = sample.startTime\n                                                                        end\n                                                                    end\n\n                                                                    if sample.readyToStart and inRange then\n                                                                        g_soundManager:playSample(sample)\n                                                                    end\n                                                                end\n                                                            end\n                                                        end\n                                                    end\n\n                                                    SpecializationUtil.raiseEvent( self , "onUpdateAnimation" , anim.name)\n\n                                                    if not table.hasElement(spec.activeAnimations, anim) then\n                                                        spec.fixedTimeSamplesDirtyDelay = 2\n                                                    end\n                                                end\n                                            end\n                                            if stopAnim or(numParts > 0 and(anim.currentPartIndex > numParts or anim.currentPartIndex < 1 )) then\n                                                anim.previousTime = anim.currentTime\n                                                if not stopAnim then\n                                                    if anim.currentSpeed > 0 then\n                                                        anim.currentTime = anim.duration\n                                                    else\n                                                            anim.currentTime = 0\n                                                        end\n                                                    end\n                                                    anim.currentTime = math.min( math.max(anim.currentTime, 0 ), anim.duration)\n                                                    local allowLooping = anim.stopTime ~ = anim.currentTime\n                                                    anim.stopTime = nil\n                                                    if table.hasElement(spec.activeAnimations, anim) then\n                                                        if self.isClient then\n                                                            for i = 1 , #anim.samples do\n                                                                local sample = anim.samples[i]\n                                                                if sample.loops = = 0 then\n                                                                    g_soundManager:stopSample(sample)\n                                                                end\n                                                            end\n\n                                                            if isStopTimeStop and anim.eventSamples ~ = nil then\n                                                                if anim.currentSpeed > 0 then\n                                                                    if anim.eventSamples.stopTimePos ~ = nil then\n                                                                        for i = 1 , #anim.eventSamples.stopTimePos do\n                                                                            g_soundManager:playSample(anim.eventSamples.stopTimePos[i])\n                                                                        end\n                                                                    end\n                                                                else\n                                                                        if anim.eventSamples.stopTimeNeg ~ = nil then\n                                                                            for i = 1 , #anim.eventSamples.stopTimeNeg do\n                                                                                g_soundManager:playSample(anim.eventSamples.stopTimeNeg[i])\n                                                                            end\n                                                                        end\n                                                                    end\n                                                                end\n                                                            end\n\n                                                            table.removeElement(spec.activeAnimations, anim)\n                                                            spec.numActiveAnimations = spec.numActiveAnimations - 1\n                                                            SpecializationUtil.raiseEvent( self , "onFinishAnimation" , anim.name)\n                                                        end\n\n                                                        if allowLooping and fixedTimeUpdate ~ = true then\n                                                            if anim.looping then\n                                                                -- restart animation\n                                                                self:setAnimationTime(anim.name, math.abs((anim.currentTime / math.max(anim.duration, 0.0001 )) - 1 ), true )\n                                                                self:playAnimation(anim.name, anim.currentSpeed, nil , true )\n                                                            end\n                                                        end\n                                                    end\n                                                end\n\n'})}),"\n",(0,a.jsx)(e.h3,{id:"updateanimationbyname",children:"updateAnimationByName"}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)(e.strong,{children:"Description"})}),"\n",(0,a.jsxs)(e.blockquote,{children:["\n",(0,a.jsx)(e.p,{children:"Update animation by name"}),"\n"]}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)(e.strong,{children:"Definition"})}),"\n",(0,a.jsxs)(e.blockquote,{children:["\n",(0,a.jsx)(e.p,{children:"updateAnimationByName(string animName, float dt, , )"}),"\n"]}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)(e.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,a.jsxs)(e.table,{children:[(0,a.jsx)(e.thead,{children:(0,a.jsxs)(e.tr,{children:[(0,a.jsx)(e.th,{children:"string"}),(0,a.jsx)(e.th,{children:"animName"}),(0,a.jsx)(e.th,{children:"name of animation to update"})]})}),(0,a.jsxs)(e.tbody,{children:[(0,a.jsxs)(e.tr,{children:[(0,a.jsx)(e.td,{children:"float"}),(0,a.jsx)(e.td,{children:"dt"}),(0,a.jsx)(e.td,{children:"time since last call in ms"})]}),(0,a.jsxs)(e.tr,{children:[(0,a.jsx)(e.td,{children:"any"}),(0,a.jsx)(e.td,{children:"dt"}),(0,a.jsx)(e.td,{})]}),(0,a.jsxs)(e.tr,{children:[(0,a.jsx)(e.td,{children:"any"}),(0,a.jsx)(e.td,{children:"fixedTimeUpdate"}),(0,a.jsx)(e.td,{})]})]})]}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)(e.strong,{children:"Code"})}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-lua",children:"function AnimatedVehicle.updateAnimationByName( self , animName, dt, fixedTimeUpdate)\n    local spec = self.spec_animatedVehicle\n\n    local anim = spec.animations[animName]\n    if anim ~ = nil then\n        local dtToUse, stopAnim = AnimatedVehicle.updateAnimationCurrentTime( self , anim, dt, anim.stopTime)\n        AnimatedVehicle.updateAnimation( self , anim, dtToUse, stopAnim, fixedTimeUpdate)\n    end\nend\n\n"})}),"\n",(0,a.jsx)(e.h3,{id:"updateanimationcurrenttime",children:"updateAnimationCurrentTime"}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)(e.strong,{children:"Description"})}),"\n",(0,a.jsxs)(e.blockquote,{children:["\n",(0,a.jsx)(e.p,{children:"Update current animation time"}),"\n"]}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)(e.strong,{children:"Definition"})}),"\n",(0,a.jsxs)(e.blockquote,{children:["\n",(0,a.jsx)(e.p,{children:"updateAnimationCurrentTime(table anim, float dt, float stopTime, )"}),"\n"]}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)(e.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,a.jsxs)(e.table,{children:[(0,a.jsx)(e.thead,{children:(0,a.jsxs)(e.tr,{children:[(0,a.jsx)(e.th,{children:"table"}),(0,a.jsx)(e.th,{children:"anim"}),(0,a.jsx)(e.th,{children:"animation"})]})}),(0,a.jsxs)(e.tbody,{children:[(0,a.jsxs)(e.tr,{children:[(0,a.jsx)(e.td,{children:"float"}),(0,a.jsx)(e.td,{children:"dt"}),(0,a.jsx)(e.td,{children:"time since last call in ms"})]}),(0,a.jsxs)(e.tr,{children:[(0,a.jsx)(e.td,{children:"float"}),(0,a.jsx)(e.td,{children:"stopTime"}),(0,a.jsx)(e.td,{children:"stop time"})]}),(0,a.jsxs)(e.tr,{children:[(0,a.jsx)(e.td,{children:"any"}),(0,a.jsx)(e.td,{children:"stopTime"}),(0,a.jsx)(e.td,{})]})]})]}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)(e.strong,{children:"Return Values"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,a.jsxs)(e.table,{children:[(0,a.jsx)(e.thead,{children:(0,a.jsxs)(e.tr,{children:[(0,a.jsx)(e.th,{children:"any"}),(0,a.jsx)(e.th,{children:"dtToUse"}),(0,a.jsx)(e.th,{children:"dt to use"})]})}),(0,a.jsx)(e.tbody,{children:(0,a.jsxs)(e.tr,{children:[(0,a.jsx)(e.td,{children:"any"}),(0,a.jsx)(e.td,{children:"stopAnimation"}),(0,a.jsx)(e.td,{children:"stop animation"})]})})]}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)(e.strong,{children:"Code"})}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-lua",children:"function AnimatedVehicle.updateAnimationCurrentTime( self , anim, dt, stopTime)\n    anim.previousTime = anim.currentTime\n    anim.currentTime = anim.currentTime + dt * anim.currentSpeed\n\n    local absSpeed = math.abs(anim.currentSpeed)\n    local dtToUse = dt * absSpeed\n    local stopAnim = false\n    if stopTime ~ = nil then\n        if anim.currentSpeed > 0 then\n            if stopTime < = anim.currentTime then\n                dtToUse = dtToUse - (anim.currentTime - stopTime)\n                anim.currentTime = stopTime\n                stopAnim = true\n            end\n        else\n                if stopTime > = anim.currentTime then\n                    dtToUse = dtToUse - (stopTime - anim.currentTime)\n                    anim.currentTime = stopTime\n                    stopAnim = true\n                end\n            end\n        end\n        return dtToUse, stopAnim\n    end\n\n"})}),"\n",(0,a.jsx)(e.h3,{id:"updateanimationpart",children:"updateAnimationPart"}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)(e.strong,{children:"Description"})}),"\n",(0,a.jsxs)(e.blockquote,{children:["\n",(0,a.jsx)(e.p,{children:"Update animation part"}),"\n"]}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)(e.strong,{children:"Definition"})}),"\n",(0,a.jsxs)(e.blockquote,{children:["\n",(0,a.jsx)(e.p,{children:"updateAnimationPart(table anim, table part, float durationToEnd, float dtToUse, float realDt, )"}),"\n"]}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)(e.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,a.jsxs)(e.table,{children:[(0,a.jsx)(e.thead,{children:(0,a.jsxs)(e.tr,{children:[(0,a.jsx)(e.th,{children:"table"}),(0,a.jsx)(e.th,{children:"anim"}),(0,a.jsx)(e.th,{children:"animation"})]})}),(0,a.jsxs)(e.tbody,{children:[(0,a.jsxs)(e.tr,{children:[(0,a.jsx)(e.td,{children:"table"}),(0,a.jsx)(e.td,{children:"part"}),(0,a.jsx)(e.td,{children:"part"})]}),(0,a.jsxs)(e.tr,{children:[(0,a.jsx)(e.td,{children:"float"}),(0,a.jsx)(e.td,{children:"durationToEnd"}),(0,a.jsx)(e.td,{children:"duration to end"})]}),(0,a.jsxs)(e.tr,{children:[(0,a.jsx)(e.td,{children:"float"}),(0,a.jsx)(e.td,{children:"dtToUse"}),(0,a.jsx)(e.td,{children:"dt to use"})]}),(0,a.jsxs)(e.tr,{children:[(0,a.jsx)(e.td,{children:"float"}),(0,a.jsx)(e.td,{children:"realDt"}),(0,a.jsx)(e.td,{children:"real dt"})]}),(0,a.jsxs)(e.tr,{children:[(0,a.jsx)(e.td,{children:"any"}),(0,a.jsx)(e.td,{children:"fixedTimeUpdate"}),(0,a.jsx)(e.td,{})]})]})]}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)(e.strong,{children:"Code"})}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-lua",children:"function AnimatedVehicle:updateAnimationPart(animation, part, durationToEnd, dtToUse, realDt, fixedTimeUpdate)\n    local hasPartChanged = false\n\n    for index = 1 , #part.animationValues do\n        local valueChanged = part.animationValues[index]:update(durationToEnd, dtToUse, realDt, fixedTimeUpdate)\n        hasPartChanged = hasPartChanged or valueChanged\n    end\n\n    return hasPartChanged\nend\n\n"})}),"\n",(0,a.jsx)(e.h3,{id:"updateanimations",children:"updateAnimations"}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)(e.strong,{children:"Description"})}),"\n",(0,a.jsxs)(e.blockquote,{children:["\n",(0,a.jsx)(e.p,{children:"Update animations"}),"\n"]}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)(e.strong,{children:"Definition"})}),"\n",(0,a.jsxs)(e.blockquote,{children:["\n",(0,a.jsx)(e.p,{children:"updateAnimations(float dt, , )"}),"\n"]}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)(e.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,a.jsxs)(e.table,{children:[(0,a.jsx)(e.thead,{children:(0,a.jsxs)(e.tr,{children:[(0,a.jsx)(e.th,{children:"float"}),(0,a.jsx)(e.th,{children:"dt"}),(0,a.jsx)(e.th,{children:"time since last call in ms"})]})}),(0,a.jsxs)(e.tbody,{children:[(0,a.jsxs)(e.tr,{children:[(0,a.jsx)(e.td,{children:"any"}),(0,a.jsx)(e.td,{children:"dt"}),(0,a.jsx)(e.td,{})]}),(0,a.jsxs)(e.tr,{children:[(0,a.jsx)(e.td,{children:"any"}),(0,a.jsx)(e.td,{children:"fixedTimeUpdate"}),(0,a.jsx)(e.td,{})]})]})]}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)(e.strong,{children:"Code"})}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-lua",children:"function AnimatedVehicle.updateAnimations( self , dt, fixedTimeUpdate)\n    local spec = self.spec_animatedVehicle\n\n    for i = #spec.activeAnimations, 1 , - 1 do\n        local animation = spec.activeAnimations[i]\n\n        local dtToUse, stopAnim = AnimatedVehicle.updateAnimationCurrentTime( self , animation, dt, animation.stopTime)\n        AnimatedVehicle.updateAnimation( self , animation, dtToUse, stopAnim, fixedTimeUpdate)\n    end\nend\n\n"})})]})}function m(n={}){const{wrapper:e}={...(0,r.R)(),...n.components};return e?(0,a.jsx)(e,{...n,children:(0,a.jsx)(c,{...n})}):c(n)}}}]);