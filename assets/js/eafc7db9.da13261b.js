"use strict";(globalThis.webpackChunkfs25_community_luadoc=globalThis.webpackChunkfs25_community_luadoc||[]).push([[14230],{28453(n,e,s){s.d(e,{R:()=>o,x:()=>r});var t=s(96540);const l={},i=t.createContext(l);function o(n){const e=t.useContext(i);return t.useMemo(function(){return"function"==typeof n?n(e):{...e,...n}},[e,n])}function r(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(l):n.components||l:o(n.components),t.createElement(i.Provider,{value:e},n.children)}},47195(n,e,s){s.r(e),s.d(e,{assets:()=>c,contentTitle:()=>r,default:()=>h,frontMatter:()=>o,metadata:()=>t,toc:()=>a});const t=JSON.parse('{"id":"script/GUI/IngameMapElement","title":"IngameMapElement","description":"IngameMapElement","source":"@site/../docs/script/GUI/IngameMapElement.md","sourceDirName":"script/GUI","slug":"/script/GUI/IngameMapElement","permalink":"/FS25-Community-LUADOC/script/GUI/IngameMapElement","draft":false,"unlisted":false,"tags":[],"version":"current","lastUpdatedAt":1767161192000,"frontMatter":{},"sidebar":"docsSidebar","previous":{"title":"IngameMap","permalink":"/FS25-Community-LUADOC/script/GUI/IngameMap"},"next":{"title":"IngameMapMobile","permalink":"/FS25-Community-LUADOC/script/GUI/IngameMapMobile"}}');var l=s(74848),i=s(28453);const o={},r=void 0,c={},a=[{value:"IngameMapElement",id:"ingamemapelement",level:2},{value:"addCursorDeadzone",id:"addcursordeadzone",level:3},{value:"checkAndResetMouse",id:"checkandresetmouse",level:3},{value:"clearCursorDeadzones",id:"clearcursordeadzones",level:3},{value:"copyAttributes",id:"copyattributes",level:3},{value:"delete",id:"delete",level:3},{value:"draw",id:"draw",level:3},{value:"getLocalPointerTarget",id:"getlocalpointertarget",level:3},{value:"getLocalPosition",id:"getlocalposition",level:3},{value:"isInputInDeadzones",id:"isinputindeadzones",level:3},{value:"isPointVisible",id:"ispointvisible",level:3},{value:"loadFromXML",id:"loadfromxml",level:3},{value:"loadProfile",id:"loadprofile",level:3},{value:"localToWorldPos",id:"localtoworldpos",level:3},{value:"mouseEvent",id:"mouseevent",level:3},{value:"moveCenter",id:"movecenter",level:3},{value:"new",id:"new",level:3},{value:"onAccept",id:"onaccept",level:3},{value:"onClickMap",id:"onclickmap",level:3},{value:"onClose",id:"onclose",level:3},{value:"onGuiSetupFinished",id:"onguisetupfinished",level:3},{value:"onHorizontalCursorInput",id:"onhorizontalcursorinput",level:3},{value:"onOpen",id:"onopen",level:3},{value:"onPinchEvent",id:"onpinchevent",level:3},{value:"onVerticalCursorInput",id:"onverticalcursorinput",level:3},{value:"onZoomInput",id:"onzoominput",level:3},{value:"panToHotspot",id:"pantohotspot",level:3},{value:"registerActionEvents",id:"registeractionevents",level:3},{value:"removeActionEvents",id:"removeactionevents",level:3},{value:"reset",id:"reset",level:3},{value:"resetFrameInputState",id:"resetframeinputstate",level:3},{value:"selectHotspotAt",id:"selecthotspotat",level:3},{value:"selectHotspotFrom",id:"selecthotspotfrom",level:3},{value:"setIngameMap",id:"setingamemap",level:3},{value:"setTerrainSize",id:"setterrainsize",level:3},{value:"touchEvent",id:"touchevent",level:3},{value:"update",id:"update",level:3},{value:"updateCursor",id:"updatecursor",level:3},{value:"zoom",id:"zoom",level:3}];function d(n){const e={a:"a",blockquote:"blockquote",code:"code",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,i.R)(),...n.components};return(0,l.jsxs)(l.Fragment,{children:[(0,l.jsx)(e.h2,{id:"ingamemapelement",children:"IngameMapElement"}),"\n",(0,l.jsx)(e.p,{children:(0,l.jsx)(e.strong,{children:"Description"})}),"\n",(0,l.jsxs)(e.blockquote,{children:["\n",(0,l.jsx)(e.p,{children:"In-game map element.\nControls input on the map in the in-game menu with objectives, vehicles, etc. The actual map rendering is deferred to\nthe map component of the current mission. The map reference and terrain size must be set during mission\ninitialization via the setIngameMap() and setTerrainSize() methods."}),"\n"]}),"\n",(0,l.jsx)(e.p,{children:(0,l.jsx)(e.strong,{children:"Parent"})}),"\n",(0,l.jsxs)(e.blockquote,{children:["\n",(0,l.jsx)(e.p,{children:(0,l.jsx)(e.a,{href:"?version=script&category=43&class=466",children:"GuiElement"})}),"\n"]}),"\n",(0,l.jsx)(e.p,{children:(0,l.jsx)(e.strong,{children:"Functions"})}),"\n",(0,l.jsxs)(e.ul,{children:["\n",(0,l.jsx)(e.li,{children:(0,l.jsx)(e.a,{href:"#addcursordeadzone",children:"addCursorDeadzone"})}),"\n",(0,l.jsx)(e.li,{children:(0,l.jsx)(e.a,{href:"#checkandresetmouse",children:"checkAndResetMouse"})}),"\n",(0,l.jsx)(e.li,{children:(0,l.jsx)(e.a,{href:"#clearcursordeadzones",children:"clearCursorDeadzones"})}),"\n",(0,l.jsx)(e.li,{children:(0,l.jsx)(e.a,{href:"#copyattributes",children:"copyAttributes"})}),"\n",(0,l.jsx)(e.li,{children:(0,l.jsx)(e.a,{href:"#delete",children:"delete"})}),"\n",(0,l.jsx)(e.li,{children:(0,l.jsx)(e.a,{href:"#draw",children:"draw"})}),"\n",(0,l.jsx)(e.li,{children:(0,l.jsx)(e.a,{href:"#getlocalpointertarget",children:"getLocalPointerTarget"})}),"\n",(0,l.jsx)(e.li,{children:(0,l.jsx)(e.a,{href:"#getlocalposition",children:"getLocalPosition"})}),"\n",(0,l.jsx)(e.li,{children:(0,l.jsx)(e.a,{href:"#isinputindeadzones",children:"isInputInDeadzones"})}),"\n",(0,l.jsx)(e.li,{children:(0,l.jsx)(e.a,{href:"#ispointvisible",children:"isPointVisible"})}),"\n",(0,l.jsx)(e.li,{children:(0,l.jsx)(e.a,{href:"#loadfromxml",children:"loadFromXML"})}),"\n",(0,l.jsx)(e.li,{children:(0,l.jsx)(e.a,{href:"#loadprofile",children:"loadProfile"})}),"\n",(0,l.jsx)(e.li,{children:(0,l.jsx)(e.a,{href:"#localtoworldpos",children:"localToWorldPos"})}),"\n",(0,l.jsx)(e.li,{children:(0,l.jsx)(e.a,{href:"#mouseevent",children:"mouseEvent"})}),"\n",(0,l.jsx)(e.li,{children:(0,l.jsx)(e.a,{href:"#movecenter",children:"moveCenter"})}),"\n",(0,l.jsx)(e.li,{children:(0,l.jsx)(e.a,{href:"#new",children:"new"})}),"\n",(0,l.jsx)(e.li,{children:(0,l.jsx)(e.a,{href:"#onaccept",children:"onAccept"})}),"\n",(0,l.jsx)(e.li,{children:(0,l.jsx)(e.a,{href:"#onclickmap",children:"onClickMap"})}),"\n",(0,l.jsx)(e.li,{children:(0,l.jsx)(e.a,{href:"#onclose",children:"onClose"})}),"\n",(0,l.jsx)(e.li,{children:(0,l.jsx)(e.a,{href:"#onguisetupfinished",children:"onGuiSetupFinished"})}),"\n",(0,l.jsx)(e.li,{children:(0,l.jsx)(e.a,{href:"#onhorizontalcursorinput",children:"onHorizontalCursorInput"})}),"\n",(0,l.jsx)(e.li,{children:(0,l.jsx)(e.a,{href:"#onopen",children:"onOpen"})}),"\n",(0,l.jsx)(e.li,{children:(0,l.jsx)(e.a,{href:"#onpinchevent",children:"onPinchEvent"})}),"\n",(0,l.jsx)(e.li,{children:(0,l.jsx)(e.a,{href:"#onverticalcursorinput",children:"onVerticalCursorInput"})}),"\n",(0,l.jsx)(e.li,{children:(0,l.jsx)(e.a,{href:"#onzoominput",children:"onZoomInput"})}),"\n",(0,l.jsx)(e.li,{children:(0,l.jsx)(e.a,{href:"#pantohotspot",children:"panToHotspot"})}),"\n",(0,l.jsx)(e.li,{children:(0,l.jsx)(e.a,{href:"#registeractionevents",children:"registerActionEvents"})}),"\n",(0,l.jsx)(e.li,{children:(0,l.jsx)(e.a,{href:"#removeactionevents",children:"removeActionEvents"})}),"\n",(0,l.jsx)(e.li,{children:(0,l.jsx)(e.a,{href:"#reset",children:"reset"})}),"\n",(0,l.jsx)(e.li,{children:(0,l.jsx)(e.a,{href:"#resetframeinputstate",children:"resetFrameInputState"})}),"\n",(0,l.jsx)(e.li,{children:(0,l.jsx)(e.a,{href:"#selecthotspotat",children:"selectHotspotAt"})}),"\n",(0,l.jsx)(e.li,{children:(0,l.jsx)(e.a,{href:"#selecthotspotfrom",children:"selectHotspotFrom"})}),"\n",(0,l.jsx)(e.li,{children:(0,l.jsx)(e.a,{href:"#setingamemap",children:"setIngameMap"})}),"\n",(0,l.jsx)(e.li,{children:(0,l.jsx)(e.a,{href:"#setterrainsize",children:"setTerrainSize"})}),"\n",(0,l.jsx)(e.li,{children:(0,l.jsx)(e.a,{href:"#touchevent",children:"touchEvent"})}),"\n",(0,l.jsx)(e.li,{children:(0,l.jsx)(e.a,{href:"#update",children:"update"})}),"\n",(0,l.jsx)(e.li,{children:(0,l.jsx)(e.a,{href:"#updatecursor",children:"updateCursor"})}),"\n",(0,l.jsx)(e.li,{children:(0,l.jsx)(e.a,{href:"#zoom",children:"zoom"})}),"\n"]}),"\n",(0,l.jsx)(e.h3,{id:"addcursordeadzone",children:"addCursorDeadzone"}),"\n",(0,l.jsx)(e.p,{children:(0,l.jsx)(e.strong,{children:"Description"})}),"\n",(0,l.jsxs)(e.blockquote,{children:["\n",(0,l.jsx)(e.p,{children:"Add a dead zone wherein the map will not react to cursor inputs.\nUsed this to designate areas where other controls should receive cursor input which would otherwise be used up by\nthe map (e.g. in full-screen mode in the map overview screen in-game). The deadzones will also restrict cursor\nmovement."}),"\n"]}),"\n",(0,l.jsx)(e.p,{children:(0,l.jsx)(e.strong,{children:"Definition"})}),"\n",(0,l.jsxs)(e.blockquote,{children:["\n",(0,l.jsx)(e.p,{children:"addCursorDeadzone()"}),"\n"]}),"\n",(0,l.jsx)(e.p,{children:(0,l.jsx)(e.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,l.jsxs)(e.table,{children:[(0,l.jsx)(e.thead,{children:(0,l.jsxs)(e.tr,{children:[(0,l.jsx)(e.th,{children:"any"}),(0,l.jsx)(e.th,{children:"screenX"})]})}),(0,l.jsxs)(e.tbody,{children:[(0,l.jsxs)(e.tr,{children:[(0,l.jsx)(e.td,{children:"any"}),(0,l.jsx)(e.td,{children:"screenY"})]}),(0,l.jsxs)(e.tr,{children:[(0,l.jsx)(e.td,{children:"any"}),(0,l.jsx)(e.td,{children:"width"})]}),(0,l.jsxs)(e.tr,{children:[(0,l.jsx)(e.td,{children:"any"}),(0,l.jsx)(e.td,{children:"height"})]})]})]}),"\n",(0,l.jsx)(e.p,{children:(0,l.jsx)(e.strong,{children:"Code"})}),"\n",(0,l.jsx)(e.pre,{children:(0,l.jsx)(e.code,{className:"language-lua",children:"function IngameMapElement:addCursorDeadzone(screenX, screenY, width, height)\n    table.insert( self.cursorDeadzones, { screenX, screenY, width, height } )\nend\n\n"})}),"\n",(0,l.jsx)(e.h3,{id:"checkandresetmouse",children:"checkAndResetMouse"}),"\n",(0,l.jsx)(e.p,{children:(0,l.jsx)(e.strong,{children:"Description"})}),"\n",(0,l.jsxs)(e.blockquote,{children:["\n",(0,l.jsx)(e.p,{children:"Check if mouse input was active before a bound input was triggered and queue a reset of the mouse state for the next\nframe.\nMouse input continuously sets the mouse input flag (self.useMouse) but does not receive any events when the mouse\nis inert. Therefore we need to set and reset the state each frame to make sure we can seamlessly switch between mouse\nand gamepad input on the map element while at the same time preventing any player bindings from interfering with the\ncustom mouse input logic of this class."}),"\n"]}),"\n",(0,l.jsx)(e.p,{children:(0,l.jsx)(e.strong,{children:"Definition"})}),"\n",(0,l.jsxs)(e.blockquote,{children:["\n",(0,l.jsx)(e.p,{children:"checkAndResetMouse()"}),"\n"]}),"\n",(0,l.jsx)(e.p,{children:(0,l.jsx)(e.strong,{children:"Code"})}),"\n",(0,l.jsx)(e.pre,{children:(0,l.jsx)(e.code,{className:"language-lua",children:"function IngameMapElement:checkAndResetMouse()\n    local useMouse = self.useMouse\n    if useMouse then\n        self.resetMouseNextFrame = true\n    end\n\n    return useMouse\nend\n\n"})}),"\n",(0,l.jsx)(e.h3,{id:"clearcursordeadzones",children:"clearCursorDeadzones"}),"\n",(0,l.jsx)(e.p,{children:(0,l.jsx)(e.strong,{children:"Description"})}),"\n",(0,l.jsxs)(e.blockquote,{children:["\n",(0,l.jsx)(e.p,{children:"Clear cursor dead zones."}),"\n"]}),"\n",(0,l.jsx)(e.p,{children:(0,l.jsx)(e.strong,{children:"Definition"})}),"\n",(0,l.jsxs)(e.blockquote,{children:["\n",(0,l.jsx)(e.p,{children:"clearCursorDeadzones()"}),"\n"]}),"\n",(0,l.jsx)(e.p,{children:(0,l.jsx)(e.strong,{children:"Code"})}),"\n",(0,l.jsx)(e.pre,{children:(0,l.jsx)(e.code,{className:"language-lua",children:"function IngameMapElement:clearCursorDeadzones()\n    self.cursorDeadzones = { }\nend\n\n"})}),"\n",(0,l.jsx)(e.h3,{id:"copyattributes",children:"copyAttributes"}),"\n",(0,l.jsx)(e.p,{children:(0,l.jsx)(e.strong,{children:"Description"})}),"\n",(0,l.jsx)(e.p,{children:(0,l.jsx)(e.strong,{children:"Definition"})}),"\n",(0,l.jsxs)(e.blockquote,{children:["\n",(0,l.jsx)(e.p,{children:"copyAttributes()"}),"\n"]}),"\n",(0,l.jsx)(e.p,{children:(0,l.jsx)(e.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,l.jsx)(e.table,{children:(0,l.jsx)(e.thead,{children:(0,l.jsxs)(e.tr,{children:[(0,l.jsx)(e.th,{children:"any"}),(0,l.jsx)(e.th,{children:"src"})]})})}),"\n",(0,l.jsx)(e.p,{children:(0,l.jsx)(e.strong,{children:"Code"})}),"\n",(0,l.jsx)(e.pre,{children:(0,l.jsx)(e.code,{className:"language-lua",children:"function IngameMapElement:copyAttributes(src)\n    IngameMapElement:superClass().copyAttributes( self , src)\n\n    self.mapZoom = src.mapZoom\n    self.mapAlpha = src.mapAlpha\n    self.cursorId = src.cursorId\n    self.limitMapWidth = src.limitMapWidth\n    self.limitCursorMovement = src.limitCursorMovement\n    self.onDrawPreIngameMapCallback = src.onDrawPreIngameMapCallback\n    self.onDrawPostIngameMapCallback = src.onDrawPostIngameMapCallback\n    self.onDrawPostIngameMapHotspotsCallback = src.onDrawPostIngameMapHotspotsCallback\n    self.onClickHotspotCallback = src.onClickHotspotCallback\n    self.onClickMapCallback = src.onClickMapCallback\nend\n\n"})}),"\n",(0,l.jsx)(e.h3,{id:"delete",children:"delete"}),"\n",(0,l.jsx)(e.p,{children:(0,l.jsx)(e.strong,{children:"Description"})}),"\n",(0,l.jsx)(e.p,{children:(0,l.jsx)(e.strong,{children:"Definition"})}),"\n",(0,l.jsxs)(e.blockquote,{children:["\n",(0,l.jsx)(e.p,{children:"delete()"}),"\n"]}),"\n",(0,l.jsx)(e.p,{children:(0,l.jsx)(e.strong,{children:"Code"})}),"\n",(0,l.jsx)(e.pre,{children:(0,l.jsx)(e.code,{className:"language-lua",children:"function IngameMapElement:delete()\n    GuiOverlay.deleteOverlay( self.overlay)\n    self.ingameMap = nil\n\n    IngameMapElement:superClass().delete( self )\nend\n\n"})}),"\n",(0,l.jsx)(e.h3,{id:"draw",children:"draw"}),"\n",(0,l.jsx)(e.p,{children:(0,l.jsx)(e.strong,{children:"Description"})}),"\n",(0,l.jsx)(e.p,{children:(0,l.jsx)(e.strong,{children:"Definition"})}),"\n",(0,l.jsxs)(e.blockquote,{children:["\n",(0,l.jsx)(e.p,{children:"draw()"}),"\n"]}),"\n",(0,l.jsx)(e.p,{children:(0,l.jsx)(e.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,l.jsxs)(e.table,{children:[(0,l.jsx)(e.thead,{children:(0,l.jsxs)(e.tr,{children:[(0,l.jsx)(e.th,{children:"any"}),(0,l.jsx)(e.th,{children:"clipX1"})]})}),(0,l.jsxs)(e.tbody,{children:[(0,l.jsxs)(e.tr,{children:[(0,l.jsx)(e.td,{children:"any"}),(0,l.jsx)(e.td,{children:"clipY1"})]}),(0,l.jsxs)(e.tr,{children:[(0,l.jsx)(e.td,{children:"any"}),(0,l.jsx)(e.td,{children:"clipX2"})]}),(0,l.jsxs)(e.tr,{children:[(0,l.jsx)(e.td,{children:"any"}),(0,l.jsx)(e.td,{children:"clipY2"})]})]})]}),"\n",(0,l.jsx)(e.p,{children:(0,l.jsx)(e.strong,{children:"Code"})}),"\n",(0,l.jsx)(e.pre,{children:(0,l.jsx)(e.code,{className:"language-lua",children:'function IngameMapElement:draw(clipX1, clipY1, clipX2, clipY2)\n    self:raiseCallback( "onDrawPreIngameMapCallback" , self , self.ingameMap)\n    self.ingameMap:drawMapOnly()\n    self:raiseCallback( "onDrawPostIngameMapCallback" , self , self.ingameMap)\n\n    self.ingameMap:drawHotspotsOnly()\n\n    self:raiseCallback( "onDrawPostIngameMapHotspotsCallback" , self , self.ingameMap)\n    IngameMapElement:superClass().draw( self , clipX1, clipY1, clipX2, clipY2)\nend\n\n'})}),"\n",(0,l.jsx)(e.h3,{id:"getlocalpointertarget",children:"getLocalPointerTarget"}),"\n",(0,l.jsx)(e.p,{children:(0,l.jsx)(e.strong,{children:"Description"})}),"\n",(0,l.jsx)(e.p,{children:(0,l.jsx)(e.strong,{children:"Definition"})}),"\n",(0,l.jsxs)(e.blockquote,{children:["\n",(0,l.jsx)(e.p,{children:"getLocalPointerTarget()"}),"\n"]}),"\n",(0,l.jsx)(e.p,{children:(0,l.jsx)(e.strong,{children:"Code"})}),"\n",(0,l.jsx)(e.pre,{children:(0,l.jsx)(e.code,{className:"language-lua",children:"function IngameMapElement:getLocalPointerTarget()\n    if self.useMouse then\n        return self:getLocalPosition( self.lastInputPosX[ self.lastInputIndex], self.lastInputPosY[ self.lastInputIndex])\n    elseif self.cursorElement then\n            local posX = self.cursorElement.absPosition[ 1 ] + self.cursorElement.size[ 1 ] * 0.5\n            local posY = self.cursorElement.absPosition[ 2 ] + self.cursorElement.size[ 2 ] * 0.5\n\n            return self:getLocalPosition(posX, posY)\n        end\n\n        return 0 , 0\n    end\n\n"})}),"\n",(0,l.jsx)(e.h3,{id:"getlocalposition",children:"getLocalPosition"}),"\n",(0,l.jsx)(e.p,{children:(0,l.jsx)(e.strong,{children:"Description"})}),"\n",(0,l.jsx)(e.p,{children:(0,l.jsx)(e.strong,{children:"Definition"})}),"\n",(0,l.jsxs)(e.blockquote,{children:["\n",(0,l.jsx)(e.p,{children:"getLocalPosition()"}),"\n"]}),"\n",(0,l.jsx)(e.p,{children:(0,l.jsx)(e.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,l.jsxs)(e.table,{children:[(0,l.jsx)(e.thead,{children:(0,l.jsxs)(e.tr,{children:[(0,l.jsx)(e.th,{children:"any"}),(0,l.jsx)(e.th,{children:"posX"})]})}),(0,l.jsx)(e.tbody,{children:(0,l.jsxs)(e.tr,{children:[(0,l.jsx)(e.td,{children:"any"}),(0,l.jsx)(e.td,{children:"posY"})]})})]}),"\n",(0,l.jsx)(e.p,{children:(0,l.jsx)(e.strong,{children:"Code"})}),"\n",(0,l.jsx)(e.pre,{children:(0,l.jsx)(e.code,{className:"language-lua",children:"function IngameMapElement:getLocalPosition(posX, posY)\n    local width, height = self.ingameMap.fullScreenLayout:getMapSize()\n    local offX, offY = self.ingameMap.fullScreenLayout:getMapPosition()\n\n    -- offset with map poisition, then conver to 0-1 and adjust for minimap being doubled in size\n        -- from actual map.\n        local x, y\n\n        if Platform.isMobile then\n            x = (posX - offX) / width\n            y = (posY - offY) / height\n        else\n                x = ((posX - offX) / width - 0.25 ) * 2\n                y = ((posY - offY) / height - 0.25 ) * 2\n            end\n\n            return x, y\n        end\n\n"})}),"\n",(0,l.jsx)(e.h3,{id:"isinputindeadzones",children:"isInputInDeadzones"}),"\n",(0,l.jsx)(e.p,{children:(0,l.jsx)(e.strong,{children:"Description"})}),"\n",(0,l.jsxs)(e.blockquote,{children:["\n",(0,l.jsx)(e.p,{children:"Check if a cursor position is within one of the stored deadzones."}),"\n"]}),"\n",(0,l.jsx)(e.p,{children:(0,l.jsx)(e.strong,{children:"Definition"})}),"\n",(0,l.jsxs)(e.blockquote,{children:["\n",(0,l.jsx)(e.p,{children:"isInputInDeadzones()"}),"\n"]}),"\n",(0,l.jsx)(e.p,{children:(0,l.jsx)(e.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,l.jsxs)(e.table,{children:[(0,l.jsx)(e.thead,{children:(0,l.jsxs)(e.tr,{children:[(0,l.jsx)(e.th,{children:"any"}),(0,l.jsx)(e.th,{children:"inputScreenX"})]})}),(0,l.jsx)(e.tbody,{children:(0,l.jsxs)(e.tr,{children:[(0,l.jsx)(e.td,{children:"any"}),(0,l.jsx)(e.td,{children:"inputScreenY"})]})})]}),"\n",(0,l.jsx)(e.p,{children:(0,l.jsx)(e.strong,{children:"Code"})}),"\n",(0,l.jsx)(e.pre,{children:(0,l.jsx)(e.code,{className:"language-lua",children:"function IngameMapElement:isInputInDeadzones(inputScreenX, inputScreenY)\n    for _, zone in pairs( self.cursorDeadzones) do\n        if GuiUtils.checkOverlayOverlap(inputScreenX, inputScreenY, zone[ 1 ], zone[ 2 ], zone[ 3 ], zone[ 4 ]) then\n            return true\n        end\n    end\n\n    return false\nend\n\n"})}),"\n",(0,l.jsx)(e.h3,{id:"ispointvisible",children:"isPointVisible"}),"\n",(0,l.jsx)(e.p,{children:(0,l.jsx)(e.strong,{children:"Description"})}),"\n",(0,l.jsx)(e.p,{children:(0,l.jsx)(e.strong,{children:"Definition"})}),"\n",(0,l.jsxs)(e.blockquote,{children:["\n",(0,l.jsx)(e.p,{children:"isPointVisible()"}),"\n"]}),"\n",(0,l.jsx)(e.p,{children:(0,l.jsx)(e.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,l.jsxs)(e.table,{children:[(0,l.jsx)(e.thead,{children:(0,l.jsxs)(e.tr,{children:[(0,l.jsx)(e.th,{children:"any"}),(0,l.jsx)(e.th,{children:"x"})]})}),(0,l.jsx)(e.tbody,{children:(0,l.jsxs)(e.tr,{children:[(0,l.jsx)(e.td,{children:"any"}),(0,l.jsx)(e.td,{children:"z"})]})})]}),"\n",(0,l.jsx)(e.p,{children:(0,l.jsx)(e.strong,{children:"Code"})}),"\n",(0,l.jsx)(e.pre,{children:(0,l.jsx)(e.code,{className:"language-lua",children:"function IngameMapElement:isPointVisible(x, z)\nend\n\n"})}),"\n",(0,l.jsx)(e.h3,{id:"loadfromxml",children:"loadFromXML"}),"\n",(0,l.jsx)(e.p,{children:(0,l.jsx)(e.strong,{children:"Description"})}),"\n",(0,l.jsx)(e.p,{children:(0,l.jsx)(e.strong,{children:"Definition"})}),"\n",(0,l.jsxs)(e.blockquote,{children:["\n",(0,l.jsx)(e.p,{children:"loadFromXML()"}),"\n"]}),"\n",(0,l.jsx)(e.p,{children:(0,l.jsx)(e.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,l.jsxs)(e.table,{children:[(0,l.jsx)(e.thead,{children:(0,l.jsxs)(e.tr,{children:[(0,l.jsx)(e.th,{children:"any"}),(0,l.jsx)(e.th,{children:"xmlFile"})]})}),(0,l.jsx)(e.tbody,{children:(0,l.jsxs)(e.tr,{children:[(0,l.jsx)(e.td,{children:"any"}),(0,l.jsx)(e.td,{children:"key"})]})})]}),"\n",(0,l.jsx)(e.p,{children:(0,l.jsx)(e.strong,{children:"Code"})}),"\n",(0,l.jsx)(e.pre,{children:(0,l.jsx)(e.code,{className:"language-lua",children:'function IngameMapElement:loadFromXML(xmlFile, key)\n    IngameMapElement:superClass().loadFromXML( self , xmlFile, key)\n\n    self.cursorId = getXMLString(xmlFile, key .. "#cursorId" )\n    self.mapAlpha = getXMLFloat(xmlFile, key .. "#mapAlpha" ) or self.mapAlpha\n    self.limitMapWidth = Utils.getNoNil(getXMLBool(xmlFile, key .. "#limitMapWidth" ), self.limitMapWidth)\n    self.limitCursorMovement = Utils.getNoNil(getXMLBool(xmlFile, key .. "#limitCursorMovement" ), self.limitCursorMovement)\n\n    self:addCallback(xmlFile, key .. "#onDrawPreIngameMap" , "onDrawPreIngameMapCallback" )\n    self:addCallback(xmlFile, key .. "#onDrawPostIngameMap" , "onDrawPostIngameMapCallback" )\n    self:addCallback(xmlFile, key .. "#onDrawPostIngameMapHotspots" , "onDrawPostIngameMapHotspotsCallback" )\n    self:addCallback(xmlFile, key .. "#onClickHotspot" , "onClickHotspotCallback" )\n    self:addCallback(xmlFile, key .. "#onClickMap" , "onClickMapCallback" )\nend\n\n'})}),"\n",(0,l.jsx)(e.h3,{id:"loadprofile",children:"loadProfile"}),"\n",(0,l.jsx)(e.p,{children:(0,l.jsx)(e.strong,{children:"Description"})}),"\n",(0,l.jsx)(e.p,{children:(0,l.jsx)(e.strong,{children:"Definition"})}),"\n",(0,l.jsxs)(e.blockquote,{children:["\n",(0,l.jsx)(e.p,{children:"loadProfile()"}),"\n"]}),"\n",(0,l.jsx)(e.p,{children:(0,l.jsx)(e.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,l.jsxs)(e.table,{children:[(0,l.jsx)(e.thead,{children:(0,l.jsxs)(e.tr,{children:[(0,l.jsx)(e.th,{children:"any"}),(0,l.jsx)(e.th,{children:"profile"})]})}),(0,l.jsx)(e.tbody,{children:(0,l.jsxs)(e.tr,{children:[(0,l.jsx)(e.td,{children:"any"}),(0,l.jsx)(e.td,{children:"applyProfile"})]})})]}),"\n",(0,l.jsx)(e.p,{children:(0,l.jsx)(e.strong,{children:"Code"})}),"\n",(0,l.jsx)(e.pre,{children:(0,l.jsx)(e.code,{className:"language-lua",children:'function IngameMapElement:loadProfile(profile, applyProfile)\n    IngameMapElement:superClass().loadProfile( self , profile, applyProfile)\n\n    self.mapAlpha = profile:getNumber( "mapAlpha" , self.mapAlpha)\n    self.limitMapWidth = profile:getBool( "limitMapWidth" , self.limitMapWidth)\n    self.limitCursorMovement = profile:getBool( "limitCursorMovement" , self.limitCursorMovement)\nend\n\n'})}),"\n",(0,l.jsx)(e.h3,{id:"localtoworldpos",children:"localToWorldPos"}),"\n",(0,l.jsx)(e.p,{children:(0,l.jsx)(e.strong,{children:"Description"})}),"\n",(0,l.jsx)(e.p,{children:(0,l.jsx)(e.strong,{children:"Definition"})}),"\n",(0,l.jsxs)(e.blockquote,{children:["\n",(0,l.jsx)(e.p,{children:"localToWorldPos()"}),"\n"]}),"\n",(0,l.jsx)(e.p,{children:(0,l.jsx)(e.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,l.jsxs)(e.table,{children:[(0,l.jsx)(e.thead,{children:(0,l.jsxs)(e.tr,{children:[(0,l.jsx)(e.th,{children:"any"}),(0,l.jsx)(e.th,{children:"localPosX"})]})}),(0,l.jsx)(e.tbody,{children:(0,l.jsxs)(e.tr,{children:[(0,l.jsx)(e.td,{children:"any"}),(0,l.jsx)(e.td,{children:"localPosY"})]})})]}),"\n",(0,l.jsx)(e.p,{children:(0,l.jsx)(e.strong,{children:"Code"})}),"\n",(0,l.jsx)(e.pre,{children:(0,l.jsx)(e.code,{className:"language-lua",children:"function IngameMapElement:localToWorldPos(localPosX, localPosY)\n    local worldPosX = localPosX * self.terrainSize\n    local worldPosZ = - localPosY * self.terrainSize\n\n    -- move world positions to range -1024 to 1024 on a 2k map\n    worldPosX = worldPosX - self.terrainSize * 0.5\n    worldPosZ = worldPosZ + self.terrainSize * 0.5\n\n    return worldPosX, worldPosZ\nend\n\n"})}),"\n",(0,l.jsx)(e.h3,{id:"mouseevent",children:"mouseEvent"}),"\n",(0,l.jsx)(e.p,{children:(0,l.jsx)(e.strong,{children:"Description"})}),"\n",(0,l.jsxs)(e.blockquote,{children:["\n",(0,l.jsx)(e.p,{children:"Custom mouse event handling for the in-game map.\nDirectly handles zoom, click and drag events on the map. See input events and IngameMapElement:checkAndResetMouse()\nfor the state checking code required to bypass player mouse input bindings."}),"\n"]}),"\n",(0,l.jsx)(e.p,{children:(0,l.jsx)(e.strong,{children:"Definition"})}),"\n",(0,l.jsxs)(e.blockquote,{children:["\n",(0,l.jsx)(e.p,{children:"mouseEvent()"}),"\n"]}),"\n",(0,l.jsx)(e.p,{children:(0,l.jsx)(e.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,l.jsxs)(e.table,{children:[(0,l.jsx)(e.thead,{children:(0,l.jsxs)(e.tr,{children:[(0,l.jsx)(e.th,{children:"any"}),(0,l.jsx)(e.th,{children:"posX"})]})}),(0,l.jsxs)(e.tbody,{children:[(0,l.jsxs)(e.tr,{children:[(0,l.jsx)(e.td,{children:"any"}),(0,l.jsx)(e.td,{children:"posY"})]}),(0,l.jsxs)(e.tr,{children:[(0,l.jsx)(e.td,{children:"any"}),(0,l.jsx)(e.td,{children:"isDown"})]}),(0,l.jsxs)(e.tr,{children:[(0,l.jsx)(e.td,{children:"any"}),(0,l.jsx)(e.td,{children:"isUp"})]}),(0,l.jsxs)(e.tr,{children:[(0,l.jsx)(e.td,{children:"any"}),(0,l.jsx)(e.td,{children:"button"})]}),(0,l.jsxs)(e.tr,{children:[(0,l.jsx)(e.td,{children:"any"}),(0,l.jsx)(e.td,{children:"eventUsed"})]})]})]}),"\n",(0,l.jsx)(e.p,{children:(0,l.jsx)(e.strong,{children:"Code"})}),"\n",(0,l.jsx)(e.pre,{children:(0,l.jsx)(e.code,{className:"language-lua",children:"function IngameMapElement:mouseEvent(posX, posY, isDown, isUp, button, eventUsed)\n    if self:getIsActive() then\n        eventUsed = IngameMapElement:superClass().mouseEvent( self , posX, posY, isDown, isUp, button, eventUsed)\n        self.lastInputIndex = 0\n        local index = 0\n\n        if not GS_IS_CONSOLE_VERSION and(isDown or isUp or posX ~ = self.lastInputPosX[index] or posY ~ = self.lastInputPosY[index]) then\n            self.useMouse = true\n\n            if self.cursorElement then\n                self.cursorElement:setVisible( false )\n            end\n            self.isCursorActive = false\n        end\n\n        -- On mobile we have touch input.Touch does not give us a position until there is a touch.\n        -- This means on the first touch-begin, the lastMousePos is wrong and has a big offset.\n        -- We set it when the touch begins so it becomes a drag action\n        if Platform.isMobile and self.useMouse then\n            if isDown then\n                self.lastInputPosX[index] = posX\n                self.lastInputPosY[index] = posY\n            end\n        end\n\n        if not eventUsed then\n            if isDown and button = = Input.MOUSE_BUTTON_LEFT and not self:isInputInDeadzones(posX, posY) then\n                eventUsed = true\n                if not self.inputDown then\n                    self.inputDown = true\n                end\n            end\n        end\n\n        if self.inputDown and self.lastInputPosX[index] ~ = nil then\n            local distX = self.lastInputPosX[index] - posX\n            local distY = posY - self.lastInputPosY[index]\n\n            if self.isFixedHorizontal then\n                distX = 0\n            end\n\n            if math.abs(distX) > self.minDragDistanceX or math.abs(distY) > self.minDragDistanceY then\n                local factorX = - distX\n                local factorY = distY\n\n                self:moveCenter(factorX, factorY)\n\n                self.hasDragged = true\n            end\n        end\n\n        if isUp and button = = Input.MOUSE_BUTTON_LEFT then\n            if not eventUsed and self.inputDown and not self.hasDragged then\n                local localX, localY = self:getLocalPosition(posX, posY)\n\n                -- save state locally to avoid issues if activating/deactivating selection in the onClickMap callback\n                    local isHotspotSelectionActive = self.isHotspotSelectionActive\n\n                    self:onClickMap(localX, localY)\n\n                    if isHotspotSelectionActive then\n                        -- Trigger hot spot selection after map clicking because it's the more specific event\n                        self:selectHotspotAt(posX, posY)\n                    end\n\n                    eventUsed = true\n                end\n\n                self.inputDown = false\n                self.hasDragged = false\n            end\n\n            self.lastInputPosX[index] = posX\n            self.lastInputPosY[index] = posY\n        end\n\n        return eventUsed\n    end\n\n"})}),"\n",(0,l.jsx)(e.h3,{id:"movecenter",children:"moveCenter"}),"\n",(0,l.jsx)(e.p,{children:(0,l.jsx)(e.strong,{children:"Description"})}),"\n",(0,l.jsxs)(e.blockquote,{children:["\n",(0,l.jsx)(e.p,{children:"Move center of the map"}),"\n"]}),"\n",(0,l.jsx)(e.p,{children:(0,l.jsx)(e.strong,{children:"Definition"})}),"\n",(0,l.jsxs)(e.blockquote,{children:["\n",(0,l.jsx)(e.p,{children:"moveCenter()"}),"\n"]}),"\n",(0,l.jsx)(e.p,{children:(0,l.jsx)(e.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,l.jsxs)(e.table,{children:[(0,l.jsx)(e.thead,{children:(0,l.jsxs)(e.tr,{children:[(0,l.jsx)(e.th,{children:"any"}),(0,l.jsx)(e.th,{children:"x"})]})}),(0,l.jsx)(e.tbody,{children:(0,l.jsxs)(e.tr,{children:[(0,l.jsx)(e.td,{children:"any"}),(0,l.jsx)(e.td,{children:"y"})]})})]}),"\n",(0,l.jsx)(e.p,{children:(0,l.jsx)(e.strong,{children:"Code"})}),"\n",(0,l.jsx)(e.pre,{children:(0,l.jsx)(e.code,{className:"language-lua",children:"function IngameMapElement:moveCenter(x, y)\n    local width, height = self.ingameMap.fullScreenLayout:getMapSize()\n\n    if Platform.isMobile then\n        local maxCenterOffsetX = (width - self.ingameMap.fullScreenLayout.width) * 0.5\n        local maxCenterOffsetY = (height - 1 ) * 0.5\n\n        self.mapCenterX = math.clamp( self.mapCenterX + x, self.originalMapCenterX - maxCenterOffsetX, self.originalMapCenterX + maxCenterOffsetX)\n        self.mapCenterY = math.clamp( self.mapCenterY + y, self.originalMapCenterY - maxCenterOffsetY, self.originalMapCenterY + maxCenterOffsetY)\n    else\n            self.mapCenterX = math.clamp( self.mapCenterX + x, width * - 0.5 + self.originalMapCenterX, width * 0.5 + self.originalMapCenterX)\n\n            if self.limitCursorMovement then\n                local minValue = ( self.absPosition[ 2 ] + self.absSize[ 2 ]) - height * 0.5\n                local maxValue = self.absPosition[ 2 ] + height * 0.5\n                self.mapCenterY = math.clamp( self.mapCenterY + y, minValue, maxValue)\n            else\n                    self.mapCenterY = math.clamp( self.mapCenterY + y, height * - 0.5 + self.originalMapCenterY, height * 0.5 + self.originalMapCenterY)\n                end\n            end\n\n            self.ingameMap.fullScreenLayout:setMapCenter( self.mapCenterX, self.mapCenterY)\n        end\n\n"})}),"\n",(0,l.jsx)(e.h3,{id:"new",children:"new"}),"\n",(0,l.jsx)(e.p,{children:(0,l.jsx)(e.strong,{children:"Description"})}),"\n",(0,l.jsx)(e.p,{children:(0,l.jsx)(e.strong,{children:"Definition"})}),"\n",(0,l.jsxs)(e.blockquote,{children:["\n",(0,l.jsx)(e.p,{children:"new()"}),"\n"]}),"\n",(0,l.jsx)(e.p,{children:(0,l.jsx)(e.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,l.jsxs)(e.table,{children:[(0,l.jsx)(e.thead,{children:(0,l.jsxs)(e.tr,{children:[(0,l.jsx)(e.th,{children:"any"}),(0,l.jsx)(e.th,{children:"target"})]})}),(0,l.jsx)(e.tbody,{children:(0,l.jsxs)(e.tr,{children:[(0,l.jsx)(e.td,{children:"any"}),(0,l.jsx)(e.td,{children:"custom_mt"})]})})]}),"\n",(0,l.jsx)(e.p,{children:(0,l.jsx)(e.strong,{children:"Code"})}),"\n",(0,l.jsx)(e.pre,{children:(0,l.jsx)(e.code,{className:"language-lua",children:"function IngameMapElement.new(target, custom_mt)\n    local self = GuiElement.new(target, custom_mt or IngameMapElement _mt)\n\n    self.ingameMap = nil\n\n    -- cursor\n    self.cursorId = nil\n\n    self.inputMode = GS_INPUT_HELP_MODE_GAMEPAD\n\n    -- map attributes\n    self.terrainSize = 0\n    self.mapAlpha = 1\n    self.zoomMin = 1\n    self.zoomMax = 8\n    self.zoomDefault = Platform.ingameMap.zoomDefault\n\n    self.mapCenterX = 0.5\n    self.mapCenterY = 0.5\n\n    self.mapZoom = self.zoomDefault\n\n    -- horizontal cursor input since last frame\n    self.accumHorizontalInput = 0\n    -- vertical cursor input since last frame\n    self.accumVerticalInput = 0\n    -- zoom input since last frame\n    self.accumZoomInput = 0\n    -- mouse input flag to override potential double binding on cursor movement\n    self.useMouse = false\n    -- reset flag for mouse input flag to avoid catching input in the current frame\n        self.resetMouseNextFrame = false\n        -- screen space rectangle definitions {x, y, w, h} where the cursor/mouse should not go and react to input\n        self.cursorDeadzones = { }\n\n        self.limitMapWidth = false\n        self.limitCursorMovement = false\n        self.mapMovementLocked = false\n\n        self.zoomSpeedFactor = Platform.ingameMap.zoomSpeedFactor\n        ---Minimum mouse movement distance in pixels before dragging is started.Used to distinguish between drags and clicks.\n        self.dragStartDistance = Platform.ingameMap.dragStartDistance\n\n        self.minDragDistanceX = self.dragStartDistance * g_pixelSizeX\n        self.minDragDistanceY = self.dragStartDistance * g_pixelSizeY\n        self.hasDragged = false -- drag state flag to avoid triggering a click event on a dragging mouse up\n\n        self.minimalHotspotSize = getNormalizedScreenValues( 9 , 1 )\n\n        self.isHotspotSelectionActive = true\n        self.isCursorAvailable = true\n\n        self.cursorOffsetX = 0\n        self.cursorOffsetY = 0\n\n        self.originalMapCenterX = 0.5\n        self.originalMapCenterY = 0.5\n\n        self.isPinching = false\n\n        self.isTouchPickingRotation = false\n\n        self.lastInputPosX = { }\n        self.lastInputPosY = { }\n        self.lastInputIndex = 0\n\n        return self\n    end\n\n"})}),"\n",(0,l.jsx)(e.h3,{id:"onaccept",children:"onAccept"}),"\n",(0,l.jsx)(e.p,{children:(0,l.jsx)(e.strong,{children:"Description"})}),"\n",(0,l.jsxs)(e.blockquote,{children:["\n",(0,l.jsx)(e.p,{children:"Event function for gamepad cursor accept input bound to InputAction.INGAMEMAP_ACCEPT."}),"\n"]}),"\n",(0,l.jsx)(e.p,{children:(0,l.jsx)(e.strong,{children:"Definition"})}),"\n",(0,l.jsxs)(e.blockquote,{children:["\n",(0,l.jsx)(e.p,{children:"onAccept()"}),"\n"]}),"\n",(0,l.jsx)(e.p,{children:(0,l.jsx)(e.strong,{children:"Code"})}),"\n",(0,l.jsx)(e.pre,{children:(0,l.jsx)(e.code,{className:"language-lua",children:"function IngameMapElement:onAccept()\n    if self.cursorElement then\n        local cursorElement = self.cursorElement\n        local posX, posY = cursorElement.absPosition[ 1 ] + cursorElement.size[ 1 ] * 0.5 , cursorElement.absPosition[ 2 ] + cursorElement.size[ 2 ] * 0.5\n        local localX, localY = self:getLocalPointerTarget()\n\n        -- save state locally to avoid issues if activating/deactivating selection in the onClickMap callback\n            local isHotspotSelectionActive = self.isHotspotSelectionActive\n\n            self:onClickMap(localX, localY)\n\n            if isHotspotSelectionActive then\n                -- trigger hot spot selection after map clicking because it's the more specific event\n                self:selectHotspotAt(posX, posY)\n            end\n        end\n    end\n\n"})}),"\n",(0,l.jsx)(e.h3,{id:"onclickmap",children:"onClickMap"}),"\n",(0,l.jsx)(e.p,{children:(0,l.jsx)(e.strong,{children:"Description"})}),"\n",(0,l.jsx)(e.p,{children:(0,l.jsx)(e.strong,{children:"Definition"})}),"\n",(0,l.jsxs)(e.blockquote,{children:["\n",(0,l.jsx)(e.p,{children:"onClickMap()"}),"\n"]}),"\n",(0,l.jsx)(e.p,{children:(0,l.jsx)(e.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,l.jsxs)(e.table,{children:[(0,l.jsx)(e.thead,{children:(0,l.jsxs)(e.tr,{children:[(0,l.jsx)(e.th,{children:"any"}),(0,l.jsx)(e.th,{children:"localPosX"})]})}),(0,l.jsx)(e.tbody,{children:(0,l.jsxs)(e.tr,{children:[(0,l.jsx)(e.td,{children:"any"}),(0,l.jsx)(e.td,{children:"localPosY"})]})})]}),"\n",(0,l.jsx)(e.p,{children:(0,l.jsx)(e.strong,{children:"Code"})}),"\n",(0,l.jsx)(e.pre,{children:(0,l.jsx)(e.code,{className:"language-lua",children:'function IngameMapElement:onClickMap(localPosX, localPosY)\n    local worldPosX, worldPosZ = self:localToWorldPos(localPosX, localPosY)\n\n    self:raiseCallback( "onClickMapCallback" , self , worldPosX, worldPosZ)\nend\n\n'})}),"\n",(0,l.jsx)(e.h3,{id:"onclose",children:"onClose"}),"\n",(0,l.jsx)(e.p,{children:(0,l.jsx)(e.strong,{children:"Description"})}),"\n",(0,l.jsx)(e.p,{children:(0,l.jsx)(e.strong,{children:"Definition"})}),"\n",(0,l.jsxs)(e.blockquote,{children:["\n",(0,l.jsx)(e.p,{children:"onClose()"}),"\n"]}),"\n",(0,l.jsx)(e.p,{children:(0,l.jsx)(e.strong,{children:"Code"})}),"\n",(0,l.jsx)(e.pre,{children:(0,l.jsx)(e.code,{className:"language-lua",children:"function IngameMapElement:onClose()\n    IngameMapElement:superClass().onClose( self )\n\n    self:removeActionEvents()\n\n    self.ingameMap:setFullscreen( false )\nend\n\n"})}),"\n",(0,l.jsx)(e.h3,{id:"onguisetupfinished",children:"onGuiSetupFinished"}),"\n",(0,l.jsx)(e.p,{children:(0,l.jsx)(e.strong,{children:"Description"})}),"\n",(0,l.jsx)(e.p,{children:(0,l.jsx)(e.strong,{children:"Definition"})}),"\n",(0,l.jsxs)(e.blockquote,{children:["\n",(0,l.jsx)(e.p,{children:"onGuiSetupFinished()"}),"\n"]}),"\n",(0,l.jsx)(e.p,{children:(0,l.jsx)(e.strong,{children:"Code"})}),"\n",(0,l.jsx)(e.pre,{children:(0,l.jsx)(e.code,{className:"language-lua",children:'function IngameMapElement:onGuiSetupFinished()\n    IngameMapElement:superClass().onGuiSetupFinished( self )\n\n    if self.cursorId ~ = nil then\n        if self.target[ self.cursorId] ~ = nil then\n            self.cursorElement = self.target[ self.cursorId]\n        else\n                printWarning( "Warning:CursorId \'" .. self.cursorId .. "\' not found for \'" .. self.target.name .. "\'!" )\n                end\n            end\n        end\n\n'})}),"\n",(0,l.jsx)(e.h3,{id:"onhorizontalcursorinput",children:"onHorizontalCursorInput"}),"\n",(0,l.jsx)(e.p,{children:(0,l.jsx)(e.strong,{children:"Description"})}),"\n",(0,l.jsxs)(e.blockquote,{children:["\n",(0,l.jsx)(e.p,{children:"Event function for horizontal cursor input bound to InputAction.AXIS_LOOK_LEFTRIGHT_VEHICLE."}),"\n"]}),"\n",(0,l.jsx)(e.p,{children:(0,l.jsx)(e.strong,{children:"Definition"})}),"\n",(0,l.jsxs)(e.blockquote,{children:["\n",(0,l.jsx)(e.p,{children:"onHorizontalCursorInput()"}),"\n"]}),"\n",(0,l.jsx)(e.p,{children:(0,l.jsx)(e.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,l.jsxs)(e.table,{children:[(0,l.jsx)(e.thead,{children:(0,l.jsxs)(e.tr,{children:[(0,l.jsx)(e.th,{children:"any"}),(0,l.jsx)(e.th,{children:"_"})]})}),(0,l.jsx)(e.tbody,{children:(0,l.jsxs)(e.tr,{children:[(0,l.jsx)(e.td,{children:"any"}),(0,l.jsx)(e.td,{children:"inputValue"})]})})]}),"\n",(0,l.jsx)(e.p,{children:(0,l.jsx)(e.strong,{children:"Code"})}),"\n",(0,l.jsx)(e.pre,{children:(0,l.jsx)(e.code,{className:"language-lua",children:"function IngameMapElement:onHorizontalCursorInput(_, inputValue)\n    if not self:checkAndResetMouse() and not self.isFixedHorizontal then\n        self.accumHorizontalInput = self.accumHorizontalInput + inputValue\n\n        if math.abs(inputValue) > 0.05 then\n            g_inGameMenu.pageMapOverview.lastInputTime = g_ time\n        end\n    end\nend\n\n"})}),"\n",(0,l.jsx)(e.h3,{id:"onopen",children:"onOpen"}),"\n",(0,l.jsx)(e.p,{children:(0,l.jsx)(e.strong,{children:"Description"})}),"\n",(0,l.jsx)(e.p,{children:(0,l.jsx)(e.strong,{children:"Definition"})}),"\n",(0,l.jsxs)(e.blockquote,{children:["\n",(0,l.jsx)(e.p,{children:"onOpen()"}),"\n"]}),"\n",(0,l.jsx)(e.p,{children:(0,l.jsx)(e.strong,{children:"Code"})}),"\n",(0,l.jsx)(e.pre,{children:(0,l.jsx)(e.code,{className:"language-lua",children:"function IngameMapElement:onOpen()\n    IngameMapElement:superClass().onOpen( self )\n\n    if self.cursorElement ~ = nil then\n        self.cursorElement:setVisible( false )\n    end\n    self.isCursorActive = false\n\n    if self.largestSize = = nil then\n        self.largestSize = self.size\n    end\n\n    self.ingameMap:setFullscreen( true )\n\n    if Platform.ingameMap.resetZoomOnOpen then\n        self:zoom( 0 )\n    end\nend\n\n"})}),"\n",(0,l.jsx)(e.h3,{id:"onpinchevent",children:"onPinchEvent"}),"\n",(0,l.jsx)(e.p,{children:(0,l.jsx)(e.strong,{children:"Description"})}),"\n",(0,l.jsxs)(e.blockquote,{children:["\n",(0,l.jsx)(e.p,{children:"Event function for map zoom input triggered by pinching via touch input."}),"\n"]}),"\n",(0,l.jsx)(e.p,{children:(0,l.jsx)(e.strong,{children:"Definition"})}),"\n",(0,l.jsxs)(e.blockquote,{children:["\n",(0,l.jsx)(e.p,{children:"onPinchEvent(float offset, pinchCenterX x, pinchCenterY y, float distance)"}),"\n"]}),"\n",(0,l.jsx)(e.p,{children:(0,l.jsx)(e.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,l.jsxs)(e.table,{children:[(0,l.jsx)(e.thead,{children:(0,l.jsxs)(e.tr,{children:[(0,l.jsx)(e.th,{children:"float"}),(0,l.jsx)(e.th,{children:"offset"}),(0,l.jsx)(e.th,{children:"offset between new distance and distance of last pinch event"})]})}),(0,l.jsxs)(e.tbody,{children:[(0,l.jsxs)(e.tr,{children:[(0,l.jsx)(e.td,{children:"pinchCenterX"}),(0,l.jsx)(e.td,{children:"x"}),(0,l.jsx)(e.td,{children:"position of the center point of the pinch"})]}),(0,l.jsxs)(e.tr,{children:[(0,l.jsx)(e.td,{children:"pinchCenterY"}),(0,l.jsx)(e.td,{children:"y"}),(0,l.jsx)(e.td,{children:"position of the center point of the pinch"})]}),(0,l.jsxs)(e.tr,{children:[(0,l.jsx)(e.td,{children:"float"}),(0,l.jsx)(e.td,{children:"distance"}),(0,l.jsx)(e.td,{children:"distance between both touch positions"})]})]})]}),"\n",(0,l.jsx)(e.p,{children:(0,l.jsx)(e.strong,{children:"Code"})}),"\n",(0,l.jsx)(e.pre,{children:(0,l.jsx)(e.code,{className:"language-lua",children:"function IngameMapElement:onPinchEvent(offset, pinchCenterX, pinchCenterY, distance)\n    self.oldCursorX = self.cursorElement.absPosition[ 1 ]\n    self.oldCursorY = self.cursorElement.absPosition[ 2 ]\n    self.cursorElement.absPosition[ 1 ] = pinchCenterX\n    self.cursorElement.absPosition[ 2 ] = pinchCenterY\n\n    self.accumZoomInput = self.accumZoomInput + offset * 100\n\n    self.isPinching = true\nend\n\n"})}),"\n",(0,l.jsx)(e.h3,{id:"onverticalcursorinput",children:"onVerticalCursorInput"}),"\n",(0,l.jsx)(e.p,{children:(0,l.jsx)(e.strong,{children:"Description"})}),"\n",(0,l.jsxs)(e.blockquote,{children:["\n",(0,l.jsx)(e.p,{children:"Event function for vertical cursor input bound to InputAction.AXIS_LOOK_UPDOWN_VEHICLE."}),"\n"]}),"\n",(0,l.jsx)(e.p,{children:(0,l.jsx)(e.strong,{children:"Definition"})}),"\n",(0,l.jsxs)(e.blockquote,{children:["\n",(0,l.jsx)(e.p,{children:"onVerticalCursorInput()"}),"\n"]}),"\n",(0,l.jsx)(e.p,{children:(0,l.jsx)(e.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,l.jsxs)(e.table,{children:[(0,l.jsx)(e.thead,{children:(0,l.jsxs)(e.tr,{children:[(0,l.jsx)(e.th,{children:"any"}),(0,l.jsx)(e.th,{children:"_"})]})}),(0,l.jsx)(e.tbody,{children:(0,l.jsxs)(e.tr,{children:[(0,l.jsx)(e.td,{children:"any"}),(0,l.jsx)(e.td,{children:"inputValue"})]})})]}),"\n",(0,l.jsx)(e.p,{children:(0,l.jsx)(e.strong,{children:"Code"})}),"\n",(0,l.jsx)(e.pre,{children:(0,l.jsx)(e.code,{className:"language-lua",children:"function IngameMapElement:onVerticalCursorInput(_, inputValue)\n    if not self:checkAndResetMouse() then\n        self.accumVerticalInput = self.accumVerticalInput + inputValue\n\n        if math.abs(inputValue) > 0.05 then\n            g_inGameMenu.pageMapOverview.lastInputTime = g_ time\n        end\n    end\nend\n\n"})}),"\n",(0,l.jsx)(e.h3,{id:"onzoominput",children:"onZoomInput"}),"\n",(0,l.jsx)(e.p,{children:(0,l.jsx)(e.strong,{children:"Description"})}),"\n",(0,l.jsxs)(e.blockquote,{children:["\n",(0,l.jsx)(e.p,{children:"Event function for map zoom input bound to InputAction.AXIS_ACCELERATE_VEHICLE and InputAction.AXIS_BRAKE_VEHICLE."}),"\n"]}),"\n",(0,l.jsx)(e.p,{children:(0,l.jsx)(e.strong,{children:"Definition"})}),"\n",(0,l.jsxs)(e.blockquote,{children:["\n",(0,l.jsx)(e.p,{children:"onZoomInput(inputValue Zoom, direction Zoom, )"}),"\n"]}),"\n",(0,l.jsx)(e.p,{children:(0,l.jsx)(e.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,l.jsxs)(e.table,{children:[(0,l.jsx)(e.thead,{children:(0,l.jsxs)(e.tr,{children:[(0,l.jsx)(e.th,{children:"inputValue"}),(0,l.jsx)(e.th,{children:"Zoom"}),(0,l.jsx)(e.th,{children:"input value"})]})}),(0,l.jsxs)(e.tbody,{children:[(0,l.jsxs)(e.tr,{children:[(0,l.jsx)(e.td,{children:"direction"}),(0,l.jsx)(e.td,{children:"Zoom"}),(0,l.jsx)(e.td,{children:"input sign value, 1 for zoom in, -1 for zoom out"})]}),(0,l.jsxs)(e.tr,{children:[(0,l.jsx)(e.td,{children:"any"}),(0,l.jsx)(e.td,{children:"direction"}),(0,l.jsx)(e.td,{})]})]})]}),"\n",(0,l.jsx)(e.p,{children:(0,l.jsx)(e.strong,{children:"Code"})}),"\n",(0,l.jsx)(e.pre,{children:(0,l.jsx)(e.code,{className:"language-lua",children:"function IngameMapElement:onZoomInput(_, inputValue, direction)\n    if not self:isInputInDeadzones(g_lastMousePosX, g_lastMousePosY) or not self.useMouse then\n        self.accumZoomInput = self.accumZoomInput - direction * inputValue\n    end\nend\n\n"})}),"\n",(0,l.jsx)(e.h3,{id:"pantohotspot",children:"panToHotspot"}),"\n",(0,l.jsx)(e.p,{children:(0,l.jsx)(e.strong,{children:"Description"})}),"\n",(0,l.jsxs)(e.blockquote,{children:["\n",(0,l.jsx)(e.p,{children:"Pan to a hotpspot, if possible the hotspot will end up at the center of the screen, or if it is near the map border it\nwill be centered as much as possible"}),"\n"]}),"\n",(0,l.jsx)(e.p,{children:(0,l.jsx)(e.strong,{children:"Definition"})}),"\n",(0,l.jsxs)(e.blockquote,{children:["\n",(0,l.jsx)(e.p,{children:"panToHotspot(hotspot the, )"}),"\n"]}),"\n",(0,l.jsx)(e.p,{children:(0,l.jsx)(e.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,l.jsxs)(e.table,{children:[(0,l.jsx)(e.thead,{children:(0,l.jsxs)(e.tr,{children:[(0,l.jsx)(e.th,{children:"hotspot"}),(0,l.jsx)(e.th,{children:"the"}),(0,l.jsx)(e.th,{children:"hotspot that gets centered"})]})}),(0,l.jsx)(e.tbody,{children:(0,l.jsxs)(e.tr,{children:[(0,l.jsx)(e.td,{children:"any"}),(0,l.jsx)(e.td,{children:"extraOffsetX"}),(0,l.jsx)(e.td,{})]})})]}),"\n",(0,l.jsx)(e.p,{children:(0,l.jsx)(e.strong,{children:"Code"})}),"\n",(0,l.jsx)(e.pre,{children:(0,l.jsx)(e.code,{className:"language-lua",children:"function IngameMapElement:panToHotspot(hotspot, extraOffsetX)\n    if hotspot ~ = nil then\n        if Platform.isMobile then\n            local hotspotX, hotspotY = self:worldToScreenPos(hotspot:getWorldPosition())\n            local cursorOffsetX = - hotspotX + self.mapCenterX + self.originalMapCenterX\n            local cursorOffsetY = - hotspotY + self.mapCenterY + self.originalMapCenterY\n\n            self.cursorOffsetX = cursorOffsetX - self.mapCenterX\n            self.cursorOffsetY = cursorOffsetY - self.mapCenterY\n        else\n                local ingameMap = self.ingameMap\n                local hotspotX, hotspotY = hotspot:getWorldPosition()\n                local objectX = (hotspotX + ingameMap.worldCenterOffsetX) / ingameMap.worldSizeX * ingameMap.mapExtensionScaleFactor + ingameMap.mapExtensionOffsetX\n                local objectZ = (hotspotY + ingameMap.worldCenterOffsetZ) / ingameMap.worldSizeZ * ingameMap.mapExtensionScaleFactor + ingameMap.mapExtensionOffsetZ\n                hotspotX, hotspotY = ingameMap.layout:getMapObjectPosition(objectX, objectZ, 0 , 0 )\n\n                local offsetX = self.originalMapCenterX - hotspotX\n                local offsetY = self.originalMapCenterY - hotspotY\n                self:moveCenter(offsetX, offsetY)\n            end\n        end\n    end\n\n"})}),"\n",(0,l.jsx)(e.h3,{id:"registeractionevents",children:"registerActionEvents"}),"\n",(0,l.jsx)(e.p,{children:(0,l.jsx)(e.strong,{children:"Description"})}),"\n",(0,l.jsxs)(e.blockquote,{children:["\n",(0,l.jsx)(e.p,{children:"Register non-GUI input action events."}),"\n"]}),"\n",(0,l.jsx)(e.p,{children:(0,l.jsx)(e.strong,{children:"Definition"})}),"\n",(0,l.jsxs)(e.blockquote,{children:["\n",(0,l.jsx)(e.p,{children:"registerActionEvents()"}),"\n"]}),"\n",(0,l.jsx)(e.p,{children:(0,l.jsx)(e.strong,{children:"Code"})}),"\n",(0,l.jsx)(e.pre,{children:(0,l.jsx)(e.code,{className:"language-lua",children:"function IngameMapElement:registerActionEvents()\n    g_inputBinding:registerActionEvent(InputAction.AXIS_MAP_SCROLL_LEFT_RIGHT, self , self.onHorizontalCursorInput, false , false , true , true )\n    g_inputBinding:registerActionEvent(InputAction.AXIS_MAP_SCROLL_UP_DOWN, self , self.onVerticalCursorInput, false , false , true , true )\n    g_inputBinding:registerActionEvent(InputAction.INGAMEMAP_ACCEPT, self , self.onAccept, false , true , false , true )\n    g_inputBinding:registerActionEvent(InputAction.AXIS_MAP_ZOOM_OUT, self , self.onZoomInput, false , false , true , true , - 1 ) -- -1 = = zoom out\n    g_inputBinding:registerActionEvent(InputAction.AXIS_MAP_ZOOM_IN, self , self.onZoomInput, false , false , true , true , 1 ) -- 1 = = zoom in\n\n    if g_touchHandler ~ = nil then\n        self.touchListenerPinch = g_touchHandler:registerGestureListener(TouchHandler.GESTURE_PINCH, self.onPinchEvent, self )\n    end\nend\n\n"})}),"\n",(0,l.jsx)(e.h3,{id:"removeactionevents",children:"removeActionEvents"}),"\n",(0,l.jsx)(e.p,{children:(0,l.jsx)(e.strong,{children:"Description"})}),"\n",(0,l.jsxs)(e.blockquote,{children:["\n",(0,l.jsx)(e.p,{children:"Remove non-GUI input action events."}),"\n"]}),"\n",(0,l.jsx)(e.p,{children:(0,l.jsx)(e.strong,{children:"Definition"})}),"\n",(0,l.jsxs)(e.blockquote,{children:["\n",(0,l.jsx)(e.p,{children:"removeActionEvents()"}),"\n"]}),"\n",(0,l.jsx)(e.p,{children:(0,l.jsx)(e.strong,{children:"Code"})}),"\n",(0,l.jsx)(e.pre,{children:(0,l.jsx)(e.code,{className:"language-lua",children:"function IngameMapElement:removeActionEvents()\n    g_inputBinding:removeActionEventsByTarget( self )\n\n    if g_touchHandler ~ = nil then\n        g_touchHandler:removeGestureListener( self.touchListenerPinch)\n    end\nend\n\n"})}),"\n",(0,l.jsx)(e.h3,{id:"reset",children:"reset"}),"\n",(0,l.jsx)(e.p,{children:(0,l.jsx)(e.strong,{children:"Description"})}),"\n",(0,l.jsx)(e.p,{children:(0,l.jsx)(e.strong,{children:"Definition"})}),"\n",(0,l.jsxs)(e.blockquote,{children:["\n",(0,l.jsx)(e.p,{children:"reset()"}),"\n"]}),"\n",(0,l.jsx)(e.p,{children:(0,l.jsx)(e.strong,{children:"Code"})}),"\n",(0,l.jsx)(e.pre,{children:(0,l.jsx)(e.code,{className:"language-lua",children:"function IngameMapElement:reset()\n    IngameMapElement:superClass().reset( self )\n\n    self.mapCenterX = 0.5\n    self.mapCenterY = 0.5\n    self.mapZoom = self.zoomDefault\n\n    -- self.ingameMap:resetSettings()\nend\n\n"})}),"\n",(0,l.jsx)(e.h3,{id:"resetframeinputstate",children:"resetFrameInputState"}),"\n",(0,l.jsx)(e.p,{children:(0,l.jsx)(e.strong,{children:"Description"})}),"\n",(0,l.jsx)(e.p,{children:(0,l.jsx)(e.strong,{children:"Definition"})}),"\n",(0,l.jsxs)(e.blockquote,{children:["\n",(0,l.jsx)(e.p,{children:"resetFrameInputState()"}),"\n"]}),"\n",(0,l.jsx)(e.p,{children:(0,l.jsx)(e.strong,{children:"Code"})}),"\n",(0,l.jsx)(e.pre,{children:(0,l.jsx)(e.code,{className:"language-lua",children:"function IngameMapElement:resetFrameInputState()\n    self.accumZoomInput = 0\n    self.accumHorizontalInput = 0\n    self.accumVerticalInput = 0\n    if self.resetMouseNextFrame then\n        self.useMouse = false\n        self.resetMouseNextFrame = false\n    end\n\n    if Platform.isMobile and self.isPinching then\n        self.cursorElement.absPosition[ 1 ] = self.originalMapCenterX + self.cursorOffsetX\n        self.cursorElement.absPosition[ 2 ] = self.originalMapCenterY + self.cursorOffsetY\n\n        self.isPinching = false\n    end\nend\n\n"})}),"\n",(0,l.jsx)(e.h3,{id:"selecthotspotat",children:"selectHotspotAt"}),"\n",(0,l.jsx)(e.p,{children:(0,l.jsx)(e.strong,{children:"Description"})}),"\n",(0,l.jsx)(e.p,{children:(0,l.jsx)(e.strong,{children:"Definition"})}),"\n",(0,l.jsxs)(e.blockquote,{children:["\n",(0,l.jsx)(e.p,{children:"selectHotspotAt()"}),"\n"]}),"\n",(0,l.jsx)(e.p,{children:(0,l.jsx)(e.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,l.jsxs)(e.table,{children:[(0,l.jsx)(e.thead,{children:(0,l.jsxs)(e.tr,{children:[(0,l.jsx)(e.th,{children:"any"}),(0,l.jsx)(e.th,{children:"posX"})]})}),(0,l.jsx)(e.tbody,{children:(0,l.jsxs)(e.tr,{children:[(0,l.jsx)(e.td,{children:"any"}),(0,l.jsx)(e.td,{children:"posY"})]})})]}),"\n",(0,l.jsx)(e.p,{children:(0,l.jsx)(e.strong,{children:"Code"})}),"\n",(0,l.jsx)(e.pre,{children:(0,l.jsx)(e.code,{className:"language-lua",children:"function IngameMapElement:selectHotspotAt(posX, posY)\n    if self.isHotspotSelectionActive then\n        self.ingameMap:updateHotspotSorting()\n        local sortedHotspots = self.ingameMap.hotspotsSorted\n\n        if sortedHotspots ~ = nil then\n            local playerHotspot = self:getPlayerHotspot(sortedHotspots[ true ])\n            local prioritizePlayerHotspot = not Platform.isMobile or playerHotspot:getVehicle() ~ = nil\n\n            if not self:selectHotspotFrom(sortedHotspots[prioritizePlayerHotspot], posX, posY) then\n                if prioritizePlayerHotspot then\n                    self:selectHotspotFrom(sortedHotspots[ false ], posX, posY)\n                end\n            end\n\n            return\n        end\n\n        self:selectHotspotFrom( self.ingameMap.hotspots, posX, posY)\n    end\nend\n\n"})}),"\n",(0,l.jsx)(e.h3,{id:"selecthotspotfrom",children:"selectHotspotFrom"}),"\n",(0,l.jsx)(e.p,{children:(0,l.jsx)(e.strong,{children:"Description"})}),"\n",(0,l.jsx)(e.p,{children:(0,l.jsx)(e.strong,{children:"Definition"})}),"\n",(0,l.jsxs)(e.blockquote,{children:["\n",(0,l.jsx)(e.p,{children:"selectHotspotFrom()"}),"\n"]}),"\n",(0,l.jsx)(e.p,{children:(0,l.jsx)(e.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,l.jsxs)(e.table,{children:[(0,l.jsx)(e.thead,{children:(0,l.jsxs)(e.tr,{children:[(0,l.jsx)(e.th,{children:"any"}),(0,l.jsx)(e.th,{children:"hotspots"})]})}),(0,l.jsxs)(e.tbody,{children:[(0,l.jsxs)(e.tr,{children:[(0,l.jsx)(e.td,{children:"any"}),(0,l.jsx)(e.td,{children:"posX"})]}),(0,l.jsxs)(e.tr,{children:[(0,l.jsx)(e.td,{children:"any"}),(0,l.jsx)(e.td,{children:"posY"})]})]})]}),"\n",(0,l.jsx)(e.p,{children:(0,l.jsx)(e.strong,{children:"Code"})}),"\n",(0,l.jsx)(e.pre,{children:(0,l.jsx)(e.code,{className:"language-lua",children:'function IngameMapElement:selectHotspotFrom(hotspots, posX, posY)\n    local minDistance = math.huge\n    local minHotspot\n    for i = #hotspots, 1 , - 1 do\n        local hotspot = hotspots[i]\n\n        if self.ingameMap.filter[hotspot:getCategory()] and hotspot:getIsVisible() then\n            local isInRange, distance = hotspot:hasMouseOverlap(posX, posY)\n            if isInRange then\n                if minHotspot ~ = nil then\n                    if hotspot:getSortingValue() < minHotspot:getSortingValue() then\n                        if distance < minDistance then\n                            minDistance = distance\n                            minHotspot = hotspot\n                        end\n                    else\n                            minDistance = distance\n                            minHotspot = hotspot\n                        end\n                    else\n                            minDistance = distance\n                            minHotspot = hotspot\n                        end\n                    end\n                end\n            end\n\n            if minHotspot ~ = nil then\n                self:raiseCallback( "onClickHotspotCallback" , self , minHotspot)\n                return true\n            end\n\n            return false\n        end\n\n'})}),"\n",(0,l.jsx)(e.h3,{id:"setingamemap",children:"setIngameMap"}),"\n",(0,l.jsx)(e.p,{children:(0,l.jsx)(e.strong,{children:"Description"})}),"\n",(0,l.jsxs)(e.blockquote,{children:["\n",(0,l.jsx)(e.p,{children:"Set the IngameMap reference to use for display."}),"\n"]}),"\n",(0,l.jsx)(e.p,{children:(0,l.jsx)(e.strong,{children:"Definition"})}),"\n",(0,l.jsxs)(e.blockquote,{children:["\n",(0,l.jsx)(e.p,{children:"setIngameMap()"}),"\n"]}),"\n",(0,l.jsx)(e.p,{children:(0,l.jsx)(e.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,l.jsx)(e.table,{children:(0,l.jsx)(e.thead,{children:(0,l.jsxs)(e.tr,{children:[(0,l.jsx)(e.th,{children:"any"}),(0,l.jsx)(e.th,{children:"ingameMap"})]})})}),"\n",(0,l.jsx)(e.p,{children:(0,l.jsx)(e.strong,{children:"Code"})}),"\n",(0,l.jsx)(e.pre,{children:(0,l.jsx)(e.code,{className:"language-lua",children:"function IngameMapElement:setIngameMap(ingameMap)\n    self.ingameMap = ingameMap\n    if self.limitMapWidth and self.ingameMap ~ = nil then\n        self.ingameMap.fullScreenLayout:setMapWidth( self.absSize[ 1 ])\n    end\nend\n\n"})}),"\n",(0,l.jsx)(e.h3,{id:"setterrainsize",children:"setTerrainSize"}),"\n",(0,l.jsx)(e.p,{children:(0,l.jsx)(e.strong,{children:"Description"})}),"\n",(0,l.jsxs)(e.blockquote,{children:["\n",(0,l.jsx)(e.p,{children:"Set the current map's terrain size for map display."}),"\n"]}),"\n",(0,l.jsx)(e.p,{children:(0,l.jsx)(e.strong,{children:"Definition"})}),"\n",(0,l.jsxs)(e.blockquote,{children:["\n",(0,l.jsx)(e.p,{children:"setTerrainSize()"}),"\n"]}),"\n",(0,l.jsx)(e.p,{children:(0,l.jsx)(e.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,l.jsx)(e.table,{children:(0,l.jsx)(e.thead,{children:(0,l.jsxs)(e.tr,{children:[(0,l.jsx)(e.th,{children:"any"}),(0,l.jsx)(e.th,{children:"terrainSize"})]})})}),"\n",(0,l.jsx)(e.p,{children:(0,l.jsx)(e.strong,{children:"Code"})}),"\n",(0,l.jsx)(e.pre,{children:(0,l.jsx)(e.code,{className:"language-lua",children:"function IngameMapElement:setTerrainSize(terrainSize)\n    self.terrainSize = terrainSize\nend\n\n"})}),"\n",(0,l.jsx)(e.h3,{id:"touchevent",children:"touchEvent"}),"\n",(0,l.jsx)(e.p,{children:(0,l.jsx)(e.strong,{children:"Description"})}),"\n",(0,l.jsxs)(e.blockquote,{children:["\n",(0,l.jsx)(e.p,{children:"Custom touch event handling for the in-game map.\nDirectly handles zoom, click and drag events on the map."}),"\n"]}),"\n",(0,l.jsx)(e.p,{children:(0,l.jsx)(e.strong,{children:"Definition"})}),"\n",(0,l.jsxs)(e.blockquote,{children:["\n",(0,l.jsx)(e.p,{children:"touchEvent()"}),"\n"]}),"\n",(0,l.jsx)(e.p,{children:(0,l.jsx)(e.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,l.jsxs)(e.table,{children:[(0,l.jsx)(e.thead,{children:(0,l.jsxs)(e.tr,{children:[(0,l.jsx)(e.th,{children:"any"}),(0,l.jsx)(e.th,{children:"posX"})]})}),(0,l.jsxs)(e.tbody,{children:[(0,l.jsxs)(e.tr,{children:[(0,l.jsx)(e.td,{children:"any"}),(0,l.jsx)(e.td,{children:"posY"})]}),(0,l.jsxs)(e.tr,{children:[(0,l.jsx)(e.td,{children:"any"}),(0,l.jsx)(e.td,{children:"isDown"})]}),(0,l.jsxs)(e.tr,{children:[(0,l.jsx)(e.td,{children:"any"}),(0,l.jsx)(e.td,{children:"isUp"})]}),(0,l.jsxs)(e.tr,{children:[(0,l.jsx)(e.td,{children:"any"}),(0,l.jsx)(e.td,{children:"touchId"})]}),(0,l.jsxs)(e.tr,{children:[(0,l.jsx)(e.td,{children:"any"}),(0,l.jsx)(e.td,{children:"eventUsed"})]})]})]}),"\n",(0,l.jsx)(e.p,{children:(0,l.jsx)(e.strong,{children:"Code"})}),"\n",(0,l.jsx)(e.pre,{children:(0,l.jsx)(e.code,{className:"language-lua",children:"function IngameMapElement:touchEvent(posX, posY, isDown, isUp, touchId, eventUsed)\n    if self:getIsActive() then\n        eventUsed = IngameMapElement:superClass().mouseEvent( self , posX, posY, isDown, isUp, touchId, eventUsed)\n        self.lastInputIndex = touchId\n\n        if isDown or isUp or posX ~ = self.lastInputPosX[touchId] or posY ~ = self.lastInputPosY[touchId] then\n            if self.cursorElement then\n                self.cursorElement:setVisible( false )\n            end\n            self.isCursorActive = false\n        end\n\n        -- On mobile we have touch input.Touch does not give us a position until there is a touch.\n        -- This means on the first touch-begin, the lastMousePos is wrong and has a big offset.\n        -- We set it when the touch begins so it becomes a drag action\n        if isDown then\n            self.lastInputPosX[touchId] = posX\n            self.lastInputPosY[touchId] = posY\n        end\n\n        if not eventUsed then\n            if isDown and not self:isInputInDeadzones(posX, posY) then\n                eventUsed = true\n                if not self.inputDown then\n                    self.inputDown = true\n                end\n            end\n        end\n\n        if self.inputDown and self.lastInputPosX[touchId] ~ = nil then\n            local distX = self.lastInputPosX[touchId] - posX\n            local distY = posY - self.lastInputPosY[touchId]\n\n            if self.isFixedHorizontal then\n                distX = 0\n            end\n\n            if self.isTouchPickingRotation then\n                local aiButton = self.target.buttonConfirmAITarget\n                local clickInButton = GuiUtils.checkOverlayOverlap(posX, posY, aiButton.absPosition[ 1 ], aiButton.absPosition[ 2 ], aiButton.size[ 1 ], aiButton.size[ 2 ])\n\n                if not clickInButton then\n                    local localX, localY = self:getLocalPosition(posX, posY)\n                    self:onClickMap(localX, localY)\n                end\n            else\n                    if math.abs(distX) > self.minDragDistanceX or math.abs(distY) > self.minDragDistanceY then\n                        local factorX = - distX\n                        local factorY = distY\n\n                        self:moveCenter(factorX, factorY)\n\n                        self.hasDragged = true\n                    end\n                end\n            end\n\n            if isUp then\n                if not eventUsed and self.inputDown and not self.hasDragged then\n                    local localX, localY = self:getLocalPosition(posX, posY)\n\n                    -- save state locally to avoid issues if activating/deactivating selection in the onClickMap callback\n                        local isHotspotSelectionActive = self.isHotspotSelectionActive\n\n                        self:onClickMap(localX, localY)\n\n                        if isHotspotSelectionActive then\n                            -- Trigger hot spot selection after map clicking because it's the more specific event\n                            self:selectHotspotAt(posX, posY)\n                        end\n\n                        eventUsed = true\n                    end\n\n                    self.inputDown = false\n                    self.hasDragged = false\n                end\n\n                self.lastInputPosX[touchId] = posX\n                self.lastInputPosY[touchId] = posY\n            end\n\n            return eventUsed\n        end\n\n"})}),"\n",(0,l.jsx)(e.h3,{id:"update",children:"update"}),"\n",(0,l.jsx)(e.p,{children:(0,l.jsx)(e.strong,{children:"Description"})}),"\n",(0,l.jsx)(e.p,{children:(0,l.jsx)(e.strong,{children:"Definition"})}),"\n",(0,l.jsxs)(e.blockquote,{children:["\n",(0,l.jsx)(e.p,{children:"update()"}),"\n"]}),"\n",(0,l.jsx)(e.p,{children:(0,l.jsx)(e.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,l.jsx)(e.table,{children:(0,l.jsx)(e.thead,{children:(0,l.jsxs)(e.tr,{children:[(0,l.jsx)(e.th,{children:"any"}),(0,l.jsx)(e.th,{children:"dt"})]})})}),"\n",(0,l.jsx)(e.p,{children:(0,l.jsx)(e.strong,{children:"Code"})}),"\n",(0,l.jsx)(e.pre,{children:(0,l.jsx)(e.code,{className:"language-lua",children:"function IngameMapElement:update(dt)\n    IngameMapElement:superClass().update( self , dt)\n\n    self.inputMode = g_inputBinding:getLastInputMode()\n\n    if not g_gui:getIsDialogVisible() then\n        if not self.alreadyClosed then\n            local zoomFactor = self.accumZoomInput\n            if not self.isPinching then\n                zoomFactor = math.clamp(zoomFactor, - 1 , 1 )\n            end\n\n            if zoomFactor ~ = 0 then\n                self:zoom(zoomFactor * - 0.015 * dt)\n            end\n\n            if self.cursorElement ~ = nil then\n                self.isCursorActive = self.inputMode = = GS_INPUT_HELP_MODE_GAMEPAD\n                self.cursorElement:setVisible( self.isCursorAvailable and self.isCursorActive)\n                self:updateCursor( self.accumHorizontalInput, - self.accumVerticalInput, dt)\n                self.useMouse = false\n            end\n        end\n    end\n\n    self:resetFrameInputState()\nend\n\n"})}),"\n",(0,l.jsx)(e.h3,{id:"updatecursor",children:"updateCursor"}),"\n",(0,l.jsx)(e.p,{children:(0,l.jsx)(e.strong,{children:"Description"})}),"\n",(0,l.jsx)(e.p,{children:(0,l.jsx)(e.strong,{children:"Definition"})}),"\n",(0,l.jsxs)(e.blockquote,{children:["\n",(0,l.jsx)(e.p,{children:"updateCursor()"}),"\n"]}),"\n",(0,l.jsx)(e.p,{children:(0,l.jsx)(e.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,l.jsxs)(e.table,{children:[(0,l.jsx)(e.thead,{children:(0,l.jsxs)(e.tr,{children:[(0,l.jsx)(e.th,{children:"any"}),(0,l.jsx)(e.th,{children:"deltaX"})]})}),(0,l.jsxs)(e.tbody,{children:[(0,l.jsxs)(e.tr,{children:[(0,l.jsx)(e.td,{children:"any"}),(0,l.jsx)(e.td,{children:"deltaY"})]}),(0,l.jsxs)(e.tr,{children:[(0,l.jsx)(e.td,{children:"any"}),(0,l.jsx)(e.td,{children:"dt"})]})]})]}),"\n",(0,l.jsx)(e.p,{children:(0,l.jsx)(e.strong,{children:"Code"})}),"\n",(0,l.jsx)(e.pre,{children:(0,l.jsx)(e.code,{className:"language-lua",children:"function IngameMapElement:updateCursor(deltaX, deltaY, dt)\n    if self.cursorElement ~ = nil then\n        local speed = IngameMapElement.CURSOR_SPEED_FACTOR\n\n        local diffX = deltaX * speed * dt / g_screenAspectRatio\n        local diffY = deltaY * speed * dt\n\n        if Platform.isMobile or self.mapMovementLocked then\n            diffX = diffX - self.cursorOffsetX\n            diffY = diffY - self.cursorOffsetY\n\n            local oldX = self.mapCenterX\n            local oldY = self.mapCenterY\n\n            if not self.mapMovementLocked then\n                self:moveCenter( - diffX, - diffY)\n            end\n\n            local newX = self.mapCenterX\n            local newY = self.mapCenterY\n\n            local cursorSize = self.cursorElement.absSize\n            local _, width = self.ingameMap.fullScreenLayout:getMapSize()\n\n            self.cursorOffsetX = oldX - newX - diffX\n            self.cursorOffsetX = math.max( math.min( self.cursorOffsetX, width * 0.5 - cursorSize[ 1 ] * 0.5 ), - width * 0.5 + cursorSize[ 1 ] * 0.5 )\n            self.cursorOffsetY = oldY - newY - diffY\n            self.cursorOffsetY = math.max( math.min( self.cursorOffsetY, 0.5 - cursorSize[ 2 ] * 0.5 ), - 0.5 + cursorSize[ 2 ] * 0.5 )\n\n            if not Platform.isMobile and self.mapMovementLocked then\n                local maxOffset = 250\n                self.cursorOffsetX = math.clamp( self.cursorOffsetX, - maxOffset * g_pixelSizeScaledX, maxOffset * g_pixelSizeScaledX)\n                self.cursorOffsetY = math.clamp( self.cursorOffsetY, - maxOffset * g_pixelSizeScaledY, maxOffset * g_pixelSizeScaledY)\n            end\n\n            local cursor = self.cursorElement\n\n            cursor.absPosition[ 1 ] = self.originalMapCenterX - self.cursorOffsetX - cursor.absSize[ 1 ] * 0.5\n            cursor.absPosition[ 2 ] = self.originalMapCenterY - self.cursorOffsetY - cursor.absSize[ 2 ] * 0.5\n        else\n                self:moveCenter( - diffX, - diffY)\n            end\n        end\n    end\n\n"})}),"\n",(0,l.jsx)(e.h3,{id:"zoom",children:"zoom"}),"\n",(0,l.jsx)(e.p,{children:(0,l.jsx)(e.strong,{children:"Description"})}),"\n",(0,l.jsx)(e.p,{children:(0,l.jsx)(e.strong,{children:"Definition"})}),"\n",(0,l.jsxs)(e.blockquote,{children:["\n",(0,l.jsx)(e.p,{children:"zoom(zoomTarget if, )"}),"\n"]}),"\n",(0,l.jsx)(e.p,{children:(0,l.jsx)(e.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,l.jsxs)(e.table,{children:[(0,l.jsx)(e.thead,{children:(0,l.jsxs)(e.tr,{children:[(0,l.jsx)(e.th,{children:"zoomTarget"}),(0,l.jsx)(e.th,{children:"if"}),(0,l.jsx)(e.th,{children:"set, instead of zooming with predefined speed, map will instantly zoom in to that zoom level"})]})}),(0,l.jsx)(e.tbody,{children:(0,l.jsxs)(e.tr,{children:[(0,l.jsx)(e.td,{children:"any"}),(0,l.jsx)(e.td,{children:"zoomTarget"}),(0,l.jsx)(e.td,{})]})})]}),"\n",(0,l.jsx)(e.p,{children:(0,l.jsx)(e.strong,{children:"Code"})}),"\n",(0,l.jsx)(e.pre,{children:(0,l.jsx)(e.code,{className:"language-lua",children:"function IngameMapElement:zoom(direction, zoomTarget)\n    -- No zooming if plaform does not support it\n        if not Platform.ingameMap.canZoom then\n            return\n        end\n\n        -- Find the location pointed at by the cursor so we can zoom towards it\n        local targetX, targetZ = self:localToWorldPos( self:getLocalPointerTarget())\n\n        local width, height = self.ingameMap.fullScreenLayout:getMapSize()\n\n        -- Zoom by a set factor, or instantly to specified level if zoomTarget is set\n            local oldZoom = self.mapZoom\n            local speed = self.zoomSpeedFactor * direction * width -- multiply by size to mimic a constant scroll\n\n            if zoomTarget ~ = nil then\n                self.mapZoom = math.clamp(zoomTarget, self.zoomMin, self.zoomMax)\n            else\n                    self.mapZoom = math.clamp( self.mapZoom + speed, self.zoomMin, self.zoomMax)\n                end\n\n                self.ingameMap.fullScreenLayout:setMapZoom( self.mapZoom)\n\n                -- Size depends on zoom, center bounds depend on size.So clamp the center\n                self:moveCenter( 0 , 0 )\n\n                -- Do not change focus position if we did not change zoom\n                    if oldZoom ~ = self.mapZoom then\n                        -- Find the location the mouseis pointing at now\n                        local newTargetX, newTargetZ = self:localToWorldPos( self:getLocalPointerTarget())\n\n                        -- Above location is wrong.We want it to point at the same location as before, so find the different for moving\n                            local diffX, diffZ = newTargetX - targetX, newTargetZ - targetZ\n\n                            -- The diff is in world coordinates.Transform it to screenspace.\n                            local dx, dy = diffX / self.terrainSize * 0.5 * width, - diffZ / self.terrainSize * 0.5 * height\n\n                            self.cursorOffsetX = self.cursorOffsetX + dx\n                            self.cursorOffsetY = self.cursorOffsetY + dy\n\n                            local mapLayout = self.ingameMap.fullScreenLayout\n\n                            local centerX, centerY = mapLayout.mapCenterX, mapLayout.mapCenterY\n\n                            self:moveCenter(dx, dy)\n\n                            local newCenterX, newCenterY = mapLayout.mapCenterX, mapLayout.mapCenterY\n\n                            if direction < 0 then\n                                self.cursorOffsetX = self.cursorOffsetX - newCenterX + centerX + dx\n                                self.cursorOffsetY = self.cursorOffsetY - newCenterY + centerY + dy\n                            end\n                        end\n                    end\n\n"})})]})}function h(n={}){const{wrapper:e}={...(0,i.R)(),...n.components};return e?(0,l.jsx)(e,{...n,children:(0,l.jsx)(d,{...n})}):d(n)}}}]);