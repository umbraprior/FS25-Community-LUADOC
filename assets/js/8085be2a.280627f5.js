"use strict";(globalThis.webpackChunkfs25_community_luadoc=globalThis.webpackChunkfs25_community_luadoc||[]).push([[1402],{28453(e,n,t){t.d(n,{R:()=>r,x:()=>o});var i=t(96540);const l={},s=i.createContext(l);function r(e){const n=i.useContext(s);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(l):e.components||l:r(e.components),i.createElement(s.Provider,{value:n},e.children)}},71549(e,n,t){t.r(n),t.d(n,{assets:()=>a,contentTitle:()=>o,default:()=>h,frontMatter:()=>r,metadata:()=>i,toc:()=>d});const i=JSON.parse('{"id":"script/AI/AIDriveStrategyFieldCourse","title":"AIDriveStrategyFieldCourse","description":"AIDriveStrategyFieldCourse","source":"@site/../docs/script/AI/AIDriveStrategyFieldCourse.md","sourceDirName":"script/AI","slug":"/script/AI/AIDriveStrategyFieldCourse","permalink":"/FS25-Community-LUADOC/script/AI/AIDriveStrategyFieldCourse","draft":false,"unlisted":false,"tags":[],"version":"current","lastUpdatedAt":1767161192000,"frontMatter":{},"sidebar":"docsSidebar","previous":{"title":"AIDriveStrategyConveyor","permalink":"/FS25-Community-LUADOC/script/AI/AIDriveStrategyConveyor"},"next":{"title":"AIDriveStrategyStonePicker","permalink":"/FS25-Community-LUADOC/script/AI/AIDriveStrategyStonePicker"}}');var l=t(74848),s=t(28453);const r={},o=void 0,a={},d=[{value:"AIDriveStrategyFieldCourse",id:"aidrivestrategyfieldcourse",level:2},{value:"delete",id:"delete",level:3},{value:"fillReconstructionData",id:"fillreconstructiondata",level:3},{value:"getDriveData",id:"getdrivedata",level:3},{value:"loadFromXML",id:"loadfromxml",level:3},{value:"new",id:"new",level:3},{value:"onFieldCourseLoadedCallback",id:"onfieldcourseloadedcallback",level:3},{value:"registerSavegameXMLPaths",id:"registersavegamexmlpaths",level:3},{value:"saveToXML",id:"savetoxml",level:3},{value:"setAIVehicle",id:"setaivehicle",level:3},{value:"update",id:"update",level:3}];function c(e){const n={a:"a",blockquote:"blockquote",code:"code",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,s.R)(),...e.components};return(0,l.jsxs)(l.Fragment,{children:[(0,l.jsx)(n.h2,{id:"aidrivestrategyfieldcourse",children:"AIDriveStrategyFieldCourse"}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Description"})}),"\n",(0,l.jsxs)(n.blockquote,{children:["\n",(0,l.jsx)(n.p,{children:"Copyright (C) GIANTS Software GmbH, Confidential, All Rights Reserved."}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Parent"})}),"\n",(0,l.jsxs)(n.blockquote,{children:["\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.a,{href:"?version=script&category=4&class=150",children:"AIDriveStrategy"})}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Functions"})}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsx)(n.li,{children:(0,l.jsx)(n.a,{href:"#delete",children:"delete"})}),"\n",(0,l.jsx)(n.li,{children:(0,l.jsx)(n.a,{href:"#fillreconstructiondata",children:"fillReconstructionData"})}),"\n",(0,l.jsx)(n.li,{children:(0,l.jsx)(n.a,{href:"#getdrivedata",children:"getDriveData"})}),"\n",(0,l.jsx)(n.li,{children:(0,l.jsx)(n.a,{href:"#loadfromxml",children:"loadFromXML"})}),"\n",(0,l.jsx)(n.li,{children:(0,l.jsx)(n.a,{href:"#new",children:"new"})}),"\n",(0,l.jsx)(n.li,{children:(0,l.jsx)(n.a,{href:"#onfieldcourseloadedcallback",children:"onFieldCourseLoadedCallback"})}),"\n",(0,l.jsx)(n.li,{children:(0,l.jsx)(n.a,{href:"#registersavegamexmlpaths",children:"registerSavegameXMLPaths"})}),"\n",(0,l.jsx)(n.li,{children:(0,l.jsx)(n.a,{href:"#savetoxml",children:"saveToXML"})}),"\n",(0,l.jsx)(n.li,{children:(0,l.jsx)(n.a,{href:"#setaivehicle",children:"setAIVehicle"})}),"\n",(0,l.jsx)(n.li,{children:(0,l.jsx)(n.a,{href:"#update",children:"update"})}),"\n"]}),"\n",(0,l.jsx)(n.h3,{id:"delete",children:"delete"}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Description"})}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Definition"})}),"\n",(0,l.jsxs)(n.blockquote,{children:["\n",(0,l.jsx)(n.p,{children:"delete()"}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Code"})}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-lua",children:"function AIDriveStrategyFieldCourse:delete()\n    AIDriveStrategyFieldCourse:superClass().delete( self )\n\n    for _, implement in ipairs( self.vehicle:getAttachedAIImplements()) do\n        implement.object:aiImplementEndLine()\n\n        local rootVehicle = implement.object.rootVehicle\n        rootVehicle:raiseStateChange(VehicleStateChange.AI_END_LINE)\n    end\nend\n\n"})}),"\n",(0,l.jsx)(n.h3,{id:"fillreconstructiondata",children:"fillReconstructionData"}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Description"})}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Definition"})}),"\n",(0,l.jsxs)(n.blockquote,{children:["\n",(0,l.jsx)(n.p,{children:"fillReconstructionData()"}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,l.jsx)(n.table,{children:(0,l.jsx)(n.thead,{children:(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.th,{children:"any"}),(0,l.jsx)(n.th,{children:"data"})]})})}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Code"})}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-lua",children:"function AIDriveStrategyFieldCourse:fillReconstructionData(data)\n    if self.aiFieldCourse ~ = nil then\n        data.aiFieldCourseReconstructionData = AIFieldCourseReconstructionData.new()\n        data.aiFieldCourseReconstructionData:setDataByAIFieldCourse( self.aiFieldCourse)\n    end\nend\n\n"})}),"\n",(0,l.jsx)(n.h3,{id:"getdrivedata",children:"getDriveData"}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Description"})}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Definition"})}),"\n",(0,l.jsxs)(n.blockquote,{children:["\n",(0,l.jsx)(n.p,{children:"getDriveData()"}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,l.jsxs)(n.table,{children:[(0,l.jsx)(n.thead,{children:(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.th,{children:"any"}),(0,l.jsx)(n.th,{children:"dt"})]})}),(0,l.jsxs)(n.tbody,{children:[(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{children:"any"}),(0,l.jsx)(n.td,{children:"vX"})]}),(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{children:"any"}),(0,l.jsx)(n.td,{children:"vY"})]}),(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{children:"any"}),(0,l.jsx)(n.td,{children:"vZ"})]})]})]}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Code"})}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-lua",children:'function AIDriveStrategyFieldCourse:getDriveData(dt, vX, vY, vZ)\n    if self.fieldDetectionInProgress = = nil then\n        if self.fieldNotOwned then\n            self.vehicle:stopCurrentAIJob( AIMessageErrorFieldNotOwned.new())\n            self:debugPrint( "Stopping AIVehicle - Field not owned" )\n        else\n                self.vehicle:stopCurrentAIJob( AIMessageErrorNoFieldFound.new())\n                self:debugPrint( "Stopping AIVehicle - Failed to start field detection" )\n            end\n\n            return\n        end\n\n        local isTurning, _ = false , nil\n        if self.aiFieldCourse ~ = nil then\n            isTurning, _, _, _, _, _ = self.aiFieldCourse:getActiveSegmentData()\n        end\n\n        local tX, tZ, moveForwards, maxSpeed, distanceToStop = 0 , 0 , true , 0 , 0\n\n        local canContinueWork, stopAI, stopReason = self.vehicle:getCanAIFieldWorkerContinueWork(isTurning)\n        if not canContinueWork then\n            self.lastContinueWorkState = false\n            self.lastContinueWorkBlockedTime = g_ time\n\n            if VehicleDebug.state = = VehicleDebug.DEBUG_AI then\n                self.vehicle:addAIDebugText( "- Wait for turn on(getCanAIFieldWorkerContinueWork)" )\n                end\n\n                maxSpeed = 0\n\n                if stopAI then\n                    self.vehicle:stopCurrentAIJob(stopReason or AIMessageErrorUnknown.new())\n                    self:debugPrint( "Stopping AIVehicle - cannot continue work" )\n                end\n\n                return tX, tZ, moveForwards, maxSpeed, distanceToStop\n            else\n                    self.lastContinueWorkState = true\n                end\n\n                if VehicleDebug.state = = VehicleDebug.DEBUG_AI then\n                    if self.aiFieldCourse ~ = nil then\n                        self.aiFieldCourse:addDebugTexts( self.vehicle)\n                    end\n\n                    self.vehicle:addAIDebugText( string.format( " Has Static Collision: %s" , self.hasStaticCollision))\n                    self.vehicle:addAIDebugText( string.format( " Collision Distance:dynamic: %.1f static: %.1f" , self.collisionHandler.dynamicHitPointDistance, self.collisionHandler.staticHitPointDistance))\n                    self.vehicle:addAIDebugText( string.format( " Is Blocked: %s" , self.isBlocked))\n                    self.vehicle:addAIDebugText( string.format( " Distance To Collision: %s" , self.collisionDistance))\n\n                    if self.aiFieldCourse ~ = nil then\n                        local aiImplements = self.vehicle:getAttachedAIImplements()\n                        for i, implement in ipairs(aiImplements) do\n                            local leftMarker, rightMarker, backMarker, _ = implement.object:getAIMarkers()\n                            local lx, _, lz = getWorldTranslation(leftMarker)\n                            local rx, _, rz = getWorldTranslation(rightMarker)\n                            local leftOffset = self.aiFieldCourse:getPositionOffsetToActiveSegment(lx, lz)\n                            local rightOffset = self.aiFieldCourse:getPositionOffsetToActiveSegment(rx, rz)\n\n                            local _, _, maxZOffset = localToLocal(leftMarker, self.vehicleAISteeringNode, 0 , 0 , 0 )\n                            local _, _, minZOffset = localToLocal(backMarker, self.vehicleAISteeringNode, 0 , 0 , 0 )\n\n                            self.vehicle:addAIDebugText( string.format( "%s" , implement.object:getName()))\n                            self.vehicle:addAIDebugText( string.format( " Side Drift: %.2fm | Width: %.2fm" , (leftOffset + rightOffset) * 0.5 * - 1 , calcDistanceFrom(leftMarker, rightMarker)))\n                            self.vehicle:addAIDebugText( string.format( " zOffset: %.2fm / %.2fm" , minZOffset, maxZOffset))\n                        end\n\n                        self.vehicle:addAIDebugText( string.format( " Segment Side Offset: %.2f" , self.aiFieldCourse:getActiveSegmentSideOffset()))\n                    end\n                end\n\n                if self.isBlocked then\n                    return tX, tZ, moveForwards, maxSpeed, distanceToStop\n                end\n\n                if self.aiFieldCourse ~ = nil then\n                    local steeringOffset = 4\n                    vX, vY, vZ = getWorldTranslation( self.lastMovingDirection > 0 and self.vehicleAISteeringNode or self.vehicleAISteeringNodeReverse)\n\n                    tX, tZ, moveForwards, maxSpeed, distanceToStop = self.aiFieldCourse:getDriveData(dt, vX, vY, vZ, self.vehicle:getLastSpeed(), steeringOffset, self.reverserDirectionNodeRefNode)\n\n                    if tX ~ = nil and(tX ~ = 0 or tZ ~ = 0 ) then\n                        if not moveForwards and self.reverserDirectionNode ~ = nil then\n                            local rx, _, rz = getWorldTranslation( self.reverserDirectionNode)\n                            local revDistance = MathUtil.vector2Length(tX - rx, tZ - rz)\n\n                            local dirX1, _, dirZ1 = localDirectionToWorld( self.vehicleAISteeringNodeReverse, 0 , 0 , 1 )\n                            local length1 = MathUtil.vector2Length(dirX1, dirZ1)\n\n                            local dirX2, _, dirZ2 = localDirectionToWorld( self.reverserDirectionNode, 0 , 0 , 1 )\n                            local length2 = MathUtil.vector2Length(dirX2, dirZ2)\n\n                            if length1 > 0 and length2 > 0 then\n                                dirX1, dirZ1 = dirX1 / length1, dirZ1 / length1\n                                dirX2, dirZ2 = dirX2 / length2, dirZ2 / length2\n\n                                local z = MathUtil.getProjectOnLineParameter(tX, tZ, rx, rz, dirX2, dirZ2)\n                                local x = math.sqrt(revDistance * revDistance - z * z)\n\n                                local sDirX, sDirZ = MathUtil.vector2Normalize(rx - tX, rz - tZ)\n                                x = x * math.sign( MathUtil.dotProduct( - dirZ2, 0 , dirX2, sDirX, 0 , sDirZ))\n\n                                local angle = MathUtil.getSignedAngleBetweenVectors2D(dirX1, dirZ1, dirX2, dirZ2)\n\n                                local ltX = math.cos(angle) * x - math.sin(angle) * z\n                                local ltZ = math.sin(angle) * x + math.cos(angle) * z\n\n                                if not MathUtil.isNan(ltX) and not MathUtil.isNan(ltZ) then\n                                    tX, _, tZ = localToWorld( self.vehicleAISteeringNodeReverse, - ltX, 0 , ltZ)\n                                end\n                            end\n                        end\n\n                        if VehicleDebug.state = = VehicleDebug.DEBUG_AI then\n                            local _, _, segmentPosition, segmentLength, subSegmentPosition, subSegmentLength = self.aiFieldCourse:getActiveSegmentData()\n                            if segmentPosition ~ = nil then\n                                self.vehicle:addAIDebugText( string.format( "Segment Position: %.1f%% of %.1fm" , segmentPosition * 100 , segmentLength))\n                                if subSegmentLength ~ = segmentLength then\n                                    self.vehicle:addAIDebugText( string.format( "Sub Segment Position: %.1f%% of %.1fm" , subSegmentPosition * 100 , subSegmentLength))\n                                end\n                            end\n                        end\n\n                        self.lastVehiclePosition[ 1 ] = vX\n                        self.lastVehiclePosition[ 2 ] = vY\n                        self.lastVehiclePosition[ 3 ] = vZ\n                        self.lastTargetPosition[ 1 ] = tX\n                        self.lastTargetPosition[ 2 ] = vY\n                        self.lastTargetPosition[ 3 ] = tZ\n                        self.lastMovingDirection = moveForwards and 1 or - 1\n                    end\n                end\n\n                if self.collisionDistance ~ = math.huge and moveForwards then\n                    maxSpeed = math.min(maxSpeed, math.max( self.collisionDistance * 2 , 1 ))\n                end\n\n                return tX, tZ, moveForwards, maxSpeed, distanceToStop\n            end\n\n'})}),"\n",(0,l.jsx)(n.h3,{id:"loadfromxml",children:"loadFromXML"}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Description"})}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Definition"})}),"\n",(0,l.jsxs)(n.blockquote,{children:["\n",(0,l.jsx)(n.p,{children:"loadFromXML()"}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,l.jsxs)(n.table,{children:[(0,l.jsx)(n.thead,{children:(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.th,{children:"any"}),(0,l.jsx)(n.th,{children:"data"})]})}),(0,l.jsxs)(n.tbody,{children:[(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{children:"any"}),(0,l.jsx)(n.td,{children:"xmlFile"})]}),(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{children:"any"}),(0,l.jsx)(n.td,{children:"key"})]})]})]}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Code"})}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-lua",children:'function AIDriveStrategyFieldCourse.loadFromXML(data, xmlFile, key)\n    data.aiFieldCourseReconstructionData = AIFieldCourseReconstructionData.new()\n    if not data.aiFieldCourseReconstructionData:loadFromXML(xmlFile, key .. ".strategyFieldCourse" ) then\n        data.aiFieldCourseReconstructionData = nil\n    end\nend\n\n'})}),"\n",(0,l.jsx)(n.h3,{id:"new",children:"new"}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Description"})}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Definition"})}),"\n",(0,l.jsxs)(n.blockquote,{children:["\n",(0,l.jsx)(n.p,{children:"new()"}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,l.jsxs)(n.table,{children:[(0,l.jsx)(n.thead,{children:(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.th,{children:"any"}),(0,l.jsx)(n.th,{children:"reconstructionData"})]})}),(0,l.jsx)(n.tbody,{children:(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{children:"any"}),(0,l.jsx)(n.td,{children:"customMt"})]})})]}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Code"})}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-lua",children:"function AIDriveStrategyFieldCourse.new(reconstructionData, customMt)\n    local self = AIDriveStrategy.new(reconstructionData, customMt or AIDriveStrategyFieldCourse _mt)\n\n    self.collisionHandler = AICollisionTriggerHandler.new()\n\n    self.isBlocked = false\n    self.hasStaticCollision = false\n    self.hasStaticCollisionTimer = 0\n    self.collisionDistance = math.huge\n\n    self.lastContinueWorkState = false\n    self.lastContinueWorkBlockedTime = - math.huge\n\n    self.reconstructionData = reconstructionData\n\n    return self\nend\n\n"})}),"\n",(0,l.jsx)(n.h3,{id:"onfieldcourseloadedcallback",children:"onFieldCourseLoadedCallback"}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Description"})}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Definition"})}),"\n",(0,l.jsxs)(n.blockquote,{children:["\n",(0,l.jsx)(n.p,{children:"onFieldCourseLoadedCallback()"}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,l.jsx)(n.table,{children:(0,l.jsx)(n.thead,{children:(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.th,{children:"any"}),(0,l.jsx)(n.th,{children:"fieldCourse"})]})})}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Code"})}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-lua",children:'function AIDriveStrategyFieldCourse:onFieldCourseLoadedCallback(fieldCourse)\n    if self.vehicle.isDeleted or self.vehicle.isDeleting then\n        return\n    end\n\n    if fieldCourse ~ = nil then\n        -- callback is allowed with pre adjusted AIFieldCourse as well(from savegame)\n        local aiFieldCourse = nil\n        if ClassUtil.getClassObjectByObject(fieldCourse) = = FieldCourse then\n            aiFieldCourse = AIFieldCourse.new(fieldCourse)\n        else\n                aiFieldCourse = fieldCourse\n                fieldCourse = aiFieldCourse.fieldCourse\n            end\n\n            if fieldCourse.isVineyardCourse then\n                self.vehicle:stopCurrentAIJob( AIMessageErrorVineyardNotSupported.new())\n                self:debugPrint( "Stopping AIVehicle - Vineyard course not supported" )\n                return\n            end\n\n            local _\n\n            local aiRootNode = self.vehicle:getAIDirectionNode()\n            self.startX, _, self.startZ = localToWorld(aiRootNode, 0 , 0 , 0 )\n            local dx, _, dz = localDirectionToWorld(aiRootNode, 0 , 0 , 1 )\n            self.startYRot = MathUtil.getYRotationFromDirection(dx, dz)\n\n            local attachedAIImplements = self.vehicle:getAttachedAIImplements()\n\n            aiFieldCourse:setStartPosition( self.startX, self.startZ, self.startYRot)\n\n            self:debugPrint( " Start Position: %.3f %.3f(%.3f\xb0)" , self.startX, self.startZ, math.deg( self.startYRot))\n\n            self.aiFieldCourse = aiFieldCourse\n\n            aiFieldCourse:setInitialSegmentCallback( function ()\n                self.initialSegmentFinished = true\n\n                if not self.fieldCourseSettings.workInitialSegment then\n                    self.vehicle:raiseAIEvent( "onAIFieldWorkerPrepareForWork" , "onAIImplementPrepareForWork" )\n                end\n            end )\n\n            aiFieldCourse:setSegmentAreaValidityFunction( function (startWorldX, startWorldZ, widthWorldX, widthWorldZ, heightWorldX, heightWorldZ)\n                for i, implement in ipairs(attachedAIImplements) do\n                    local area, totalArea = AIVehicleUtil.getAIAreaOfVehicle(implement.object, startWorldX, startWorldZ, widthWorldX, widthWorldZ, heightWorldX, heightWorldZ)\n                    if totalArea > 0 and area / totalArea > 0 then\n                        return true\n                    end\n                end\n\n                return false\n            end )\n\n            if self.fieldCourseSettings.workInitialSegment then\n                self.vehicle:raiseAIEvent( "onAIFieldWorkerPrepareForWork" , "onAIImplementPrepareForWork" )\n            end\n\n            aiFieldCourse:finalize( function ()\n                if #aiFieldCourse.fieldCourse.segments = = 0 then\n                    self.vehicle:stopCurrentAIJob( AIMessageErrorFieldNotReady.new())\n                    return\n                end\n\n                self.fieldDetectionInProgress = false\n            end )\n        else\n                self.vehicle:stopCurrentAIJob( AIMessageErrorNoFieldFound.new())\n                self:debugPrint( "Stopping AIVehicle - Field boundary not detected" )\n            end\n        end\n\n'})}),"\n",(0,l.jsx)(n.h3,{id:"registersavegamexmlpaths",children:"registerSavegameXMLPaths"}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Description"})}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Definition"})}),"\n",(0,l.jsxs)(n.blockquote,{children:["\n",(0,l.jsx)(n.p,{children:"registerSavegameXMLPaths()"}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,l.jsxs)(n.table,{children:[(0,l.jsx)(n.thead,{children:(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.th,{children:"any"}),(0,l.jsx)(n.th,{children:"schema"})]})}),(0,l.jsx)(n.tbody,{children:(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{children:"any"}),(0,l.jsx)(n.td,{children:"basePath"})]})})]}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Code"})}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-lua",children:'function AIDriveStrategyFieldCourse.registerSavegameXMLPaths(schema, basePath)\n    AIFieldCourseReconstructionData.registerXMLPaths(schema, basePath .. ".strategyFieldCourse" )\nend\n\n'})}),"\n",(0,l.jsx)(n.h3,{id:"savetoxml",children:"saveToXML"}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Description"})}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Definition"})}),"\n",(0,l.jsxs)(n.blockquote,{children:["\n",(0,l.jsx)(n.p,{children:"saveToXML()"}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,l.jsxs)(n.table,{children:[(0,l.jsx)(n.thead,{children:(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.th,{children:"any"}),(0,l.jsx)(n.th,{children:"data"})]})}),(0,l.jsxs)(n.tbody,{children:[(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{children:"any"}),(0,l.jsx)(n.td,{children:"xmlFile"})]}),(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{children:"any"}),(0,l.jsx)(n.td,{children:"key"})]})]})]}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Code"})}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-lua",children:'function AIDriveStrategyFieldCourse.saveToXML(data, xmlFile, key)\n    if data.aiFieldCourseReconstructionData ~ = nil then\n        data.aiFieldCourseReconstructionData:saveToXML(xmlFile, key .. ".strategyFieldCourse" )\n    end\nend\n\n'})}),"\n",(0,l.jsx)(n.h3,{id:"setaivehicle",children:"setAIVehicle"}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Description"})}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Definition"})}),"\n",(0,l.jsxs)(n.blockquote,{children:["\n",(0,l.jsx)(n.p,{children:"setAIVehicle()"}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,l.jsx)(n.table,{children:(0,l.jsx)(n.thead,{children:(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.th,{children:"any"}),(0,l.jsx)(n.th,{children:"vehicle"})]})})}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Code"})}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-lua",children:'function AIDriveStrategyFieldCourse:setAIVehicle(vehicle)\n    AIDriveStrategyFieldCourse:superClass().setAIVehicle( self , vehicle)\n\n    self.collisionHandler:init(vehicle, self )\n\n    self.vehicleAISteeringNode = self.vehicle:getAISteeringNode()\n    self.vehicleAISteeringNodeReverse = self.vehicle:getAIReverserNode()\n\n    self.reverserDirectionNode = AIVehicleUtil.getAIToolReverserDirectionNode( self.vehicle)\n    self.reverserDirectionNodeRefNode = self.reverserDirectionNode -- ref node is only used a reference for the on-segment-position\n\n        if self.reverserDirectionNodeRefNode = = nil then\n            if self.vehicle.getAIToolReverserDirectionNode ~ = nil then\n                self.reverserDirectionNodeRefNode = self.vehicle:getAIToolReverserDirectionNode()\n            end\n\n            if self.reverserDirectionNodeRefNode = = nil then\n                if self.vehicleAISteeringNodeReverse ~ = self.vehicleAISteeringNode then\n                    self.reverserDirectionNodeRefNode = self.vehicleAISteeringNodeReverse\n                end\n            end\n        end\n\n        self.vehicle.aiDriveDirection = { 0 , 1 }\n        self.vehicle.aiDriveTarget = { 0 , 0 }\n\n        self.lastVehiclePosition = { 0 , 0 , 0 }\n        self.lastTargetPosition = { 0 , 0 , 1 }\n        self.lastMovingDirection = 1\n\n        self.lastSegmentIsTurn = false\n        self.nextSegmentTurnSide = nil\n        self.lastSegmentTurnSide = nil\n\n        self.vehicle:initializeLoadedAIModeUserSettings()\n        self.fieldCourseSettings = self.vehicle:getAIModeFieldCourseSettings()\n\n        if self.fieldCourseSettings ~ = nil then\n            self.implementData = self.fieldCourseSettings:resetDynamicSettings( self.vehicle)\n        else\n                self.fieldCourseSettings, self.implementData = FieldCourseSettings.generate( self.vehicle)\n            end\n\n            self.fieldCourseSettings:print( self.debugPrint, self )\n\n            local doFieldDetection = true\n            if self.reconstructionData ~ = nil then\n                if self.reconstructionData.aiFieldCourseReconstructionData ~ = nil then\n                    doFieldDetection = false\n\n                    Logging.devInfo( "Using field course data from savegame" )\n\n                    local vx, _, vz = localToWorld( self.vehicle:getAIDirectionNode(), 0 , 0 , 0 )\n\n                    self.fieldDetectionInProgress = true\n                    if not self.reconstructionData.aiFieldCourseReconstructionData:apply( self , self.onFieldCourseLoadedCallback, vx, vz) then\n                        self.fieldDetectionInProgress = nil\n                        doFieldDetection = true\n                    end\n                end\n            end\n\n            if doFieldDetection then\n                local notOwned = false\n                if AIDriveStrategyFieldCourse.fieldDetectionPosition = = nil then\n                    self.fieldDetectionX, self.fieldDetectionZ, notOwned = FieldCourse.findClosestField( nil , nil , nil , nil , self.vehicle:getAIJobFarmId(), self.vehicle, 2 , self.fieldCourseSettings)\n                else\n                        self.fieldDetectionX, self.fieldDetectionZ = AIDriveStrategyFieldCourse.fieldDetectionPosition[ 1 ], AIDriveStrategyFieldCourse.fieldDetectionPosition[ 2 ]\n                    end\n\n                    if self.fieldDetectionX ~ = nil and notOwned = = false then\n                        self.fieldDetectionInProgress = true\n\n                        g_fieldCourseManager:generateFieldCourseAtWorldPos( self.fieldDetectionX, self.fieldDetectionZ, self.fieldCourseSettings, self.onFieldCourseLoadedCallback, self )\n                    elseif notOwned then\n                            self.fieldNotOwned = true\n                        end\n                    end\n\n                    self.collisionHandler:setStaticCollisionCallback( function (hasStaticCollision)\n                        self.hasStaticCollision = hasStaticCollision\n                    end )\n                    self.collisionHandler:setIsBlockedCallback( function (isBlocked)\n                        self.isBlocked = isBlocked\n\n                        if g_server ~ = nil then\n                            g_server:broadcastEvent( AIVehicleIsBlockedEvent.new( self.vehicle, isBlocked), true , nil , self.vehicle)\n                        end\n                    end )\n                    self.collisionHandler:setCollisionDistanceCallback( function (distance)\n                        self.collisionDistance = distance\n                    end )\n                end\n\n'})}),"\n",(0,l.jsx)(n.h3,{id:"update",children:"update"}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Description"})}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Definition"})}),"\n",(0,l.jsxs)(n.blockquote,{children:["\n",(0,l.jsx)(n.p,{children:"update()"}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,l.jsx)(n.table,{children:(0,l.jsx)(n.thead,{children:(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.th,{children:"any"}),(0,l.jsx)(n.th,{children:"dt"})]})})}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Code"})}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-lua",children:"function AIDriveStrategyFieldCourse:update(dt)\n    self.collisionHandler:update(dt, self.lastMovingDirection)\n\n    if self.aiFieldCourse ~ = nil then\n        self.aiFieldCourse:update(dt)\n\n        if VehicleDebug.state = = VehicleDebug.DEBUG_AI and self.vehicle.isActiveForInputIgnoreSelectionIgnoreAI then\n            self.aiFieldCourse:draw()\n            self.fieldCourseSettings:draw()\n        end\n\n        local aiImplements = self.vehicle:getAttachedAIImplements()\n\n        local segmentIsTurn, segmentIsInitial, segmentPosition, _, _, _ = self.aiFieldCourse:getActiveSegmentData()\n        if segmentIsTurn ~ = nil then\n            local isInitial, sideOffset = self.aiFieldCourse:getNextSegmentData()\n            if not isInitial and sideOffset ~ = nil then\n                local nextSegmentTurnSide = sideOffset > 0\n                if nextSegmentTurnSide ~ = self.nextSegmentTurnSide then\n                    self.vehicle:aiFieldWorkerSideOffsetChanged(nextSegmentTurnSide, segmentIsInitial)\n                    self.nextSegmentTurnSide = nextSegmentTurnSide\n                end\n            end\n\n            if not segmentIsInitial or self.fieldCourseSettings.workInitialSegment then\n                if segmentIsTurn ~ = self.lastSegmentIsTurn then\n                    if segmentIsTurn then\n                        self.lastSegmentTurnSide = self.nextSegmentTurnSide\n                        self.vehicle:aiFieldWorkerStartTurn( self.lastSegmentTurnSide, nil )\n                    else\n                            self.vehicle:aiFieldWorkerEndTurn( self.lastSegmentTurnSide, nil )\n                        end\n\n                        self.lastSegmentIsTurn = segmentIsTurn\n                    elseif segmentIsTurn then\n                            self.vehicle:aiFieldWorkerTurnProgress(segmentPosition, self.lastSegmentTurnSide, self.lastMovingDirection)\n                        end\n\n                        for i, implement in ipairs(aiImplements) do\n                            local data = self.implementData[i]\n\n                            if not self.fieldCourseSettings.toolAlwaysActive then\n                                local doAreaCheck = false\n                                if segmentIsTurn or self.lastMovingDirection < 0 then\n                                    data.isLowered = false\n\n                                    -- for tools that can never reverse we check also on headlands if we have valid\n                                        -- ground below and lower the tool to work as much as we can\n                                        -- or if we have only a front tool mounted we work our path to the first segment\n                                            if ( not self.fieldCourseSettings.canTurnBackward and not self.fieldCourseSettings.allowStraightReversing)\n                                                or( self.fieldCourseSettings.workInitialSegment and segmentIsInitial and self.lastMovingDirection > 0 ) then\n                                                doAreaCheck = true\n                                            end\n                                        else\n                                                -- on the line we always do checks for valid ground and lower only if it was found\n                                                    -- have some delay between beeing blocked due to lowering/lifting and the next area checks\n                                                    -- to avoid changing of the area state during lowering/lifting\n                                                    doAreaCheck = g_ time - self.lastContinueWorkBlockedTime > 1000\n                                                end\n\n                                                if doAreaCheck then\n                                                    local leftMarker, rightMarker, backMarker, markersInverted = implement.object:getAIMarkers()\n                                                    local _, _, areaLength = localToLocal(leftMarker, backMarker, 0 , 0 , 0 )\n\n                                                    -- we apply a savety offset here cause on same implements the markers are moved on x axis while lifting the tool\n                                                        -- with this offset we don't check the next row\n                                                        local safetyOffset = 0.2\n\n                                                        local size = 3 + areaLength\n\n                                                        local getAreaDimensions = function (leftNode, rightNode, xOffset, zOffset, areaSize, invertXOffset)\n                                                            local xOffsetLeft, xOffsetRight = xOffset, xOffset\n                                                            if invertXOffset = = nil or invertXOffset then\n                                                                xOffsetLeft = - xOffsetLeft\n                                                            end\n\n                                                            if markersInverted then\n                                                                xOffsetLeft = - xOffsetLeft\n                                                                xOffsetRight = - xOffsetRight\n                                                            end\n\n                                                            local sX, _, sZ = localToWorld(leftNode, xOffsetLeft, 0 , zOffset)\n                                                            local hX, _, hZ = localToWorld(leftNode, xOffsetLeft, 0 , zOffset + areaSize)\n                                                            local wX, _, wZ = localToWorld(rightNode, xOffsetRight, 0 , zOffset)\n\n                                                            return sX, sZ, wX, wZ, hX, hZ\n                                                        end\n\n                                                        local sX, sZ, wX, wZ, hX, hZ = getAreaDimensions(leftMarker, rightMarker, safetyOffset, - areaLength, size)\n\n                                                        local area, totalArea = AIVehicleUtil.getAIAreaOfVehicle(implement.object, sX, sZ, wX, wZ, hX, hZ)\n                                                        if totalArea > 0 and area / totalArea > 0 then\n                                                            data.isLowered = true\n                                                        else\n                                                                data.isLowered = false\n                                                            end\n\n                                                            if VehicleDebug.state = = VehicleDebug.DEBUG_AI then\n                                                                local x, z, widthX, widthZ, heightX, heightZ = MathUtil.getXZWidthAndHeight(sX, sZ, wX, wZ, hX, hZ)\n                                                                DebugUtil.drawDebugParallelogram(x, z, widthX, widthZ, heightX, heightZ, 0.2 , data.isLowered and 0 or 1 , data.isLowered and 1 or 0 , 0 , 1 )\n                                                            end\n                                                        end\n                                                    else\n                                                            data.isLowered = not segmentIsTurn and self.lastMovingDirection > = 0\n                                                        end\n\n                                                        -- a implement always lowers it's parent(s) as well\n                                                        local currentData = data\n                                                        while currentData.parentAIImplement ~ = nil do\n                                                            if currentData.isLowered and not currentData.parentAIImplement.isLowered then\n                                                                currentData.parentAIImplement.isLowered = true\n                                                            end\n\n                                                            currentData = currentData.parentAIImplement\n                                                        end\n                                                    end\n                                                end\n                                            end\n\n                                            self.vehicle:setAIFieldWorkerIsTurning(segmentIsTurn)\n\n                                            local isCornerCutOutActive = self.aiFieldCourse:getIsCornerCutOutActive()\n                                            self.vehicle:setAIFieldWorkerIsCornerCutOutActive(isCornerCutOutActive)\n\n                                            for i, implement in ipairs(aiImplements) do\n                                                local data = self.implementData[i]\n\n                                                if data.isLowered then\n                                                    if data.wasLowered ~ = true then\n                                                        implement.object:aiImplementStartLine()\n\n                                                        local rootVehicle = implement.object:getRootVehicle()\n                                                        rootVehicle:raiseStateChange(VehicleStateChange.AI_START_LINE)\n                                                    end\n                                                else\n                                                        if data.wasLowered ~ = false then\n                                                            implement.object:aiImplementEndLine()\n\n                                                            local rootVehicle = implement.object:getRootVehicle()\n                                                            rootVehicle:raiseStateChange(VehicleStateChange.AI_END_LINE)\n                                                        end\n                                                    end\n\n                                                    data.wasLowered = data.isLowered\n                                                end\n\n                                                local vX, vY, vZ = self.lastVehiclePosition[ 1 ], self.lastVehiclePosition[ 2 ], self.lastVehiclePosition[ 3 ]\n                                                local tX, tY, tZ = self.lastTargetPosition[ 1 ], self.lastTargetPosition[ 2 ], self.lastTargetPosition[ 3 ]\n                                                local dx, dz = MathUtil.vector2Normalize(tX - vX, tZ - vZ)\n                                                local r, g, b = 0 , 1 , 0\n                                                if self.lastMovingDirection < 0 then\n                                                    r, g, b = 1 , 0 , 0\n                                                end\n                                                drawDebugTriangle(vX + dz * 0.25 , vY + 4 , vZ - dx * 0.25 , vX - dz * 0.25 , vY + 4 , vZ + dx * 0.25 , tX, tY + 4 , tZ, r, g, b, 0.2 , true )\n\n                                                if self.hasStaticCollision and self.lastContinueWorkState then\n                                                    if self.vehicle:getLastSpeed() < 1 then\n                                                        self.hasStaticCollisionTimer = self.hasStaticCollisionTimer + dt\n                                                        if self.hasStaticCollisionTimer > 5000 then\n                                                            self.hasStaticCollisionTimer = 0\n\n                                                            self.aiFieldCourse:skipCurrentSubSegment( 25 )\n                                                            self:debugPrint( \"AIVehicle blocked - skip current sub segment\" )\n                                                        end\n                                                    else\n                                                            self.hasStaticCollisionTimer = 0\n                                                        end\n                                                    else\n                                                            self.hasStaticCollisionTimer = 0\n                                                        end\n                                                    end\n                                                end\n\n"})})]})}function h(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,l.jsx)(n,{...e,children:(0,l.jsx)(c,{...e})}):c(e)}}}]);