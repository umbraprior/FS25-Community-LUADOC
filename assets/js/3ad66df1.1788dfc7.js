"use strict";(globalThis.webpackChunkfs25_community_luadoc=globalThis.webpackChunkfs25_community_luadoc||[]).push([[53940],{28453(e,n,l){l.d(n,{R:()=>t,x:()=>a});var i=l(96540);const s={},r=i.createContext(s);function t(e){const n=i.useContext(r);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:t(e.components),i.createElement(r.Provider,{value:n},e.children)}},57472(e,n,l){l.r(n),l.d(n,{assets:()=>o,contentTitle:()=>a,default:()=>c,frontMatter:()=>t,metadata:()=>i,toc:()=>d});const i=JSON.parse('{"id":"script/Specializations/Wheels","title":"Wheels","description":"Wheels","source":"@site/../docs/script/Specializations/Wheels.md","sourceDirName":"script/Specializations","slug":"/script/Specializations/Wheels","permalink":"/FS25-Community-LUADOC/script/Specializations/Wheels","draft":false,"unlisted":false,"tags":[],"version":"current","lastUpdatedAt":1767161192000,"frontMatter":{},"sidebar":"docsSidebar","previous":{"title":"Weeder","permalink":"/FS25-Community-LUADOC/script/Specializations/Weeder"},"next":{"title":"WindBending","permalink":"/FS25-Community-LUADOC/script/Specializations/WindBending"}}');var s=l(74848),r=l(28453);const t={},a=void 0,o={},d=[{value:"Wheels",id:"wheels",level:2},{value:"addToPhysics",id:"addtophysics",level:3},{value:"brake",id:"brake",level:3},{value:"createConfigToParentConfigMapping",id:"createconfigtoparentconfigmapping",level:3},{value:"forceUpdateWheelPhysics",id:"forceupdatewheelphysics",level:3},{value:"getAIDirectionNode",id:"getaidirectionnode",level:3},{value:"getAIRootNode",id:"getairootnode",level:3},{value:"getAreSurfaceSoundsActive",id:"getaresurfacesoundsactive",level:3},{value:"getBrakeForce",id:"getbrakeforce",level:3},{value:"getBrands",id:"getbrands",level:3},{value:"getComponentMass",id:"getcomponentmass",level:3},{value:"getCurrentSurfaceSound",id:"getcurrentsurfacesound",level:3},{value:"getIsVersatileYRotActive",id:"getisversatileyrotactive",level:3},{value:"getIsWheelChockAllowed",id:"getiswheelchockallowed",level:3},{value:"getSpecValueWheels",id:"getspecvaluewheels",level:3},{value:"getSteeringNodeByNode",id:"getsteeringnodebynode",level:3},{value:"getSteeringRotTimeByCurvature",id:"getsteeringrottimebycurvature",level:3},{value:"getSupportsMountKinematic",id:"getsupportsmountkinematic",level:3},{value:"getTireNames",id:"gettirenames",level:3},{value:"getTurningRadiusByRotTime",id:"getturningradiusbyrottime",level:3},{value:"getVehicleWorldDirection",id:"getvehicleworlddirection",level:3},{value:"getVehicleWorldXRot",id:"getvehicleworldxrot",level:3},{value:"getWheelByWheelNode",id:"getwheelbywheelnode",level:3},{value:"getWheelFromWheelIndex",id:"getwheelfromwheelindex",level:3},{value:"getWheels",id:"getwheels",level:3},{value:"getWheelsByBrand",id:"getwheelsbybrand",level:3},{value:"getWheelSuspensionModfier",id:"getwheelsuspensionmodfier",level:3},{value:"initSpecialization",id:"initspecialization",level:3},{value:"loadAckermannSteeringFromXML",id:"loadackermannsteeringfromxml",level:3},{value:"loadBendingNodeFromXML",id:"loadbendingnodefromxml",level:3},{value:"loadHubFromXML",id:"loadhubfromxml",level:3},{value:"loadHubMaterial",id:"loadhubmaterial",level:3},{value:"loadHubsFromXML",id:"loadhubsfromxml",level:3},{value:"loadSpecValueWheels",id:"loadspecvaluewheels",level:3},{value:"loadSpecValueWheelWeight",id:"loadspecvaluewheelweight",level:3},{value:"loadWheelFromXML",id:"loadwheelfromxml",level:3},{value:"loadWheelsFromXML",id:"loadwheelsfromxml",level:3},{value:"onAIFieldWorkerEnd",id:"onaifieldworkerend",level:3},{value:"onAIFieldWorkerStart",id:"onaifieldworkerstart",level:3},{value:"onAIImplementEnd",id:"onaiimplementend",level:3},{value:"onAIImplementStart",id:"onaiimplementstart",level:3},{value:"onDelete",id:"ondelete",level:3},{value:"onLeaveVehicle",id:"onleavevehicle",level:3},{value:"onLoad",id:"onload",level:3},{value:"onLoadFinished",id:"onloadfinished",level:3},{value:"onLoadWheelChockFromXML",id:"onloadwheelchockfromxml",level:3},{value:"onPostAttachImplement",id:"onpostattachimplement",level:3},{value:"onPostDetach",id:"onpostdetach",level:3},{value:"onPostUpdate",id:"onpostupdate",level:3},{value:"onPreAttach",id:"onpreattach",level:3},{value:"onPreLoad",id:"onpreload",level:3},{value:"onReadStream",id:"onreadstream",level:3},{value:"onReadUpdateStream",id:"onreadupdatestream",level:3},{value:"onRegisterAnimationValueTypes",id:"onregisteranimationvaluetypes",level:3},{value:"onRegisterDashboardValueTypes",id:"onregisterdashboardvaluetypes",level:3},{value:"onUpdate",id:"onupdate",level:3},{value:"onUpdateEnd",id:"onupdateend",level:3},{value:"onUpdateTick",id:"onupdatetick",level:3},{value:"onWheelHubI3DLoaded",id:"onwheelhubi3dloaded",level:3},{value:"onWheelSnowHeightChanged",id:"onwheelsnowheightchanged",level:3},{value:"onWriteStream",id:"onwritestream",level:3},{value:"onWriteUpdateStream",id:"onwriteupdatestream",level:3},{value:"prerequisitesPresent",id:"prerequisitespresent",level:3},{value:"registerAckermannSteeringXMLPaths",id:"registerackermannsteeringxmlpaths",level:3},{value:"registerEventListeners",id:"registereventlisteners",level:3},{value:"registerEvents",id:"registerevents",level:3},{value:"registerFunctions",id:"registerfunctions",level:3},{value:"registerOverwrittenFunctions",id:"registeroverwrittenfunctions",level:3},{value:"removeFromPhysics",id:"removefromphysics",level:3},{value:"saveToXMLFile",id:"savetoxmlfile",level:3},{value:"updateSteeringNodes",id:"updatesteeringnodes",level:3},{value:"updateWheelDirtAmount",id:"updatewheeldirtamount",level:3},{value:"updateWheelMudAmount",id:"updatewheelmudamount",level:3},{value:"validateWashableNode",id:"validatewashablenode",level:3}];function h(e){const n={a:"a",blockquote:"blockquote",code:"code",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,r.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.h2,{id:"wheels",children:"Wheels"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"Specialization extending a vehicle with wheels, including fruit destruction, wheel chocks, driving particles and\ntiretracks"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Functions"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#addtophysics",children:"addToPhysics"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#brake",children:"brake"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#createconfigtoparentconfigmapping",children:"createConfigToParentConfigMapping"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#forceupdatewheelphysics",children:"forceUpdateWheelPhysics"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#getaidirectionnode",children:"getAIDirectionNode"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#getairootnode",children:"getAIRootNode"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#getaresurfacesoundsactive",children:"getAreSurfaceSoundsActive"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#getbrakeforce",children:"getBrakeForce"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#getbrands",children:"getBrands"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#getcomponentmass",children:"getComponentMass"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#getcurrentsurfacesound",children:"getCurrentSurfaceSound"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#getisversatileyrotactive",children:"getIsVersatileYRotActive"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#getiswheelchockallowed",children:"getIsWheelChockAllowed"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#getspecvaluewheels",children:"getSpecValueWheels"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#getsteeringnodebynode",children:"getSteeringNodeByNode"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#getsteeringrottimebycurvature",children:"getSteeringRotTimeByCurvature"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#getsupportsmountkinematic",children:"getSupportsMountKinematic"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#gettirenames",children:"getTireNames"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#getturningradiusbyrottime",children:"getTurningRadiusByRotTime"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#getvehicleworlddirection",children:"getVehicleWorldDirection"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#getvehicleworldxrot",children:"getVehicleWorldXRot"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#getwheelbywheelnode",children:"getWheelByWheelNode"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#getwheelfromwheelindex",children:"getWheelFromWheelIndex"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#getwheels",children:"getWheels"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#getwheelsbybrand",children:"getWheelsByBrand"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#getwheelsuspensionmodfier",children:"getWheelSuspensionModfier"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#initspecialization",children:"initSpecialization"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#loadackermannsteeringfromxml",children:"loadAckermannSteeringFromXML"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#loadbendingnodefromxml",children:"loadBendingNodeFromXML"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#loadhubfromxml",children:"loadHubFromXML"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#loadhubmaterial",children:"loadHubMaterial"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#loadhubsfromxml",children:"loadHubsFromXML"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#loadspecvaluewheels",children:"loadSpecValueWheels"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#loadspecvaluewheelweight",children:"loadSpecValueWheelWeight"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#loadwheelfromxml",children:"loadWheelFromXML"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#loadwheelsfromxml",children:"loadWheelsFromXML"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#onaifieldworkerend",children:"onAIFieldWorkerEnd"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#onaifieldworkerstart",children:"onAIFieldWorkerStart"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#onaiimplementend",children:"onAIImplementEnd"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#onaiimplementstart",children:"onAIImplementStart"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#ondelete",children:"onDelete"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#onleavevehicle",children:"onLeaveVehicle"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#onload",children:"onLoad"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#onloadfinished",children:"onLoadFinished"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#onloadwheelchockfromxml",children:"onLoadWheelChockFromXML"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#onpostattachimplement",children:"onPostAttachImplement"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#onpostdetach",children:"onPostDetach"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#onpostupdate",children:"onPostUpdate"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#onpreattach",children:"onPreAttach"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#onpreload",children:"onPreLoad"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#onreadstream",children:"onReadStream"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#onreadupdatestream",children:"onReadUpdateStream"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#onregisteranimationvaluetypes",children:"onRegisterAnimationValueTypes"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#onregisterdashboardvaluetypes",children:"onRegisterDashboardValueTypes"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#onupdate",children:"onUpdate"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#onupdateend",children:"onUpdateEnd"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#onupdatetick",children:"onUpdateTick"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#onwheelhubi3dloaded",children:"onWheelHubI3DLoaded"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#onwheelsnowheightchanged",children:"onWheelSnowHeightChanged"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#onwritestream",children:"onWriteStream"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#onwriteupdatestream",children:"onWriteUpdateStream"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#prerequisitespresent",children:"prerequisitesPresent"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#registerackermannsteeringxmlpaths",children:"registerAckermannSteeringXMLPaths"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#registereventlisteners",children:"registerEventListeners"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#registerevents",children:"registerEvents"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#registerfunctions",children:"registerFunctions"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#registeroverwrittenfunctions",children:"registerOverwrittenFunctions"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#removefromphysics",children:"removeFromPhysics"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#savetoxmlfile",children:"saveToXMLFile"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#updatesteeringnodes",children:"updateSteeringNodes"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#updatewheeldirtamount",children:"updateWheelDirtAmount"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#updatewheelmudamount",children:"updateWheelMudAmount"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#validatewashablenode",children:"validateWashableNode"})}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"addtophysics",children:"addToPhysics"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Definition"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"addToPhysics()"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,s.jsx)(n.table,{children:(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"any"}),(0,s.jsx)(n.th,{children:"superFunc"})]})})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Code"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:"function Wheels:addToPhysics(superFunc)\n    if not superFunc( self ) then\n        return false\n    end\n\n    local spec = self.spec_wheels\n\n    local brakeForce = self:getBrakeForce()\n    for _, wheel in pairs(spec.wheels) do\n        wheel:addToPhysics(brakeForce)\n    end\n\n    if self.isServer then\n        self:brake(brakeForce)\n    end\n\n    return true\nend\n\n"})}),"\n",(0,s.jsx)(n.h3,{id:"brake",children:"brake"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Definition"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"brake()"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,s.jsx)(n.table,{children:(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"any"}),(0,s.jsx)(n.th,{children:"brakePedal"})]})})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Code"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:'function Wheels:brake(brakePedal)\n    local spec = self.spec_wheels\n    if brakePedal ~ = spec.brakePedal then\n        spec.brakePedal = brakePedal\n\n        for _,wheel in pairs(spec.wheels) do\n            wheel:setBrakePedal(spec.brakePedal)\n        end\n\n        SpecializationUtil.raiseEvent( self , "onBrake" , spec.brakePedal)\n    end\nend\n\n'})}),"\n",(0,s.jsx)(n.h3,{id:"createconfigtoparentconfigmapping",children:"createConfigToParentConfigMapping"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"Create wheel config save if mappings"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Definition"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"createConfigToParentConfigMapping(table xmlFile)"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n",(0,s.jsx)(n.table,{children:(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"table"}),(0,s.jsx)(n.th,{children:"xmlFile"}),(0,s.jsx)(n.th,{children:"xml file object"})]})})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Return Values"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"table"}),(0,s.jsx)(n.th,{children:"configurationSaveIdToIndex"}),(0,s.jsx)(n.th,{children:"save id to config index mapping"})]})}),(0,s.jsx)(n.tbody,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"table"}),(0,s.jsx)(n.td,{children:"configurationIndexToParentConfigIndex"}),(0,s.jsx)(n.td,{children:"config index to base config mapping"})]})})]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Code"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:'function Wheels.createConfigToParentConfigMapping(xmlFile)\n    local configurationSaveIdToIndex = { }\n    local configurationIndexToParentConfigIndex = { }\n\n    xmlFile:iterate( "vehicle.wheels.wheelConfigurations.wheelConfiguration" , function (index, key)\n        local saveId = xmlFile:getValue(key .. "#saveId" , tostring(index))\n        configurationSaveIdToIndex[saveId] = index\n    end )\n\n    xmlFile:iterate( "vehicle.wheels.wheelConfigurations.wheelConfiguration" , function (index, key)\n        XMLUtil.checkDeprecatedXMLElements(xmlFile, key .. ".wheels.foliageBendingModifier" , key .. ".foliageBendingModifier" ) --FS19 to FS22\n\n        local baseConfigId = xmlFile:getValue(key .. ".wheels#baseConfig" )\n        if baseConfigId ~ = nil then\n            local baseIndex = configurationSaveIdToIndex[baseConfigId]\n            if index = = baseIndex then\n                Logging.xmlError(xmlFile, "Wheel configuration %s references itself as baseConfig! Ignoring this reference" , key)\n            else\n                    configurationIndexToParentConfigIndex[index] = baseIndex\n                end\n            end\n        end )\n\n        return configurationIndexToParentConfigIndex\n    end\n\n'})}),"\n",(0,s.jsx)(n.h3,{id:"forceupdatewheelphysics",children:"forceUpdateWheelPhysics"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Definition"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"forceUpdateWheelPhysics()"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,s.jsx)(n.table,{children:(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"any"}),(0,s.jsx)(n.th,{children:"dt"})]})})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Code"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:"function Wheels:forceUpdateWheelPhysics(dt)\n    local spec = self.spec_wheels\n    for i = 1 , #spec.wheels do\n        spec.wheels[i]:updatePhysics( self:getBrakeForce())\n    end\nend\n\n"})}),"\n",(0,s.jsx)(n.h3,{id:"getaidirectionnode",children:"getAIDirectionNode"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Definition"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"getAIDirectionNode()"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,s.jsx)(n.table,{children:(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"any"}),(0,s.jsx)(n.th,{children:"superFunc"})]})})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Code"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:"function Wheels:getAIDirectionNode(superFunc)\n    return self.spec_wheels.steeringCenterNode or superFunc( self )\nend\n\n"})}),"\n",(0,s.jsx)(n.h3,{id:"getairootnode",children:"getAIRootNode"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Definition"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"getAIRootNode()"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,s.jsx)(n.table,{children:(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"any"}),(0,s.jsx)(n.th,{children:"superFunc"})]})})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Code"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:"function Wheels:getAIRootNode(superFunc)\n    return self.spec_wheels.steeringCenterNode or superFunc( self )\nend\n\n"})}),"\n",(0,s.jsx)(n.h3,{id:"getaresurfacesoundsactive",children:"getAreSurfaceSoundsActive"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Definition"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"getAreSurfaceSoundsActive()"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Code"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:"function Wheels:getAreSurfaceSoundsActive()\n    return self.isActiveForLocalSound\nend\n\n"})}),"\n",(0,s.jsx)(n.h3,{id:"getbrakeforce",children:"getBrakeForce"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Definition"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"getBrakeForce()"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Code"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:"function Wheels:getBrakeForce()\n    local spec = self.spec_wheels\n    return spec.customBrakeForce or 0\nend\n\n"})}),"\n",(0,s.jsx)(n.h3,{id:"getbrands",children:"getBrands"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Definition"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"getBrands()"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,s.jsx)(n.table,{children:(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"any"}),(0,s.jsx)(n.th,{children:"items"})]})})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Code"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:"function Wheels.getBrands(items)\n    local brands = { }\n    local addedBrands = { }\n    for _, item in ipairs(items) do\n        if item.isSelectable ~ = false and item.wheelBrandName ~ = nil and addedBrands[item.wheelBrandName] = = nil then\n            table.insert(brands, { title = item.wheelBrandName, icon = item.wheelBrandIconFilename } )\n            addedBrands[item.wheelBrandName] = true\n        end\n    end\n\n    return brands\nend\n\n"})}),"\n",(0,s.jsx)(n.h3,{id:"getcomponentmass",children:"getComponentMass"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"Returns total mass of vehicle (optional including attached vehicles)"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Definition"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"getComponentMass(boolean onlyGivenVehicle, )"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"boolean"}),(0,s.jsx)(n.th,{children:"onlyGivenVehicle"}),(0,s.jsx)(n.th,{children:"use only the given vehicle, if false or nil it includes all attachables"})]})}),(0,s.jsx)(n.tbody,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"any"}),(0,s.jsx)(n.td,{children:"component"}),(0,s.jsx)(n.td,{})]})})]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Return Values"})}),"\n\n\n\n\n\n\n\n\n",(0,s.jsx)(n.table,{children:(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"any"}),(0,s.jsx)(n.th,{children:"totalMass"}),(0,s.jsx)(n.th,{children:"total mass"})]})})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Code"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:"function Wheels:getComponentMass(superFunc, component)\n    local mass = superFunc( self , component)\n\n    local spec = self.spec_wheels\n    for _, wheel in pairs(spec.wheels) do\n        if wheel.node = = component.node then\n            mass = mass + wheel:getMass()\n        end\n    end\n\n    return mass\nend\n\n"})}),"\n",(0,s.jsx)(n.h3,{id:"getcurrentsurfacesound",children:"getCurrentSurfaceSound"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Definition"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"getCurrentSurfaceSound()"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Code"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:"function Wheels:getCurrentSurfaceSound()\n    local spec = self.spec_wheels\n\n    local numWheels = #spec.wheels\n    for i, wheel in ipairs(spec.wheels) do\n        if wheel.syncContactState or i = = numWheels then\n            local surfaceName, surfaceId = wheel.physics:getSurfaceSoundAttributes()\n            if surfaceName ~ = nil then\n                return spec.surfaceNameToSound[surfaceName]\n            elseif surfaceId ~ = nil then\n                    return spec.surfaceIdToSound[surfaceId]\n                end\n            end\n        end\n\n        return nil\n    end\n\n"})}),"\n",(0,s.jsx)(n.h3,{id:"getisversatileyrotactive",children:"getIsVersatileYRotActive"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Definition"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"getIsVersatileYRotActive()"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,s.jsx)(n.table,{children:(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"any"}),(0,s.jsx)(n.th,{children:"wheel"})]})})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Code"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:"function Wheels:getIsVersatileYRotActive(wheel)\n    return true\nend\n\n"})}),"\n",(0,s.jsx)(n.h3,{id:"getiswheelchockallowed",children:"getIsWheelChockAllowed"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Definition"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"getIsWheelChockAllowed()"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,s.jsx)(n.table,{children:(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"any"}),(0,s.jsx)(n.th,{children:"wheelChock"})]})})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Code"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:"function Wheels:getIsWheelChockAllowed(wheelChock)\n    return true\nend\n\n"})}),"\n",(0,s.jsx)(n.h3,{id:"getspecvaluewheels",children:"getSpecValueWheels"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Definition"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"getSpecValueWheels()"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"any"}),(0,s.jsx)(n.th,{children:"storeItem"})]})}),(0,s.jsx)(n.tbody,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"any"}),(0,s.jsx)(n.td,{children:"realItem"})]})})]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Code"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:'function Wheels.getSpecValueWheels(storeItem, realItem)\n    if realItem = = nil then\n        return nil\n    end\n\n    local tireNames = Wheels.getTireNames(realItem)\n    if tireNames = = nil then\n        return nil\n    end\n\n    return table.concatKeys(tireNames, " / " )\nend\n\n'})}),"\n",(0,s.jsx)(n.h3,{id:"getsteeringnodebynode",children:"getSteeringNodeByNode"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Definition"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"getSteeringNodeByNode()"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,s.jsx)(n.table,{children:(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"any"}),(0,s.jsx)(n.th,{children:"node"})]})})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Code"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:"function Wheels:getSteeringNodeByNode(node)\n    local spec = self.spec_wheels\n    for _, steeringNode in ipairs(spec.steeringNodes) do\n        if steeringNode.node = = node then\n            return steeringNode\n        end\n    end\n\n    return nil\nend\n\n"})}),"\n",(0,s.jsx)(n.h3,{id:"getsteeringrottimebycurvature",children:"getSteeringRotTimeByCurvature"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Definition"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"getSteeringRotTimeByCurvature()"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,s.jsx)(n.table,{children:(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"any"}),(0,s.jsx)(n.th,{children:"curvature"})]})})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Code"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:'function Wheels:getSteeringRotTimeByCurvature(curvature)\n    local targetRotTime = 0\n    if curvature ~ = 0 then\n        local spec = self.spec_wheels\n\n        targetRotTime = math.huge\n        if curvature > 0 then\n            targetRotTime = - math.huge\n        end\n        for i, wheel in ipairs(spec.wheels) do\n            if wheel.physics.rotSpeed ~ = 0 then\n                local diffX, _, diffZ = localToLocal(wheel.repr, spec.steeringCenterNode, 0 , 0 , 0 )\n                local targetRot = math.atan((diffZ * math.abs(curvature)) / (( 1 - math.abs(curvature) * math.abs(diffX))))\n                local wheelRotTime = targetRot / wheel.physics.rotSpeed\n                if curvature > 0 then\n                    wheelRotTime = - wheelRotTime\n                    targetRotTime = math.max(targetRotTime, wheelRotTime)\n                else\n                        targetRotTime = math.min(targetRotTime, wheelRotTime)\n                    end\n\n                end\n            end\n\n            targetRotTime = targetRotTime * - 1\n\n            -- log(string.format("Curvature %.4f , MaxCurvature %.4f, CalcTurnRadius %.3fm -> targetRot %.3f deg -> targetRotTime %.4f", curvature, maxCurvature, currentTurnRadius, math.deg(targetRot), targetRotTime))\n        end\n\n        return targetRotTime\n    end\n\n'})}),"\n",(0,s.jsx)(n.h3,{id:"getsupportsmountkinematic",children:"getSupportsMountKinematic"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Definition"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"getSupportsMountKinematic()"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,s.jsx)(n.table,{children:(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"any"}),(0,s.jsx)(n.th,{children:"superFunc"})]})})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Code"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:"function Wheels:getSupportsMountKinematic(superFunc)\n    return # self.spec_wheels.wheels = = 0 and superFunc( self )\nend\n\n"})}),"\n",(0,s.jsx)(n.h3,{id:"gettirenames",children:"getTireNames"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"Returns set of tire names used on the vehicle or nil if none are present"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Definition"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"getTireNames()"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,s.jsx)(n.table,{children:(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"any"}),(0,s.jsx)(n.th,{children:"instance"})]})})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Code"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:"function Wheels.getTireNames(instance)\n    local spec = instance.spec_wheels\n    if spec = = nil then\n        return nil\n    end\n\n    local tireNames = { }\n    for _, wheel in ipairs(spec.wheels) do\n        if wheel.name ~ = nil then\n            tireNames[wheel.name] = true\n        end\n    end\n    for _, dynLoadedWheel in ipairs(spec.dynamicallyLoadedWheels) do\n        if dynLoadedWheel.name ~ = nil then\n            tireNames[dynLoadedWheel.name] = true\n        end\n    end\n\n    if table.size(tireNames) = = 0 then\n        return nil\n    end\n\n    return tireNames\nend\n\n"})}),"\n",(0,s.jsx)(n.h3,{id:"getturningradiusbyrottime",children:"getTurningRadiusByRotTime"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Definition"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"getTurningRadiusByRotTime()"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,s.jsx)(n.table,{children:(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"any"}),(0,s.jsx)(n.th,{children:"rotTime"})]})})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Code"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:"function Wheels:getTurningRadiusByRotTime(rotTime)\n    local spec = self.spec_wheels\n\n    local maxTurningRadius = math.huge\n    if spec.steeringCenterNode ~ = nil then\n        for i, wheel in ipairs(spec.wheels) do\n            if wheel.physics.rotSpeed ~ = 0 then\n                local wheelRot = math.abs(rotTime * wheel.physics.rotSpeed)\n                if wheelRot > 0 then\n                    local diffX, _, diffZ = localToLocal(wheel.repr, spec.steeringCenterNode, 0 , 0 , 0 )\n                    local turningRadius = math.abs(diffZ) / math.tan(wheelRot) + math.abs(diffX)\n                    if turningRadius < maxTurningRadius then\n                        maxTurningRadius = turningRadius\n                    end\n                end\n            end\n        end\n    end\n\n    return maxTurningRadius\nend\n\n"})}),"\n",(0,s.jsx)(n.h3,{id:"getvehicleworlddirection",children:"getVehicleWorldDirection"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"Returns the world space direction of the vehicle"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Definition"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"getVehicleWorldDirection()"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,s.jsx)(n.table,{children:(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"any"}),(0,s.jsx)(n.th,{children:"superFunc"})]})})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Return Values"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"any"}),(0,s.jsx)(n.th,{children:"x"}),(0,s.jsx)(n.th,{children:"x"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"any"}),(0,s.jsx)(n.td,{children:"y"}),(0,s.jsx)(n.td,{children:"y"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"any"}),(0,s.jsx)(n.td,{children:"z"}),(0,s.jsx)(n.td,{children:"z"})]})]})]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Code"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:'function Wheels:getVehicleWorldDirection(superFunc)\n    local avgDirX, avgDirY, avgDirZ, _ = 0 , 0 , 0 , nil\n    local centerZ = 0\n    local contactedWheels = 0\n    local spec = self.spec_wheels\n    for i = 1 , #spec.wheels do\n        local wheel = spec.wheels[i]\n        if wheel.physics.hasGroundContact then\n            local netInfo = wheel.physics.netInfo\n            local _, _, z = localToLocal(wheel.node, self.components[ 1 ].node, netInfo.x, netInfo.y, netInfo.z)\n            centerZ = centerZ + z\n\n            local dx, dy, dz = localDirectionToWorld(wheel.node, wheel.physics.directionZ, wheel.physics.directionX, - wheel.physics.directionY)\n            avgDirX, avgDirY, avgDirZ = avgDirX + dx, avgDirY + dy, avgDirZ + dz\n\n            contactedWheels = contactedWheels + 1\n        end\n    end\n\n    if contactedWheels > 0 then\n        avgDirX, _, avgDirZ = avgDirX / contactedWheels, avgDirY / contactedWheels, avgDirZ / contactedWheels\n    end\n\n    if contactedWheels > 2 then\n        centerZ = centerZ / contactedWheels\n\n        local frontCenterX, frontCenterY, frontCenterZ, frontWheelsCount = 0 , 0 , 0 , 0\n        local backCenterX, backCenterY, backCenterZ, backWheelsCount = 0 , 0 , 0 , 0\n\n        for i = 1 , #spec.wheels do\n            local wheel = spec.wheels[i]\n            if wheel.physics.hasGroundContact then\n                local netInfo, radius = wheel.physics.netInfo, wheel.physics.radius\n                local x, y, z = localToLocal(wheel.node, self.components[ 1 ].node, netInfo.x + wheel.physics.directionX * radius, netInfo.y + wheel.physics.directionY * radius, netInfo.z + wheel.physics.directionZ * radius)\n\n                if z > centerZ + 0.25 then\n                    frontCenterX, frontCenterY, frontCenterZ, frontWheelsCount = frontCenterX + x, frontCenterY + y, frontCenterZ + z, frontWheelsCount + 1\n                elseif z < centerZ - 0.25 then\n                        backCenterX, backCenterY, backCenterZ, backWheelsCount = backCenterX + x, backCenterY + y, backCenterZ + z, backWheelsCount + 1\n                    end\n                end\n            end\n\n            if frontWheelsCount > 0 and backWheelsCount > 0 then\n                frontCenterX, frontCenterY, frontCenterZ = frontCenterX / frontWheelsCount, frontCenterY / frontWheelsCount, frontCenterZ / frontWheelsCount\n                backCenterX, backCenterY, backCenterZ = backCenterX / backWheelsCount, backCenterY / backWheelsCount, backCenterZ / backWheelsCount\n\n                frontCenterX, frontCenterY, frontCenterZ = localToWorld( self.components[ 1 ].node, frontCenterX, frontCenterY, frontCenterZ)\n                backCenterX, backCenterY, backCenterZ = localToWorld( self.components[ 1 ].node, backCenterX, backCenterY, backCenterZ)\n\n                if VehicleDebug.state = = VehicleDebug.DEBUG_TRANSMISSION then\n                    DebugGizmo.renderAtPosition(frontCenterX, frontCenterY, frontCenterZ, 1 , 0 , 0 , 0 , 1 , 0 , "frontWheels" )\n                    DebugGizmo.renderAtPosition(backCenterX, backCenterY, backCenterZ, 1 , 0 , 0 , 0 , 1 , 0 , "backWheels" )\n                end\n\n                local dx, dy, dz, _ = frontCenterX - backCenterX, frontCenterY - backCenterY, frontCenterZ - backCenterZ, nil\n                _, avgDirY, _ = MathUtil.vector3Normalize(dx, dy, dz)\n            else\n                    return superFunc( self )\n                end\n            else\n                    return 0 , 0 , 0\n                end\n\n                return MathUtil.vector3Normalize(avgDirX, avgDirY, avgDirZ)\n            end\n\n'})}),"\n",(0,s.jsx)(n.h3,{id:"getvehicleworldxrot",children:"getVehicleWorldXRot"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"Returns the world space x rotation in rad"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Definition"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"getVehicleWorldXRot()"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,s.jsx)(n.table,{children:(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"any"}),(0,s.jsx)(n.th,{children:"superFunc"})]})})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Return Values"})}),"\n\n\n\n\n\n\n\n\n",(0,s.jsx)(n.table,{children:(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"any"}),(0,s.jsx)(n.th,{children:"rotation"}),(0,s.jsx)(n.th,{children:"rotation"})]})})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Code"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:"function Wheels:getVehicleWorldXRot(superFunc)\n    local slopeAngle = 0\n    local minWheelZ = math.huge\n    local minWheelZHeight = 0\n    local maxWheelZ = - math.huge\n    local maxWheelZHeight = 0\n\n    local spec = self.spec_wheels\n    for i = 1 , #spec.wheels do\n        local wheel = spec.wheels[i]\n        if wheel.physics.hasGroundContact then\n            local netInfo, radius = wheel.physics.netInfo, wheel.physics.radius\n            local _, _, z = localToLocal(wheel.node, self.components[ 1 ].node, 0 , 0 , netInfo.z)\n            local _, wheelY, _ = localToWorld(wheel.node, netInfo.x, netInfo.y - radius, netInfo.z)\n            if z < minWheelZ then\n                minWheelZ = z\n                minWheelZHeight = wheelY\n            end\n            if z > maxWheelZ then\n                maxWheelZ = z\n                maxWheelZHeight = wheelY\n            end\n        end\n    end\n\n    if minWheelZ ~ = math.huge then\n        local y = maxWheelZHeight - minWheelZHeight\n        if y ~ = 0 then\n            local l = maxWheelZ - minWheelZ\n            if l < 0.25 and superFunc ~ = nil then\n                return superFunc( self )\n            end\n\n            slopeAngle = math.pi * 0.5 - math.atan(l / (y))\n            if slopeAngle > math.pi * 0.5 then\n                slopeAngle = slopeAngle - math.pi\n            end\n        end\n    end\n\n    return slopeAngle\nend\n\n"})}),"\n",(0,s.jsx)(n.h3,{id:"getwheelbywheelnode",children:"getWheelByWheelNode"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Definition"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"getWheelByWheelNode()"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,s.jsx)(n.table,{children:(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"any"}),(0,s.jsx)(n.th,{children:"wheelNode"})]})})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Code"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:'function Wheels:getWheelByWheelNode(wheelNode)\n    local spec = self.spec_wheels\n\n    if type(wheelNode) = = "string" then\n        local mapping = self.i3dMappings[wheelNode]\n        if mapping ~ = nil then\n            wheelNode = mapping.nodeId\n        end\n    end\n\n    for i = 1 , #spec.wheels do\n        local wheel = spec.wheels[i]\n        if wheel.repr = = wheelNode\n            or wheel.driveNode = = wheelNode\n            or wheel.linkNode = = wheelNode then\n            return wheel\n        end\n    end\n\n    return nil\nend\n\n'})}),"\n",(0,s.jsx)(n.h3,{id:"getwheelfromwheelindex",children:"getWheelFromWheelIndex"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Definition"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"getWheelFromWheelIndex()"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,s.jsx)(n.table,{children:(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"any"}),(0,s.jsx)(n.th,{children:"wheelIndex"})]})})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Code"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:"function Wheels:getWheelFromWheelIndex(wheelIndex)\n    return self.spec_wheels.wheels[wheelIndex]\nend\n\n"})}),"\n",(0,s.jsx)(n.h3,{id:"getwheels",children:"getWheels"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Definition"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"getWheels()"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Code"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:"function Wheels:getWheels()\n    return self.spec_wheels.wheels\nend\n\n"})}),"\n",(0,s.jsx)(n.h3,{id:"getwheelsbybrand",children:"getWheelsByBrand"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Definition"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"getWheelsByBrand()"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"any"}),(0,s.jsx)(n.th,{children:"items"})]})}),(0,s.jsx)(n.tbody,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"any"}),(0,s.jsx)(n.td,{children:"brand"})]})})]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Code"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:"function Wheels.getWheelsByBrand(items, brand)\n    local wheels = { }\n    for _, item in ipairs(items) do\n        if item.isSelectable ~ = false and item.wheelBrandName = = brand.title then\n            table.insert(wheels, item)\n        end\n    end\n\n    return wheels\nend\n\n"})}),"\n",(0,s.jsx)(n.h3,{id:"getwheelsuspensionmodfier",children:"getWheelSuspensionModfier"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Definition"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"getWheelSuspensionModfier()"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Code"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:"function Wheels:getWheelSuspensionModfier()\n    local spec = self.spec_wheels\n\n    local numWheels = #spec.wheels\n    if numWheels > 0 then\n        local totalDelta = 0\n        for _, wheel in ipairs(spec.wheels) do\n            totalDelta = totalDelta + (wheel.physics.deltaY - wheel.physics.netInfo.suspensionLength)\n        end\n\n        local averageDelta = totalDelta / numWheels\n\n        local maxDelta = 0\n        for _, wheel in ipairs(spec.wheels) do\n            local delta = averageDelta - (wheel.physics.deltaY - wheel.physics.netInfo.suspensionLength)\n            maxDelta = math.max( math.abs(delta), maxDelta)\n        end\n\n        return maxDelta\n    end\n\n    return 0\nend\n\n"})}),"\n",(0,s.jsx)(n.h3,{id:"initspecialization",children:"initSpecialization"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Definition"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"initSpecialization()"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Code"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:'function Wheels.initSpecialization()\n    g_vehicleConfigurationManager:addConfigurationType( "wheel" , g_i18n:getText( "configuration_wheelSetup" ), "wheels" , VehicleConfigurationItemWheel , g_i18n:getText( "configuration_wheelBrand" ), Wheels.getBrands, Wheels.getWheelsByBrand, 2 )\n    g_vehicleConfigurationManager:addConfigurationType( "rimColor" , g_i18n:getText( "configuration_rimColor" ), nil , VehicleConfigurationItemColor )\n\n    g_storeManager:addSpecType( "wheels" , "shopListAttributeIconWheels" , Wheels.loadSpecValueWheels, Wheels.getSpecValueWheels, StoreSpecies.VEHICLE)\n\n    g_storeManager:addVRamUsageFunction( Wheels.getVRamUsageFromXML)\n\n    local schema = Vehicle.xmlSchema\n    schema:setXMLSpecializationType( "Wheels" )\n\n    schema:register(XMLValueType.STRING, "vehicle.wheels.wheelConfigurations#tireCategories" , "List of tire categories to include in the automatic wheel config generation(separated by whitespace)" )\n    schema:register(XMLValueType.STRING_LIST, "vehicle.wheels.wheelConfigurations#customBrandOrder" , "Custom brand order for dynamic configurations(names of the brands separated by whitespace)" )\n        schema:register(XMLValueType.STRING, "vehicle.wheels.wheelConfigurations.tireCombination(?)#brand" , "Brand name of the combination" )\n        schema:register(XMLValueType.STRING, "vehicle.wheels.wheelConfigurations.tireCombination(?)#names" , "List of tire names that are allowed to be mixed.Otherwise all mixes are allowed.Does not effect configuration with all tires from the same name. (separated by whitespace)" )\n\n        schema:register(XMLValueType.INT, Wheels.CONFIG_XML_PATH .. "(?)#numDynamicConfigurations" , "Max.number of dynamic configurations per brand" , "unlimited" )\n        schema:register(XMLValueType.STRING, Wheels.CONFIG_XML_PATH .. "(?)#tireCategories" , "List of tire categories to include in the automatic wheel config generation(separated by whitespace)" )\n        schema:register(XMLValueType.STRING, Wheels.CONFIG_XML_PATH .. "(?).tireCombination(?)#brand" , "Brand name of the combination" )\n        schema:register(XMLValueType.STRING, Wheels.CONFIG_XML_PATH .. "(?).tireCombination(?)#names" , "List of tire names that are allowed to be mixed.Otherwise all mixes are allowed.Does not effect configuration with all tires from the same name. (separated by whitespace)" )\n\n        WheelAxle.registerXMLPaths(schema, "vehicle.wheels.axles.axle(?)" )\n        WheelAxle.registerXMLPaths(schema, Wheels.CONFIG_XML_PATH .. "(?).axle(?)" )\n\n        local configKey = Wheels.WHEELS_XML_PATH\n        schema:register(XMLValueType.FLOAT, configKey .. "#autoRotateBackSpeed" , "Auto rotate back speed" , 1 )\n        schema:register(XMLValueType.BOOL, configKey .. "#speedDependentRotateBack" , "Speed dependent auto rotate back speed" , true )\n        schema:register(XMLValueType.INT, configKey .. "#differentialIndex" , "Differential index" )\n        schema:register(XMLValueType.INT, configKey .. "#ackermannSteeringIndex" , "Ackermann steering index" )\n        schema:register(XMLValueType.FLOAT, configKey .. "#ackermannSteeringAngle" , "Ackermann steering angle to set while this config is active" )\n            schema:register(XMLValueType.BOOL, configKey .. "#isCareWheelConfiguration" , "All wheels will be care wheels" )\n            schema:register(XMLValueType.STRING, configKey .. "#baseConfig" , "Base for this configuration" )\n\n                schema:register(XMLValueType.BOOL, configKey .. "#hasSurfaceSounds" , "Has surface sounds" , true )\n                schema:register(XMLValueType.STRING, configKey .. "#surfaceSoundTireType" , "Tire type that is used for surface sounds" , "Tire type of first wheel" )\n                    schema:register(XMLValueType.NODE_INDEX, configKey .. "#surfaceSoundLinkNode" , "Surface sound link node" , "Root component" )\n\n                    Wheel.registerXMLPaths(schema, configKey .. ".wheel(?)" )\n\n                    VehicleMaterial.registerXMLPaths(schema, "vehicle.wheels.rimMaterial" )\n                    schema:register(XMLValueType.BOOL, "vehicle.wheels.rimMaterial#useBaseColor" , "Use base vehicle color" , false )\n                    schema:register(XMLValueType.INT, "vehicle.wheels.rimMaterial#useDesignColorIndex" , "Use color of the design color with the defined index(1-16)" )\n\n                    VehicleMaterial.registerXMLPaths(schema, "vehicle.wheels.innerRimMaterial" )\n                    schema:register(XMLValueType.BOOL, "vehicle.wheels.innerRimMaterial#useBaseColor" , "Use base vehicle color" , false )\n                    schema:register(XMLValueType.INT, "vehicle.wheels.innerRimMaterial#useDesignColorIndex" , "Use color of the design color with the defined index(1-16)" )\n\n                    VehicleMaterial.registerXMLPaths(schema, "vehicle.wheels.outerRimMaterial" )\n                    schema:register(XMLValueType.BOOL, "vehicle.wheels.outerRimMaterial#useBaseColor" , "Use base vehicle color" , false )\n                    schema:register(XMLValueType.INT, "vehicle.wheels.outerRimMaterial#useDesignColorIndex" , "Use color of the design color with the defined index(1-16)" )\n\n                    VehicleMaterial.registerXMLPaths(schema, "vehicle.wheels.additionalMaterial" )\n                    schema:register(XMLValueType.BOOL, "vehicle.wheels.additionalMaterial#useBaseColor" , "Use base vehicle color" , false )\n                    schema:register(XMLValueType.INT, "vehicle.wheels.additionalMaterial#useDesignColorIndex" , "Use color of the design color with the defined index(1-16)" )\n\n                    VehicleMaterial.registerXMLPaths(schema, "vehicle.wheels.hubMaterial" )\n                    schema:register(XMLValueType.BOOL, "vehicle.wheels.hubMaterial#useBaseColor" , "Use base vehicle color" , false )\n                    schema:register(XMLValueType.INT, "vehicle.wheels.hubMaterial#useDesignColorIndex" , "Use color of the design color with the defined index(1-16)" )\n                    schema:register(XMLValueType.BOOL, "vehicle.wheels.hubMaterial#useRimColor" , "Use rim color" , false )\n\n                    VehicleMaterial.registerXMLPaths(schema, "vehicle.wheels.hubBoltMaterial" )\n                    schema:register(XMLValueType.BOOL, "vehicle.wheels.hubBoltMaterial#useBaseColor" , "Use base vehicle color" , false )\n                    schema:register(XMLValueType.INT, "vehicle.wheels.hubBoltMaterial#useDesignColorIndex" , "Use color of the design color with the defined index(1-16)" )\n                    schema:register(XMLValueType.BOOL, "vehicle.wheels.hubBoltMaterial#useRimColor" , "Use rim color" , false )\n\n                    VehicleMaterial.registerXMLPaths(schema, "vehicle.wheels.hubs.material" )\n                    schema:register(XMLValueType.BOOL, "vehicle.wheels.hubs.material#useBaseColor" , "Use base vehicle color" , false )\n                    schema:register(XMLValueType.INT, "vehicle.wheels.hubs.material#useDesignColorIndex" , "Use color of the design color with the defined index(1-16)" )\n                    schema:register(XMLValueType.BOOL, "vehicle.wheels.hubs.material#useRimColor" , "Use rim color" , false )\n\n                    schema:register(XMLValueType.NODE_INDEX, "vehicle.wheels.hubs.hub(?)#linkNode" , "Link node" )\n                    schema:register(XMLValueType.STRING, "vehicle.wheels.hubs.hub(?)#filename" , "Filename" )\n                    schema:register(XMLValueType.BOOL, "vehicle.wheels.hubs.hub(?)#isLeft" , "Is left side" , false )\n                    schema:register(XMLValueType.FLOAT, "vehicle.wheels.hubs.hub(?)#offset" , "X axis offset" )\n                    schema:register(XMLValueType.VECTOR_SCALE, "vehicle.wheels.hubs.hub(?)#scale" , "Hub scale" )\n\n                    VehicleMaterial.registerXMLPaths(schema, "vehicle.wheels.hubs.hub(?).material" )\n                    schema:register(XMLValueType.BOOL, "vehicle.wheels.hubs.hub(?).material#useBaseColor" , "Use base vehicle color" , false )\n                    schema:register(XMLValueType.INT, "vehicle.wheels.hubs.hub(?).material#useDesignColorIndex" , "Use color of the design color with the defined index(1-16)" )\n                    schema:register(XMLValueType.BOOL, "vehicle.wheels.hubs.hub(?).material#useRimColor" , "Use rim color" , false )\n\n                    VehicleMaterial.registerXMLPaths(schema, "vehicle.wheels.hubs.hub(?).boltMaterial" )\n                    schema:register(XMLValueType.BOOL, "vehicle.wheels.hubs.hub(?).boltMaterial#useBaseColor" , "Use base vehicle color" , false )\n                    schema:register(XMLValueType.INT, "vehicle.wheels.hubs.hub(?).boltMaterial#useDesignColorIndex" , "Use color of the design color with the defined index(1-16)" )\n                    schema:register(XMLValueType.BOOL, "vehicle.wheels.hubs.hub(?).boltMaterial#useRimColor" , "Use rim color" , false )\n\n                    VehicleMaterial.registerXMLPaths(schema, "vehicle.wheels.hubs.hub(?).additionalMaterial" )\n                    schema:register(XMLValueType.BOOL, "vehicle.wheels.hubs.hub(?).additionalMaterial#useBaseColor" , "Use base vehicle color" , false )\n                    schema:register(XMLValueType.INT, "vehicle.wheels.hubs.hub(?).additionalMaterial#useDesignColorIndex" , "Use color of the design color with the defined index(1-16)" )\n                    schema:register(XMLValueType.BOOL, "vehicle.wheels.hubs.hub(?).additionalMaterial#useRimColor" , "Use rim color" , false )\n\n                    VehicleMaterial.registerXMLPaths(schema, "vehicle.wheels.hubs.hub(?).boltAdditionalMaterial" )\n                    schema:register(XMLValueType.BOOL, "vehicle.wheels.hubs.hub(?).boltAdditionalMaterial#useBaseColor" , "Use base vehicle color" , false )\n                    schema:register(XMLValueType.INT, "vehicle.wheels.hubs.hub(?).boltAdditionalMaterial#useDesignColorIndex" , "Use color of the design color with the defined index(1-16)" )\n                    schema:register(XMLValueType.BOOL, "vehicle.wheels.hubs.hub(?).boltAdditionalMaterial#useRimColor" , "Use rim color" , false )\n\n                    schema:addDelayedRegistrationFunc( "AnimatedVehicle:part" , function (cSchema, cKey)\n                        cSchema:register(XMLValueType.INT, cKey .. "#wheelIndex" , "Wheel index [1 .. n]" )\n                        cSchema:register(XMLValueType.ANGLE, cKey .. "#startSteeringAngle" , "Start steering angle" )\n                        cSchema:register(XMLValueType.ANGLE, cKey .. "#endSteeringAngle" , "End steering angle" )\n                        cSchema:register(XMLValueType.FLOAT, cKey .. "#startBrakeFactor" , "Start brake force factor" )\n                        cSchema:register(XMLValueType.FLOAT, cKey .. "#endBrakeFactor" , "End brake force factor" )\n                        cSchema:register(XMLValueType.FLOAT, cKey .. "#startTorqueDirection" , "Start torque direction" )\n                        cSchema:register(XMLValueType.FLOAT, cKey .. "#endTorqueDirection" , "End torque direction" )\n                    end )\n\n                    local dynamicallyLoadedWheelKey = "vehicle.wheels.dynamicallyLoadedWheels.dynamicallyLoadedWheel(?)"\n                    schema:register(XMLValueType.NODE_INDEX, dynamicallyLoadedWheelKey .. "#linkNode" , "Link node" )\n                    schema:register(XMLValueType.BOOL, dynamicallyLoadedWheelKey .. "#isLeft" , "Is Left" , false )\n                    schema:register(XMLValueType.STRING, dynamicallyLoadedWheelKey .. "#filename" , "Filename" )\n                    schema:register(XMLValueType.STRING, dynamicallyLoadedWheelKey .. "#configId" , "Wheel config id" , "default" )\n                    schema:register(XMLValueType.BOOL, dynamicallyLoadedWheelKey .. "#isShallowWaterObstacle" , "The dynamically loaded wheel will interact with the shallow water simulation" , false )\n                    WheelVisual.registerXMLPaths(schema, dynamicallyLoadedWheelKey)\n\n                    Wheels.registerAckermannSteeringXMLPaths(schema, "vehicle.wheels.ackermannSteeringConfigurations.ackermannSteering(?)" )\n\n                    schema:register(XMLValueType.NODE_INDEX, "vehicle.wheels.steeringNodes.steeringNode(?)#node" , "Additional node that is used for steering(Same behaviour as wheels using the ackermann steering setting)" )\n                        schema:register(XMLValueType.FLOAT, "vehicle.wheels.steeringNodes.steeringNode(?)#rotScale" , "Scale factor for rotation" , 1 )\n                            schema:register(XMLValueType.ANGLE, "vehicle.wheels.steeringNodes.steeringNode(?)#rotChangeSpeed" , "Max.rotation speed when limits change" , 45 )\n\n                            schema:register(XMLValueType.VECTOR_N, FoliageBending.BENDING_NODE_XML_KEY .. "#wheelIndices" , "Wheel Indices to calculate the bending node size automatically" )\n\n                            Dashboard.registerDashboardXMLPaths(schema, "vehicle.wheels.dashboards" , { "brake" , "steeringAngle" } )\n                            Dashboard.addDelayedRegistrationFunc(schema, function (cSchema, cKey)\n                                cSchema:register(XMLValueType.INT, cKey .. "#steeringNodeIndex" , "Index of steering node" )\n                                cSchema:register(XMLValueType.INT, cKey .. "#wheelIndex" , "Index of wheel" )\n                            end )\n\n                            schema:setXMLSpecializationType()\n\n                            Wheels.xmlSchema = XMLSchema.new( "wheel" )\n                            Wheels.xmlSchema:register(XMLValueType.STRING, "wheel.metadata#brand" , "Wheel tire brand" , "LIZARD" )\n                            Wheels.xmlSchema:registerAutoCompletionDataSource( "wheel.metadata#brand" , "$dataS/brands.xml" , "brands.brand#name" )\n                            Wheels.xmlSchema:register(XMLValueType.STRING, "wheel.metadata#name" , "Wheel tire name" , "Tire" )\n                            Wheels.xmlSchema:register(XMLValueType.STRING, "wheel.metadata#category" , "Wheel tire category for automatic wheel configurations" )\n                                Wheels.xmlSchema:register(XMLValueType.BOOL, "wheel.metadata#allowMixture" , "Allow mixing with other tires from the same brand" , false )\n                                Wheels.xmlSchema:register(XMLValueType.FLOAT, "wheel.metadata#priority" , "Tire priority for selection in the shop(wheels with high prio will be shown first)" , 1 )\n                                    Wheel.registerXMLPaths( Wheels.xmlSchema, "wheel.default" )\n                                    Wheel.registerXMLPaths( Wheels.xmlSchema, "wheel.configurations.configuration(?)" )\n                                    Wheels.xmlSchema:register(XMLValueType.STRING, "wheel.configurations.configuration(?)#id" , "Configuration Id" )\n\n                                    Wheels.xmlSchemaHub = XMLSchema.new( "wheelHub" )\n                                    local hubSchema = Wheels.xmlSchemaHub\n                                    hubSchema:register(XMLValueType.STRING, "hub.filename" , "I3D filename" )\n                                    hubSchema:register(XMLValueType.STRING, "hub.nodes#left" , "Index of left node in hub i3d file" )\n                                    hubSchema:register(XMLValueType.STRING, "hub.nodes#right" , "Index of right node in hub i3d file" )\n\n                                    Wheels.xmlSchemaConnector = XMLSchema.new( "wheelConnector" )\n                                    local connectorSchema = Wheels.xmlSchemaConnector\n                                    connectorSchema:register(XMLValueType.STRING, "connector.file#name" , "I3D filename" )\n                                    connectorSchema:register(XMLValueType.STRING, "connector.file#leftNode" , "Index of left node in connector i3d file" )\n                                    connectorSchema:register(XMLValueType.STRING, "connector.file#rightNode" , "Index of right node in connector i3d file" )\n\n                                    local schemaSavegame = Vehicle.xmlSchemaSavegame\n                                    schemaSavegame:register(XMLValueType.STRING, "vehicles.vehicle(?).wheels#lastConfigId" , "Last selected wheel configuration id" )\n                                end\n\n'})}),"\n",(0,s.jsx)(n.h3,{id:"loadackermannsteeringfromxml",children:"loadAckermannSteeringFromXML"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Definition"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"loadAckermannSteeringFromXML()"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"any"}),(0,s.jsx)(n.th,{children:"xmlFile"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"any"}),(0,s.jsx)(n.td,{children:"ackermannSteeringIndex"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"any"}),(0,s.jsx)(n.td,{children:"ackermannSteeringAngle"})]})]})]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Code"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:'function Wheels:loadAckermannSteeringFromXML(xmlFile, ackermannSteeringIndex, ackermannSteeringAngle)\n    local spec = self.spec_wheels\n\n    local key, _ = ConfigurationUtil.getXMLConfigurationKey(xmlFile, ackermannSteeringIndex, "vehicle.wheels.ackermannSteeringConfigurations.ackermannSteering" , nil , "ackermann" )\n\n    spec.steeringCenterNode = nil\n\n    if key ~ = nil then\n        local rotSpeed = xmlFile:getValue(key .. "#rotSpeed" )\n        local rotMax = ackermannSteeringAngle or xmlFile:getValue(key .. "#rotMax" )\n\n        local centerX\n        local centerZ\n        local rotCenterWheel1 = xmlFile:getValue(key .. "#rotCenterWheel1" )\n        if rotCenterWheel1 ~ = nil and spec.wheels[rotCenterWheel1] ~ = nil then\n            local wheel = spec.wheels[rotCenterWheel1]\n            centerX, _, centerZ = localToLocal(wheel.node, self.components[ 1 ].node, wheel.physics.positionX, wheel.physics.positionY, wheel.physics.positionZ)\n\n            local rotCenterWheel2 = xmlFile:getValue(key .. "#rotCenterWheel2" )\n            if rotCenterWheel2 ~ = nil and spec.wheels[rotCenterWheel2] ~ = nil then\n                if rotCenterWheel2 = = rotCenterWheel1 then\n                    Logging.xmlWarning(xmlFile, "The ackermann steering wheels are identical(both index %d).Are you sure this is correct? (%s)" , rotCenterWheel1, key)\n                end\n\n                local wheel2 = spec.wheels[rotCenterWheel2]\n                local x, _, z = localToLocal(wheel2.node, self.components[ 1 ].node, wheel2.physics.positionX, wheel2.physics.positionY, wheel2.physics.positionZ)\n                centerX, centerZ = 0.5 * (centerX + x), 0.5 * (centerZ + z)\n            end\n        else\n                local centerNode, _ = xmlFile:getValue(key .. "#rotCenterNode" , nil , self.components, self.i3dMappings)\n                if centerNode ~ = nil then\n                    centerX, _, centerZ = localToLocal(centerNode, self.components[ 1 ].node, 0 , 0 , 0 )\n                    spec.steeringCenterNode = centerNode\n                else\n                        local rotCenterWheels = xmlFile:getValue(key .. "#rotCenterWheels" , nil , true )\n                        if rotCenterWheels ~ = nil and #rotCenterWheels > 0 then\n                            local x, z, numWheels = 0 , 0 , 0\n                            for i = 1 , #rotCenterWheels do\n                                local wheel = spec.wheels[rotCenterWheels[i]]\n                                if wheel ~ = nil then\n                                    local _x, _, _z = localToLocal(wheel.node, self.components[ 1 ].node, wheel.physics.positionX, 0 , wheel.physics.positionZ)\n                                    x, z, numWheels = x + _x, z + _z, numWheels + 1\n                                end\n                            end\n\n                            if numWheels > 0 then\n                                centerX, centerZ = x / numWheels, z / numWheels\n                            end\n                        else\n                                local p = xmlFile:getValue(key .. "#rotCenter" , nil , true )\n                                if p ~ = nil then\n                                    centerX = p[ 1 ]\n                                    centerZ = p[ 2 ]\n                                end\n                            end\n                        end\n                    end\n                    if spec.steeringCenterNode = = nil then\n                        spec.steeringCenterNode = createTransformGroup( "steeringCenterNode" )\n                        link( self.components[ 1 ].node, spec.steeringCenterNode)\n                        if centerX ~ = nil and centerZ ~ = nil then\n                            setTranslation(spec.steeringCenterNode, centerX, 0 , centerZ)\n                        end\n                    end\n\n                    if rotSpeed ~ = nil and rotMax ~ = nil and centerX ~ = nil then\n                        rotSpeed = math.abs( math.rad(rotSpeed))\n                        rotMax = math.abs( math.rad(rotMax))\n\n                        -- find the wheel that should get the maximum steering(the one that results in the maximum turnign radius)\n                        local maxTurningRadius = 0\n                        local isValid = false\n                        for i, wheel in ipairs(spec.wheels) do\n                            if wheel.physics.rotSpeed ~ = 0 then\n                                local diffX, _, diffZ = localToLocal(wheel.repr, spec.steeringCenterNode, 0 , 0 , 0 )\n                                local turningRadius = math.abs(diffZ) / math.tan(rotMax) + math.abs(diffX)\n                                if turningRadius > = maxTurningRadius then\n                                    maxTurningRadius = turningRadius\n                                    isValid = true\n                                end\n                            end\n                        end\n\n                        for _, steeringNode in ipairs(spec.steeringNodes) do\n                            local diffX, _, diffZ = localToLocal(steeringNode.node, spec.steeringCenterNode, 0 , 0 , 0 )\n                            local turningRadius = math.abs(diffZ) / math.tan(rotMax) + math.abs(diffX)\n                            if turningRadius > = maxTurningRadius then\n                                maxTurningRadius = turningRadius\n                                isValid = true\n                            end\n                        end\n\n                        self.maxRotation = math.max( Utils.getNoNil( self.maxRotation, 0 ), rotMax)\n                        self.maxTurningRadius = xmlFile:getValue(key .. "#minTurningRadius" , maxTurningRadius)\n                        self.wheelSteeringDuration = rotMax / rotSpeed\n\n                        if isValid then\n                            for _, wheel in ipairs(spec.wheels) do\n                                if wheel.physics.rotSpeed ~ = 0 then\n                                    local rotMinI, rotMaxI, inverted = Wheels.getAckermannSteeringAngles(wheel.repr, spec.steeringCenterNode, maxTurningRadius)\n                                    wheel:setSteeringValues(rotMinI, rotMaxI, rotMaxI / self.wheelSteeringDuration, - rotMinI / self.wheelSteeringDuration, inverted)\n                                end\n                            end\n\n                            for _, steeringNode in ipairs(spec.steeringNodes) do\n                                local rotMinI, rotMaxI, inverted = Wheels.getAckermannSteeringAngles(steeringNode.node, spec.steeringCenterNode, maxTurningRadius)\n\n                                steeringNode.rotMin = rotMinI\n                                steeringNode.rotMax = rotMaxI\n                                steeringNode.rotSpeed = rotMaxI / self.wheelSteeringDuration\n                                steeringNode.rotSpeedNeg = - rotMinI / self.wheelSteeringDuration\n                                if inverted then\n                                    steeringNode.rotSpeed, steeringNode.rotSpeedNeg = - steeringNode.rotSpeedNeg, - steeringNode.rotSpeed\n                                end\n\n                                steeringNode.rotMinOrig, steeringNode.rotMaxOrig = steeringNode.rotMin, steeringNode.rotMax\n                                steeringNode.rotSpeedOrig, steeringNode.rotSpeedNegOrig = steeringNode.rotSpeed, steeringNode.rotSpeedNeg\n                            end\n                        end\n                    end\n                end\n\n                for _, wheel in ipairs(spec.wheels) do\n                    if wheel.physics.rotSpeed ~ = 0 then\n                        -- if both speed and rot have the same sign, we can reach it with the positive time\n                            if (wheel.physics.rotMax > = 0 ) = = (wheel.physics.rotSpeed > = 0 ) then\n                                self.maxRotTime = math.max(wheel.physics.rotMax / wheel.physics.rotSpeed, self.maxRotTime)\n                            end\n                            if (wheel.physics.rotMin > = 0 ) = = (wheel.physics.rotSpeed > = 0 ) then\n                                self.maxRotTime = math.max(wheel.physics.rotMin / wheel.physics.rotSpeed, self.maxRotTime)\n                            end\n\n                            -- if speed and rot have a different sign, we can reach it with the negative time\n                                local rotSpeedNeg = wheel.physics.rotSpeedNeg\n                                if rotSpeedNeg = = nil or rotSpeedNeg = = 0 then\n                                    rotSpeedNeg = wheel.physics.rotSpeed\n                                end\n                                if (wheel.physics.rotMax > = 0 ) ~ = (rotSpeedNeg > = 0 ) then\n                                    self.minRotTime = math.min(wheel.physics.rotMax / rotSpeedNeg, self.minRotTime)\n                                end\n                                if (wheel.physics.rotMin > = 0 ) ~ = (rotSpeedNeg > = 0 ) then\n                                    self.minRotTime = math.min(wheel.physics.rotMin / rotSpeedNeg, self.minRotTime)\n                                end\n                            end\n\n                            if wheel.physics.rotSpeedLimit ~ = nil then\n                                wheel.physics.rotSpeedDefault = wheel.physics.rotSpeed\n                                wheel.physics.rotSpeedNegDefault = wheel.physics.rotSpeedNeg\n                                wheel.physics.currentRotSpeedAlpha = 1\n                            end\n                        end\n\n                        for _, steeringNode in ipairs(spec.steeringNodes) do\n                            self.maxRotTime = math.max(steeringNode.rotMax / steeringNode.rotSpeed, self.maxRotTime)\n\n                            -- if speed and rot have a different sign, we can reach it with the negative time\n                                local rotSpeedNeg = steeringNode.rotSpeedNeg\n                                if rotSpeedNeg = = nil or rotSpeedNeg = = 0 then\n                                    rotSpeedNeg = steeringNode.rotSpeed\n                                end\n\n                                self.minRotTime = math.min(steeringNode.rotMin / rotSpeedNeg, self.minRotTime)\n                            end\n                        end\n\n'})}),"\n",(0,s.jsx)(n.h3,{id:"loadbendingnodefromxml",children:"loadBendingNodeFromXML"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Definition"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"loadBendingNodeFromXML()"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"any"}),(0,s.jsx)(n.th,{children:"superFunc"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"any"}),(0,s.jsx)(n.td,{children:"xmlFile"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"any"}),(0,s.jsx)(n.td,{children:"key"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"any"}),(0,s.jsx)(n.td,{children:"bendingNode"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"any"}),(0,s.jsx)(n.td,{children:"..."})]})]})]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Code"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:'function Wheels:loadBendingNodeFromXML(superFunc, xmlFile, key, bendingNode, .. .)\n    if not superFunc( self , xmlFile, key, bendingNode, .. .) then\n        return false\n    end\n\n    local wheelIndices = xmlFile:getValue(key .. "#wheelIndices" , nil , true )\n    if wheelIndices ~ = nil and #wheelIndices > 0 then\n        bendingNode.minX = math.huge\n        bendingNode.maxX = - math.huge\n        bendingNode.minZ = math.huge\n        bendingNode.maxZ = - math.huge\n\n        local offset = 0.05\n        for _, wheelIndex in ipairs(wheelIndices) do\n            local wheel = self:getWheelFromWheelIndex(wheelIndex)\n            if wheel ~ = nil then\n                local x1, _, z1 = localToLocal(wheel.driveNode, bendingNode.node, (wheel.physics.wheelShapeWidth * 0.5 + offset) + wheel.physics.wheelShapeWidthOffset, 0 , (wheel.physics.radius * 0.5 + offset))\n                local x2, _, z2 = localToLocal(wheel.driveNode, bendingNode.node, - ((wheel.physics.wheelShapeWidth * 0.5 + offset) - wheel.physics.wheelShapeWidthOffset), 0 , - (wheel.physics.radius * 0.5 + offset))\n\n                bendingNode.minX = math.min(bendingNode.minX, x1, x2)\n                bendingNode.maxX = math.max(bendingNode.maxX, x1, x2)\n                bendingNode.minZ = math.min(bendingNode.minZ, z1, z2)\n                bendingNode.maxZ = math.max(bendingNode.maxZ, z1, z2)\n            else\n                    Logging.xmlWarning(xmlFile, "Unable to find wheel index \'%s\' in \'%s\'" , wheelIndex, key)\n                end\n            end\n\n            -- values still can be overwritten by the XML file\n            bendingNode.minX = xmlFile:getValue(key .. "#minX" , bendingNode.minX)\n            bendingNode.maxX = xmlFile:getValue(key .. "#maxX" , bendingNode.maxX)\n            bendingNode.minZ = xmlFile:getValue(key .. "#minZ" , bendingNode.minZ)\n            bendingNode.maxZ = xmlFile:getValue(key .. "#maxZ" , bendingNode.maxZ)\n        end\n\n        return true\n    end\n\n'})}),"\n",(0,s.jsx)(n.h3,{id:"loadhubfromxml",children:"loadHubFromXML"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Definition"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"loadHubFromXML()"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"any"}),(0,s.jsx)(n.th,{children:"xmlFile"})]})}),(0,s.jsx)(n.tbody,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"any"}),(0,s.jsx)(n.td,{children:"key"})]})})]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Code"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:'function Wheels:loadHubFromXML(xmlFile, key)\n    local spec = self.spec_wheels\n    local linkNode = xmlFile:getValue(key .. "#linkNode" , nil , self.components, self.i3dMappings)\n    if linkNode = = nil then\n        Logging.xmlError(xmlFile, "Missing link node for hub \'%s\'" , key)\n            return\n        end\n\n        local hub = { }\n        hub.linkNode = linkNode\n        hub.isLeft = xmlFile:getValue(key .. "#isLeft" )\n\n        local hubXmlFilename = xmlFile:getValue(key .. "#filename" )\n        hub.xmlFilename = Utils.getFilename(hubXmlFilename, self.baseDirectory)\n        local xmlFileHub = XMLFile.load( "wheelHubXml" , hub.xmlFilename, Wheels.xmlSchemaHub)\n        if xmlFileHub ~ = nil then\n            local i3dFilename = xmlFileHub:getValue( "hub.filename" )\n            if i3dFilename = = nil then\n                Logging.xmlError(xmlFileHub, "Unable to retrieve hub i3d filename!" )\n                return\n            end\n            hub.i3dFilename = Utils.getFilename(i3dFilename, self.baseDirectory)\n\n            Wheels.loadHubMaterial( self , xmlFile, key .. ".material" , hub, "material" )\n            Wheels.loadHubMaterial( self , xmlFile, key .. ".boltMaterial" , hub, "boltMaterial" )\n            Wheels.loadHubMaterial( self , xmlFile, key .. ".additionalMaterial" , hub, "additionalMaterial" )\n            Wheels.loadHubMaterial( self , xmlFile, key .. ".boltAdditionalMaterial" , hub, "boltAdditionalMaterial" )\n\n            hub.nodeStr = xmlFileHub:getValue( "hub.nodes#" .. (hub.isLeft and "left" or "right" ))\n\n            local arguments = {\n            hub = hub,\n            linkNode = linkNode,\n            xmlFile = xmlFile,\n            key = key\n            }\n\n            local sharedLoadRequestId = self:loadSubSharedI3DFile(hub.i3dFilename, false , false , self.onWheelHubI3DLoaded, self , arguments)\n            table.insert(spec.sharedLoadRequestIds, sharedLoadRequestId)\n\n            xmlFileHub:delete()\n        end\n\n        return true\n    end\n\n'})}),"\n",(0,s.jsx)(n.h3,{id:"loadhubmaterial",children:"loadHubMaterial"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Definition"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"loadHubMaterial()"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"any"}),(0,s.jsx)(n.th,{children:"vehicle"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"any"}),(0,s.jsx)(n.td,{children:"xmlFile"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"any"}),(0,s.jsx)(n.td,{children:"key"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"any"}),(0,s.jsx)(n.td,{children:"hub"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"any"}),(0,s.jsx)(n.td,{children:"materialName"})]})]})]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Code"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:'function Wheels.loadHubMaterial(vehicle, xmlFile, key, hub, materialName)\n    local material = VehicleMaterial.new(vehicle.baseDirectory)\n    if material:loadFromXML(xmlFile, key, vehicle.customEnvironment) then\n        hub[materialName] = material\n    end\n\n    if xmlFile:getValue(key .. "#useBaseColor" , false ) then\n        hub[materialName] = VehicleConfigurationItemColor.getMaterialByColorConfiguration(vehicle, "baseColor" ) or hub[materialName]\n    elseif xmlFile:getValue(key .. "#useRimColor" , false ) then\n            hub[materialName] = VehicleConfigurationItemColor.getMaterialByColorConfiguration(vehicle, "rimColor" ) or vehicle.spec_wheels[ "rimMaterial" ] or hub[materialName]\n\n            if hub[materialName] = = nil then\n                hub[materialName] = VehicleMaterial.new(vehicle.baseDirectory)\n                hub[materialName]:setTemplateName( "RIM_DEFAULT" )\n            end\n        else\n                local useDesignColorIndex = xmlFile:getValue(key .. "#useDesignColorIndex" )\n                if useDesignColorIndex ~ = nil then\n                    local configName = "designColor"\n                    if useDesignColorIndex > = 2 then\n                        configName = string.format( "designColor%d" , useDesignColorIndex)\n                    end\n\n                    hub[materialName] = VehicleConfigurationItemColor.getMaterialByColorConfiguration(vehicle, configName) or hub[materialName]\n                end\n            end\n        end\n\n'})}),"\n",(0,s.jsx)(n.h3,{id:"loadhubsfromxml",children:"loadHubsFromXML"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Definition"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"loadHubsFromXML()"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Code"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:'function Wheels:loadHubsFromXML()\n    local spec = self.spec_wheels\n\n    spec.hubs = { }\n    self.xmlFile:iterate( "vehicle.wheels.hubs.hub" , function (_, key)\n        self:loadHubFromXML( self.xmlFile, key)\n    end )\nend\n\n'})}),"\n",(0,s.jsx)(n.h3,{id:"loadspecvaluewheels",children:"loadSpecValueWheels"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Definition"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"loadSpecValueWheels()"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"any"}),(0,s.jsx)(n.th,{children:"xmlFile"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"any"}),(0,s.jsx)(n.td,{children:"customEnvironment"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"any"}),(0,s.jsx)(n.td,{children:"baseDir"})]})]})]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Code"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:"function Wheels.loadSpecValueWheels(xmlFile, customEnvironment, baseDir)\n    -- No data to load as this spec is only for existing items\n        return nil\n    end\n\n"})}),"\n",(0,s.jsx)(n.h3,{id:"loadspecvaluewheelweight",children:"loadSpecValueWheelWeight"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Definition"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"loadSpecValueWheelWeight()"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"any"}),(0,s.jsx)(n.th,{children:"xmlFile"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"any"}),(0,s.jsx)(n.td,{children:"customEnvironment"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"any"}),(0,s.jsx)(n.td,{children:"baseDir"})]})]})]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Code"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:'function Wheels.loadSpecValueWheelWeight(xmlFile, customEnvironment, baseDir)\n    local storeItem = g_storeManager:getItemByXMLFilename(xmlFile.filename)\n\n    local configItem\n    if storeItem.configurations ~ = nil then\n        local configItems = storeItem.configurations[ "wheel" ]\n        if configItems ~ = nil then\n            for i, item in ipairs(configItems) do\n                if item.isSelectable and item.isDefault then\n                    configItem = item\n                    break\n                end\n            end\n\n            if configItem = = nil then\n                for i, item in ipairs(configItems) do\n                    if item.isSelectable then\n                        configItem = item\n                        break\n                    end\n                end\n            end\n        end\n    end\n\n    local configMass = 0\n\n    if configItem ~ = nil then\n        configItem:applyGeneratedConfiguration(xmlFile)\n        local configurationIndexToParentConfigIndex = Wheels.createConfigToParentConfigMapping(xmlFile)\n\n        xmlFile:iterate(configItem.configKey .. ".wheels.wheel" , function (index, key)\n            local wheelKey = string.format( ".wheels.wheel(%d)" , index - 1 )\n\n            local wheeXMLObject = WheelXMLObject.new(xmlFile, "vehicle.wheels.wheelConfigurations.wheelConfiguration" , configItem.index, wheelKey, configurationIndexToParentConfigIndex)\n            wheeXMLObject:setXMLLoadKey( "" )\n\n            local mass = wheeXMLObject:cacheWheelMass()\n\n            wheeXMLObject:delete()\n\n            configMass = configMass + mass\n        end )\n    end\n\n    return configMass\nend\n\n'})}),"\n",(0,s.jsx)(n.h3,{id:"loadwheelfromxml",children:"loadWheelFromXML"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Definition"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"loadWheelFromXML()"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,s.jsx)(n.table,{children:(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"any"}),(0,s.jsx)(n.th,{children:"wheel"})]})})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Code"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:"function Wheels:loadWheelFromXML(wheel)\n    return wheel:loadFromXML()\nend\n\n"})}),"\n",(0,s.jsx)(n.h3,{id:"loadwheelsfromxml",children:"loadWheelsFromXML"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Definition"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"loadWheelsFromXML()"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"any"}),(0,s.jsx)(n.th,{children:"xmlFile"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"any"}),(0,s.jsx)(n.td,{children:"key"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"any"}),(0,s.jsx)(n.td,{children:"wheelConfigurationId"})]})]})]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Code"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:'function Wheels:loadWheelsFromXML(xmlFile, key, wheelConfigurationId)\n    local spec = self.spec_wheels\n\n    local i = 0\n    while true do\n        local wheelKey = string.format( ".wheels.wheel(%d)" , i)\n        if not xmlFile:hasProperty(key .. wheelKey) then\n            break\n        end\n\n        local wheel = Wheel.new( self , self.xmlFile, Wheels.CONFIG_XML_PATH, wheelKey, i + 1 , wheelConfigurationId, spec.configurationIndexToParentConfigIndex, self.baseDirectory)\n        if self:loadWheelFromXML(wheel) then\n            wheel:finalize()\n\n            if spec.isCareWheelConfiguration ~ = nil then\n                wheel:setIsCareWheel(spec.isCareWheelConfiguration)\n            end\n\n            table.insert(spec.wheels, wheel)\n        end\n\n        i = i + 1\n    end\nend\n\n'})}),"\n",(0,s.jsx)(n.h3,{id:"onaifieldworkerend",children:"onAIFieldWorkerEnd"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Definition"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"onAIFieldWorkerEnd()"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Code"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:"function Wheels:onAIFieldWorkerEnd()\n    local spec = self.spec_wheels\n    for _, wheel in ipairs(spec.wheels) do\n        wheel.physics:setDisplacementAllowed( true )\n        wheel.physics:setDisplacementCollisionEnabled( true )\n    end\nend\n\n"})}),"\n",(0,s.jsx)(n.h3,{id:"onaifieldworkerstart",children:"onAIFieldWorkerStart"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Definition"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"onAIFieldWorkerStart()"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Code"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:"function Wheels:onAIFieldWorkerStart()\n    local spec = self.spec_wheels\n    for _, wheel in ipairs(spec.wheels) do\n        wheel.physics:setDisplacementAllowed( false )\n        wheel.physics:setDisplacementCollisionEnabled( false )\n    end\nend\n\n"})}),"\n",(0,s.jsx)(n.h3,{id:"onaiimplementend",children:"onAIImplementEnd"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Definition"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"onAIImplementEnd()"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Code"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:"function Wheels:onAIImplementEnd()\n    local spec = self.spec_wheels\n    for _, wheel in ipairs(spec.wheels) do\n        wheel.physics:setDisplacementAllowed( true )\n        wheel.physics:setDisplacementCollisionEnabled( true )\n    end\nend\n\n"})}),"\n",(0,s.jsx)(n.h3,{id:"onaiimplementstart",children:"onAIImplementStart"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Definition"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"onAIImplementStart()"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Code"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:"function Wheels:onAIImplementStart()\n    local spec = self.spec_wheels\n    for _, wheel in ipairs(spec.wheels) do\n        wheel.physics:setDisplacementAllowed( false )\n        wheel.physics:setDisplacementCollisionEnabled( false )\n    end\nend\n\n"})}),"\n",(0,s.jsx)(n.h3,{id:"ondelete",children:"onDelete"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Definition"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"onDelete()"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Code"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:"function Wheels:onDelete()\n    local spec = self.spec_wheels\n\n    if spec.sharedLoadRequestIds ~ = nil then\n        for _, sharedLoadRequestId in pairs(spec.sharedLoadRequestIds) do\n            g_i3DManager:releaseSharedI3DFile(sharedLoadRequestId)\n        end\n    end\n\n    if spec.hubs ~ = nil then\n        for _, hub in pairs(spec.hubs) do\n            delete(hub.node)\n        end\n    end\n\n    if spec.wheels ~ = nil then\n        for _, wheel in pairs(spec.wheels) do\n            wheel:delete()\n        end\n    end\n\n    if spec.dynamicallyLoadedWheels ~ = nil then\n        for _, visualWheel in ipairs(spec.dynamicallyLoadedWheels) do\n            visualWheel:delete()\n        end\n    end\n\n    g_soundManager:deleteSamples(spec.surfaceSounds)\nend\n\n"})}),"\n",(0,s.jsx)(n.h3,{id:"onleavevehicle",children:"onLeaveVehicle"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Definition"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"onLeaveVehicle()"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Code"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:"function Wheels:onLeaveVehicle()\n    local spec = self.spec_wheels\n    if self.isServer and self.isAddedToPhysics then\n        local brakeForce = self:getBrakeForce()\n        for _,wheel in pairs(spec.wheels) do\n            wheel:updatePhysics(brakeForce, 0 )\n        end\n    end\nend\n\n"})}),"\n",(0,s.jsx)(n.h3,{id:"onload",children:"onLoad"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Definition"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"onLoad()"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,s.jsx)(n.table,{children:(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"any"}),(0,s.jsx)(n.th,{children:"savegame"})]})})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Code"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:'function Wheels:onLoad(savegame)\n    local spec = self.spec_wheels\n\n    spec.sharedLoadRequestIds = { }\n\n    XMLUtil.checkDeprecatedXMLElements( self.xmlFile, "vehicle.driveGroundParticleSystems" , "vehicle.wheels.wheelConfigurations.wheelConfiguration.wheels.wheel#hasParticles" ) --FS13 to FS15\n\n    XMLUtil.checkDeprecatedXMLElements( self.xmlFile, "vehicle.wheelConfigurations.wheelConfiguration" , "vehicle.wheels.wheelConfigurations.wheelConfiguration" ) --FS17 to FS19\n    XMLUtil.checkDeprecatedXMLElements( self.xmlFile, "vehicle.rimColor" , "vehicle.wheels.rimColor" ) --FS17 to FS19\n    XMLUtil.checkDeprecatedXMLElements( self.xmlFile, "vehicle.hubColor" , "vehicle.wheels.hubs.color0" ) --FS17 to FS19\n    XMLUtil.checkDeprecatedXMLElements( self.xmlFile, "vehicle.dynamicallyLoadedWheels" , "vehicle.wheels.dynamicallyLoadedWheels" ) --FS17 to FS19\n    XMLUtil.checkDeprecatedXMLElements( self.xmlFile, "vehicle.ackermannSteeringConfigurations" , "vehicle.wheels.ackermannSteeringConfigurations" ) --FS17 to FS19\n    XMLUtil.checkDeprecatedXMLElements( self.xmlFile, "vehicle.wheels.wheel" , "vehicle.wheels.wheelConfigurations.wheelConfiguration.wheels.wheel" ) --FS17 to FS19\n    XMLUtil.checkDeprecatedXMLElements( self.xmlFile, "vehicle.wheels.wheel#repr" , "vehicle.wheels.wheelConfigurations.wheelConfiguration.wheels.wheel.physics#repr" ) --FS17 to FS19\n    XMLUtil.checkDeprecatedXMLElements( self.xmlFile, "vehicle.wheelConfigurations.wheelConfiguration.wheels.wheel#repr" , "vehicle.wheels.wheelConfigurations.wheelConfiguration.wheels.wheel.physics#repr" ) --FS17 to FS19\n    XMLUtil.checkDeprecatedXMLElements( self.xmlFile, "vehicle.wheels.wheelConfigurations.wheelConfiguration.wheels.wheel#repr" , "vehicle.wheels.wheelConfigurations.wheelConfiguration.wheels.wheel.physics#repr" ) --FS17 to FS19\n    XMLUtil.checkDeprecatedXMLElements( self.xmlFile, "vehicle.wheels.wheelConfigurations.wheelConfiguration.wheels.wheel#configIndex" , "vehicle.wheels.wheelConfigurations.wheelConfiguration.wheels.wheel#configId" ) --FS17 to FS19\n\n    XMLUtil.checkDeprecatedXMLElements( self.xmlFile, "vehicle.ackermannSteering" , "vehicle.wheels.ackermannSteeringConfigurations.ackermannSteering" ) --FS19 to FS21\n\n    XMLUtil.checkDeprecatedXMLElements( self.xmlFile, "vehicle.wheel.rimColor" , "vehicle.wheels.rimMaterial" ) --FS22 to FS25\n    XMLUtil.checkDeprecatedXMLElements( self.xmlFile, "vehicle.wheel.hubs.rimColor.color0" , "vehicle.wheels.hubMaterial" ) --FS22 to FS25\n    XMLUtil.checkDeprecatedXMLElements( self.xmlFile, "vehicle.wheel.hubs.rimColor.color1" , "vehicle.wheels.hubBoltMaterial" ) --FS22 to FS25\n\n    spec.configurationIndexToParentConfigIndex = Wheels.createConfigToParentConfigMapping( self.xmlFile)\n\n    if spec.configItem ~ = nil then\n        -- apply the object changes again including the ones from the parent configurations\n        spec.configItem:applyObjectChanges( self , spec.configurationIndexToParentConfigIndex)\n    end\n\n    local loadMaterial = function (name, key, hubMaterial)\n        local material = VehicleMaterial.new( self.baseDirectory)\n        if material:loadFromXML( self.xmlFile, key, self.customEnvironment) then\n            spec[name] = material\n        else\n                material = nil\n            end\n\n            if self.xmlFile:getValue(key .. "#useBaseColor" ) then\n                spec[name] = VehicleConfigurationItemColor.getMaterialByColorConfiguration( self , "baseColor" ) or spec[name]\n            else\n                    local useDesignColorIndex = self.xmlFile:getValue(key .. "#useDesignColorIndex" )\n                    if useDesignColorIndex ~ = nil then\n                        local configName = "designColor"\n                        if useDesignColorIndex > = 2 then\n                            configName = string.format( "designColor%d" , useDesignColorIndex)\n                        end\n\n                        spec[name] = VehicleConfigurationItemColor.getMaterialByColorConfiguration( self , configName) or spec[name]\n                    else\n                            if (material = = nil and not hubMaterial) or self.xmlFile:getBool(key .. "#useRimColor" , false ) then\n                                spec[name] = VehicleConfigurationItemColor.getMaterialByColorConfiguration( self , "rimColor" ) or spec[ "rimMaterial" ] or spec[name]\n\n                                if spec[name] = = nil then\n                                    spec[name] = VehicleMaterial.new( self.baseDirectory)\n                                    spec[name]:setTemplateName( "RIM_DEFAULT" )\n                                end\n                            end\n                        end\n                    end\n                end\n\n                loadMaterial( "rimMaterial" , "vehicle.wheels.rimMaterial" , false )\n                loadMaterial( "innerRimMaterial" , "vehicle.wheels.innerRimMaterial" , false )\n                loadMaterial( "outerRimMaterial" , "vehicle.wheels.outerRimMaterial" , false )\n                loadMaterial( "additionalMaterial" , "vehicle.wheels.additionalMaterial" , false )\n                loadMaterial( "hubMaterial" , "vehicle.wheels.hubMaterial" , true )\n                loadMaterial( "hubBoltMaterial" , "vehicle.wheels.hubBoltMaterial" , true )\n\n                -- load hubs to hubs/repr nodes\n                self:loadHubsFromXML()\n\n                self.maxRotTime = 0\n                self.minRotTime = 0\n                self.rotatedTimeInterpolator = InterpolatorValue.new( 0 )\n\n                self.autoRotateBackSpeed = WheelXMLObject.getValueStatic(spec.wheelConfigurationId, spec.configurationIndexToParentConfigIndex, self.xmlFile, Wheels.CONFIG_XML_PATH, ".wheels" , "#autoRotateBackSpeed" , 1 )\n                self.speedDependentRotateBack = WheelXMLObject.getValueStatic(spec.wheelConfigurationId, spec.configurationIndexToParentConfigIndex, self.xmlFile, Wheels.CONFIG_XML_PATH, ".wheels" , "#speedDependentRotateBack" , true )\n                self.differentialIndex = WheelXMLObject.getValueStatic(spec.wheelConfigurationId, spec.configurationIndexToParentConfigIndex, self.xmlFile, Wheels.CONFIG_XML_PATH, ".wheels" , "#differentialIndex" )\n                spec.ackermannSteeringIndex = WheelXMLObject.getValueStatic(spec.wheelConfigurationId, spec.configurationIndexToParentConfigIndex, self.xmlFile, Wheels.CONFIG_XML_PATH, ".wheels" , "#ackermannSteeringIndex" )\n                spec.ackermannSteeringAngle = WheelXMLObject.getValueStatic(spec.wheelConfigurationId, spec.configurationIndexToParentConfigIndex, self.xmlFile, Wheels.CONFIG_XML_PATH, ".wheels" , "#ackermannSteeringAngle" )\n                spec.isCareWheelConfiguration = WheelXMLObject.getValueStatic(spec.wheelConfigurationId, spec.configurationIndexToParentConfigIndex, self.xmlFile, Wheels.CONFIG_XML_PATH, ".wheels" , "#isCareWheelConfiguration" )\n                local hasSurfaceSounds = WheelXMLObject.getValueStatic(spec.wheelConfigurationId, spec.configurationIndexToParentConfigIndex, self.xmlFile, Wheels.CONFIG_XML_PATH, ".wheels" , "#hasSurfaceSounds" , true )\n\n                spec.wheelSmoothAccumulation = 0\n\n                spec.currentUpdateIndex = 1\n\n                spec.wheels = { }\n                spec.wheelsByNode = { }\n\n                -- load wheels\n                self:loadWheelsFromXML( self.xmlFile, spec.configKey, spec.wheelConfigurationId)\n\n                --load surface sounds\n                if hasSurfaceSounds then\n                    local surfaceSoundLinkNode = WheelXMLObject.getValueStatic(spec.wheelConfigurationId, spec.configurationIndexToParentConfigIndex, self.xmlFile, Wheels.CONFIG_XML_PATH, ".wheels" , "#surfaceSoundLinkNode" , self.components[ 1 ].node, self.components, self.i3dMappings)\n\n                    local tireTypeName = ""\n                    if #spec.wheels > 0 and spec.wheels[ 1 ].physics.tireType ~ = nil then\n                        tireTypeName = WheelsUtil.getTireTypeName(spec.wheels[ 1 ].physics.tireType)\n                    end\n                    tireTypeName = WheelXMLObject.getValueStatic(spec.wheelConfigurationId, spec.configurationIndexToParentConfigIndex, self.xmlFile, Wheels.CONFIG_XML_PATH, ".wheels" , "#surfaceSoundTireType" , tireTypeName)\n\n                    spec.surfaceSounds = { }\n                    spec.surfaceIdToSound = { }\n                    spec.surfaceNameToSound = { }\n                    spec.currentSurfaceSound = nil\n\n                    local function addSurfaceSound(surfaceSound)\n                        local sample = g_soundManager:cloneSample(surfaceSound.sample, surfaceSoundLinkNode, self )\n                        sample.sampleName = surfaceSound.name\n\n                        table.insert(spec.surfaceSounds, sample)\n                        spec.surfaceIdToSound[surfaceSound.materialId] = sample\n                        spec.surfaceNameToSound[surfaceSound.name] = sample\n                    end\n\n                    local surfaceSounds = g_currentMission.surfaceSounds\n                    for j = 1 , #surfaceSounds do\n                        local surfaceSound = surfaceSounds[j]\n                        if string.lower(surfaceSound.type ) = = ( "wheel_" .. string.lower(tireTypeName)) then\n                            addSurfaceSound(surfaceSound)\n                        end\n                    end\n\n                    for j = 1 , #surfaceSounds do\n                        local surfaceSound = surfaceSounds[j]\n                        if spec.surfaceNameToSound[surfaceSound.name] = = nil then\n                            if surfaceSound.type = = "wheel" then\n                                addSurfaceSound(surfaceSound)\n                            end\n                        end\n                    end\n                end\n\n                -- load non physical wheels\n                spec.dynamicallyLoadedWheels = { }\n                self.xmlFile:iterate( "vehicle.wheels.dynamicallyLoadedWheels.dynamicallyLoadedWheel" , function (index, key)\n                    local linkNode = self.xmlFile:getValue(key .. "#linkNode" , self.components[ 1 ].node, self.components, self.i3dMappings)\n                    local isLeft = self.xmlFile:getValue(key .. "#isLeft" , false )\n                    local isShallowWaterObstacle = self.xmlFile:getValue(key .. "#isShallowWaterObstacle" , false )\n\n                    local xmlObject = WheelXMLObject.new( self.xmlFile, "vehicle.wheels.dynamicallyLoadedWheels.dynamicallyLoadedWheel" , index, "" , { } )\n\n                    local visualWheel = WheelVisual.new( self , nil , linkNode, isLeft, 0 , self.baseDirectory)\n                    if visualWheel:loadFromXML(xmlObject) then\n                        if isShallowWaterObstacle then\n                            visualWheel:addShallowWaterObstacle()\n                        end\n\n                        visualWheel.name = xmlObject.externalWheelName\n\n                        table.insert(spec.dynamicallyLoadedWheels, visualWheel)\n                    else\n                            visualWheel:delete()\n                        end\n\n                        xmlObject:delete()\n                    end )\n\n                    spec.steeringNodes = { }\n                    self.xmlFile:iterate( "vehicle.wheels.steeringNodes.steeringNode" , function (index, key)\n                        local node = self.xmlFile:getValue(key .. "#node" , nil , self.components, self.i3dMappings)\n                        if node ~ = nil then\n                            local steeringNode = { }\n                            steeringNode.node = node\n\n                            steeringNode.rotScale = self.xmlFile:getValue(key .. "#rotScale" , 1 )\n                            steeringNode.rotChangeSpeed = self.xmlFile:getValue(key .. "#rotChangeSpeed" , 45 )\n                            steeringNode.rotScaleOrig = steeringNode.rotScale\n                            steeringNode.rotScaleTarget = steeringNode.rotScale\n                            steeringNode.rotScaleTargetSpeed = 1\n\n                            steeringNode.steeringAngle = 0\n\n                            steeringNode.offset = 0\n                            steeringNode.offsetTarget = 0\n                            steeringNode.offsetTargetSpeed = 1\n\n                            for _, componentJoint in pairs( self.componentJoints) do\n                                if componentJoint.jointNode = = node then\n                                    steeringNode.componentJoint = componentJoint\n                                    break\n                                end\n                            end\n\n                            table.insert(spec.steeringNodes, steeringNode)\n                        end\n                    end )\n                    spec.hasSteeringNodes = #spec.steeringNodes > 0\n\n                    spec.axles = { }\n                    self.xmlFile:iterate( "vehicle.wheels.axles.axle" , function (index, key)\n                        local axle = WheelAxle.new( self )\n                        if axle:loadFromXML( self.xmlFile, key) then\n                            table.insert(spec.axles, axle)\n                        end\n                    end )\n                    self.xmlFile:iterate(spec.configKey .. ".axle" , function (index, key)\n                        local axle = WheelAxle.new( self )\n                        if axle:loadFromXML( self.xmlFile, key) then\n                            table.insert(spec.axles, axle)\n                        end\n                    end )\n                    spec.hasAxles = #spec.axles > 0\n\n                    spec.networkTimeInterpolator = InterpolationTime.new( 1.2 )\n\n                    self:loadAckermannSteeringFromXML( self.xmlFile, spec.ackermannSteeringIndex, spec.ackermannSteeringAngle)\n\n                    SpecializationUtil.raiseEvent( self , "onFinishedWheelLoading" , self.xmlFile, spec.configKey .. ".wheels" )\n\n                    spec.brakePedal = 0\n                    spec.dirtyFlag = self:getNextDirtyFlag()\n\n                    g_messageCenter:subscribe(MessageType.SNOW_HEIGHT_CHANGED, self.onWheelSnowHeightChanged, self )\n                end\n\n'})}),"\n",(0,s.jsx)(n.h3,{id:"onloadfinished",children:"onLoadFinished"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Definition"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"onLoadFinished()"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,s.jsx)(n.table,{children:(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"any"}),(0,s.jsx)(n.th,{children:"savegame"})]})})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Code"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:'function Wheels:onLoadFinished(savegame)\n    local spec = self.spec_wheels\n\n    -- add wheel masses to default vehicle mass\n    if self.isServer then\n        for _, wheel in pairs(spec.wheels) do\n            self.defaultMass = self.defaultMass + wheel:getMass()\n        end\n\n        if savegame ~ = nil and not savegame.resetVehicles then\n            local lastConfigId = savegame.xmlFile:getValue(savegame.key .. ".wheels#lastConfigId" )\n            if lastConfigId ~ = nil then\n                if spec.configItem ~ = nil and spec.configItem.saveId ~ = lastConfigId then\n                    for _, wheel in pairs(spec.wheels) do\n                        local washableNode = self:getWashableNodeByCustomIndex(wheel)\n                        if washableNode ~ = nil then\n                            self:setNodeDirtAmount(washableNode, 0 , true )\n                        end\n\n                        if wheel.wheelMudMeshes ~ = nil then\n                            local mudWashableNode = self:getWashableNodeByCustomIndex(wheel.wheelMudMeshes)\n                            if mudWashableNode ~ = nil then\n                                self:setNodeDirtAmount(mudWashableNode, 0 , true )\n                            end\n                        end\n                    end\n\n                    SpecializationUtil.raiseEvent( self , "onWheelConfigurationChanged" )\n                end\n            end\n        end\n    end\n\n    if spec.rimMaterial ~ = nil then\n        spec.rimMaterial:applyToVehicle( self , "rim_inner_mat" )\n        spec.rimMaterial:applyToVehicle( self , "rim_outer_mat" )\n    end\n\n    if spec.innerRimMaterial ~ = nil then\n        spec.innerRimMaterial:applyToVehicle( self , "rim_inner_mat" )\n    end\n\n    if spec.outerRimMaterial ~ = nil then\n        spec.outerRimMaterial:applyToVehicle( self , "rim_outer_mat" )\n    end\n\n    if spec.additionalMaterial ~ = nil then\n        spec.additionalMaterial:applyToVehicle( self , "rim_additional_mat" )\n    end\n\n    if spec.hubMaterial ~ = nil then\n        spec.hubMaterial:applyToVehicle( self , "hub_main_mat" )\n    end\n\n    if spec.hubBoltMaterial ~ = nil then\n        spec.hubBoltMaterial:applyToVehicle( self , "hub_bolt_mat" )\n    end\n\n    for i, hub in ipairs(spec.hubs) do\n        if hub.material ~ = nil then\n            hub.material:apply(hub.node, "hub_main_mat" )\n        end\n\n        if hub.boltMaterial ~ = nil then\n            hub.boltMaterial:apply(hub.node, "hub_bolt_mat" )\n        end\n\n        if hub.additionalMaterial ~ = nil then\n            hub.additionalMaterial:apply(hub.node, "hub_main_additional_mat" )\n        end\n\n        if hub.boltAdditionalMaterial ~ = nil then\n            hub.boltAdditionalMaterial:apply(hub.node, "hub_bolt_additional_mat" )\n        end\n    end\n\n    -- wheel post load handles individual colors of wheel parts, so should be applied after the general rim material\n    for _, wheel in pairs(spec.wheels) do\n        wheel:postLoad()\n    end\n\n    for _, visualWheel in pairs(spec.dynamicallyLoadedWheels) do\n        visualWheel:postLoad()\n    end\nend\n\n'})}),"\n",(0,s.jsx)(n.h3,{id:"onloadwheelchockfromxml",children:"onLoadWheelChockFromXML"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Definition"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"onLoadWheelChockFromXML()"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,s.jsx)(n.table,{children:(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"any"}),(0,s.jsx)(n.th,{children:"wheelChock"})]})})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Code"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:"function Wheels:onLoadWheelChockFromXML(wheelChock)\nend\n\n"})}),"\n",(0,s.jsx)(n.h3,{id:"onpostattachimplement",children:"onPostAttachImplement"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Definition"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"onPostAttachImplement()"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"any"}),(0,s.jsx)(n.th,{children:"object"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"any"}),(0,s.jsx)(n.td,{children:"inputJointDescIndex"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"any"}),(0,s.jsx)(n.td,{children:"jointDescIndex"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"any"}),(0,s.jsx)(n.td,{children:"loadFromSavegame"})]})]})]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Code"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:'function Wheels:onPostAttachImplement(object, inputJointDescIndex, jointDescIndex, loadFromSavegame)\n    -- raise onBrake event again, so the brake force of the new implement is updated, even if the attacherVehicle has no brake pedal change\n        SpecializationUtil.raiseEvent( self , "onBrake" , self.spec_wheels.brakePedal)\n    end\n\n'})}),"\n",(0,s.jsx)(n.h3,{id:"onpostdetach",children:"onPostDetach"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Definition"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"onPostDetach()"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Code"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:"function Wheels:onPostDetach()\n    local spec = self.spec_wheels\n    for _,wheel in pairs(spec.wheels) do\n        wheel:onPostDetach()\n    end\nend\n\n"})}),"\n",(0,s.jsx)(n.h3,{id:"onpostupdate",children:"onPostUpdate"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Definition"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"onPostUpdate()"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"any"}),(0,s.jsx)(n.th,{children:"dt"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"any"}),(0,s.jsx)(n.td,{children:"isActiveForInput"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"any"}),(0,s.jsx)(n.td,{children:"isActiveForInputIgnoreSelection"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"any"}),(0,s.jsx)(n.td,{children:"isSelected"})]})]})]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Code"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:"function Wheels:onPostUpdate(dt, isActiveForInput, isActiveForInputIgnoreSelection, isSelected)\n    if self.isServer then\n        local spec = self.spec_wheels\n        for _,wheel in ipairs(spec.wheels) do\n            wheel:postUpdate(dt)\n        end\n    end\nend\n\n"})}),"\n",(0,s.jsx)(n.h3,{id:"onpreattach",children:"onPreAttach"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Definition"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"onPreAttach()"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Code"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:"function Wheels:onPreAttach()\n    local spec = self.spec_wheels\n    for _,wheel in pairs(spec.wheels) do\n        wheel:onPreAttach()\n    end\nend\n\n"})}),"\n",(0,s.jsx)(n.h3,{id:"onpreload",children:"onPreLoad"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Definition"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"onPreLoad()"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,s.jsx)(n.table,{children:(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"any"}),(0,s.jsx)(n.th,{children:"savegame"})]})})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Code"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:'function Wheels:onPreLoad(savegame)\n    local spec = self.spec_wheels\n\n    spec.wheelConfigurationId = self.configurations[ "wheel" ] or 1\n    spec.configKey = string.format( "vehicle.wheels.wheelConfigurations.wheelConfiguration(%d)" , spec.wheelConfigurationId - 1 )\n\n    spec.configItem = ConfigurationUtil.getConfigItemByConfigId( self.configFileName, "wheel" , spec.wheelConfigurationId)\n    if spec.configItem ~ = nil then\n        spec.configItem:applyGeneratedConfiguration( self.xmlFile)\n\n        spec.configKey = spec.configItem.configKey\n        spec.lastWheelConfigSaveId = spec.configItem.saveId\n    end\nend\n\n'})}),"\n",(0,s.jsx)(n.h3,{id:"onreadstream",children:"onReadStream"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Definition"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"onReadStream()"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"any"}),(0,s.jsx)(n.th,{children:"streamId"})]})}),(0,s.jsx)(n.tbody,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"any"}),(0,s.jsx)(n.td,{children:"connection"})]})})]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Code"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:"function Wheels:onReadStream(streamId, connection)\n    if connection.isServer then\n        local spec = self.spec_wheels\n        spec.networkTimeInterpolator:reset()\n        for i = 1 , #spec.wheels do\n            local wheel = spec.wheels[i]\n            if wheel.physics.isSynchronized then\n                wheel:readStream(streamId, true )\n            end\n        end\n\n        self.rotatedTimeInterpolator:setValue( 0 )\n    end\nend\n\n"})}),"\n",(0,s.jsx)(n.h3,{id:"onreadupdatestream",children:"onReadUpdateStream"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Definition"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"onReadUpdateStream()"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"any"}),(0,s.jsx)(n.th,{children:"streamId"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"any"}),(0,s.jsx)(n.td,{children:"timestamp"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"any"}),(0,s.jsx)(n.td,{children:"connection"})]})]})]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Code"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:"function Wheels:onReadUpdateStream(streamId, timestamp, connection)\n    if connection.isServer then\n        local hasUpdate = streamReadBool(streamId)\n        if hasUpdate then\n            local spec = self.spec_wheels\n            spec.networkTimeInterpolator:startNewPhaseNetwork()\n\n            for i = 1 , #spec.wheels do\n                local wheel = spec.wheels[i]\n                if wheel.physics.isSynchronized then\n                    wheel:readStream(streamId, false )\n                end\n            end\n\n            if self.maxRotTime ~ = 0 and self.minRotTime ~ = 0 then\n                local rotatedTimeRange = math.max( self.maxRotTime - self.minRotTime, 0.001 )\n                local rotatedTime = streamReadUIntN(streamId, 8 )\n                -- set to 0 due to inaccuracy\n                if math.abs( self.rotatedTime) < 0.001 then\n                    self.rotatedTime = 0\n                end\n\n                local rotatedTimeTarget = rotatedTime / 255 * rotatedTimeRange + self.minRotTime\n                self.rotatedTimeInterpolator:setTargetValue(rotatedTimeTarget)\n            end\n        end\n    end\nend\n\n"})}),"\n",(0,s.jsx)(n.h3,{id:"onregisteranimationvaluetypes",children:"onRegisterAnimationValueTypes"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"Called on pre load to register animation value types"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Definition"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"onRegisterAnimationValueTypes()"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Code"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:'function Wheels:onRegisterAnimationValueTypes()\n    self:registerAnimationValueType( "steeringAngle" , "startSteeringAngle" , "endSteeringAngle" , false , AnimationValueFloat ,\n    function (value, xmlFile, xmlKey)\n        value.wheelIndex = xmlFile:getValue(xmlKey .. "#wheelIndex" )\n        value.wheelNode = xmlFile:getValue(xmlKey .. "#node" , nil , self.components, self.i3dMappings)\n\n        if value.wheelIndex ~ = nil or value.wheelNode then\n            if value.wheelIndex ~ = nil then\n                value:setWarningInformation( "wheelIndex: " .. value.wheelIndex)\n                value:addCompareParameters( "wheelIndex" )\n            else\n                    value:setWarningInformation( "wheelNode: " .. getName(value.wheelNode))\n                    value:addCompareParameters( "wheelNode" )\n                end\n\n                return true\n            end\n\n            return false\n        end ,\n\n        function (value)\n            if value.wheelIndex ~ = nil or value.wheelNode ~ = nil then\n                if value.wheel = = nil and value.wheelIndex ~ = nil then\n                    value.wheel = self:getWheelFromWheelIndex(value.wheelIndex)\n                    if value.wheel = = nil then\n                        Logging.xmlWarning( self.xmlFile, "Unknown wheel index \'%s\' for animation part." , value.wheelIndex)\n                            value.wheelIndex = nil\n                            return 0\n                        end\n                    end\n\n                    if value.wheel = = nil and value.wheelNode ~ = nil then\n                        value.wheel = self:getWheelByWheelNode(value.wheelNode)\n                        if value.wheel = = nil then\n                            Logging.xmlWarning( self.xmlFile, "Unknown wheel node \'%s\' for animation part." , getName(value.wheelNode))\n                                value.wheelNode = nil\n                                return 0\n                            end\n                        end\n\n                        return value.wheel.physics.steeringAngle\n                    end\n\n                    return 0\n                end ,\n\n                function (value, steeringAngle)\n                    if value.wheel ~ = nil then\n                        value.wheel.physics.steeringAngle = steeringAngle\n                    end\n                end )\n\n                self:registerAnimationValueType( "brakeFactor" , "startBrakeFactor" , "endBrakeFactor" , false , AnimationValueFloat ,\n                function (value, xmlFile, xmlKey)\n                    value.wheelIndex = xmlFile:getValue(xmlKey .. "#wheelIndex" )\n                    value.wheelNode = xmlFile:getValue(xmlKey .. "#node" , nil , self.components, self.i3dMappings)\n\n                    if value.wheelIndex ~ = nil or value.wheelNode then\n                        if value.wheelIndex ~ = nil then\n                            value:setWarningInformation( "wheelIndex: " .. value.wheelIndex)\n                            value:addCompareParameters( "wheelIndex" )\n                        else\n                                value:setWarningInformation( "wheelNode: " .. getName(value.wheelNode))\n                                value:addCompareParameters( "wheelNode" )\n                            end\n\n                            return true\n                        end\n\n                        return false\n                    end ,\n\n                    function (value)\n                        if value.wheel = = nil and value.wheelIndex ~ = nil then\n                            value.wheel = self:getWheelFromWheelIndex(value.wheelIndex)\n                            if value.wheel = = nil then\n                                Logging.xmlWarning( self.xmlFile, "Unknown wheel index \'%s\' for animation part." , value.wheelIndex)\n                                    value.wheelIndex = nil\n                                    return 0\n                                end\n                            end\n\n                            if value.wheel = = nil and value.wheelNode ~ = nil then\n                                value.wheel = self:getWheelByWheelNode(value.wheelNode)\n                                if value.wheel = = nil then\n                                    Logging.xmlWarning( self.xmlFile, "Unknown wheel node \'%s\' for animation part." , getName(value.wheelNode))\n                                        value.wheelNode = nil\n                                        return 0\n                                    end\n                                end\n\n                                return value.wheel.physics.brakeFactor\n                            end ,\n\n                            function (value, brakeFactor)\n                                if value.wheel ~ = nil then\n                                    value.wheel.physics.brakeFactor = brakeFactor\n                                    value.wheel:updatePhysics( self:getBrakeForce())\n                                end\n                            end )\n\n                            self:registerAnimationValueType( "torqueDirection" , "startTorqueDirection" , "endTorqueDirection" , false , AnimationValueFloat ,\n                            function (value, xmlFile, xmlKey)\n                                value.wheelIndex = xmlFile:getValue(xmlKey .. "#wheelIndex" )\n                                value.wheelNode = xmlFile:getValue(xmlKey .. "#node" , nil , self.components, self.i3dMappings)\n\n                                if value.wheelIndex ~ = nil or value.wheelNode then\n                                    if value.wheelIndex ~ = nil then\n                                        value:setWarningInformation( "wheelIndex: " .. value.wheelIndex)\n                                        value:addCompareParameters( "wheelIndex" )\n                                    else\n                                            value:setWarningInformation( "wheelNode: " .. getName(value.wheelNode))\n                                            value:addCompareParameters( "wheelNode" )\n                                        end\n\n                                        return true\n                                    end\n\n                                    return false\n                                end ,\n\n                                function (value)\n                                    if value.wheel = = nil and value.wheelIndex ~ = nil then\n                                        value.wheel = self:getWheelFromWheelIndex(value.wheelIndex)\n                                        if value.wheel = = nil then\n                                            Logging.xmlWarning( self.xmlFile, "Unknown wheel index \'%s\' for animation part." , value.wheelIndex)\n                                                value.wheelIndex = nil\n                                                return 0\n                                            end\n                                        end\n\n                                        if value.wheel = = nil and value.wheelNode ~ = nil then\n                                            value.wheel = self:getWheelByWheelNode(value.wheelNode)\n                                            if value.wheel = = nil then\n                                                Logging.xmlWarning( self.xmlFile, "Unknown wheel node \'%s\' for animation part." , getName(value.wheelNode))\n                                                    value.wheelNode = nil\n                                                    return 0\n                                                end\n                                            end\n\n                                            return value.wheel.physics.torqueDirection\n                                        end ,\n\n                                        function (value, torqueDirection)\n                                            if value.wheel ~ = nil then\n                                                value.wheel.physics:setTorqueDirection(torqueDirection)\n                                            end\n                                        end )\n                                    end\n\n'})}),"\n",(0,s.jsx)(n.h3,{id:"onregisterdashboardvaluetypes",children:"onRegisterDashboardValueTypes"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"Called on post load to register dashboard value types"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Definition"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"onRegisterDashboardValueTypes()"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Code"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:'function Wheels:onRegisterDashboardValueTypes()\n    local spec = self.spec_wheels\n\n    local brake = DashboardValueType.new( "wheels" , "brake" )\n    brake:setValue(spec, "brakePedal" )\n    brake:setRange( 0 , 1 )\n    self:registerDashboardValueType(brake)\n\n    local steeringAngle = DashboardValueType.new( "wheels" , "steeringAngle" )\n    steeringAngle:setRange( - 180 , 180 )\n    steeringAngle:setValue(spec, function (_, dashboard)\n        if dashboard.steeringNodeIndex ~ = nil then\n            local steeringNode = spec.steeringNodes[dashboard.steeringNodeIndex]\n            if steeringNode ~ = nil then\n                return math.deg(steeringNode.steeringAngle)\n            end\n        end\n\n        if dashboard.wheelIndex ~ = nil then\n            local wheel = spec.wheels[dashboard.wheelIndex]\n            if wheel ~ = nil then\n                return math.deg(wheel.physics.steeringAngle)\n            end\n        end\n\n        return 0\n    end )\n    steeringAngle:setAdditionalFunctions( function ( self , xmlFile, key, dashboard, isActive)\n        dashboard.steeringNodeIndex = xmlFile:getValue(key .. "#steeringNodeIndex" )\n        dashboard.wheelIndex = xmlFile:getValue(key .. "#wheelIndex" )\n\n        return true\n    end )\n    self:registerDashboardValueType(steeringAngle)\nend\n\n'})}),"\n",(0,s.jsx)(n.h3,{id:"onupdate",children:"onUpdate"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"Called on update"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Definition"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"onUpdate(float dt, boolean isActiveForInput, boolean isSelected, )"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"float"}),(0,s.jsx)(n.th,{children:"dt"}),(0,s.jsx)(n.th,{children:"time since last call in ms"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"boolean"}),(0,s.jsx)(n.td,{children:"isActiveForInput"}),(0,s.jsx)(n.td,{children:"true if vehicle is active for input"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"boolean"}),(0,s.jsx)(n.td,{children:"isSelected"}),(0,s.jsx)(n.td,{children:"true if vehicle is selected"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"any"}),(0,s.jsx)(n.td,{children:"isSelected"}),(0,s.jsx)(n.td,{})]})]})]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Code"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:'function Wheels:onUpdate(dt, isActiveForInput, isActiveForInputIgnoreSelection, isSelected)\n    local spec = self.spec_wheels\n\n    -- interpolation of wheel properties\n    if not self.isServer and self.isClient then\n        --#profile RemoteProfiler.zoneBeginN("updateClient")\n\n        spec.networkTimeInterpolator:update(dt)\n        local interpolationAlpha = spec.networkTimeInterpolator:getAlpha()\n\n        self.rotatedTime = self.rotatedTimeInterpolator:getInterpolatedValue(interpolationAlpha)\n\n        for i = 1 , #spec.wheels do\n            local wheel = spec.wheels[i]\n            wheel:updateInterpolation(dt, interpolationAlpha)\n        end\n\n        if spec.networkTimeInterpolator:isInterpolating() then\n            self:raiseActive()\n        end\n\n        --#profile RemoteProfiler.zoneEnd()\n    end\n\n    if self.finishedFirstUpdate then\n        local groundWetness = g_currentMission.environment.weather:getGroundWetness()\n\n        for k, wheel in ipairs(spec.wheels) do\n            --#profile RemoteProfiler.zoneBeginN("wheel:update")\n            wheel:update(dt, spec.currentUpdateIndex, groundWetness)\n            --#profile RemoteProfiler.zoneEnd()\n        end\n\n        spec.currentUpdateIndex = spec.currentUpdateIndex + 1\n        if spec.currentUpdateIndex > 4 then\n            spec.currentUpdateIndex = 1\n        end\n\n        if self.isActive then\n            --#profile RemoteProfiler.zoneBeginN("updateWheelDestruction")\n\n            local allowFoliageDestruction = g_currentMission.missionInfo.fruitDestruction\n            allowFoliageDestruction = allowFoliageDestruction and not self:getIsAIActive()\n            allowFoliageDestruction = allowFoliageDestruction and( self.getBlockFoliageDestruction = = nil or not self:getBlockFoliageDestruction())\n\n            for k, wheel in ipairs(spec.wheels) do\n                wheel.destruction:update(dt, allowFoliageDestruction)\n            end\n            --#profile RemoteProfiler.zoneEnd()\n\n            --#profile RemoteProfiler.zoneBeginN("updateAxles")\n            if self.isServer and spec.hasAxles then\n                for _, axle in ipairs(spec.axles) do\n                    axle:update(dt)\n                end\n            end\n            --#profile RemoteProfiler.zoneEnd()\n        end\n\n        --#profile RemoteProfiler.zoneBeginN("updateSurfaceSound")\n        if spec.surfaceSounds ~ = nil then\n            -- update surface sounds\n            if self:getAreSurfaceSoundsActive() then\n                local currentSound = self:getCurrentSurfaceSound()\n                if currentSound ~ = spec.currentSurfaceSound then\n                    if spec.currentSurfaceSound ~ = nil then\n                        g_soundManager:stopSample(spec.currentSurfaceSound)\n                    end\n                    if currentSound ~ = nil then\n                        g_soundManager:playSample(currentSound)\n                    end\n\n                    spec.currentSurfaceSound = currentSound\n                end\n            else\n                    if spec.currentSurfaceSound ~ = nil then\n                        g_soundManager:stopSample(spec.currentSurfaceSound)\n                        spec.currentSurfaceSound = nil\n                    end\n                end\n            end\n            --#profile RemoteProfiler.zoneEnd()\n\n            if spec.hasSteeringNodes then\n                self:updateSteeringNodes(dt)\n            end\n        end\n\n        if #spec.wheels > 0 then\n            if self.isServer then\n                self:raiseDirtyFlags(spec.dirtyFlag)\n            end\n        end\n    end\n\n'})}),"\n",(0,s.jsx)(n.h3,{id:"onupdateend",children:"onUpdateEnd"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"Called after last update tick"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Definition"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"onUpdateEnd(float dt, boolean isActive, boolean isActiveForInput, boolean isSelected)"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"float"}),(0,s.jsx)(n.th,{children:"dt"}),(0,s.jsx)(n.th,{children:"time since last call in ms"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"boolean"}),(0,s.jsx)(n.td,{children:"isActive"}),(0,s.jsx)(n.td,{children:"true if vehicle is active"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"boolean"}),(0,s.jsx)(n.td,{children:"isActiveForInput"}),(0,s.jsx)(n.td,{children:"true if vehicle is active for input"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"boolean"}),(0,s.jsx)(n.td,{children:"isSelected"}),(0,s.jsx)(n.td,{children:"true if vehicle is selected"})]})]})]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Code"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:"function Wheels:onUpdateEnd(dt, isActiveForInput, isActiveForInputIgnoreSelection, isSelected)\n    if self.isClient then\n        local spec = self.spec_wheels\n        for _, wheel in pairs(spec.wheels) do\n            wheel:onUpdateEnd()\n        end\n\n        if spec.currentSurfaceSound ~ = nil then\n            g_soundManager:stopSample(spec.currentSurfaceSound)\n            spec.currentSurfaceSound = nil\n        end\n    end\nend\n\n"})}),"\n",(0,s.jsx)(n.h3,{id:"onupdatetick",children:"onUpdateTick"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"Called on update tick"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Definition"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"onUpdateTick(float dt, boolean isActive, boolean isActiveForInput, boolean isSelected)"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"float"}),(0,s.jsx)(n.th,{children:"dt"}),(0,s.jsx)(n.th,{children:"time since last call in ms"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"boolean"}),(0,s.jsx)(n.td,{children:"isActive"}),(0,s.jsx)(n.td,{children:"true if vehicle is active"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"boolean"}),(0,s.jsx)(n.td,{children:"isActiveForInput"}),(0,s.jsx)(n.td,{children:"true if vehicle is active for input"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"boolean"}),(0,s.jsx)(n.td,{children:"isSelected"}),(0,s.jsx)(n.td,{children:"true if vehicle is selected"})]})]})]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Code"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:"function Wheels:onUpdateTick(dt, isActiveForInput, isActiveForInputIgnoreSelection, isSelected)\n    local spec = self.spec_wheels\n\n    local groundWetness = g_currentMission.environment.weather:getGroundWetness()\n    for _, wheel in pairs(spec.wheels) do\n        wheel:updateTick(dt, groundWetness, self.currentUpdateDistance)\n    end\nend\n\n"})}),"\n",(0,s.jsx)(n.h3,{id:"onwheelhubi3dloaded",children:"onWheelHubI3DLoaded"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"Called when wheel hub i3d was loaded"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Definition"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"onWheelHubI3DLoaded(integer i3dNode, table args, )"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"integer"}),(0,s.jsx)(n.th,{children:"i3dNode"}),(0,s.jsx)(n.th,{children:"i3dNode of wheel chock"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"table"}),(0,s.jsx)(n.td,{children:"args"}),(0,s.jsx)(n.td,{children:"arguments"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"any"}),(0,s.jsx)(n.td,{children:"args"}),(0,s.jsx)(n.td,{})]})]})]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Code"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:"function Wheels:onWheelHubI3DLoaded(i3dNode, failedReason, args)\n    local spec = self.spec_wheels\n    local hub = args.hub\n    local linkNode = args.linkNode\n    local xmlFile = args.xmlFile\n    local key = args.key\n\n    if i3dNode ~ = 0 then\n        hub.node = I3DUtil.indexToObject(i3dNode, hub.nodeStr, self.i3dMappings)\n\n        if hub.node ~ = nil then\n            link(linkNode, hub.node)\n            delete(i3dNode)\n        else\n                Logging.xmlError(xmlFile, \"Could not find hub node '%s' in '%s'\" , hub.nodeStr, hub.xmlFilename)\n                return\n            end\n\n            local offset = xmlFile:getValue(key .. \"#offset\" )\n            if offset ~ = nil then\n                if not hub.isLeft then\n                    offset = offset * - 1\n                end\n                setTranslation(hub.node, offset, 0 , 0 )\n            end\n\n            local scale = xmlFile:getValue(key .. \"#scale\" , nil , true )\n            if scale ~ = nil then\n                setScale(hub.node, scale[ 1 ], scale[ 2 ], scale[ 3 ])\n            end\n\n            table.insert(spec.hubs, hub)\n        else\n                if not( self.isDeleting or self.isDeleted) then\n                    Logging.xmlError(xmlFile, \"Unable to load '%s' in hub '%s'\" , hub.i3dFilename, hub.xmlFilename)\n                end\n            end\n        end\n\n"})}),"\n",(0,s.jsx)(n.h3,{id:"onwheelsnowheightchanged",children:"onWheelSnowHeightChanged"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Definition"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"onWheelSnowHeightChanged()"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"any"}),(0,s.jsx)(n.th,{children:"heightPct"})]})}),(0,s.jsx)(n.tbody,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"any"}),(0,s.jsx)(n.td,{children:"heightAbs"})]})})]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Code"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:"function Wheels:onWheelSnowHeightChanged(heightPct, heightAbs)\n    if heightPct < = 0 then\n        local spec = self.spec_wheels\n        local changedSnowScale = false\n        for i = 1 , #spec.wheels do\n            if spec.wheels[i].physics.snowScale > 0 then\n                spec.wheels[i].physics.snowScale = 0\n                spec.wheels[i].forceWheelDirtUpdate = true\n                changedSnowScale = true\n            end\n        end\n\n        -- raise active to update dirt amount\n        if changedSnowScale then\n            self:raiseActive()\n        end\n    end\nend\n\n"})}),"\n",(0,s.jsx)(n.h3,{id:"onwritestream",children:"onWriteStream"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Definition"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"onWriteStream()"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"any"}),(0,s.jsx)(n.th,{children:"streamId"})]})}),(0,s.jsx)(n.tbody,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"any"}),(0,s.jsx)(n.td,{children:"connection"})]})})]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Code"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:"function Wheels:onWriteStream(streamId, connection)\n    if not connection.isServer then\n        local spec = self.spec_wheels\n        for i = 1 , #spec.wheels do\n            local wheel = spec.wheels[i]\n            if wheel.physics.isSynchronized then\n                wheel:writeStream(streamId)\n            end\n        end\n    end\nend\n\n"})}),"\n",(0,s.jsx)(n.h3,{id:"onwriteupdatestream",children:"onWriteUpdateStream"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Definition"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"onWriteUpdateStream()"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"any"}),(0,s.jsx)(n.th,{children:"streamId"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"any"}),(0,s.jsx)(n.td,{children:"connection"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"any"}),(0,s.jsx)(n.td,{children:"dirtyMask"})]})]})]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Code"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:"function Wheels:onWriteUpdateStream(streamId, connection, dirtyMask)\n    if not connection.isServer then\n        local spec = self.spec_wheels\n\n        if streamWriteBool(streamId, bit32.band(dirtyMask, spec.dirtyFlag) ~ = 0 ) then\n            for i = 1 , #spec.wheels do\n                local wheel = spec.wheels[i]\n                if wheel.physics.isSynchronized then\n                    wheel:writeStream(streamId)\n                end\n            end\n\n            if self.maxRotTime ~ = 0 and self.minRotTime ~ = 0 then\n                local rotatedTimeRange = math.max( self.maxRotTime - self.minRotTime, 0.001 )\n                local rotatedTime = math.clamp( math.floor(( self.rotatedTime - self.minRotTime) / rotatedTimeRange * 255 ), 0 , 255 )\n                streamWriteUIntN(streamId, rotatedTime, 8 )\n            end\n        end\n    end\nend\n\n"})}),"\n",(0,s.jsx)(n.h3,{id:"prerequisitespresent",children:"prerequisitesPresent"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Definition"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"prerequisitesPresent()"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,s.jsx)(n.table,{children:(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"any"}),(0,s.jsx)(n.th,{children:"specializations"})]})})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Code"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:"function Wheels.prerequisitesPresent(specializations)\n    return true\nend\n\n"})}),"\n",(0,s.jsx)(n.h3,{id:"registerackermannsteeringxmlpaths",children:"registerAckermannSteeringXMLPaths"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Definition"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"registerAckermannSteeringXMLPaths()"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"any"}),(0,s.jsx)(n.th,{children:"schema"})]})}),(0,s.jsx)(n.tbody,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"any"}),(0,s.jsx)(n.td,{children:"key"})]})})]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Code"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:'function Wheels.registerAckermannSteeringXMLPaths(schema, key)\n    schema:register(XMLValueType.FLOAT, key .. "#rotSpeed" , "Rotation speed" )\n    schema:register(XMLValueType.FLOAT, key .. "#rotMax" , "Max.rotation" )\n    schema:register(XMLValueType.INT, key .. "#rotCenterWheel1" , "Rotation center wheel 1" )\n    schema:register(XMLValueType.INT, key .. "#rotCenterWheel2" , "Rotation center wheel 2" )\n    schema:register(XMLValueType.VECTOR_N, key .. "#rotCenterWheels" , "List of wheel indices which represent the steering center" )\n    schema:register(XMLValueType.NODE_INDEX, key .. "#rotCenterNode" , "Rotation center node(Used if rotCenterWheelX not given)" )\n        schema:register(XMLValueType.VECTOR_ 2 , key .. "#rotCenter" , "Center position(from root component) (Used if rotCenterWheelX not given)" )\n            schema:register(XMLValueType.FLOAT, key .. "#minTurningRadius" , "Overwrites the automatically calculated turning radius for this config" )\n            end\n\n'})}),"\n",(0,s.jsx)(n.h3,{id:"registereventlisteners",children:"registerEventListeners"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Definition"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"registerEventListeners()"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,s.jsx)(n.table,{children:(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"any"}),(0,s.jsx)(n.th,{children:"vehicleType"})]})})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Code"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:'function Wheels.registerEventListeners(vehicleType)\n    SpecializationUtil.registerEventListener(vehicleType, "onPreLoad" , Wheels )\n    SpecializationUtil.registerEventListener(vehicleType, "onLoad" , Wheels )\n    SpecializationUtil.registerEventListener(vehicleType, "onLoadFinished" , Wheels )\n    SpecializationUtil.registerEventListener(vehicleType, "onRegisterDashboardValueTypes" , Wheels )\n    SpecializationUtil.registerEventListener(vehicleType, "onDelete" , Wheels )\n    SpecializationUtil.registerEventListener(vehicleType, "onReadStream" , Wheels )\n    SpecializationUtil.registerEventListener(vehicleType, "onWriteStream" , Wheels )\n    SpecializationUtil.registerEventListener(vehicleType, "onReadUpdateStream" , Wheels )\n    SpecializationUtil.registerEventListener(vehicleType, "onWriteUpdateStream" , Wheels )\n    SpecializationUtil.registerEventListener(vehicleType, "onUpdate" , Wheels )\n    SpecializationUtil.registerEventListener(vehicleType, "onPostUpdate" , Wheels )\n    SpecializationUtil.registerEventListener(vehicleType, "onUpdateTick" , Wheels )\n    SpecializationUtil.registerEventListener(vehicleType, "onUpdateEnd" , Wheels )\n    SpecializationUtil.registerEventListener(vehicleType, "onLeaveVehicle" , Wheels )\n    SpecializationUtil.registerEventListener(vehicleType, "onPreAttach" , Wheels )\n    SpecializationUtil.registerEventListener(vehicleType, "onPostDetach" , Wheels )\n    SpecializationUtil.registerEventListener(vehicleType, "onRegisterAnimationValueTypes" , Wheels )\n    SpecializationUtil.registerEventListener(vehicleType, "onPostAttachImplement" , Wheels )\n    SpecializationUtil.registerEventListener(vehicleType, "onAIFieldWorkerStart" , Wheels )\n    SpecializationUtil.registerEventListener(vehicleType, "onAIImplementStart" , Wheels )\n    SpecializationUtil.registerEventListener(vehicleType, "onAIFieldWorkerEnd" , Wheels )\n    SpecializationUtil.registerEventListener(vehicleType, "onAIImplementEnd" , Wheels )\nend\n\n'})}),"\n",(0,s.jsx)(n.h3,{id:"registerevents",children:"registerEvents"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Definition"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"registerEvents()"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,s.jsx)(n.table,{children:(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"any"}),(0,s.jsx)(n.th,{children:"vehicleType"})]})})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Code"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:'function Wheels.registerEvents(vehicleType)\n    SpecializationUtil.registerEvent(vehicleType, "onBrake" )\n    SpecializationUtil.registerEvent(vehicleType, "onFinishedWheelLoading" )\n    SpecializationUtil.registerEvent(vehicleType, "onWheelConfigurationChanged" )\nend\n\n'})}),"\n",(0,s.jsx)(n.h3,{id:"registerfunctions",children:"registerFunctions"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Definition"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"registerFunctions()"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,s.jsx)(n.table,{children:(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"any"}),(0,s.jsx)(n.th,{children:"vehicleType"})]})})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Code"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:'function Wheels.registerFunctions(vehicleType)\n    SpecializationUtil.registerFunction(vehicleType, "getSteeringRotTimeByCurvature" , Wheels.getSteeringRotTimeByCurvature)\n    SpecializationUtil.registerFunction(vehicleType, "getTurningRadiusByRotTime" , Wheels.getTurningRadiusByRotTime)\n\n    SpecializationUtil.registerFunction(vehicleType, "loadHubsFromXML" , Wheels.loadHubsFromXML)\n    SpecializationUtil.registerFunction(vehicleType, "loadHubFromXML" , Wheels.loadHubFromXML)\n    SpecializationUtil.registerFunction(vehicleType, "onWheelHubI3DLoaded" , Wheels.onWheelHubI3DLoaded)\n\n    SpecializationUtil.registerFunction(vehicleType, "loadAckermannSteeringFromXML" , Wheels.loadAckermannSteeringFromXML)\n\n    SpecializationUtil.registerFunction(vehicleType, "loadWheelsFromXML" , Wheels.loadWheelsFromXML)\n    SpecializationUtil.registerFunction(vehicleType, "loadWheelFromXML" , Wheels.loadWheelFromXML)\n\n    SpecializationUtil.registerFunction(vehicleType, "onLoadWheelChockFromXML" , Wheels.onLoadWheelChockFromXML)\n    SpecializationUtil.registerFunction(vehicleType, "getIsWheelChockAllowed" , Wheels.getIsWheelChockAllowed)\n\n    SpecializationUtil.registerFunction(vehicleType, "getIsVersatileYRotActive" , Wheels.getIsVersatileYRotActive)\n    SpecializationUtil.registerFunction(vehicleType, "getWheelFromWheelIndex" , Wheels.getWheelFromWheelIndex)\n    SpecializationUtil.registerFunction(vehicleType, "getWheelByWheelNode" , Wheels.getWheelByWheelNode)\n    SpecializationUtil.registerFunction(vehicleType, "getWheels" , Wheels.getWheels)\n    SpecializationUtil.registerFunction(vehicleType, "getCurrentSurfaceSound" , Wheels.getCurrentSurfaceSound)\n    SpecializationUtil.registerFunction(vehicleType, "getAreSurfaceSoundsActive" , Wheels.getAreSurfaceSoundsActive)\n    SpecializationUtil.registerFunction(vehicleType, "brake" , Wheels.brake)\n    SpecializationUtil.registerFunction(vehicleType, "getBrakeForce" , Wheels.getBrakeForce)\n    SpecializationUtil.registerFunction(vehicleType, "setCustomBrakeForce" , Wheels.setCustomBrakeForce)\n    SpecializationUtil.registerFunction(vehicleType, "updateWheelDirtAmount" , Wheels.updateWheelDirtAmount)\n    SpecializationUtil.registerFunction(vehicleType, "updateWheelMudAmount" , Wheels.updateWheelMudAmount)\n    SpecializationUtil.registerFunction(vehicleType, "forceUpdateWheelPhysics" , Wheels.forceUpdateWheelPhysics)\n    SpecializationUtil.registerFunction(vehicleType, "onWheelSnowHeightChanged" , Wheels.onWheelSnowHeightChanged)\n    SpecializationUtil.registerFunction(vehicleType, "getSteeringNodeByNode" , Wheels.getSteeringNodeByNode)\n    SpecializationUtil.registerFunction(vehicleType, "updateSteeringNodes" , Wheels.updateSteeringNodes)\nend\n\n'})}),"\n",(0,s.jsx)(n.h3,{id:"registeroverwrittenfunctions",children:"registerOverwrittenFunctions"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Definition"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"registerOverwrittenFunctions()"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,s.jsx)(n.table,{children:(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"any"}),(0,s.jsx)(n.th,{children:"vehicleType"})]})})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Code"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:'function Wheels.registerOverwrittenFunctions(vehicleType)\n    SpecializationUtil.registerOverwrittenFunction(vehicleType, "addToPhysics" , Wheels.addToPhysics)\n    SpecializationUtil.registerOverwrittenFunction(vehicleType, "removeFromPhysics" , Wheels.removeFromPhysics)\n    SpecializationUtil.registerOverwrittenFunction(vehicleType, "getComponentMass" , Wheels.getComponentMass)\n    SpecializationUtil.registerOverwrittenFunction(vehicleType, "getVehicleWorldXRot" , Wheels.getVehicleWorldXRot)\n    SpecializationUtil.registerOverwrittenFunction(vehicleType, "getVehicleWorldDirection" , Wheels.getVehicleWorldDirection)\n    SpecializationUtil.registerOverwrittenFunction(vehicleType, "validateWashableNode" , Wheels.validateWashableNode)\n    SpecializationUtil.registerOverwrittenFunction(vehicleType, "getAIDirectionNode" , Wheels.getAIDirectionNode)\n    SpecializationUtil.registerOverwrittenFunction(vehicleType, "getAIRootNode" , Wheels.getAIRootNode)\n    SpecializationUtil.registerOverwrittenFunction(vehicleType, "getSupportsMountKinematic" , Wheels.getSupportsMountKinematic)\n    SpecializationUtil.registerOverwrittenFunction(vehicleType, "loadBendingNodeFromXML" , Wheels.loadBendingNodeFromXML)\nend\n\n'})}),"\n",(0,s.jsx)(n.h3,{id:"removefromphysics",children:"removeFromPhysics"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Definition"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"removeFromPhysics()"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,s.jsx)(n.table,{children:(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"any"}),(0,s.jsx)(n.th,{children:"superFunc"})]})})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Code"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:"function Wheels:removeFromPhysics(superFunc)\n    local ret = superFunc( self )\n\n    if self.isServer then\n        local spec = self.spec_wheels\n        for _, wheel in pairs(spec.wheels) do\n            wheel:removeFromPhysics()\n        end\n    end\n\n    return ret\nend\n\n"})}),"\n",(0,s.jsx)(n.h3,{id:"savetoxmlfile",children:"saveToXMLFile"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Definition"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"saveToXMLFile()"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"any"}),(0,s.jsx)(n.th,{children:"xmlFile"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"any"}),(0,s.jsx)(n.td,{children:"key"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"any"}),(0,s.jsx)(n.td,{children:"usedModNames"})]})]})]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Code"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:'function Wheels:saveToXMLFile(xmlFile, key, usedModNames)\n    local spec = self.spec_wheels\n    if spec.lastWheelConfigSaveId ~ = nil then\n        xmlFile:setValue(key .. "#lastConfigId" , spec.lastWheelConfigSaveId)\n    end\nend\n\n'})}),"\n",(0,s.jsx)(n.h3,{id:"updatesteeringnodes",children:"updateSteeringNodes"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Definition"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"updateSteeringNodes()"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,s.jsx)(n.table,{children:(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"any"}),(0,s.jsx)(n.th,{children:"dt"})]})})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Code"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:"function Wheels:updateSteeringNodes(dt)\n    local spec = self.spec_wheels\n    for _, steeringNode in ipairs(spec.steeringNodes) do\n        local targetSteeringAngle\n        if self.rotatedTime > 0 or steeringNode.rotSpeedNeg = = nil then\n            targetSteeringAngle = self.rotatedTime * steeringNode.rotSpeed\n        else\n                targetSteeringAngle = self.rotatedTime * steeringNode.rotSpeedNeg\n            end\n\n            if targetSteeringAngle > steeringNode.rotMax then\n                targetSteeringAngle = steeringNode.rotMax\n            elseif targetSteeringAngle < steeringNode.rotMin then\n                    targetSteeringAngle = steeringNode.rotMin\n                end\n\n                if steeringNode.rotScale ~ = steeringNode.rotScaleTarget then\n                    local direction = math.sign(steeringNode.rotScaleTarget - steeringNode.rotScale)\n                    local change = dt * steeringNode.rotScaleTargetSpeed * direction\n                    local limit = direction > 0 and math.min or math.max\n                    steeringNode.rotScale = limit(steeringNode.rotScale + change, steeringNode.rotScaleTarget)\n                end\n                targetSteeringAngle = targetSteeringAngle * steeringNode.rotScale\n\n                if steeringNode.offset ~ = steeringNode.offsetTarget then\n                    local direction = math.sign(steeringNode.offsetTarget - steeringNode.offset)\n                    local change = dt * steeringNode.offsetTargetSpeed * direction\n                    local limit = direction > 0 and math.min or math.max\n                    steeringNode.offset = limit(steeringNode.offset + change, steeringNode.offsetTarget)\n                end\n                targetSteeringAngle = targetSteeringAngle + steeringNode.offset\n\n                local _, steeringAngle, _ = getRotation(steeringNode.node)\n                if math.abs(steeringAngle - targetSteeringAngle) > 0.004 then\n                    local direction = math.sign(targetSteeringAngle - steeringAngle)\n                    local change = dt * steeringNode.rotChangeSpeed * 0.001 * direction\n                    local limit = direction > 0 and math.min or math.max\n                    steeringAngle = limit(steeringAngle + change, targetSteeringAngle)\n\n                    setRotation(steeringNode.node, 0 , steeringAngle, 0 )\n                    steeringNode.steeringAngle = steeringAngle\n\n                    if self.isServer then\n                        if steeringNode.componentJoint ~ = nil then\n                            self:setComponentJointFrame(steeringNode.componentJoint, 0 )\n                        end\n                    end\n                end\n            end\n        end\n\n"})}),"\n",(0,s.jsx)(n.h3,{id:"updatewheeldirtamount",children:"updateWheelDirtAmount"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Definition"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"updateWheelDirtAmount()"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"any"}),(0,s.jsx)(n.th,{children:"nodeData"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"any"}),(0,s.jsx)(n.td,{children:"dt"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"any"}),(0,s.jsx)(n.td,{children:"allowsWashingByRain"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"any"}),(0,s.jsx)(n.td,{children:"rainScale"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"any"}),(0,s.jsx)(n.td,{children:"timeSinceLastRain"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"any"}),(0,s.jsx)(n.td,{children:"temperature"})]})]})]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Code"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:"function Wheels:updateWheelDirtAmount(nodeData, dt, allowsWashingByRain, rainScale, timeSinceLastRain, temperature)\n    local changeDirt, changeWetness = 0 , 0\n    local dirtMultiplier = self.spec_washable.lastDirtMultiplier\n    if dirtMultiplier ~ = 0 then\n        changeDirt = dt * self.spec_washable.dirtDuration * dirtMultiplier\n    end\n\n    local allowManipulation = true\n    if nodeData.wheel ~ = nil then\n        if nodeData.wheel.physics.contact = = WheelContactType.NONE and nodeData.wheel.forceWheelDirtUpdate ~ = true then\n            allowManipulation = false\n        end\n    end\n\n    if allowManipulation then\n        local physics = nodeData.wheel.physics\n        local isOnDirtField = physics:getIsOnField()\n\n        local lastSpeed = self.lastSpeed * 3600\n\n        if isOnDirtField then\n            changeDirt = changeDirt * nodeData.fieldDirtMultiplier\n        else\n                -- dirt is not reduced when driving on grassland, just not increased more\n                if not self.isOnField then\n                    if nodeData.dirtAmount > nodeData.minDirtPercentage then\n                        local dirtFactor = lastSpeed / 20\n                        dirtFactor = dirtFactor * nodeData.streetDirtMultiplier\n                        dirtFactor = dirtFactor * (rainScale > 0.1 and 0.15 or 1 ) -- mud sticks more when it's wet\n\n                        changeDirt = changeDirt * dirtFactor\n                    end\n                end\n            end\n\n            if nodeData.wetness < 0.25 then\n                local globalValue = self.spec_washable.washableNodes[ 1 ].dirtAmount\n                local minDirtOffset = nodeData.maxDirtOffset * ( math.pow( 1 - globalValue, 2 ) * 0.75 + 0.25 )\n                local maxDirtOffset = nodeData.maxDirtOffset * ( math.pow( 1 - globalValue, 2 ) * 0.95 + 0.05 )\n                if globalValue - nodeData.dirtAmount > minDirtOffset then\n                    if changeDirt < 0 then\n                        changeDirt = 0\n                    end\n                elseif globalValue - nodeData.dirtAmount < - maxDirtOffset then\n                        if changeDirt > 0 then\n                            changeDirt = 0\n                        end\n                    end\n                end\n\n                -- change dirt scale of wheels slowly to snow color when having snow contact\n                -- changing back to normal color takes longer\n                local factor = (physics.hasSnowContact and(temperature or 0 ) < 1 ) and 1 or - 0.25\n                local speedFactor = math.min(lastSpeed / 5 , 2 )\n                local lastSnowScale = physics.snowScale\n                physics.snowScale = math.min( math.max(lastSnowScale + factor * dt * nodeData.dirtColorChangeSpeed * speedFactor, 0 ), 1 )\n\n                if physics.snowScale ~ = physics.lastSnowScale then\n                    local defaultColor, snowColor = g_currentMission.environment:getDirtColors()\n                    local r, g, b = MathUtil.vector3ArrayLerp(defaultColor, snowColor, physics.snowScale)\n                    self:setNodeDirtColor(nodeData, r, g, b)\n\n                    physics.lastSnowScale = physics.snowScale\n                end\n\n                if physics.hasWaterContact then\n                    changeWetness = dt * self.spec_washable.wetDuration * nodeData.waterWetnessFactor * ( 1 + math.min( self.lastSpeed * 3600 / 10 , 1 ))\n                else\n                        changeWetness = - dt * self.spec_washable.dryDuration * ( math.min( self.lastSpeed * 3600 / 10 , 1 ) * 5 )\n                    end\n\n                    nodeData.wheel.forceWheelDirtUpdate = false\n                end\n\n                return changeDirt, changeWetness\n            end\n\n"})}),"\n",(0,s.jsx)(n.h3,{id:"updatewheelmudamount",children:"updateWheelMudAmount"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Definition"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"updateWheelMudAmount()"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"any"}),(0,s.jsx)(n.th,{children:"nodeData"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"any"}),(0,s.jsx)(n.td,{children:"dt"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"any"}),(0,s.jsx)(n.td,{children:"allowsWashingByRain"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"any"}),(0,s.jsx)(n.td,{children:"rainScale"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"any"}),(0,s.jsx)(n.td,{children:"timeSinceLastRain"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"any"}),(0,s.jsx)(n.td,{children:"temperature"})]})]})]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Code"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:"function Wheels:updateWheelMudAmount(nodeData, dt, allowsWashingByRain, rainScale, timeSinceLastRain, temperature)\n    local changeDirt, changeWetness = 0 , 0\n    local dirtMultiplier = self.spec_washable.lastDirtMultiplier\n    if dirtMultiplier ~ = 0 then\n        changeDirt = dt * self.spec_washable.dirtDuration * dirtMultiplier\n    end\n\n    if nodeData.wheelDirtNode = = nil then\n        nodeData.wheelDirtNode = self:getWashableNodeByCustomIndex(nodeData.wheel)\n\n        if nodeData.wheelDirtNode = = nil then\n            return 0 , 0\n        end\n    end\n\n    if nodeData.wheel ~ = nil then\n        if nodeData.wheel.physics.contact = = WheelContactType.NONE and nodeData.wheel.forceWheelDirtUpdate ~ = true then\n            return 0 , nodeData.wheelDirtNode.wetness - nodeData.wetness\n        end\n    end\n\n    local lastSpeed = self.lastSpeed * 3600\n    local maxAmount = WheelEffects.MAX_MUD_AMOUNT[nodeData.wheel.physics.densityType] or 0\n    maxAmount = maxAmount * (rainScale > 0.1 and 1 or 0.5 ) -- full mud only when it's wet, otherwise 50%\n\n    local wheelDirtAmount = nodeData.wheelDirtNode.dirtAmount\n\n    if nodeData.dirtAmount < maxAmount and wheelDirtAmount > 0.75 then\n        changeDirt = changeDirt * nodeData.fieldDirtMultiplier * 2\n    elseif nodeData.dirtAmount > maxAmount or wheelDirtAmount < 0.75 then\n            local speedFactor = lastSpeed / 20\n            changeDirt = changeDirt * nodeData.streetDirtMultiplier * 2 * speedFactor\n        end\n\n        changeWetness = nodeData.wheelDirtNode.wetness - nodeData.wetness\n\n        local colorMud, colorWheel = nodeData.color, nodeData.wheelDirtNode.color\n        if colorMud[ 1 ] ~ = colorWheel[ 1 ] or colorMud[ 2 ] ~ = colorWheel[ 2 ] or colorMud[ 3 ] ~ = colorWheel[ 3 ] then\n            self:setNodeDirtColor(nodeData, colorWheel[ 1 ], colorWheel[ 2 ], colorWheel[ 3 ])\n        end\n\n        return changeDirt, changeWetness\n    end\n\n"})}),"\n",(0,s.jsx)(n.h3,{id:"validatewashablenode",children:"validateWashableNode"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Definition"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"validateWashableNode()"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"any"}),(0,s.jsx)(n.th,{children:"superFunc"})]})}),(0,s.jsx)(n.tbody,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"any"}),(0,s.jsx)(n.td,{children:"node"})]})})]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Code"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:'function Wheels:validateWashableNode(superFunc, node)\n    -- start checking the wheel nodes only if all wheel parts are loaded\n        if self.loadingStep > = SpecializationLoadStep.FINISHED then\n            local spec = self.spec_wheels\n            for i = 1 , #spec.wheels do\n                local wheel = spec.wheels[i]\n                local wheelNode = wheel.driveNode\n                if wheel.linkNode ~ = wheel.driveNode then\n                    wheelNode = wheel.linkNode\n                end\n\n                if wheel.wheelDirtNodes = = nil then\n                    wheel.wheelDirtNodes = { }\n                    I3DUtil.getNodesByShaderParam(wheelNode, "scratches_dirt_snow_wetness" , wheel.wheelDirtNodes)\n                end\n\n                if wheel.wheelMudMeshes = = nil then\n                    wheel.wheelMudMeshes = { }\n                    I3DUtil.getNodesByShaderParam(wheelNode, "mudAmount" , wheel.wheelMudMeshes)\n                end\n\n                if wheel.wheelDirtNodes[node] ~ = nil then\n                    local nodeData = { }\n                    nodeData.wheel = wheel\n                    nodeData.fieldDirtMultiplier = wheel.physics.fieldDirtMultiplier\n                    nodeData.streetDirtMultiplier = wheel.physics.streetDirtMultiplier\n                    nodeData.waterWetnessFactor = wheel.physics.waterWetnessFactor\n                    nodeData.minDirtPercentage = wheel.physics.minDirtPercentage\n                    nodeData.maxDirtOffset = wheel.physics.maxDirtOffset\n                    nodeData.dirtColorChangeSpeed = wheel.physics.dirtColorChangeSpeed\n                    nodeData.isSnowNode = true\n\n                    nodeData.loadFromSavegameFunc = function (xmlFile, key)\n                        nodeData.wheel.physics.snowScale = xmlFile:getValue(key .. "#snowScale" , 0 )\n                        nodeData.wheel.physics.lastSnowScale = nodeData.wheel.physics.snowScale\n\n                        local defaultColor, snowColor = g_currentMission.environment:getDirtColors()\n                        local r, g, b = MathUtil.vector3ArrayLerp(defaultColor, snowColor, nodeData.wheel.physics.snowScale)\n                        local washableNode = self:getWashableNodeByCustomIndex(wheel)\n                        self:setNodeDirtColor(washableNode, r, g, b, true )\n                    end\n                    nodeData.saveToSavegameFunc = function (xmlFile, key)\n                        xmlFile:setValue(key .. "#snowScale" , nodeData.wheel.physics.snowScale)\n                    end\n\n                    return false , self.updateWheelDirtAmount, wheel, nodeData\n                end\n\n                if wheel.wheelMudMeshes[node] ~ = nil then\n                    local nodeData = { }\n                    nodeData.wheel = wheel\n                    nodeData.fieldDirtMultiplier = wheel.physics.fieldDirtMultiplier\n                    nodeData.streetDirtMultiplier = wheel.physics.streetDirtMultiplier\n                    nodeData.waterWetnessFactor = wheel.physics.waterWetnessFactor\n                    nodeData.minDirtPercentage = wheel.physics.minDirtPercentage\n                    nodeData.maxDirtOffset = wheel.physics.maxDirtOffset\n                    nodeData.dirtColorChangeSpeed = wheel.physics.dirtColorChangeSpeed\n                    nodeData.isSnowNode = true\n                    nodeData.cleaningMultiplier = 4\n\n                    -- randomly rotate the mud mesh, so they do not look the same on each tire\n                        rotateAboutLocalAxis(node, math.random() * 3.14 , 1 , 0 , 0 )\n\n                        return false , self.updateWheelMudAmount, wheel.wheelMudMeshes, nodeData\n                    end\n                end\n            end\n\n            return superFunc( self , node)\n        end\n\n'})})]})}function c(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(h,{...e})}):h(e)}}}]);