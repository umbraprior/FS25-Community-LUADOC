"use strict";(globalThis.webpackChunkfs25_community_luadoc=globalThis.webpackChunkfs25_community_luadoc||[]).push([[64150],{13933(e,n,o){o.r(n),o.d(n,{assets:()=>d,contentTitle:()=>a,default:()=>p,frontMatter:()=>l,metadata:()=>i,toc:()=>r});const i=JSON.parse('{"id":"script/Specializations/SlopeCompensation","title":"SlopeCompensation","description":"SlopeCompensation","source":"@site/../docs/script/Specializations/SlopeCompensation.md","sourceDirName":"script/Specializations","slug":"/script/Specializations/SlopeCompensation","permalink":"/FS25-Community-LUADOC/script/Specializations/SlopeCompensation","draft":false,"unlisted":false,"tags":[],"version":"current","lastUpdatedAt":1767161192000,"frontMatter":{},"sidebar":"docsSidebar","previous":{"title":"Shovel","permalink":"/FS25-Community-LUADOC/script/Specializations/Shovel"},"next":{"title":"SmartAttachActivatable","permalink":"/FS25-Community-LUADOC/script/Specializations/SmartAttachActivatable"}}');var t=o(74848),s=o(28453);const l={},a=void 0,d={},r=[{value:"SlopeCompensation",id:"slopecompensation",level:2},{value:"getSlopeCompensationAngle",id:"getslopecompensationangle",level:3},{value:"getSlopeCompensationAngleScale",id:"getslopecompensationanglescale",level:3},{value:"initSpecialization",id:"initspecialization",level:3},{value:"loadSlopeCompensationNodeFromXML",id:"loadslopecompensationnodefromxml",level:3},{value:"loadSlopeCompensationWheels",id:"loadslopecompensationwheels",level:3},{value:"onLoad",id:"onload",level:3},{value:"onLoadFinished",id:"onloadfinished",level:3},{value:"onRegisterAnimationValueTypes",id:"onregisteranimationvaluetypes",level:3},{value:"onUpdate",id:"onupdate",level:3},{value:"onUpdateTick",id:"onupdatetick",level:3},{value:"prerequisitesPresent",id:"prerequisitespresent",level:3},{value:"registerEventListeners",id:"registereventlisteners",level:3},{value:"registerFunctions",id:"registerfunctions",level:3},{value:"registerXMLPaths",id:"registerxmlpaths",level:3},{value:"saveToXMLFile",id:"savetoxmlfile",level:3},{value:"setSlopeCompensationNodeAngle",id:"setslopecompensationnodeangle",level:3},{value:"updateDebugValues",id:"updatedebugvalues",level:3}];function c(e){const n={a:"a",blockquote:"blockquote",code:"code",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,s.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.h2,{id:"slopecompensation",children:"SlopeCompensation"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Description"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"Specialization for automatic slope compensation in vehicles based on the angle between two wheel nodes or a reference\nnode angle (world space)"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Functions"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#getslopecompensationangle",children:"getSlopeCompensationAngle"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#getslopecompensationanglescale",children:"getSlopeCompensationAngleScale"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#initspecialization",children:"initSpecialization"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#loadslopecompensationnodefromxml",children:"loadSlopeCompensationNodeFromXML"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#loadslopecompensationwheels",children:"loadSlopeCompensationWheels"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#onload",children:"onLoad"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#onloadfinished",children:"onLoadFinished"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#onregisteranimationvaluetypes",children:"onRegisterAnimationValueTypes"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#onupdate",children:"onUpdate"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#onupdatetick",children:"onUpdateTick"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#prerequisitespresent",children:"prerequisitesPresent"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#registereventlisteners",children:"registerEventListeners"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#registerfunctions",children:"registerFunctions"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#registerxmlpaths",children:"registerXMLPaths"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#savetoxmlfile",children:"saveToXMLFile"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#setslopecompensationnodeangle",children:"setSlopeCompensationNodeAngle"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#updatedebugvalues",children:"updateDebugValues"})}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"getslopecompensationangle",children:"getSlopeCompensationAngle"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Description"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Definition"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"getSlopeCompensationAngle()"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,t.jsx)(n.table,{children:(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"any"}),(0,t.jsx)(n.th,{children:"compensationNode"})]})})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Code"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:"function SlopeCompensation:getSlopeCompensationAngle(compensationNode)\n    return compensationNode.detectedAngle\nend\n\n"})}),"\n",(0,t.jsx)(n.h3,{id:"getslopecompensationanglescale",children:"getSlopeCompensationAngleScale"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Description"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Definition"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"getSlopeCompensationAngleScale()"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,t.jsx)(n.table,{children:(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"any"}),(0,t.jsx)(n.th,{children:"compensationNode"})]})})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Code"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:"function SlopeCompensation:getSlopeCompensationAngleScale(compensationNode)\n    return 1\nend\n\n"})}),"\n",(0,t.jsx)(n.h3,{id:"initspecialization",children:"initSpecialization"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Description"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Definition"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"initSpecialization()"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Code"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:'function SlopeCompensation.initSpecialization()\n    g_vehicleConfigurationManager:addConfigurationType( "slopeCompensation" , g_i18n:getText( "shop_configuration" ), "slopeCompensation" , VehicleConfigurationItem )\n\n    local schema = Vehicle.xmlSchema\n    schema:setXMLSpecializationType( "SlopeCompensation" )\n\n    SlopeCompensation.registerXMLPaths(schema, "vehicle.slopeCompensation" )\n    SlopeCompensation.registerXMLPaths(schema, "vehicle.slopeCompensation.slopeCompensationConfigurations.slopeCompensationConfiguration(?)" )\n\n    schema:addDelayedRegistrationFunc( "AnimatedVehicle:part" , function (cSchema, cKey)\n        cSchema:register(XMLValueType.INT, cKey .. "#slopeCompensationNodeIndex" , "Index in the XML of the slope compensation node" )\n        cSchema:register(XMLValueType.FLOAT, cKey .. "#startSlopeCompensationLevel" , "Start slope compensation level" )\n        cSchema:register(XMLValueType.FLOAT, cKey .. "#endSlopeCompensationLevel" , "End slope compensation level" )\n    end )\n\n    schema:setXMLSpecializationType()\n\n    local schemaSavegame = Vehicle.xmlSchemaSavegame\n    schemaSavegame:register(XMLValueType.ANGLE, "vehicles.vehicle(?).slopeCompensation.compensationNode(?)#lastAngle" , "Last angle of compensation node" )\nend\n\n'})}),"\n",(0,t.jsx)(n.h3,{id:"loadslopecompensationnodefromxml",children:"loadSlopeCompensationNodeFromXML"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Description"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Definition"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"loadSlopeCompensationNodeFromXML()"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"any"}),(0,t.jsx)(n.th,{children:"compensationNode"})]})}),(0,t.jsxs)(n.tbody,{children:[(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"any"}),(0,t.jsx)(n.td,{children:"xmlFile"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"any"}),(0,t.jsx)(n.td,{children:"key"})]})]})]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Code"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:'function SlopeCompensation:loadSlopeCompensationNodeFromXML(compensationNode, xmlFile, key)\n    compensationNode.useWheelReference = false\n    compensationNode.raycastDistance = 0\n    compensationNode.lastDistance1 = 0\n    compensationNode.lastDistance2 = 0\n\n    local success1, wheelNodes1, maxRadius1 = self:loadSlopeCompensationWheels(xmlFile, key, "wheel1" , "wheelNode1" , "wheelNodes1" )\n    local success2, wheelNodes2, maxRadius2 = self:loadSlopeCompensationWheels(xmlFile, key, "wheel2" , "wheelNode2" , "wheelNodes2" )\n    if success1 and success2 then\n        compensationNode.wheelNodes1 = wheelNodes1\n        compensationNode.wheelNodes2 = wheelNodes2\n\n        compensationNode.hitPosition1 = { 0 , 0 , 0 }\n        compensationNode.hitPosition1Valid = false\n\n        compensationNode.detectionCallback1 = function (_, hitObjectId, x, y, z, distance, nx, ny, nz, subShapeIndex, shapeId, isLast)\n            if hitObjectId ~ = 0 then\n                if getRigidBodyType(hitObjectId) ~ = RigidBodyType.STATIC then\n                    return true\n                end\n\n                compensationNode.hitPosition1[ 1 ], compensationNode.hitPosition1[ 2 ], compensationNode.hitPosition1[ 3 ] = x, y, z\n                compensationNode.hitPosition1Valid = true\n            end\n\n            return false\n        end\n\n        compensationNode.detectionCallback2 = function (_, hitObjectId, x2, y2, z2, distance, nx, ny, nz, subShapeIndex, shapeId, isLast)\n            if hitObjectId ~ = 0 then\n                if getRigidBodyType(hitObjectId) ~ = RigidBodyType.STATIC then\n                    return true\n                end\n\n                if compensationNode.hitPosition1Valid then\n                    local x1, y1, z1 = compensationNode.hitPosition1[ 1 ], compensationNode.hitPosition1[ 2 ], compensationNode.hitPosition1[ 3 ]\n                    local h = y1 - y2\n                    local l = MathUtil.vector2Length(x1 - x2, z1 - z2)\n\n                    if VehicleDebug.state = = VehicleDebug.DEBUG_ATTRIBUTES then\n                        drawDebugLine(x1, y1, z1, 1 , 1 , 0 , x2, y2, z2, 1 , 1 , 0 , false )\n                        Utils.renderTextAtWorldPosition((x1 + x2) * 0.5 , (y1 + y2) * 0.5 , (z1 + z2) * 0.5 , string.format( "Angle: %.2f\xb0" , math.deg( math.tan(h / l))), 0.01 )\n                    end\n\n                    compensationNode.detectedAngle = math.tan(h / l)\n                    return false\n                end\n            end\n\n            if isLast then\n                compensationNode.detectedAngle = 0\n            end\n\n            return false\n        end\n\n        compensationNode.raycastDistance = math.max(maxRadius1 + 1 , maxRadius2 + 1 )\n        compensationNode.useWheelReference = true\n    end\n\n    compensationNode.referenceNode = self.xmlFile:getValue(key .. "#referenceNode" , nil , self.components, self.i3dMappings)\n    compensationNode.referenceAxis = self.xmlFile:getValue(key .. "#referenceAxis" , 1 )\n\n    compensationNode.rotationNode = self.xmlFile:getValue(key .. "#rotationNode" , nil , self.components, self.i3dMappings)\n    compensationNode.rotationAxis = self.xmlFile:getValue(key .. "#rotationAxis" , 1 )\n    if compensationNode.rotationNode ~ = nil then\n        compensationNode.rotationNodeRotation = { getRotation(compensationNode.rotationNode) }\n    end\n\n    compensationNode.maxAngle = self.xmlFile:getValue(key .. "#maxAngle" , 5 )\n    compensationNode.minAngle = self.xmlFile:getValue(key .. "#minAngle" , - math.deg(compensationNode.maxAngle))\n\n    compensationNode.speed = self.xmlFile:getValue(key .. "#speed" , 5 ) / 1000\n    compensationNode.inverted = self.xmlFile:getValue(key .. "#inverted" , false )\n\n    if compensationNode.minAngle > compensationNode.maxAngle then\n        compensationNode.minAngle, compensationNode.maxAngle = compensationNode.maxAngle, compensationNode.minAngle\n        compensationNode.inverted = true\n    end\n\n    compensationNode.targetAngle = 0\n    compensationNode.lastAngle = 0\n    compensationNode.detectedAngle = 0\n\n    compensationNode.animationName = self.xmlFile:getValue(key .. "#animationName" )\n\n    compensationNode.inActiveHeight = xmlFile:getValue(key .. "#inActiveHeight" , 0 )\n    compensationNode.initialHeightOffset = 1 - math.clamp(xmlFile:getValue(key .. "#initialHeight" , 1 ), 0 , 1 )\n\n    compensationNode.compensationLevel = 1\n\n    compensationNode.animationParts = { }\n    for _, partKey in xmlFile:iterator(key .. ".animationPart" ) do\n        local animationPart = { }\n        animationPart.node = xmlFile:getValue(partKey .. "#node" , nil , self.components, self.i3dMappings)\n        if animationPart.node ~ = nil then\n            animationPart.isLeft = xmlFile:getValue(partKey .. "#isLeft" , false )\n\n            animationPart.rotMin = xmlFile:getValue(partKey .. "#rotMin" , nil , true )\n            animationPart.rotMax = xmlFile:getValue(partKey .. "#rotMax" , nil , true )\n\n            animationPart.transMin = xmlFile:getValue(partKey .. "#transMin" , nil , true )\n            animationPart.transMax = xmlFile:getValue(partKey .. "#transMax" , nil , true )\n\n            if (animationPart.rotMin ~ = nil and animationPart.rotMax ~ = nil )\n                or(animationPart.transMin ~ = nil and animationPart.transMax ~ = nil ) then\n                animationPart.lastAlpha = - 1\n\n                table.insert(compensationNode.animationParts, animationPart)\n            else\n                    Logging.xmlWarning(xmlFile, "Failed to load slope compensation animation part \'%s\'.Missing values." , partKey)\n                end\n            else\n                    Logging.xmlWarning(xmlFile, "Failed to load slope compensation animation part \'%s\'.Missing node." , partKey)\n                end\n            end\n\n            return true\n        end\n\n'})}),"\n",(0,t.jsx)(n.h3,{id:"loadslopecompensationwheels",children:"loadSlopeCompensationWheels"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Description"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Definition"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"loadSlopeCompensationWheels()"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"any"}),(0,t.jsx)(n.th,{children:"xmlFile"})]})}),(0,t.jsxs)(n.tbody,{children:[(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"any"}),(0,t.jsx)(n.td,{children:"key"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"any"}),(0,t.jsx)(n.td,{children:"indexName"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"any"}),(0,t.jsx)(n.td,{children:"nodeName"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"any"}),(0,t.jsx)(n.td,{children:"nodesName"})]})]})]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Code"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:"function SlopeCompensation:loadSlopeCompensationWheels(xmlFile, key, indexName, nodeName, nodesName)\n    local maxRadius = 0\n    local wheelNodes = { }\n\n    local wheelIndex = self.xmlFile:getValue(key .. \"#\" .. indexName)\n    if wheelIndex ~ = nil then\n        local wheel = self:getWheelFromWheelIndex(wheelIndex)\n        if wheel ~ = nil then\n            maxRadius = math.max(maxRadius, wheel.physics.radius)\n            table.insert(wheelNodes, wheel.driveNode)\n        else\n                Logging.xmlWarning( self.xmlFile, \"Unable to find wheel index '%d' for compensation node '%s'\" , wheelIndex, key)\n                    return false\n                end\n            end\n\n            local wheelNode = self.xmlFile:getValue(key .. \"#\" .. nodeName, nil , self.components, self.i3dMappings)\n            if wheelNode ~ = nil then\n                local wheel = self:getWheelByWheelNode(wheelNode)\n                if wheel ~ = nil then\n                    maxRadius = math.max(maxRadius, wheel.physics.radius)\n                    table.insert(wheelNodes, wheel.driveNode)\n                else\n                        Logging.xmlWarning( self.xmlFile, \"Unable to find wheel for node '%s' for compensation node '%s'\" , getName(wheelNode), key)\n                            return false\n                        end\n                    end\n\n                    local nodes = self.xmlFile:getValue(key .. \"#\" .. nodesName, nil , self.components, self.i3dMappings, true )\n                    if nodes ~ = nil then\n                        for _, node in ipairs(nodes) do\n                            local wheel = self:getWheelByWheelNode(node)\n                            if wheel ~ = nil then\n                                maxRadius = math.max(maxRadius, wheel.physics.radius)\n                                table.insert(wheelNodes, wheel.driveNode)\n                            else\n                                    Logging.xmlWarning( self.xmlFile, \"Unable to find wheel for node '%s' for compensation node '%s'\" , getName(node), key)\n                                        return false\n                                    end\n                                end\n                            end\n\n                            if #wheelNodes = = 0 then\n                                return false\n                            end\n\n                            return true , wheelNodes, maxRadius\n                        end\n\n"})}),"\n",(0,t.jsx)(n.h3,{id:"onload",children:"onLoad"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Description"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Definition"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"onLoad()"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,t.jsx)(n.table,{children:(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"any"}),(0,t.jsx)(n.th,{children:"savegame"})]})})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Code"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:'function SlopeCompensation:onLoad(savegame)\n    local spec = self.spec_slopeCompensation\n\n    spec.threshold = self.xmlFile:getValue( "vehicle.slopeCompensation#threshold" , 0.002 )\n    spec.highUpdateFrequency = self.xmlFile:getValue( "vehicle.slopeCompensation#highUpdateFrequency" , false )\n\n    spec.lastRaycastDistance = 0\n    spec.compensationNodes = { }\n    for _, key in self.xmlFile:iterator( "vehicle.slopeCompensation.compensationNode" ) do\n        local compensationNode = { }\n        if self:loadSlopeCompensationNodeFromXML(compensationNode, self.xmlFile, key) then\n            table.insert(spec.compensationNodes, compensationNode)\n        end\n    end\n\n    local configurationId = self.configurations[ "slopeCompensation" ] or 1\n    local configKey = string.format( "vehicle.slopeCompensation.slopeCompensationConfigurations.slopeCompensationConfiguration(%d)" , configurationId - 1 )\n\n    if self.xmlFile:hasProperty(configKey) then\n        for _, key in self.xmlFile:iterator(configKey .. ".compensationNode" ) do\n            local compensationNode = { }\n            if self:loadSlopeCompensationNodeFromXML(compensationNode, self.xmlFile, key) then\n                table.insert(spec.compensationNodes, compensationNode)\n            end\n        end\n\n        spec.threshold = self.xmlFile:getValue(configKey .. "#threshold" , spec.threshold)\n        spec.highUpdateFrequency = self.xmlFile:getValue(configKey .. "#highUpdateFrequency" , spec.highUpdateFrequency)\n    end\n\n    if #spec.compensationNodes = = 0 then\n        SpecializationUtil.removeEventListener( self , "onLoadFinished" , SlopeCompensation )\n        SpecializationUtil.removeEventListener( self , "onUpdate" , SlopeCompensation )\n        SpecializationUtil.removeEventListener( self , "onUpdateTick" , SlopeCompensation )\n    else\n            if spec.highUpdateFrequency then\n                SpecializationUtil.removeEventListener( self , "onUpdateTick" , SlopeCompensation )\n            else\n                    SpecializationUtil.removeEventListener( self , "onUpdate" , SlopeCompensation )\n                end\n            end\n        end\n\n'})}),"\n",(0,t.jsx)(n.h3,{id:"onloadfinished",children:"onLoadFinished"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Description"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Definition"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"onLoadFinished()"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,t.jsx)(n.table,{children:(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"any"}),(0,t.jsx)(n.th,{children:"savegame"})]})})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Code"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:'function SlopeCompensation:onLoadFinished(savegame)\n    local spec = self.spec_slopeCompensation\n\n    for _, compensationNode in ipairs(spec.compensationNodes) do\n        if compensationNode.animationName ~ = nil then\n            local updateAnimation = self:getSlopeCompensationAngleScale(compensationNode) > 0\n            self:setAnimationTime(compensationNode.animationName, 0 , updateAnimation)\n            self:setAnimationTime(compensationNode.animationName, 1 , updateAnimation)\n            self:setAnimationTime(compensationNode.animationName, 0.5 , updateAnimation)\n        end\n    end\n\n    if savegame ~ = nil then\n        for j, compensationNode in ipairs(spec.compensationNodes) do\n            local lastAngle = savegame.xmlFile:getValue( string.format( "%s.slopeCompensation.compensationNode(%d)#lastAngle" , savegame.key, j - 1 ), 0 )\n            self:setSlopeCompensationNodeAngle(compensationNode, lastAngle)\n        end\n    else\n            for j, compensationNode in ipairs(spec.compensationNodes) do\n                self:setSlopeCompensationNodeAngle(compensationNode, 0 )\n            end\n        end\n    end\n\n'})}),"\n",(0,t.jsx)(n.h3,{id:"onregisteranimationvaluetypes",children:"onRegisterAnimationValueTypes"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Description"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"Called on pre load to register animation value types"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Definition"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"onRegisterAnimationValueTypes()"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Code"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:'function SlopeCompensation:onRegisterAnimationValueTypes()\n    self:registerAnimationValueType( "slopeCompensationLevel" , "startSlopeCompensationLevel" , "endSlopeCompensationLevel" , false , AnimationValueFloat ,\n    function (value, xmlFile, xmlKey)\n        value.slopeCompensationNodeIndex = xmlFile:getValue(xmlKey .. "#slopeCompensationNodeIndex" )\n        if value.slopeCompensationNodeIndex ~ = nil then\n            value:setWarningInformation( "index: " .. tostring(value.slopeCompensationNodeIndex))\n            value:addCompareParameters( "slopeCompensationNodeIndex" )\n\n            return true\n        end\n\n        return false\n    end ,\n\n    function (value)\n        if value.slopeCompensationNode = = nil then\n            local spec = value.vehicle.spec_slopeCompensation\n            local slopeCompensationNode = spec.compensationNodes[value.slopeCompensationNodeIndex]\n            if slopeCompensationNode = = nil then\n                Logging.xmlWarning(value.xmlFile, "Could not update slope compensation node level.No slope compensation node with index %d found!" , value.slopeCompensationNodeIndex)\n                value.startValue = nil\n                return 0\n            end\n\n            value.slopeCompensationNode = slopeCompensationNode\n        end\n\n        return value.slopeCompensationNode.compensationLevel\n    end ,\n\n    function (value, compensationLevel)\n        if value.slopeCompensationNode ~ = nil then\n            value.slopeCompensationNode.compensationLevel = compensationLevel\n\n            self:setSlopeCompensationNodeAngle(value.slopeCompensationNode, value.slopeCompensationNode.lastAngle)\n        end\n    end )\nend\n\n'})}),"\n",(0,t.jsx)(n.h3,{id:"onupdate",children:"onUpdate"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Description"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Definition"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"onUpdate()"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"any"}),(0,t.jsx)(n.th,{children:"dt"})]})}),(0,t.jsxs)(n.tbody,{children:[(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"any"}),(0,t.jsx)(n.td,{children:"isActiveForInput"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"any"}),(0,t.jsx)(n.td,{children:"isActiveForInputIgnoreSelection"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"any"}),(0,t.jsx)(n.td,{children:"isSelected"})]})]})]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Code"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:"function SlopeCompensation:onUpdate(dt, isActiveForInput, isActiveForInputIgnoreSelection, isSelected)\n    local spec = self.spec_slopeCompensation\n\n    for _, compensationNode in ipairs(spec.compensationNodes) do\n        local angle = math.clamp(compensationNode.detectedAngle, compensationNode.minAngle, compensationNode.maxAngle) * self:getSlopeCompensationAngleScale(compensationNode)\n        if compensationNode.inverted then\n            angle = - angle\n        end\n\n        local difference = math.abs(compensationNode.targetAngle - angle)\n        if difference > spec.threshold then\n            compensationNode.targetAngle = angle\n        end\n\n        local dir = math.sign(compensationNode.targetAngle - compensationNode.lastAngle)\n        local limit = dir > 0 and math.min or math.max\n\n        local speedScale = math.min( math.max( math.abs(compensationNode.lastAngle - angle) / (compensationNode.speed * 1000 ), 0.2 ), 1 )\n        local newAngle = limit(compensationNode.lastAngle + compensationNode.speed * dt * dir * speedScale, compensationNode.targetAngle)\n        if newAngle ~ = compensationNode.lastAngle then\n            self:setSlopeCompensationNodeAngle(compensationNode, newAngle)\n        end\n\n        self:updateSlopeCompensationAngle(compensationNode)\n    end\nend\n\n"})}),"\n",(0,t.jsx)(n.h3,{id:"onupdatetick",children:"onUpdateTick"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Description"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Definition"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"onUpdateTick()"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"any"}),(0,t.jsx)(n.th,{children:"dt"})]})}),(0,t.jsxs)(n.tbody,{children:[(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"any"}),(0,t.jsx)(n.td,{children:"isActiveForInput"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"any"}),(0,t.jsx)(n.td,{children:"isActiveForInputIgnoreSelection"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"any"}),(0,t.jsx)(n.td,{children:"isSelected"})]})]})]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Code"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:"function SlopeCompensation:onUpdateTick(dt, isActiveForInput, isActiveForInputIgnoreSelection, isSelected)\n    SlopeCompensation.onUpdate( self , dt, isActiveForInput, isActiveForInputIgnoreSelection, isSelected)\nend\n\n"})}),"\n",(0,t.jsx)(n.h3,{id:"prerequisitespresent",children:"prerequisitesPresent"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Description"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Definition"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"prerequisitesPresent()"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,t.jsx)(n.table,{children:(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"any"}),(0,t.jsx)(n.th,{children:"specializations"})]})})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Code"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:"function SlopeCompensation.prerequisitesPresent(specializations)\n    return SpecializationUtil.hasSpecialization( Wheels , specializations)\nend\n\n"})}),"\n",(0,t.jsx)(n.h3,{id:"registereventlisteners",children:"registerEventListeners"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Description"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Definition"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"registerEventListeners()"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,t.jsx)(n.table,{children:(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"any"}),(0,t.jsx)(n.th,{children:"vehicleType"})]})})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Code"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:'function SlopeCompensation.registerEventListeners(vehicleType)\n    SpecializationUtil.registerEventListener(vehicleType, "onLoad" , SlopeCompensation )\n    SpecializationUtil.registerEventListener(vehicleType, "onLoadFinished" , SlopeCompensation )\n    SpecializationUtil.registerEventListener(vehicleType, "onUpdate" , SlopeCompensation )\n    SpecializationUtil.registerEventListener(vehicleType, "onUpdateTick" , SlopeCompensation )\n    SpecializationUtil.registerEventListener(vehicleType, "onRegisterAnimationValueTypes" , SlopeCompensation )\nend\n\n'})}),"\n",(0,t.jsx)(n.h3,{id:"registerfunctions",children:"registerFunctions"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Description"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Definition"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"registerFunctions()"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,t.jsx)(n.table,{children:(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"any"}),(0,t.jsx)(n.th,{children:"vehicleType"})]})})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Code"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:'function SlopeCompensation.registerFunctions(vehicleType)\n    SpecializationUtil.registerFunction(vehicleType, "loadSlopeCompensationWheels" , SlopeCompensation.loadSlopeCompensationWheels)\n    SpecializationUtil.registerFunction(vehicleType, "loadSlopeCompensationNodeFromXML" , SlopeCompensation.loadSlopeCompensationNodeFromXML)\n    SpecializationUtil.registerFunction(vehicleType, "getSlopeCompensationAngle" , SlopeCompensation.getSlopeCompensationAngle)\n    SpecializationUtil.registerFunction(vehicleType, "getSlopeCompensationAngleScale" , SlopeCompensation.getSlopeCompensationAngleScale)\n    SpecializationUtil.registerFunction(vehicleType, "updateSlopeCompensationAngle" , SlopeCompensation.updateSlopeCompensationAngle)\n    SpecializationUtil.registerFunction(vehicleType, "setSlopeCompensationNodeAngle" , SlopeCompensation.setSlopeCompensationNodeAngle)\nend\n\n'})}),"\n",(0,t.jsx)(n.h3,{id:"registerxmlpaths",children:"registerXMLPaths"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Description"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Definition"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"registerXMLPaths()"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"any"}),(0,t.jsx)(n.th,{children:"schema"})]})}),(0,t.jsx)(n.tbody,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"any"}),(0,t.jsx)(n.td,{children:"basePath"})]})})]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Code"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:'function SlopeCompensation.registerXMLPaths(schema, basePath)\n    schema:register(XMLValueType.ANGLE, basePath .. "#threshold" , "Update threshold for animation" , 0.1 )\n        schema:register(XMLValueType.BOOL, basePath .. "#highUpdateFrequency" , "Defines if the angle is updated every frame or every seconds frame" , false )\n\n            local compensationNodePath = basePath .. ".compensationNode(?)"\n\n            schema:addDelayedRegistrationPath(compensationNodePath, "SlopeCompensation:compensationNode" )\n\n            schema:register(XMLValueType.INT, compensationNodePath .. "#wheel1" , "Wheel index 1" )\n            schema:register(XMLValueType.INT, compensationNodePath .. "#wheel2" , "Wheel index 2" )\n            schema:register(XMLValueType.NODE_INDEX, compensationNodePath .. "#wheelNode1" , "Wheel node 1" )\n            schema:register(XMLValueType.NODE_INDEX, compensationNodePath .. "#wheelNode2" , "Wheel node 2" )\n            schema:register(XMLValueType.NODE_INDICES, compensationNodePath .. "#wheelNodes1" , "List of wheel nodes 1(center of all nodes will be used for detection)" )\n                schema:register(XMLValueType.NODE_INDICES, compensationNodePath .. "#wheelNodes2" , "List of wheel nodes 2(center of all nodes will be used for detection)" )\n\n                    schema:register(XMLValueType.ANGLE, compensationNodePath .. "#maxAngle" , "Max.angle" , 5 )\n                    schema:register(XMLValueType.ANGLE, compensationNodePath .. "#minAngle" , "Min.angle" , "Negative #maxAngle" )\n                    schema:register(XMLValueType.ANGLE, compensationNodePath .. "#speed" , "Move speed(degree/sec)" , 5 )\n                    schema:register(XMLValueType.BOOL, compensationNodePath .. "#inverted" , "Inverted rotation" , false )\n                    schema:register(XMLValueType.FLOAT, compensationNodePath .. "#inActiveHeight" , "Height while the compensation node is not active" , 0 )\n                        schema:register(XMLValueType.FLOAT, compensationNodePath .. "#initialHeight" , "Height while the componensation node is active and the vehicle is fully leveled" , 1 )\n\n                            schema:register(XMLValueType.STRING, compensationNodePath .. "#animationName" , "Animation name" )\n\n                            schema:register(XMLValueType.NODE_INDEX, compensationNodePath .. "#referenceNode" , "Node that is used to detect the current angle" )\n                            schema:register(XMLValueType.INT, compensationNodePath .. "#referenceAxis" , "Reference angle detection axis" , 1 )\n\n                            schema:register(XMLValueType.NODE_INDEX, compensationNodePath .. "#rotationNode" , "Node that is rotated based on the slope angle" )\n                            schema:register(XMLValueType.INT, compensationNodePath .. "#rotationAxis" , "Rotation axis on which the rotationNode is rotated" , 1 )\n\n                            schema:register(XMLValueType.NODE_INDEX, compensationNodePath .. ".animationPart(?)#node" , "Node that is adjusted" )\n                            schema:register(XMLValueType.BOOL, compensationNodePath .. ".animationPart(?)#isLeft" , "Is left or right side node" )\n                            schema:register(XMLValueType.VECTOR_ROT, compensationNodePath .. ".animationPart(?)#rotMin" , "Min.rotation" )\n                            schema:register(XMLValueType.VECTOR_ROT, compensationNodePath .. ".animationPart(?)#rotMax" , "Max.rotation" )\n                            schema:register(XMLValueType.VECTOR_TRANS, compensationNodePath .. ".animationPart(?)#transMin" , "Min.translation" )\n                            schema:register(XMLValueType.VECTOR_TRANS, compensationNodePath .. ".animationPart(?)#transMax" , "Max.translation" )\n                        end\n\n'})}),"\n",(0,t.jsx)(n.h3,{id:"savetoxmlfile",children:"saveToXMLFile"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Description"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Definition"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"saveToXMLFile()"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"any"}),(0,t.jsx)(n.th,{children:"xmlFile"})]})}),(0,t.jsxs)(n.tbody,{children:[(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"any"}),(0,t.jsx)(n.td,{children:"key"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"any"}),(0,t.jsx)(n.td,{children:"usedModNames"})]})]})]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Code"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:'function SlopeCompensation:saveToXMLFile(xmlFile, key, usedModNames)\n    local spec = self.spec_slopeCompensation\n    for i, compensationNode in ipairs(spec.compensationNodes) do\n        xmlFile:setValue( string.format( "%s.compensationNode(%d)#lastAngle" , key, i - 1 ), compensationNode.lastAngle)\n    end\nend\n\n'})}),"\n",(0,t.jsx)(n.h3,{id:"setslopecompensationnodeangle",children:"setSlopeCompensationNodeAngle"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Description"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Definition"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"setSlopeCompensationNodeAngle()"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"any"}),(0,t.jsx)(n.th,{children:"compensationNode"})]})}),(0,t.jsx)(n.tbody,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"any"}),(0,t.jsx)(n.td,{children:"angle"})]})})]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Code"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:"function SlopeCompensation:setSlopeCompensationNodeAngle(compensationNode, angle)\n    local position = (angle - compensationNode.minAngle) / (compensationNode.maxAngle - compensationNode.minAngle)\n\n    if compensationNode.animationName ~ = nil then\n        if self.setAnimationTime ~ = nil then\n            local currentTime = self:getAnimationTime(compensationNode.animationName)\n            self:setAnimationStopTime(compensationNode.animationName, position)\n            self:playAnimation(compensationNode.animationName, math.sign(position - currentTime), currentTime, true )\n            AnimatedVehicle.updateAnimationByName( self , compensationNode.animationName, 9999999 , true )\n        end\n    end\n\n    if compensationNode.rotationNode ~ = nil then\n        compensationNode.rotationNodeRotation[ 1 ], compensationNode.rotationNodeRotation[ 2 ], compensationNode.rotationNodeRotation[ 3 ] = getRotation(compensationNode.rotationNode)\n        compensationNode.rotationNodeRotation[compensationNode.rotationAxis] = angle\n        setRotation(compensationNode.rotationNode, compensationNode.rotationNodeRotation[ 1 ], compensationNode.rotationNodeRotation[ 2 ], compensationNode.rotationNodeRotation[ 3 ])\n\n        if self.setMovingToolDirty ~ = nil then\n            self:setMovingToolDirty(compensationNode.rotationNode)\n        end\n    end\n\n    for _, animationPart in ipairs(compensationNode.animationParts) do\n        local alpha\n        if animationPart.isLeft then\n            alpha = 1 - math.clamp((position - 0.5 ) / 0.5 + compensationNode.initialHeightOffset, 0 , 1 )\n        else\n                alpha = math.clamp(position / 0.5 - compensationNode.initialHeightOffset, 0 , 1 )\n            end\n\n            alpha = MathUtil.lerp(compensationNode.inActiveHeight, alpha, compensationNode.compensationLevel)\n\n            animationPart.lastAlpha = alpha\n\n            if animationPart.rotMin ~ = nil then\n                local x, y, z = MathUtil.vector3ArrayLerp(animationPart.rotMin, animationPart.rotMax, alpha)\n                setRotation(animationPart.node, x, y, z)\n\n                if self.setMovingToolDirty ~ = nil then\n                    self:setMovingToolDirty(animationPart.node)\n                end\n            end\n\n            if animationPart.transMin ~ = nil then\n                local x, y, z = MathUtil.vector3ArrayLerp(animationPart.transMin, animationPart.transMax, alpha)\n                setTranslation(animationPart.node, x, y, z)\n\n                if self.setMovingToolDirty ~ = nil then\n                    self:setMovingToolDirty(animationPart.node)\n                end\n            end\n        end\n\n        compensationNode.lastAngle = angle\n    end\n\n"})}),"\n",(0,t.jsx)(n.h3,{id:"updatedebugvalues",children:"updateDebugValues"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Description"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Definition"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"updateDebugValues()"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,t.jsx)(n.table,{children:(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"any"}),(0,t.jsx)(n.th,{children:"values"})]})})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Code"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:'function SlopeCompensation:updateDebugValues(values)\n    local spec = self.spec_slopeCompensation\n\n    for i, compensationNode in ipairs(spec.compensationNodes) do\n        local angle = math.clamp(compensationNode.detectedAngle, compensationNode.minAngle, compensationNode.maxAngle)\n        if compensationNode.inverted then\n            angle = - angle\n        end\n\n        table.insert(values, { name = string.format( "compNode %d" , i), value = string.format( "%.2f\xb0" , math.deg(angle)) } )\n    end\n\nend\n\n'})})]})}function p(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(c,{...e})}):c(e)}},28453(e,n,o){o.d(n,{R:()=>l,x:()=>a});var i=o(96540);const t={},s=i.createContext(t);function l(e){const n=i.useContext(s);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:l(e.components),i.createElement(s.Provider,{value:n},e.children)}}}]);