"use strict";(globalThis.webpackChunkfs25_community_luadoc=globalThis.webpackChunkfs25_community_luadoc||[]).push([[70497],{28453(e,n,t){t.d(n,{R:()=>l,x:()=>a});var i=t(96540);const r={},s=i.createContext(r);function l(e){const n=i.useContext(s);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:l(e.components),i.createElement(s.Provider,{value:n},e.children)}},49291(e,n,t){t.r(n),t.d(n,{assets:()=>o,contentTitle:()=>a,default:()=>h,frontMatter:()=>l,metadata:()=>i,toc:()=>c});const i=JSON.parse('{"id":"script/Specializations/ArticulatedAxis","title":"ArticulatedAxis","description":"ArticulatedAxis","source":"@site/../docs/script/Specializations/ArticulatedAxis.md","sourceDirName":"script/Specializations","slug":"/script/Specializations/ArticulatedAxis","permalink":"/FS25-Community-LUADOC/script/Specializations/ArticulatedAxis","draft":false,"unlisted":false,"tags":[],"version":"current","lastUpdatedAt":1767161192000,"frontMatter":{},"sidebar":"docsSidebar","previous":{"title":"AnimatedVehicle","permalink":"/FS25-Community-LUADOC/script/Specializations/AnimatedVehicle"},"next":{"title":"Attachable","permalink":"/FS25-Community-LUADOC/script/Specializations/Attachable"}}');var r=t(74848),s=t(28453);const l={},a=void 0,o={},c=[{value:"ArticulatedAxis",id:"articulatedaxis",level:2},{value:"getSteeringRotTimeByCurvature",id:"getsteeringrottimebycurvature",level:3},{value:"getTurningRadiusByRotTime",id:"getturningradiusbyrottime",level:3},{value:"initSpecialization",id:"initspecialization",level:3},{value:"onDeactivate",id:"ondeactivate",level:3},{value:"onDelete",id:"ondelete",level:3},{value:"onLoad",id:"onload",level:3},{value:"onPostLoad",id:"onpostload",level:3},{value:"onUpdate",id:"onupdate",level:3},{value:"prerequisitesPresent",id:"prerequisitespresent",level:3},{value:"registerEventListeners",id:"registereventlisteners",level:3},{value:"registerOverwrittenFunctions",id:"registeroverwrittenfunctions",level:3}];function d(e){const n={a:"a",blockquote:"blockquote",code:"code",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,s.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.h2,{id:"articulatedaxis",children:"ArticulatedAxis"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Description"})}),"\n",(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsx)(n.p,{children:"Specialization for vehicles which steer with an articulated axis (excavators, loaders ...)"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Functions"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"#getsteeringrottimebycurvature",children:"getSteeringRotTimeByCurvature"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"#getturningradiusbyrottime",children:"getTurningRadiusByRotTime"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"#initspecialization",children:"initSpecialization"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"#ondeactivate",children:"onDeactivate"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"#ondelete",children:"onDelete"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"#onload",children:"onLoad"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"#onpostload",children:"onPostLoad"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"#onupdate",children:"onUpdate"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"#prerequisitespresent",children:"prerequisitesPresent"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"#registereventlisteners",children:"registerEventListeners"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"#registeroverwrittenfunctions",children:"registerOverwrittenFunctions"})}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"getsteeringrottimebycurvature",children:"getSteeringRotTimeByCurvature"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Description"})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Definition"})}),"\n",(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsx)(n.p,{children:"getSteeringRotTimeByCurvature()"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,r.jsxs)(n.table,{children:[(0,r.jsx)(n.thead,{children:(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.th,{children:"any"}),(0,r.jsx)(n.th,{children:"superFunc"})]})}),(0,r.jsx)(n.tbody,{children:(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"any"}),(0,r.jsx)(n.td,{children:"curvature"})]})})]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Code"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-lua",children:"function ArticulatedAxis:getSteeringRotTimeByCurvature(superFunc, curvature)\n    return self.wheelSteeringDuration * ( math.atan(curvature) / math.atan( 1 / self.maxTurningRadius))\nend\n\n"})}),"\n",(0,r.jsx)(n.h3,{id:"getturningradiusbyrottime",children:"getTurningRadiusByRotTime"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Description"})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Definition"})}),"\n",(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsx)(n.p,{children:"getTurningRadiusByRotTime()"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,r.jsxs)(n.table,{children:[(0,r.jsx)(n.thead,{children:(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.th,{children:"any"}),(0,r.jsx)(n.th,{children:"superFunc"})]})}),(0,r.jsx)(n.tbody,{children:(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"any"}),(0,r.jsx)(n.td,{children:"rotTime"})]})})]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Code"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-lua",children:"function ArticulatedAxis:getTurningRadiusByRotTime(superFunc, rotTime)\n    local spec = self.spec_articulatedAxis\n    if spec.componentJoint = = nil or spec.rotSpeed = = 0 then\n        return superFunc( self , rotTime)\n    end\n\n    local rotSpeed = spec.rotSpeed\n    local rotMax = self.maxRotation\n\n    local curvature = - math.tan((rotTime / ( math.sign(rotSpeed) * rotMax / rotSpeed)) * math.atan( 1 / self.maxTurningRadius))\n\n    if curvature = = 0 then\n        return math.huge\n    end\n\n    return 1 / curvature\nend\n\n"})}),"\n",(0,r.jsx)(n.h3,{id:"initspecialization",children:"initSpecialization"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Description"})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Definition"})}),"\n",(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsx)(n.p,{children:"initSpecialization()"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Code"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-lua",children:'function ArticulatedAxis.initSpecialization()\n    local schema = Vehicle.xmlSchema\n    schema:setXMLSpecializationType( "ArticulatedAxis" )\n\n    schema:register(XMLValueType.INT, "vehicle.articulatedAxis#componentJointIndex" , "Index of component joint" )\n    schema:register(XMLValueType.ANGLE, "vehicle.articulatedAxis#rotSpeed" , "Rotation speed" )\n    schema:register(XMLValueType.ANGLE, "vehicle.articulatedAxis#rotMax" , "Max rotation" )\n    schema:register(XMLValueType.ANGLE, "vehicle.articulatedAxis#rotMin" , "Min rotation" )\n    schema:register(XMLValueType.INT, "vehicle.articulatedAxis#anchorActor" , "Anchor actor index" , 0 )\n    schema:register(XMLValueType.NODE_INDEX, "vehicle.articulatedAxis#rotNode" , "Rotation node" )\n    schema:register(XMLValueType.NODE_INDEX, "vehicle.articulatedAxis#aiReverserNode" , "AI reverser node" )\n    schema:register(XMLValueType.FLOAT, "vehicle.articulatedAxis#maxTurningRadius" , "Fixed turning radius to overwrite automatic calculations" )\n    schema:register(XMLValueType.VECTOR_N, "vehicle.articulatedAxis#customWheelIndices1" , "Component 1 wheel indices.Needed if wheels are not linked to component 1 directly.E.g.dolly axis" )\n        schema:register(XMLValueType.VECTOR_N, "vehicle.articulatedAxis#customWheelIndices2" , "Component 2 wheel indices.Needed if wheels are not linked to component 2 directly.E.g.dolly axis" )\n\n            schema:register(XMLValueType.NODE_INDEX, "vehicle.articulatedAxis.rotatingPart(?)#node" , "Rotation part node" )\n            schema:register(XMLValueType.VECTOR_ROT, "vehicle.articulatedAxis.rotatingPart(?)#posRot" , "Positive rotation" )\n            schema:register(XMLValueType.VECTOR_ROT, "vehicle.articulatedAxis.rotatingPart(?)#negRot" , "Negative rotation" )\n            schema:register(XMLValueType.FLOAT, "vehicle.articulatedAxis.rotatingPart(?)#posRotFactor" , "Positive rotation factor" , 1 )\n            schema:register(XMLValueType.FLOAT, "vehicle.articulatedAxis.rotatingPart(?)#negRotFactor" , "Negative rotation factor" , 1 )\n            schema:register(XMLValueType.BOOL, "vehicle.articulatedAxis.rotatingPart(?)#invertSteeringAngle" , "Invert steering angle" , false )\n\n            SoundManager.registerSampleXMLPaths(schema, "vehicle.articulatedAxis.sounds" , "steering" )\n\n            schema:setXMLSpecializationType()\n        end\n\n'})}),"\n",(0,r.jsx)(n.h3,{id:"ondeactivate",children:"onDeactivate"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Description"})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Definition"})}),"\n",(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsx)(n.p,{children:"onDeactivate()"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Code"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-lua",children:"function ArticulatedAxis:onDeactivate()\n    if self.isClient then\n        local spec = self.spec_articulatedAxis\n        g_soundManager:stopSamples(spec.samples)\n        spec.isSteeringSoundPlaying = false\n    end\nend\n\n"})}),"\n",(0,r.jsx)(n.h3,{id:"ondelete",children:"onDelete"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Description"})}),"\n",(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsx)(n.p,{children:"Called on deleting"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Definition"})}),"\n",(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsx)(n.p,{children:"onDelete()"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Code"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-lua",children:"function ArticulatedAxis:onDelete()\n    if self.isClient then\n        local spec = self.spec_articulatedAxis\n        g_soundManager:deleteSamples(spec.samples)\n    end\nend\n\n"})}),"\n",(0,r.jsx)(n.h3,{id:"onload",children:"onLoad"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Description"})}),"\n",(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsx)(n.p,{children:"Called on loading"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Definition"})}),"\n",(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsx)(n.p,{children:"onLoad(table savegame)"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n",(0,r.jsx)(n.table,{children:(0,r.jsx)(n.thead,{children:(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.th,{children:"table"}),(0,r.jsx)(n.th,{children:"savegame"}),(0,r.jsx)(n.th,{children:"savegame"})]})})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Code"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-lua",children:'function ArticulatedAxis:onLoad(savegame)\n    local xmlFile = self.xmlFile\n    local spec = self.spec_articulatedAxis\n\n    XMLUtil.checkDeprecatedXMLElements( self.xmlFile, "vehicle.articulatedAxis.rotatingPart(0)#index" , "vehicle.articulatedAxis.rotatingPart(0)#node" ) -- FS17\n\n    local index = xmlFile:getValue( "vehicle.articulatedAxis#componentJointIndex" )\n    if index ~ = nil then\n        if index = = 0 then\n            Logging.xmlWarning( self.xmlFile, "Invalid component joint index \'0\' for articulatedAxis.Indices start with 1!" )\n            else\n                    local componentJoint = self.componentJoints[index]\n                    local rotSpeed = xmlFile:getValue( "vehicle.articulatedAxis#rotSpeed" )\n                    local rotMax = xmlFile:getValue( "vehicle.articulatedAxis#rotMax" )\n                    local rotMin = xmlFile:getValue( "vehicle.articulatedAxis#rotMin" )\n                    if componentJoint ~ = nil and rotSpeed ~ = nil and rotMax ~ = nil and rotMin ~ = nil then\n                        spec.rotSpeed = rotSpeed\n                        spec.rotMax = rotMax\n                        spec.rotMin = rotMin\n\n                        spec.componentJoint = componentJoint\n                        spec.anchorActor = xmlFile:getValue( "vehicle.articulatedAxis#anchorActor" , 0 )\n                        spec.rotationNode = xmlFile:getValue( "vehicle.articulatedAxis#rotNode" , nil , self.components, self.i3dMappings)\n                        if spec.rotationNode = = nil then\n                            spec.rotationNode = spec.componentJoint.jointNode\n                        end\n\n                        spec.curRot = 0\n\n                        spec.rotatingParts = { }\n                        for _index, key in xmlFile:iterator( "vehicle.articulatedAxis.rotatingPart" ) do\n                            local node = xmlFile:getValue(key .. "#node" , nil , self.components, self.i3dMappings)\n                            if node = = nil then\n                                Logging.xmlWarning( self.xmlFile, "Failed to load rotation part \'%s\'" , key)\n                                continue\n                            end\n\n                            local rotatingPart = { }\n                            rotatingPart.node = node\n                            rotatingPart.defRot = { getRotation(node) }\n                            rotatingPart.posRot = xmlFile:getValue(key .. "#posRot" , nil , true )\n                            if rotatingPart.posRot = = nil then\n                                Logging.xmlError(xmlFile, "Missing values for \'%s\'" , key .. "#posRot" )\n                                    continue\n                                end\n                                rotatingPart.negRot = xmlFile:getValue(key .. "#negRot" , nil , true )\n                                if rotatingPart.negRot = = nil then\n                                    Logging.xmlError(xmlFile, "Missing values for \'%s\'" , key .. "#negRot" )\n                                        continue\n                                    end\n                                    rotatingPart.negRotFactor = xmlFile:getValue(key .. "#negRotFactor" , 1 )\n                                    rotatingPart.posRotFactor = xmlFile:getValue(key .. "#posRotFactor" , 1 )\n                                    rotatingPart.invertSteeringAngle = xmlFile:getValue(key .. "#invertSteeringAngle" , false )\n\n                                    table.insert(spec.rotatingParts, rotatingPart)\n                                end\n\n                                local customWheelIndices = { { } , { } }\n                                local customWheelIndices1Sorted = xmlFile:getValue( "vehicle.articulatedAxis#customWheelIndices1" , nil , true )\n                                if customWheelIndices1Sorted ~ = nil then\n                                    for _, wheelIndex in ipairs(customWheelIndices1Sorted) do\n                                        customWheelIndices[ 1 ][wheelIndex] = true\n                                    end\n                                end\n                                local customWheelIndices2Sorted = xmlFile:getValue( "vehicle.articulatedAxis#customWheelIndices2" , nil , true )\n                                if customWheelIndices2Sorted ~ = nil then\n                                    for _, wheelIndex in ipairs(customWheelIndices2Sorted) do\n                                        customWheelIndices[ 2 ][wheelIndex] = true\n                                    end\n                                end\n\n                                -- adjust steering values\n                                local maxRotTime = rotMax / rotSpeed\n                                local minRotTime = rotMin / rotSpeed\n                                if minRotTime > maxRotTime then\n                                    local temp = minRotTime\n                                    minRotTime = maxRotTime\n                                    maxRotTime = temp\n                                end\n                                if maxRotTime > self.maxRotTime then\n                                    self.maxRotTime = maxRotTime\n                                end\n                                if minRotTime < self.minRotTime then\n                                    self.minRotTime = minRotTime\n                                end\n\n                                self.maxRotation = rotMax\n                                self.wheelSteeringDuration = math.sign(rotSpeed) * rotMax / rotSpeed\n\n                                -- adjust variables used by AIVehicleUtil\n                                spec.aiReverserNode = xmlFile:getValue( "vehicle.articulatedAxis#aiReverserNode" , nil , self.components, self.i3dMappings)\n\n                                local maxTurningRadius = 0\n                                local specWheels = self.spec_wheels\n                                for j = 1 , 2 do\n                                    local rootNode = self.components[componentJoint.componentIndices[j]].node\n\n                                    local numFoundWheels = 0\n                                    for wheelIndex, wheel in ipairs(specWheels.wheels) do\n                                        if self:getParentComponent(wheel.repr) = = rootNode or customWheelIndices[j][wheelIndex] ~ = nil then\n                                            numFoundWheels = numFoundWheels + 1\n\n                                            local wx,_,wz = localToLocal(wheel.driveNode, rootNode, 0 , 0 , 0 )\n                                            local dx1 = 1\n                                            if wx < 0 then\n                                                dx1 = - 1\n                                            end\n                                            local dz1 = math.tan( math.max(wheel.physics.rotMin, wheel.physics.rotMax) )\n                                            if wz > 0 then\n                                                dz1 = - dz1\n                                            end\n\n                                            local x2, z2 = 0 , 0\n                                            local dx2 = 1\n                                            if wx < 0 then\n                                                dx2 = - 1\n                                            end\n                                            local dz2 = math.tan( math.max(rotMin, rotMax) )\n                                            if wz < 0 then\n                                                dz2 = - dz2\n                                            end\n\n                                            -- normalize directions\n                                            local l1 = MathUtil.vector2Length(dx1, dz1)\n                                            dx1, dz1 = dx1 / l1, dz1 / l1\n\n                                            local l2 = MathUtil.vector2Length(dx2, dz2)\n                                            dx2, dz2 = dx2 / l2, dz2 / l2\n\n                                            local intersect, _, f2 = MathUtil.getLineLineIntersection2D(wx,wz, dx1,dz1, x2,z2, dx2,dz2)\n                                            if intersect then\n                                                local radius = math.abs(f2)\n                                                maxTurningRadius = math.max(maxTurningRadius, radius)\n                                            end\n                                        end\n                                    end\n\n                                    if numFoundWheels < 2 then\n                                        Logging.warning( "Could not find articulated axis wheels for component %d.Requires at least two wheels.Need to be added via \'customWheelIndices%d\' attribute if not directly inside the component." , j, j)\n                                        end\n                                    end\n\n                                    if maxTurningRadius ~ = 0 then\n                                        self.maxTurningRadius = maxTurningRadius\n                                    end\n\n                                    self.maxTurningRadius = xmlFile:getValue( "vehicle.articulatedAxis#maxTurningRadius" , self.maxTurningRadius)\n                                end\n                            end\n                        end\n\n                        if self.isClient then\n                            spec.samples = { }\n                            spec.samples.steering = g_soundManager:loadSampleFromXML( self.xmlFile, "vehicle.articulatedAxis.sounds" , "steering" , self.baseDirectory, self.components, 0 , AudioGroup.VEHICLE, self.i3dMappings, self )\n                            spec.isSteeringSoundPlaying = false\n                        end\n\n                        spec.interpolatedRotatedTime = 0\n                    end\n\n'})}),"\n",(0,r.jsx)(n.h3,{id:"onpostload",children:"onPostLoad"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Description"})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Definition"})}),"\n",(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsx)(n.p,{children:"onPostLoad()"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Code"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-lua",children:'function ArticulatedAxis:onPostLoad()\n    local spec = self.spec_articulatedAxis\n    if spec.componentJoint ~ = nil then\n        if self.updateArticulatedAxisRotation ~ = nil then\n            self:updateArticulatedAxisRotation( 0 , 99999 )\n        end\n    else\n            SpecializationUtil.removeEventListener( self , "onUpdate" , ArticulatedAxis )\n        end\n    end\n\n'})}),"\n",(0,r.jsx)(n.h3,{id:"onupdate",children:"onUpdate"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Description"})}),"\n",(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsx)(n.p,{children:"Called on update"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Definition"})}),"\n",(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsx)(n.p,{children:"onUpdate(float dt, boolean isActiveForInput, boolean isSelected, )"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,r.jsxs)(n.table,{children:[(0,r.jsx)(n.thead,{children:(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.th,{children:"float"}),(0,r.jsx)(n.th,{children:"dt"}),(0,r.jsx)(n.th,{children:"time since last call in ms"})]})}),(0,r.jsxs)(n.tbody,{children:[(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"boolean"}),(0,r.jsx)(n.td,{children:"isActiveForInput"}),(0,r.jsx)(n.td,{children:"true if vehicle is active for input"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"boolean"}),(0,r.jsx)(n.td,{children:"isSelected"}),(0,r.jsx)(n.td,{children:"true if vehicle is selected"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"any"}),(0,r.jsx)(n.td,{children:"isSelected"}),(0,r.jsx)(n.td,{})]})]})]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Code"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-lua",children:"function ArticulatedAxis:onUpdate(dt, isActiveForInput, isActiveForInputIgnoreSelection, isSelected)\n    local spec = self.spec_articulatedAxis\n    -- interpolatedRotatedTime to manipulate camera rot\n    if spec.interpolatedRotatedTime < self.rotatedTime then\n        spec.interpolatedRotatedTime = math.min( self.rotatedTime, spec.interpolatedRotatedTime + math.abs(spec.rotSpeed) * dt / 500 )\n    elseif spec.interpolatedRotatedTime > self.rotatedTime then\n            spec.interpolatedRotatedTime = math.max( self.rotatedTime, spec.interpolatedRotatedTime - math.abs(spec.rotSpeed) * dt / 500 )\n        end\n\n        local steeringAngle = math.clamp( self.rotatedTime * spec.rotSpeed, spec.rotMin, spec.rotMax)\n        if self.updateArticulatedAxisRotation ~ = nil then\n            steeringAngle = self:updateArticulatedAxisRotation(steeringAngle, dt)\n        end\n\n        if self.isClient then\n            local isSteering = math.abs(steeringAngle - spec.curRot) > 0.0001\n            if isSteering ~ = spec.isSteeringSoundPlaying then\n                if isSteering then\n                    g_soundManager:playSample(spec.samples.steering)\n                else\n                        g_soundManager:stopSample(spec.samples.steering)\n                    end\n\n                    spec.isSteeringSoundPlaying = isSteering\n                end\n            end\n\n            if math.abs(steeringAngle - spec.curRot) > 0.000001 then\n                if self.isServer then\n                    setRotation(spec.rotationNode, 0 , steeringAngle, 0 )\n                    self:setComponentJointFrame(spec.componentJoint, spec.anchorActor)\n                end\n                spec.curRot = steeringAngle\n\n                if self.isClient then\n                    local percent = 0\n                    if steeringAngle > 0 then\n                        percent = steeringAngle / spec.rotMax\n                    elseif steeringAngle < 0 then\n                            percent = steeringAngle / spec.rotMin\n                        end\n\n                        for _,rotPart in pairs(spec.rotatingParts) do\n                            local rx,ry,rz\n                            if (steeringAngle > 0 and not rotPart.invertSteeringAngle) or(steeringAngle < 0 and rotPart.invertSteeringAngle) then\n                                rx,ry,rz = MathUtil.vector3ArrayLerp(rotPart.defRot, rotPart.posRot, math.min( 1 ,percent * rotPart.posRotFactor))\n                            else\n                                    rx,ry,rz = MathUtil.vector3ArrayLerp(rotPart.defRot, rotPart.negRot, math.min( 1 ,percent * rotPart.negRotFactor))\n                                end\n                                setRotation(rotPart.node, rx,ry,rz)\n                                if self.setMovingToolDirty ~ = nil then\n                                    self:setMovingToolDirty(rotPart.node)\n                                end\n                            end\n                        end\n                    end\n                end\n\n"})}),"\n",(0,r.jsx)(n.h3,{id:"prerequisitespresent",children:"prerequisitesPresent"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Description"})}),"\n",(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsx)(n.p,{children:"Checks if all prerequisite specializations are loaded"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Definition"})}),"\n",(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsx)(n.p,{children:"prerequisitesPresent(table specializations)"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n",(0,r.jsx)(n.table,{children:(0,r.jsx)(n.thead,{children:(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.th,{children:"table"}),(0,r.jsx)(n.th,{children:"specializations"}),(0,r.jsx)(n.th,{children:"specializations"})]})})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Return Values"})}),"\n\n\n\n\n\n\n\n\n",(0,r.jsx)(n.table,{children:(0,r.jsx)(n.thead,{children:(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.th,{children:"table"}),(0,r.jsx)(n.th,{children:"hasPrerequisite"}),(0,r.jsx)(n.th,{children:"true if all prerequisite specializations are loaded"})]})})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Code"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-lua",children:"function ArticulatedAxis.prerequisitesPresent(specializations)\n    return SpecializationUtil.hasSpecialization( Drivable , specializations)\nend\n\n"})}),"\n",(0,r.jsx)(n.h3,{id:"registereventlisteners",children:"registerEventListeners"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Description"})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Definition"})}),"\n",(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsx)(n.p,{children:"registerEventListeners()"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,r.jsx)(n.table,{children:(0,r.jsx)(n.thead,{children:(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.th,{children:"any"}),(0,r.jsx)(n.th,{children:"vehicleType"})]})})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Code"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-lua",children:'function ArticulatedAxis.registerEventListeners(vehicleType)\n    SpecializationUtil.registerEventListener(vehicleType, "onLoad" , ArticulatedAxis )\n    SpecializationUtil.registerEventListener(vehicleType, "onPostLoad" , ArticulatedAxis )\n    SpecializationUtil.registerEventListener(vehicleType, "onDelete" , ArticulatedAxis )\n    SpecializationUtil.registerEventListener(vehicleType, "onDeactivate" , ArticulatedAxis )\n    SpecializationUtil.registerEventListener(vehicleType, "onUpdate" , ArticulatedAxis )\nend\n\n'})}),"\n",(0,r.jsx)(n.h3,{id:"registeroverwrittenfunctions",children:"registerOverwrittenFunctions"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Description"})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Definition"})}),"\n",(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsx)(n.p,{children:"registerOverwrittenFunctions()"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,r.jsx)(n.table,{children:(0,r.jsx)(n.thead,{children:(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.th,{children:"any"}),(0,r.jsx)(n.th,{children:"vehicleType"})]})})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Code"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-lua",children:'function ArticulatedAxis.registerOverwrittenFunctions(vehicleType)\n    SpecializationUtil.registerOverwrittenFunction(vehicleType, "getSteeringRotTimeByCurvature" , ArticulatedAxis.getSteeringRotTimeByCurvature)\n    SpecializationUtil.registerOverwrittenFunction(vehicleType, "getTurningRadiusByRotTime" , ArticulatedAxis.getTurningRadiusByRotTime)\n    SpecializationUtil.registerOverwrittenFunction(vehicleType, "getAIReverserNode" , ArticulatedAxis.getAIReverserNode)\nend\n\n'})})]})}function h(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}}}]);