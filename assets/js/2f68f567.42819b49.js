"use strict";(globalThis.webpackChunkfs25_community_luadoc=globalThis.webpackChunkfs25_community_luadoc||[]).push([[61659],{19244(e,n,t){t.r(n),t.d(n,{assets:()=>d,contentTitle:()=>o,default:()=>h,frontMatter:()=>s,metadata:()=>r,toc:()=>a});const r=JSON.parse('{"id":"script/Player/PlayerMover","title":"PlayerMover","description":"PlayerMover","source":"@site/../docs/script/Player/PlayerMover.md","sourceDirName":"script/Player","slug":"/script/Player/PlayerMover","permalink":"/FS25-Community-LUADOC/script/Player/PlayerMover","draft":false,"unlisted":false,"tags":[],"version":"current","lastUpdatedAt":1767161192000,"frontMatter":{},"sidebar":"docsSidebar","previous":{"title":"PlayerInputComponent","permalink":"/FS25-Community-LUADOC/script/Player/PlayerInputComponent"},"next":{"title":"PlayerSystem","permalink":"/FS25-Community-LUADOC/script/Player/PlayerSystem"}}');var i=t(74848),l=t(28453);const s={},o=void 0,d={},a=[{value:"PlayerMover",id:"playermover",level:2},{value:"calculateSmoothSpeed",id:"calculatesmoothspeed",level:3},{value:"debugDraw",id:"debugdraw",level:3},{value:"getMovementYaw",id:"getmovementyaw",level:3},{value:"getSpeed",id:"getspeed",level:3},{value:"initialise",id:"initialise",level:3},{value:"moveHorizontally",id:"movehorizontally",level:3},{value:"moveVertically",id:"movevertically",level:3},{value:"new",id:"new",level:3},{value:"onGroundRaycastCallback",id:"ongroundraycastcallback",level:3},{value:"onWaterRaycastCallback",id:"onwaterraycastcallback",level:3},{value:"setFlightActive",id:"setflightactive",level:3},{value:"setPosition",id:"setposition",level:3},{value:"teleportTo",id:"teleportto",level:3},{value:"toggleFlightActive",id:"toggleflightactive",level:3},{value:"update",id:"update",level:3},{value:"updateFloorDistance",id:"updatefloordistance",level:3},{value:"updateWaterSubmergeDistance",id:"updatewatersubmergedistance",level:3}];function c(e){const n={a:"a",blockquote:"blockquote",code:"code",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,l.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.h2,{id:"playermover",children:"PlayerMover"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Description"})}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsx)(n.p,{children:"Converts inputs into actual player movement, calculating and storing things like velocity."}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Functions"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"#calculatesmoothspeed",children:"calculateSmoothSpeed"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"#debugdraw",children:"debugDraw"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"#getmovementyaw",children:"getMovementYaw"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"#getspeed",children:"getSpeed"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"#initialise",children:"initialise"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"#movehorizontally",children:"moveHorizontally"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"#movevertically",children:"moveVertically"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"#new",children:"new"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"#ongroundraycastcallback",children:"onGroundRaycastCallback"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"#onwaterraycastcallback",children:"onWaterRaycastCallback"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"#setflightactive",children:"setFlightActive"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"#setposition",children:"setPosition"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"#teleportto",children:"teleportTo"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"#toggleflightactive",children:"toggleFlightActive"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"#update",children:"update"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"#updatefloordistance",children:"updateFloorDistance"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"#updatewatersubmergedistance",children:"updateWaterSubmergeDistance"})}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"calculatesmoothspeed",children:"calculateSmoothSpeed"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Description"})}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsx)(n.p,{children:"Uses the given parameters to calculate a smooth speed, interpolated between various values depending on the state of\nthe mover."}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Definition"})}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsx)(n.p,{children:"calculateSmoothSpeed(float moveScalar, boolean doWading, float minimumSpeed, float maximumSpeed)"}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"float"}),(0,i.jsx)(n.th,{children:"moveScalar"}),(0,i.jsx)(n.th,{children:"The value from 0 to 1 of how much the player is moving, this is usually the input. e.g. if the player is holding the movement analogue stick 50% of the way, this will be 0.5."})]})}),(0,i.jsxs)(n.tbody,{children:[(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"boolean"}),(0,i.jsx)(n.td,{children:"doWading"}),(0,i.jsx)(n.td,{children:"If this is true then the current water submerge distance is used, interpolating the speed between PlayerStateSwim.MAXIMUM_MOVE_SPEED and the maximumSpeed parameter."})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"float"}),(0,i.jsx)(n.td,{children:"minimumSpeed"}),(0,i.jsx)(n.td,{children:"The slowest speed of the player, this will only be used if doWading is false or the player is not submerged in water."})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"float"}),(0,i.jsx)(n.td,{children:"maximumSpeed"}),(0,i.jsx)(n.td,{children:"The fastest speed that the player can move."})]})]})]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Return Values"})}),"\n\n\n\n\n\n\n\n\n",(0,i.jsx)(n.table,{children:(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"float"}),(0,i.jsx)(n.th,{children:"smoothSpeed"}),(0,i.jsx)(n.th,{children:"The interpolated speed."})]})})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Code"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lua",children:"function PlayerMover:calculateSmoothSpeed(moveScalar, doWading, minimumSpeed, maximumSpeed)\n\n    -- If water is to be taken into account, adjust the minimum speed and move scalar.\n    if doWading then\n\n        -- fix to stop movement if moveScalar is 0 as it does not work with adjusted lower bound otherwise\n            if moveScalar = = 0 then\n                return 0\n            end\n\n            -- Adjust the minimum movement speed possible if the player is in the water, so they smoothly go from running/walking to swimming.\n                if self.currentWaterSubmergeDistance > PlayerMover.SLOW_SUBMERGE_THRESHOLD then\n                    minimumSpeed = PlayerStateSwim.MAXIMUM_MOVE_SPEED\n                end\n\n                -- Apply the wade scalar to the movement so they become slower the more submerged they are.\n                moveScalar = moveScalar * PlayerMover.calculateWadeScalar( self.currentWaterSubmergeDistance)\n            end\n\n            -- Smoothly interpolate the speed between the minimum and maximum.\n            return MathUtil.lerp(minimumSpeed, maximumSpeed, moveScalar)\n        end\n\n"})}),"\n",(0,i.jsx)(n.h3,{id:"debugdraw",children:"debugDraw"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Description"})}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsx)(n.p,{children:"Displays the debug information."}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Definition"})}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsx)(n.p,{children:"debugDraw(float x, float y, float textSize)"}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"float"}),(0,i.jsx)(n.th,{children:"x"}),(0,i.jsx)(n.th,{children:"The x position on the screen to begin drawing the values."})]})}),(0,i.jsxs)(n.tbody,{children:[(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"float"}),(0,i.jsx)(n.td,{children:"y"}),(0,i.jsx)(n.td,{children:"The y position on the screen to begin drawing the values."})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"float"}),(0,i.jsx)(n.td,{children:"textSize"}),(0,i.jsx)(n.td,{children:"The height of the text."})]})]})]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Return Values"})}),"\n\n\n\n\n\n\n\n\n",(0,i.jsx)(n.table,{children:(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"float"}),(0,i.jsx)(n.th,{children:"y"}),(0,i.jsx)(n.th,{children:"The y position on the screen after the entire debug info was drawn."})]})})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Code"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lua",children:'function PlayerMover:debugDraw(x, y, textSize)\n\n    -- Draw the movement direction node.\n    DebugUtil.drawDebugNode( self.movementDirectionNode, "MDIR" , false , 0 )\n\n    -- Render the header.\n    y = DebugUtil.renderTextLine(x, y, textSize * 1.5 , "Mover" , nil , true )\n\n    -- Render the values.\n    y = DebugUtil.renderTextLine(x, y, textSize, "Movement" , nil , true )\n    local positionX, positionY, positionZ = self:getPosition()\n    y = DebugUtil.renderTextLine(x, y, textSize, string.format( "Position: %.2f, %.2f, %.2f" , positionX, positionY, positionZ))\n    y = DebugUtil.renderTextLine(x, y, textSize, string.format( "Velocity: %.2f, %.2f, %.2f" , self.currentVelocityX, self.currentVelocityY , self.currentVelocityZ))\n    y = DebugUtil.renderTextLine(x, y, textSize, string.format( "Movement yaw: %.4f" , self:getMovementYaw()))\n    y = DebugUtil.renderTextLine(x, y, textSize, string.format( "Rotation: %.4f" , self.movementDirectionYaw))\n    y = DebugUtil.renderTextLine(x, y, textSize, string.format( "Rotation velocity: %.4f" , self.currentRotationVelocity))\n    y = DebugUtil.renderTextLine(x, y, textSize, string.format( "Speed: %.4f" , self.currentSpeed))\n    y = DebugUtil.renderNewLine(y, textSize)\n    y = DebugUtil.renderTextLine(x, y, textSize, "Ground/water" , nil , true )\n    y = DebugUtil.renderTextLine(x, y, textSize, string.format( "Water level: %.4f" , self.waterUnderfootY or 0.0 ))\n    y = DebugUtil.renderTextLine(x, y, textSize, string.format( "Submerge distance: %.4f" , self.currentWaterSubmergeDistance))\n    y = DebugUtil.renderTextLine(x, y, textSize, string.format( "Swimming/in water: %s/%s" , self.isSwimming, self.isInWater))\n    y = DebugUtil.renderTextLine(x, y, textSize, string.format( "Ground level: %.4f" , self.groundUnderfootY or 0.0 ))\n    y = DebugUtil.renderTextLine(x, y, textSize, string.format( "Ground distance: %.4f" , self.currentGroundDistance))\n    y = DebugUtil.renderTextLine(x, y, textSize, string.format( "Grounded: %s" , self.isGrounded))\n    y = DebugUtil.renderTextLine(x, y, textSize, string.format( "Close to ground: %s" , self.isCloseToGround))\n    y = DebugUtil.renderTextLine(x, y, textSize, string.format( "Fall/air/ground time: %.4f/%.4f/%.4f" , self.currentFallTime, self.currentAirTime, self.currentGroundTime))\n\n    -- Return the final y value.\n    return y\nend\n\n'})}),"\n",(0,i.jsx)(n.h3,{id:"getmovementyaw",children:"getMovementYaw"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Description"})}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsx)(n.p,{children:"Gets the yaw (y rotation) of the player's movement direction. This is more or less the actual yaw that the player has,\nand the graphical node's yaw smoothly follows it."}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Definition"})}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsx)(n.p,{children:"getMovementYaw()"}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Return Values"})}),"\n\n\n\n\n\n\n\n\n",(0,i.jsx)(n.table,{children:(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"float"}),(0,i.jsx)(n.th,{children:"currentForceYaw"}),(0,i.jsx)(n.th,{children:"The movement yaw of the player."})]})})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Code"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lua",children:"function PlayerMover:getMovementYaw()\n    return self.movementDirectionYaw\nend\n\n"})}),"\n",(0,i.jsx)(n.h3,{id:"getspeed",children:"getSpeed"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Description"})}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsx)(n.p,{children:"Returns the player's current horizontal speed in metres per second."}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Definition"})}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsx)(n.p,{children:"getSpeed()"}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Return Values"})}),"\n\n\n\n\n\n\n\n\n",(0,i.jsx)(n.table,{children:(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"float"}),(0,i.jsx)(n.th,{children:"currentSpeed"}),(0,i.jsx)(n.th,{children:"The player's current speed in metres per second."})]})})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Code"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lua",children:"function PlayerMover:getSpeed()\n    return self.currentSpeed\nend\n\n"})}),"\n",(0,i.jsx)(n.h3,{id:"initialise",children:"initialise"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Description"})}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsx)(n.p,{children:"Is called when the player first loads into the world, used to create and set up the movement node into the scene."}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Definition"})}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsx)(n.p,{children:"initialise()"}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Code"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lua",children:'function PlayerMover:initialise()\n\n    -- Create the node used to show the direction of movement relative to the player.\n    self.movementDirectionNode = createTransformGroup( "movementDirectionNode" )\n    link(getRootNode(), self.movementDirectionNode)\nend\n\n'})}),"\n",(0,i.jsx)(n.h3,{id:"movehorizontally",children:"moveHorizontally"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Description"})}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsx)(n.p,{children:"Adds the given movement to the player's movement this frame. Does not immediately change the player's position."}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Definition"})}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsx)(n.p,{children:"moveHorizontally(float currentForceX, float currentForceZ)"}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"float"}),(0,i.jsx)(n.th,{children:"currentForceX"}),(0,i.jsx)(n.th,{children:"The movement to make on the x axis in world space."})]})}),(0,i.jsx)(n.tbody,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"float"}),(0,i.jsx)(n.td,{children:"currentForceZ"}),(0,i.jsx)(n.td,{children:"The movement to make on the z axis in world space."})]})})]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Code"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lua",children:"function PlayerMover:moveHorizontally(currentForceX, currentForceZ)\n\n    -- Add the movement to the movement this frame.\n    self.currentForceX = self.currentForceX + currentForceX\n    self.currentForceZ = self.currentForceZ + currentForceZ\n\n    -- Raise the dirty flag, as a change has been made.\n    self.player:raiseDefaultDirtyFlag()\nend\n\n"})}),"\n",(0,i.jsx)(n.h3,{id:"movevertically",children:"moveVertically"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Description"})}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsx)(n.p,{children:"Adds the given movement to the player's movement this frame. Does not immediately change the player's position."}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Definition"})}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsx)(n.p,{children:"moveVertically(float currentForceY)"}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n",(0,i.jsx)(n.table,{children:(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"float"}),(0,i.jsx)(n.th,{children:"currentForceY"}),(0,i.jsx)(n.th,{children:"The movement to make on the y axis in world space."})]})})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Code"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lua",children:"function PlayerMover:moveVertically(currentForceY)\n\n    -- Add the movement to the movement this frame.\n    self.currentForceY = self.currentForceY + currentForceY\n\n    -- Raise the dirty flag, as a change has been made.\n    self.player:raiseDefaultDirtyFlag()\nend\n\n"})}),"\n",(0,i.jsx)(n.h3,{id:"new",children:"new"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Description"})}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsx)(n.p,{children:"Creates a new instance of the player mover class."}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Definition"})}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsx)(n.p,{children:"new(Player player)"}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n",(0,i.jsx)(n.table,{children:(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"Player"}),(0,i.jsx)(n.th,{children:"player"}),(0,i.jsx)(n.th,{children:"The player who owns this mover and is moved."})]})})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Return Values"})}),"\n\n\n\n\n\n\n\n\n",(0,i.jsx)(n.table,{children:(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"Player"}),(0,i.jsx)(n.th,{children:"instance"}),(0,i.jsx)(n.th,{children:"The created instance."})]})})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Code"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lua",children:"function PlayerMover.new(player)\n\n    -- TODO:Set up the dirty flag for the mover.\n\n        -- Create the instance.\n        local self = setmetatable( { } , PlayerMover _mt)\n\n        -- The player.\n        self.player = player\n\n        -- If this is true, update functions will run as normal and the player will be able to move and be affected by gravity.\n        self.isPhysicsEnabled = true\n\n        -- The movement to make this frame.\n        self.currentForceX = 0.0\n        self.currentForceY = 0.0\n        self.currentForceZ = 0.0\n\n        -- The rotation on the Y axis in world space in which the player is currently moving.\n        self.movementDirectionYaw = 0.0\n\n        -- The node used to show the direction of movement.\n        self.movementDirectionNode = nil\n\n        -- The velocity of the player.\n        self.currentSpeed = 0.0\n        self.currentVelocityX = 0.0\n        self.currentVelocityY = 0.0\n        self.currentVelocityZ = 0.0\n\n        self.positionDeltaX = 0.0\n        self.positionDeltaY = 0.0\n        self.positionDeltaZ = 0.0\n\n        self.currentRotationVelocity = 0.0\n\n        -- The water level under the player's feet, and the distance from the player to the water level.\n        self.waterUnderfootY = 0.0\n        self.currentWaterSubmergeDistance = 0.0\n\n        -- The floor level under the player's feet, and the distance from the player to the floor level.\n        self.groundUnderfootY = 0.0\n        self.currentGroundDistance = 0.0\n\n        -- Is true if the player is currently grounded(not falling or jumping); otherwise false.\n            self.isGrounded = true\n\n            -- Is true if the player is currently close to the ground; otherwise false.\n                self.isCloseToGround = true\n\n                self.isInWater = false\n\n                -- Is true if the player is submerged in water enough to start swimming; otherwise false.\n                    self.isSwimming = false\n                    self.needSwimming = false\n\n                    self.isCrouching = false\n\n                    self.isOnLadder = false\n\n                    -- How many seconds the player has been in the air.\n                    self.currentAirTime = 0.0\n\n                    -- How many seconds the player has been falling.\n                    self.currentFallTime = 0.0\n\n                    -- How many seconds the player has been on the ground.\n                    self.currentGroundTime = 0.0\n\n                    self.isFlightActive = false\n\n                    -- The dirty flag.\n                    self.dirtyFlag = self.player:getNextDirtyFlag()\n\n                    -- The event for when the position is changed via PlayerMover.teleportXXX.\n                        self.onPositionTeleport = ListenerList.new()\n\n                        -- Return the created instance.\n                        return self\n                    end\n\n"})}),"\n",(0,i.jsx)(n.h3,{id:"ongroundraycastcallback",children:"onGroundRaycastCallback"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Description"})}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsx)(n.p,{children:"Raycast callback for the ground checking ray. Simply sets self.groundUnderfootY to the y parameter if the hitObjectId\nexists."}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Definition"})}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsx)(n.p,{children:"onGroundRaycastCallback(float hitObjectId, float x, float y, float z)"}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"float"}),(0,i.jsx)(n.th,{children:"hitObjectId"}),(0,i.jsx)(n.th,{children:"The id of the object hit by the ray."})]})}),(0,i.jsxs)(n.tbody,{children:[(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"float"}),(0,i.jsx)(n.td,{children:"x"}),(0,i.jsx)(n.td,{children:"The x position of the ray hit."})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"float"}),(0,i.jsx)(n.td,{children:"y"}),(0,i.jsx)(n.td,{children:"The y position of the ray hit."})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"float"}),(0,i.jsx)(n.td,{children:"z"}),(0,i.jsx)(n.td,{children:"The z position of the ray hit."})]})]})]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Code"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lua",children:"function PlayerMover:onGroundRaycastCallback(hitObjectId, x, y, z)\n    if hitObjectId ~ = 0 then\n        self.groundUnderfootY = y\n    end\nend\n\n"})}),"\n",(0,i.jsx)(n.h3,{id:"onwaterraycastcallback",children:"onWaterRaycastCallback"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Description"})}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsx)(n.p,{children:"Raycast callback for the water checking ray\nSets self.waterUnderfootY to the y parameter if the hitObjectId exists and updates isInWater, needSwimming and\nisSwimming variables"}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Definition"})}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsx)(n.p,{children:"onWaterRaycastCallback(float hitObjectId, float x, float y, float z)"}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"float"}),(0,i.jsx)(n.th,{children:"hitObjectId"}),(0,i.jsx)(n.th,{children:"The id of the object hit by the ray."})]})}),(0,i.jsxs)(n.tbody,{children:[(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"float"}),(0,i.jsx)(n.td,{children:"x"}),(0,i.jsx)(n.td,{children:"The x position of the ray hit."})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"float"}),(0,i.jsx)(n.td,{children:"y"}),(0,i.jsx)(n.td,{children:"The y position of the ray hit."})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"float"}),(0,i.jsx)(n.td,{children:"z"}),(0,i.jsx)(n.td,{children:"The z position of the ray hit."})]})]})]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Code"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lua",children:"function PlayerMover:onWaterRaycastCallback(hitObjectId, x, y, z)\n    if hitObjectId ~ = 0 then\n        self.waterUnderfootY = y\n    end\n\n    -- Start with a distance of 0\n    self.currentWaterSubmergeDistance = 0.0\n\n    -- If the ray hit water save the result.\n    if self.waterUnderfootY ~ = nil then\n        self.currentWaterSubmergeDistance = math.max( 0 , self.waterUnderfootY - self.updateWaterSubmergeDistanceCurrentY)\n    end\n\n    self.isInWater = self.currentWaterSubmergeDistance > 0\n\n    self.needSwimming = self.currentWaterSubmergeDistance > = PlayerMover.SWIM_SUBMERGE_THRESHOLD\n\n    self.isSwimming = self.currentWaterSubmergeDistance > = PlayerMover.SWIM_SUBMERGE_THRESHOLD - 0.2\nend\n\n"})}),"\n",(0,i.jsx)(n.h3,{id:"setflightactive",children:"setFlightActive"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Description"})}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsx)(n.p,{children:"Sets the flight active mode to the given value. Does nothing if the player's flight mode is not toggled on."}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Definition"})}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsx)(n.p,{children:"setFlightActive(boolean isFlightActive, boolean? isForced)"}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"boolean"}),(0,i.jsx)(n.th,{children:"isFlightActive"}),(0,i.jsx)(n.th,{children:"True if flight mode should be activated; otherwise false."})]})}),(0,i.jsx)(n.tbody,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"boolean?"}),(0,i.jsx)(n.td,{children:"isForced"}),(0,i.jsx)(n.td,{children:"If this is true, the check for the command is skipped."})]})})]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Code"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lua",children:"function PlayerMover:setFlightActive(isFlightActive, isForced)\n\n    -- Disallow flight if the command is not toggled on.\n        if not isForced and( self.player.toggleFlightModeCommand = = nil or self.player.toggleFlightModeCommand.value = = false ) then\n            return\n        end\n\n        -- Set the flight toggle.\n        self.isFlightActive = isFlightActive = = true\n    end\n\n"})}),"\n",(0,i.jsx)(n.h3,{id:"setposition",children:"setPosition"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Description"})}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsx)(n.p,{children:"Moves the player to the given position."}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Definition"})}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsx)(n.p,{children:"setPosition(float x, float y, float z, boolean? setNodeTranslation)"}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"float"}),(0,i.jsx)(n.th,{children:"x"}),(0,i.jsx)(n.th,{children:"The x position."})]})}),(0,i.jsxs)(n.tbody,{children:[(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"float"}),(0,i.jsx)(n.td,{children:"y"}),(0,i.jsx)(n.td,{children:"The y position."})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"float"}),(0,i.jsx)(n.td,{children:"z"}),(0,i.jsx)(n.td,{children:"The z position."})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"boolean?"}),(0,i.jsx)(n.td,{children:"setNodeTranslation"}),(0,i.jsx)(n.td,{children:"If this is true, the player's root node will also be moved to the given position. Defaults to false."})]})]})]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Code"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lua",children:"function PlayerMover:setPosition(x, y, z, setNodeTranslation)\n\n    -- Move the player via their CCT.\n    self.player.capsuleController:setPosition(x, y, z, setNodeTranslation)\n\n    -- Raise the dirty flag, as a change has been made.\n    self.player:raiseDefaultDirtyFlag()\nend\n\n"})}),"\n",(0,i.jsx)(n.h3,{id:"teleportto",children:"teleportTo"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Description"})}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsx)(n.p,{children:"Teleports the player to the given position, sending a network event."}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Definition"})}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsx)(n.p,{children:"teleportTo(float x, float y, float z, boolean? setNodeTranslation, boolean? noEventSend)"}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"float"}),(0,i.jsx)(n.th,{children:"x"}),(0,i.jsx)(n.th,{children:"The x position."})]})}),(0,i.jsxs)(n.tbody,{children:[(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"float"}),(0,i.jsx)(n.td,{children:"y"}),(0,i.jsx)(n.td,{children:"The y position."})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"float"}),(0,i.jsx)(n.td,{children:"z"}),(0,i.jsx)(n.td,{children:"The z position."})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"boolean?"}),(0,i.jsx)(n.td,{children:"setNodeTranslation"}),(0,i.jsx)(n.td,{children:"If this is true, the player's root node will also be moved to the given position. Defaults to false."})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"boolean?"}),(0,i.jsx)(n.td,{children:"noEventSend"}),(0,i.jsx)(n.td,{children:"If this is true, no event will be sent to the server/client."})]})]})]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Code"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lua",children:'function PlayerMover:teleportTo(x, y, z, setNodeTranslation, noEventSend)\n\n    g_messageCenter:publish(MessageType.PLAYER_PRE_TELEPORT, self.player)\n\n    -- If the player is not the server and is the controlling player, then fire the teleport event so that the teleport is reflected on the server.\n    if not noEventSend and not self.player.isServer and self.player.isOwner then\n        g_client:getServerConnection():sendEvent( PlayerTeleportEvent.new(x, y, z, true , false ))\n    end\n\n    -- Set the last position.\n    self.lastPositionX, self.lastPositionY, self.lastPositionZ = self:getPosition()\n\n    -- Call the base move function.\n        self:setPosition(x, y, z, setNodeTranslation)\n\n        self.onPositionTeleport:invoke(x, y, z)\n\n        --#debug self.player:debugLog(Player.DEBUG_DISPLAY_FLAG.MOVEMENT, "Teleported to %.4f, %.4f, %.4f", x, y, z)\n    end\n\n'})}),"\n",(0,i.jsx)(n.h3,{id:"toggleflightactive",children:"toggleFlightActive"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Description"})}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsx)(n.p,{children:"Toggles the flight active mode on/off. Does nothing if the player's flight mode is not toggled on."}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Definition"})}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsx)(n.p,{children:"toggleFlightActive()"}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Code"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lua",children:"function PlayerMover:toggleFlightActive()\n    self:setFlightActive( not self.isFlightActive)\nend\n\n"})}),"\n",(0,i.jsx)(n.h3,{id:"update",children:"update"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Description"})}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsx)(n.p,{children:"Applies gravity and movement every frame."}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Definition"})}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsx)(n.p,{children:"update(float dt)"}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n",(0,i.jsx)(n.table,{children:(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"float"}),(0,i.jsx)(n.th,{children:"dt"}),(0,i.jsx)(n.th,{children:"Delta time in ms."})]})})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Code"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lua",children:"function PlayerMover:update(dt)\n\n    local nextPositionX, nextPositionY, nextPositionZ\n    if self:getIsPhysicsEnabled() then\n        -- Update and calculate the deltas.\n        self.positionDeltaX, self.positionDeltaY, self.positionDeltaZ = self:updateDeltas(dt)\n\n        -- Calculate where the player should be after the move, if there are no collisions.\n            local currentPositionX, currentPositionY, currentPositionZ = self:getPosition()\n            nextPositionX, nextPositionY, nextPositionZ = currentPositionX + self.positionDeltaX, currentPositionY + self.positionDeltaY, currentPositionZ + self.positionDeltaZ\n\n            setWorldTranslation( self.movementDirectionNode, nextPositionX, nextPositionY, nextPositionZ)\n\n            -- Apply the velocity to the player CCT.\n            self.player.capsuleController:move( self.positionDeltaX, self.positionDeltaY, self.positionDeltaZ)\n        end\n\n        -- If no next position was calculated, use the current position.\n        if nextPositionX = = nil then\n            nextPositionX, nextPositionY, nextPositionZ = self:getPosition()\n        end\n\n        -- Get the collision of the player's collider, if the bottom is touching something then they are grounded.This can only be done on the server.\n            local isGrounded = nil\n            if self.player.isServer or self:getIsPhysicsEnabled() then\n                isGrounded = self.player.capsuleController:calculateIfBottomTouchesGround()\n            end\n\n            -- Update the current distance from the water level and floor using the current position.\n            self:updateWaterSubmergeDistance(nextPositionX, nextPositionY, nextPositionZ)\n            self:updateFloorDistance(dt, isGrounded, nextPositionX, nextPositionY, nextPositionZ)\n\n            -- If physics are disabled, don't bother updating anything else.\n                if not self:getIsPhysicsEnabled() then\n                    return\n                end\n\n                local movementYaw\n                if self.player.isStrafeWalkMode then\n                    local _, yaw = self.player.camera:getRotation()\n                    movementYaw = yaw\n                else\n                        local currentSpeed = self:getSpeed()\n                        movementYaw = currentSpeed < = 0 and self.movementDirectionYaw or MathUtil.getYRotationFromDirection( self.currentVelocityX / currentSpeed, self.currentVelocityZ / currentSpeed)\n                    end\n\n                    -- Update the movement node's rotation.\n                    local oldDirectionYaw = self.movementDirectionYaw\n                    self:updateRotation(dt, movementYaw)\n                    self.currentRotationVelocity = MathUtil.getValidLimit( self.movementDirectionYaw - oldDirectionYaw) / (dt * 0.001 )\n                end\n\n"})}),"\n",(0,i.jsx)(n.h3,{id:"updatefloordistance",children:"updateFloorDistance"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Description"})}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsx)(n.p,{children:"Updates the distance from the player to the ground level to determine how far in the air they are."}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Definition"})}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsx)(n.p,{children:"updateFloorDistance(float dt, , , , )"}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"float"}),(0,i.jsx)(n.th,{children:"dt"}),(0,i.jsx)(n.th,{children:"The current delta time, used to update the self.currentFallTime timer."})]})}),(0,i.jsxs)(n.tbody,{children:[(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"any"}),(0,i.jsx)(n.td,{children:"isGrounded"}),(0,i.jsx)(n.td,{})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"any"}),(0,i.jsx)(n.td,{children:"currentX"}),(0,i.jsx)(n.td,{})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"any"}),(0,i.jsx)(n.td,{children:"currentY"}),(0,i.jsx)(n.td,{})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"any"}),(0,i.jsx)(n.td,{children:"currentZ"}),(0,i.jsx)(n.td,{})]})]})]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Code"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lua",children:"function PlayerMover:updateFloorDistance(dt, isGrounded, currentX, currentY, currentZ)\n\n    -- If a grounded value was given, use it.\n    if isGrounded ~ = nil then\n        self.isGrounded = isGrounded\n    end\n\n    -- If the bottom of the player's collider is touching the ground, set the ground distance to 0 and the ground level to the given y.This avoids raycasting.\n    if self.isGrounded then\n        self.currentGroundDistance = 0.0\n        self.groundUnderfootY = currentY\n        -- Otherwise; calculate the distance from the ground using a raycast.\n    else\n\n            -- Reset the ground level distance and fire a ray downwards.\n            self.groundUnderfootY = nil\n            raycastClosest(currentX, currentY + 10 , currentZ, 0 , - 1 , 0 , 200 , \"onGroundRaycastCallback\" , self , CollisionFlag.TERRAIN + CollisionFlag.STATIC_OBJECT + CollisionFlag.ROAD)\n\n            -- If the ray hit the ground, then calculate the distance.\n            if self.groundUnderfootY ~ = nil then\n                self.currentGroundDistance = math.max( 0 , currentY - self.groundUnderfootY)\n                -- Otherwise; treat y0 as the floor.\n            else\n                    self.groundUnderfootY = 0.0\n                    self.currentGroundDistance = currentY\n                end\n            end\n\n            -- The player is close to ground if they are either grounded or they're close enough to the ground.\n                self.isCloseToGround = self.isGrounded or self.currentGroundDistance < = self.CLOSE_TO_GROUND_THRESHOLD\n\n                -- Increment the fall timer.If the player is grounded or swimming then set it to 0.\n                self.currentGroundTime = self.isGrounded and self.currentGroundTime + dt * 0.001 or 0\n                self.currentAirTime = ( self.isGrounded or self.isInWater) and 0 or self.currentAirTime + dt * 0.001\n                self.currentFallTime = ( self.currentAirTime = = 0 or self.currentVelocityY > = 0 ) and 0 or self.currentFallTime + dt * 0.001\n            end\n\n"})}),"\n",(0,i.jsx)(n.h3,{id:"updatewatersubmergedistance",children:"updateWaterSubmergeDistance"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Description"})}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsx)(n.p,{children:"Updates the distance from the player to the water level to determine how submerged they are."}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Definition"})}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsx)(n.p,{children:"updateWaterSubmergeDistance()"}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"any"}),(0,i.jsx)(n.th,{children:"currentX"})]})}),(0,i.jsxs)(n.tbody,{children:[(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"any"}),(0,i.jsx)(n.td,{children:"currentY"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"any"}),(0,i.jsx)(n.td,{children:"currentZ"})]})]})]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Code"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lua",children:'function PlayerMover:updateWaterSubmergeDistance(currentX, currentY, currentZ)\n\n    -- Reset the water level distance and fire a ray downwards.\n    self.waterUnderfootY = nil\n    self.updateWaterSubmergeDistanceCurrentY = currentY\n    raycastClosestAsync(currentX, currentY + 3 , currentZ, 0 , - 1 , 0 , 6 , "onWaterRaycastCallback" , self , CollisionFlag.WATER)\nend\n\n'})})]})}function h(e={}){const{wrapper:n}={...(0,l.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(c,{...e})}):c(e)}},28453(e,n,t){t.d(n,{R:()=>s,x:()=>o});var r=t(96540);const i={},l=r.createContext(i);function s(e){const n=r.useContext(l);return r.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:s(e.components),r.createElement(l.Provider,{value:n},e.children)}}}]);