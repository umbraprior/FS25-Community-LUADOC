"use strict";(globalThis.webpackChunkfs25_community_luadoc=globalThis.webpackChunkfs25_community_luadoc||[]).push([[92544],{6378(e,n,t){t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>s,default:()=>o,frontMatter:()=>d,metadata:()=>r,toc:()=>h});const r=JSON.parse('{"id":"script/Vehicles/AIVehicleUtil","title":"AIVehicleUtil","description":"AIVehicleUtil","source":"@site/../docs/script/Vehicles/AIVehicleUtil.md","sourceDirName":"script/Vehicles","slug":"/script/Vehicles/AIVehicleUtil","permalink":"/FS25-Community-LUADOC/script/Vehicles/AIVehicleUtil","draft":false,"unlisted":false,"tags":[],"version":"current","lastUpdatedAt":1767330635000,"frontMatter":{},"sidebar":"docsSidebar","previous":{"title":"TargetedFunction","permalink":"/FS25-Community-LUADOC/script/Utils/TargetedFunction"},"next":{"title":"AnimationValueBool","permalink":"/FS25-Community-LUADOC/script/Vehicles/AnimationValueBool"}}');var l=t(74848),i=t(28453);const d={},s=void 0,c={},h=[{value:"AIVehicleUtil",id:"aivehicleutil",level:2},{value:"driveAlongCurvature",id:"drivealongcurvature",level:3},{value:"driveInDirection",id:"driveindirection",level:3},{value:"driveToPoint",id:"drivetopoint",level:3},{value:"getAIAreaOfVehicle",id:"getaiareaofvehicle",level:3},{value:"getAIDensityHeightArea",id:"getaidensityheightarea",level:3},{value:"getAIFruitArea",id:"getaifruitarea",level:3},{value:"getAIToolReverserDirectionNode",id:"getaitoolreverserdirectionnode",level:3},{value:"getAreaDimensions",id:"getareadimensions",level:3},{value:"getAttachedImplementsAllowTurnBackward",id:"getattachedimplementsallowturnbackward",level:3},{value:"getAttachedImplementsBlockTurnBackward",id:"getattachedimplementsblockturnbackward",level:3},{value:"getAttachedImplementsMaxTurnRadius",id:"getattachedimplementsmaxturnradius",level:3},{value:"getAverageDriveDirection",id:"getaveragedrivedirection",level:3},{value:"getDriveDirection",id:"getdrivedirection",level:3},{value:"getIsAreaOwned",id:"getisareaowned",level:3},{value:"getMaxToolRadius",id:"getmaxtoolradius",level:3},{value:"getValidityOfTurnDirections",id:"getvalidityofturndirections",level:3},{value:"updateInvertLeftRightMarkers",id:"updateinvertleftrightmarkers",level:3}];function a(e){const n={a:"a",blockquote:"blockquote",code:"code",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,i.R)(),...e.components};return(0,l.jsxs)(l.Fragment,{children:[(0,l.jsx)(n.h2,{id:"aivehicleutil",children:"AIVehicleUtil"}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Description"})}),"\n",(0,l.jsxs)(n.blockquote,{children:["\n",(0,l.jsx)(n.p,{children:"Util class for various ai vehicle functions"}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Functions"})}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsx)(n.li,{children:(0,l.jsx)(n.a,{href:"#drivealongcurvature",children:"driveAlongCurvature"})}),"\n",(0,l.jsx)(n.li,{children:(0,l.jsx)(n.a,{href:"#driveindirection",children:"driveInDirection"})}),"\n",(0,l.jsx)(n.li,{children:(0,l.jsx)(n.a,{href:"#drivetopoint",children:"driveToPoint"})}),"\n",(0,l.jsx)(n.li,{children:(0,l.jsx)(n.a,{href:"#getaiareaofvehicle",children:"getAIAreaOfVehicle"})}),"\n",(0,l.jsx)(n.li,{children:(0,l.jsx)(n.a,{href:"#getaidensityheightarea",children:"getAIDensityHeightArea"})}),"\n",(0,l.jsx)(n.li,{children:(0,l.jsx)(n.a,{href:"#getaifruitarea",children:"getAIFruitArea"})}),"\n",(0,l.jsx)(n.li,{children:(0,l.jsx)(n.a,{href:"#getaitoolreverserdirectionnode",children:"getAIToolReverserDirectionNode"})}),"\n",(0,l.jsx)(n.li,{children:(0,l.jsx)(n.a,{href:"#getareadimensions",children:"getAreaDimensions"})}),"\n",(0,l.jsx)(n.li,{children:(0,l.jsx)(n.a,{href:"#getattachedimplementsallowturnbackward",children:"getAttachedImplementsAllowTurnBackward"})}),"\n",(0,l.jsx)(n.li,{children:(0,l.jsx)(n.a,{href:"#getattachedimplementsblockturnbackward",children:"getAttachedImplementsBlockTurnBackward"})}),"\n",(0,l.jsx)(n.li,{children:(0,l.jsx)(n.a,{href:"#getattachedimplementsmaxturnradius",children:"getAttachedImplementsMaxTurnRadius"})}),"\n",(0,l.jsx)(n.li,{children:(0,l.jsx)(n.a,{href:"#getaveragedrivedirection",children:"getAverageDriveDirection"})}),"\n",(0,l.jsx)(n.li,{children:(0,l.jsx)(n.a,{href:"#getdrivedirection",children:"getDriveDirection"})}),"\n",(0,l.jsx)(n.li,{children:(0,l.jsx)(n.a,{href:"#getisareaowned",children:"getIsAreaOwned"})}),"\n",(0,l.jsx)(n.li,{children:(0,l.jsx)(n.a,{href:"#getmaxtoolradius",children:"getMaxToolRadius"})}),"\n",(0,l.jsx)(n.li,{children:(0,l.jsx)(n.a,{href:"#getvalidityofturndirections",children:"getValidityOfTurnDirections"})}),"\n",(0,l.jsx)(n.li,{children:(0,l.jsx)(n.a,{href:"#updateinvertleftrightmarkers",children:"updateInvertLeftRightMarkers"})}),"\n"]}),"\n",(0,l.jsx)(n.h3,{id:"drivealongcurvature",children:"driveAlongCurvature"}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Description"})}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Definition"})}),"\n",(0,l.jsxs)(n.blockquote,{children:["\n",(0,l.jsx)(n.p,{children:"driveAlongCurvature()"}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,l.jsxs)(n.table,{children:[(0,l.jsx)(n.thead,{children:(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.th,{children:"any"}),(0,l.jsx)(n.th,{children:"self"})]})}),(0,l.jsxs)(n.tbody,{children:[(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{children:"any"}),(0,l.jsx)(n.td,{children:"dt"})]}),(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{children:"any"}),(0,l.jsx)(n.td,{children:"curvature"})]}),(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{children:"any"}),(0,l.jsx)(n.td,{children:"maxSpeed"})]}),(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{children:"any"}),(0,l.jsx)(n.td,{children:"acceleration"})]})]})]}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Code"})}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-lua",children:"function AIVehicleUtil.driveAlongCurvature( self , dt, curvature, maxSpeed, acceleration)\n    local targetRotTime = self:getSteeringRotTimeByCurvature(curvature) * self:getSteeringDirection()\n    maxSpeed = maxSpeed or math.huge\n\n    -- if targetRotTime > self.rotatedTime then\n        -- self.rotatedTime = math.min(self.rotatedTime + dt*self:getAISteeringSpeed(), targetRotTime)\n        -- else\n            -- self.rotatedTime = math.max(self.rotatedTime - dt*self:getAISteeringSpeed(), targetRotTime)\n            -- end\n\n            self.rotatedTime = - targetRotTime\n\n            if self.finishedFirstUpdate then\n                local acc = acceleration\n                if maxSpeed > 0 then\n                    if self:getCruiseControlState() ~ = Drivable.CRUISECONTROL_STATE_ACTIVE then\n                        self:setCruiseControlState( Drivable.CRUISECONTROL_STATE_ACTIVE)\n                    end\n                else\n                        acc = 0\n                    end\n\n                    self:getMotor():setSpeedLimit(maxSpeed)\n\n                    WheelsUtil.updateWheelsPhysics( self , dt, self.lastSpeedReal * self.movingDirection, acc, maxSpeed > 0 , true )\n                end\n            end\n\n"})}),"\n",(0,l.jsx)(n.h3,{id:"driveindirection",children:"driveInDirection"}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Description"})}),"\n",(0,l.jsxs)(n.blockquote,{children:["\n",(0,l.jsx)(n.p,{children:"Drive in given direction"}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Definition"})}),"\n",(0,l.jsxs)(n.blockquote,{children:["\n",(0,l.jsx)(n.p,{children:"driveInDirection(table self, float dt, float steeringAngleLimit, float acceleration, float slowAcceleration, float\nslowAngleLimit, boolean allowedToDrive, boolean moveForwards, float lx, float lz, float maxSpeed, float\nslowDownFactor)"}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,l.jsxs)(n.table,{children:[(0,l.jsx)(n.thead,{children:(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.th,{children:"table"}),(0,l.jsx)(n.th,{children:"self"}),(0,l.jsx)(n.th,{children:"object of vehicle"})]})}),(0,l.jsxs)(n.tbody,{children:[(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{children:"float"}),(0,l.jsx)(n.td,{children:"dt"}),(0,l.jsx)(n.td,{children:"time since last call in ms"})]}),(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{children:"float"}),(0,l.jsx)(n.td,{children:"steeringAngleLimit"}),(0,l.jsx)(n.td,{children:"limit for steering angle"})]}),(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{children:"float"}),(0,l.jsx)(n.td,{children:"acceleration"}),(0,l.jsx)(n.td,{children:"acceleration"})]}),(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{children:"float"}),(0,l.jsx)(n.td,{children:"slowAcceleration"}),(0,l.jsx)(n.td,{children:"slow acceleration"})]}),(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{children:"float"}),(0,l.jsx)(n.td,{children:"slowAngleLimit"}),(0,l.jsx)(n.td,{children:"limit of slow angle"})]}),(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{children:"boolean"}),(0,l.jsx)(n.td,{children:"allowedToDrive"}),(0,l.jsx)(n.td,{children:"allow to drive"})]}),(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{children:"boolean"}),(0,l.jsx)(n.td,{children:"moveForwards"}),(0,l.jsx)(n.td,{children:"move forwards"})]}),(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{children:"float"}),(0,l.jsx)(n.td,{children:"lx"}),(0,l.jsx)(n.td,{children:"x direction"})]}),(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{children:"float"}),(0,l.jsx)(n.td,{children:"lz"}),(0,l.jsx)(n.td,{children:"z direction"})]}),(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{children:"float"}),(0,l.jsx)(n.td,{children:"maxSpeed"}),(0,l.jsx)(n.td,{children:"max speed"})]}),(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{children:"float"}),(0,l.jsx)(n.td,{children:"slowDownFactor"}),(0,l.jsx)(n.td,{children:"slow down factor"})]})]})]}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Code"})}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-lua",children:"function AIVehicleUtil.driveInDirection( self , dt, steeringAngleLimit, acceleration, slowAcceleration, slowAngleLimit, allowedToDrive, moveForwards, lx, lz, maxSpeed, slowDownFactor)\n\n    local angle = 0\n    if lx ~ = nil and lz ~ = nil then\n        local dot = lz\n        angle = math.deg( math.acos(dot))\n        if angle < 0 then\n            angle = angle + 180\n        end\n\n        local turnLeft = lx > 0.00001\n        if not moveForwards then\n            turnLeft = not turnLeft\n        end\n\n        local targetRotTime\n        if turnLeft then\n            --rotate to the left\n            targetRotTime = self.maxRotTime * math.min(angle / steeringAngleLimit, 1 )\n        else\n                --rotate to the right\n                targetRotTime = self.minRotTime * math.min(angle / steeringAngleLimit, 1 )\n            end\n\n            if targetRotTime > self.rotatedTime then\n                self.rotatedTime = math.min( self.rotatedTime + dt * self:getAISteeringSpeed(), targetRotTime)\n            else\n                    self.rotatedTime = math.max( self.rotatedTime - dt * self:getAISteeringSpeed(), targetRotTime)\n                end\n            end\n\n            if self.finishedFirstUpdate then\n                local acc = acceleration\n                if maxSpeed ~ = nil and maxSpeed ~ = 0 then\n                    if math.abs(angle) > = slowAngleLimit then\n                        maxSpeed = maxSpeed * slowDownFactor\n                    end\n                    self.motor:setSpeedLimit(maxSpeed)\n\n                    if self.cruiseControl.state ~ = Drivable.CRUISECONTROL_STATE_ACTIVE then\n                        self:setCruiseControlState( Drivable.CRUISECONTROL_STATE_ACTIVE)\n                    end\n                else\n                        if math.abs(angle) > = slowAngleLimit then\n                            acc = slowAcceleration\n                        end\n                    end\n                    if not allowedToDrive then\n                        acc = 0\n                    end\n                    if not moveForwards then\n                        acc = - acc\n                    end\n                    WheelsUtil.updateWheelsPhysics( self , dt, self.lastSpeedReal * self.movingDirection, acc, not allowedToDrive, true )\n                end\n            end\n\n"})}),"\n",(0,l.jsx)(n.h3,{id:"drivetopoint",children:"driveToPoint"}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Description"})}),"\n",(0,l.jsxs)(n.blockquote,{children:["\n",(0,l.jsx)(n.p,{children:"Drive vehicle to given point"}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Definition"})}),"\n",(0,l.jsxs)(n.blockquote,{children:["\n",(0,l.jsx)(n.p,{children:"driveToPoint(table self, float dt, float acceleration, boolean allowedToDrive, boolean moveForwards, float tX, float\ntZ, float maxSpeed, boolean? doNotSteer)"}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,l.jsxs)(n.table,{children:[(0,l.jsx)(n.thead,{children:(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.th,{children:"table"}),(0,l.jsx)(n.th,{children:"self"}),(0,l.jsx)(n.th,{children:"object of vehicle to move"})]})}),(0,l.jsxs)(n.tbody,{children:[(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{children:"float"}),(0,l.jsx)(n.td,{children:"dt"}),(0,l.jsx)(n.td,{children:"time since last call in ms"})]}),(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{children:"float"}),(0,l.jsx)(n.td,{children:"acceleration"}),(0,l.jsx)(n.td,{children:"acceleration"})]}),(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{children:"boolean"}),(0,l.jsx)(n.td,{children:"allowedToDrive"}),(0,l.jsx)(n.td,{children:"allowed to drive"})]}),(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{children:"boolean"}),(0,l.jsx)(n.td,{children:"moveForwards"}),(0,l.jsx)(n.td,{children:"move forwards"})]}),(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{children:"float"}),(0,l.jsx)(n.td,{children:"tX"}),(0,l.jsx)(n.td,{children:"local space x position"})]}),(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{children:"float"}),(0,l.jsx)(n.td,{children:"tZ"}),(0,l.jsx)(n.td,{children:"local space y position"})]}),(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{children:"float"}),(0,l.jsx)(n.td,{children:"maxSpeed"}),(0,l.jsx)(n.td,{children:"speed limit"})]}),(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{children:"boolean?"}),(0,l.jsx)(n.td,{children:"doNotSteer"}),(0,l.jsx)(n.td,{children:"do not steer, default: false"})]})]})]}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Code"})}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-lua",children:"function AIVehicleUtil.driveToPoint( self , dt, acceleration, allowedToDrive, moveForwards, tX, tZ, maxSpeed, doNotSteer)\n    if self.finishedFirstUpdate then\n\n        if allowedToDrive then\n\n            local tX_ 2 = tX * 0.5\n            local tZ_ 2 = tZ * 0.5\n\n            local d1X, d1Z = tZ_ 2 , - tX_ 2\n            if tX > 0 then\n                d1X, d1Z = - tZ_ 2 , tX_ 2\n            end\n\n            local hit,_,f2 = MathUtil.getLineLineIntersection2D(tX_ 2 ,tZ_ 2 , d1X,d1Z, 0 , 0 , tX, 0 )\n\n            if doNotSteer = = nil or not doNotSteer then\n                local rotTime = 0\n                if hit and math.abs(f2) < 100000 then\n                    local radius = tX * f2\n                    rotTime = self:getSteeringRotTimeByCurvature( 1 / radius)\n\n                    if self:getReverserDirection() < 0 then\n                        rotTime = - rotTime\n                    end\n\n                    --rotTime = self.wheelSteeringDuration * ( math.atan(1/radius) / math.atan(1/self.maxTurningRadius) )\n                end\n\n                local targetRotTime\n                if rotTime > = 0 then\n                    targetRotTime = math.min(rotTime, self.maxRotTime)\n                else\n                        targetRotTime = math.max(rotTime, self.minRotTime)\n                    end\n\n                    if targetRotTime > self.rotatedTime then\n                        self.rotatedTime = math.min( self.rotatedTime + dt * self:getAISteeringSpeed(), targetRotTime)\n                    else\n                            self.rotatedTime = math.max( self.rotatedTime - dt * self:getAISteeringSpeed(), targetRotTime)\n                        end\n\n                        -- adjust maxSpeed\n                        local steerDiff = targetRotTime - self.rotatedTime\n                        local fac = math.abs(steerDiff) / math.max( self.maxRotTime, - self.minRotTime)\n                        local speedReduction = 1.0 - math.pow(fac, 0.25 )\n\n                        -- if the speed is decreased to less than 1 km/h we do not accelrate anymore\n                            if maxSpeed * speedReduction < 1 then\n                                acceleration = 0\n                                speedReduction = 1 / maxSpeed\n                            end\n\n                            maxSpeed = maxSpeed * speedReduction\n                        end\n                    end\n\n                    self:getMotor():setSpeedLimit( math.min(maxSpeed, self:getCruiseControlSpeed()))\n                    if self:getCruiseControlState() ~ = Drivable.CRUISECONTROL_STATE_ACTIVE then\n                        self:setCruiseControlState( Drivable.CRUISECONTROL_STATE_ACTIVE)\n                    end\n\n                    if not allowedToDrive then\n                        acceleration = 0\n                    end\n                    if not moveForwards then\n                        acceleration = - acceleration\n                    end\n\n                    WheelsUtil.updateWheelsPhysics( self , dt, self.lastSpeedReal * self.movingDirection, acceleration, not allowedToDrive, true )\n\n                end\n            end\n\n"})}),"\n",(0,l.jsx)(n.h3,{id:"getaiareaofvehicle",children:"getAIAreaOfVehicle"}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Description"})}),"\n",(0,l.jsxs)(n.blockquote,{children:["\n",(0,l.jsx)(n.p,{children:"Returns amount of fruit to work for ai vehicle is in given area"}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Definition"})}),"\n",(0,l.jsxs)(n.blockquote,{children:["\n",(0,l.jsx)(n.p,{children:"getAIAreaOfVehicle(table vehicle, float startWorldX, float startWorldZ, float widthWorldX, float widthWorldZ, float\nheightWorldX, float heightWorldZ)"}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,l.jsxs)(n.table,{children:[(0,l.jsx)(n.thead,{children:(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.th,{children:"table"}),(0,l.jsx)(n.th,{children:"vehicle"}),(0,l.jsx)(n.th,{children:"vehicle"})]})}),(0,l.jsxs)(n.tbody,{children:[(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{children:"float"}),(0,l.jsx)(n.td,{children:"startWorldX"}),(0,l.jsx)(n.td,{children:"start world x"})]}),(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{children:"float"}),(0,l.jsx)(n.td,{children:"startWorldZ"}),(0,l.jsx)(n.td,{children:"start world z"})]}),(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{children:"float"}),(0,l.jsx)(n.td,{children:"widthWorldX"}),(0,l.jsx)(n.td,{children:"width world x"})]}),(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{children:"float"}),(0,l.jsx)(n.td,{children:"widthWorldZ"}),(0,l.jsx)(n.td,{children:"width world z"})]}),(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{children:"float"}),(0,l.jsx)(n.td,{children:"heightWorldX"}),(0,l.jsx)(n.td,{children:"height world x"})]}),(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{children:"float"}),(0,l.jsx)(n.td,{children:"heightWorldZ"}),(0,l.jsx)(n.td,{children:"height world z"})]})]})]}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Return Values"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,l.jsxs)(n.table,{children:[(0,l.jsx)(n.thead,{children:(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.th,{children:"float"}),(0,l.jsx)(n.th,{children:"area"}),(0,l.jsx)(n.th,{children:"area found"})]})}),(0,l.jsx)(n.tbody,{children:(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{children:"float"}),(0,l.jsx)(n.td,{children:"totalArea"}),(0,l.jsx)(n.td,{children:"total area checked"})]})})]}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Code"})}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-lua",children:"function AIVehicleUtil.getAIAreaOfVehicle(vehicle, startWorldX, startWorldZ, widthWorldX, widthWorldZ, heightWorldX, heightWorldZ)\n    local useDensityHeightMap = #vehicle:getAIDensityHeightTypeRequirements() > 0\n\n    if not useDensityHeightMap then\n        local query, isValid = vehicle:getFieldCropsQuery()\n        if isValid then\n            return AIVehicleUtil.getAIFruitArea(startWorldX, startWorldZ, widthWorldX, widthWorldZ, heightWorldX, heightWorldZ, query)\n        else\n                return 0 , 0\n            end\n        else\n                local densityHeightTypeRequirements = vehicle:getAIDensityHeightTypeRequirements()\n                return AIVehicleUtil.getAIDensityHeightArea(startWorldX, startWorldZ, widthWorldX, widthWorldZ, heightWorldX, heightWorldZ, densityHeightTypeRequirements)\n            end\n        end\n\n"})}),"\n",(0,l.jsx)(n.h3,{id:"getaidensityheightarea",children:"getAIDensityHeightArea"}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Description"})}),"\n",(0,l.jsxs)(n.blockquote,{children:["\n",(0,l.jsx)(n.p,{children:"Returns amount of density height to work is in given area"}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Definition"})}),"\n",(0,l.jsxs)(n.blockquote,{children:["\n",(0,l.jsx)(n.p,{children:"getAIDensityHeightArea(float startWorldX, float startWorldZ, float widthWorldX, float widthWorldZ, float heightWorldX,\nfloat heightWorldZ, table fruitRequirements, boolean densityHeightTypeRequirements)"}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,l.jsxs)(n.table,{children:[(0,l.jsx)(n.thead,{children:(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.th,{children:"float"}),(0,l.jsx)(n.th,{children:"startWorldX"}),(0,l.jsx)(n.th,{children:"start world x"})]})}),(0,l.jsxs)(n.tbody,{children:[(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{children:"float"}),(0,l.jsx)(n.td,{children:"startWorldZ"}),(0,l.jsx)(n.td,{children:"start world z"})]}),(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{children:"float"}),(0,l.jsx)(n.td,{children:"widthWorldX"}),(0,l.jsx)(n.td,{children:"width world x"})]}),(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{children:"float"}),(0,l.jsx)(n.td,{children:"widthWorldZ"}),(0,l.jsx)(n.td,{children:"width world z"})]}),(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{children:"float"}),(0,l.jsx)(n.td,{children:"heightWorldX"}),(0,l.jsx)(n.td,{children:"height world x"})]}),(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{children:"float"}),(0,l.jsx)(n.td,{children:"heightWorldZ"}),(0,l.jsx)(n.td,{children:"height world z"})]}),(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{children:"table"}),(0,l.jsx)(n.td,{children:"fruitRequirements"}),(0,l.jsx)(n.td,{children:"table with all required fruit types"})]}),(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{children:"boolean"}),(0,l.jsx)(n.td,{children:"densityHeightTypeRequirements"}),(0,l.jsx)(n.td,{children:"use density height types as requirements"})]})]})]}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Return Values"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,l.jsxs)(n.table,{children:[(0,l.jsx)(n.thead,{children:(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.th,{children:"boolean"}),(0,l.jsx)(n.th,{children:"area"}),(0,l.jsx)(n.th,{children:"area found"})]})}),(0,l.jsx)(n.tbody,{children:(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{children:"boolean"}),(0,l.jsx)(n.td,{children:"totalArea"}),(0,l.jsx)(n.td,{children:"total area checked"})]})})]}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Code"})}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-lua",children:"function AIVehicleUtil.getAIDensityHeightArea(startWorldX, startWorldZ, widthWorldX, widthWorldZ, heightWorldX, heightWorldZ, densityHeightTypeRequirements)\n    -- first check if we are on a field\n        local _, detailArea, _ = FSDensityMapUtil.getFieldDensity(startWorldX, startWorldZ, widthWorldX, widthWorldZ, heightWorldX, heightWorldZ)\n        if detailArea = = 0 then\n            return 0 , 0\n        end\n\n        local retArea, retTotalArea = 0 , 0\n        for _, densityHeightTypeRequirement in pairs(densityHeightTypeRequirements) do\n            if densityHeightTypeRequirement.fillType ~ = FillType.UNKNOWN then\n                local _, area, totalArea = DensityMapHeightUtil.getFillLevelAtArea(densityHeightTypeRequirement.fillType, startWorldX,startWorldZ, widthWorldX,widthWorldZ, heightWorldX,heightWorldZ)\n                retArea, retTotalArea = retArea + area, totalArea\n            end\n        end\n\n        return retArea, retTotalArea\n    end\n\n"})}),"\n",(0,l.jsx)(n.h3,{id:"getaifruitarea",children:"getAIFruitArea"}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Description"})}),"\n",(0,l.jsxs)(n.blockquote,{children:["\n",(0,l.jsx)(n.p,{children:"Returns amount of fruit to work is in given area"}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Definition"})}),"\n",(0,l.jsxs)(n.blockquote,{children:["\n",(0,l.jsx)(n.p,{children:"getAIFruitArea(float startWorldX, float startWorldZ, float widthWorldX, float widthWorldZ, float heightWorldX, float\nheightWorldZ, table query)"}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,l.jsxs)(n.table,{children:[(0,l.jsx)(n.thead,{children:(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.th,{children:"float"}),(0,l.jsx)(n.th,{children:"startWorldX"}),(0,l.jsx)(n.th,{children:"start world x"})]})}),(0,l.jsxs)(n.tbody,{children:[(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{children:"float"}),(0,l.jsx)(n.td,{children:"startWorldZ"}),(0,l.jsx)(n.td,{children:"start world z"})]}),(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{children:"float"}),(0,l.jsx)(n.td,{children:"widthWorldX"}),(0,l.jsx)(n.td,{children:"width world x"})]}),(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{children:"float"}),(0,l.jsx)(n.td,{children:"widthWorldZ"}),(0,l.jsx)(n.td,{children:"width world z"})]}),(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{children:"float"}),(0,l.jsx)(n.td,{children:"heightWorldX"}),(0,l.jsx)(n.td,{children:"height world x"})]}),(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{children:"float"}),(0,l.jsx)(n.td,{children:"heightWorldZ"}),(0,l.jsx)(n.td,{children:"height world z"})]}),(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{children:"table"}),(0,l.jsx)(n.td,{children:"query"}),(0,l.jsx)(n.td,{children:"field crops query of vehicle"})]})]})]}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Return Values"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,l.jsxs)(n.table,{children:[(0,l.jsx)(n.thead,{children:(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.th,{children:"table"}),(0,l.jsx)(n.th,{children:"area"}),(0,l.jsx)(n.th,{children:"area found"})]})}),(0,l.jsx)(n.tbody,{children:(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{children:"table"}),(0,l.jsx)(n.td,{children:"totalArea"}),(0,l.jsx)(n.td,{children:"total area checked"})]})})]}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Code"})}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-lua",children:"function AIVehicleUtil.getAIFruitArea(startWorldX, startWorldZ, widthWorldX, widthWorldZ, heightWorldX, heightWorldZ, query)\n    local x,z, widthX,widthZ, heightX,heightZ = MathUtil.getXZWidthAndHeight(startWorldX, startWorldZ, widthWorldX, widthWorldZ, heightWorldX, heightWorldZ)\n    return query:getParallelogram(x,z, widthX,widthZ, heightX,heightZ, false )\nend\n\n"})}),"\n",(0,l.jsx)(n.h3,{id:"getaitoolreverserdirectionnode",children:"getAIToolReverserDirectionNode"}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Description"})}),"\n",(0,l.jsxs)(n.blockquote,{children:["\n",(0,l.jsx)(n.p,{children:"Returns reverser direction node of attached ai tool"}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Definition"})}),"\n",(0,l.jsxs)(n.blockquote,{children:["\n",(0,l.jsx)(n.p,{children:"getAIToolReverserDirectionNode(table vehicle)"}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n",(0,l.jsx)(n.table,{children:(0,l.jsx)(n.thead,{children:(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.th,{children:"table"}),(0,l.jsx)(n.th,{children:"vehicle"}),(0,l.jsx)(n.th,{children:"vehicle to check"})]})})}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Return Values"})}),"\n\n\n\n\n\n\n\n\n",(0,l.jsx)(n.table,{children:(0,l.jsx)(n.thead,{children:(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.th,{children:"table"}),(0,l.jsx)(n.th,{children:"aiToolReverserDirectionNode"}),(0,l.jsx)(n.th,{children:"reverser direction node of ai tool"})]})})}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Code"})}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-lua",children:"function AIVehicleUtil.getAIToolReverserDirectionNode(vehicle)\n    for _, implement in pairs(vehicle:getAttachedImplements()) do\n        if implement.object ~ = nil and implement.object.getAIToolReverserDirectionNode ~ = nil then\n            local reverserNode = implement.object:getAIToolReverserDirectionNode()\n\n            local attachedReverserNode = AIVehicleUtil.getAIToolReverserDirectionNode(implement.object)\n            reverserNode = reverserNode or attachedReverserNode\n\n            if reverserNode ~ = nil then\n                return reverserNode\n            end\n        end\n    end\n\n    return nil\nend\n\n"})}),"\n",(0,l.jsx)(n.h3,{id:"getareadimensions",children:"getAreaDimensions"}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Description"})}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Definition"})}),"\n",(0,l.jsxs)(n.blockquote,{children:["\n",(0,l.jsx)(n.p,{children:"getAreaDimensions()"}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,l.jsxs)(n.table,{children:[(0,l.jsx)(n.thead,{children:(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.th,{children:"any"}),(0,l.jsx)(n.th,{children:"directionX"})]})}),(0,l.jsxs)(n.tbody,{children:[(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{children:"any"}),(0,l.jsx)(n.td,{children:"directionZ"})]}),(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{children:"any"}),(0,l.jsx)(n.td,{children:"leftNode"})]}),(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{children:"any"}),(0,l.jsx)(n.td,{children:"rightNode"})]}),(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{children:"any"}),(0,l.jsx)(n.td,{children:"xOffset"})]}),(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{children:"any"}),(0,l.jsx)(n.td,{children:"zOffset"})]}),(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{children:"any"}),(0,l.jsx)(n.td,{children:"areaSize"})]}),(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{children:"any"}),(0,l.jsx)(n.td,{children:"invertXOffset"})]})]})]}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Code"})}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-lua",children:"function AIVehicleUtil.getAreaDimensions(directionX, directionZ, leftNode, rightNode, xOffset, zOffset, areaSize, invertXOffset)\n    local xOffsetLeft, xOffsetRight = xOffset, xOffset\n    if invertXOffset = = nil or invertXOffset then\n        xOffsetLeft = - xOffsetLeft\n    end\n    local lX, _, lZ = localToWorld(leftNode, xOffsetLeft, 0 , zOffset)\n    local rX, _, rZ = localToWorld(rightNode, xOffsetRight, 0 , zOffset)\n\n    local sX = lX - ( 0.5 * directionX)\n    local sZ = lZ - ( 0.5 * directionZ)\n    local wX = rX - ( 0.5 * directionX)\n    local wZ = rZ - ( 0.5 * directionZ)\n    local hX = lX + (areaSize * directionX)\n    local hZ = lZ + (areaSize * directionZ)\n\n    return sX, sZ, wX, wZ, hX, hZ\nend\n\n"})}),"\n",(0,l.jsx)(n.h3,{id:"getattachedimplementsallowturnbackward",children:"getAttachedImplementsAllowTurnBackward"}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Description"})}),"\n",(0,l.jsxs)(n.blockquote,{children:["\n",(0,l.jsx)(n.p,{children:"Returns if trailer or trailer low is attached"}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Definition"})}),"\n",(0,l.jsxs)(n.blockquote,{children:["\n",(0,l.jsx)(n.p,{children:"getAttachedImplementsAllowTurnBackward(table vehicle)"}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n",(0,l.jsx)(n.table,{children:(0,l.jsx)(n.thead,{children:(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.th,{children:"table"}),(0,l.jsx)(n.th,{children:"vehicle"}),(0,l.jsx)(n.th,{children:"vehicle to check"})]})})}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Return Values"})}),"\n\n\n\n\n\n\n\n\n",(0,l.jsx)(n.table,{children:(0,l.jsx)(n.thead,{children:(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.th,{children:"table"}),(0,l.jsx)(n.th,{children:"isAttached"}),(0,l.jsx)(n.th,{children:"is attached"})]})})}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Code"})}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-lua",children:"function AIVehicleUtil.getAttachedImplementsAllowTurnBackward(vehicle)\n    if vehicle.getAIAllowTurnBackward ~ = nil then\n        if not vehicle:getAIAllowTurnBackward() then\n            return false\n        end\n    end\n\n    if vehicle.getAttachedImplements ~ = nil then\n        for _, implement in pairs(vehicle:getAttachedImplements()) do\n            local object = implement.object\n            if object ~ = nil then\n                if object.getAIAllowTurnBackward ~ = nil then\n                    if not object:getAIAllowTurnBackward() then\n                        return false\n                    end\n                end\n\n                if not AIVehicleUtil.getAttachedImplementsAllowTurnBackward(object) then\n                    return false\n                end\n            end\n        end\n    end\n\n    return true\nend\n\n"})}),"\n",(0,l.jsx)(n.h3,{id:"getattachedimplementsblockturnbackward",children:"getAttachedImplementsBlockTurnBackward"}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Description"})}),"\n",(0,l.jsxs)(n.blockquote,{children:["\n",(0,l.jsx)(n.p,{children:"Returns if one of the attached implements blocks reverse driving"}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Definition"})}),"\n",(0,l.jsxs)(n.blockquote,{children:["\n",(0,l.jsx)(n.p,{children:"getAttachedImplementsBlockTurnBackward(table vehicle)"}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n",(0,l.jsx)(n.table,{children:(0,l.jsx)(n.thead,{children:(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.th,{children:"table"}),(0,l.jsx)(n.th,{children:"vehicle"}),(0,l.jsx)(n.th,{children:"vehicle to check"})]})})}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Return Values"})}),"\n\n\n\n\n\n\n\n\n",(0,l.jsx)(n.table,{children:(0,l.jsx)(n.thead,{children:(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.th,{children:"table"}),(0,l.jsx)(n.th,{children:"doesBlock"}),(0,l.jsx)(n.th,{children:"implement does block"})]})})}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Code"})}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-lua",children:"function AIVehicleUtil.getAttachedImplementsBlockTurnBackward(vehicle)\n    if vehicle.getAIBlockTurnBackward ~ = nil then\n        if vehicle:getAIBlockTurnBackward() then\n            return true\n        end\n    end\n\n    if vehicle.getAttachedImplements ~ = nil then\n        for _, implement in pairs(vehicle:getAttachedImplements()) do\n            local object = implement.object\n            if object ~ = nil then\n                if object.getAIBlockTurnBackward ~ = nil then\n                    if object:getAIBlockTurnBackward() then\n                        return true\n                    end\n                end\n\n                if AIVehicleUtil.getAttachedImplementsBlockTurnBackward(object) then\n                    return true\n                end\n            end\n        end\n    end\n\n    return false\nend\n\n"})}),"\n",(0,l.jsx)(n.h3,{id:"getattachedimplementsmaxturnradius",children:"getAttachedImplementsMaxTurnRadius"}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Description"})}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Definition"})}),"\n",(0,l.jsxs)(n.blockquote,{children:["\n",(0,l.jsx)(n.p,{children:"getAttachedImplementsMaxTurnRadius()"}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,l.jsx)(n.table,{children:(0,l.jsx)(n.thead,{children:(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.th,{children:"any"}),(0,l.jsx)(n.th,{children:"vehicle"})]})})}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Code"})}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-lua",children:"function AIVehicleUtil.getAttachedImplementsMaxTurnRadius(vehicle)\n    local maxRadius = - 1\n    if vehicle.getAttachedImplements ~ = nil then\n        for _, implement in pairs(vehicle:getAttachedImplements()) do\n            local object = implement.object\n            if object ~ = nil then\n                if object.getAITurnRadiusLimitation ~ = nil then\n                    local radius = object:getAITurnRadiusLimitation()\n                    if radius ~ = nil and radius > maxRadius then\n                        maxRadius = radius\n                    end\n                end\n\n                local radius = AIVehicleUtil.getAttachedImplementsMaxTurnRadius(object)\n                if radius > maxRadius then\n                    maxRadius = radius\n                end\n            end\n        end\n    end\n\n    return maxRadius\nend\n\n"})}),"\n",(0,l.jsx)(n.h3,{id:"getaveragedrivedirection",children:"getAverageDriveDirection"}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Description"})}),"\n",(0,l.jsxs)(n.blockquote,{children:["\n",(0,l.jsx)(n.p,{children:"Returns average drive direction between 2 given vectors"}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Definition"})}),"\n",(0,l.jsxs)(n.blockquote,{children:["\n",(0,l.jsx)(n.p,{children:"getAverageDriveDirection(integer refNode, float x, float y, float z, float x2, float y2, float z2)"}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,l.jsxs)(n.table,{children:[(0,l.jsx)(n.thead,{children:(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.th,{children:"integer"}),(0,l.jsx)(n.th,{children:"refNode"}),(0,l.jsx)(n.th,{children:"id of ref node"})]})}),(0,l.jsxs)(n.tbody,{children:[(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{children:"float"}),(0,l.jsx)(n.td,{children:"x"}),(0,l.jsx)(n.td,{children:"world x 1"})]}),(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{children:"float"}),(0,l.jsx)(n.td,{children:"y"}),(0,l.jsx)(n.td,{children:"world y 1"})]}),(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{children:"float"}),(0,l.jsx)(n.td,{children:"z"}),(0,l.jsx)(n.td,{children:"world z 1"})]}),(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{children:"float"}),(0,l.jsx)(n.td,{children:"x2"}),(0,l.jsx)(n.td,{children:"world x 2"})]}),(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{children:"float"}),(0,l.jsx)(n.td,{children:"y2"}),(0,l.jsx)(n.td,{children:"world y 2"})]}),(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{children:"float"}),(0,l.jsx)(n.td,{children:"z2"}),(0,l.jsx)(n.td,{children:"world z 2"})]})]})]}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Return Values"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,l.jsxs)(n.table,{children:[(0,l.jsx)(n.thead,{children:(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.th,{children:"float"}),(0,l.jsx)(n.th,{children:"lx"}),(0,l.jsx)(n.th,{children:"average x direction"})]})}),(0,l.jsx)(n.tbody,{children:(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{children:"float"}),(0,l.jsx)(n.td,{children:"lz"}),(0,l.jsx)(n.td,{children:"average z direction"})]})})]}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Code"})}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-lua",children:"function AIVehicleUtil.getAverageDriveDirection(refNode, x, y, z, x2, y2, z2)\n    local lx, _, lz = worldToLocal(refNode, (x + x2) * 0.5 , (y + y2) * 0.5 , (z + z2) * 0.5 )\n\n    local length = MathUtil.vector2Length(lx, lz)\n    if length > 0.00001 then\n        lx = lx / length\n        lz = lz / length\n    end\n    return lx, lz, length\nend\n\n"})}),"\n",(0,l.jsx)(n.h3,{id:"getdrivedirection",children:"getDriveDirection"}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Description"})}),"\n",(0,l.jsxs)(n.blockquote,{children:["\n",(0,l.jsx)(n.p,{children:"Returns drive direction"}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Definition"})}),"\n",(0,l.jsxs)(n.blockquote,{children:["\n",(0,l.jsx)(n.p,{children:"getDriveDirection(integer refNode, float x, float y, float z)"}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,l.jsxs)(n.table,{children:[(0,l.jsx)(n.thead,{children:(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.th,{children:"integer"}),(0,l.jsx)(n.th,{children:"refNode"}),(0,l.jsx)(n.th,{children:"id of ref node"})]})}),(0,l.jsxs)(n.tbody,{children:[(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{children:"float"}),(0,l.jsx)(n.td,{children:"x"}),(0,l.jsx)(n.td,{children:"world x"})]}),(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{children:"float"}),(0,l.jsx)(n.td,{children:"y"}),(0,l.jsx)(n.td,{children:"world y"})]}),(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{children:"float"}),(0,l.jsx)(n.td,{children:"z"}),(0,l.jsx)(n.td,{children:"world z"})]})]})]}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Return Values"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,l.jsxs)(n.table,{children:[(0,l.jsx)(n.thead,{children:(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.th,{children:"float"}),(0,l.jsx)(n.th,{children:"lx"}),(0,l.jsx)(n.th,{children:"x direction"})]})}),(0,l.jsx)(n.tbody,{children:(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{children:"float"}),(0,l.jsx)(n.td,{children:"lz"}),(0,l.jsx)(n.td,{children:"z direction"})]})})]}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Code"})}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-lua",children:"function AIVehicleUtil.getDriveDirection(refNode, x, y, z)\n    local lx, _, lz = worldToLocal(refNode, x, y, z)\n\n    local length = MathUtil.vector2Length(lx, lz)\n    if length > 0.00001 then\n        length = 1 / length\n        lx = lx * length\n        lz = lz * length\n    end\n    return lx, lz\nend\n\n"})}),"\n",(0,l.jsx)(n.h3,{id:"getisareaowned",children:"getIsAreaOwned"}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Description"})}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Definition"})}),"\n",(0,l.jsxs)(n.blockquote,{children:["\n",(0,l.jsx)(n.p,{children:"getIsAreaOwned()"}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,l.jsxs)(n.table,{children:[(0,l.jsx)(n.thead,{children:(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.th,{children:"any"}),(0,l.jsx)(n.th,{children:"vehicle"})]})}),(0,l.jsxs)(n.tbody,{children:[(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{children:"any"}),(0,l.jsx)(n.td,{children:"sX"})]}),(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{children:"any"}),(0,l.jsx)(n.td,{children:"sZ"})]}),(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{children:"any"}),(0,l.jsx)(n.td,{children:"wX"})]}),(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{children:"any"}),(0,l.jsx)(n.td,{children:"wZ"})]}),(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{children:"any"}),(0,l.jsx)(n.td,{children:"hX"})]}),(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{children:"any"}),(0,l.jsx)(n.td,{children:"hZ"})]})]})]}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Code"})}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-lua",children:"function AIVehicleUtil.getIsAreaOwned(vehicle, sX, sZ, wX, wZ, hX, hZ)\n    local farmId = vehicle:getAIJobFarmId()\n    local centerX, centerZ = (sX + wX) * 0.5 , (sZ + wZ) * 0.5\n    if g_farmlandManager:getIsOwnedByFarmAtWorldPosition(farmId, centerX, centerZ) then\n        return true\n    end\n\n    if g_missionManager:getIsMissionWorkAllowed(farmId, centerX, centerZ, nil , vehicle) then\n        return true\n    end\n\n    return false\nend\n\n"})}),"\n",(0,l.jsx)(n.h3,{id:"getmaxtoolradius",children:"getMaxToolRadius"}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Description"})}),"\n",(0,l.jsxs)(n.blockquote,{children:["\n",(0,l.jsx)(n.p,{children:"Returns max tool turn radius"}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Definition"})}),"\n",(0,l.jsxs)(n.blockquote,{children:["\n",(0,l.jsx)(n.p,{children:"getMaxToolRadius(table implement)"}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n",(0,l.jsx)(n.table,{children:(0,l.jsx)(n.thead,{children:(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.th,{children:"table"}),(0,l.jsx)(n.th,{children:"implement"}),(0,l.jsx)(n.th,{children:"implement to check"})]})})}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Return Values"})}),"\n\n\n\n\n\n\n\n\n",(0,l.jsx)(n.table,{children:(0,l.jsx)(n.thead,{children:(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.th,{children:"table"}),(0,l.jsx)(n.th,{children:"maxTurnRadius"}),(0,l.jsx)(n.th,{children:"max turn radius"})]})})}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Code"})}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-lua",children:"function AIVehicleUtil.getMaxToolRadius(implement)\n    local radius = 0\n\n    local _, rotationNode, wheels, rotLimitFactor = implement.object:getAITurnRadiusLimitation()\n\n    -- collect the max manual defined turn radius of all vehicles, not only valid ai implements\n    local rootVehicle = implement.object.rootVehicle\n    local retRadius = AIVehicleUtil.getAttachedImplementsMaxTurnRadius(rootVehicle)\n\n    if retRadius ~ = - 1 then\n        radius = retRadius\n    end\n\n    if rotationNode then\n        local activeInputAttacherJoint = implement.object:getActiveInputAttacherJoint()\n        local refNode = rotationNode\n\n        -- If the refNode is any attacher joint, we always use the currently used attacher joint\n        for _, inputAttacherJoint in pairs(implement.object:getInputAttacherJoints()) do\n            if refNode = = inputAttacherJoint.node then\n                refNode = activeInputAttacherJoint.node\n                break\n            end\n        end\n\n        local rx,_,rz = localToLocal(refNode, implement.object.components[ 1 ].node, 0 , 0 , 0 )\n\n        for _, wheel in pairs(wheels) do\n            local nx,_,nz = localToLocal(wheel.repr, implement.object.components[ 1 ].node, 0 , 0 , 0 )\n\n            local x,z = nx - rx, nz - rz\n            local cx,cz = 0 , 0\n\n            -- get max rotation\n            local rotMax\n            if refNode = = activeInputAttacherJoint.node then\n                local attacherVehicle = implement.object:getAttacherVehicle()\n                local jointDesc = attacherVehicle:getAttacherJointDescFromObject(implement.object)\n                rotMax = math.max(jointDesc.upperRotLimit[ 2 ], jointDesc.lowerRotLimit[ 2 ]) * activeInputAttacherJoint.lowerRotLimitScale[ 2 ]\n            else\n                    for _,compJoint in pairs(implement.object.componentJoints) do\n                        if refNode = = compJoint.jointNode then\n                            -- assume that the axis with max.limit is our Y axis\n                            -- depending on the joint setup this can be the Y or Z axis\n                            for i = 1 , 3 do\n                                rotMax = math.max(rotMax or 0 , compJoint.rotLimit[i])\n                            end\n\n                            break\n                        end\n                    end\n                end\n\n                if rotMax ~ = nil then\n                    rotMax = rotMax * rotLimitFactor\n\n                    -- calc turning radius\n                    local x1 = x * math.cos(rotMax) - z * math.sin(rotMax)\n                    local z1 = x * math.sin(rotMax) + z * math.cos(rotMax)\n\n                    local dx = - z1\n                    local dz = x1\n                    if wheel.steering.steeringAxleScale ~ = 0 and wheel.steering.steeringAxleRotMax ~ = 0 then\n                        local tmpx, tmpz = dx, dz\n                        dx = tmpx * math.cos(wheel.steering.steeringAxleRotMax) - tmpz * math.sin(wheel.steering.steeringAxleRotMax)\n                        dz = tmpx * math.sin(wheel.steering.steeringAxleRotMax) + tmpz * math.cos(wheel.steering.steeringAxleRotMax)\n                    end\n\n                    local hit,f1,_ = MathUtil.getLineLineIntersection2D(cx,cz, 1 , 0 , x1,z1, dx,dz)\n                    if hit then\n                        radius = math.max(radius, math.abs(f1))\n                    end\n                else\n                        Logging.warning( \"AI rotation node '%s' could not be found as component joint or attacher joint on '%s'\" , getName(refNode), implement.object.configFileName)\n                    end\n                end\n            end\n\n            return radius\n        end\n\n"})}),"\n",(0,l.jsx)(n.h3,{id:"getvalidityofturndirections",children:"getValidityOfTurnDirections"}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Description"})}),"\n",(0,l.jsxs)(n.blockquote,{children:["\n",(0,l.jsx)(n.p,{children:"Checks fruits on left and right side of vehicle to decide the turn direction"}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Definition"})}),"\n",(0,l.jsxs)(n.blockquote,{children:["\n",(0,l.jsx)(n.p,{children:"getValidityOfTurnDirections(table vehicle, float checkFrontDistance, table turnData)"}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,l.jsxs)(n.table,{children:[(0,l.jsx)(n.thead,{children:(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.th,{children:"table"}),(0,l.jsx)(n.th,{children:"vehicle"}),(0,l.jsx)(n.th,{children:"vehicle to check"})]})}),(0,l.jsxs)(n.tbody,{children:[(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{children:"float"}),(0,l.jsx)(n.td,{children:"checkFrontDistance"}),(0,l.jsx)(n.td,{children:"distance to check in front of vehicle"})]}),(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{children:"table"}),(0,l.jsx)(n.td,{children:"turnData"}),(0,l.jsx)(n.td,{children:"properties for turning"})]})]})]}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Return Values"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,l.jsxs)(n.table,{children:[(0,l.jsx)(n.thead,{children:(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.th,{children:"table"}),(0,l.jsx)(n.th,{children:"leftAreaPercentage"}),(0,l.jsx)(n.th,{children:"left area percentage"})]})}),(0,l.jsx)(n.tbody,{children:(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{children:"table"}),(0,l.jsx)(n.td,{children:"rightAreaPercentage"}),(0,l.jsx)(n.td,{children:"right area percentage"})]})})]}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Code"})}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-lua",children:"function AIVehicleUtil.getValidityOfTurnDirections(vehicle, turnData)\n    -- let's check the area at/around the marker which is farest behind of vehicle\n    local directionNode = vehicle:getAIDirectionNode()\n    local attachedAIImplements = vehicle:getAttachedAIImplements()\n    local checkFrontDistance = 5\n\n    local leftAreaPercentage = 0\n    local rightAreaPercentage = 0\n\n    local minZ = math.huge\n    local maxZ = - math.huge\n    for _,implement in pairs(attachedAIImplements) do\n        local leftMarker, rightMarker, backMarker = implement.object:getAIMarkers()\n\n        local _,_,zl = localToLocal(leftMarker, directionNode, 0 , 0 , 0 )\n        local _,_,zr = localToLocal(rightMarker, directionNode, 0 , 0 , 0 )\n        local _,_,zb = localToLocal(backMarker, directionNode, 0 , 0 , 0 )\n\n        minZ = math.min(minZ, zl, zr, zb)\n        maxZ = math.max(maxZ, zl, zr, zb)\n    end\n\n    local sideDistance\n    if turnData = = nil then\n        local minAreaWidth = math.huge\n        for _,implement in pairs(attachedAIImplements) do\n            local leftMarker, rightMarker, _ = implement.object:getAIMarkers()\n\n            local lx, _, _ = localToLocal(leftMarker, directionNode, 0 , 0 , 0 )\n            local rx, _, _ = localToLocal(rightMarker, directionNode, 0 , 0 , 0 )\n            minAreaWidth = math.min(minAreaWidth, math.abs(lx - rx))\n        end\n        sideDistance = minAreaWidth\n    else\n            sideDistance = math.abs(turnData.sideOffsetRight - turnData.sideOffsetLeft)\n        end\n\n        local dx, dz = vehicle.aiDriveDirection[ 1 ], vehicle.aiDriveDirection[ 2 ]\n        local sx, sz = - dz, dx\n\n        for _,implement in pairs(attachedAIImplements) do\n            local leftMarker, rightMarker, _ = implement.object:getAIMarkers()\n\n            local lx, ly, lz = localToLocal(leftMarker, directionNode, 0 , 0 , 0 )\n            local rx, ry, rz = localToLocal(rightMarker, directionNode, 0 , 0 , 0 )\n\n            local width = math.abs(lx - rx)\n            local length = checkFrontDistance + (maxZ - minZ) + math.max(sideDistance * 1.3 + 2 , checkFrontDistance) -- 1.3~tan(53) allows detecting back along a field side with angle 53(and 2m extra compensates for some variances, or higher angles with small tools)\n\n                lx, _, lz = localToWorld(directionNode, lx,ly,maxZ + checkFrontDistance)\n                rx, _, rz = localToWorld(directionNode, rx,ry,maxZ + checkFrontDistance)\n\n                local lSX = lx\n                local lSZ = lz\n                local lWX = lSX - sx * width\n                local lWZ = lSZ - sz * width\n                local lHX = lSX - dx * length\n                local lHZ = lSZ - dz * length\n\n                local rSX = rx\n                local rSZ = rz\n                local rWX = rSX + sx * width\n                local rWZ = rSZ + sz * width\n                local rHX = rSX - dx * length\n                local rHZ = rSZ - dz * length\n\n                local lArea, lTotal = AIVehicleUtil.getAIAreaOfVehicle(implement.object, lSX,lSZ, lWX,lWZ, lHX,lHZ)\n                local rArea, rTotal = AIVehicleUtil.getAIAreaOfVehicle(implement.object, rSX,rSZ, rWX,rWZ, rHX,rHZ)\n\n                if lTotal > 0 then\n                    leftAreaPercentage = leftAreaPercentage + (lArea / lTotal)\n                end\n                if rTotal > 0 then\n                    rightAreaPercentage = rightAreaPercentage + (rArea / rTotal)\n                end\n\n                -- just visual debuging\n                if VehicleDebug.state = = VehicleDebug.DEBUG_AI then\n                    local lSY = getTerrainHeightAtWorldPos(g_terrainNode, lSX, 0 ,lSZ) + 2\n                    local lWY = getTerrainHeightAtWorldPos(g_terrainNode, lWX, 0 ,lWZ) + 2\n                    local lHY = getTerrainHeightAtWorldPos(g_terrainNode, lHX, 0 ,lHZ) + 2\n                    local rSY = getTerrainHeightAtWorldPos(g_terrainNode, rSX, 0 ,rSZ) + 2\n                    local rWY = getTerrainHeightAtWorldPos(g_terrainNode, rWX, 0 ,rWZ) + 2\n                    local rHY = getTerrainHeightAtWorldPos(g_terrainNode, rHX, 0 ,rHZ) + 2\n\n                    vehicle:addAIDebugLine( { lSX,lSY,lSZ } , { lWX,lWY,lWZ } , { 0.5 , 0.5 , 0.5 } )\n                    vehicle:addAIDebugLine( { lSX,lSY,lSZ } , { lHX,lHY,lHZ } , { 0.5 , 0.5 , 0.5 } )\n                    vehicle:addAIDebugLine( { rSX,rSY,rSZ } , { rWX,rWY,rWZ } , { 0.5 , 0.5 , 0.5 } )\n                    vehicle:addAIDebugLine( { rSX,rSY,rSZ } , { rHX,rHY,rHZ } , { 0.5 , 0.5 , 0.5 } )\n                end\n            end\n\n            leftAreaPercentage = leftAreaPercentage / #attachedAIImplements\n            rightAreaPercentage = rightAreaPercentage / #attachedAIImplements\n\n            return leftAreaPercentage, rightAreaPercentage\n        end\n\n"})}),"\n",(0,l.jsx)(n.h3,{id:"updateinvertleftrightmarkers",children:"updateInvertLeftRightMarkers"}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Description"})}),"\n",(0,l.jsxs)(n.blockquote,{children:["\n",(0,l.jsx)(n.p,{children:"Update invertation of ai left and right markers on vehicle"}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Definition"})}),"\n",(0,l.jsxs)(n.blockquote,{children:["\n",(0,l.jsx)(n.p,{children:"updateInvertLeftRightMarkers(table rootAttacherVehicle, table vehicle)"}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,l.jsxs)(n.table,{children:[(0,l.jsx)(n.thead,{children:(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.th,{children:"table"}),(0,l.jsx)(n.th,{children:"rootAttacherVehicle"}),(0,l.jsx)(n.th,{children:"root attacher vehicle"})]})}),(0,l.jsx)(n.tbody,{children:(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{children:"table"}),(0,l.jsx)(n.td,{children:"vehicle"}),(0,l.jsx)(n.td,{children:"vehicle"})]})})]}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Code"})}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-lua",children:"function AIVehicleUtil.updateInvertLeftRightMarkers(rootAttacherVehicle, vehicle)\n    if vehicle.getAIMarkers ~ = nil then\n        local leftMarker, rightMarker, _ = vehicle:getAIMarkers()\n        if leftMarker ~ = nil and rightMarker ~ = nil then\n            local lX, _, _ = localToLocal(leftMarker, rootAttacherVehicle:getAIDirectionNode(), 0 , 0 , 0 )\n            local rX, _, _ = localToLocal(rightMarker, rootAttacherVehicle:getAIDirectionNode(), 0 , 0 , 0 )\n\n            if rX > lX then\n                vehicle:setAIMarkersInverted()\n            end\n        end\n    end\nend\n\n"})})]})}function o(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,l.jsx)(n,{...e,children:(0,l.jsx)(a,{...e})}):a(e)}},28453(e,n,t){t.d(n,{R:()=>d,x:()=>s});var r=t(96540);const l={},i=r.createContext(l);function d(e){const n=r.useContext(i);return r.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function s(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(l):e.components||l:d(e.components),r.createElement(i.Provider,{value:n},e.children)}}}]);