"use strict";(globalThis.webpackChunkfs25_community_luadoc=globalThis.webpackChunkfs25_community_luadoc||[]).push([[42879],{9286(n,i,e){e.r(i),e.d(i,{assets:()=>o,contentTitle:()=>c,default:()=>g,frontMatter:()=>s,metadata:()=>t,toc:()=>a});const t=JSON.parse('{"id":"script/AI/AICollisionTriggerHandler","title":"AICollisionTriggerHandler","description":"AICollisionTriggerHandler","source":"@site/../docs/script/AI/AICollisionTriggerHandler.md","sourceDirName":"script/AI","slug":"/script/AI/AICollisionTriggerHandler","permalink":"/FS25-Community-LUADOC/script/AI/AICollisionTriggerHandler","draft":false,"unlisted":false,"tags":[],"version":"current","lastUpdatedAt":1767161192000,"frontMatter":{},"sidebar":"docsSidebar","previous":{"title":"Script","permalink":"/FS25-Community-LUADOC/script"},"next":{"title":"AIDriveStrategy","permalink":"/FS25-Community-LUADOC/script/AI/AIDriveStrategy"}}');var l=e(74848),r=e(28453);const s={},c=void 0,o={},a=[{value:"AICollisionTriggerHandler",id:"aicollisiontriggerhandler",level:2},{value:"generateTriggerPath",id:"generatetriggerpath",level:3},{value:"init",id:"init",level:3},{value:"new",id:"new",level:3},{value:"onVehicleCollisionDistanceCallback",id:"onvehiclecollisiondistancecallback",level:3},{value:"setCollisionDistanceCallback",id:"setcollisiondistancecallback",level:3},{value:"setIsBlockedCallback",id:"setisblockedcallback",level:3},{value:"setStaticCollisionCallback",id:"setstaticcollisioncallback",level:3},{value:"update",id:"update",level:3},{value:"updateBlockedCallback",id:"updateblockedcallback",level:3},{value:"updateStaticCollisionCallback",id:"updatestaticcollisioncallback",level:3}];function d(n){const i={a:"a",blockquote:"blockquote",code:"code",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,r.R)(),...n.components};return(0,l.jsxs)(l.Fragment,{children:[(0,l.jsx)(i.h2,{id:"aicollisiontriggerhandler",children:"AICollisionTriggerHandler"}),"\n",(0,l.jsx)(i.p,{children:(0,l.jsx)(i.strong,{children:"Description"})}),"\n",(0,l.jsxs)(i.blockquote,{children:["\n",(0,l.jsx)(i.p,{children:"Drive strategy to stop vehicle on collision\nCopyright (C) GIANTS Software GmbH, Confidential, All Rights Reserved."}),"\n"]}),"\n",(0,l.jsx)(i.p,{children:(0,l.jsx)(i.strong,{children:"Functions"})}),"\n",(0,l.jsxs)(i.ul,{children:["\n",(0,l.jsx)(i.li,{children:(0,l.jsx)(i.a,{href:"#generatetriggerpath",children:"generateTriggerPath"})}),"\n",(0,l.jsx)(i.li,{children:(0,l.jsx)(i.a,{href:"#init",children:"init"})}),"\n",(0,l.jsx)(i.li,{children:(0,l.jsx)(i.a,{href:"#new",children:"new"})}),"\n",(0,l.jsx)(i.li,{children:(0,l.jsx)(i.a,{href:"#onvehiclecollisiondistancecallback",children:"onVehicleCollisionDistanceCallback"})}),"\n",(0,l.jsx)(i.li,{children:(0,l.jsx)(i.a,{href:"#setcollisiondistancecallback",children:"setCollisionDistanceCallback"})}),"\n",(0,l.jsx)(i.li,{children:(0,l.jsx)(i.a,{href:"#setisblockedcallback",children:"setIsBlockedCallback"})}),"\n",(0,l.jsx)(i.li,{children:(0,l.jsx)(i.a,{href:"#setstaticcollisioncallback",children:"setStaticCollisionCallback"})}),"\n",(0,l.jsx)(i.li,{children:(0,l.jsx)(i.a,{href:"#update",children:"update"})}),"\n",(0,l.jsx)(i.li,{children:(0,l.jsx)(i.a,{href:"#updateblockedcallback",children:"updateBlockedCallback"})}),"\n",(0,l.jsx)(i.li,{children:(0,l.jsx)(i.a,{href:"#updatestaticcollisioncallback",children:"updateStaticCollisionCallback"})}),"\n"]}),"\n",(0,l.jsx)(i.h3,{id:"generatetriggerpath",children:"generateTriggerPath"}),"\n",(0,l.jsx)(i.p,{children:(0,l.jsx)(i.strong,{children:"Description"})}),"\n",(0,l.jsx)(i.p,{children:(0,l.jsx)(i.strong,{children:"Definition"})}),"\n",(0,l.jsxs)(i.blockquote,{children:["\n",(0,l.jsx)(i.p,{children:"generateTriggerPath()"}),"\n"]}),"\n",(0,l.jsx)(i.p,{children:(0,l.jsx)(i.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,l.jsxs)(i.table,{children:[(0,l.jsx)(i.thead,{children:(0,l.jsxs)(i.tr,{children:[(0,l.jsx)(i.th,{children:"any"}),(0,l.jsx)(i.th,{children:"vehicle"})]})}),(0,l.jsxs)(i.tbody,{children:[(0,l.jsxs)(i.tr,{children:[(0,l.jsx)(i.td,{children:"any"}),(0,l.jsx)(i.td,{children:"trigger"})]}),(0,l.jsxs)(i.tr,{children:[(0,l.jsx)(i.td,{children:"any"}),(0,l.jsx)(i.td,{children:"movingDirection"})]})]})]}),"\n",(0,l.jsx)(i.p,{children:(0,l.jsx)(i.strong,{children:"Code"})}),"\n",(0,l.jsx)(i.pre,{children:(0,l.jsx)(i.code,{className:"language-lua",children:"function AICollisionTriggerHandler:generateTriggerPath(vehicle, trigger, movingDirection)\n    local node = movingDirection > = 0 and trigger.node or(trigger.backNode or trigger.node)\n    trigger.curTriggerDirection = (movingDirection < 0 and trigger.backNode ~ = trigger.node) and trigger.backNodeDirection or 1\n\n    for i = 0 , AICollisionTriggerHandler.TRIGGER_SUBDIVISIONS * 3 , 3 do\n        local x, y, z = localToWorld(node, 0 , 0 , i / AICollisionTriggerHandler.TRIGGER_SUBDIVISIONS / 3 * trigger.length * trigger.curTriggerDirection)\n        trigger.positions[i + 1 ] = x\n        trigger.positions[i + 2 ] = getTerrainHeightAtWorldPos(g_terrainNode, x, y, z) + trigger.height * 0.5\n        trigger.positions[i + 3 ] = z\n    end\n\n    trigger.isValid = true\nend\n\n"})}),"\n",(0,l.jsx)(i.h3,{id:"init",children:"init"}),"\n",(0,l.jsx)(i.p,{children:(0,l.jsx)(i.strong,{children:"Description"})}),"\n",(0,l.jsx)(i.p,{children:(0,l.jsx)(i.strong,{children:"Definition"})}),"\n",(0,l.jsxs)(i.blockquote,{children:["\n",(0,l.jsx)(i.p,{children:"init()"}),"\n"]}),"\n",(0,l.jsx)(i.p,{children:(0,l.jsx)(i.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,l.jsxs)(i.table,{children:[(0,l.jsx)(i.thead,{children:(0,l.jsxs)(i.tr,{children:[(0,l.jsx)(i.th,{children:"any"}),(0,l.jsx)(i.th,{children:"vehicle"})]})}),(0,l.jsx)(i.tbody,{children:(0,l.jsxs)(i.tr,{children:[(0,l.jsx)(i.td,{children:"any"}),(0,l.jsx)(i.td,{children:"strategy"})]})})]}),"\n",(0,l.jsx)(i.p,{children:(0,l.jsx)(i.strong,{children:"Code"})}),"\n",(0,l.jsx)(i.pre,{children:(0,l.jsx)(i.code,{className:"language-lua",children:"function AICollisionTriggerHandler:init(vehicle, strategy)\n    self.vehicle = vehicle\n    self.strategy = strategy\n\n    if vehicle.isServer then\n        self.collisionTriggerByVehicle = { }\n\n        self.rootVehicle = vehicle.rootVehicle\n\n        local vehicles = self.rootVehicle.childVehicles\n        for i = 1 , #vehicles do\n            local subVehicle = vehicles[i]\n            if subVehicle.getAICollisionTriggers ~ = nil then\n                subVehicle:getAICollisionTriggers( self.collisionTriggerByVehicle)\n            end\n\n            if subVehicle.getAIImplementCollisionTriggers ~ = nil then\n                subVehicle:getAIImplementCollisionTriggers( self.collisionTriggerByVehicle)\n            end\n        end\n\n        local index = 1\n        for v, trigger in pairs( self.collisionTriggerByVehicle) do\n            trigger.vehicle = v\n            trigger.updateIndex = index\n            trigger.hasCollision = false\n            trigger.hasStaticCollision = false\n            trigger.isValid = true\n            trigger.hitCounter = 0\n            trigger.hitStaticCounter = 0\n            trigger.curTriggerLength = 5\n            trigger.curTriggerDirection = 1\n\n            trigger.dynamicHitPoint = { 0 , 0 , 0 }\n            trigger.dynamicHitPointValid = false\n            trigger.dynamicHitPointDistance = math.huge\n            trigger.dynamicHitPointInitialDistance = 0\n\n            trigger.staticHitPoint = { 0 , 0 , 0 }\n            trigger.staticHitPointValid = false\n            trigger.staticHitPointDistance = math.huge\n            trigger.staticHitPointInitialDistance = 0\n\n            trigger.positions = { }\n            for i = 1 , ( AICollisionTriggerHandler.TRIGGER_SUBDIVISIONS + 1 ) * 3 do\n                table.insert(trigger.positions, 0 )\n            end\n\n            index = index + AICollisionTriggerHandler.UPDATE_INTERVAL\n        end\n        self.maxUpdateIndex = index\n    end\nend\n\n"})}),"\n",(0,l.jsx)(i.h3,{id:"new",children:"new"}),"\n",(0,l.jsx)(i.p,{children:(0,l.jsx)(i.strong,{children:"Description"})}),"\n",(0,l.jsx)(i.p,{children:(0,l.jsx)(i.strong,{children:"Definition"})}),"\n",(0,l.jsxs)(i.blockquote,{children:["\n",(0,l.jsx)(i.p,{children:"new()"}),"\n"]}),"\n",(0,l.jsx)(i.p,{children:(0,l.jsx)(i.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,l.jsx)(i.table,{children:(0,l.jsx)(i.thead,{children:(0,l.jsxs)(i.tr,{children:[(0,l.jsx)(i.th,{children:"any"}),(0,l.jsx)(i.th,{children:"customMt"})]})})}),"\n",(0,l.jsx)(i.p,{children:(0,l.jsx)(i.strong,{children:"Code"})}),"\n",(0,l.jsx)(i.pre,{children:(0,l.jsx)(i.code,{className:"language-lua",children:"function AICollisionTriggerHandler.new(customMt)\n    local self = setmetatable( { } , customMt or AICollisionTriggerHandler _mt)\n\n    self.numCollidingVehicles = { }\n    self.vehicleIgnoreList = { }\n\n    self.collisionTriggerByVehicle = { }\n    self.maxUpdateIndex = 1\n\n    self.hasStaticCollision = false\n    self.isBlocked = false\n\n    self.dynamicHitPointDistance = math.huge\n    self.staticHitPointDistance = math.huge\n\n    return self\nend\n\n"})}),"\n",(0,l.jsx)(i.h3,{id:"onvehiclecollisiondistancecallback",children:"onVehicleCollisionDistanceCallback"}),"\n",(0,l.jsx)(i.p,{children:(0,l.jsx)(i.strong,{children:"Description"})}),"\n",(0,l.jsx)(i.p,{children:(0,l.jsx)(i.strong,{children:"Definition"})}),"\n",(0,l.jsxs)(i.blockquote,{children:["\n",(0,l.jsx)(i.p,{children:"onVehicleCollisionDistanceCallback()"}),"\n"]}),"\n",(0,l.jsx)(i.p,{children:(0,l.jsx)(i.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,l.jsxs)(i.table,{children:[(0,l.jsx)(i.thead,{children:(0,l.jsxs)(i.tr,{children:[(0,l.jsx)(i.th,{children:"any"}),(0,l.jsx)(i.th,{children:"distance"})]})}),(0,l.jsxs)(i.tbody,{children:[(0,l.jsxs)(i.tr,{children:[(0,l.jsx)(i.td,{children:"any"}),(0,l.jsx)(i.td,{children:"objectId"})]}),(0,l.jsxs)(i.tr,{children:[(0,l.jsx)(i.td,{children:"any"}),(0,l.jsx)(i.td,{children:"subShapeIndex"})]}),(0,l.jsxs)(i.tr,{children:[(0,l.jsx)(i.td,{children:"any"}),(0,l.jsx)(i.td,{children:"isLast"})]}),(0,l.jsxs)(i.tr,{children:[(0,l.jsx)(i.td,{children:"any"}),(0,l.jsx)(i.td,{children:"trigger"})]})]})]}),"\n",(0,l.jsx)(i.p,{children:(0,l.jsx)(i.strong,{children:"Code"})}),"\n",(0,l.jsx)(i.pre,{children:(0,l.jsx)(i.code,{className:"language-lua",children:"function AICollisionTriggerHandler:onVehicleCollisionDistanceCallback(distance, objectId, subShapeIndex, isLast, trigger)\n    -- check for mission and strategy existence in case we receive the async callback after one of them has been removed(e.g.leaving game)\n        if g_currentMission ~ = nil and self.collisionTriggerByVehicle ~ = nil then\n            -- ignore callbacks that arrive after the vehicle has been deleted\n            for vehicle, _ in pairs( self.collisionTriggerByVehicle) do\n                if vehicle.isDeleted or vehicle.isDeleting then\n                    return false\n                end\n            end\n\n            if objectId ~ = 0 then\n\n                local player = g_currentMission.playerSystem:getPlayerByRootNode(objectId)\n                if player ~ = nil then\n                    trigger.hitCounter = trigger.hitCounter + 1\n                else\n                        local vehicle = g_currentMission.nodeToObject[objectId]\n                        if vehicle = = nil or self.collisionTriggerByVehicle[vehicle] = = nil then\n                            -- exclude all objects that have 'road' in their name -> for wrongly set up mod map roads\n                                if not getHasTrigger(objectId) then --and not getName(objectId):contains(\"road\") then\n                                    if vehicle = = nil or vehicle.getRootVehicle = = nil or vehicle:getRootVehicle() ~ = self.rootVehicle then\n                                        if getRigidBodyType(objectId) ~ = RigidBodyType.DYNAMIC then\n                                            trigger.hitStaticCounter = trigger.hitStaticCounter + 1\n                                        else\n                                                -- we fully ignore other than vehicle dynamic objects(bales, traffic signs, etc.)\n                                                if bit32.band(getCollisionFilterGroup(objectId), CollisionFlag.VEHICLE) ~ = 0 then\n                                                    trigger.hitCounter = trigger.hitCounter + 1\n                                                end\n                                            end\n                                        end\n                                    end\n                                end\n                            end\n                        end\n\n                        -- we store the first hit position and then calculate the distance to this position afterwards\n                        -- this works fine while driving straight to the collision, but is not accorate in curves\n                            -- but it is much cheaper than checking for the real distance to the collision the engine\n\n                                if objectId = = 0 or isLast then\n                                    local hasCollision = trigger.hitCounter > 0\n                                    if hasCollision ~ = trigger.hasCollision then\n                                        trigger.hasCollision = hasCollision\n\n                                        if hasCollision then\n                                            trigger.dynamicHitPointValid = true\n                                            trigger.dynamicHitPoint[ 1 ], trigger.dynamicHitPoint[ 2 ], trigger.dynamicHitPoint[ 3 ] = getWorldTranslation(trigger.node)\n                                            trigger.dynamicHitPointInitialDistance = trigger.vehicle.lastSpeedReal * g_physicsDt * AICollisionTriggerHandler.UPDATE_INTERVAL\n                                        else\n                                                trigger.dynamicHitPointValid = false\n                                                trigger.dynamicHitPointDistance = math.huge\n                                            end\n\n                                            self:updateBlockedCallback()\n                                        end\n\n                                        local hasStaticCollision = trigger.hitStaticCounter > 0\n                                        if hasStaticCollision ~ = trigger.hasStaticCollision then\n                                            trigger.hasStaticCollision = hasStaticCollision\n\n                                            if hasStaticCollision then\n                                                trigger.staticHitPointValid = true\n                                                trigger.staticHitPoint[ 1 ], trigger.staticHitPoint[ 2 ], trigger.staticHitPoint[ 3 ] = getWorldTranslation(trigger.node)\n                                                trigger.staticHitPointInitialDistance = trigger.vehicle.lastSpeedReal * g_physicsDt * AICollisionTriggerHandler.UPDATE_INTERVAL\n                                            else\n                                                    trigger.staticHitPointValid = false\n                                                    trigger.staticHitPointDistance = math.huge\n                                                end\n\n                                                self:updateStaticCollisionCallback()\n                                            end\n\n                                            return false\n                                        else\n                                                return true\n                                            end\n                                        end\n\n                                        return\n                                    end\n\n"})}),"\n",(0,l.jsx)(i.h3,{id:"setcollisiondistancecallback",children:"setCollisionDistanceCallback"}),"\n",(0,l.jsx)(i.p,{children:(0,l.jsx)(i.strong,{children:"Description"})}),"\n",(0,l.jsx)(i.p,{children:(0,l.jsx)(i.strong,{children:"Definition"})}),"\n",(0,l.jsxs)(i.blockquote,{children:["\n",(0,l.jsx)(i.p,{children:"setCollisionDistanceCallback()"}),"\n"]}),"\n",(0,l.jsx)(i.p,{children:(0,l.jsx)(i.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,l.jsx)(i.table,{children:(0,l.jsx)(i.thead,{children:(0,l.jsxs)(i.tr,{children:[(0,l.jsx)(i.th,{children:"any"}),(0,l.jsx)(i.th,{children:"callback"})]})})}),"\n",(0,l.jsx)(i.p,{children:(0,l.jsx)(i.strong,{children:"Code"})}),"\n",(0,l.jsx)(i.pre,{children:(0,l.jsx)(i.code,{className:"language-lua",children:"function AICollisionTriggerHandler:setCollisionDistanceCallback(callback)\n    self.collisionDistanceCallback = callback\nend\n\n"})}),"\n",(0,l.jsx)(i.h3,{id:"setisblockedcallback",children:"setIsBlockedCallback"}),"\n",(0,l.jsx)(i.p,{children:(0,l.jsx)(i.strong,{children:"Description"})}),"\n",(0,l.jsx)(i.p,{children:(0,l.jsx)(i.strong,{children:"Definition"})}),"\n",(0,l.jsxs)(i.blockquote,{children:["\n",(0,l.jsx)(i.p,{children:"setIsBlockedCallback()"}),"\n"]}),"\n",(0,l.jsx)(i.p,{children:(0,l.jsx)(i.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,l.jsx)(i.table,{children:(0,l.jsx)(i.thead,{children:(0,l.jsxs)(i.tr,{children:[(0,l.jsx)(i.th,{children:"any"}),(0,l.jsx)(i.th,{children:"callback"})]})})}),"\n",(0,l.jsx)(i.p,{children:(0,l.jsx)(i.strong,{children:"Code"})}),"\n",(0,l.jsx)(i.pre,{children:(0,l.jsx)(i.code,{className:"language-lua",children:"function AICollisionTriggerHandler:setIsBlockedCallback(callback)\n    self.isBlockedCallback = callback\nend\n\n"})}),"\n",(0,l.jsx)(i.h3,{id:"setstaticcollisioncallback",children:"setStaticCollisionCallback"}),"\n",(0,l.jsx)(i.p,{children:(0,l.jsx)(i.strong,{children:"Description"})}),"\n",(0,l.jsx)(i.p,{children:(0,l.jsx)(i.strong,{children:"Definition"})}),"\n",(0,l.jsxs)(i.blockquote,{children:["\n",(0,l.jsx)(i.p,{children:"setStaticCollisionCallback()"}),"\n"]}),"\n",(0,l.jsx)(i.p,{children:(0,l.jsx)(i.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,l.jsx)(i.table,{children:(0,l.jsx)(i.thead,{children:(0,l.jsxs)(i.tr,{children:[(0,l.jsx)(i.th,{children:"any"}),(0,l.jsx)(i.th,{children:"callback"})]})})}),"\n",(0,l.jsx)(i.p,{children:(0,l.jsx)(i.strong,{children:"Code"})}),"\n",(0,l.jsx)(i.pre,{children:(0,l.jsx)(i.code,{className:"language-lua",children:"function AICollisionTriggerHandler:setStaticCollisionCallback(callback)\n    self.staticCollisionCallback = callback\nend\n\n"})}),"\n",(0,l.jsx)(i.h3,{id:"update",children:"update"}),"\n",(0,l.jsx)(i.p,{children:(0,l.jsx)(i.strong,{children:"Description"})}),"\n",(0,l.jsx)(i.p,{children:(0,l.jsx)(i.strong,{children:"Definition"})}),"\n",(0,l.jsxs)(i.blockquote,{children:["\n",(0,l.jsx)(i.p,{children:"update()"}),"\n"]}),"\n",(0,l.jsx)(i.p,{children:(0,l.jsx)(i.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,l.jsxs)(i.table,{children:[(0,l.jsx)(i.thead,{children:(0,l.jsxs)(i.tr,{children:[(0,l.jsx)(i.th,{children:"any"}),(0,l.jsx)(i.th,{children:"dt"})]})}),(0,l.jsx)(i.tbody,{children:(0,l.jsxs)(i.tr,{children:[(0,l.jsx)(i.td,{children:"any"}),(0,l.jsx)(i.td,{children:"movingDirection"})]})})]}),"\n",(0,l.jsx)(i.p,{children:(0,l.jsx)(i.strong,{children:"Code"})}),"\n",(0,l.jsx)(i.pre,{children:(0,l.jsx)(i.code,{className:"language-lua",children:'function AICollisionTriggerHandler:update(dt, movingDirection)\n    local dynamicHitPointDistance, staticHitPointDistance = math.huge, math.huge\n    local currentIndex = g_updateLoopIndex % self.maxUpdateIndex\n    for v, trigger in pairs( self.collisionTriggerByVehicle) do\n        if trigger.dynamicHitPointValid then\n            local x, y, z = getWorldTranslation(trigger.node)\n            trigger.dynamicHitPointDistance = math.max(trigger.length - MathUtil.vector3Length(trigger.dynamicHitPoint[ 1 ] - x, trigger.dynamicHitPoint[ 2 ] - y, trigger.dynamicHitPoint[ 3 ] - z) - trigger.dynamicHitPointInitialDistance, 0 )\n        end\n\n        if trigger.staticHitPointValid then\n            local x, y, z = getWorldTranslation(trigger.node)\n            trigger.staticHitPointDistance = math.max(trigger.length - MathUtil.vector3Length(trigger.staticHitPoint[ 1 ] - x, trigger.staticHitPoint[ 2 ] - y, trigger.staticHitPoint[ 3 ] - z) - trigger.staticHitPointInitialDistance, 0 )\n        end\n\n        dynamicHitPointDistance = math.min(trigger.dynamicHitPointDistance, dynamicHitPointDistance)\n        staticHitPointDistance = math.min(trigger.staticHitPointDistance, staticHitPointDistance)\n\n        if trigger.updateIndex = = currentIndex then\n            self:generateTriggerPath(v, trigger, movingDirection)\n\n            if trigger.isValid then\n                trigger.hitCounter = 0\n                trigger.hitStaticCounter = 0\n                local dx, dy, dz = localDirectionToWorld(trigger.node, 0 , 0 , trigger.curTriggerDirection)\n                getVehicleCollisionDistance(trigger.positions, dx, dy, dz, trigger.width, trigger.height, "onVehicleCollisionDistanceCallback" , self , trigger, AICollisionTriggerHandler.COLLISION_MASK, true , true , true , true )\n            end\n        end\n    end\n\n    self.dynamicHitPointDistance = dynamicHitPointDistance\n    self.staticHitPointDistance = staticHitPointDistance\n\n    if self.collisionDistanceCallback ~ = nil then\n        self.collisionDistanceCallback( math.min( self.dynamicHitPointDistance, self.staticHitPointDistance))\n    end\n\n    if VehicleDebug.state = = VehicleDebug.DEBUG_AI then\n        for v, trigger in pairs( self.collisionTriggerByVehicle) do\n            self:generateTriggerPath(v, trigger, movingDirection)\n\n            if trigger.isValid then\n                for i = 1 , #trigger.positions - 3 , 3 do\n                    drawDebugLine(trigger.positions[i + 0 ], trigger.positions[i + 1 ] + 2 , trigger.positions[i + 2 ], 1 , 0 , 0 , trigger.positions[i + 3 ], trigger.positions[i + 4 ] + 2 , trigger.positions[i + 5 ], 0 , 1 , 0 , true )\n                end\n\n                local dx, dy, dz = localDirectionToWorld(trigger.node, 0 , 0 , 1 )\n                debugDrawVehicleCollision(trigger.positions, dx, dy, dz, trigger.width, trigger.height)\n            end\n        end\n    end\nend\n\n'})}),"\n",(0,l.jsx)(i.h3,{id:"updateblockedcallback",children:"updateBlockedCallback"}),"\n",(0,l.jsx)(i.p,{children:(0,l.jsx)(i.strong,{children:"Description"})}),"\n",(0,l.jsx)(i.p,{children:(0,l.jsx)(i.strong,{children:"Definition"})}),"\n",(0,l.jsxs)(i.blockquote,{children:["\n",(0,l.jsx)(i.p,{children:"updateBlockedCallback()"}),"\n"]}),"\n",(0,l.jsx)(i.p,{children:(0,l.jsx)(i.strong,{children:"Code"})}),"\n",(0,l.jsx)(i.pre,{children:(0,l.jsx)(i.code,{className:"language-lua",children:"function AICollisionTriggerHandler:updateBlockedCallback()\n    local isBlocked = false\n    for v, trigger in pairs( self.collisionTriggerByVehicle) do\n        if trigger.hasCollision then\n            isBlocked = true\n            break\n        end\n    end\n\n    if isBlocked ~ = self.isBlocked then\n        self.isBlocked = isBlocked\n\n        if self.isBlockedCallback ~ = nil then\n            self.isBlockedCallback(isBlocked)\n        end\n    end\nend\n\n"})}),"\n",(0,l.jsx)(i.h3,{id:"updatestaticcollisioncallback",children:"updateStaticCollisionCallback"}),"\n",(0,l.jsx)(i.p,{children:(0,l.jsx)(i.strong,{children:"Description"})}),"\n",(0,l.jsx)(i.p,{children:(0,l.jsx)(i.strong,{children:"Definition"})}),"\n",(0,l.jsxs)(i.blockquote,{children:["\n",(0,l.jsx)(i.p,{children:"updateStaticCollisionCallback()"}),"\n"]}),"\n",(0,l.jsx)(i.p,{children:(0,l.jsx)(i.strong,{children:"Code"})}),"\n",(0,l.jsx)(i.pre,{children:(0,l.jsx)(i.code,{className:"language-lua",children:"function AICollisionTriggerHandler:updateStaticCollisionCallback()\n    local hasStaticCollision = false\n    for v, trigger in pairs( self.collisionTriggerByVehicle) do\n        if trigger.hasStaticCollision then\n            hasStaticCollision = true\n            break\n        end\n    end\n\n    if hasStaticCollision ~ = self.hasStaticCollision then\n        self.hasStaticCollision = hasStaticCollision\n\n        if self.staticCollisionCallback ~ = nil then\n            self.staticCollisionCallback(hasStaticCollision)\n        end\n    end\nend\n\n"})})]})}function g(n={}){const{wrapper:i}={...(0,r.R)(),...n.components};return i?(0,l.jsx)(i,{...n,children:(0,l.jsx)(d,{...n})}):d(n)}},28453(n,i,e){e.d(i,{R:()=>s,x:()=>c});var t=e(96540);const l={},r=t.createContext(l);function s(n){const i=t.useContext(r);return t.useMemo(function(){return"function"==typeof n?n(i):{...i,...n}},[i,n])}function c(n){let i;return i=n.disableParentContext?"function"==typeof n.components?n.components(l):n.components||l:s(n.components),t.createElement(r.Provider,{value:i},n.children)}}}]);