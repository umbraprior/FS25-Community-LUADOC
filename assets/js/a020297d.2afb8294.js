"use strict";(globalThis.webpackChunkfs25_community_luadoc=globalThis.webpackChunkfs25_community_luadoc||[]).push([[68236],{28453(e,n,t){t.d(n,{R:()=>a,x:()=>s});var r=t(96540);const l={},i=r.createContext(l);function a(e){const n=r.useContext(i);return r.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function s(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(l):e.components||l:a(e.components),r.createElement(i.Provider,{value:n},e.children)}},83262(e,n,t){t.r(n),t.d(n,{assets:()=>d,contentTitle:()=>s,default:()=>h,frontMatter:()=>a,metadata:()=>r,toc:()=>o});const r=JSON.parse('{"id":"script/Misc/TreePlantManager","title":"TreePlantManager","description":"TreePlantManager","source":"@site/../docs/script/Misc/TreePlantManager.md","sourceDirName":"script/Misc","slug":"/script/Misc/TreePlantManager","permalink":"/FS25-Community-LUADOC/script/Misc/TreePlantManager","draft":false,"unlisted":false,"tags":[],"version":"current","lastUpdatedAt":1767161192000,"frontMatter":{},"sidebar":"docsSidebar","previous":{"title":"ToolTypeManager","permalink":"/FS25-Community-LUADOC/script/Misc/ToolTypeManager"},"next":{"title":"AbstractMission","permalink":"/FS25-Community-LUADOC/script/Missions/AbstractMission"}}');var l=t(74848),i=t(28453);const a={},s=void 0,d={},o=[{value:"TreePlantManager",id:"treeplantmanager",level:2},{value:"addClientTree",id:"addclienttree",level:3},{value:"addingSplitShape",id:"addingsplitshape",level:3},{value:"addTreeCutJoint",id:"addtreecutjoint",level:3},{value:"canPlantTree",id:"canplanttree",level:3},{value:"cleanupDeletedTrees",id:"cleanupdeletedtrees",level:3},{value:"consoleCommandCutTrees",id:"consolecommandcuttrees",level:3},{value:"consoleCommandLoadAll",id:"consolecommandloadall",level:3},{value:"consoleCommandPlantTrees",id:"consolecommandplanttrees",level:3},{value:"cutTreeTrunkCallback",id:"cuttreetrunkcallback",level:3},{value:"deleteTreesData",id:"deletetreesdata",level:3},{value:"getClientTree",id:"getclienttree",level:3},{value:"getIsTreeDeleted",id:"getistreedeleted",level:3},{value:"getPalletStoreItemFilenameByIndex",id:"getpalletstoreitemfilenamebyindex",level:3},{value:"getTreeRigidBodyType",id:"gettreerigidbodytype",level:3},{value:"getTreeTypeDescFromIndex",id:"gettreetypedescfromindex",level:3},{value:"getTreeTypeDescFromName",id:"gettreetypedescfromname",level:3},{value:"getTreeTypeDescFromSplitType",id:"gettreetypedescfromsplittype",level:3},{value:"getTreeTypeFilename",id:"gettreetypefilename",level:3},{value:"getTreeTypeIndexAndVariationFromName",id:"gettreetypeindexandvariationfromname",level:3},{value:"getTreeTypeIndexFromName",id:"gettreetypeindexfromname",level:3},{value:"getTreeTypeNameAndVariationByIndex",id:"gettreetypenameandvariationbyindex",level:3},{value:"getTreeTypeNameFromIndex",id:"gettreetypenamefromindex",level:3},{value:"initDataStructures",id:"initdatastructures",level:3},{value:"initialize",id:"initialize",level:3},{value:"loadDefaultTypes",id:"loaddefaulttypes",level:3},{value:"loadFromXMLFile",id:"loadfromxmlfile",level:3},{value:"loadMapData",id:"loadmapdata",level:3},{value:"loadTreeNode",id:"loadtreenode",level:3},{value:"loadTreeTrunk",id:"loadtreetrunk",level:3},{value:"loadTreeTypes",id:"loadtreetypes",level:3},{value:"new",id:"new",level:3},{value:"onTreeCutCommandOverlapCallback",id:"ontreecutcommandoverlapcallback",level:3},{value:"onTreeCutCommandSplitCallback",id:"ontreecutcommandsplitcallback",level:3},{value:"plantTree",id:"planttree",level:3},{value:"readFromServerStream",id:"readfromserverstream",level:3},{value:"registerTreeType",id:"registertreetype",level:3},{value:"removeClientTree",id:"removeclienttree",level:3},{value:"removingSplitShape",id:"removingsplitshape",level:3},{value:"saveToXMLFile",id:"savetoxmlfile",level:3},{value:"setSplitShapeLeafScaleAndVariation",id:"setsplitshapeleafscaleandvariation",level:3},{value:"unloadMapData",id:"unloadmapdata",level:3},{value:"updateTrees",id:"updatetrees",level:3},{value:"writeToClientStream",id:"writetoclientstream",level:3}];function c(e){const n={a:"a",blockquote:"blockquote",code:"code",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,i.R)(),...e.components};return(0,l.jsxs)(l.Fragment,{children:[(0,l.jsx)(n.h2,{id:"treeplantmanager",children:"TreePlantManager"}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Parent"})}),"\n",(0,l.jsxs)(n.blockquote,{children:["\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.a,{href:"?version=script&category=58&class=565",children:"AbstractManager"})}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Functions"})}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsx)(n.li,{children:(0,l.jsx)(n.a,{href:"#addclienttree",children:"addClientTree"})}),"\n",(0,l.jsx)(n.li,{children:(0,l.jsx)(n.a,{href:"#addingsplitshape",children:"addingSplitShape"})}),"\n",(0,l.jsx)(n.li,{children:(0,l.jsx)(n.a,{href:"#addtreecutjoint",children:"addTreeCutJoint"})}),"\n",(0,l.jsx)(n.li,{children:(0,l.jsx)(n.a,{href:"#canplanttree",children:"canPlantTree"})}),"\n",(0,l.jsx)(n.li,{children:(0,l.jsx)(n.a,{href:"#cleanupdeletedtrees",children:"cleanupDeletedTrees"})}),"\n",(0,l.jsx)(n.li,{children:(0,l.jsx)(n.a,{href:"#consolecommandcuttrees",children:"consoleCommandCutTrees"})}),"\n",(0,l.jsx)(n.li,{children:(0,l.jsx)(n.a,{href:"#consolecommandloadall",children:"consoleCommandLoadAll"})}),"\n",(0,l.jsx)(n.li,{children:(0,l.jsx)(n.a,{href:"#consolecommandplanttrees",children:"consoleCommandPlantTrees"})}),"\n",(0,l.jsx)(n.li,{children:(0,l.jsx)(n.a,{href:"#cuttreetrunkcallback",children:"cutTreeTrunkCallback"})}),"\n",(0,l.jsx)(n.li,{children:(0,l.jsx)(n.a,{href:"#deletetreesdata",children:"deleteTreesData"})}),"\n",(0,l.jsx)(n.li,{children:(0,l.jsx)(n.a,{href:"#getclienttree",children:"getClientTree"})}),"\n",(0,l.jsx)(n.li,{children:(0,l.jsx)(n.a,{href:"#getistreedeleted",children:"getIsTreeDeleted"})}),"\n",(0,l.jsx)(n.li,{children:(0,l.jsx)(n.a,{href:"#getpalletstoreitemfilenamebyindex",children:"getPalletStoreItemFilenameByIndex"})}),"\n",(0,l.jsx)(n.li,{children:(0,l.jsx)(n.a,{href:"#gettreerigidbodytype",children:"getTreeRigidBodyType"})}),"\n",(0,l.jsx)(n.li,{children:(0,l.jsx)(n.a,{href:"#gettreetypedescfromindex",children:"getTreeTypeDescFromIndex"})}),"\n",(0,l.jsx)(n.li,{children:(0,l.jsx)(n.a,{href:"#gettreetypedescfromname",children:"getTreeTypeDescFromName"})}),"\n",(0,l.jsx)(n.li,{children:(0,l.jsx)(n.a,{href:"#gettreetypedescfromsplittype",children:"getTreeTypeDescFromSplitType"})}),"\n",(0,l.jsx)(n.li,{children:(0,l.jsx)(n.a,{href:"#gettreetypefilename",children:"getTreeTypeFilename"})}),"\n",(0,l.jsx)(n.li,{children:(0,l.jsx)(n.a,{href:"#gettreetypeindexandvariationfromname",children:"getTreeTypeIndexAndVariationFromName"})}),"\n",(0,l.jsx)(n.li,{children:(0,l.jsx)(n.a,{href:"#gettreetypeindexfromname",children:"getTreeTypeIndexFromName"})}),"\n",(0,l.jsx)(n.li,{children:(0,l.jsx)(n.a,{href:"#gettreetypenameandvariationbyindex",children:"getTreeTypeNameAndVariationByIndex"})}),"\n",(0,l.jsx)(n.li,{children:(0,l.jsx)(n.a,{href:"#gettreetypenamefromindex",children:"getTreeTypeNameFromIndex"})}),"\n",(0,l.jsx)(n.li,{children:(0,l.jsx)(n.a,{href:"#initdatastructures",children:"initDataStructures"})}),"\n",(0,l.jsx)(n.li,{children:(0,l.jsx)(n.a,{href:"#initialize",children:"initialize"})}),"\n",(0,l.jsx)(n.li,{children:(0,l.jsx)(n.a,{href:"#loaddefaulttypes",children:"loadDefaultTypes"})}),"\n",(0,l.jsx)(n.li,{children:(0,l.jsx)(n.a,{href:"#loadfromxmlfile",children:"loadFromXMLFile"})}),"\n",(0,l.jsx)(n.li,{children:(0,l.jsx)(n.a,{href:"#loadmapdata",children:"loadMapData"})}),"\n",(0,l.jsx)(n.li,{children:(0,l.jsx)(n.a,{href:"#loadtreenode",children:"loadTreeNode"})}),"\n",(0,l.jsx)(n.li,{children:(0,l.jsx)(n.a,{href:"#loadtreetrunk",children:"loadTreeTrunk"})}),"\n",(0,l.jsx)(n.li,{children:(0,l.jsx)(n.a,{href:"#loadtreetypes",children:"loadTreeTypes"})}),"\n",(0,l.jsx)(n.li,{children:(0,l.jsx)(n.a,{href:"#new",children:"new"})}),"\n",(0,l.jsx)(n.li,{children:(0,l.jsx)(n.a,{href:"#ontreecutcommandoverlapcallback",children:"onTreeCutCommandOverlapCallback"})}),"\n",(0,l.jsx)(n.li,{children:(0,l.jsx)(n.a,{href:"#ontreecutcommandsplitcallback",children:"onTreeCutCommandSplitCallback"})}),"\n",(0,l.jsx)(n.li,{children:(0,l.jsx)(n.a,{href:"#planttree",children:"plantTree"})}),"\n",(0,l.jsx)(n.li,{children:(0,l.jsx)(n.a,{href:"#readfromserverstream",children:"readFromServerStream"})}),"\n",(0,l.jsx)(n.li,{children:(0,l.jsx)(n.a,{href:"#registertreetype",children:"registerTreeType"})}),"\n",(0,l.jsx)(n.li,{children:(0,l.jsx)(n.a,{href:"#removeclienttree",children:"removeClientTree"})}),"\n",(0,l.jsx)(n.li,{children:(0,l.jsx)(n.a,{href:"#removingsplitshape",children:"removingSplitShape"})}),"\n",(0,l.jsx)(n.li,{children:(0,l.jsx)(n.a,{href:"#savetoxmlfile",children:"saveToXMLFile"})}),"\n",(0,l.jsx)(n.li,{children:(0,l.jsx)(n.a,{href:"#setsplitshapeleafscaleandvariation",children:"setSplitShapeLeafScaleAndVariation"})}),"\n",(0,l.jsx)(n.li,{children:(0,l.jsx)(n.a,{href:"#unloadmapdata",children:"unloadMapData"})}),"\n",(0,l.jsx)(n.li,{children:(0,l.jsx)(n.a,{href:"#updatetrees",children:"updateTrees"})}),"\n",(0,l.jsx)(n.li,{children:(0,l.jsx)(n.a,{href:"#writetoclientstream",children:"writeToClientStream"})}),"\n"]}),"\n",(0,l.jsx)(n.h3,{id:"addclienttree",children:"addClientTree"}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Description"})}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Definition"})}),"\n",(0,l.jsxs)(n.blockquote,{children:["\n",(0,l.jsx)(n.p,{children:"addClientTree()"}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,l.jsxs)(n.table,{children:[(0,l.jsx)(n.thead,{children:(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.th,{children:"any"}),(0,l.jsx)(n.th,{children:"serverSplitShapeFileId"})]})}),(0,l.jsx)(n.tbody,{children:(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{children:"any"}),(0,l.jsx)(n.td,{children:"nodeId"})]})})]}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Code"})}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-lua",children:"function TreePlantManager:addClientTree(serverSplitShapeFileId, nodeId)\n    if self.treesData ~ = nil then\n        self.treesData.clientTrees[serverSplitShapeFileId] = nodeId\n    end\nend\n\n"})}),"\n",(0,l.jsx)(n.h3,{id:"addingsplitshape",children:"addingSplitShape"}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Description"})}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Definition"})}),"\n",(0,l.jsxs)(n.blockquote,{children:["\n",(0,l.jsx)(n.p,{children:"addingSplitShape()"}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,l.jsxs)(n.table,{children:[(0,l.jsx)(n.thead,{children:(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.th,{children:"any"}),(0,l.jsx)(n.th,{children:"shape"})]})}),(0,l.jsxs)(n.tbody,{children:[(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{children:"any"}),(0,l.jsx)(n.td,{children:"oldShape"})]}),(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{children:"any"}),(0,l.jsx)(n.td,{children:"fromTree"})]})]})]}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Code"})}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-lua",children:"function TreePlantManager:addingSplitShape(shape, oldShape, fromTree)\n    local state\n    local variation\n\n    -- If a parent is provided, copy the info if we still actively update\n        if oldShape ~ = nil and self.activeDecayingSplitShapes[oldShape] ~ = nil then\n            state = self.activeDecayingSplitShapes[oldShape].state\n            variation = self.activeDecayingSplitShapes[oldShape].variation\n        elseif fromTree then\n                state = 1\n                local x, y, z = getWorldTranslation(shape)\n                variation = math.abs(x) + math.abs(y) + math.abs(z)\n            else\n                    state = 0\n                    variation = 80\n                end\n\n                -- With no children, the shape has no branches and we need to update nothing\n                -- And as cuts from this item cannot have branches either, we do not need to store\n                    -- it for parent state either.\n                        if state ~ = nil and getNumOfChildren(shape) > 0 then\n                            self.activeDecayingSplitShapes[shape] = { state = state, variation = variation }\n\n                            self:setSplitShapeLeafScaleAndVariation(shape, state, variation)\n                        end\n\n                        g_messageCenter:publish(MessageType.TREE_SHAPE_CUT, oldShape, shape)\n                    end\n\n"})}),"\n",(0,l.jsx)(n.h3,{id:"addtreecutjoint",children:"addTreeCutJoint"}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Description"})}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Definition"})}),"\n",(0,l.jsxs)(n.blockquote,{children:["\n",(0,l.jsx)(n.p,{children:"addTreeCutJoint()"}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,l.jsxs)(n.table,{children:[(0,l.jsx)(n.thead,{children:(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.th,{children:"any"}),(0,l.jsx)(n.th,{children:"jointIndex"})]})}),(0,l.jsxs)(n.tbody,{children:[(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{children:"any"}),(0,l.jsx)(n.td,{children:"shape"})]}),(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{children:"any"}),(0,l.jsx)(n.td,{children:"nx"})]}),(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{children:"any"}),(0,l.jsx)(n.td,{children:"ny"})]}),(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{children:"any"}),(0,l.jsx)(n.td,{children:"nz"})]}),(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{children:"any"}),(0,l.jsx)(n.td,{children:"maxAngle"})]}),(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{children:"any"}),(0,l.jsx)(n.td,{children:"maxLifetime"})]})]})]}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Code"})}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-lua",children:"function TreePlantManager:addTreeCutJoint(jointIndex, shape, nx,ny,nz, maxAngle, maxLifetime)\n    local treesData = self.treesData\n    local lnx,lny,lnz = worldDirectionToLocal(shape, nx,ny,nz)\n    local joint = { jointIndex = jointIndex, shape = shape, nx = nx,ny = ny,nz = nz, lnx = lnx,lny = lny,lnz = lnz, maxCosAngle = math.cos(maxAngle), destroyTime = g_currentMission.time + maxLifetime }\n    treesData.treeCutJoints[joint] = joint\nend\n\n"})}),"\n",(0,l.jsx)(n.h3,{id:"canplanttree",children:"canPlantTree"}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Description"})}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Definition"})}),"\n",(0,l.jsxs)(n.blockquote,{children:["\n",(0,l.jsx)(n.p,{children:"canPlantTree()"}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Code"})}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-lua",children:"function TreePlantManager:canPlantTree()\n    local totalNumSplit, numSplit = getNumOfSplitShapes()\n    local numUnsplit = totalNumSplit - numSplit\n    return(numUnsplit + self.numTreesWithoutSplits) < self.maxNumTrees\nend\n\n"})}),"\n",(0,l.jsx)(n.h3,{id:"cleanupdeletedtrees",children:"cleanupDeletedTrees"}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Description"})}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Definition"})}),"\n",(0,l.jsxs)(n.blockquote,{children:["\n",(0,l.jsx)(n.p,{children:"cleanupDeletedTrees()"}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Code"})}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-lua",children:"function TreePlantManager:cleanupDeletedTrees()\n    local treesData = self.treesData\n\n    local numGrowingTrees = #treesData.growingTrees\n    local growingTreeIndex = 1\n    while growingTreeIndex < = numGrowingTrees do\n        local tree = treesData.growingTrees[growingTreeIndex]\n        -- Check if the tree has been cut in the mean time\n            if self:getIsTreeDeleted(tree.node) then\n                -- The tree has been removed completely, remove from list\n                table.remove(treesData.growingTrees, growingTreeIndex)\n                numGrowingTrees = numGrowingTrees - 1\n                delete(tree.node)\n\n                if not tree.hasSplitShapes then\n                    self.numTreesWithoutSplits = math.max( self.numTreesWithoutSplits - 1 , 0 )\n                    treesData.numTreesWithoutSplits = math.max(treesData.numTreesWithoutSplits - 1 , 0 )\n                end\n            else\n                    growingTreeIndex = growingTreeIndex + 1\n                end\n            end\n\n            local numSplitTrees = #treesData.splitTrees\n            local splitTreeIndex = 1\n            while splitTreeIndex < = numSplitTrees do\n                local tree = treesData.splitTrees[splitTreeIndex]\n                -- Check if the tree has been cut in the mean time\n                    if self:getIsTreeDeleted(tree.node) then\n                        -- The tree has been removed completely, remove from list\n                        table.remove(treesData.splitTrees, splitTreeIndex)\n                        numSplitTrees = numSplitTrees - 1\n                        delete(tree.node)\n\n                        if not tree.hasSplitShapes then\n                            self.numTreesWithoutSplits = math.max( self.numTreesWithoutSplits - 1 , 0 )\n                            treesData.numTreesWithoutSplits = math.max(treesData.numTreesWithoutSplits - 1 , 0 )\n                        end\n                    else\n                            splitTreeIndex = splitTreeIndex + 1\n                        end\n                    end\n                end\n\n"})}),"\n",(0,l.jsx)(n.h3,{id:"consolecommandcuttrees",children:"consoleCommandCutTrees"}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Description"})}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Definition"})}),"\n",(0,l.jsxs)(n.blockquote,{children:["\n",(0,l.jsx)(n.p,{children:"consoleCommandCutTrees(string|number radius)"}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n",(0,l.jsx)(n.table,{children:(0,l.jsx)(n.thead,{children:(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.th,{children:"string"}),(0,l.jsx)(n.th,{children:"number"}),(0,l.jsx)(n.th,{children:"radius"})]})})}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Return Values"})}),"\n\n\n\n\n\n\n\n\n",(0,l.jsx)(n.table,{children:(0,l.jsx)(n.thead,{children:(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.th,{children:"string"}),(0,l.jsx)(n.th,{children:"number"}),(0,l.jsx)(n.th,{children:"feedback"})]})})}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Code"})}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-lua",children:'function TreePlantManager:consoleCommandCutTrees(radius)\n    radius = tonumber(radius) or 50\n\n    self.commandCutTreeData = { }\n    self.commandCutTreeData.trees = { }\n\n    local x, y, z = getWorldTranslation(g_cameraManager:getActiveCamera())\n    overlapSphere(x, y, z, radius, "onTreeCutCommandOverlapCallback" , self , CollisionFlag.TREE, false , false , true , false )\n\n    return string.format( "Found %d trees to cut in a %dm radius" , # self.commandCutTreeData.trees, radius)\nend\n\n'})}),"\n",(0,l.jsx)(n.h3,{id:"consolecommandloadall",children:"consoleCommandLoadAll"}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Description"})}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Definition"})}),"\n",(0,l.jsxs)(n.blockquote,{children:["\n",(0,l.jsx)(n.p,{children:"consoleCommandLoadAll()"}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,l.jsxs)(n.table,{children:[(0,l.jsx)(n.thead,{children:(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.th,{children:"any"}),(0,l.jsx)(n.th,{children:"treeTypeName"})]})}),(0,l.jsxs)(n.tbody,{children:[(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{children:"any"}),(0,l.jsx)(n.td,{children:"number"})]}),(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{children:"any"}),(0,l.jsx)(n.td,{children:"growthStateI"})]}),(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{children:"any"}),(0,l.jsx)(n.td,{children:"variationIndex"})]}),(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{children:"any"}),(0,l.jsx)(n.td,{children:"isGrowing"})]})]})]}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Code"})}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-lua",children:'function TreePlantManager:consoleCommandLoadAll(treeTypeName, number, growthStateI, variationIndex, isGrowing)\n    g_debugManager:removeGroup( "treeLoadAll" )\n\n    local x, _, z = g_localPlayer:getPosition()\n    local dirX, dirZ = g_localPlayer:getCurrentFacingDirection()\n    local yRot = MathUtil.getYRotationFromDirection( - dirX, - dirZ)\n\n    x, z = x + dirX * 5 , z + dirZ * 5\n    local xOffset = 10\n    local zOffset = 10\n\n    local numPlantedTrees = 0\n    for index, treeType in ipairs( self.treeTypes) do\n        local tx, tz = x + dirZ * index * xOffset, z - dirX * index * xOffset\n\n        for stageIndex, stage in ipairs(treeType.stages) do\n            for variationIndex, variation in ipairs(stage) do\n                local ty = getTerrainHeightAtWorldPos(g_terrainNode, tx, 0 , tz)\n\n                local treeId = self:plantTree(treeType.index, tx, ty, tz, 0 , math.random() * math.pi, 0 , stageIndex, variationIndex, false )\n                if treeId ~ = nil and treeId ~ = 0 then\n                    local splitShapeId = getChildAt(getChildAt(treeId, 0 ), 0 )\n\n                    local splitTypeIndex = - 1\n                    local splitTypeName = "<NO_SPLIT_TYPE>"\n                    local allowWoodHarvester = false\n                    local sizeX, sizeY, sizeZ, numConvexes, numAttachments\n                    if splitShapeId ~ = 0 and getHasClassId(splitShapeId, ClassIds.MESH_SPLIT_SHAPE) then\n                        splitTypeIndex = getSplitType(splitShapeId)\n                        splitTypeName = g_splitShapeManager:getSplitTypeNameByIndex(splitTypeIndex)\n                        allowWoodHarvester = g_splitShapeManager:getSplitShapeAllowsHarvester(splitShapeId)\n                        sizeX, sizeY, sizeZ, numConvexes, numAttachments = getSplitShapeStats(splitShapeId)\n\n                        local boundingBox = getSplitShapeOrientedBoundingBox(splitShapeId)\n                        local dir0X, dir0Y, dir0Z, dir1X, dir1Y, dir1Z, _, _, _, centerX, centerY, centerZ, extent0, extent1, extent2 = unpack(boundingBox)\n\n                        local sx, sy, sz = localToWorld(splitShapeId, centerX, 0 , centerZ)\n                        dir1X, dir1Y, dir1Z = localDirectionToWorld(splitShapeId, dir1X, dir1Y, dir1Z)\n                        dir0X, dir0Y, dir0Z = localDirectionToWorld(splitShapeId, dir0X, dir0Y, dir0Z)\n                        local debugPlane = DebugPlane.new():createFromPosAndDir(sx, sy, sz, dir1X, dir1Y, dir1Z, dir0X, dir0Y, dir0Z, extent2 * 2 , extent1 * 2 )\n                        debugPlane.color = allowWoodHarvester and Color.PRESETS.GREEN or Color.PRESETS.RED\n                        g_debugManager:addElement(debugPlane, "treeLoadAll" )\n\n                        local debugText = DebugText3D.new():createWithWorldPos(sx - dirX * 0.75 , sy + 0.1 , sz - dirZ * 0.75 , 0 , yRot, 0 , string.format( "Area: %.1fm\xb2" , sizeY * sizeZ), 0.07 )\n                        debugText.color = debugPlane.color\n                        g_debugManager:addElement(debugText, "treeLoadAll" )\n\n                        local rCenterX, rCenterY, rCenterZ, _, _, _, radius = SplitShapeUtil.getTreeOffsetPosition(splitShapeId, tx, ty + 0.5 , tz, 20 , 0 )\n                        if rCenterX ~ = nil then\n                            local color = radius < = 0.601 and(radius < = 0.351 and Color.PRESETS.GREEN or Color.PRESETS.ORANGE) or Color.PRESETS.RED\n                            local debugCircleRadius1 = DebugCircle.new():createWithWorldPos(rCenterX, rCenterY, rCenterZ, radius, color, 20 , false , false , false , false )\n                            g_debugManager:addElement(debugCircleRadius1, "treeLoadAll" )\n\n                            local debugTextRadius1 = DebugText3D.new():createWithWorldPos(rCenterX - dirX * radius * 1.2 , rCenterY, rCenterZ - dirZ * radius * 1.2 , 0 , yRot, 0 , string.format( "Diameter: %.1fcm" , radius * 200 ), 0.05 )\n                            debugTextRadius1.color = color\n                            g_debugManager:addElement(debugTextRadius1, "treeLoadAll" )\n                        end\n\n                        rCenterX, rCenterY, rCenterZ, _, _, _, radius = SplitShapeUtil.getTreeOffsetPosition(splitShapeId, tx, ty + 1 , tz, 20 , 0 )\n                        if rCenterX ~ = nil then\n                            local color = radius < = 0.601 and(radius < = 0.351 and Color.PRESETS.GREEN or Color.PRESETS.ORANGE) or Color.PRESETS.RED\n                            local debugCircleRadius2 = DebugCircle.new():createWithWorldPos(rCenterX, rCenterY, rCenterZ, radius, color, 20 , false , false , false , false )\n                            g_debugManager:addElement(debugCircleRadius2, "treeLoadAll" )\n\n                            local debugTextRadius2 = DebugText3D.new():createWithWorldPos(rCenterX - dirX * radius * 1.2 , rCenterY, rCenterZ - dirZ * radius * 1.2 , 0 , yRot, 0 , string.format( "Diameter: %.1fcm" , radius * 200 ), 0.05 )\n                            debugTextRadius2.color = color\n                            g_debugManager:addElement(debugTextRadius2, "treeLoadAll" )\n                        end\n                    end\n\n                    local splitShapeDescStr = ""\n                    if sizeX ~ = nil then\n                        splitShapeDescStr = string.format( "\\nSplit Shape Size:Height: %.2f | Width: %.2f | Length: %.2f | Area: %.2f m\xb2 | convexes: %d | attachments: %d" , sizeX, sizeY, sizeZ, sizeY * sizeZ, numConvexes, numAttachments)\n                    end\n\n                    local debugText = DebugText3D.new():createWithWorldPos(tx - dirX, ty + 0.5 , tz - dirZ, 0 , yRot, 0 , string.format( "%s: %s\\nsplitType: %s / %s%s%s" , treeType.name, Utils.getFilenameInfo(variation.filename, true ), splitTypeIndex, splitTypeName, splitShapeDescStr, allowWoodHarvester and "\\n\\nSupports Wood Harvester" or "" ), 0.07 )\n                    if allowWoodHarvester then\n                        debugText:setColor( Color.PRESETS.GREEN)\n                    end\n                    g_debugManager:addElement(debugText, "treeLoadAll" )\n\n                    self:loadTreeTrunk(treeType, tx + dirZ * 2 , ty, tz - dirX * 2 , dirX, 0 , dirZ, 0.25 , stageIndex, variationIndex, true , true )\n\n                    numPlantedTrees = numPlantedTrees + 1\n\n                    tx, tz = tx + dirX * zOffset, tz + dirZ * zOffset\n                end\n            end\n        end\n    end\n\n    return string.format( "Planted %d trees" , numPlantedTrees)\nend\n\n'})}),"\n",(0,l.jsx)(n.h3,{id:"consolecommandplanttrees",children:"consoleCommandPlantTrees"}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Description"})}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Definition"})}),"\n",(0,l.jsxs)(n.blockquote,{children:["\n",(0,l.jsx)(n.p,{children:"consoleCommandPlantTrees()"}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,l.jsxs)(n.table,{children:[(0,l.jsx)(n.thead,{children:(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.th,{children:"any"}),(0,l.jsx)(n.th,{children:"treeTypeName"})]})}),(0,l.jsxs)(n.tbody,{children:[(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{children:"any"}),(0,l.jsx)(n.td,{children:"number"})]}),(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{children:"any"}),(0,l.jsx)(n.td,{children:"growthStateI"})]}),(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{children:"any"}),(0,l.jsx)(n.td,{children:"variationIndex"})]}),(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{children:"any"}),(0,l.jsx)(n.td,{children:"isGrowing"})]})]})]}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Code"})}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-lua",children:'function TreePlantManager:consoleCommandPlantTrees(treeTypeName, number, growthStateI, variationIndex, isGrowing)\n    local usage = "Usage:gsTreePlant treeType number growthState variationIndex isGrowing"\n\n    local treeType = self:getTreeTypeDescFromName(treeTypeName)\n    if treeTypeName ~ = nil and treeType = = nil then\n        printError( string.format( "Error:unknown tree type %q" , treeTypeName))\n        print( "Available types:\\n" .. table.concatKeys(g_treePlantManager.nameToTreeType, ", " ))\n        return usage\n    end\n\n    treeType = treeType or self:getTreeTypeDescFromName( "lodgepolePine" ) or self:getTreeTypeDescFromName( "aspen" ) or self.treeTypes[ 1 ]\n\n    number = tonumber(number) or 1\n    growthStateI = tonumber(growthStateI) or #treeType.stages -- max growth by default\n    growthStateI = math.clamp(growthStateI, 1 , #treeType.stages) -- clamp user input to valid range\n    variationIndex = tonumber(variationIndex) or math.random( 1 , #treeType.stages[growthStateI])\n    variationIndex = math.clamp(variationIndex, 1 , #treeType.stages[growthStateI])\n    isGrowing = Utils.stringToBoolean(isGrowing)\n\n    local x, y, z = g_localPlayer:getPosition()\n    local dirX, dirZ = g_localPlayer:getCurrentFacingDirection()\n\n    x,z = x + dirX * 5 , z + dirZ * 5\n\n    -- TODO:async\n    local numPlantedTrees = 0\n    for i = 0 , number - 1 do\n        local tx, tz = x + dirX * i * 5 , z + dirZ * i * 5\n        local ty = getTerrainHeightAtWorldPos(g_terrainNode, tx, y, tz)\n        local ry = math.random() * 2 * math.pi\n\n        self.plantTreeCommandHasCollision = false\n        overlapBox(tx,ty,tz, 0 , 0 , 0 , 0.5 , 1 , 0.5 , "onTreeOverlapCheckCallback" , self , CollisionFlag.TREE)\n\n        if not self.plantTreeCommandHasCollision then\n            if self:plantTree(treeType.index, tx,ty,tz, 0 ,ry, 0 , growthStateI, variationIndex, isGrowing) then\n                numPlantedTrees = numPlantedTrees + 1\n            end\n        else\n                -- TODO:retry instead\n                printWarning( "Warning:skipped tree due to overlap with existing tree" )\n            end\n        end\n\n        return string.format( "Planted %d trees of type %s" , numPlantedTrees, treeType.name)\n    end\n\n'})}),"\n",(0,l.jsx)(n.h3,{id:"cuttreetrunkcallback",children:"cutTreeTrunkCallback"}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Description"})}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Definition"})}),"\n",(0,l.jsxs)(n.blockquote,{children:["\n",(0,l.jsx)(n.p,{children:"cutTreeTrunkCallback()"}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,l.jsxs)(n.table,{children:[(0,l.jsx)(n.thead,{children:(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.th,{children:"any"}),(0,l.jsx)(n.th,{children:"loadTreeTrunkData"})]})}),(0,l.jsxs)(n.tbody,{children:[(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{children:"any"}),(0,l.jsx)(n.td,{children:"shape"})]}),(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{children:"any"}),(0,l.jsx)(n.td,{children:"isBelow"})]}),(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{children:"any"}),(0,l.jsx)(n.td,{children:"isAbove"})]}),(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{children:"any"}),(0,l.jsx)(n.td,{children:"minY"})]}),(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{children:"any"}),(0,l.jsx)(n.td,{children:"maxY"})]}),(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{children:"any"}),(0,l.jsx)(n.td,{children:"minZ"})]}),(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{children:"any"}),(0,l.jsx)(n.td,{children:"maxZ"})]})]})]}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Code"})}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-lua",children:'function TreePlantManager.cutTreeTrunkCallback(loadTreeTrunkData, shape, isBelow, isAbove, minY, maxY, minZ, maxZ)\n    g_treePlantManager:addingSplitShape(shape, loadTreeTrunkData.shapeBeingCut)\n\n    --#debug if g_treePlantManager.debugActive then\n        --#debug local splitType = getSplitType(shape)\n        --#debug Logging.devInfo("cutTreeTrunkCallback shape = %d splitType = %d(%s)", shape, splitType, g_splitShapeManager:getSplitTypeNameByIndex(splitType))\n        --#debug end\n\n        table.insert(loadTreeTrunkData.parts, { shape = shape, isBelow = isBelow, isAbove = isAbove, minY = minY, maxY = maxY, minZ = minZ, maxZ = maxZ } )\n    end\n\n'})}),"\n",(0,l.jsx)(n.h3,{id:"deletetreesdata",children:"deleteTreesData"}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Description"})}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Definition"})}),"\n",(0,l.jsxs)(n.blockquote,{children:["\n",(0,l.jsx)(n.p,{children:"deleteTreesData()"}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Code"})}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-lua",children:"function TreePlantManager:deleteTreesData()\n    if self.treesData ~ = nil then\n        delete( self.treesData.rootNode)\n        self.numTreesWithoutSplits = math.max( self.numTreesWithoutSplits - self.treesData.numTreesWithoutSplits, 0 )\n        self:initDataStructures()\n    end\nend\n\n"})}),"\n",(0,l.jsx)(n.h3,{id:"getclienttree",children:"getClientTree"}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Description"})}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Definition"})}),"\n",(0,l.jsxs)(n.blockquote,{children:["\n",(0,l.jsx)(n.p,{children:"getClientTree()"}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,l.jsx)(n.table,{children:(0,l.jsx)(n.thead,{children:(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.th,{children:"any"}),(0,l.jsx)(n.th,{children:"serverSplitShapeFileId"})]})})}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Code"})}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-lua",children:"function TreePlantManager:getClientTree(serverSplitShapeFileId)\n    if self.treesData ~ = nil then\n        return self.treesData.clientTrees[serverSplitShapeFileId]\n    end\n\n    return nil\nend\n\n"})}),"\n",(0,l.jsx)(n.h3,{id:"getistreedeleted",children:"getIsTreeDeleted"}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Description"})}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Definition"})}),"\n",(0,l.jsxs)(n.blockquote,{children:["\n",(0,l.jsx)(n.p,{children:"getIsTreeDeleted()"}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,l.jsx)(n.table,{children:(0,l.jsx)(n.thead,{children:(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.th,{children:"any"}),(0,l.jsx)(n.th,{children:"node"})]})})}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Code"})}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-lua",children:"function TreePlantManager:getIsTreeDeleted(node)\n    for i = 1 , getNumOfChildren(node) do\n        local child = getChildAt(node, i - 1 )\n        if getHasClassId(child, ClassIds.MESH_SPLIT_SHAPE) or getHasClassId(child, ClassIds.SHAPE) then\n            return false\n        else\n                if not self:getIsTreeDeleted(child) then\n                    return false\n                end\n            end\n        end\n\n        return true\n    end\n\n"})}),"\n",(0,l.jsx)(n.h3,{id:"getpalletstoreitemfilenamebyindex",children:"getPalletStoreItemFilenameByIndex"}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Description"})}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Definition"})}),"\n",(0,l.jsxs)(n.blockquote,{children:["\n",(0,l.jsx)(n.p,{children:"getPalletStoreItemFilenameByIndex()"}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,l.jsxs)(n.table,{children:[(0,l.jsx)(n.thead,{children:(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.th,{children:"any"}),(0,l.jsx)(n.th,{children:"treeTypeIndex"})]})}),(0,l.jsxs)(n.tbody,{children:[(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{children:"any"}),(0,l.jsx)(n.td,{children:"stageIndex"})]}),(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{children:"any"}),(0,l.jsx)(n.td,{children:"variationIndex"})]})]})]}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Code"})}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-lua",children:"function TreePlantManager:getPalletStoreItemFilenameByIndex(treeTypeIndex, stageIndex, variationIndex)\n    if self.treeTypes ~ = nil then\n        local treeTypeDesc = self.treeTypes[treeTypeIndex]\n        if treeTypeDesc ~ = nil then\n            local variations = treeTypeDesc.stages[stageIndex or 1 ]\n            if variations ~ = nil then\n                local variation = variations[variationIndex] or variations[ 1 ]\n                if variation ~ = nil then\n                    return variation.palletStoreItemFilename\n                end\n            end\n        end\n    end\n\n    return nil\nend\n\n"})}),"\n",(0,l.jsx)(n.h3,{id:"gettreerigidbodytype",children:"getTreeRigidBodyType"}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Description"})}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Definition"})}),"\n",(0,l.jsxs)(n.blockquote,{children:["\n",(0,l.jsx)(n.p,{children:"getTreeRigidBodyType()"}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,l.jsx)(n.table,{children:(0,l.jsx)(n.thead,{children:(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.th,{children:"any"}),(0,l.jsx)(n.th,{children:"node"})]})})}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Code"})}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-lua",children:"function TreePlantManager:getTreeRigidBodyType(node)\n    for i = 1 , getNumOfChildren(node) do\n        local child = getChildAt(node, i - 1 )\n        if getHasClassId(child, ClassIds.MESH_SPLIT_SHAPE) then\n            return getRigidBodyType(child)\n        else\n                local rigidBodyType = self:getTreeRigidBodyType(child)\n                if rigidBodyType ~ = nil then\n                    return rigidBodyType\n                end\n            end\n        end\n\n        return nil\n    end\n\n"})}),"\n",(0,l.jsx)(n.h3,{id:"gettreetypedescfromindex",children:"getTreeTypeDescFromIndex"}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Description"})}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Definition"})}),"\n",(0,l.jsxs)(n.blockquote,{children:["\n",(0,l.jsx)(n.p,{children:"getTreeTypeDescFromIndex()"}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,l.jsx)(n.table,{children:(0,l.jsx)(n.thead,{children:(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.th,{children:"any"}),(0,l.jsx)(n.th,{children:"index"})]})})}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Code"})}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-lua",children:"function TreePlantManager:getTreeTypeDescFromIndex(index)\n    if self.treeTypes ~ = nil then\n        return self.treeTypes[index]\n    end\n    return nil\nend\n\n"})}),"\n",(0,l.jsx)(n.h3,{id:"gettreetypedescfromname",children:"getTreeTypeDescFromName"}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Description"})}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Definition"})}),"\n",(0,l.jsxs)(n.blockquote,{children:["\n",(0,l.jsx)(n.p,{children:"getTreeTypeDescFromName()"}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,l.jsx)(n.table,{children:(0,l.jsx)(n.thead,{children:(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.th,{children:"any"}),(0,l.jsx)(n.th,{children:"name"})]})})}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Code"})}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-lua",children:"function TreePlantManager:getTreeTypeDescFromName(name)\n    if self.nameToTreeType ~ = nil and name ~ = nil then\n        name = string.upper(name)\n        return self.nameToTreeType[name]\n    end\n    return nil\nend\n\n"})}),"\n",(0,l.jsx)(n.h3,{id:"gettreetypedescfromsplittype",children:"getTreeTypeDescFromSplitType"}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Description"})}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Definition"})}),"\n",(0,l.jsxs)(n.blockquote,{children:["\n",(0,l.jsx)(n.p,{children:"getTreeTypeDescFromSplitType()"}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,l.jsx)(n.table,{children:(0,l.jsx)(n.thead,{children:(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.th,{children:"any"}),(0,l.jsx)(n.th,{children:"splitTypeIndex"})]})})}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Code"})}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-lua",children:"function TreePlantManager:getTreeTypeDescFromSplitType(splitTypeIndex)\n    if self.splitTypeIndexToTreeType ~ = nil and splitTypeIndex ~ = nil then\n        return self.splitTypeIndexToTreeType[splitTypeIndex]\n    end\n\n    return nil\nend\n\n"})}),"\n",(0,l.jsx)(n.h3,{id:"gettreetypefilename",children:"getTreeTypeFilename"}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Description"})}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Definition"})}),"\n",(0,l.jsxs)(n.blockquote,{children:["\n",(0,l.jsx)(n.p,{children:"getTreeTypeFilename()"}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,l.jsxs)(n.table,{children:[(0,l.jsx)(n.thead,{children:(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.th,{children:"any"}),(0,l.jsx)(n.th,{children:"treeTypeDesc"})]})}),(0,l.jsx)(n.tbody,{children:(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{children:"any"}),(0,l.jsx)(n.td,{children:"growthStateI"})]})})]}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Code"})}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-lua",children:"function TreePlantManager:getTreeTypeFilename(treeTypeDesc, growthStateI)\n    if treeTypeDesc = = nil then\n        return nil\n    end\n\n    local stage = treeTypeDesc.stages[ math.min(growthStateI, #treeTypeDesc.stages)]\n    local variation = stage[ math.random( 1 , #stage)]\n    return variation.filename\nend\n\n"})}),"\n",(0,l.jsx)(n.h3,{id:"gettreetypeindexandvariationfromname",children:"getTreeTypeIndexAndVariationFromName"}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Description"})}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Definition"})}),"\n",(0,l.jsxs)(n.blockquote,{children:["\n",(0,l.jsx)(n.p,{children:"getTreeTypeIndexAndVariationFromName()"}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,l.jsxs)(n.table,{children:[(0,l.jsx)(n.thead,{children:(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.th,{children:"any"}),(0,l.jsx)(n.th,{children:"name"})]})}),(0,l.jsxs)(n.tbody,{children:[(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{children:"any"}),(0,l.jsx)(n.td,{children:"stageIndex"})]}),(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{children:"any"}),(0,l.jsx)(n.td,{children:"variationName"})]})]})]}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Code"})}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-lua",children:'function TreePlantManager:getTreeTypeIndexAndVariationFromName(name, stageIndex, variationName)\n    if self.nameToTreeType ~ = nil and name ~ = nil then\n        name = string.upper(name)\n        local treeTypeDesc = self.nameToTreeType[name]\n        if treeTypeDesc ~ = nil then\n            local stage = treeTypeDesc.stages[stageIndex]\n            if stage ~ = nil then\n                local variationIndex\n                for index, variation in ipairs(stage) do\n                    if string.lower(variation.name or "DEFAULT" ) = = string.lower(variationName or "DEFAULT" ) then\n                        variationIndex = index\n                        break\n                    end\n                end\n\n                return treeTypeDesc.index, variationIndex\n            end\n        end\n    end\n\n    return nil , nil\nend\n\n'})}),"\n",(0,l.jsx)(n.h3,{id:"gettreetypeindexfromname",children:"getTreeTypeIndexFromName"}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Description"})}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Definition"})}),"\n",(0,l.jsxs)(n.blockquote,{children:["\n",(0,l.jsx)(n.p,{children:"getTreeTypeIndexFromName()"}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,l.jsx)(n.table,{children:(0,l.jsx)(n.thead,{children:(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.th,{children:"any"}),(0,l.jsx)(n.th,{children:"name"})]})})}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Code"})}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-lua",children:"function TreePlantManager:getTreeTypeIndexFromName(name)\n    if self.nameToTreeType ~ = nil and name ~ = nil then\n        name = string.upper(name)\n        if self.nameToTreeType[name] ~ = nil then\n            return self.nameToTreeType[name].index\n        end\n    end\n\n    return nil\nend\n\n"})}),"\n",(0,l.jsx)(n.h3,{id:"gettreetypenameandvariationbyindex",children:"getTreeTypeNameAndVariationByIndex"}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Description"})}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Definition"})}),"\n",(0,l.jsxs)(n.blockquote,{children:["\n",(0,l.jsx)(n.p,{children:"getTreeTypeNameAndVariationByIndex()"}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,l.jsxs)(n.table,{children:[(0,l.jsx)(n.thead,{children:(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.th,{children:"any"}),(0,l.jsx)(n.th,{children:"treeTypeIndex"})]})}),(0,l.jsxs)(n.tbody,{children:[(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{children:"any"}),(0,l.jsx)(n.td,{children:"stageIndex"})]}),(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{children:"any"}),(0,l.jsx)(n.td,{children:"variationIndex"})]})]})]}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Code"})}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-lua",children:'function TreePlantManager:getTreeTypeNameAndVariationByIndex(treeTypeIndex, stageIndex, variationIndex)\n    if self.treeTypes ~ = nil then\n        local treeTypeDesc = self.treeTypes[treeTypeIndex]\n        if treeTypeDesc ~ = nil then\n            local variations = treeTypeDesc.stages[stageIndex or 1 ]\n            if variations ~ = nil then\n                local variation = variations[variationIndex] or variations[ 1 ]\n                if variation ~ = nil then\n                    return treeTypeDesc.name, variation.name or "DEFAULT"\n                end\n            end\n        end\n    end\n\n    return nil , nil\nend\n\n'})}),"\n",(0,l.jsx)(n.h3,{id:"gettreetypenamefromindex",children:"getTreeTypeNameFromIndex"}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Description"})}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Definition"})}),"\n",(0,l.jsxs)(n.blockquote,{children:["\n",(0,l.jsx)(n.p,{children:"getTreeTypeNameFromIndex()"}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,l.jsx)(n.table,{children:(0,l.jsx)(n.thead,{children:(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.th,{children:"any"}),(0,l.jsx)(n.th,{children:"index"})]})})}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Code"})}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-lua",children:"function TreePlantManager:getTreeTypeNameFromIndex(index)\n    if self.treeTypes ~ = nil then\n        if self.treeTypes[index] ~ = nil then\n            return self.treeTypes[index].name\n        end\n    end\n    return nil\nend\n\n"})}),"\n",(0,l.jsx)(n.h3,{id:"initdatastructures",children:"initDataStructures"}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Description"})}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Definition"})}),"\n",(0,l.jsxs)(n.blockquote,{children:["\n",(0,l.jsx)(n.p,{children:"initDataStructures()"}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Code"})}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-lua",children:"function TreePlantManager:initDataStructures()\n    self.treeTypes = { }\n    self.indexToTreeType = { }\n    self.splitTypeIndexToTreeType = { }\n    self.nameToTreeType = { }\n    self.treeFileCache = { }\n\n    self.loadTreeTrunkDatas = { }\n\n    self.numTreesWithoutSplits = 0\n\n    self.activeDecayingSplitShapes = { }\n    self.updateDecayDtGame = 0\nend\n\n"})}),"\n",(0,l.jsx)(n.h3,{id:"initialize",children:"initialize"}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Description"})}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Definition"})}),"\n",(0,l.jsxs)(n.blockquote,{children:["\n",(0,l.jsx)(n.p,{children:"initialize()"}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Code"})}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-lua",children:'function TreePlantManager:initialize()\n    local rootNode = createTransformGroup( "trees" )\n    link(getRootNode(), rootNode)\n\n    self.treesData = { }\n    self.treesData.rootNode = rootNode\n    self.treesData.growingTrees = { }\n    self.treesData.splitTrees = { }\n    self.treesData.clientTrees = { }\n    self.treesData.updateDtGame = 0\n    self.treesData.treeCutJoints = { }\n    self.treesData.numTreesWithoutSplits = 0\nend\n\n'})}),"\n",(0,l.jsx)(n.h3,{id:"loaddefaulttypes",children:"loadDefaultTypes"}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Description"})}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Definition"})}),"\n",(0,l.jsxs)(n.blockquote,{children:["\n",(0,l.jsx)(n.p,{children:"loadDefaultTypes()"}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,l.jsxs)(n.table,{children:[(0,l.jsx)(n.thead,{children:(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.th,{children:"any"}),(0,l.jsx)(n.th,{children:"missionInfo"})]})}),(0,l.jsx)(n.tbody,{children:(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{children:"any"}),(0,l.jsx)(n.td,{children:"baseDirectory"})]})})]}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Code"})}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-lua",children:'function TreePlantManager:loadDefaultTypes(missionInfo, baseDirectory)\n    local xmlFile = loadXMLFile( "treeTypes" , "data/maps/maps_treeTypes.xml" )\n    self:loadTreeTypes(xmlFile, missionInfo, baseDirectory, true )\n    delete(xmlFile)\nend\n\n'})}),"\n",(0,l.jsx)(n.h3,{id:"loadfromxmlfile",children:"loadFromXMLFile"}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Description"})}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Definition"})}),"\n",(0,l.jsxs)(n.blockquote,{children:["\n",(0,l.jsx)(n.p,{children:"loadFromXMLFile()"}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,l.jsx)(n.table,{children:(0,l.jsx)(n.thead,{children:(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.th,{children:"any"}),(0,l.jsx)(n.th,{children:"xmlFilename"})]})})}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Code"})}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-lua",children:'function TreePlantManager:loadFromXMLFile(xmlFilename)\n    if xmlFilename = = nil then\n        return false\n    end\n    local xmlFile = loadXMLFile( "treePlantXML" , xmlFilename)\n    if xmlFile = = 0 then\n        return false\n    end\n\n    local i = 0\n    while true do\n\n        local key = string.format( "treePlant.tree(%d)" , i)\n        if not hasXMLProperty(xmlFile, key) then\n            break\n        end\n\n        local treeTypeName = getXMLString(xmlFile, key .. "#treeType" )\n        local treeType = self.nameToTreeType[treeTypeName]\n\n        local pos = string.getVector(getXMLString(xmlFile, key .. "#position" ), 3 )\n        local rot = string.getRadians(getXMLString(xmlFile, key .. "#rotation" ), 3 )\n\n        if #pos = = 3 and #rot = = 3 and treeType ~ = nil then\n            local growthStateI = getXMLInt(xmlFile, key .. "#growthStateI" )\n            local variationIndex = getXMLInt(xmlFile, key .. "#variationIndex" ) or 1\n            local nextGrowthTargetHour = getXMLFloat(xmlFile, key .. "#nextGrowthTargetHour" )\n            local isGrowing = Utils.getNoNil(getXMLBool(xmlFile, key .. "#isGrowing" ), true )\n            local splitShapeFileId = getXMLInt(xmlFile, key .. "#splitShapeFileId" ) -- note:might be nil if not available\n\n                self:plantTree(treeType.index, pos[ 1 ], pos[ 2 ], pos[ 3 ], rot[ 1 ], rot[ 2 ], rot[ 3 ], growthStateI, variationIndex, isGrowing, nextGrowthTargetHour, splitShapeFileId)\n            end\n\n            i = i + 1\n        end\n        delete(xmlFile)\n\n        return true\n    end\n\n'})}),"\n",(0,l.jsx)(n.h3,{id:"loadmapdata",children:"loadMapData"}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Description"})}),"\n",(0,l.jsxs)(n.blockquote,{children:["\n",(0,l.jsx)(n.p,{children:"Load data on map load"}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Definition"})}),"\n",(0,l.jsxs)(n.blockquote,{children:["\n",(0,l.jsx)(n.p,{children:"loadMapData()"}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,l.jsxs)(n.table,{children:[(0,l.jsx)(n.thead,{children:(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.th,{children:"any"}),(0,l.jsx)(n.th,{children:"xmlFile"})]})}),(0,l.jsxs)(n.tbody,{children:[(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{children:"any"}),(0,l.jsx)(n.td,{children:"missionInfo"})]}),(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{children:"any"}),(0,l.jsx)(n.td,{children:"baseDirectory"})]})]})]}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Return Values"})}),"\n\n\n\n\n\n\n\n\n",(0,l.jsx)(n.table,{children:(0,l.jsx)(n.thead,{children:(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.th,{children:"any"}),(0,l.jsx)(n.th,{children:"true"}),(0,l.jsx)(n.th,{children:"if loading was successful else false"})]})})}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Code"})}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-lua",children:'function TreePlantManager:loadMapData(xmlFile, missionInfo, baseDirectory)\n    TreePlantManager:superClass().loadMapData( self )\n\n    -- server only cheats\n    if g_server ~ = nil and g_addCheatCommands then\n        addConsoleCommand( "gsTreeCut" , "Cut all trees around a given radius" , "consoleCommandCutTrees" , self , "[radius]" )\n        addConsoleCommand( "gsTreeAdd" , "Load a loose tree trunk" , "consoleCommandLoadTree" , self , "length; treeType; [growthState]; [delimb]" )\n        addConsoleCommand( "gsTreePlant" , "Plant given number of trees of a specified type" , "consoleCommandPlantTrees" , self , "treeType; number; growthState; variationIndex; isGrowing" )\n        addConsoleCommand( "gsTreeLoadAll" , "Spawn all trees in front of player" , "consoleCommandLoadAll" , self )\n        addConsoleCommand( "gsTreeRemove" , "Remove currently looked at split shape or tree" , "consoleCommandRemoveSplitShape" , self )\n    end\n\n    if g_addCheatCommands then\n        addConsoleCommand( "gsTreeDebug" , "Toggle tree/splitshape debug mode" , "consoleCommandDebug" , self )\n    end\n\n    self.maxNumTrees = math.clamp(getXMLInt(xmlFile, "map.treeTypes#maxNumTrees" ) or 8000 , 1 , 30000 )\n    g_messageCenter:subscribeOneshot(MessageType.CURRENT_MISSION_START, TreePlantManager.onMissionStarted, self )\n\n    self:loadDefaultTypes(missionInfo, baseDirectory)\n\n    return XMLUtil.loadDataFromMapXML(xmlFile, "treeTypes" , baseDirectory, self , self.loadTreeTypes, missionInfo, baseDirectory)\nend\n\n'})}),"\n",(0,l.jsx)(n.h3,{id:"loadtreenode",children:"loadTreeNode"}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Description"})}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Definition"})}),"\n",(0,l.jsxs)(n.blockquote,{children:["\n",(0,l.jsx)(n.p,{children:"loadTreeNode()"}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,l.jsxs)(n.table,{children:[(0,l.jsx)(n.thead,{children:(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.th,{children:"any"}),(0,l.jsx)(n.th,{children:"treeTypeDesc"})]})}),(0,l.jsxs)(n.tbody,{children:[(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{children:"any"}),(0,l.jsx)(n.td,{children:"x"})]}),(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{children:"any"}),(0,l.jsx)(n.td,{children:"y"})]}),(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{children:"any"}),(0,l.jsx)(n.td,{children:"z"})]}),(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{children:"any"}),(0,l.jsx)(n.td,{children:"rx"})]}),(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{children:"any"}),(0,l.jsx)(n.td,{children:"ry"})]}),(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{children:"any"}),(0,l.jsx)(n.td,{children:"rz"})]}),(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{children:"any"}),(0,l.jsx)(n.td,{children:"growthStateI"})]}),(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{children:"any"}),(0,l.jsx)(n.td,{children:"variationIndex"})]}),(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{children:"any"}),(0,l.jsx)(n.td,{children:"splitShapeLoadingFileId"})]})]})]}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Code"})}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-lua",children:"function TreePlantManager:loadTreeNode(treeTypeDesc, x,y,z, rx,ry,rz, growthStateI, variationIndex, splitShapeLoadingFileId)\n    local treesData = self.treesData\n\n    local stage = math.min(growthStateI, #treeTypeDesc.stages)\n    local variations = treeTypeDesc.stages[stage]\n    if variations = = nil then\n        Logging.error( \"TreePlantManager:loadTreeNode failed due to invalid stage index(stage %d of %d)\" , stage, #treeTypeDesc.stages)\n        return 0\n    end\n\n    local variation = variations[ math.clamp(variationIndex, 1 , #variations)]\n    local i3dFilename = variation.filename\n\n    if self.treeFileCache[i3dFilename] = = nil then\n        -- make sure the i3d is loaded, so that the file id will not be used by the i3d clone source\n        setSplitShapesLoadingFileId( - 1 )\n        setSplitShapesNextFileId( true )\n        local node, requestId = g_i3DManager:loadSharedI3DFile(i3dFilename, false , false )\n        if node ~ = 0 then\n            delete(node)\n            self.treeFileCache[i3dFilename] = requestId\n        end\n    end\n\n    setSplitShapesLoadingFileId(splitShapeLoadingFileId or - 1 )\n    local splitShapeFileId = setSplitShapesNextFileId()\n\n    local treeId, requestId = g_i3DManager:loadSharedI3DFile(i3dFilename, false , false )\n    g_i3DManager:releaseSharedI3DFile(requestId)\n\n    if treeId ~ = 0 then\n        link(treesData.rootNode, treeId)\n\n        setTranslation(treeId, x,y,z)\n        setRotation(treeId, rx,ry,rz)\n        -- Split shapes loaded from savegames/streams are placed at world space, so correct the position after we moved our node\n        local numChildren = getNumOfChildren(treeId)\n        for i = 0 , numChildren - 1 do\n            local child = getChildAt(treeId, i)\n            if getHasClassId(child, ClassIds.MESH_SPLIT_SHAPE) and getIsSplitShapeSplit(child) then\n                setWorldRotation(child, getRotation(child))\n                setWorldTranslation(child, getTranslation(child))\n            end\n        end\n\n        I3DUtil.iterateRecursively(treeId, function (node, _)\n            if getHasClassId(node, ClassIds.MESH_SPLIT_SHAPE) then\n                local splitTypeIndex = getSplitType(node)\n                if splitTypeIndex ~ = treeTypeDesc.splitTypeIndex then\n                    Logging.warning( \"Tree has wrong splitType '%s' assigned.Should be '%s'.File: '%s'\" , splitTypeIndex, treeTypeDesc.splitTypeIndex, i3dFilename)\n                end\n\n                -- on client side the trees must be kinematic(required for pre-cut trees which are not handled by an dedicated class like TreeTransportMissionTree - due to bug or mods)\n                    if g_server = = nil then\n                        if getRigidBodyType(node) = = RigidBodyType.DYNAMIC then\n                            setRigidBodyType(node, RigidBodyType.KINEMATIC)\n                        end\n                    end\n                end\n\n                return true\n            end )\n\n            addToPhysics(treeId)\n        end\n\n        local updateRange = 2\n        g_densityMapHeightManager:setCollisionMapAreaDirty(x - updateRange, z - updateRange, x + updateRange, z + updateRange, true )\n        g_currentMission.aiSystem:setAreaDirty(x - updateRange, x + updateRange, z - updateRange, z + updateRange)\n\n        return treeId, splitShapeFileId\n    end\n\n"})}),"\n",(0,l.jsx)(n.h3,{id:"loadtreetrunk",children:"loadTreeTrunk"}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Description"})}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Definition"})}),"\n",(0,l.jsxs)(n.blockquote,{children:["\n",(0,l.jsx)(n.p,{children:"loadTreeTrunk()"}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,l.jsxs)(n.table,{children:[(0,l.jsx)(n.thead,{children:(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.th,{children:"any"}),(0,l.jsx)(n.th,{children:"treeTypeDesc"})]})}),(0,l.jsxs)(n.tbody,{children:[(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{children:"any"}),(0,l.jsx)(n.td,{children:"x"})]}),(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{children:"any"}),(0,l.jsx)(n.td,{children:"y"})]}),(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{children:"any"}),(0,l.jsx)(n.td,{children:"z"})]}),(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{children:"any"}),(0,l.jsx)(n.td,{children:"dirX"})]}),(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{children:"any"}),(0,l.jsx)(n.td,{children:"dirY"})]}),(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{children:"any"}),(0,l.jsx)(n.td,{children:"dirZ"})]}),(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{children:"any"}),(0,l.jsx)(n.td,{children:"length"})]}),(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{children:"any"}),(0,l.jsx)(n.td,{children:"growthStateI"})]}),(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{children:"any"}),(0,l.jsx)(n.td,{children:"variationIndex"})]}),(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{children:"any"}),(0,l.jsx)(n.td,{children:"delimb"})]}),(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{children:"any"}),(0,l.jsx)(n.td,{children:"useOnlyStump"})]})]})]}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Code"})}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-lua",children:"function TreePlantManager:loadTreeTrunk(treeTypeDesc, x, y, z, dirX, dirY, dirZ, length, growthStateI, variationIndex, delimb, useOnlyStump)\n    local treeId, splitShapeFileId = g_treePlantManager:loadTreeNode(treeTypeDesc, x, y, z, 0 , 0 , 0 , growthStateI, variationIndex)\n\n    if treeId ~ = 0 then\n        if getFileIdHasSplitShapes(splitShapeFileId) then\n            local tree = { }\n            tree.node = treeId\n            tree.growthStateI = growthStateI\n            tree.variationIndex = variationIndex\n            tree.x, tree.y, tree.z = x,y,z\n            tree.rx, tree.ry, tree.rz = 0 , 0 , 0\n            tree.treeType = treeTypeDesc.index\n            tree.splitShapeFileId = splitShapeFileId\n            tree.hasSplitShapes = getFileIdHasSplitShapes(splitShapeFileId)\n            table.insert( self.treesData.splitTrees, tree)\n\n            local loadTreeTrunkData = { framesLeft = 2 , shape = treeId + 2 , x = x, y = y, z = z, length = length, offset = 0.5 , dirX = dirX, dirY = dirY, dirZ = dirZ, delimb = delimb, useOnlyStump = useOnlyStump, cutTreeTrunkCallback = TreePlantManager.cutTreeTrunkCallback }\n\n            table.insert( self.loadTreeTrunkDatas, loadTreeTrunkData)\n        else\n                delete(treeId)\n            end\n        end\n    end\n\n"})}),"\n",(0,l.jsx)(n.h3,{id:"loadtreetypes",children:"loadTreeTypes"}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Description"})}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Definition"})}),"\n",(0,l.jsxs)(n.blockquote,{children:["\n",(0,l.jsx)(n.p,{children:"loadTreeTypes()"}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,l.jsxs)(n.table,{children:[(0,l.jsx)(n.thead,{children:(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.th,{children:"any"}),(0,l.jsx)(n.th,{children:"xmlFile"})]})}),(0,l.jsxs)(n.tbody,{children:[(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{children:"any"}),(0,l.jsx)(n.td,{children:"missionInfo"})]}),(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{children:"any"}),(0,l.jsx)(n.td,{children:"baseDirectory"})]}),(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{children:"any"}),(0,l.jsx)(n.td,{children:"isBaseType"})]}),(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{children:"any"}),(0,l.jsx)(n.td,{children:"customEnvironment"})]})]})]}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Code"})}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-lua",children:'function TreePlantManager:loadTreeTypes(xmlFile, missionInfo, baseDirectory, isBaseType, customEnvironment)\n    if type(xmlFile) = = "number" then\n        xmlFile = XMLFile.wrap(xmlFile)\n    end\n\n    for _, treeTypeKey in xmlFile:iterator( "map.treeTypes.treeType" ) do\n        local name = xmlFile:getString(treeTypeKey .. "#name" )\n        local title = xmlFile:getString(treeTypeKey .. "#title" )\n        local growthTimeHours = xmlFile:getString(treeTypeKey .. "#growthTimeHours" )\n        local splitTypeName = xmlFile:getString(treeTypeKey .. "#splitType" )\n        local supportsPlanting = xmlFile:getBool(treeTypeKey .. "#supportsPlanting" , true )\n        local saplingPrice = xmlFile:getFloat(treeTypeKey .. "#saplingPrice" , 0 )\n\n        if name = = nil then\n            Logging.xmlWarning(xmlFile, "Missing \'name\' attribute for treeType %q" , treeTypeKey)\n                continue\n            end\n            if title = = nil then\n                Logging.xmlWarning(xmlFile, "Missing \'title\' attribute for treeType %q" , treeTypeKey)\n                    continue\n                end\n                if growthTimeHours = = nil then\n                    Logging.xmlWarning(xmlFile, "Missing \'growthTimeHours\' attribute for treeType %q" , treeTypeKey)\n                        continue\n                    end\n                    if splitTypeName = = nil then\n                        Logging.xmlWarning(xmlFile, "Missing \'splitType\' attribute for treeType %q" , treeTypeKey)\n                            continue\n                        end\n\n                        local splitTypeIndex = g_splitShapeManager:getSplitTypeIndexByName(splitTypeName)\n                        if splitTypeIndex = = nil then\n                            Logging.xmlWarning(xmlFile, "SplitType \'%s\' not defined for treeType %q" , splitTypeName, treeTypeKey)\n                                continue\n                            end\n\n                            local stages = { }\n                            for _, stageKey in xmlFile:iterator(treeTypeKey .. ".stage" ) do\n                                local filename = xmlFile:getString(stageKey .. "#filename" )\n                                if filename ~ = nil then\n                                    -- single i3d file for this stage\n                                        local variation = { }\n                                        variation.filename = Utils.getFilename(filename, baseDirectory)\n\n                                        local palletFilename = xmlFile:getString(stageKey .. ".pallet#filename" )\n                                        if palletFilename ~ = nil then\n                                            variation.palletFilename = Utils.getFilename(palletFilename, baseDirectory)\n                                        end\n\n                                        local palletStoreItemFilename = xmlFile:getString(stageKey .. ".pallet#storeItem" )\n                                        if palletStoreItemFilename ~ = nil then\n                                            variation.palletStoreItemFilename = Utils.getFilename(palletStoreItemFilename, baseDirectory)\n                                        end\n\n                                        local planterFilename = xmlFile:getString(stageKey .. ".planter#filename" )\n                                        if planterFilename ~ = nil then\n                                            variation.planterFilename = Utils.getFilename(planterFilename, baseDirectory)\n                                        end\n\n                                        table.insert(stages, { variation } ) -- single variation\n                                    else\n                                            -- multiple variations for this stage\n                                                local variations = { }\n                                                for _, variationKey in xmlFile:iterator(stageKey .. ".variation" ) do\n                                                    filename = xmlFile:getString(variationKey .. "#filename" )\n                                                    if filename ~ = nil then\n                                                        if #variations > = TreePlantManager.MAX_NUM_VARIATIONS_PER_STAGE then\n                                                            Logging.xmlWarning(xmlFile, "Unable to add variation %q for tree %q, max number of variations per stage(%d) reached" , filename, name, TreePlantManager.MAX_NUM_VARIATIONS_PER_STAGE)\n                                                                break\n                                                            end\n\n                                                            local variation = { }\n                                                            variation.name = xmlFile:getString(variationKey .. "#name" )\n                                                            variation.filename = Utils.getFilename(filename, baseDirectory)\n\n                                                            local palletFilename = xmlFile:getString(variationKey .. ".pallet#filename" )\n                                                            if palletFilename ~ = nil then\n                                                                variation.palletFilename = Utils.getFilename(palletFilename, baseDirectory)\n                                                            end\n\n                                                            local palletStoreItemFilename = xmlFile:getString(variationKey .. ".pallet#storeItem" )\n                                                            if palletStoreItemFilename ~ = nil then\n                                                                variation.palletStoreItemFilename = Utils.getFilename(palletStoreItemFilename, baseDirectory)\n                                                            end\n\n                                                            local planterFilename = xmlFile:getString(variationKey .. ".planter#filename" )\n                                                            if planterFilename ~ = nil then\n                                                                variation.planterFilename = Utils.getFilename(planterFilename, baseDirectory)\n                                                            end\n\n                                                            table.insert(variations, variation)\n                                                        end\n                                                    end\n\n                                                    if #stages > = TreePlantManager.MAX_NUM_STAGES then\n                                                        Logging.xmlWarning(xmlFile, "Unable to add stage %q for tree %q, max number of stages(%d) reached" , stageKey, name, TreePlantManager.MAX_NUM_STAGES)\n                                                            break\n                                                        end\n\n                                                        table.insert(stages, variations)\n                                                    end\n                                                end\n                                                if #stages = = 0 then\n                                                    Logging.xmlWarning(xmlFile, "A treetype %q(%s) has no valid stages defined\'" , name, treeTypeKey)\n                                                    continue\n                                                end\n\n                                                title = g_i18n:convertText(title, customEnvironment)\n\n                                                self:registerTreeType(name, title, stages, growthTimeHours, isBaseType, splitTypeIndex, supportsPlanting, saplingPrice)\n                                            end\n\n                                            return true\n                                        end\n\n'})}),"\n",(0,l.jsx)(n.h3,{id:"new",children:"new"}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Description"})}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Definition"})}),"\n",(0,l.jsxs)(n.blockquote,{children:["\n",(0,l.jsx)(n.p,{children:"new()"}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,l.jsx)(n.table,{children:(0,l.jsx)(n.thead,{children:(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.th,{children:"any"}),(0,l.jsx)(n.th,{children:"customMt"})]})})}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Code"})}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-lua",children:"function TreePlantManager.new(customMt)\n    local self = AbstractManager.new(customMt or TreePlantManager _mt)\n\n    return self\nend\n\n"})}),"\n",(0,l.jsx)(n.h3,{id:"ontreecutcommandoverlapcallback",children:"onTreeCutCommandOverlapCallback"}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Description"})}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Definition"})}),"\n",(0,l.jsxs)(n.blockquote,{children:["\n",(0,l.jsx)(n.p,{children:"onTreeCutCommandOverlapCallback()"}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,l.jsxs)(n.table,{children:[(0,l.jsx)(n.thead,{children:(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.th,{children:"any"}),(0,l.jsx)(n.th,{children:"objectId"})]})}),(0,l.jsx)(n.tbody,{children:(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{children:"any"}),(0,l.jsx)(n.td,{children:"..."})]})})]}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Code"})}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-lua",children:"function TreePlantManager:onTreeCutCommandOverlapCallback(objectId, .. .)\n    if getHasClassId(objectId, ClassIds.MESH_SPLIT_SHAPE) and getSplitType(objectId) ~ = 0 and getRigidBodyType(objectId) = = RigidBodyType.STATIC and not getIsSplitShapeSplit(objectId) then\n        table.insert( self.commandCutTreeData.trees, objectId)\n    end\nend\n\n"})}),"\n",(0,l.jsx)(n.h3,{id:"ontreecutcommandsplitcallback",children:"onTreeCutCommandSplitCallback"}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Description"})}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Definition"})}),"\n",(0,l.jsxs)(n.blockquote,{children:["\n",(0,l.jsx)(n.p,{children:"onTreeCutCommandSplitCallback()"}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,l.jsxs)(n.table,{children:[(0,l.jsx)(n.thead,{children:(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.th,{children:"any"}),(0,l.jsx)(n.th,{children:"shape"})]})}),(0,l.jsxs)(n.tbody,{children:[(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{children:"any"}),(0,l.jsx)(n.td,{children:"isBelow"})]}),(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{children:"any"}),(0,l.jsx)(n.td,{children:"isAbove"})]}),(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{children:"any"}),(0,l.jsx)(n.td,{children:"minY"})]}),(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{children:"any"}),(0,l.jsx)(n.td,{children:"maxY"})]}),(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{children:"any"}),(0,l.jsx)(n.td,{children:"minZ"})]}),(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{children:"any"}),(0,l.jsx)(n.td,{children:"maxZ"})]})]})]}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Code"})}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-lua",children:"function TreePlantManager:onTreeCutCommandSplitCallback(shape, isBelow, isAbove, minY, maxY, minZ, maxZ)\n    rotate(shape, 0.1 , 0 , 0 )\n\n    g_currentMission:addKnownSplitShape(shape)\n    self:addingSplitShape(shape, self.commandCutTreeData.shapeBeingCut, true )\nend\n\n"})}),"\n",(0,l.jsx)(n.h3,{id:"planttree",children:"plantTree"}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Description"})}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Definition"})}),"\n",(0,l.jsxs)(n.blockquote,{children:["\n",(0,l.jsx)(n.p,{children:"plantTree(integer treeTypeIndex, float x, float y, float z, float rx, float ry, float rz, integer growthStateI,\ninteger variationIndex, boolean? isGrowing, float? nextGrowthTargetHour, integer? existingSplitShapeFileId)"}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,l.jsxs)(n.table,{children:[(0,l.jsx)(n.thead,{children:(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.th,{children:"integer"}),(0,l.jsx)(n.th,{children:"treeTypeIndex"})]})}),(0,l.jsxs)(n.tbody,{children:[(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{children:"float"}),(0,l.jsx)(n.td,{children:"x"})]}),(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{children:"float"}),(0,l.jsx)(n.td,{children:"y"})]}),(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{children:"float"}),(0,l.jsx)(n.td,{children:"z"})]}),(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{children:"float"}),(0,l.jsx)(n.td,{children:"rx"})]}),(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{children:"float"}),(0,l.jsx)(n.td,{children:"ry"})]}),(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{children:"float"}),(0,l.jsx)(n.td,{children:"rz"})]}),(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{children:"integer"}),(0,l.jsx)(n.td,{children:"growthStateI"})]}),(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{children:"integer"}),(0,l.jsx)(n.td,{children:"variationIndex"})]}),(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{children:"boolean?"}),(0,l.jsx)(n.td,{children:"isGrowing"})]}),(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{children:"float?"}),(0,l.jsx)(n.td,{children:"nextGrowthTargetHour"})]}),(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{children:"integer?"}),(0,l.jsx)(n.td,{children:"existingSplitShapeFileId"})]})]})]}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Return Values"})}),"\n\n\n\n\n\n\n\n",(0,l.jsx)(n.table,{children:(0,l.jsx)(n.thead,{children:(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.th,{children:"integer?"}),(0,l.jsx)(n.th,{children:"treeId"})]})})}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Code"})}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-lua",children:"function TreePlantManager:plantTree(treeTypeIndex, x,y,z, rx,ry,rz, growthStateI, variationIndex, isGrowing, nextGrowthTargetHour, existingSplitShapeFileId)\n    local treeTypeDesc = self.indexToTreeType[treeTypeIndex]\n    if treeTypeDesc = = nil then\n        return nil\n    end\n\n    local treeId, splitShapeFileId = self:loadTreeNode(treeTypeDesc, x,y,z, rx,ry,rz, growthStateI, variationIndex, existingSplitShapeFileId)\n\n    if treeId = = 0 then\n        return nil\n    end\n\n    local treesData = self.treesData\n\n    local tree = { }\n    tree.node = treeId\n    tree.growthStateI = growthStateI\n    tree.variationIndex = variationIndex or 1\n    tree.isGrowing = Utils.getNoNil(isGrowing, true ) and growthStateI < #treeTypeDesc.stages -- tree can only grow if not at the last stage already\n        tree.x, tree.y, tree.z = x,y,z\n        tree.rx, tree.ry, tree.rz = rx,ry,rz\n        tree.treeType = treeTypeIndex\n        tree.splitShapeFileId = splitShapeFileId\n        tree.hasSplitShapes = getFileIdHasSplitShapes(splitShapeFileId)\n\n        if tree.isGrowing then\n            tree.origSplitShape = getChildAt(treeId, 0 )\n\n            if nextGrowthTargetHour = = nil then\n                -- freshly planted, use growth time defined ni tree type\n                tree.nextGrowthTargetHour = g_currentMission.environment:getMonotonicHour() + treeTypeDesc.growthTimeHours\n            else\n                    -- tree loaded from savegame, use stored growth target hour\n                    tree.nextGrowthTargetHour = nextGrowthTargetHour\n                end\n\n                table.insert(treesData.growingTrees, tree)\n            else\n                    table.insert(treesData.splitTrees, tree)\n                end\n\n                if not tree.hasSplitShapes then\n                    self.numTreesWithoutSplits = self.numTreesWithoutSplits + 1\n                    treesData.numTreesWithoutSplits = treesData.numTreesWithoutSplits + 1\n                end\n\n                g_server:broadcastEvent(TreePlantEvent.new(treeTypeIndex, x,y,z, rx,ry,rz, growthStateI, tree.variationIndex, splitShapeFileId, tree.isGrowing))\n\n                return treeId\n            end\n\n"})}),"\n",(0,l.jsx)(n.h3,{id:"readfromserverstream",children:"readFromServerStream"}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Description"})}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Definition"})}),"\n",(0,l.jsxs)(n.blockquote,{children:["\n",(0,l.jsx)(n.p,{children:"readFromServerStream()"}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,l.jsx)(n.table,{children:(0,l.jsx)(n.thead,{children:(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.th,{children:"any"}),(0,l.jsx)(n.th,{children:"streamId"})]})})}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Code"})}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-lua",children:"function TreePlantManager:readFromServerStream(streamId)\n    local treesData = self.treesData\n\n    local numTrees = streamReadInt32(streamId)\n    for i = 1 , numTrees do\n        local treeType = streamReadUInt8(streamId)\n        local x = streamReadFloat32(streamId)\n        local y = streamReadFloat32(streamId)\n        local z = streamReadFloat32(streamId)\n        local rx = streamReadFloat32(streamId)\n        local ry = streamReadFloat32(streamId)\n        local rz = streamReadFloat32(streamId)\n        local growthStateI = streamReadUIntN(streamId, TreePlantManager.STAGE_NUM_BITS)\n        local variationIndex = streamReadUIntN(streamId, TreePlantManager.VARIATION_NUM_BITS)\n        local serverSplitShapeFileId = streamReadInt32(streamId)\n\n        local treeTypeDesc = self.indexToTreeType[treeType]\n        if treeTypeDesc ~ = nil then\n            local nodeId, splitShapeFileId = self:loadTreeNode(treeTypeDesc, x,y,z, rx,ry,rz, growthStateI, variationIndex, - 1 )\n            setSplitShapesFileIdMapping(splitShapeFileId, serverSplitShapeFileId)\n            treesData.clientTrees[serverSplitShapeFileId] = nodeId\n        end\n    end\nend\n\n"})}),"\n",(0,l.jsx)(n.h3,{id:"registertreetype",children:"registerTreeType"}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Description"})}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Definition"})}),"\n",(0,l.jsxs)(n.blockquote,{children:["\n",(0,l.jsx)(n.p,{children:"registerTreeType(string name, string title, array stages, float growthTimeHours, boolean isBaseType, integer\nsplitTypeIndex, boolean supportsPlanting, float saplingPrice)"}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,l.jsxs)(n.table,{children:[(0,l.jsx)(n.thead,{children:(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.th,{children:"string"}),(0,l.jsx)(n.th,{children:"name"}),(0,l.jsx)(n.th,{children:"id"})]})}),(0,l.jsxs)(n.tbody,{children:[(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{children:"string"}),(0,l.jsx)(n.td,{children:"title"}),(0,l.jsx)(n.td,{children:"localized title"})]}),(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{children:"array"}),(0,l.jsx)(n.td,{children:"stages"}),(0,l.jsx)(n.td,{})]}),(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{children:"float"}),(0,l.jsx)(n.td,{children:"growthTimeHours"}),(0,l.jsx)(n.td,{})]}),(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{children:"boolean"}),(0,l.jsx)(n.td,{children:"isBaseType"}),(0,l.jsx)(n.td,{})]}),(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{children:"integer"}),(0,l.jsx)(n.td,{children:"splitTypeIndex"}),(0,l.jsx)(n.td,{})]}),(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{children:"boolean"}),(0,l.jsx)(n.td,{children:"supportsPlanting"}),(0,l.jsx)(n.td,{children:"if false tree type will not be added to saplings pallet, default: true"})]}),(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{children:"float"}),(0,l.jsx)(n.td,{children:"saplingPrice"}),(0,l.jsx)(n.td,{})]})]})]}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Return Values"})}),"\n\n\n\n\n\n\n\n",(0,l.jsx)(n.table,{children:(0,l.jsx)(n.thead,{children:(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.th,{children:"float"}),(0,l.jsx)(n.th,{children:"treeType"})]})})}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Code"})}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-lua",children:'function TreePlantManager:registerTreeType(name, title, stages, growthTimeHours, isBaseType, splitTypeIndex, supportsPlanting, saplingPrice)\n    name = string.upper(name)\n\n    if # self.treeTypes > = TreePlantManager.MAX_NUM_TYPES then\n        Logging.warning( "Unable to register tree type %q, maximum number of tree types(%d) reached" , name, TreePlantManager.MAX_NUM_TYPES)\n        return nil\n    end\n\n    if isBaseType and self.nameToTreeType[name] ~ = nil then\n        Logging.warning( "TreeType %q already exists.Ignoring treeType!" , name)\n        return nil\n    end\n\n    local treeType = self.nameToTreeType[name]\n    if treeType = = nil then\n        treeType = { }\n        treeType.name = name\n        treeType.title = title\n        treeType.index = # self.treeTypes + 1\n        treeType.splitTypeIndex = splitTypeIndex\n\n        table.insert( self.treeTypes, treeType)\n        self.indexToTreeType[treeType.index] = treeType\n        self.nameToTreeType[name] = treeType\n        self.splitTypeIndexToTreeType[splitTypeIndex] = treeType\n    end\n\n    treeType.stages = stages\n    treeType.growthTimeHours = growthTimeHours\n    treeType.supportsPlanting = supportsPlanting\n    if supportsPlanting then\n        treeType.saplingPrice = saplingPrice\n    end\n\n    return treeType\nend\n\n'})}),"\n",(0,l.jsx)(n.h3,{id:"removeclienttree",children:"removeClientTree"}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Description"})}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Definition"})}),"\n",(0,l.jsxs)(n.blockquote,{children:["\n",(0,l.jsx)(n.p,{children:"removeClientTree()"}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,l.jsx)(n.table,{children:(0,l.jsx)(n.thead,{children:(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.th,{children:"any"}),(0,l.jsx)(n.th,{children:"serverSplitShapeFileId"})]})})}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Code"})}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-lua",children:"function TreePlantManager:removeClientTree(serverSplitShapeFileId)\n    if self.treesData ~ = nil then\n        self.treesData.clientTrees[serverSplitShapeFileId] = nil\n    end\nend\n\n"})}),"\n",(0,l.jsx)(n.h3,{id:"removingsplitshape",children:"removingSplitShape"}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Description"})}),"\n",(0,l.jsxs)(n.blockquote,{children:["\n",(0,l.jsx)(n.p,{children:"Remove any known state about a split shape"}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Definition"})}),"\n",(0,l.jsxs)(n.blockquote,{children:["\n",(0,l.jsx)(n.p,{children:"removingSplitShape()"}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,l.jsx)(n.table,{children:(0,l.jsx)(n.thead,{children:(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.th,{children:"any"}),(0,l.jsx)(n.th,{children:"shape"})]})})}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Code"})}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-lua",children:"function TreePlantManager:removingSplitShape(shape)\n    -- At this point the shape does not exist anymore!\n    self.activeDecayingSplitShapes[shape] = nil\nend\n\n"})}),"\n",(0,l.jsx)(n.h3,{id:"savetoxmlfile",children:"saveToXMLFile"}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Description"})}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Definition"})}),"\n",(0,l.jsxs)(n.blockquote,{children:["\n",(0,l.jsx)(n.p,{children:"saveToXMLFile()"}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,l.jsx)(n.table,{children:(0,l.jsx)(n.thead,{children:(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.th,{children:"any"}),(0,l.jsx)(n.th,{children:"xmlFilename"})]})})}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Code"})}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-lua",children:'function TreePlantManager:saveToXMLFile(xmlFilename)\n\n    self:cleanupDeletedTrees()\n\n    --save mappings to xml\n    local xmlFile = createXMLFile( "treePlantXML" , xmlFilename, "treePlant" )\n    if xmlFile = = 0 then\n        Logging.error( "Failed to create xml file %q" , xmlFilename)\n        return false\n    end\n\n    local function saveTreeToXML(tree, xmlIndex)\n        local treeTypeDesc = self:getTreeTypeDescFromIndex(tree.treeType)\n        local treeTypeName = treeTypeDesc.name\n        local isGrowing = (getChildAt(tree.node, 0 ) = = tree.origSplitShape)\n        local splitShapeFileId = tree.splitShapeFileId or - 1\n\n        local treeKey = string.format( "treePlant.tree(%d)" , xmlIndex)\n        setXMLString(xmlFile, treeKey .. "#treeType" , treeTypeName)\n        setXMLString(xmlFile, treeKey .. "#position" , string.format( "%.4f %.4f %.4f" , tree.x, tree.y, tree.z))\n        setXMLString(xmlFile, treeKey .. "#rotation" , string.format( "%.4f %.4f %.4f" , math.deg(tree.rx), math.deg(tree.ry), math.deg(tree.rz)))\n        setXMLInt(xmlFile, treeKey .. "#growthStateI" , tree.growthStateI)\n        if tree.variationIndex ~ = 1 then -- 1 is the default set on load\n            setXMLInt(xmlFile, treeKey .. "#variationIndex" , tree.variationIndex)\n        end\n        if tree.nextGrowthTargetHour ~ = nil then\n            setXMLFloat(xmlFile, treeKey .. "#nextGrowthTargetHour" , tree.nextGrowthTargetHour)\n        end\n        setXMLBool(xmlFile, treeKey .. "#isGrowing" , isGrowing)\n        setXMLInt(xmlFile, treeKey .. "#splitShapeFileId" , splitShapeFileId)\n    end\n\n    local index = 0\n    for _, tree in ipairs( self.treesData.growingTrees) do\n        saveTreeToXML(tree, index)\n        index = index + 1\n    end\n\n    for _, tree in ipairs( self.treesData.splitTrees) do\n        saveTreeToXML(tree, index)\n        index = index + 1\n    end\n\n    saveXMLFile(xmlFile)\n    delete(xmlFile)\n\n    return true\nend\n\n'})}),"\n",(0,l.jsx)(n.h3,{id:"setsplitshapeleafscaleandvariation",children:"setSplitShapeLeafScaleAndVariation"}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Description"})}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Definition"})}),"\n",(0,l.jsxs)(n.blockquote,{children:["\n",(0,l.jsx)(n.p,{children:"setSplitShapeLeafScaleAndVariation()"}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,l.jsxs)(n.table,{children:[(0,l.jsx)(n.thead,{children:(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.th,{children:"any"}),(0,l.jsx)(n.th,{children:"shape"})]})}),(0,l.jsxs)(n.tbody,{children:[(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{children:"any"}),(0,l.jsx)(n.td,{children:"scale"})]}),(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{children:"any"}),(0,l.jsx)(n.td,{children:"variation"})]})]})]}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Code"})}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-lua",children:'function TreePlantManager:setSplitShapeLeafScaleAndVariation(shape, scale, variation)\n    -- Splitshape is a trunk, and possibly has attachments. (Engine removes attachments when needed)\n    setShaderParameterRecursive(shape, "windSnowLeafScale" , 0 , 0 , scale, variation, false )\nend\n\n'})}),"\n",(0,l.jsx)(n.h3,{id:"unloadmapdata",children:"unloadMapData"}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Description"})}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Definition"})}),"\n",(0,l.jsxs)(n.blockquote,{children:["\n",(0,l.jsx)(n.p,{children:"unloadMapData()"}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Code"})}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-lua",children:'function TreePlantManager:unloadMapData()\n    for i3dFilename, requestId in pairs( self.treeFileCache) do\n        g_i3DManager:releaseSharedI3DFile(requestId)\n        self.treeFileCache[i3dFilename] = true\n    end\n\n    removeConsoleCommand( "gsTreeCut" )\n    removeConsoleCommand( "gsTreeAdd" )\n    removeConsoleCommand( "gsTreePlant" )\n    removeConsoleCommand( "gsTreeLoadAll" )\n    removeConsoleCommand( "gsTreeRemove" )\n    removeConsoleCommand( "gsTreeDebug" )\n\n    self:deleteTreesData()\n\n    g_messageCenter:unsubscribe(MessageType.CURRENT_MISSION_START, self )\n\n    TreePlantManager:superClass().unloadMapData( self )\nend\n\n'})}),"\n",(0,l.jsx)(n.h3,{id:"updatetrees",children:"updateTrees"}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Description"})}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Definition"})}),"\n",(0,l.jsxs)(n.blockquote,{children:["\n",(0,l.jsx)(n.p,{children:"updateTrees()"}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,l.jsxs)(n.table,{children:[(0,l.jsx)(n.thead,{children:(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.th,{children:"any"}),(0,l.jsx)(n.th,{children:"dt"})]})}),(0,l.jsx)(n.tbody,{children:(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{children:"any"}),(0,l.jsx)(n.td,{children:"dtGame"})]})})]}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Code"})}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-lua",children:'function TreePlantManager:updateTrees(dt, dtGame)\n    local treesData = self.treesData\n    treesData.updateDtGame = treesData.updateDtGame + dtGame\n\n    -- update all 60 ingame minutes\n    if treesData.updateDtGame > 1000 * 60 * 60 then\n        self:cleanupDeletedTrees()\n\n        treesData.updateDtGame = 0\n\n        local currentMonotonicHour = g_currentMission.environment:getMonotonicHour()\n\n        local numGrowingTrees = #treesData.growingTrees\n        local i = 1\n        while i < = numGrowingTrees do -- TODO:time slice?\n            local tree = treesData.growingTrees[i]\n\n            -- Check if the tree has been cut in the mean time\n                if getChildAt(tree.node, 0 ) ~ = tree.origSplitShape then\n                    -- The tree has been cut, it will not grow anymore\n\n                    if self.debugActive then\n                        Logging.info( "Removing cut tree %d from growing trees" , tree.node)\n                    end\n\n                    table.remove(treesData.growingTrees, i)\n                    numGrowingTrees = numGrowingTrees - 1\n                    tree.origSplitShape = nil\n                    table.insert(treesData.splitTrees, tree)\n                else\n                        local treeTypeDesc = self.indexToTreeType[tree.treeType]\n                        local numStages = #treeTypeDesc.stages\n\n                        if currentMonotonicHour > tree.nextGrowthTargetHour then\n\n                            local growthStateNew = math.min(tree.growthStateI + 1 , #treeTypeDesc.stages)\n\n                            if self.debugActive then\n                                Logging.info( "growing tree %s from stage %d to %d" , treeTypeDesc.name, tree.growthStateI, growthStateNew)\n                            end\n\n                            tree.growthStateI = growthStateNew\n                            if tree.growthStateI > = numStages then\n                                -- tree is fully grown\n                                tree.nextGrowthTargetHour = nil\n                            else\n                                    -- setup next target hour for growth\n                                        tree.nextGrowthTargetHour = currentMonotonicHour + treeTypeDesc.growthTimeHours\n                                    end\n\n                                    -- Delete the old tree\n                                    delete(tree.node)\n\n                                    if not tree.hasSplitShapes then\n                                        self.numTreesWithoutSplits = math.max( self.numTreesWithoutSplits - 1 , 0 )\n                                        treesData.numTreesWithoutSplits = math.max(treesData.numTreesWithoutSplits - 1 , 0 )\n                                    end\n\n                                    -- Create the new tree\n                                    local variations = treeTypeDesc.stages[tree.growthStateI]\n                                    tree.variationIndex = math.random( 1 , #variations)\n\n                                    local treeId, splitShapeFileId = self:loadTreeNode(treeTypeDesc, tree.x, tree.y, tree.z, tree.rx, tree.ry, tree.rz, tree.growthStateI, tree.variationIndex, - 1 )\n\n                                    g_server:broadcastEvent(TreeGrowEvent.new(tree.treeType, tree.x, tree.y, tree.z, tree.rx, tree.ry, tree.rz, tree.growthStateI, tree.variationIndex, splitShapeFileId, tree.splitShapeFileId))\n\n                                    tree.origSplitShape = getChildAt(treeId, 0 )\n                                    tree.splitShapeFileId = splitShapeFileId\n                                    tree.hasSplitShapes = getFileIdHasSplitShapes(splitShapeFileId)\n                                    tree.node = treeId\n\n                                    -- update collision map\n                                    local range = 2.5\n                                    local x, _, z = getWorldTranslation(treeId)\n                                    g_densityMapHeightManager:setCollisionMapAreaDirty(x - range, z - range, x + range, z + range, true )\n                                    g_currentMission.aiSystem:setAreaDirty(x - range, x + range, z - range, z + range)\n\n                                    if not tree.hasSplitShapes then\n                                        self.numTreesWithoutSplits = self.numTreesWithoutSplits + 1\n                                        treesData.numTreesWithoutSplits = treesData.numTreesWithoutSplits + 1\n                                    end\n                                end\n\n                                if tree.growthStateI > = numStages then\n\n                                    if self.debugActive then\n                                        Logging.info( "Removing fully grown tree %d(%s stage %d) from growth" , tree.node, treeTypeDesc.name, tree.growthStateI)\n                                    end\n\n                                    -- Reached max grow level, can\'t grow any more\n                                    table.remove(treesData.growingTrees, i)\n                                    numGrowingTrees = numGrowingTrees - 1\n                                    tree.origSplitShape = nil\n                                    table.insert(treesData.splitTrees, tree)\n                                else\n                                        i = i + 1\n                                    end\n                                end\n                            end\n                        end\n\n                        -- update cut joints of recently cut trees making it fall over\n                        local curTime = g_currentMission.time\n                        for joint in pairs(treesData.treeCutJoints) do\n                            if joint.destroyTime < = curTime or not entityExists(joint.shape) then\n                                removeJoint(joint.jointIndex)\n                                treesData.treeCutJoints[joint] = nil\n                            else\n                                    local x1,y1,z1 = localDirectionToWorld(joint.shape, joint.lnx, joint.lny, joint.lnz)\n                                    if x1 * joint.nx + y1 * joint.ny + z1 * joint.nz < joint.maxCosAngle then\n                                        removeJoint(joint.jointIndex)\n                                        treesData.treeCutJoints[joint] = nil\n                                    end\n                                end\n                            end\n\n                            -- process enqueued tree trunks for cutting\n                                if # self.loadTreeTrunkDatas > 0 then\n                                    for i = # self.loadTreeTrunkDatas, 1 , - 1 do\n                                        local loadTreeTrunkData = self.loadTreeTrunkDatas[i]\n\n                                        loadTreeTrunkData.framesLeft = loadTreeTrunkData.framesLeft - 1\n                                        -- first cut and remove upper part of tree\n                                        if loadTreeTrunkData.framesLeft = = 1 then\n                                            local nx,ny,nz = 0 , 1 , 0\n                                            local yx,yy,yz = - 1 , 0 , 0\n                                            local x,y,z = loadTreeTrunkData.x + 1 , loadTreeTrunkData.y, loadTreeTrunkData.z - 1\n\n                                            loadTreeTrunkData.parts = { }\n\n                                            local shape = loadTreeTrunkData.shape\n                                            if shape ~ = nil and shape ~ = 0 then\n                                                loadTreeTrunkData.shapeBeingCut = shape\n\n                                                --#debug if self.debugActive then\n                                                    --#debug local splitType = getSplitType(shape)\n                                                    --#debug Logging.devInfo("splitShape %s splitType = %s(%s)", shape, splitType, g_splitShapeManager:getSplitTypeNameByIndex(splitType))\n                                                    --#debug end\n\n                                                    splitShape(shape, x,y + loadTreeTrunkData.length + loadTreeTrunkData.offset,z, nx,ny,nz, yx,yy,yz, 4 , 4 , "cutTreeTrunkCallback" , loadTreeTrunkData)\n                                                    self:removingSplitShape(shape)\n                                                    for _, p in pairs(loadTreeTrunkData.parts) do\n                                                        if p.isAbove then\n                                                            delete(p.shape)\n                                                        else\n                                                                loadTreeTrunkData.shape = p.shape\n                                                            end\n                                                        end\n                                                    end\n\n                                                    -- second cut lower part to get final length\n                                                elseif loadTreeTrunkData.framesLeft = = 0 then\n                                                        local nx,ny,nz = 0 , 1 , 0\n                                                        local yx,yy,yz = - 1 , 0 , 0\n                                                        local x,y,z = loadTreeTrunkData.x + 1 , loadTreeTrunkData.y, loadTreeTrunkData.z - 1\n\n                                                        loadTreeTrunkData.parts = { }\n                                                        local shape = loadTreeTrunkData.shape\n                                                        if shape ~ = nil and shape ~ = 0 then\n\n                                                            --#debug if self.debugActive then\n                                                                --#debug local splitType = getSplitType(shape)\n                                                                --#debug Logging.devInfo("splitShape %s splitType = %s(%s)", shape, splitType, g_splitShapeManager:getSplitTypeNameByIndex(splitType))\n                                                                --#debug end\n\n                                                                local cutDiameter = 2.5\n                                                                splitShape(shape, x,y + loadTreeTrunkData.offset,z, nx,ny,nz, yx,yy,yz, cutDiameter * 2 , cutDiameter * 2 , "cutTreeTrunkCallback" , loadTreeTrunkData)\n\n                                                                if loadTreeTrunkData.useOnlyStump then\n                                                                    for _, p in pairs(loadTreeTrunkData.parts) do\n                                                                        if not p.isBelow then\n                                                                            delete(p.shape)\n                                                                        end\n                                                                    end\n                                                                else\n                                                                        local finalShape = nil\n                                                                        for _, p in pairs(loadTreeTrunkData.parts) do\n                                                                            if p.isBelow then\n                                                                                delete(p.shape)\n                                                                            else\n                                                                                    finalShape = p.shape\n                                                                                end\n                                                                            end\n                                                                            -- set correct rotation of final chunk\n                                                                            if finalShape ~ = nil then\n                                                                                if loadTreeTrunkData.delimb then\n                                                                                    removeSplitShapeAttachments(finalShape, x,y + loadTreeTrunkData.offset,z, nx,ny,nz, yx,yy,yz, loadTreeTrunkData.length, 4 , 4 )\n                                                                                end\n\n                                                                                removeFromPhysics(finalShape)\n                                                                                setDirection(finalShape, 0 , - 1 , 0 , loadTreeTrunkData.dirX, loadTreeTrunkData.dirY, loadTreeTrunkData.dirZ)\n                                                                                addToPhysics(finalShape)\n                                                                            else\n                                                                                    Logging.error( "Unable to cut tree trunk with length \'%s\'.Try using a different value" , loadTreeTrunkData.length)\n                                                                                end\n                                                                            end\n                                                                        end\n\n                                                                        table.remove( self.loadTreeTrunkDatas, i)\n                                                                    end\n                                                                end\n                                                            end\n\n                                                            if self.commandCutTreeData ~ = nil then\n                                                                if # self.commandCutTreeData.trees > 0 then\n                                                                    local treeId = self.commandCutTreeData.trees[ 1 ]\n\n                                                                    local x, y, z = getWorldTranslation(treeId)\n                                                                    local localX, localY, localZ = worldToLocal(treeId, x, y + 0.5 , z)\n                                                                    local cx, cy, cz = localToWorld(treeId, localX - 2 , localY, localZ - 2 )\n                                                                    local nx, ny, nz = localDirectionToWorld(treeId, 0 , 1 , 0 )\n                                                                    local yx, yy, yz = localDirectionToWorld(treeId, 0 , 0 , 1 )\n\n                                                                    self.commandCutTreeData.shapeBeingCut = treeId\n                                                                    Logging.info( "Cut tree \'%s\' (%d left)" , getName(treeId), # self.commandCutTreeData.trees - 1 )\n                                                                    splitShape(treeId, cx, cy, cz, nx, ny, nz, yx, yy, yz, 4 , 4 , "onTreeCutCommandSplitCallback" , self )\n\n                                                                    table.remove( self.commandCutTreeData.trees, 1 )\n                                                                else\n                                                                        self.commandCutTreeData = nil\n                                                                    end\n                                                                end\n\n                                                                self.updateDecayDtGame = self.updateDecayDtGame + dtGame\n                                                                if self.updateDecayDtGame > TreePlantManager.DECAY_INTERVAL then\n                                                                    -- Update seasonal state of active split shapes\n                                                                    for shape, data in pairs( self.activeDecayingSplitShapes) do\n                                                                        if not entityExists(shape) then\n                                                                            self.activeDecayingSplitShapes[shape] = nil\n                                                                        elseif data.state > 0 then\n                                                                                local newState = math.max(data.state - TreePlantManager.DECAY_DURATION_INV * self.updateDecayDtGame, 0 )\n\n                                                                                self:setSplitShapeLeafScaleAndVariation(shape, newState, data.variation)\n                                                                                self.activeDecayingSplitShapes[shape].state = newState\n                                                                            end\n                                                                        end\n\n                                                                        self.updateDecayDtGame = 0\n                                                                    end\n                                                                end\n\n'})}),"\n",(0,l.jsx)(n.h3,{id:"writetoclientstream",children:"writeToClientStream"}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Description"})}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Definition"})}),"\n",(0,l.jsxs)(n.blockquote,{children:["\n",(0,l.jsx)(n.p,{children:"writeToClientStream()"}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,l.jsx)(n.table,{children:(0,l.jsx)(n.thead,{children:(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.th,{children:"any"}),(0,l.jsx)(n.th,{children:"streamId"})]})})}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Code"})}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-lua",children:"function TreePlantManager:writeToClientStream(streamId)\n    local treesData = self.treesData\n\n    self:cleanupDeletedTrees()\n\n    local numTrees = #treesData.growingTrees + #treesData.splitTrees\n\n    streamWriteInt32(streamId, numTrees)\n    for _, tree in ipairs(treesData.growingTrees) do\n        streamWriteUInt8(streamId, tree.treeType)\n        streamWriteFloat32(streamId, tree.x)\n        streamWriteFloat32(streamId, tree.y)\n        streamWriteFloat32(streamId, tree.z)\n        streamWriteFloat32(streamId, tree.rx)\n        streamWriteFloat32(streamId, tree.ry)\n        streamWriteFloat32(streamId, tree.rz)\n        streamWriteUIntN(streamId, tree.growthStateI, TreePlantManager.STAGE_NUM_BITS)\n        streamWriteUIntN(streamId, tree.variationIndex, TreePlantManager.VARIATION_NUM_BITS)\n        streamWriteInt32(streamId, tree.splitShapeFileId)\n    end\n    for _, tree in ipairs(treesData.splitTrees) do\n        streamWriteUInt8(streamId, tree.treeType)\n        streamWriteFloat32(streamId, tree.x)\n        streamWriteFloat32(streamId, tree.y)\n        streamWriteFloat32(streamId, tree.z)\n        streamWriteFloat32(streamId, tree.rx)\n        streamWriteFloat32(streamId, tree.ry)\n        streamWriteFloat32(streamId, tree.rz)\n        streamWriteUIntN(streamId, tree.growthStateI, TreePlantManager.STAGE_NUM_BITS)\n        streamWriteUIntN(streamId, tree.variationIndex, TreePlantManager.VARIATION_NUM_BITS)\n        streamWriteInt32(streamId, tree.splitShapeFileId)\n    end\nend\n\n"})})]})}function h(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,l.jsx)(n,{...e,children:(0,l.jsx)(c,{...e})}):c(e)}}}]);