"use strict";(globalThis.webpackChunkfs25_community_luadoc=globalThis.webpackChunkfs25_community_luadoc||[]).push([[94623],{28453(e,n,t){t.d(n,{R:()=>a,x:()=>l});var s=t(96540);const r={},i=s.createContext(r);function a(e){const n=s.useContext(i);return s.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:a(e.components),s.createElement(i.Provider,{value:n},e.children)}},75810(e,n,t){t.r(n),t.d(n,{assets:()=>d,contentTitle:()=>l,default:()=>o,frontMatter:()=>a,metadata:()=>s,toc:()=>c});const s=JSON.parse('{"id":"script/Handtools/PlayerTargeter","title":"PlayerTargeter","description":"PlayerTargeter","source":"@site/../docs/script/Handtools/PlayerTargeter.md","sourceDirName":"script/Handtools","slug":"/script/Handtools/PlayerTargeter","permalink":"/FS25-Community-LUADOC/script/Handtools/PlayerTargeter","draft":false,"unlisted":false,"tags":[],"version":"current","lastUpdatedAt":1767161192000,"frontMatter":{},"sidebar":"docsSidebar","previous":{"title":"HandToolUtil","permalink":"/FS25-Community-LUADOC/script/Handtools/HandToolUtil"},"next":{"title":"ContextActionDisplay","permalink":"/FS25-Community-LUADOC/script/Hud/ContextActionDisplay"}}');var r=t(74848),i=t(28453);const a={},l=void 0,d={},c=[{value:"PlayerTargeter",id:"playertargeter",level:2},{value:"addFilterToTargetType",id:"addfiltertotargettype",level:3},{value:"addTargetType",id:"addtargettype",level:3},{value:"debugDraw",id:"debugdraw",level:3},{value:"getClosestTargetedNodeFromType",id:"getclosesttargetednodefromtype",level:3},{value:"getHasTargetedKey",id:"gethastargetedkey",level:3},{value:"getLastLookRay",id:"getlastlookray",level:3},{value:"new",id:"new",level:3},{value:"recalculateCombinedTargetMask",id:"recalculatecombinedtargetmask",level:3},{value:"removeTargetType",id:"removetargettype",level:3},{value:"tryAddTargetWithMask",id:"tryaddtargetwithmask",level:3},{value:"update",id:"update",level:3}];function h(e){const n={a:"a",blockquote:"blockquote",code:"code",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,i.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.h2,{id:"playertargeter",children:"PlayerTargeter"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Description"})}),"\n",(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsx)(n.p,{children:"Exists for the client's player, and handles raycasting and finding specific objects for them to interact with."}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Functions"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"#addfiltertotargettype",children:"addFilterToTargetType"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"#addtargettype",children:"addTargetType"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"#debugdraw",children:"debugDraw"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"#getclosesttargetednodefromtype",children:"getClosestTargetedNodeFromType"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"#gethastargetedkey",children:"getHasTargetedKey"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"#getlastlookray",children:"getLastLookRay"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"#new",children:"new"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"#recalculatecombinedtargetmask",children:"recalculateCombinedTargetMask"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"#removetargettype",children:"removeTargetType"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"#tryaddtargetwithmask",children:"tryAddTargetWithMask"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"#update",children:"update"})}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"addfiltertotargettype",children:"addFilterToTargetType"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Description"})}),"\n",(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsx)(n.p,{children:"Adds the given filter function to the given target type."}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Definition"})}),"\n",(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsx)(n.p,{children:"addFilterToTargetType(any targetKey, function filterFunction)"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,r.jsxs)(n.table,{children:[(0,r.jsx)(n.thead,{children:(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.th,{children:"any"}),(0,r.jsx)(n.th,{children:"targetKey"}),(0,r.jsx)(n.th,{children:"The key of the objects to target."})]})}),(0,r.jsx)(n.tbody,{children:(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"function"}),(0,r.jsx)(n.td,{children:"filterFunction"}),(0,r.jsx)(n.td,{children:"A function that is called for each raycast object that matches the mask and helps filter out unwanted items. bool function(hitObject, x, y, z)"})]})})]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Code"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-lua",children:'function PlayerTargeter:addFilterToTargetType(targetKey, filterFunction)\n\n    --#debug Assert.isType(filterFunction, "function", "Filter function must be a function!")\n        --#debug Assert.isTrue(self:getHasTargetedKey(targetKey), "Cannot add filter function to key that does not exist!")\n\n            -- Get the mask for the given target.\n                local targetedMask = self.targetedMasks[targetKey]\n                table.insert(targetedMask.filterFunctions, filterFunction)\n            end\n\n'})}),"\n",(0,r.jsx)(n.h3,{id:"addtargettype",children:"addTargetType"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Description"})}),"\n",(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsx)(n.p,{children:"Adds the given target type to the targeter, so that the raycasts will include objects with these collision masks."}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Definition"})}),"\n",(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsx)(n.p,{children:"addTargetType(any targetKey, CollisionFlag targetMask, float? minDistance, float maxDistance)"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,r.jsxs)(n.table,{children:[(0,r.jsx)(n.thead,{children:(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.th,{children:"any"}),(0,r.jsx)(n.th,{children:"targetKey"}),(0,r.jsx)(n.th,{children:"An object used as a key to later retrieve or remove the target type."})]})}),(0,r.jsxs)(n.tbody,{children:[(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"CollisionFlag"}),(0,r.jsx)(n.td,{children:"targetMask"}),(0,r.jsx)(n.td,{children:"The mask of the objects to target."})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"float?"}),(0,r.jsx)(n.td,{children:"minDistance"}),(0,r.jsx)(n.td,{children:"The optional minimum distance that an object of this type can be targeted. Defaults to 0."})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"float"}),(0,r.jsx)(n.td,{children:"maxDistance"}),(0,r.jsx)(n.td,{children:"The maximum distance that an object of this type can be targeted."})]})]})]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Code"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-lua",children:'function PlayerTargeter:addTargetType(targetKey, targetMask, minDistance, maxDistance)\n\n    --#debug Assert.isNilOrType(minDistance, "number", "Minimum distance must be a number or nil!")\n    --#debug Assert.isType(maxDistance, "number", "Maximum distance must be a number!")\n\n    -- Check that the key is not already being targeted.\n    if self:getHasTargetedKey(targetKey) then\n        return\n    end\n\n    -- Set the highest max distance of the ray based on the given distance and the current max.\n    self.highestMaxDistance = math.max( self.highestMaxDistance, maxDistance)\n\n    -- Create the targeted mask table.\n    self.targetedMasks[targetKey] = { key = targetKey, mask = targetMask, minDistance = minDistance or 0 , maxDistance = maxDistance, filterFunctions = { } }\n\n    -- Recalculate the combined mask to use for the ray.\n        self:recalculateCombinedTargetMask()\n    end\n\n'})}),"\n",(0,r.jsx)(n.h3,{id:"debugdraw",children:"debugDraw"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Description"})}),"\n",(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsx)(n.p,{children:"Displays the debug information."}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Definition"})}),"\n",(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsx)(n.p,{children:"debugDraw(float x, float y, float textSize)"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,r.jsxs)(n.table,{children:[(0,r.jsx)(n.thead,{children:(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.th,{children:"float"}),(0,r.jsx)(n.th,{children:"x"}),(0,r.jsx)(n.th,{children:"The x position on the screen to begin drawing the values."})]})}),(0,r.jsxs)(n.tbody,{children:[(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"float"}),(0,r.jsx)(n.td,{children:"y"}),(0,r.jsx)(n.td,{children:"The y position on the screen to begin drawing the values."})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"float"}),(0,r.jsx)(n.td,{children:"textSize"}),(0,r.jsx)(n.td,{children:"The height of the text."})]})]})]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Return Values"})}),"\n\n\n\n\n\n\n\n\n",(0,r.jsx)(n.table,{children:(0,r.jsx)(n.thead,{children:(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.th,{children:"float"}),(0,r.jsx)(n.th,{children:"y"}),(0,r.jsx)(n.th,{children:"The y position on the screen after the entire debug info was drawn."})]})})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Code"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-lua",children:'function PlayerTargeter:debugDraw(x, y, textSize)\n\n    -- Render the header.\n    y = DebugUtil.renderTextLine(x, y, textSize * 1.5 , "Targeter" , nil , true )\n\n    local combinedMaskName = CollisionFlag.getFlagsStringFromMask( self.combinedTargetMask)\n    y = DebugUtil.renderTextLine(x, y, textSize, string.format( "Combined mask: %q" , combinedMaskName), nil , true )\n    y = DebugUtil.renderTextLine(x, y, textSize, "Masks:" , nil , true )\n\n    for key, targetedMask in pairs( self.targetedMasks) do\n        local maskNode = self:getClosestTargetedNodeFromType(key)\n        local nodeName = (maskNode ~ = nil and entityExists(maskNode)) and getName(maskNode) or "none"\n\n        local maskName = CollisionFlag.getFlagsStringFromMask(targetedMask.mask)\n\n        y = DebugUtil.renderTextLine(x, y, textSize, string.format( "Mask %q: %q" , maskName, nodeName))\n    end\n\n    return y\nend\n\n'})}),"\n",(0,r.jsx)(n.h3,{id:"getclosesttargetednodefromtype",children:"getClosestTargetedNodeFromType"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Description"})}),"\n",(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsx)(n.p,{children:"Gets the last found node from the given target mask, or nil if none was found."}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Definition"})}),"\n",(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsx)(n.p,{children:"getClosestTargetedNodeFromType(any targetKey)"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n",(0,r.jsx)(n.table,{children:(0,r.jsx)(n.thead,{children:(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.th,{children:"any"}),(0,r.jsx)(n.th,{children:"targetKey"}),(0,r.jsx)(n.th,{children:"The key of the objects to stop targeting."})]})})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Return Values"})}),"\n\n\n\n\n\n\n\n\n",(0,r.jsx)(n.table,{children:(0,r.jsx)(n.thead,{children:(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.th,{children:"any"}),(0,r.jsx)(n.th,{children:"node"}),(0,r.jsx)(n.th,{children:"The last found node from the given target mask, or nil if none was found."})]})})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Code"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-lua",children:"function PlayerTargeter:getClosestTargetedNodeFromType(targetKey)\n    local closestTarget = self.closestTargetsByKey[targetKey]\n    return closestTarget ~ = nil and closestTarget.node or nil\nend\n\n"})}),"\n",(0,r.jsx)(n.h3,{id:"gethastargetedkey",children:"getHasTargetedKey"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Description"})}),"\n",(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsx)(n.p,{children:"Returns true if the given key is targeted; otherwise false."}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Definition"})}),"\n",(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsx)(n.p,{children:"getHasTargetedKey(CollisionFlag targetKey)"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n",(0,r.jsx)(n.table,{children:(0,r.jsx)(n.thead,{children:(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.th,{children:"CollisionFlag"}),(0,r.jsx)(n.th,{children:"targetKey"}),(0,r.jsx)(n.th,{children:"The key of the objects to target."})]})})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Return Values"})}),"\n\n\n\n\n\n\n\n\n",(0,r.jsx)(n.table,{children:(0,r.jsx)(n.thead,{children:(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.th,{children:"CollisionFlag"}),(0,r.jsx)(n.th,{children:"hasTargetedMask"}),(0,r.jsx)(n.th,{children:"True if the mask is targeted; otherwise false."})]})})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Code"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-lua",children:"function PlayerTargeter:getHasTargetedKey(targetKey)\n    return self.targetedMasks[targetKey] ~ = nil\nend\n\n"})}),"\n",(0,r.jsx)(n.h3,{id:"getlastlookray",children:"getLastLookRay"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Description"})}),"\n",(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsx)(n.p,{children:"Gets the last look ray components."}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Definition"})}),"\n",(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsx)(n.p,{children:"getLastLookRay()"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Return Values"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,r.jsxs)(n.table,{children:[(0,r.jsx)(n.thead,{children:(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.th,{children:"CollisionFlag"}),(0,r.jsx)(n.th,{children:"lastRayX"}),(0,r.jsx)(n.th,{children:"The origin's x position."})]})}),(0,r.jsxs)(n.tbody,{children:[(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"CollisionFlag"}),(0,r.jsx)(n.td,{children:"lastRayY"}),(0,r.jsx)(n.td,{children:"The origin's y position."})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"CollisionFlag"}),(0,r.jsx)(n.td,{children:"lastRayZ"}),(0,r.jsx)(n.td,{children:"The origin's z position."})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"CollisionFlag"}),(0,r.jsx)(n.td,{children:"lastRayDirectionX"}),(0,r.jsx)(n.td,{children:"The ray's x direction."})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"CollisionFlag"}),(0,r.jsx)(n.td,{children:"lastRayDirectionY"}),(0,r.jsx)(n.td,{children:"The ray's y direction."})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"CollisionFlag"}),(0,r.jsx)(n.td,{children:"lastRayDirectionZ"}),(0,r.jsx)(n.td,{children:"The ray's z direction."})]})]})]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Code"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-lua",children:"function PlayerTargeter:getLastLookRay()\n    return self.lastRayX, self.lastRayY, self.lastRayZ, self.lastRayDirectionX, self.lastRayDirectionY, self.lastRayDirectionZ\nend\n\n"})}),"\n",(0,r.jsx)(n.h3,{id:"new",children:"new"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Description"})}),"\n",(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsx)(n.p,{children:"Creates a new targeter for the given player."}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Definition"})}),"\n",(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsx)(n.p,{children:"new(Player player)"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n",(0,r.jsx)(n.table,{children:(0,r.jsx)(n.thead,{children:(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.th,{children:"Player"}),(0,r.jsx)(n.th,{children:"player"}),(0,r.jsx)(n.th,{children:"The player for whom the targeter is made."})]})})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Return Values"})}),"\n\n\n\n\n\n\n\n\n",(0,r.jsx)(n.table,{children:(0,r.jsx)(n.thead,{children:(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.th,{children:"Player"}),(0,r.jsx)(n.th,{children:"self"}),(0,r.jsx)(n.th,{children:"The created instance."})]})})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Code"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-lua",children:"function PlayerTargeter.new(player)\n\n    -- Create the instance.\n    local self = setmetatable( { } , PlayerTargeter _mt)\n\n    -- The player that this targeter belongs to.\n    self.player = player\n\n    -- The pool of unused target tables.\n    self.pooledTargets = ObjectPool.new()\n\n    -- The total combined mask.\n    self.combinedTargetMask = 0\n\n    -- The collection of specifically targeted masks.\n    self.targetedMasks = { }\n\n    self.closestTargetsByKey = { }\n    self.currentTargetsByKey = { }\n\n    -- The highest maximum distance that is targeted.\n    self.highestMaxDistance = 0\n\n    -- The components of the last ray that was fired by this targeter.\n    self.lastRayX, self.lastRayY, self.lastRayZ = nil , nil , nil\n    self.lastRayDirectionX, self.lastRayDirectionY, self.lastRayDirectionZ = nil , nil , nil\n\n    -- Return the created instance.\n    return self\nend\n\n"})}),"\n",(0,r.jsx)(n.h3,{id:"recalculatecombinedtargetmask",children:"recalculateCombinedTargetMask"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Description"})}),"\n",(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsx)(n.p,{children:"Resets and recalculates the combined target mask using all targeted masks."}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Definition"})}),"\n",(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsx)(n.p,{children:"recalculateCombinedTargetMask()"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Code"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-lua",children:"function PlayerTargeter:recalculateCombinedTargetMask()\n    self.combinedTargetMask = 0\n    for _, targetedMask in pairs( self.targetedMasks) do\n        self.combinedTargetMask = bit32.bor( self.combinedTargetMask, targetedMask.mask)\n    end\nend\n\n"})}),"\n",(0,r.jsx)(n.h3,{id:"removetargettype",children:"removeTargetType"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Description"})}),"\n",(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsx)(n.p,{children:"Removes the given target type from this targeter."}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Definition"})}),"\n",(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsx)(n.p,{children:"removeTargetType(any targetKey)"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n",(0,r.jsx)(n.table,{children:(0,r.jsx)(n.thead,{children:(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.th,{children:"any"}),(0,r.jsx)(n.th,{children:"targetKey"}),(0,r.jsx)(n.th,{children:"The key of the objects to stop targeting."})]})})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Code"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-lua",children:"function PlayerTargeter:removeTargetType(targetKey)\n\n    -- Remove the target from the collection.\n    self.targetedMasks[targetKey] = nil\n\n    -- Recalculate the combined target mask and maximum distance.\n    self:recalculateCombinedTargetMask()\n    self.highestMaxDistance = 0\n    for _, targetedMask in pairs( self.targetedMasks) do\n        self.highestMaxDistance = math.max( self.highestMaxDistance, targetedMask.maxDistance)\n    end\nend\n\n"})}),"\n",(0,r.jsx)(n.h3,{id:"tryaddtargetwithmask",children:"tryAddTargetWithMask"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Description"})}),"\n",(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsx)(n.p,{children:"Attempts to add the given information to the given target mask's target."}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Definition"})}),"\n",(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsx)(n.p,{children:"tryAddTargetWithMask(entityId hitNode, float x, float y, float z, table targetedMask, float distance)"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,r.jsxs)(n.table,{children:[(0,r.jsx)(n.thead,{children:(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.th,{children:"entityId"}),(0,r.jsx)(n.th,{children:"hitNode"}),(0,r.jsx)(n.th,{children:"The node that was hit."})]})}),(0,r.jsxs)(n.tbody,{children:[(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"float"}),(0,r.jsx)(n.td,{children:"x"}),(0,r.jsx)(n.td,{children:"The hit x position."})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"float"}),(0,r.jsx)(n.td,{children:"y"}),(0,r.jsx)(n.td,{children:"The hit y position."})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"float"}),(0,r.jsx)(n.td,{children:"z"}),(0,r.jsx)(n.td,{children:"The hit z position."})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"table"}),(0,r.jsx)(n.td,{children:"targetedMask"}),(0,r.jsx)(n.td,{children:"The targeted mask table to attempt to add to."})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"float"}),(0,r.jsx)(n.td,{children:"distance"}),(0,r.jsx)(n.td,{children:"The distance of the ray."})]})]})]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Code"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-lua",children:"function PlayerTargeter:tryAddTargetWithMask(hitNode, x, y, z, targetedMask, distance)\n\n    -- If the distance is greater than the max distance or the hit node does not have the right mask, do nothing.\n        if distance > targetedMask.maxDistance or distance < targetedMask.minDistance or not CollisionFlag.getHasGroupFlagSet(hitNode, targetedMask.mask) then\n            return\n        end\n\n        -- If the ray already hit something with this mask that's closer, check the distances.If the hit object is further away than the existing one, do nothing.\n            local existingClosestTarget = self.currentTargetsByKey[targetedMask.key]\n            if existingClosestTarget ~ = nil and existingClosestTarget.distance < distance then\n                return\n            end\n\n            -- If the any of the filter functions from the targeted mask returns false; do nothing.\n                for i, filterFunction in ipairs(targetedMask.filterFunctions) do\n                    if not filterFunction(hitNode, x, y, z) then\n                        return\n                    end\n                end\n\n                -- Set the closest target of the mask to the hit node.\n                local target = self.pooledTargets:getOrCreateNext()\n                target.x, target.y, target.z = x, y, z\n                target.node = hitNode\n                target.distance = distance\n                self.currentTargetsByKey[targetedMask.key] = target\n            end\n\n"})}),"\n",(0,r.jsx)(n.h3,{id:"update",children:"update"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Description"})}),"\n",(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsx)(n.p,{children:"Updates the targeter to find targeted objects."}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Definition"})}),"\n",(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsx)(n.p,{children:"update(float dt)"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n",(0,r.jsx)(n.table,{children:(0,r.jsx)(n.thead,{children:(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.th,{children:"float"}),(0,r.jsx)(n.th,{children:"dt"}),(0,r.jsx)(n.th,{children:"Delta time in ms."})]})})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Code"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-lua",children:'function PlayerTargeter:update(dt)\n    -- Get the position and direction from the player\'s camera, do nothing if it was invalid.\n        self.lastRayX, self.lastRayY, self.lastRayZ, self.lastRayDirectionX, self.lastRayDirectionY, self.lastRayDirectionZ = self.player:getLookRay()\n        if self.lastRayX = = nil then\n            return\n        end\n\n        self:resetState()\n\n        -- Cast the ray.\n        raycastAllAsync( self.lastRayX, self.lastRayY, self.lastRayZ, self.lastRayDirectionX, self.lastRayDirectionY, self.lastRayDirectionZ, self.highestMaxDistance, "raycastCallback" , self , self.combinedTargetMask)\n    end\n\n'})})]})}function o(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(h,{...e})}):h(e)}}}]);