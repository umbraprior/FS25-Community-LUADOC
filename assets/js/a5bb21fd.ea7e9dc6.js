"use strict";(globalThis.webpackChunkfs25_community_luadoc=globalThis.webpackChunkfs25_community_luadoc||[]).push([[34348],{28453(e,n,t){t.d(n,{R:()=>l,x:()=>a});var i=t(96540);const r={},s=i.createContext(r);function l(e){const n=i.useContext(s);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:l(e.components),i.createElement(s.Provider,{value:n},e.children)}},42015(e,n,t){t.r(n),t.d(n,{assets:()=>d,contentTitle:()=>a,default:()=>h,frontMatter:()=>l,metadata:()=>i,toc:()=>c});const i=JSON.parse('{"id":"script/Specializations/CrabSteering","title":"CrabSteering","description":"CrabSteering","source":"@site/../docs/script/Specializations/CrabSteering.md","sourceDirName":"script/Specializations","slug":"/script/Specializations/CrabSteering","permalink":"/FS25-Community-LUADOC/script/Specializations/CrabSteering","draft":false,"unlisted":false,"tags":[],"version":"current","lastUpdatedAt":1767161192000,"frontMatter":{},"sidebar":"docsSidebar","previous":{"title":"Cover","permalink":"/FS25-Community-LUADOC/script/Specializations/Cover"},"next":{"title":"Crawlers","permalink":"/FS25-Community-LUADOC/script/Specializations/Crawlers"}}');var r=t(74848),s=t(28453);const l={},a=void 0,d={},c=[{value:"CrabSteering",id:"crabsteering",level:2},{value:"actionEventSetCrabSteeringMode",id:"actioneventsetcrabsteeringmode",level:3},{value:"actionEventToggleCrabSteeringModes",id:"actioneventtogglecrabsteeringmodes",level:3},{value:"getAIAutomaticSteeringLookAheadDistance",id:"getaiautomaticsteeringlookaheaddistance",level:3},{value:"getCanBeSelected",id:"getcanbeselected",level:3},{value:"getCanToggleCrabSteering",id:"getcantogglecrabsteering",level:3},{value:"initSpecialization",id:"initspecialization",level:3},{value:"loadCrabSteeringModeFromXML",id:"loadcrabsteeringmodefromxml",level:3},{value:"loadWheelFromXML",id:"loadwheelfromxml",level:3},{value:"loadWheelsFromXML",id:"loadwheelsfromxml",level:3},{value:"onLoad",id:"onload",level:3},{value:"onPostLoad",id:"onpostload",level:3},{value:"onReadStream",id:"onreadstream",level:3},{value:"onReadUpdateStream",id:"onreadupdatestream",level:3},{value:"onRegisterActionEvents",id:"onregisteractionevents",level:3},{value:"onRegisterDashboardValueTypes",id:"onregisterdashboardvaluetypes",level:3},{value:"onUpdateTick",id:"onupdatetick",level:3},{value:"onWriteStream",id:"onwritestream",level:3},{value:"onWriteUpdateStream",id:"onwriteupdatestream",level:3},{value:"prerequisitesPresent",id:"prerequisitespresent",level:3},{value:"registerEventListeners",id:"registereventlisteners",level:3},{value:"registerFunctions",id:"registerfunctions",level:3},{value:"registerOverwrittenFunctions",id:"registeroverwrittenfunctions",level:3},{value:"registerSteeringModeXMLPaths",id:"registersteeringmodexmlpaths",level:3},{value:"saveToXMLFile",id:"savetoxmlfile",level:3},{value:"setCrabSteering",id:"setcrabsteering",level:3},{value:"startFieldWorker",id:"startfieldworker",level:3},{value:"updateArticulatedAxisRotation",id:"updatearticulatedaxisrotation",level:3},{value:"updateSteeringAngle",id:"updatesteeringangle",level:3},{value:"updateSteeringWheel",id:"updatesteeringwheel",level:3}];function o(e){const n={a:"a",blockquote:"blockquote",code:"code",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,s.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.h2,{id:"crabsteering",children:"CrabSteering"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Description"})}),"\n",(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsx)(n.p,{children:"Class for vehicles with variable steering modes (e.g. all wheel steering, crab steering, back wheel steering)"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Functions"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"#actioneventsetcrabsteeringmode",children:"actionEventSetCrabSteeringMode"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"#actioneventtogglecrabsteeringmodes",children:"actionEventToggleCrabSteeringModes"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"#getaiautomaticsteeringlookaheaddistance",children:"getAIAutomaticSteeringLookAheadDistance"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"#getcanbeselected",children:"getCanBeSelected"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"#getcantogglecrabsteering",children:"getCanToggleCrabSteering"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"#initspecialization",children:"initSpecialization"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"#loadcrabsteeringmodefromxml",children:"loadCrabSteeringModeFromXML"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"#loadwheelfromxml",children:"loadWheelFromXML"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"#loadwheelsfromxml",children:"loadWheelsFromXML"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"#onload",children:"onLoad"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"#onpostload",children:"onPostLoad"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"#onreadstream",children:"onReadStream"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"#onreadupdatestream",children:"onReadUpdateStream"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"#onregisteractionevents",children:"onRegisterActionEvents"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"#onregisterdashboardvaluetypes",children:"onRegisterDashboardValueTypes"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"#onupdatetick",children:"onUpdateTick"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"#onwritestream",children:"onWriteStream"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"#onwriteupdatestream",children:"onWriteUpdateStream"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"#prerequisitespresent",children:"prerequisitesPresent"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"#registereventlisteners",children:"registerEventListeners"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"#registerfunctions",children:"registerFunctions"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"#registeroverwrittenfunctions",children:"registerOverwrittenFunctions"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"#registersteeringmodexmlpaths",children:"registerSteeringModeXMLPaths"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"#savetoxmlfile",children:"saveToXMLFile"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"#setcrabsteering",children:"setCrabSteering"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"#startfieldworker",children:"startFieldWorker"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"#updatearticulatedaxisrotation",children:"updateArticulatedAxisRotation"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"#updatesteeringangle",children:"updateSteeringAngle"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"#updatesteeringwheel",children:"updateSteeringWheel"})}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"actioneventsetcrabsteeringmode",children:"actionEventSetCrabSteeringMode"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Description"})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Definition"})}),"\n",(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsx)(n.p,{children:"actionEventSetCrabSteeringMode()"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,r.jsxs)(n.table,{children:[(0,r.jsx)(n.thead,{children:(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.th,{children:"any"}),(0,r.jsx)(n.th,{children:"self"})]})}),(0,r.jsxs)(n.tbody,{children:[(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"any"}),(0,r.jsx)(n.td,{children:"actionName"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"any"}),(0,r.jsx)(n.td,{children:"inputValue"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"any"}),(0,r.jsx)(n.td,{children:"callbackState"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"any"}),(0,r.jsx)(n.td,{children:"isAnalog"})]})]})]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Code"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-lua",children:"function CrabSteering.actionEventSetCrabSteeringMode( self , actionName, inputValue, callbackState, isAnalog)\n    local isAllowed, warning = self:getCanToggleCrabSteering()\n    if isAllowed then\n        local spec = self.spec_crabSteering\n        local state = spec.state\n\n        for i, mode in pairs(spec.steeringModes) do\n            if mode.inputAction = = InputAction[actionName] then\n                state = i\n                break\n            end\n        end\n\n        if state ~ = spec.state then\n            if self:getCrabSteeringModeAvailable(spec.steeringModes[state]) then\n                self:setCrabSteering(state)\n            end\n        end\n    elseif warning ~ = nil then\n            g_currentMission:showBlinkingWarning(warning, 2000 )\n        end\n    end\n\n"})}),"\n",(0,r.jsx)(n.h3,{id:"actioneventtogglecrabsteeringmodes",children:"actionEventToggleCrabSteeringModes"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Description"})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Definition"})}),"\n",(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsx)(n.p,{children:"actionEventToggleCrabSteeringModes()"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,r.jsxs)(n.table,{children:[(0,r.jsx)(n.thead,{children:(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.th,{children:"any"}),(0,r.jsx)(n.th,{children:"self"})]})}),(0,r.jsxs)(n.tbody,{children:[(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"any"}),(0,r.jsx)(n.td,{children:"actionName"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"any"}),(0,r.jsx)(n.td,{children:"inputValue"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"any"}),(0,r.jsx)(n.td,{children:"callbackState"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"any"}),(0,r.jsx)(n.td,{children:"isAnalog"})]})]})]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Code"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-lua",children:"function CrabSteering.actionEventToggleCrabSteeringModes( self , actionName, inputValue, callbackState, isAnalog)\n    local isAllowed, warning = self:getCanToggleCrabSteering()\n    if isAllowed then\n        self:setNextCrabSteeringMode(callbackState)\n    elseif warning ~ = nil then\n            g_currentMission:showBlinkingWarning(warning, 2000 )\n        end\n    end\n\n"})}),"\n",(0,r.jsx)(n.h3,{id:"getaiautomaticsteeringlookaheaddistance",children:"getAIAutomaticSteeringLookAheadDistance"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Description"})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Definition"})}),"\n",(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsx)(n.p,{children:"getAIAutomaticSteeringLookAheadDistance()"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,r.jsx)(n.table,{children:(0,r.jsx)(n.thead,{children:(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.th,{children:"any"}),(0,r.jsx)(n.th,{children:"superFunc"})]})})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Code"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-lua",children:"function CrabSteering:getAIAutomaticSteeringLookAheadDistance(superFunc)\n    if self.spec_crabSteering.hasSteeringModes then\n        local spec = self.spec_crabSteering\n        local currentMode = spec.steeringModes[spec.state]\n        if currentMode.automaticSteeringLookAheadDistance ~ = nil then\n            return currentMode.automaticSteeringLookAheadDistance\n        end\n    end\n\n    return superFunc( self )\nend\n\n"})}),"\n",(0,r.jsx)(n.h3,{id:"getcanbeselected",children:"getCanBeSelected"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Description"})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Definition"})}),"\n",(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsx)(n.p,{children:"getCanBeSelected()"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,r.jsx)(n.table,{children:(0,r.jsx)(n.thead,{children:(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.th,{children:"any"}),(0,r.jsx)(n.th,{children:"superFunc"})]})})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Code"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-lua",children:"function CrabSteering:getCanBeSelected(superFunc)\n    return self.spec_crabSteering.hasSteeringModes or superFunc( self )\nend\n\n"})}),"\n",(0,r.jsx)(n.h3,{id:"getcantogglecrabsteering",children:"getCanToggleCrabSteering"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Description"})}),"\n",(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsx)(n.p,{children:"Returns if it's allowed to toggle crab steering"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Definition"})}),"\n",(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsx)(n.p,{children:"getCanToggleCrabSteering()"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Return Values"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,r.jsxs)(n.table,{children:[(0,r.jsx)(n.thead,{children:(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.th,{children:"any"}),(0,r.jsx)(n.th,{children:"isAllowed"}),(0,r.jsx)(n.th,{children:"is allowed"})]})}),(0,r.jsx)(n.tbody,{children:(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"any"}),(0,r.jsx)(n.td,{children:"warning"}),(0,r.jsx)(n.td,{children:"warning to be displayed"})]})})]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Code"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-lua",children:"function CrabSteering:getCanToggleCrabSteering()\n    return true , nil\nend\n\n"})}),"\n",(0,r.jsx)(n.h3,{id:"initspecialization",children:"initSpecialization"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Description"})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Definition"})}),"\n",(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsx)(n.p,{children:"initSpecialization()"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Code"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-lua",children:'function CrabSteering.initSpecialization()\n    local schema = Vehicle.xmlSchema\n    schema:setXMLSpecializationType( "CrabSteering" )\n\n    schema:register(XMLValueType.FLOAT, "vehicle.crabSteering#distFromCompJointToCenterOfBackWheels" , "Distance from component joint to center of back wheels" )\n    schema:register(XMLValueType.FLOAT, "vehicle.crabSteering#aiSteeringModeIndex" , "AI steering mode index" , 1 )\n    schema:register(XMLValueType.FLOAT, "vehicle.crabSteering#toggleSpeedFactor" , "Toggle speed factor" , 1 )\n\n    CrabSteering.registerSteeringModeXMLPaths(schema, "vehicle.crabSteering.steeringMode(?)" )\n    CrabSteering.registerSteeringModeXMLPaths(schema, "vehicle.crabSteering.crabSteeringConfiguration(?).steeringMode(?)" )\n\n    Dashboard.registerDashboardXMLPaths(schema, "vehicle.crabSteering.dashboards" , { "state" } )\n\n    Dashboard.addDelayedRegistrationFunc(schema, function (cSchema, cKey)\n        cSchema:register(XMLValueType.VECTOR_N, cKey .. "#states" , "Crab steering states which activate the dashboard" )\n    end )\n\n    schema:register(XMLValueType.INT, "vehicle.wheels.wheelConfigurations.wheelConfiguration(?).wheels#crabSteeringIndex" , "Crab steering configuration index" )\n\n    schema:setXMLSpecializationType()\n\n    local schemaSavegame = Vehicle.xmlSchemaSavegame\n    schemaSavegame:register(XMLValueType.INT, "vehicles.vehicle(?).crabSteering#state" , "Current steering mode" , 1 )\nend\n\n'})}),"\n",(0,r.jsx)(n.h3,{id:"loadcrabsteeringmodefromxml",children:"loadCrabSteeringModeFromXML"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Description"})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Definition"})}),"\n",(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsx)(n.p,{children:"loadCrabSteeringModeFromXML()"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,r.jsxs)(n.table,{children:[(0,r.jsx)(n.thead,{children:(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.th,{children:"any"}),(0,r.jsx)(n.th,{children:"xmlFile"})]})}),(0,r.jsxs)(n.tbody,{children:[(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"any"}),(0,r.jsx)(n.td,{children:"key"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"any"}),(0,r.jsx)(n.td,{children:"mode"})]})]})]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Code"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-lua",children:'function CrabSteering:loadCrabSteeringModeFromXML(xmlFile, key, mode)\n    mode.name = self.xmlFile:getValue(key .. "#name" , "" , self.customEnvironment, false )\n\n    local inputBindingName = self.xmlFile:getValue(key .. "#inputBindingName" )\n    if inputBindingName ~ = nil then\n        if InputAction[inputBindingName] ~ = nil then\n            mode.inputAction = InputAction[inputBindingName]\n        else\n                Logging.xmlWarning( self.xmlFile, "Invalid inputBindingname \'%s\' for \'%s\'" , tostring(inputBindingName), key)\n                end\n            end\n\n            mode.steeringCenterNode = self.xmlFile:getValue(key .. ".steeringCenter#node" , nil , self.components, self.i3dMappings)\n            mode.turningRadius = self.xmlFile:getValue(key .. ".steeringCenter#turningRadius" )\n\n            mode.automaticSteeringLookAheadDistance = self.xmlFile:getValue(key .. ".aiAutomaticSteering#lookAheadDistance" )\n\n            mode.wheels = { }\n            for _, wheelKey in self.xmlFile:iterator(key .. ".wheel" ) do\n                local wheelEntry = { }\n                wheelEntry.wheelIndex = self.xmlFile:getValue(wheelKey .. "#index" )\n                wheelEntry.wheelNode = self.xmlFile:getValue(wheelKey .. "#node" , nil , self.components, self.i3dMappings)\n                if wheelEntry.wheelNode ~ = nil then\n                    local wheel = self:getWheelByWheelNode(wheelEntry.wheelNode)\n                    if wheel ~ = nil then\n                        if wheel.physics.rotSpeed ~ = 0 then\n                            wheelEntry.wheelIndex = wheel.wheelIndex\n                            wheelEntry.wheel = wheel\n                        else\n                                Logging.xmlError( self.xmlFile, "Invalid wheel node \'%s\' for \'%s\'.Wheel needs to have a rotSpeed defined!" , self.xmlFile:getString(wheelKey .. "#node" ), wheelKey)\n                                    continue\n                                end\n                            else\n                                    Logging.xmlError( self.xmlFile, "Invalid wheel node \'%s\' for \'%s\'" , self.xmlFile:getString(wheelKey .. "#node" ), wheelKey)\n                                        continue\n                                    end\n                                end\n\n                                wheelEntry.offset = self.xmlFile:getValue(wheelKey .. "#offset" , 0 )\n                                wheelEntry.locked = self.xmlFile:getValue(wheelKey .. "#locked" , false )\n\n                                if wheelEntry.wheelIndex ~ = nil then\n                                    wheelEntry.wheel = self:getWheelFromWheelIndex(wheelEntry.wheelIndex)\n\n                                    if wheelEntry.wheel = = nil then\n                                        Logging.xmlError( self.xmlFile, "Invalid wheel \'%s\' for \'%s\'" , tostring(wheelEntry.wheelIndex), wheelKey)\n                                            continue\n                                        end\n                                    end\n\n                                    table.insert(mode.wheels, wheelEntry)\n                                end\n\n                                mode.steeringNodes = { }\n                                for _, steeringNodeKey in self.xmlFile:iterator(key .. ".steeringNode" ) do\n                                    local steeringNodeEntry = { }\n                                    steeringNodeEntry.node = self.xmlFile:getValue(steeringNodeKey .. "#node" , nil , self.components, self.i3dMappings)\n                                    if steeringNodeEntry.node ~ = nil then\n                                        local steeringNode = self:getSteeringNodeByNode(steeringNodeEntry.node)\n                                        if steeringNode ~ = nil then\n                                            steeringNodeEntry.steeringNode = steeringNode\n\n                                            steeringNodeEntry.offset = self.xmlFile:getValue(steeringNodeKey .. "#offset" , 0 )\n                                            steeringNodeEntry.locked = self.xmlFile:getValue(steeringNodeKey .. "#locked" , false )\n                                            steeringNodeEntry.rotScale = self.xmlFile:getValue(steeringNodeKey .. "#rotScale" )\n\n                                            table.insert(mode.steeringNodes, steeringNodeEntry)\n                                        else\n                                                Logging.xmlError( self.xmlFile, "Invalid steering node \'%s\' for \'%s\'" , getName(steeringNodeEntry.node), steeringNodeKey)\n                                                end\n                                            end\n                                        end\n\n                                        mode.nodes = { }\n                                        for _, nodeKey in self.xmlFile:iterator(key .. ".node" ) do\n                                            local nodeEntry = { }\n                                            nodeEntry.node = self.xmlFile:getValue(nodeKey .. "#node" , nil , self.components, self.i3dMappings)\n                                            if nodeEntry.node ~ = nil then\n                                                nodeEntry.rotation = self.xmlFile:getValue(nodeKey .. "#rotation" , nil , true )\n                                                nodeEntry.translation = self.xmlFile:getValue(nodeKey .. "#translation" , nil , true )\n\n                                                table.insert(mode.nodes, nodeEntry)\n                                            end\n                                        end\n\n                                        local specArticulatedAxis = self.spec_articulatedAxis\n                                        if specArticulatedAxis ~ = nil and specArticulatedAxis.componentJoint ~ = nil then\n                                            mode.articulatedAxis = { }\n                                            mode.articulatedAxis.rotSpeedBackUp = specArticulatedAxis.rotSpeed\n                                            mode.articulatedAxis.offset = self.xmlFile:getValue(key .. ".articulatedAxis#offset" , 0 )\n                                            mode.articulatedAxis.locked = self.xmlFile:getValue(key .. ".articulatedAxis#locked" , false )\n                                            mode.articulatedAxis.wheelIndices = self.xmlFile:getValue(key .. ".articulatedAxis#wheelIndices" , nil , true )\n                                        end\n\n                                        mode.animations = { }\n                                        for _, animKey in self.xmlFile:iterator(key .. ".animation" ) do\n                                            local animation = { }\n                                            animation.animName = self.xmlFile:getValue(animKey .. "#name" )\n                                            animation.animSpeed = self.xmlFile:getValue(animKey .. "#speed" , 1.0 )\n                                            animation.stopTime = self.xmlFile:getValue(animKey .. "#stopTime" )\n\n                                            if animation.animName ~ = nil and self:getAnimationExists(animation.animName) then\n                                                table.insert(mode.animations, animation)\n                                            else\n                                                    Logging.xmlWarning( self.xmlFile, "Invalid animation \'%s\' for \'%s\'" , tostring(animation.animName), animKey)\n                                                    end\n                                                end\n\n                                                local node = self.xmlFile:getValue(key .. ".steeringWheel#node" , nil , self.components, self.i3dMappings)\n                                                if node ~ = nil then\n                                                    mode.steeringWheel = { }\n                                                    mode.steeringWheel.node = node\n                                                    local _,ry,_ = getRotation(mode.steeringWheel.node)\n                                                    mode.steeringWheel.lastRotation = ry\n                                                    mode.steeringWheel.indoorRotation = self.xmlFile:getValue(key .. ".steeringWheel#indoorRotation" , 0 )\n                                                    mode.steeringWheel.outdoorRotation = self.xmlFile:getValue(key .. ".steeringWheel#outdoorRotation" , 0 )\n                                                end\n\n                                                return true\n                                            end\n\n'})}),"\n",(0,r.jsx)(n.h3,{id:"loadwheelfromxml",children:"loadWheelFromXML"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Description"})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Definition"})}),"\n",(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsx)(n.p,{children:"loadWheelFromXML()"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,r.jsxs)(n.table,{children:[(0,r.jsx)(n.thead,{children:(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.th,{children:"any"}),(0,r.jsx)(n.th,{children:"superFunc"})]})}),(0,r.jsx)(n.tbody,{children:(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"any"}),(0,r.jsx)(n.td,{children:"wheel"})]})})]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Code"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-lua",children:"function CrabSteering:loadWheelFromXML(superFunc, wheel)\n    if not superFunc( self , wheel) then\n        return false\n    end\n\n    wheel.steeringOffset = 0\n    wheel.forceSteeringAngleUpdate = true\n\n    return true\nend\n\n"})}),"\n",(0,r.jsx)(n.h3,{id:"loadwheelsfromxml",children:"loadWheelsFromXML"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Description"})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Definition"})}),"\n",(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsx)(n.p,{children:"loadWheelsFromXML()"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,r.jsxs)(n.table,{children:[(0,r.jsx)(n.thead,{children:(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.th,{children:"any"}),(0,r.jsx)(n.th,{children:"superFunc"})]})}),(0,r.jsxs)(n.tbody,{children:[(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"any"}),(0,r.jsx)(n.td,{children:"xmlFile"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"any"}),(0,r.jsx)(n.td,{children:"key"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"any"}),(0,r.jsx)(n.td,{children:"wheelConfigurationI"})]})]})]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Code"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-lua",children:'function CrabSteering:loadWheelsFromXML(superFunc, xmlFile, key, wheelConfigurationI)\n    superFunc( self , xmlFile, key, wheelConfigurationI)\n\n    self.spec_crabSteering.configurationIndex = WheelXMLObject.getValueStatic( self.spec_wheels.wheelConfigurationId, self.spec_wheels.configurationIndexToParentConfigIndex, self.xmlFile, Wheels.CONFIG_XML_PATH, ".wheels" , "#crabSteeringIndex" )\nend\n\n'})}),"\n",(0,r.jsx)(n.h3,{id:"onload",children:"onLoad"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Description"})}),"\n",(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsx)(n.p,{children:"Called on loading"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Definition"})}),"\n",(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsx)(n.p,{children:"onLoad(table savegame)"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n",(0,r.jsx)(n.table,{children:(0,r.jsx)(n.thead,{children:(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.th,{children:"table"}),(0,r.jsx)(n.th,{children:"savegame"}),(0,r.jsx)(n.th,{children:"savegame"})]})})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Code"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-lua",children:'function CrabSteering:onLoad(savegame)\n    local spec = self.spec_crabSteering\n\n    spec.state = 1\n    spec.stateMax = - 1\n\n    spec.configurationIndex = spec.configurationIndex or 1\n\n    spec.distFromCompJointToCenterOfBackWheels = self.xmlFile:getValue( "vehicle.crabSteering#distFromCompJointToCenterOfBackWheels" )\n    spec.aiSteeringModeIndex = self.xmlFile:getValue( "vehicle.crabSteering#aiSteeringModeIndex" , 1 )\n    spec.toggleSpeedFactor = self.xmlFile:getValue( "vehicle.crabSteering#toggleSpeedFactor" , 1 )\n\n    spec.currentArticulatedAxisOffset = 0\n    spec.articulatedAxisOffsetChanged = false\n    spec.articulatedAxisLastAngle = 0\n    spec.articulatedAxisChangingTime = 0\n\n    local baseKey = "vehicle.crabSteering"\n    local configKey = string.format( "vehicle.crabSteering.crabSteeringConfiguration(%d)" , spec.configurationIndex - 1 )\n    if self.xmlFile:hasProperty(configKey) then\n        baseKey = configKey\n    end\n\n    spec.steeringModes = { }\n    for _, key in self.xmlFile:iterator(baseKey .. ".steeringMode" ) do\n        local mode = { }\n        if self:loadCrabSteeringModeFromXML( self.xmlFile, key, mode) then\n            table.insert(spec.steeringModes, mode)\n            mode.index = #spec.steeringModes\n        end\n    end\n\n    spec.stateMax = #spec.steeringModes\n    if spec.stateMax > (( 2 ^ CrabSteering.STEERING_SEND_NUM_BITS) - 1 ) then\n        Logging.xmlError( self.xmlFile, "CrabSteering only supports %d steering modes!" , ( 2 ^ CrabSteering.STEERING_SEND_NUM_BITS) - 1 )\n    end\n\n    spec.hasSteeringModes = spec.stateMax > 0\n\n    if spec.hasSteeringModes then\n        self.customSteeringAngleFunction = true\n\n        spec.hudExtension = CrabSteeringHUDExtension.new( self )\n\n        self:setCrabSteering( 1 , true )\n    else\n            SpecializationUtil.removeEventListener( self , "onReadStream" , CrabSteering )\n            SpecializationUtil.removeEventListener( self , "onWriteStream" , CrabSteering )\n            SpecializationUtil.removeEventListener( self , "onReadUpdateStream" , CrabSteering )\n            SpecializationUtil.removeEventListener( self , "onWriteUpdateStream" , CrabSteering )\n            SpecializationUtil.removeEventListener( self , "onUpdateTick" , CrabSteering )\n            SpecializationUtil.removeEventListener( self , "onDraw" , CrabSteering )\n            SpecializationUtil.removeEventListener( self , "onAIImplementStart" , CrabSteering )\n            SpecializationUtil.removeEventListener( self , "onRegisterActionEvents" , CrabSteering )\n        end\n    end\n\n'})}),"\n",(0,r.jsx)(n.h3,{id:"onpostload",children:"onPostLoad"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Description"})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Definition"})}),"\n",(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsx)(n.p,{children:"onPostLoad()"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,r.jsx)(n.table,{children:(0,r.jsx)(n.thead,{children:(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.th,{children:"any"}),(0,r.jsx)(n.th,{children:"savegame"})]})})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Code"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-lua",children:'function CrabSteering:onPostLoad(savegame)\n    if savegame ~ = nil and not savegame.resetVehicles then\n        local spec = self.spec_crabSteering\n        if spec.hasSteeringModes then\n            if savegame.xmlFile:hasProperty(savegame.key .. ".crabSteering" ) then\n                local state = savegame.xmlFile:getValue(savegame.key .. ".crabSteering#state" , 1 )\n                state = math.clamp(state, 1 , spec.stateMax)\n\n                self:setCrabSteering(state, true )\n                AnimatedVehicle.updateAnimations( self , 99999999 , true )\n                self:forceUpdateWheelPhysics( 99999999 )\n            end\n        end\n    end\nend\n\n'})}),"\n",(0,r.jsx)(n.h3,{id:"onreadstream",children:"onReadStream"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Description"})}),"\n",(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsx)(n.p,{children:"Called on client side on join"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Definition"})}),"\n",(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsx)(n.p,{children:"onReadStream(integer streamId, Connection connection)"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,r.jsxs)(n.table,{children:[(0,r.jsx)(n.thead,{children:(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.th,{children:"integer"}),(0,r.jsx)(n.th,{children:"streamId"}),(0,r.jsx)(n.th,{children:"streamId"})]})}),(0,r.jsx)(n.tbody,{children:(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"Connection"}),(0,r.jsx)(n.td,{children:"connection"}),(0,r.jsx)(n.td,{children:"connection"})]})})]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Code"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-lua",children:"function CrabSteering:onReadStream(streamId, connection)\n    local state = streamReadUIntN(streamId, CrabSteering.STEERING_SEND_NUM_BITS)\n\n    self:setCrabSteering(state, true )\n    AnimatedVehicle.updateAnimations( self , 99999999 , true )\n    self:forceUpdateWheelPhysics( 99999999 )\nend\n\n"})}),"\n",(0,r.jsx)(n.h3,{id:"onreadupdatestream",children:"onReadUpdateStream"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Description"})}),"\n",(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsx)(n.p,{children:"Called on on update"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Definition"})}),"\n",(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsx)(n.p,{children:"onReadUpdateStream(integer streamId, integer timestamp, table connection)"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,r.jsxs)(n.table,{children:[(0,r.jsx)(n.thead,{children:(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.th,{children:"integer"}),(0,r.jsx)(n.th,{children:"streamId"}),(0,r.jsx)(n.th,{children:"stream ID"})]})}),(0,r.jsxs)(n.tbody,{children:[(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"integer"}),(0,r.jsx)(n.td,{children:"timestamp"}),(0,r.jsx)(n.td,{children:"timestamp"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"table"}),(0,r.jsx)(n.td,{children:"connection"}),(0,r.jsx)(n.td,{children:"connection"})]})]})]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Code"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-lua",children:"function CrabSteering:onReadUpdateStream(streamId, timestamp, connection)\n    local specArticulatedAxis = self.spec_articulatedAxis\n    if specArticulatedAxis ~ = nil and specArticulatedAxis.componentJoint ~ = nil then\n        specArticulatedAxis.curRot = streamReadFloat32(streamId)\n    end\nend\n\n"})}),"\n",(0,r.jsx)(n.h3,{id:"onregisteractionevents",children:"onRegisterActionEvents"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Description"})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Definition"})}),"\n",(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsx)(n.p,{children:"onRegisterActionEvents()"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,r.jsxs)(n.table,{children:[(0,r.jsx)(n.thead,{children:(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.th,{children:"any"}),(0,r.jsx)(n.th,{children:"isActiveForInput"})]})}),(0,r.jsx)(n.tbody,{children:(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"any"}),(0,r.jsx)(n.td,{children:"isActiveForInputIgnoreSelection"})]})})]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Code"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-lua",children:"function CrabSteering:onRegisterActionEvents(isActiveForInput, isActiveForInputIgnoreSelection)\n    if self.isClient then\n        local spec = self.spec_crabSteering\n        if spec.hasSteeringModes then\n            self:clearActionEventsTable(spec.actionEvents)\n\n            if isActiveForInputIgnoreSelection then\n                local _, actionEventId = self:addPoweredActionEvent(spec.actionEvents, InputAction.TOGGLE_CRABSTEERING, self , CrabSteering.actionEventToggleCrabSteeringModes, false , true , false , true , 1 )\n                g_inputBinding:setActionEventTextPriority(actionEventId, GS_PRIO_NORMAL)\n\n                for _, mode in pairs(spec.steeringModes) do\n                    if mode.inputAction ~ = nil then\n                        _, actionEventId = self:addPoweredActionEvent(spec.actionEvents, mode.inputAction, self , CrabSteering.actionEventSetCrabSteeringMode, false , true , false , true , nil )\n                        g_inputBinding:setActionEventTextVisibility(actionEventId, false )\n                        g_inputBinding:setActionEventTextPriority(actionEventId, GS_PRIO_NORMAL)\n                    end\n                end\n\n                _, actionEventId = self:addPoweredActionEvent(spec.actionEvents, InputAction.TOGGLE_CRABSTEERING_BACK, self , CrabSteering.actionEventToggleCrabSteeringModes, false , true , false , true , - 1 )\n                g_inputBinding:setActionEventTextVisibility(actionEventId, false )\n            end\n        end\n    end\nend\n\n"})}),"\n",(0,r.jsx)(n.h3,{id:"onregisterdashboardvaluetypes",children:"onRegisterDashboardValueTypes"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Description"})}),"\n",(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsx)(n.p,{children:"Called on post load to register dashboard value types"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Definition"})}),"\n",(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsx)(n.p,{children:"onRegisterDashboardValueTypes()"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Code"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-lua",children:'function CrabSteering:onRegisterDashboardValueTypes()\n    local spec = self.spec_crabSteering\n\n    local state = DashboardValueType.new( "crabSteering" , "state" )\n    state:setValue(spec, function (_, dashboard)\n        if dashboard.crabSteeringStates ~ = nil then\n            local isStateActive = false\n            for _, state in pairs(dashboard.crabSteeringStates) do\n                if spec.state = = state then\n                    isStateActive = true\n                end\n            end\n\n            return isStateActive\n        else\n                return spec.state\n            end\n        end )\n        state:setAdditionalFunctions( function ( self , xmlFile, key, dashboard, isActive)\n            dashboard.crabSteeringStates = xmlFile:getValue(key .. "#states" , nil , true )\n\n            return true\n        end )\n        state:setPollUpdate( false )\n        self:registerDashboardValueType(state)\n    end\n\n'})}),"\n",(0,r.jsx)(n.h3,{id:"onupdatetick",children:"onUpdateTick"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Description"})}),"\n",(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsx)(n.p,{children:"Called on update tick"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Definition"})}),"\n",(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsx)(n.p,{children:"onUpdateTick(float dt, boolean isActiveForInput, boolean isSelected, )"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,r.jsxs)(n.table,{children:[(0,r.jsx)(n.thead,{children:(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.th,{children:"float"}),(0,r.jsx)(n.th,{children:"dt"}),(0,r.jsx)(n.th,{children:"time since last call in ms"})]})}),(0,r.jsxs)(n.tbody,{children:[(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"boolean"}),(0,r.jsx)(n.td,{children:"isActiveForInput"}),(0,r.jsx)(n.td,{children:"true if vehicle is active for input"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"boolean"}),(0,r.jsx)(n.td,{children:"isSelected"}),(0,r.jsx)(n.td,{children:"true if vehicle is selected"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"any"}),(0,r.jsx)(n.td,{children:"isSelected"}),(0,r.jsx)(n.td,{})]})]})]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Code"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-lua",children:"function CrabSteering:onUpdateTick(dt, isActiveForInput, isActiveForInputIgnoreSelection, isSelected)\n    if self.isServer then\n        local spec = self.spec_crabSteering\n        if not self:getCrabSteeringModeAvailable(spec.steeringModes[spec.state]) then\n            self:setNextCrabSteeringMode( 1 )\n        end\n    end\nend\n\n"})}),"\n",(0,r.jsx)(n.h3,{id:"onwritestream",children:"onWriteStream"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Description"})}),"\n",(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsx)(n.p,{children:"Called on server side on join"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Definition"})}),"\n",(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsx)(n.p,{children:"onWriteStream(integer streamId, Connection connection)"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,r.jsxs)(n.table,{children:[(0,r.jsx)(n.thead,{children:(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.th,{children:"integer"}),(0,r.jsx)(n.th,{children:"streamId"}),(0,r.jsx)(n.th,{children:"streamId"})]})}),(0,r.jsx)(n.tbody,{children:(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"Connection"}),(0,r.jsx)(n.td,{children:"connection"}),(0,r.jsx)(n.td,{children:"connection"})]})})]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Code"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-lua",children:"function CrabSteering:onWriteStream(streamId, connection)\n    local spec = self.spec_crabSteering\n    streamWriteUIntN(streamId, spec.state, CrabSteering.STEERING_SEND_NUM_BITS)\nend\n\n"})}),"\n",(0,r.jsx)(n.h3,{id:"onwriteupdatestream",children:"onWriteUpdateStream"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Description"})}),"\n",(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsx)(n.p,{children:"Called on on update"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Definition"})}),"\n",(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsx)(n.p,{children:"onWriteUpdateStream(integer streamId, table connection, integer dirtyMask)"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,r.jsxs)(n.table,{children:[(0,r.jsx)(n.thead,{children:(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.th,{children:"integer"}),(0,r.jsx)(n.th,{children:"streamId"}),(0,r.jsx)(n.th,{children:"stream ID"})]})}),(0,r.jsxs)(n.tbody,{children:[(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"table"}),(0,r.jsx)(n.td,{children:"connection"}),(0,r.jsx)(n.td,{children:"connection"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"integer"}),(0,r.jsx)(n.td,{children:"dirtyMask"}),(0,r.jsx)(n.td,{children:"dirty mask"})]})]})]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Code"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-lua",children:"function CrabSteering:onWriteUpdateStream(streamId, connection, dirtyMask)\n    local specArticulatedAxis = self.spec_articulatedAxis\n    if specArticulatedAxis ~ = nil and specArticulatedAxis.componentJoint ~ = nil then\n        streamWriteFloat32(streamId, specArticulatedAxis.curRot)\n    end\nend\n\n"})}),"\n",(0,r.jsx)(n.h3,{id:"prerequisitespresent",children:"prerequisitesPresent"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Description"})}),"\n",(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsx)(n.p,{children:"Checks if all prerequisite specializations are loaded"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Definition"})}),"\n",(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsx)(n.p,{children:"prerequisitesPresent(table specializations)"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n",(0,r.jsx)(n.table,{children:(0,r.jsx)(n.thead,{children:(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.th,{children:"table"}),(0,r.jsx)(n.th,{children:"specializations"}),(0,r.jsx)(n.th,{children:"specializations"})]})})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Return Values"})}),"\n\n\n\n\n\n\n\n\n",(0,r.jsx)(n.table,{children:(0,r.jsx)(n.thead,{children:(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.th,{children:"table"}),(0,r.jsx)(n.th,{children:"hasPrerequisite"}),(0,r.jsx)(n.th,{children:"true if all prerequisite specializations are loaded"})]})})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Code"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-lua",children:"function CrabSteering.prerequisitesPresent(specializations)\n    return SpecializationUtil.hasSpecialization( Drivable , specializations)\n    and SpecializationUtil.hasSpecialization( Wheels , specializations)\n    and SpecializationUtil.hasSpecialization( AnimatedVehicle , specializations)\nend\n\n"})}),"\n",(0,r.jsx)(n.h3,{id:"registereventlisteners",children:"registerEventListeners"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Description"})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Definition"})}),"\n",(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsx)(n.p,{children:"registerEventListeners()"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,r.jsx)(n.table,{children:(0,r.jsx)(n.thead,{children:(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.th,{children:"any"}),(0,r.jsx)(n.th,{children:"vehicleType"})]})})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Code"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-lua",children:'function CrabSteering.registerEventListeners(vehicleType)\n    SpecializationUtil.registerEventListener(vehicleType, "onLoad" , CrabSteering )\n    SpecializationUtil.registerEventListener(vehicleType, "onPostLoad" , CrabSteering )\n    SpecializationUtil.registerEventListener(vehicleType, "onDelete" , CrabSteering )\n    SpecializationUtil.registerEventListener(vehicleType, "onRegisterDashboardValueTypes" , CrabSteering )\n    SpecializationUtil.registerEventListener(vehicleType, "onReadStream" , CrabSteering )\n    SpecializationUtil.registerEventListener(vehicleType, "onWriteStream" , CrabSteering )\n    SpecializationUtil.registerEventListener(vehicleType, "onReadUpdateStream" , CrabSteering )\n    SpecializationUtil.registerEventListener(vehicleType, "onWriteUpdateStream" , CrabSteering )\n    SpecializationUtil.registerEventListener(vehicleType, "onUpdateTick" , CrabSteering )\n    SpecializationUtil.registerEventListener(vehicleType, "onDraw" , CrabSteering )\n    SpecializationUtil.registerEventListener(vehicleType, "onRegisterActionEvents" , CrabSteering )\nend\n\n'})}),"\n",(0,r.jsx)(n.h3,{id:"registerfunctions",children:"registerFunctions"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Description"})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Definition"})}),"\n",(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsx)(n.p,{children:"registerFunctions()"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,r.jsx)(n.table,{children:(0,r.jsx)(n.thead,{children:(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.th,{children:"any"}),(0,r.jsx)(n.th,{children:"vehicleType"})]})})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Code"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-lua",children:'function CrabSteering.registerFunctions(vehicleType)\n    SpecializationUtil.registerFunction(vehicleType, "loadCrabSteeringModeFromXML" , CrabSteering.loadCrabSteeringModeFromXML)\n    SpecializationUtil.registerFunction(vehicleType, "getCanToggleCrabSteering" , CrabSteering.getCanToggleCrabSteering)\n    SpecializationUtil.registerFunction(vehicleType, "getCrabSteeringModeAvailable" , CrabSteering.getCrabSteeringModeAvailable)\n    SpecializationUtil.registerFunction(vehicleType, "getNumCrabSteeringModesAvailable" , CrabSteering.getNumCrabSteeringModesAvailable)\n    SpecializationUtil.registerFunction(vehicleType, "setCrabSteering" , CrabSteering.setCrabSteering)\n    SpecializationUtil.registerFunction(vehicleType, "getCrabSteeringMode" , CrabSteering.getCrabSteeringMode)\n    SpecializationUtil.registerFunction(vehicleType, "setNextCrabSteeringMode" , CrabSteering.setNextCrabSteeringMode)\n    SpecializationUtil.registerFunction(vehicleType, "updateArticulatedAxisRotation" , CrabSteering.updateArticulatedAxisRotation)\nend\n\n'})}),"\n",(0,r.jsx)(n.h3,{id:"registeroverwrittenfunctions",children:"registerOverwrittenFunctions"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Description"})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Definition"})}),"\n",(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsx)(n.p,{children:"registerOverwrittenFunctions()"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,r.jsx)(n.table,{children:(0,r.jsx)(n.thead,{children:(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.th,{children:"any"}),(0,r.jsx)(n.th,{children:"vehicleType"})]})})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Code"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-lua",children:'function CrabSteering.registerOverwrittenFunctions(vehicleType)\n    SpecializationUtil.registerOverwrittenFunction(vehicleType, "loadWheelFromXML" , CrabSteering.loadWheelFromXML)\n    SpecializationUtil.registerOverwrittenFunction(vehicleType, "updateSteeringAngle" , CrabSteering.updateSteeringAngle)\n    SpecializationUtil.registerOverwrittenFunction(vehicleType, "getCanBeSelected" , CrabSteering.getCanBeSelected)\n    SpecializationUtil.registerOverwrittenFunction(vehicleType, "loadWheelsFromXML" , CrabSteering.loadWheelsFromXML)\n    SpecializationUtil.registerOverwrittenFunction(vehicleType, "updateSteeringWheel" , CrabSteering.updateSteeringWheel)\n    SpecializationUtil.registerOverwrittenFunction(vehicleType, "startFieldWorker" , CrabSteering.startFieldWorker)\n    SpecializationUtil.registerOverwrittenFunction(vehicleType, "getAIAutomaticSteeringLookAheadDistance" , CrabSteering.getAIAutomaticSteeringLookAheadDistance)\nend\n\n'})}),"\n",(0,r.jsx)(n.h3,{id:"registersteeringmodexmlpaths",children:"registerSteeringModeXMLPaths"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Description"})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Definition"})}),"\n",(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsx)(n.p,{children:"registerSteeringModeXMLPaths()"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,r.jsxs)(n.table,{children:[(0,r.jsx)(n.thead,{children:(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.th,{children:"any"}),(0,r.jsx)(n.th,{children:"schema"})]})}),(0,r.jsx)(n.tbody,{children:(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"any"}),(0,r.jsx)(n.td,{children:"basePath"})]})})]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Code"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-lua",children:'function CrabSteering.registerSteeringModeXMLPaths(schema, basePath)\n    schema:addDelayedRegistrationPath(basePath, "CrabSteering:steeringMode" )\n\n    schema:register(XMLValueType.L10N_STRING, basePath .. "#name" , "Steering mode name" )\n    schema:register(XMLValueType.STRING, basePath .. "#inputBindingName" , "Input action name" )\n    schema:register(XMLValueType.INT, basePath .. ".wheel(?)#index" , "Wheel Index" )\n    schema:register(XMLValueType.NODE_INDEX, basePath .. ".wheel(?)#node" , "Wheel Node" )\n    schema:register(XMLValueType.ANGLE, basePath .. ".wheel(?)#offset" , "Rotation offset" , 0 )\n    schema:register(XMLValueType.BOOL, basePath .. ".wheel(?)#locked" , "Steering is locked" , false )\n\n    schema:register(XMLValueType.NODE_INDEX, basePath .. ".steeringCenter#node" , "Custom steering center node" )\n    schema:register(XMLValueType.FLOAT, basePath .. ".steeringCenter#turningRadius" , "Turning radius to use with custom steering node" )\n\n    schema:register(XMLValueType.FLOAT, basePath .. ".aiAutomaticSteering#lookAheadDistance" , "Distance for aiming onto the wayline when this steering mode is active" )\n\n        schema:register(XMLValueType.NODE_INDEX, basePath .. ".steeringNode(?)#node" , "Steering node" )\n        schema:register(XMLValueType.ANGLE, basePath .. ".steeringNode(?)#offset" , "Rotation offset" , 0 )\n        schema:register(XMLValueType.BOOL, basePath .. ".steeringNode(?)#locked" , "Steering is locked" , false )\n        schema:register(XMLValueType.FLOAT, basePath .. ".steeringNode(?)#rotScale" , "Scale of rotation" )\n\n        schema:register(XMLValueType.NODE_INDEX, basePath .. ".node(?)#node" , "Node to adjust when the steering mode is active" )\n        schema:register(XMLValueType.VECTOR_ROT, basePath .. ".node(?)#rotation" , "Rotation when steering mode is active" )\n        schema:register(XMLValueType.VECTOR_TRANS, basePath .. ".node(?)#translation" , "Translation when steering mode is active" )\n\n        schema:register(XMLValueType.ANGLE, basePath .. ".articulatedAxis#offset" , "Articulated axis offset angle" , 0 )\n        schema:register(XMLValueType.BOOL, basePath .. ".articulatedAxis#locked" , "Articulated axis is locked" , false )\n        schema:register(XMLValueType.VECTOR_N, basePath .. ".articulatedAxis#wheelIndices" , "Wheel indices" )\n\n        schema:register(XMLValueType.STRING, basePath .. ".animation(?)#name" , "Change animation name" )\n        schema:register(XMLValueType.FLOAT, basePath .. ".animation(?)#speed" , "Animation speed" , 1 )\n        schema:register(XMLValueType.FLOAT, basePath .. ".animation(?)#stopTime" , "Animation stop time" )\n\n        schema:register(XMLValueType.NODE_INDEX, basePath .. ".steeringWheel#node" , "Steering wheel node" )\n        schema:register(XMLValueType.ANGLE, basePath .. ".steeringWheel#indoorRotation" , "Steering wheel indoor rotation" , 0 )\n        schema:register(XMLValueType.ANGLE, basePath .. ".steeringWheel#outdoorRotation" , "Steering wheel outdoor rotation" , 0 )\n    end\n\n'})}),"\n",(0,r.jsx)(n.h3,{id:"savetoxmlfile",children:"saveToXMLFile"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Description"})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Definition"})}),"\n",(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsx)(n.p,{children:"saveToXMLFile()"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,r.jsxs)(n.table,{children:[(0,r.jsx)(n.thead,{children:(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.th,{children:"any"}),(0,r.jsx)(n.th,{children:"xmlFile"})]})}),(0,r.jsxs)(n.tbody,{children:[(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"any"}),(0,r.jsx)(n.td,{children:"key"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"any"}),(0,r.jsx)(n.td,{children:"usedModNames"})]})]})]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Code"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-lua",children:'function CrabSteering:saveToXMLFile(xmlFile, key, usedModNames)\n    local spec = self.spec_crabSteering\n    if spec.hasSteeringModes then\n        xmlFile:setValue(key .. "#state" , spec.state)\n    end\nend\n\n'})}),"\n",(0,r.jsx)(n.h3,{id:"setcrabsteering",children:"setCrabSteering"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Description"})}),"\n",(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsx)(n.p,{children:"Change crap steering mode"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Definition"})}),"\n",(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsx)(n.p,{children:"setCrabSteering(integer state, boolean noEventSend)"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,r.jsxs)(n.table,{children:[(0,r.jsx)(n.thead,{children:(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.th,{children:"integer"}),(0,r.jsx)(n.th,{children:"state"}),(0,r.jsx)(n.th,{children:"new state"})]})}),(0,r.jsx)(n.tbody,{children:(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"boolean"}),(0,r.jsx)(n.td,{children:"noEventSend"}),(0,r.jsx)(n.td,{children:"no event send"})]})})]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Code"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-lua",children:'function CrabSteering:setCrabSteering(state, noEventSend)\n    local spec = self.spec_crabSteering\n\n    if noEventSend = = nil or noEventSend = = false then\n        if g_server ~ = nil then\n            g_server:broadcastEvent( SetCrabSteeringEvent.new( self , state), nil , nil , self )\n        else\n                g_client:getServerConnection():sendEvent( SetCrabSteeringEvent.new( self , state))\n            end\n        end\n\n        if state ~ = spec.state then\n            local currentMode = spec.steeringModes[spec.state]\n            if currentMode.animations ~ = nil then\n                for _,anim in pairs(currentMode.animations) do\n                    local curTime = self:getAnimationTime(anim.animName)\n                    if anim.stopTime = = nil then\n                        self:playAnimation(anim.animName, - anim.animSpeed, curTime, noEventSend)\n                    end\n                end\n            end\n            local newMode = spec.steeringModes[state]\n            if newMode.animations ~ = nil then\n                for _,anim in pairs(newMode.animations) do\n                    local curTime = self:getAnimationTime(anim.animName)\n                    if anim.stopTime ~ = nil then\n                        self:setAnimationStopTime(anim.animName, anim.stopTime)\n                        local speed = 1.0\n                        if curTime > anim.stopTime then\n                            speed = - 1.0\n                        end\n                        self:playAnimation(anim.animName, speed, curTime, noEventSend)\n                    else\n                            self:playAnimation(anim.animName, anim.animSpeed, curTime, noEventSend)\n                        end\n                    end\n                end\n\n                for _, steeringNodeData in pairs(newMode.steeringNodes) do\n                    local steeringNode = steeringNodeData.steeringNode\n\n                    steeringNode.offsetTarget = steeringNodeData.offset\n                    steeringNode.offsetTargetSpeed = math.abs(steeringNode.offsetTarget - steeringNode.offset) / (( 1 / spec.toggleSpeedFactor) * 1000 )\n\n                    if steeringNodeData.locked then\n                        steeringNode.rotScaleTarget = 0\n                    else\n                            steeringNode.rotScaleTarget = steeringNodeData.rotScale or steeringNode.rotScaleOrig\n                        end\n\n                        if newMode.steeringCenterNode ~ = nil then\n                            self.spec_wheels.steeringCenterNode = newMode.steeringCenterNode\n                            self:setAIRootNodeDirty()\n\n                            local rotMin, rotMax, inverted = Wheels.getAckermannSteeringAngles(steeringNode.node, newMode.steeringCenterNode, newMode.turningRadius or self.spec_wheels.maxTurningRadius)\n\n                            steeringNode.rotMin, steeringNode.rotMax = rotMin, rotMax\n                            steeringNode.rotSpeed, steeringNode.rotSpeedNeg = rotMax / self.wheelSteeringDuration, - rotMin / self.wheelSteeringDuration\n                            if inverted then\n                                steeringNode.rotSpeed, steeringNode.rotSpeedNeg = - steeringNode.rotSpeedNeg, - steeringNode.rotSpeed\n                            end\n                        else\n                                steeringNode.rotMin, steeringNode.rotMax = steeringNode.rotMinOrig, steeringNode.rotMaxOrig\n                                steeringNode.rotSpeed, steeringNode.rotSpeedNeg = steeringNode.rotSpeedOrig, steeringNode.rotSpeedNegOrig\n                            end\n\n                            steeringNode.rotScaleTargetSpeed = math.abs(steeringNode.rotScaleTarget - steeringNode.rotScale) / (( 1 / spec.toggleSpeedFactor) * 1000 )\n                        end\n\n                        for _, wheelProperties in pairs(newMode.wheels) do\n                            wheelProperties.wheel.steeringOffset = wheelProperties.wheel.steeringOffset or 0\n                            wheelProperties.wheel.steeringOffsetSpeed = math.abs(wheelProperties.offset - wheelProperties.wheel.steeringOffset) / (( 1 / spec.toggleSpeedFactor) * 1000 )\n                        end\n\n                        for _, node in ipairs(newMode.nodes) do\n                            if node.rotation ~ = nil then\n                                setRotation(node.node, node.rotation[ 1 ], node.rotation[ 2 ], node.rotation[ 3 ])\n                            end\n                            if node.translation ~ = nil then\n                                setTranslation(node.node, node.translation[ 1 ], node.translation[ 2 ], node.translation[ 3 ])\n                            end\n\n                            if self.setMovingToolDirty ~ = nil then\n                                self:setMovingToolDirty(node.node)\n                            end\n                        end\n                    end\n\n                    spec.state = state\n\n                    if self.isClient then\n                        if self.updateDashboardValueType ~ = nil then\n                            self:updateDashboardValueType( "crabSteering.state" )\n                        end\n                    end\n                end\n\n'})}),"\n",(0,r.jsx)(n.h3,{id:"startfieldworker",children:"startFieldWorker"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Description"})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Definition"})}),"\n",(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsx)(n.p,{children:"startFieldWorker()"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,r.jsx)(n.table,{children:(0,r.jsx)(n.thead,{children:(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.th,{children:"any"}),(0,r.jsx)(n.th,{children:"superFunc"})]})})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Code"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-lua",children:"function CrabSteering:startFieldWorker(superFunc)\n    local spec = self.spec_crabSteering\n    self:setCrabSteering(spec.aiSteeringModeIndex)\n\n    return superFunc( self )\nend\n\n"})}),"\n",(0,r.jsx)(n.h3,{id:"updatearticulatedaxisrotation",children:"updateArticulatedAxisRotation"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Description"})}),"\n",(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsx)(n.p,{children:"Update articulated axis rotation"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Definition"})}),"\n",(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsx)(n.p,{children:"updateArticulatedAxisRotation(float steeringAngle, float dt)"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,r.jsxs)(n.table,{children:[(0,r.jsx)(n.thead,{children:(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.th,{children:"float"}),(0,r.jsx)(n.th,{children:"steeringAngle"}),(0,r.jsx)(n.th,{children:"steering angle"})]})}),(0,r.jsx)(n.tbody,{children:(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"float"}),(0,r.jsx)(n.td,{children:"dt"}),(0,r.jsx)(n.td,{children:"time since last call in ms"})]})})]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Return Values"})}),"\n\n\n\n\n\n\n\n\n",(0,r.jsx)(n.table,{children:(0,r.jsx)(n.thead,{children:(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.th,{children:"float"}),(0,r.jsx)(n.th,{children:"steeringAngle"}),(0,r.jsx)(n.th,{children:"adjusted steering angle"})]})})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Code"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-lua",children:"function CrabSteering:updateArticulatedAxisRotation(steeringAngle, dt)\n    local spec = self.spec_crabSteering\n    local specArticulatedAxis = self.spec_articulatedAxis\n    local specDriveable = self.spec_drivable\n\n    if spec.stateMax = = 0 then\n        return steeringAngle\n    end\n\n    if not self.isServer then\n        return specArticulatedAxis.curRot\n    end\n\n    local currentMode = spec.steeringModes[spec.state]\n    if currentMode.articulatedAxis = = nil then\n        return steeringAngle\n    end\n\n    --\n    local rotScale = math.min( 1.0 / ( self.lastSpeed * specDriveable.speedRotScale + specDriveable.speedRotScaleOffset), 1 )\n    local delta = dt * 0.001 * self.autoRotateBackSpeed * rotScale * spec.toggleSpeedFactor\n\n    if spec.currentArticulatedAxisOffset < currentMode.articulatedAxis.offset then\n        spec.currentArticulatedAxisOffset = math.min(currentMode.articulatedAxis.offset, spec.currentArticulatedAxisOffset + delta)\n    elseif spec.currentArticulatedAxisOffset > currentMode.articulatedAxis.offset then\n            spec.currentArticulatedAxisOffset = math.max(currentMode.articulatedAxis.offset, spec.currentArticulatedAxisOffset - delta)\n        end\n\n        -- adjust rotSpeed\n        if currentMode.articulatedAxis.locked then\n            if specArticulatedAxis.rotSpeed > 0 then\n                specArticulatedAxis.rotSpeed = math.max( 0 , specArticulatedAxis.rotSpeed - delta)\n            elseif specArticulatedAxis.rotSpeed < 0 then\n                    specArticulatedAxis.rotSpeed = math.min( 0 , specArticulatedAxis.rotSpeed + delta)\n                end\n            else\n                    if specArticulatedAxis.rotSpeed > currentMode.articulatedAxis.rotSpeedBackUp then\n                        specArticulatedAxis.rotSpeed = math.max(currentMode.articulatedAxis.rotSpeedBackUp, specArticulatedAxis.rotSpeed - delta)\n                    elseif specArticulatedAxis.rotSpeed < currentMode.articulatedAxis.rotSpeedBackUp then\n                            specArticulatedAxis.rotSpeed = math.min(currentMode.articulatedAxis.rotSpeedBackUp, specArticulatedAxis.rotSpeed + delta)\n                        end\n                    end\n\n                    local rotSpeed\n                    if ( self.rotatedTime) * (currentMode.articulatedAxis.rotSpeedBackUp) > 0 then\n                        rotSpeed = (specArticulatedAxis.rotMax - spec.currentArticulatedAxisOffset) / self.wheelSteeringDuration\n                    else\n                            rotSpeed = (specArticulatedAxis.rotMin - spec.currentArticulatedAxisOffset) / self.wheelSteeringDuration\n                        end\n\n                        local f = math.abs(specArticulatedAxis.rotSpeed) / math.abs(currentMode.articulatedAxis.rotSpeedBackUp)\n                        rotSpeed = rotSpeed * f\n\n                        steeringAngle = spec.currentArticulatedAxisOffset + ( math.abs( self.rotatedTime) * rotSpeed)\n\n                        -- change rotation just if wheels are moving(so you don't have to steer in the opposite direction while turning on crab steering)\n                            if currentMode.articulatedAxis.wheelIndices ~ = nil and spec.distFromCompJointToCenterOfBackWheels ~ = nil and self.movingDirection > = 0 then\n                                local wheels = self:getWheels()\n\n                                local curRot = math.sign(currentMode.articulatedAxis.rotSpeedBackUp) * specArticulatedAxis.curRot\n\n                                local alpha = 0\n                                local count = 0\n                                for _,wheelIndex in pairs(currentMode.articulatedAxis.wheelIndices) do\n                                    alpha = alpha + wheels[wheelIndex].physics.steeringAngle\n                                    count = count + 1\n                                end\n                                if count > 0 then\n                                    alpha = alpha / count\n                                end\n                                alpha = alpha - curRot\n\n                                local v = 0\n                                count = 0\n                                for _,wheelIndex in pairs(currentMode.articulatedAxis.wheelIndices) do\n                                    local wheel = wheels[wheelIndex]\n                                    local axleSpeed = getWheelShapeAxleSpeed(wheel.node, wheel.physics.wheelShape) -- rad/sec\n                                    if wheel.physics.hasGroundContact then\n                                        local longSlip, _ = getWheelShapeSlip(wheel.node, wheel.physics.wheelShape)\n                                        local fac = 1.0 - math.min( 1.0 , longSlip)\n                                        v = v + fac * axleSpeed * wheel.physics.radius\n                                        count = count + 1\n                                    end\n                                end\n                                if count > 0 then\n                                    v = v / count\n                                end\n                                local h = v * 0.001 * dt\n                                local g = math.sin(alpha) * h\n                                local a = math.cos(alpha) * h\n                                local ls = spec.distFromCompJointToCenterOfBackWheels\n                                local beta = math.atan2(g, ls - a)\n\n                                steeringAngle = math.sign(currentMode.articulatedAxis.rotSpeedBackUp) * (curRot + beta)\n\n                                spec.articulatedAxisOffsetChanged = true\n                                spec.articulatedAxisLastAngle = steeringAngle\n                            else\n                                    local changingTime = spec.articulatedAxisChangingTime\n                                    if spec.articulatedAxisOffsetChanged then\n                                        changingTime = 2500\n                                        spec.articulatedAxisOffsetChanged = false\n                                    end\n\n                                    --smooth blending if steering change is from crab to normal\n                                        if changingTime > 0 then\n                                            local pos = changingTime / 2500\n                                            steeringAngle = steeringAngle * ( 1 - pos) + spec.articulatedAxisLastAngle * pos\n                                            spec.articulatedAxisChangingTime = changingTime - dt\n                                        end\n                                    end\n\n                                    steeringAngle = math.max(specArticulatedAxis.rotMin, math.min(specArticulatedAxis.rotMax, steeringAngle))\n\n                                    return steeringAngle\n                                end\n\n"})}),"\n",(0,r.jsx)(n.h3,{id:"updatesteeringangle",children:"updateSteeringAngle"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Description"})}),"\n",(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsx)(n.p,{children:"Update steering angle depending of the selected steering mode"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Definition"})}),"\n",(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsx)(n.p,{children:"updateSteeringAngle(table wheel, float dt, float steeringAngle, )"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,r.jsxs)(n.table,{children:[(0,r.jsx)(n.thead,{children:(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.th,{children:"table"}),(0,r.jsx)(n.th,{children:"wheel"}),(0,r.jsx)(n.th,{children:"wheel"})]})}),(0,r.jsxs)(n.tbody,{children:[(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"float"}),(0,r.jsx)(n.td,{children:"dt"}),(0,r.jsx)(n.td,{children:"time since last call in ms"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"float"}),(0,r.jsx)(n.td,{children:"steeringAngle"}),(0,r.jsx)(n.td,{children:"steering angle"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"any"}),(0,r.jsx)(n.td,{children:"steeringAngle"}),(0,r.jsx)(n.td,{})]})]})]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Return Values"})}),"\n\n\n\n\n\n\n\n\n",(0,r.jsx)(n.table,{children:(0,r.jsx)(n.thead,{children:(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.th,{children:"any"}),(0,r.jsx)(n.th,{children:"steeringAngle"}),(0,r.jsx)(n.th,{children:"adjusted steering angle"})]})})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Code"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-lua",children:"function CrabSteering:updateSteeringAngle(superFunc, wheel, dt, steeringAngle)\n    local spec = self.spec_crabSteering\n    local specDriveable = self.spec_drivable\n\n    if spec.stateMax = = 0 then\n        return superFunc( self , wheel, dt, steeringAngle)\n    end\n\n    local currentMode = spec.steeringModes[spec.state]\n    for i = 1 , #currentMode.wheels do\n        local wheelProperties = currentMode.wheels[i]\n        if wheelProperties.wheelIndex = = wheel.wheelIndex then\n            if wheel.rotSpeedBackUp = = nil then\n                wheel.rotSpeedBackUp = wheel.physics.rotSpeed\n            end\n\n            if wheel.rotSpeedBackUp ~ = 0 then\n                local rotScale = 0\n                if self.lastSpeed ~ = 0 then\n                    rotScale = math.min( 1.0 / ( self.lastSpeed * specDriveable.speedRotScale + specDriveable.speedRotScaleOffset), 1 )\n                end\n\n                local delta = dt * 0.001 * self.autoRotateBackSpeed * rotScale * spec.toggleSpeedFactor\n\n                if wheel.steeringOffset ~ = wheelProperties.offset then\n                    local direction = math.sign(wheelProperties.offset - wheel.steeringOffset)\n                    local change = dt * wheelProperties.wheel.steeringOffsetSpeed * direction\n                    local limit = direction > 0 and math.min or math.max\n                    wheel.steeringOffset = limit(wheel.steeringOffset + change, wheelProperties.offset)\n                end\n\n                if not wheelProperties.locked then\n                    local rotSpeed\n                    if self.rotatedTime > 0 then\n                        rotSpeed = (wheel.physics.rotMax - wheel.steeringOffset) / self.wheelSteeringDuration\n                        if wheel.rotSpeedBackUp < 0 then\n                            rotSpeed = (wheel.physics.rotMin - wheel.steeringOffset) / self.wheelSteeringDuration\n                        end\n                    else\n                            rotSpeed = - (wheel.physics.rotMin - wheel.steeringOffset) / self.wheelSteeringDuration\n                            if wheel.rotSpeedBackUp < 0 then\n                                rotSpeed = - (wheel.physics.rotMax - wheel.steeringOffset) / self.wheelSteeringDuration\n                            end\n                        end\n\n                        if wheel.physics.rotSpeed < wheel.rotSpeedBackUp then\n                            wheel.physics.rotSpeed = math.min(wheel.rotSpeedBackUp, wheel.physics.rotSpeed + delta)\n                        elseif wheel.physics.rotSpeed > wheel.rotSpeedBackUp then\n                                wheel.physics.rotSpeed = math.max(wheel.rotSpeedBackUp, wheel.physics.rotSpeed - delta)\n                            end\n                            local f = wheel.physics.rotSpeed / wheel.rotSpeedBackUp\n\n                            steeringAngle = wheel.steeringOffset + ( self.rotatedTime * f * rotSpeed)\n                        else\n                                if wheel.physics.steeringAngle > wheel.steeringOffset or steeringAngle > wheel.steeringOffset then\n                                    steeringAngle = math.max(wheel.steeringOffset, math.min(wheel.physics.steeringAngle, steeringAngle) - delta)\n                                elseif wheel.physics.steeringAngle < wheel.steeringOffset or steeringAngle < wheel.steeringOffset then\n                                        steeringAngle = math.min(wheel.steeringOffset, math.max(wheel.physics.steeringAngle, steeringAngle) + delta)\n                                    end\n\n                                    if steeringAngle = = wheel.steeringOffset then\n                                        wheel.physics.rotSpeed = 0\n                                    else\n                                            if wheel.physics.rotSpeed < 0 then\n                                                wheel.physics.rotSpeed = math.min( 0 , wheel.physics.rotSpeed + delta)\n                                            elseif wheel.physics.rotSpeed > 0 then\n                                                    wheel.physics.rotSpeed = math.max( 0 , wheel.physics.rotSpeed - delta)\n                                                end\n                                            end\n                                        end\n\n                                        steeringAngle = math.clamp(steeringAngle, wheel.physics.rotMin, wheel.physics.rotMax)\n                                    end\n\n                                    break\n                                end\n                            end\n\n                            return steeringAngle\n                        end\n\n"})}),"\n",(0,r.jsx)(n.h3,{id:"updatesteeringwheel",children:"updateSteeringWheel"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Description"})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Definition"})}),"\n",(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsx)(n.p,{children:"updateSteeringWheel()"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,r.jsxs)(n.table,{children:[(0,r.jsx)(n.thead,{children:(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.th,{children:"any"}),(0,r.jsx)(n.th,{children:"superFunc"})]})}),(0,r.jsxs)(n.tbody,{children:[(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"any"}),(0,r.jsx)(n.td,{children:"steeringWheel"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"any"}),(0,r.jsx)(n.td,{children:"dt"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"any"}),(0,r.jsx)(n.td,{children:"direction"})]})]})]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Code"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-lua",children:"function CrabSteering:updateSteeringWheel(superFunc, steeringWheel, dt, direction)\n    if self.spec_crabSteering.hasSteeringModes then\n        local spec = self.spec_crabSteering\n        local currentMode = spec.steeringModes[spec.state]\n        if currentMode.steeringWheel ~ = nil then\n            steeringWheel = currentMode.steeringWheel\n        end\n    end\n\n    superFunc( self , steeringWheel, dt, direction)\nend\n\n"})})]})}function h(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(o,{...e})}):o(e)}}}]);