"use strict";(globalThis.webpackChunkfs25_community_luadoc=globalThis.webpackChunkfs25_community_luadoc||[]).push([[68560],{28453(e,n,l){l.d(n,{R:()=>r,x:()=>a});var t=l(96540);const s={},i=t.createContext(s);function r(e){const n=t.useContext(i);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:r(e.components),t.createElement(i.Provider,{value:n},e.children)}},94414(e,n,l){l.r(n),l.d(n,{assets:()=>c,contentTitle:()=>a,default:()=>h,frontMatter:()=>r,metadata:()=>t,toc:()=>d});const t=JSON.parse('{"id":"script/Specializations/PlaceableFence","title":"PlaceableFence","description":"PlaceableFence","source":"@site/../docs/script/Specializations/PlaceableFence.md","sourceDirName":"script/Specializations","slug":"/script/Specializations/PlaceableFence","permalink":"/FS25-Community-LUADOC/script/Specializations/PlaceableFence","draft":false,"unlisted":false,"tags":[],"version":"current","lastUpdatedAt":1767161192000,"frontMatter":{},"sidebar":"docsSidebar","previous":{"title":"PlaceableFarmhouse","permalink":"/FS25-Community-LUADOC/script/Specializations/PlaceableFarmhouse"},"next":{"title":"PlaceableFoliageAreas","permalink":"/FS25-Community-LUADOC/script/Specializations/PlaceableFoliageAreas"}}');var s=l(74848),i=l(28453);const r={},a=void 0,c={},d=[{value:"PlaceableFence",id:"placeablefence",level:2},{value:"addPickingNodesForSegment",id:"addpickingnodesforsegment",level:3},{value:"addSegment",id:"addsegment",level:3},{value:"addSegmentShapesToUpdate",id:"addsegmentshapestoupdate",level:3},{value:"collectPickObjects",id:"collectpickobjects",level:3},{value:"createSegment",id:"createsegment",level:3},{value:"deletePanel",id:"deletepanel",level:3},{value:"deleteSegment",id:"deletesegment",level:3},{value:"doDeletePanel",id:"dodeletepanel",level:3},{value:"fakeRandomValueForPosition",id:"fakerandomvalueforposition",level:3},{value:"findRaycastInfo",id:"findraycastinfo",level:3},{value:"generateSegmentPoles",id:"generatesegmentpoles",level:3},{value:"getAllowExtendingOnly",id:"getallowextendingonly",level:3},{value:"getBoundingCheckWidth",id:"getboundingcheckwidth",level:3},{value:"getDestructionMethod",id:"getdestructionmethod",level:3},{value:"getGate",id:"getgate",level:3},{value:"getHasParallelSnapping",id:"gethasparallelsnapping",level:3},{value:"getIsPanelLengthFixed",id:"getispanellengthfixed",level:3},{value:"getMaxCornerAngle",id:"getmaxcornerangle",level:3},{value:"getMaxVerticalAngle",id:"getmaxverticalangle",level:3},{value:"getMaxVerticalAngleAndYForPreview",id:"getmaxverticalangleandyforpreview",level:3},{value:"getMaxVerticalGateAngle",id:"getmaxverticalgateangle",level:3},{value:"getNodesToDeleteForPanel",id:"getnodestodeleteforpanel",level:3},{value:"getNumSequments",id:"getnumsequments",level:3},{value:"getPanelLength",id:"getpanellength",level:3},{value:"getPoleNear",id:"getpolenear",level:3},{value:"getPoleNearOverlapCallback",id:"getpolenearoverlapcallback",level:3},{value:"getPolePosition",id:"getpoleposition",level:3},{value:"getPoleShapeForPreview",id:"getpoleshapeforpreview",level:3},{value:"getPreviewSegment",id:"getpreviewsegment",level:3},{value:"getSegment",id:"getsegment",level:3},{value:"getSegmentLength",id:"getsegmentlength",level:3},{value:"getSnapCheckDistance",id:"getsnapcheckdistance",level:3},{value:"getSnapDistance",id:"getsnapdistance",level:3},{value:"getSupportsParallelSnapping",id:"getsupportsparallelsnapping",level:3},{value:"isPoleInAnySegment",id:"ispoleinanysegment",level:3},{value:"loadFromXMLFile",id:"loadfromxmlfile",level:3},{value:"onDelete",id:"ondelete",level:3},{value:"onLoad",id:"onload",level:3},{value:"onReadStream",id:"onreadstream",level:3},{value:"onUpdate",id:"onupdate",level:3},{value:"onWriteStream",id:"onwritestream",level:3},{value:"performNodeDestruction",id:"performnodedestruction",level:3},{value:"prerequisitesPresent",id:"prerequisitespresent",level:3},{value:"previewNodeDestructionNodes",id:"previewnodedestructionnodes",level:3},{value:"recursivelyAddPickingNodes",id:"recursivelyaddpickingnodes",level:3},{value:"registerEventListeners",id:"registereventlisteners",level:3},{value:"registerEvents",id:"registerevents",level:3},{value:"registerFunctions",id:"registerfunctions",level:3},{value:"registerOverwrittenFunctions",id:"registeroverwrittenfunctions",level:3},{value:"registerSavegameXMLPaths",id:"registersavegamexmlpaths",level:3},{value:"registerXMLPaths",id:"registerxmlpaths",level:3},{value:"removePickingNodesForSegment",id:"removepickingnodesforsegment",level:3},{value:"saveToXMLFile",id:"savetoxmlfile",level:3},{value:"setOwnerFarmId",id:"setownerfarmid",level:3},{value:"setPreviewSegment",id:"setpreviewsegment",level:3},{value:"updateDirtyAreas",id:"updatedirtyareas",level:3},{value:"updateSegmentShapes",id:"updatesegmentshapes",level:3},{value:"updateSegmentUpdateQueue",id:"updatesegmentupdatequeue",level:3}];function o(e){const n={a:"a",blockquote:"blockquote",code:"code",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,i.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.h2,{id:"placeablefence",children:"PlaceableFence"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"Specialization for placeables"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Functions"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#addpickingnodesforsegment",children:"addPickingNodesForSegment"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#addsegment",children:"addSegment"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#addsegmentshapestoupdate",children:"addSegmentShapesToUpdate"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#collectpickobjects",children:"collectPickObjects"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#createsegment",children:"createSegment"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#deletepanel",children:"deletePanel"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#deletesegment",children:"deleteSegment"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#dodeletepanel",children:"doDeletePanel"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#fakerandomvalueforposition",children:"fakeRandomValueForPosition"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#findraycastinfo",children:"findRaycastInfo"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#generatesegmentpoles",children:"generateSegmentPoles"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#getallowextendingonly",children:"getAllowExtendingOnly"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#getboundingcheckwidth",children:"getBoundingCheckWidth"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#getdestructionmethod",children:"getDestructionMethod"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#getgate",children:"getGate"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#gethasparallelsnapping",children:"getHasParallelSnapping"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#getispanellengthfixed",children:"getIsPanelLengthFixed"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#getmaxcornerangle",children:"getMaxCornerAngle"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#getmaxverticalangle",children:"getMaxVerticalAngle"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#getmaxverticalangleandyforpreview",children:"getMaxVerticalAngleAndYForPreview"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#getmaxverticalgateangle",children:"getMaxVerticalGateAngle"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#getnodestodeleteforpanel",children:"getNodesToDeleteForPanel"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#getnumsequments",children:"getNumSequments"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#getpanellength",children:"getPanelLength"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#getpolenear",children:"getPoleNear"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#getpolenearoverlapcallback",children:"getPoleNearOverlapCallback"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#getpoleposition",children:"getPolePosition"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#getpoleshapeforpreview",children:"getPoleShapeForPreview"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#getpreviewsegment",children:"getPreviewSegment"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#getsegment",children:"getSegment"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#getsegmentlength",children:"getSegmentLength"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#getsnapcheckdistance",children:"getSnapCheckDistance"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#getsnapdistance",children:"getSnapDistance"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#getsupportsparallelsnapping",children:"getSupportsParallelSnapping"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#ispoleinanysegment",children:"isPoleInAnySegment"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#loadfromxmlfile",children:"loadFromXMLFile"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#ondelete",children:"onDelete"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#onload",children:"onLoad"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#onreadstream",children:"onReadStream"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#onupdate",children:"onUpdate"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#onwritestream",children:"onWriteStream"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#performnodedestruction",children:"performNodeDestruction"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#prerequisitespresent",children:"prerequisitesPresent"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#previewnodedestructionnodes",children:"previewNodeDestructionNodes"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#recursivelyaddpickingnodes",children:"recursivelyAddPickingNodes"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#registereventlisteners",children:"registerEventListeners"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#registerevents",children:"registerEvents"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#registerfunctions",children:"registerFunctions"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#registeroverwrittenfunctions",children:"registerOverwrittenFunctions"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#registersavegamexmlpaths",children:"registerSavegameXMLPaths"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#registerxmlpaths",children:"registerXMLPaths"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#removepickingnodesforsegment",children:"removePickingNodesForSegment"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#savetoxmlfile",children:"saveToXMLFile"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#setownerfarmid",children:"setOwnerFarmId"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#setpreviewsegment",children:"setPreviewSegment"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#updatedirtyareas",children:"updateDirtyAreas"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#updatesegmentshapes",children:"updateSegmentShapes"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#updatesegmentupdatequeue",children:"updateSegmentUpdateQueue"})}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"addpickingnodesforsegment",children:"addPickingNodesForSegment"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Definition"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"addPickingNodesForSegment()"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,s.jsx)(n.table,{children:(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"any"}),(0,s.jsx)(n.th,{children:"segment"})]})})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Code"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:"function PlaceableFence:addPickingNodesForSegment(segment)\n    if segment = = self.spec_fence.previewSegment then\n        return\n    end\n\n    if segment.group ~ = nil then\n        local objects = { }\n        self:recursivelyAddPickingNodes(objects, segment.group)\n\n        for i = 1 , #objects do\n            g_currentMission:addNodeObject(objects[i], self )\n        end\n    end\n\n    -- Reset\n    self.overlayColorNodes = nil\nend\n\n"})}),"\n",(0,s.jsx)(n.h3,{id:"addsegment",children:"addSegment"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Definition"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"addSegment()"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"any"}),(0,s.jsx)(n.th,{children:"segment"})]})}),(0,s.jsx)(n.tbody,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"any"}),(0,s.jsx)(n.td,{children:"sync"})]})})]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Code"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:"function PlaceableFence:addSegment(segment, sync)\n    local spec = self.spec_fence\n    spec.segments[#spec.segments + 1 ] = segment\n\n    self:generateSegmentPoles(segment, sync)\nend\n\n"})}),"\n",(0,s.jsx)(n.h3,{id:"addsegmentshapestoupdate",children:"addSegmentShapesToUpdate"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Definition"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"addSegmentShapesToUpdate()"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,s.jsx)(n.table,{children:(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"any"}),(0,s.jsx)(n.th,{children:"segment"})]})})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Code"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:"function PlaceableFence:addSegmentShapesToUpdate(segment)\n    local spec = self.spec_fence\n    spec.segmentsToUpdate[#spec.segmentsToUpdate + 1 ] = segment\n\n    self:raiseActive()\nend\n\n"})}),"\n",(0,s.jsx)(n.h3,{id:"collectpickobjects",children:"collectPickObjects"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Definition"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"collectPickObjects()"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"any"}),(0,s.jsx)(n.th,{children:"superFunc"})]})}),(0,s.jsx)(n.tbody,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"any"}),(0,s.jsx)(n.td,{children:"node"})]})})]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Code"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:"function PlaceableFence:collectPickObjects(superFunc, node)\n    ---Default picking objects is disabled\nend\n\n"})}),"\n",(0,s.jsx)(n.h3,{id:"createsegment",children:"createSegment"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Definition"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"createSegment()"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"any"}),(0,s.jsx)(n.th,{children:"x1"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"any"}),(0,s.jsx)(n.td,{children:"z1"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"any"}),(0,s.jsx)(n.td,{children:"x2"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"any"}),(0,s.jsx)(n.td,{children:"z2"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"any"}),(0,s.jsx)(n.td,{children:"renderFirst"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"any"}),(0,s.jsx)(n.td,{children:"gateIndex"})]})]})]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Code"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:"function PlaceableFence:createSegment(x1, z1, x2, z2, renderFirst, gateIndex)\n    return {\n    x1 = x1,\n    z1 = z1,\n    x2 = x2,\n    z2 = z2,\n    renderFirst = renderFirst, -- whether to render the first pole\n    renderLast = true ,\n    gateIndex = gateIndex,\n    poles = { } , -- list of pole positions\n    }\nend\n\n"})}),"\n",(0,s.jsx)(n.h3,{id:"deletepanel",children:"deletePanel"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"Called by server or client directly on click"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Definition"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"deletePanel()"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,s.jsx)(n.table,{children:(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"any"}),(0,s.jsx)(n.th,{children:"node"})]})})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Code"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:"function PlaceableFence:deletePanel(node)\n    if node = = nil or node = = 0 or getCollisionFilterMask(node) = = 0 then\n        return\n    end\n\n    local spec = self.spec_fence\n    local panel, _, segment, _, poleIndex = self:findRaycastInfo(node)\n    if panel = = nil then\n        return nil\n    end\n\n    local segmentIndex = 1\n    for i = 1 , #spec.segments do\n        if spec.segments[i] = = segment then\n            segmentIndex = i\n            break\n        end\n    end\n\n    if self.isServer then\n        self:doDeletePanel(segment, segmentIndex, poleIndex)\n\n        g_server:broadcastEvent( PlaceableFenceRemoveSegmentEvent.new( self , segmentIndex, poleIndex), false )\n    else\n            -- Set collision mask so we cannot hit it again while it is in transport\n                setCollisionFilterMask(node, 0 )\n\n                -- Request change on server\n                g_client:getServerConnection():sendEvent( PlaceableFenceRemoveSegmentEvent.new( self , segmentIndex, poleIndex))\n            end\n\n            return true\n        end\n\n"})}),"\n",(0,s.jsx)(n.h3,{id:"deletesegment",children:"deleteSegment"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"Delete a segment with its nodes."}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Definition"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"deleteSegment()"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,s.jsx)(n.table,{children:(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"any"}),(0,s.jsx)(n.th,{children:"segment"})]})})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Code"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:"function PlaceableFence:deleteSegment(segment)\n    local spec = self.spec_fence\n    if segment.animatedObject ~ = nil then\n        segment.animatedObject:delete()\n        segment.animatedObject = nil\n    end\n\n    if segment.group ~ = nil then\n        delete(segment.group)\n        segment.group = nil\n    end\n\n    if segment.pendingUpdateTimer ~ = nil then\n        segment.pendingUpdateTimer:delete()\n        segment.pendingUpdateTimer = nil\n    end\n\n    if self.cellIdToSegments ~ = nil then\n        local terrainDeformationSyncer = g_currentMission.terrainDeformationSyncer\n        for cellId, segments in pairs( self.cellIdToSegments) do\n            segments[segment] = nil\n            if next(segments) = = nil then\n                self.cellIdToSegments[cellId] = nil\n\n                local cellX, cellZ = terrainDeformationSyncer:getCellIndicesById(cellId)\n                terrainDeformationSyncer:removeCellUpdateListener( self , cellX, cellZ)\n            end\n        end\n    end\n\n    table.removeElement(spec.segments, segment)\n\n    self:updateDirtyAreas(segment.x1, segment.z1, segment.x2, segment.z2)\nend\n\n"})}),"\n",(0,s.jsx)(n.h3,{id:"dodeletepanel",children:"doDeletePanel"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Definition"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"doDeletePanel()"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"any"}),(0,s.jsx)(n.th,{children:"segment"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"any"}),(0,s.jsx)(n.td,{children:"segmentIndex"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"any"}),(0,s.jsx)(n.td,{children:"poleIndex"})]})]})]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Code"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:"function PlaceableFence:doDeletePanel(segment, segmentIndex, poleIndex)\n    if segment = = nil or poleIndex > #segment.poles then\n        return\n    end\n\n    if segment.pendingUpdateTimer ~ = nil then\n        segment.pendingUpdateTimer:delete()\n        segment.pendingUpdateTimer = nil\n    end\n\n    if self.cellIdToSegments ~ = nil then\n        local terrainDeformationSyncer = g_currentMission.terrainDeformationSyncer\n        for cellId, segments in pairs( self.cellIdToSegments) do\n            segments[segment] = nil\n            if next(segments) = = nil then\n                self.cellIdToSegments[cellId] = nil\n\n                local cellX, cellZ = terrainDeformationSyncer:getCellIndicesById(cellId)\n                terrainDeformationSyncer:removeCellUpdateListener( self , cellX, cellZ)\n            end\n        end\n    end\n\n    -- We mark any poles we delete as deleted when they might cause a\n    -- non-rendered pole in another segment.\n    local deletedPoles = { }\n\n    local x1OrigSeg, x2OrigSeg, z1OrigSeg, z2OrigSeg = segment.x1, segment.x2, segment.z1, segment.z2\n\n    local segmentSizeChanged = false\n\n    -- Start of segment:delete the pole by moving segment start to next pole\n    if poleIndex = = 1 then\n        if segment.renderFirst then\n            deletedPoles[#deletedPoles + 1 ] = segment.poles[ 1 ]\n            deletedPoles[#deletedPoles + 1 ] = segment.poles[ 2 ]\n        end\n\n        -- If there is only 1 more pole, delete\n        if poleIndex + 2 = = #segment.poles - 1 then\n            if segment.renderLast then\n                deletedPoles[#deletedPoles + 1 ] = segment.poles[ 3 ]\n                deletedPoles[#deletedPoles + 1 ] = segment.poles[ 4 ]\n            end\n\n            self:removePickingNodesForSegment(segment)\n            self:deleteSegment(segment)\n        else\n                segment.x1 = segment.poles[ 3 ]\n                segment.z1 = segment.poles[ 4 ]\n\n                segmentSizeChanged = true\n                segment.renderFirst = true\n            end\n\n            -- Next pole is last in line(this is the last panel)\n        elseif poleIndex + 2 = = #segment.poles - 1 then\n                -- Shorten the segment\n\n                if segment.renderLast then\n                    deletedPoles[#deletedPoles + 1 ] = segment.poles[#segment.poles - 1 ]\n                    deletedPoles[#deletedPoles + 1 ] = segment.poles[#segment.poles]\n                end\n\n                segment.x2 = segment.poles[#segment.poles - 3 ]\n                segment.z2 = segment.poles[#segment.poles - 2 ]\n\n                segment.renderLast = true\n\n                segmentSizeChanged = true\n            else\n                    -- Create second part\n                    local newSegment = self:createSegment(segment.poles[poleIndex + 2 ], segment.poles[poleIndex + 3 ], segment.x2, segment.z2, true , nil )\n                    newSegment.renderLast = segment.renderLast -- copy\n                    newSegment.renderFirst = true -- we moved the start to an existing pole, so enable this pole\n\n                    -- Adjust first part\n                    segment.x2 = segment.poles[poleIndex]\n                    segment.z2 = segment.poles[poleIndex + 1 ]\n                    segment.renderLast = true\n\n                    self:addSegment(newSegment)\n                    self:registerTerrainHeightChangeCallbacks(newSegment)\n                    segmentSizeChanged = true\n\n                    -- Note:no poles were removed as only the panel visually is gone.\n                end\n\n                -- Do not update gates! They cannot resize anyway\n                if segmentSizeChanged then\n                    self:generateSegmentPoles(segment, true )\n                    self:registerTerrainHeightChangeCallbacks(segment)\n                end\n\n                -- For any pole that has changed, find if it matches the start or end of another segment\n                -- If it does mark that segment as needing to render the pole again.Only the first segment we find though\n                for i = 1 , #deletedPoles, 2 do\n                    local x, z = deletedPoles[i], deletedPoles[i + 1 ]\n                    local neighborSegment, isStart = self:isPoleInAnySegment(x, z, segment)\n\n                    if neighborSegment ~ = nil then\n                        if isStart then\n                            neighborSegment.renderFirst = true\n                        else\n                                neighborSegment.renderLast = true\n                            end\n\n                            self:generateSegmentPoles(neighborSegment, true )\n                        end\n                    end\n\n                    -- We need to update areas where panels are not anymore\n                    self:updateDirtyAreas(x1OrigSeg, z1OrigSeg, x2OrigSeg, z2OrigSeg)\n\n                    return true\n                end\n\n"})}),"\n",(0,s.jsx)(n.h3,{id:"fakerandomvalueforposition",children:"fakeRandomValueForPosition"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"Generate a value [0,1] for a position that is always consistent but highly affected by the position"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Definition"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"fakeRandomValueForPosition()"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"any"}),(0,s.jsx)(n.th,{children:"x"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"any"}),(0,s.jsx)(n.td,{children:"y"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"any"}),(0,s.jsx)(n.td,{children:"z"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"any"}),(0,s.jsx)(n.td,{children:"n"})]})]})]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Code"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:"function PlaceableFence:fakeRandomValueForPosition(x, y, z, n)\n    local alpha = (x * 0.13 + z * 0.23 ) % 1\n\n    if n = = nil then\n        return alpha\n    end\n\n    -- Integer from 1 to n(inclusive)\n    return math.floor(alpha * (n - 1 ) + 0.5 ) + 1\nend\n\n"})}),"\n",(0,s.jsx)(n.h3,{id:"findraycastinfo",children:"findRaycastInfo"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Definition"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"findRaycastInfo()"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,s.jsx)(n.table,{children:(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"any"}),(0,s.jsx)(n.th,{children:"node"})]})})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Code"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:"function PlaceableFence:findRaycastInfo(node)\n    local spec = self.spec_fence\n    -- Raycasts hit collisions.Find the visual\n    -- This collision could be a pole or a panel! If it is the pole, just return the pole info\n\n    local collision = node\n    local panel = getParent(collision)\n\n    local panelVisuals = getChildAt(panel, 1 )\n\n    -- Find which segment this is.We'll also find if the node was actually a panel\n        local segment = nil\n\n        -- Each panel has as parent the pole\n        local pole = getParent(panel)\n\n        -- Each pole has as parent the segment group\n        local sGroup = getParent(pole)\n        for si = 1 , #spec.segments do\n            local seg = spec.segments[si]\n            if seg.group = = sGroup then\n                segment = seg\n                break\n\n                -- Special case are gates because of doors or pole selection\n            elseif seg.group = = pole and seg.gateIndex ~ = nil then\n                    segment = seg\n\n                    -- The pole is actually the group\n                    sGroup = pole\n\n                    -- Thus update all references\n                    pole = panel\n                    -- First nodes are poles, last one is panel.\n                    panel = getChildAt(sGroup, getNumOfChildren(sGroup) - 1 )\n                    panelVisuals = getChildAt(panel, 1 ) -- first is col, second is visuals\n\n                    break\n                end\n            end\n\n            -- No segment then the requested node was not a panel\n            if segment = = nil then\n                -- Try to find information assuming the node is a pole instead\n                collision = node\n                --panel = getChildAt(collision, 0)\n                pole = getParent(collision)\n\n                sGroup = getParent(pole)\n                for si = 1 , #spec.segments do\n                    local seg = spec.segments[si]\n                    if seg.group = = sGroup then\n                        segment = seg\n                        break\n                    end\n                end\n\n                if segment = = nil then\n                    return nil\n                end\n\n                local poleIndex = getChildIndex(pole) * 2 + 1\n                return nil , nil , segment, pole, poleIndex\n            end\n\n            local poleIndex\n            if segment.gateIndex ~ = nil then\n                poleIndex = 1\n            else\n                    poleIndex = getChildIndex(pole) * 2 + 1\n                end\n\n                return panel, panelVisuals, segment, pole, poleIndex\n            end\n\n"})}),"\n",(0,s.jsx)(n.h3,{id:"generatesegmentpoles",children:"generateSegmentPoles"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"Generate all poles for the segment\nIn this setup, we add as many as possible whole-size elements. Then for the last, we\nmake the fences equally sized."}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Definition"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"generateSegmentPoles()"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"any"}),(0,s.jsx)(n.th,{children:"segment"})]})}),(0,s.jsx)(n.tbody,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"any"}),(0,s.jsx)(n.td,{children:"sync"})]})})]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Code"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:"function PlaceableFence:generateSegmentPoles(segment, sync)\n    local spec = self.spec_fence\n    local totalDistance = MathUtil.getPointPointDistance(segment.x1, segment.z1, segment.x2, segment.z2)\n    local numWholeFences = math.max( math.floor(totalDistance / spec.panelLength) - 1 , 0 )\n\n    for i = 1 , #segment.poles do\n        segment.poles[i] = nil\n    end\n\n    if totalDistance < 0.01 then\n        return\n    end\n\n    -- For gates we only show first and last pole\n    if segment.gateIndex ~ = nil then\n        segment.poles[ 1 ] = segment.x1\n        segment.poles[ 2 ] = segment.z1\n        segment.poles[ 3 ] = segment.x2\n        segment.poles[ 4 ] = segment.z2\n    else\n            local nextPole = 1\n            for j = 0 , numWholeFences do\n                local alpha = (spec.panelLength * j) / totalDistance\n\n                segment.poles[nextPole] = MathUtil.lerp(segment.x1, segment.x2, alpha)\n                segment.poles[nextPole + 1 ] = MathUtil.lerp(segment.z1, segment.z2, alpha)\n                nextPole = nextPole + 2\n            end\n\n            -- Final 2 posts\n            local restDistance = totalDistance - (numWholeFences * spec.panelLength)\n            local numRestFences = restDistance < = spec.panelLength * 1.2 and 1 or 2\n            local restFenceSize = restDistance / numRestFences\n\n            for j = 0 , numRestFences - 1 do\n                local alpha = ((numWholeFences * spec.panelLength) + (j + 1 ) * restFenceSize) / totalDistance\n\n                segment.poles[nextPole] = MathUtil.lerp(segment.x1, segment.x2, alpha)\n                segment.poles[nextPole + 1 ] = MathUtil.lerp(segment.z1, segment.z2, alpha)\n                nextPole = nextPole + 2\n            end\n        end\n\n        if sync then\n            self:removePickingNodesForSegment(segment)\n            self:updateSegmentShapes(segment)\n            self:addPickingNodesForSegment(segment)\n        else\n                self:addSegmentShapesToUpdate(segment)\n            end\n\n            -- Segment was updated, tell dependent systems\n            if spec.previewSegment ~ = segment then\n                self:updateDirtyAreas(segment.x1, segment.z1, segment.x2, segment.z2)\n            end\n        end\n\n"})}),"\n",(0,s.jsx)(n.h3,{id:"getallowextendingonly",children:"getAllowExtendingOnly"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Definition"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"getAllowExtendingOnly()"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Code"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:"function PlaceableFence:getAllowExtendingOnly()\n    return self.spec_fence.allowExtendingOnly\nend\n\n"})}),"\n",(0,s.jsx)(n.h3,{id:"getboundingcheckwidth",children:"getBoundingCheckWidth"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Definition"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"getBoundingCheckWidth()"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Code"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:"function PlaceableFence:getBoundingCheckWidth()\n    return self.spec_fence.boundingCheckWidth\nend\n\n"})}),"\n",(0,s.jsx)(n.h3,{id:"getdestructionmethod",children:"getDestructionMethod"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"Deletion is in pieces so not instantly"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Definition"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"getDestructionMethod()"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,s.jsx)(n.table,{children:(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"any"}),(0,s.jsx)(n.th,{children:"superFunc"})]})})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Code"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:"function PlaceableFence:getDestructionMethod(superFunc)\n    return Placeable.DESTRUCTION.PER_NODE\nend\n\n"})}),"\n",(0,s.jsx)(n.h3,{id:"getgate",children:"getGate"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Definition"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"getGate()"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,s.jsx)(n.table,{children:(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"any"}),(0,s.jsx)(n.th,{children:"index"})]})})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Code"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:"function PlaceableFence:getGate(index)\n    local spec = self.spec_fence\n    return spec.gates[index]\nend\n\n"})}),"\n",(0,s.jsx)(n.h3,{id:"gethasparallelsnapping",children:"getHasParallelSnapping"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Definition"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"getHasParallelSnapping()"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Code"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:"function PlaceableFence:getHasParallelSnapping()\n    return false\nend\n\n"})}),"\n",(0,s.jsx)(n.h3,{id:"getispanellengthfixed",children:"getIsPanelLengthFixed"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Definition"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"getIsPanelLengthFixed()"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Code"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:"function PlaceableFence:getIsPanelLengthFixed()\n    return self.spec_fence.panelLengthFixed\nend\n\n"})}),"\n",(0,s.jsx)(n.h3,{id:"getmaxcornerangle",children:"getMaxCornerAngle"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Definition"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"getMaxCornerAngle()"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Code"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:"function PlaceableFence:getMaxCornerAngle()\n    return self.spec_fence.maxCornerAngle\nend\n\n"})}),"\n",(0,s.jsx)(n.h3,{id:"getmaxverticalangle",children:"getMaxVerticalAngle"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Definition"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"getMaxVerticalAngle()"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Code"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:"function PlaceableFence:getMaxVerticalAngle()\n    local spec = self.spec_fence\n    return spec.maxVerticalAngle\nend\n\n"})}),"\n",(0,s.jsx)(n.h3,{id:"getmaxverticalangleandyforpreview",children:"getMaxVerticalAngleAndYForPreview"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"Get the difference in height and the angle"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Definition"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"getMaxVerticalAngleAndYForPreview()"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Code"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:"function PlaceableFence:getMaxVerticalAngleAndYForPreview()\n    local spec = self.spec_fence\n    local segment = spec.previewSegment\n    local maxAngle = 0\n    local minY, maxY = 1000 , - 1000\n\n    for i = 1 , #segment.poles - 2 , 2 do\n        local x1 = segment.poles[i]\n        local z1 = segment.poles[i + 1 ]\n        local x2 = segment.poles[i + 2 ]\n        local z2 = segment.poles[i + 3 ]\n\n        local horizontalDifference = MathUtil.getPointPointDistance(x1, z1, x2, z2)\n\n        local y1 = getTerrainHeightAtWorldPos(g_terrainNode, x1, 0 , z1)\n        local y2 = getTerrainHeightAtWorldPos(g_terrainNode, x2, 0 , z2)\n        local heightDifference = math.abs(y1 - y2)\n\n        minY = math.min(minY, y1, y2)\n        maxY = math.max(maxY, y1, y2)\n\n        if horizontalDifference > 0 then\n            local angle = math.atan(heightDifference / horizontalDifference)\n            if angle > maxAngle then\n                maxAngle = angle\n            end\n        end\n    end\n\n    return maxAngle, minY, maxY\nend\n\n"})}),"\n",(0,s.jsx)(n.h3,{id:"getmaxverticalgateangle",children:"getMaxVerticalGateAngle"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Definition"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"getMaxVerticalGateAngle()"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Code"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:"function PlaceableFence:getMaxVerticalGateAngle()\n    local spec = self.spec_fence\n    return spec.maxVerticalGateAngle\nend\n\n"})}),"\n",(0,s.jsx)(n.h3,{id:"getnodestodeleteforpanel",children:"getNodesToDeleteForPanel"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"Get the nodes that would be deleted if the given panel node would be\nUsed for previewing"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Definition"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"getNodesToDeleteForPanel()"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,s.jsx)(n.table,{children:(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"any"}),(0,s.jsx)(n.th,{children:"node"})]})})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Code"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:"function PlaceableFence:getNodesToDeleteForPanel(node)\n    local spec = self.spec_fence\n    local panel, panelVisuals, segment, pole, poleIndex = self:findRaycastInfo(node)\n    if panel = = nil or node = = 0 then\n        return nil\n    end\n\n    -- Collect nodes\n    local nodes = {\n    }\n\n    if segment.gateIndex ~ = nil then\n        -- Add all doors\n        local gateInfo = spec.gates[segment.gateIndex]\n        for _, door in ipairs(gateInfo.doors) do\n            local doorNode = getChildAt(panel, door.node)\n            nodes[#nodes + 1 ] = getChildAt(doorNode, 0 ) -- visual\n        end\n    else\n            -- Add the panel\n            nodes[ 1 ] = panelVisuals\n        end\n\n        local function addPole(poleNode, x, z)\n            if self:isPoleInAnySegment(x, z, segment) = = nil then\n                local visualPole = getChildAt(poleNode, 1 )\n                if visualPole ~ = 0 then\n                    table.insert(nodes, visualPole)\n                end\n            end\n        end\n\n        -- If the pole of the panel is the first pole it would become lonely and should be removed\n        if poleIndex = = 1 and segment.renderFirst then\n            addPole(pole, segment.poles[ 1 ], segment.poles[ 2 ])\n        end\n\n        -- If the pole after the panel-pole is the last pole, also delete it\n        if poleIndex + 2 = = #segment.poles - 1 and segment.renderLast then\n            addPole(getChildAt(segment.group, #segment.poles / 2 - 1 ), segment.poles[#segment.poles - 1 ], segment.poles[#segment.poles])\n        end\n\n        return nodes\n    end\n\n"})}),"\n",(0,s.jsx)(n.h3,{id:"getnumsequments",children:"getNumSequments"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Definition"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"getNumSequments()"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Code"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:"function PlaceableFence:getNumSequments()\n    local spec = self.spec_fence\n    return #spec.segments\nend\n\n"})}),"\n",(0,s.jsx)(n.h3,{id:"getpanellength",children:"getPanelLength"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Definition"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"getPanelLength()"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Code"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:"function PlaceableFence:getPanelLength()\n    return self.spec_fence.panelLength\nend\n\n"})}),"\n",(0,s.jsx)(n.h3,{id:"getpolenear",children:"getPoleNear"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"Get a pole that is near given position or nil if none."}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Definition"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"getPoleNear()"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"any"}),(0,s.jsx)(n.th,{children:"x"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"any"}),(0,s.jsx)(n.td,{children:"y"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"any"}),(0,s.jsx)(n.td,{children:"z"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"any"}),(0,s.jsx)(n.td,{children:"maxDistance"})]})]})]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Return Values"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Type"}),(0,s.jsx)(n.th,{children:"Return Value"})]})}),(0,s.jsx)(n.tbody,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"any"}),(0,s.jsx)(n.td,{})]})})]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Code"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:'function PlaceableFence:getPoleNear(x, y, z, maxDistance)\n    local spec = self.spec_fence\n    spec.getPoleNearResult = nil\n    spec.getPoleNearResultSegment = nil\n    spec.getPoleNearResultDistance = math.huge\n    spec.getPoleNearResultPosition = { x, y, z }\n\n    overlapSphere(x, y, z, maxDistance, "getPoleNearOverlapCallback" , self , CollisionFlag.STATIC_OBJECT, false , false , true , true )\n\n    if spec.getPoleNearResult ~ = nil then\n        local pole_x, pole_y, pole_z = getWorldTranslation(spec.getPoleNearResult)\n        return pole_x, pole_y, pole_z, spec.getPoleNearResult, spec.getPoleNearResultSegment\n    end\n\n    return nil\nend\n\n'})}),"\n",(0,s.jsx)(n.h3,{id:"getpolenearoverlapcallback",children:"getPoleNearOverlapCallback"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Definition"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"getPoleNearOverlapCallback()"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,s.jsx)(n.table,{children:(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"any"}),(0,s.jsx)(n.th,{children:"hitObjectId"})]})})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Code"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:"function PlaceableFence:getPoleNearOverlapCallback(hitObjectId)\n    if hitObjectId = = 0 or hitObjectId = = g_terrainNode then\n        return\n    end\n\n    local sGroup = getParent(getParent(hitObjectId))\n    local spec = self.spec_fence\n    local x, y, z = getWorldTranslation(hitObjectId)\n    local distance = MathUtil.vector3Length(x - spec.getPoleNearResultPosition[ 1 ], y - spec.getPoleNearResultPosition[ 2 ], z - spec.getPoleNearResultPosition[ 3 ])\n    if distance < spec.getPoleNearResultDistance then\n        for _, segment in ipairs(spec.segments) do\n            if segment.group = = sGroup then\n                -- A gate has at least 3 parts:trigger, 1 gate, and gate-visuals(hinges)\n                -- We need to ignore gates so we attach to poles only\n                if getNumOfChildren(hitObjectId) < 3 then\n                    spec.getPoleNearResult = hitObjectId\n                    spec.getPoleNearResultSegment = segment\n                    spec.getPoleNearResultDistance = distance\n                end\n            end\n        end\n    end\n\n    return true\nend\n\n"})}),"\n",(0,s.jsx)(n.h3,{id:"getpoleposition",children:"getPolePosition"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"Get whether the node is a fence pole and if so, get its position"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Definition"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"getPolePosition()"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"any"}),(0,s.jsx)(n.th,{children:"node"})]})}),(0,s.jsx)(n.tbody,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"any"}),(0,s.jsx)(n.td,{children:"allowPanel"})]})})]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Code"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:"function PlaceableFence:getPolePosition(node, allowPanel)\n    local spec = self.spec_fence\n    local collision = node\n    local item = getParent(collision)\n\n    -- Parent of item can be a segment(for poles), or a pole(for panels)\n        local parent = getParent(item)\n\n        -- Panels are children of poles\n        local parent2\n        if allowPanel and parent ~ = getRootNode() then\n            parent2 = getParent(parent)\n        end\n\n        for i = 1 , #spec.segments do\n            local segment = spec.segments[i]\n\n            -- If group matches, the node is part of this fence\n            if parent = = segment.group then\n                -- pole\n                local x, y, z = getWorldTranslation(item)\n                return x, y, z, segment\n            elseif parent2 = = segment.group then\n                    -- panel\n                    local x, y, z = getWorldTranslation(parent) -- the pole\n                    return x, y, z, segment\n                end\n            end\n\n            return nil\n        end\n\n"})}),"\n",(0,s.jsx)(n.h3,{id:"getpoleshapeforpreview",children:"getPoleShapeForPreview"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"Get a pole shape for previewing. Caller must delete"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Definition"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"getPoleShapeForPreview()"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Code"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:"function PlaceableFence:getPoleShapeForPreview()\n    local spec = self.spec_fence\n    if spec.hasInvisiblePoles then\n        return nil\n    end\n\n    if #spec.poles > 0 then\n        if getNumOfChildren(spec.poles[ 1 ]) = = 0 then\n            return nil\n        end\n\n        local pole = clone(spec.poles[ 1 ], false , false , false )\n        if pole = = 0 then\n            return nil\n        end\n\n        return pole\n    else\n            return nil\n        end\n    end\n\n"})}),"\n",(0,s.jsx)(n.h3,{id:"getpreviewsegment",children:"getPreviewSegment"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Definition"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"getPreviewSegment()"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Code"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:"function PlaceableFence:getPreviewSegment()\n    local spec = self.spec_fence\n    return spec.previewSegment\nend\n\n"})}),"\n",(0,s.jsx)(n.h3,{id:"getsegment",children:"getSegment"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Definition"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"getSegment()"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,s.jsx)(n.table,{children:(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"any"}),(0,s.jsx)(n.th,{children:"index"})]})})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Code"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:"function PlaceableFence:getSegment(index)\n    local spec = self.spec_fence\n    return spec.segments[index]\nend\n\n"})}),"\n",(0,s.jsx)(n.h3,{id:"getsegmentlength",children:"getSegmentLength"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"Get the length of a segment"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Definition"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"getSegmentLength()"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,s.jsx)(n.table,{children:(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"any"}),(0,s.jsx)(n.th,{children:"segment"})]})})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Code"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:"function PlaceableFence:getSegmentLength(segment)\n    return MathUtil.getPointPointDistance(segment.x1, segment.z1, segment.x2, segment.z2)\nend\n\n"})}),"\n",(0,s.jsx)(n.h3,{id:"getsnapcheckdistance",children:"getSnapCheckDistance"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Definition"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"getSnapCheckDistance()"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Code"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:"function PlaceableFence:getSnapCheckDistance()\n    return self.spec_fence.snapCheckDistance\nend\n\n"})}),"\n",(0,s.jsx)(n.h3,{id:"getsnapdistance",children:"getSnapDistance"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Definition"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"getSnapDistance()"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Code"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:"function PlaceableFence:getSnapDistance()\n    return self.spec_fence.snapDistance\nend\n\n"})}),"\n",(0,s.jsx)(n.h3,{id:"getsupportsparallelsnapping",children:"getSupportsParallelSnapping"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Definition"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"getSupportsParallelSnapping()"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Code"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:"function PlaceableFence:getSupportsParallelSnapping()\n    return self.spec_fence.supportsParallelSnapping\nend\n\n"})}),"\n",(0,s.jsx)(n.h3,{id:"ispoleinanysegment",children:"isPoleInAnySegment"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"Get whether given exact pole position is in any segment. Only checks start and end of segment"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Definition"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"isPoleInAnySegment()"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"any"}),(0,s.jsx)(n.th,{children:"x"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"any"}),(0,s.jsx)(n.td,{children:"z"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"any"}),(0,s.jsx)(n.td,{children:"ignoreSegment"})]})]})]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Code"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:"function PlaceableFence:isPoleInAnySegment(x, z, ignoreSegment)\n    local spec = self.spec_fence\n    for i = 1 , #spec.segments do\n        local segment = spec.segments[i]\n\n        if segment ~ = ignoreSegment then\n            if math.abs(segment.x1 - x) < PlaceableFence.EPSILON and math.abs(segment.z1 - z) < PlaceableFence.EPSILON then\n                return segment, true , false\n            elseif math.abs(segment.x2 - x) < PlaceableFence.EPSILON and math.abs(segment.z2 - z) < PlaceableFence.EPSILON then\n                    return segment, false , true\n                end\n            end\n        end\n\n        return nil\n    end\n\n"})}),"\n",(0,s.jsx)(n.h3,{id:"loadfromxmlfile",children:"loadFromXMLFile"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Definition"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"loadFromXMLFile()"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"any"}),(0,s.jsx)(n.th,{children:"xmlFile"})]})}),(0,s.jsx)(n.tbody,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"any"}),(0,s.jsx)(n.td,{children:"key"})]})})]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Code"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:'function PlaceableFence:loadFromXMLFile(xmlFile, key)\n    local spec = self.spec_fence\n\n    xmlFile:iterate(key .. ".segments.segment" , function (index, segmentKey)\n        local x1, z1 = xmlFile:getValue(segmentKey .. "#start" )\n        local x2, z2 = xmlFile:getValue(segmentKey .. "#end" )\n\n        if x1 ~ = nil and z1 ~ = nil and x2 ~ = nil and z2 ~ = nil then\n            local segment = {\n            x1 = x1,\n            z1 = z1,\n            x2 = x2,\n            z2 = z2,\n            renderFirst = xmlFile:getValue(segmentKey .. "#first" , true ),\n            renderLast = xmlFile:getValue(segmentKey .. "#last" , true ),\n            gateIndex = xmlFile:getValue(segmentKey .. "#gateIndex" ),\n            poles = { } , -- generated\n            segmentKey = segmentKey\n            }\n\n            table.insert(spec.segments, segment)\n        else\n                Logging.xmlError(xmlFile, "Invalid segment position for \'%s\'.Ignoring segment!" , segmentKey)\n                end\n            end )\n\n            -- Rebuild the fence\n            for i = 1 , #spec.segments do\n                local segment = spec.segments[i]\n\n                self:generateSegmentPoles(segment, true )\n\n                if segment.gateIndex ~ = nil and segment.animatedObject ~ = nil then\n                    segment.animatedObject:loadFromXMLFile(xmlFile, segment.segmentKey .. ".animatedObject" )\n                end\n\n                segment.segmentKey = nil\n            end\n        end\n\n'})}),"\n",(0,s.jsx)(n.h3,{id:"ondelete",children:"onDelete"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Definition"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"onDelete()"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Code"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:"function PlaceableFence:onDelete()\n    local spec = self.spec_fence\n\n    if spec.segments ~ = nil then\n        for _, segment in pairs(spec.segments) do\n            if segment.pendingUpdateTimer ~ = nil then\n                segment.pendingUpdateTimer:delete()\n                segment.pendingUpdateTimer = nil\n            end\n        end\n    end\n\n    if self.cellIdToSegments ~ = nil then\n        local terrainDeformationSyncer = g_currentMission.terrainDeformationSyncer\n        if terrainDeformationSyncer ~ = nil then\n            for cellId in pairs( self.cellIdToSegments) do\n                local cellX, cellZ = terrainDeformationSyncer:getCellIndicesById(cellId)\n                terrainDeformationSyncer:removeCellUpdateListener( self , cellX, cellZ)\n            end\n        end\n        self.cellIdToSegments = nil\n    end\n\n    if spec.animatedObjects ~ = nil then\n        for _, animatedObject in ipairs(spec.animatedObjects) do\n            animatedObject:delete()\n        end\n    end\nend\n\n"})}),"\n",(0,s.jsx)(n.h3,{id:"onload",children:"onLoad"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"Called on loading"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Definition"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"onLoad(table savegame)"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n",(0,s.jsx)(n.table,{children:(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"table"}),(0,s.jsx)(n.th,{children:"savegame"}),(0,s.jsx)(n.th,{children:"savegame"})]})})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Code"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:'function PlaceableFence:onLoad(savegame)\n    local spec = self.spec_fence\n    local xmlFile = self.xmlFile\n\n    spec.pickObjects = { }\n    spec.segments = { }\n    spec.segmentsToUpdate = { }\n    spec.animatedObjects = { }\n    spec.previewSegment = nil\n    spec.panelLength = xmlFile:getValue( "placeable.fence.panels#length" )\n    spec.panelLengthFixed = xmlFile:getValue( "placeable.fence.panels#fixedLength" )\n    spec.maxVerticalAngle = xmlFile:getValue( "placeable.fence#maxVerticalAngle" , 35 )\n    spec.maxVerticalGateAngle = xmlFile:getValue( "placeable.fence#maxVerticalGateAngle" , 5 )\n    spec.hasInvisiblePoles = xmlFile:getValue( "placeable.fence#hasInvisiblePoles" , false )\n    spec.supportsParallelSnapping = xmlFile:getValue( "placeable.fence#supportsParallelSnapping" , false )\n\n    spec.boundingCheckWidth = xmlFile:getValue( "placeable.fence#boundingCheckWidth" , 0.25 )\n    spec.snapDistance = xmlFile:getValue( "placeable.fence#snapDistance" , nil )\n    spec.snapAngle = xmlFile:getValue( "placeable.fence#snapAngle" , nil )\n    spec.snapCheckDistance = xmlFile:getValue( "placeable.fence#snapCheckDistance" , 0.25 )\n    spec.allowExtendingOnly = xmlFile:getValue( "placeable.fence#extendingOnly" , false )\n    spec.maxCornerAngle = xmlFile:getValue( "placeable.fence#maxCornerAngle" , 180 )\n\n    spec.poles = { }\n    local polesNode = xmlFile:getValue( "placeable.fence.poles#node" , nil , self.components, self.i3dMappings)\n    if polesNode ~ = nil then\n        for i = 1 , getNumOfChildren(polesNode) do\n            spec.poles[i] = getChildAt(polesNode, i - 1 )\n        end\n    end\n\n    spec.panels = { }\n    local panelsNode = xmlFile:getValue( "placeable.fence.panels#node" , nil , self.components, self.i3dMappings)\n    if panelsNode ~ = nil then\n        for i = 1 , getNumOfChildren(panelsNode) do\n            spec.panels[i] = getChildAt(panelsNode, i - 1 )\n        end\n    end\n\n    spec.gates = { }\n    xmlFile:iterate( "placeable.fence.gate" , function (_, key)\n        local node = xmlFile:getValue(key .. "#node" , nil , self.components, self.i3dMappings)\n        if node ~ = nil then\n            local doors = { }\n            xmlFile:iterate(key .. ".door" , function (_, doorKey)\n                local doorNode = xmlFile:getValue(doorKey .. "#node" )\n                if doorNode ~ = nil then\n                    table.insert(doors, {\n                    node = doorNode,\n                    rotation = xmlFile:getValue(doorKey .. "#openRotation" , nil , true ),\n                    translation = xmlFile:getValue(doorKey .. "#openTranslation" , nil , true ),\n                    } )\n                else\n                        Logging.xmlWarning(xmlFile, "Door node does not exist at %s" , doorKey)\n                    end\n                end )\n\n                table.insert(spec.gates, {\n                node = node,\n                length = xmlFile:getValue(key .. "#length" , 1 ),\n                triggerNode = xmlFile:getValue(key .. "#triggerNode" ),\n                openText = xmlFile:getValue(key .. "#openText" , "action_openGate" ),\n                closeText = xmlFile:getValue(key .. "#closeText" , "action_closeGate" ),\n                animationDuration = xmlFile:getValue(key .. "#openDuration" , 3 ),\n                doors = doors,\n                } )\n            else\n                    Logging.xmlWarning(xmlFile, "Gate node does not exist at %s" , key)\n                end\n            end )\n        end\n\n'})}),"\n",(0,s.jsx)(n.h3,{id:"onreadstream",children:"onReadStream"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Definition"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"onReadStream()"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"any"}),(0,s.jsx)(n.th,{children:"streamId"})]})}),(0,s.jsx)(n.tbody,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"any"}),(0,s.jsx)(n.td,{children:"connection"})]})})]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Code"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:"function PlaceableFence:onReadStream(streamId, connection)\n    local spec = self.spec_fence\n\n    local numSegments = streamReadInt32(streamId)\n    for i = 1 , numSegments do\n        local segment = { }\n        segment.x1 = streamReadFloat32(streamId)\n        segment.z1 = streamReadFloat32(streamId)\n        segment.x2 = streamReadFloat32(streamId)\n        segment.z2 = streamReadFloat32(streamId)\n\n        segment.gateIndex = streamReadUInt8(streamId)\n        if segment.gateIndex = = 0 then\n            segment.gateIndex = nil\n        end\n\n        segment.renderFirst = streamReadBool(streamId)\n        segment.renderLast = streamReadBool(streamId)\n\n        segment.poles = { } -- generated\n\n        table.insert(spec.segments, segment)\n    end\n\n    -- Rebuild the fence\n    for i = 1 , numSegments do\n        local segment = spec.segments[i]\n\n        self:generateSegmentPoles(segment, true )\n\n        if segment.gateIndex ~ = nil and segment.animatedObject ~ = nil then\n            local animatedObject = segment.animatedObject\n\n            local animatedObjectId = NetworkUtil.readNodeObjectId(streamId)\n            animatedObject:readStream(streamId, connection)\n            g_client:finishRegisterObject(animatedObject, animatedObjectId)\n        end\n\n        self:registerTerrainHeightChangeCallbacks(segment)\n    end\nend\n\n"})}),"\n",(0,s.jsx)(n.h3,{id:"onupdate",children:"onUpdate"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Definition"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"onUpdate()"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,s.jsx)(n.table,{children:(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"any"}),(0,s.jsx)(n.th,{children:"dt"})]})})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Code"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:"function PlaceableFence:onUpdate(dt)\n    self:updateSegmentUpdateQueue()\nend\n\n"})}),"\n",(0,s.jsx)(n.h3,{id:"onwritestream",children:"onWriteStream"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Definition"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"onWriteStream()"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"any"}),(0,s.jsx)(n.th,{children:"streamId"})]})}),(0,s.jsx)(n.tbody,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"any"}),(0,s.jsx)(n.td,{children:"connection"})]})})]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Code"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:"function PlaceableFence:onWriteStream(streamId, connection)\n    local spec = self.spec_fence\n\n    local numSegments = #spec.segments\n    streamWriteInt32(streamId, numSegments)\n    for i = 1 , numSegments do\n        local segment = spec.segments[i]\n\n        streamWriteFloat32(streamId, segment.x1)\n        streamWriteFloat32(streamId, segment.z1)\n        streamWriteFloat32(streamId, segment.x2)\n        streamWriteFloat32(streamId, segment.z2)\n\n        streamWriteUInt8(streamId, segment.gateIndex or 0 )\n        streamWriteBool(streamId, segment.renderFirst)\n        streamWriteBool(streamId, segment.renderLast)\n    end\n\n    for i = 1 , numSegments do\n        local segment = spec.segments[i]\n\n        if segment.gateIndex ~ = nil and segment.animatedObject ~ = nil then\n            local animatedObject = segment.animatedObject\n\n            NetworkUtil.writeNodeObjectId(streamId, NetworkUtil.getObjectId(animatedObject))\n            animatedObject:writeStream(streamId, connection)\n            g_server:registerObjectInStream(connection, animatedObject)\n        end\n    end\nend\n\n"})}),"\n",(0,s.jsx)(n.h3,{id:"performnodedestruction",children:"performNodeDestruction"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Definition"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"performNodeDestruction()"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"any"}),(0,s.jsx)(n.th,{children:"superFunc"})]})}),(0,s.jsx)(n.tbody,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"any"}),(0,s.jsx)(n.td,{children:"node"})]})})]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Code"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:"function PlaceableFence:performNodeDestruction(superFunc, node)\n    local destroyedNode = self:deletePanel(node)\n    local destroyPlaceable = self:getNumSequments() = = 0\n    return destroyedNode, destroyPlaceable\nend\n\n"})}),"\n",(0,s.jsx)(n.h3,{id:"prerequisitespresent",children:"prerequisitesPresent"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"Checks if all prerequisite specializations are loaded"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Definition"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"prerequisitesPresent(table specializations)"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n",(0,s.jsx)(n.table,{children:(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"table"}),(0,s.jsx)(n.th,{children:"specializations"}),(0,s.jsx)(n.th,{children:"specializations"})]})})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Return Values"})}),"\n\n\n\n\n\n\n\n\n",(0,s.jsx)(n.table,{children:(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"table"}),(0,s.jsx)(n.th,{children:"hasPrerequisite"}),(0,s.jsx)(n.th,{children:"true if all prerequisite specializations are loaded"})]})})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Code"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:"function PlaceableFence.prerequisitesPresent(specializations)\n    return true\nend\n\n"})}),"\n",(0,s.jsx)(n.h3,{id:"previewnodedestructionnodes",children:"previewNodeDestructionNodes"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Definition"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"previewNodeDestructionNodes()"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"any"}),(0,s.jsx)(n.th,{children:"superFunc"})]})}),(0,s.jsx)(n.tbody,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"any"}),(0,s.jsx)(n.td,{children:"node"})]})})]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Code"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:"function PlaceableFence:previewNodeDestructionNodes(superFunc, node)\n    return self:getNodesToDeleteForPanel(node)\nend\n\n"})}),"\n",(0,s.jsx)(n.h3,{id:"recursivelyaddpickingnodes",children:"recursivelyAddPickingNodes"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Definition"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"recursivelyAddPickingNodes()"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"any"}),(0,s.jsx)(n.th,{children:"objects"})]})}),(0,s.jsx)(n.tbody,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"any"}),(0,s.jsx)(n.td,{children:"node"})]})})]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Code"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:"function PlaceableFence:recursivelyAddPickingNodes(objects, node)\n    if getRigidBodyType(node) ~ = RigidBodyType.NONE then\n        table.insert(objects, node)\n    end\n\n    local numChildren = getNumOfChildren(node)\n    for i = 1 , numChildren do\n        self:recursivelyAddPickingNodes(objects, getChildAt(node, i - 1 ))\n    end\nend\n\n"})}),"\n",(0,s.jsx)(n.h3,{id:"registereventlisteners",children:"registerEventListeners"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Definition"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"registerEventListeners()"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,s.jsx)(n.table,{children:(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"any"}),(0,s.jsx)(n.th,{children:"placeableType"})]})})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Code"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:'function PlaceableFence.registerEventListeners(placeableType)\n    SpecializationUtil.registerEventListener(placeableType, "onLoad" , PlaceableFence )\n    SpecializationUtil.registerEventListener(placeableType, "onDelete" , PlaceableFence )\n    SpecializationUtil.registerEventListener(placeableType, "onReadStream" , PlaceableFence )\n    SpecializationUtil.registerEventListener(placeableType, "onWriteStream" , PlaceableFence )\n    SpecializationUtil.registerEventListener(placeableType, "onUpdate" , PlaceableFence )\nend\n\n'})}),"\n",(0,s.jsx)(n.h3,{id:"registerevents",children:"registerEvents"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Definition"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"registerEvents()"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,s.jsx)(n.table,{children:(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"any"}),(0,s.jsx)(n.th,{children:"placeableType"})]})})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Code"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:'function PlaceableFence.registerEvents(placeableType)\n    SpecializationUtil.registerEvent(placeableType, "onCreateSegmentPanel" )\nend\n\n'})}),"\n",(0,s.jsx)(n.h3,{id:"registerfunctions",children:"registerFunctions"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Definition"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"registerFunctions()"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,s.jsx)(n.table,{children:(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"any"}),(0,s.jsx)(n.th,{children:"placeableType"})]})})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Code"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:'function PlaceableFence.registerFunctions(placeableType)\n    SpecializationUtil.registerFunction(placeableType, "addSegment" , PlaceableFence.addSegment)\n    SpecializationUtil.registerFunction(placeableType, "addSegmentShapesToUpdate" , PlaceableFence.addSegmentShapesToUpdate)\n    SpecializationUtil.registerFunction(placeableType, "createSegment" , PlaceableFence.createSegment)\n    SpecializationUtil.registerFunction(placeableType, "deletePanel" , PlaceableFence.deletePanel)\n    SpecializationUtil.registerFunction(placeableType, "deleteSegment" , PlaceableFence.deleteSegment)\n    SpecializationUtil.registerFunction(placeableType, "doDeletePanel" , PlaceableFence.doDeletePanel)\n    SpecializationUtil.registerFunction(placeableType, "fakeRandomValueForPosition" , PlaceableFence.fakeRandomValueForPosition)\n    SpecializationUtil.registerFunction(placeableType, "findRaycastInfo" , PlaceableFence.findRaycastInfo)\n    SpecializationUtil.registerFunction(placeableType, "generateSegmentPoles" , PlaceableFence.generateSegmentPoles)\n    SpecializationUtil.registerFunction(placeableType, "getGate" , PlaceableFence.getGate)\n    SpecializationUtil.registerFunction(placeableType, "getMaxVerticalAngle" , PlaceableFence.getMaxVerticalAngle)\n    SpecializationUtil.registerFunction(placeableType, "getMaxVerticalAngleAndYForPreview" , PlaceableFence.getMaxVerticalAngleAndYForPreview)\n    SpecializationUtil.registerFunction(placeableType, "getMaxVerticalGateAngle" , PlaceableFence.getMaxVerticalGateAngle)\n    SpecializationUtil.registerFunction(placeableType, "getNodesToDeleteForPanel" , PlaceableFence.getNodesToDeleteForPanel)\n    SpecializationUtil.registerFunction(placeableType, "getNumSequments" , PlaceableFence.getNumSequments)\n    SpecializationUtil.registerFunction(placeableType, "getPanelLength" , PlaceableFence.getPanelLength)\n    SpecializationUtil.registerFunction(placeableType, "getIsPanelLengthFixed" , PlaceableFence.getIsPanelLengthFixed)\n    SpecializationUtil.registerFunction(placeableType, "getPoleNear" , PlaceableFence.getPoleNear)\n    SpecializationUtil.registerFunction(placeableType, "getPoleNearOverlapCallback" , PlaceableFence.getPoleNearOverlapCallback)\n    SpecializationUtil.registerFunction(placeableType, "getPolePosition" , PlaceableFence.getPolePosition)\n    SpecializationUtil.registerFunction(placeableType, "getPoleShapeForPreview" , PlaceableFence.getPoleShapeForPreview)\n    SpecializationUtil.registerFunction(placeableType, "getPreviewSegment" , PlaceableFence.getPreviewSegment)\n    SpecializationUtil.registerFunction(placeableType, "getSegment" , PlaceableFence.getSegment)\n    SpecializationUtil.registerFunction(placeableType, "getSegmentLength" , PlaceableFence.getSegmentLength)\n    SpecializationUtil.registerFunction(placeableType, "isPoleInAnySegment" , PlaceableFence.isPoleInAnySegment)\n    SpecializationUtil.registerFunction(placeableType, "recursivelyAddPickingNodes" , PlaceableFence.recursivelyAddPickingNodes)\n    SpecializationUtil.registerFunction(placeableType, "addPickingNodesForSegment" , PlaceableFence.addPickingNodesForSegment)\n    SpecializationUtil.registerFunction(placeableType, "removePickingNodesForSegment" , PlaceableFence.removePickingNodesForSegment)\n    SpecializationUtil.registerFunction(placeableType, "setPreviewSegment" , PlaceableFence.setPreviewSegment)\n    SpecializationUtil.registerFunction(placeableType, "updatePanelVisuals" , PlaceableFence.updatePanelVisuals)\n    SpecializationUtil.registerFunction(placeableType, "updateSegmentShapes" , PlaceableFence.updateSegmentShapes)\n    SpecializationUtil.registerFunction(placeableType, "updateSegmentUpdateQueue" , PlaceableFence.updateSegmentUpdateQueue)\n    SpecializationUtil.registerFunction(placeableType, "updateDirtyAreas" , PlaceableFence.updateDirtyAreas)\n    SpecializationUtil.registerFunction(placeableType, "getSupportsParallelSnapping" , PlaceableFence.getSupportsParallelSnapping)\n\n    SpecializationUtil.registerFunction(placeableType, "getBoundingCheckWidth" , PlaceableFence.getBoundingCheckWidth)\n    SpecializationUtil.registerFunction(placeableType, "getSnapDistance" , PlaceableFence.getSnapDistance)\n    SpecializationUtil.registerFunction(placeableType, "getSnapAngle" , PlaceableFence.getSnapAngle)\n    SpecializationUtil.registerFunction(placeableType, "getSnapCheckDistance" , PlaceableFence.getSnapCheckDistance)\n    SpecializationUtil.registerFunction(placeableType, "getAllowExtendingOnly" , PlaceableFence.getAllowExtendingOnly)\n    SpecializationUtil.registerFunction(placeableType, "getMaxCornerAngle" , PlaceableFence.getMaxCornerAngle)\n    SpecializationUtil.registerFunction(placeableType, "getHasParallelSnapping" , PlaceableFence.getHasParallelSnapping)\n\n    SpecializationUtil.registerFunction(placeableType, "registerTerrainHeightChangeCallbacks" , PlaceableFence.registerTerrainHeightChangeCallbacks)\n    SpecializationUtil.registerFunction(placeableType, "onTerrainDeformationSyncerUpdate" , PlaceableFence.onTerrainDeformationSyncerUpdate)\nend\n\n'})}),"\n",(0,s.jsx)(n.h3,{id:"registeroverwrittenfunctions",children:"registerOverwrittenFunctions"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Definition"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"registerOverwrittenFunctions()"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,s.jsx)(n.table,{children:(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"any"}),(0,s.jsx)(n.th,{children:"placeableType"})]})})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Code"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:'function PlaceableFence.registerOverwrittenFunctions(placeableType)\n    SpecializationUtil.registerOverwrittenFunction(placeableType, "collectPickObjects" , PlaceableFence.collectPickObjects)\n    SpecializationUtil.registerOverwrittenFunction(placeableType, "getDestructionMethod" , PlaceableFence.getDestructionMethod)\n    SpecializationUtil.registerOverwrittenFunction(placeableType, "performNodeDestruction" , PlaceableFence.performNodeDestruction)\n    SpecializationUtil.registerOverwrittenFunction(placeableType, "previewNodeDestructionNodes" , PlaceableFence.previewNodeDestructionNodes)\n    SpecializationUtil.registerOverwrittenFunction(placeableType, "setOwnerFarmId" , PlaceableFence.setOwnerFarmId)\nend\n\n'})}),"\n",(0,s.jsx)(n.h3,{id:"registersavegamexmlpaths",children:"registerSavegameXMLPaths"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Definition"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"registerSavegameXMLPaths()"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"any"}),(0,s.jsx)(n.th,{children:"schema"})]})}),(0,s.jsx)(n.tbody,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"any"}),(0,s.jsx)(n.td,{children:"basePath"})]})})]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Code"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:'function PlaceableFence.registerSavegameXMLPaths(schema, basePath)\n    schema:setXMLSpecializationType( "Fence" )\n    schema:register(XMLValueType.VECTOR_ 2 , basePath .. ".segments.segment(?)#start" , "Segment start position" )\n    schema:register(XMLValueType.VECTOR_ 2 , basePath .. ".segments.segment(?)#end" , "Segment end position" )\n    schema:register(XMLValueType.BOOL, basePath .. ".segments.segment(?)#first" , "Segment has first pole visible" , true )\n    schema:register(XMLValueType.BOOL, basePath .. ".segments.segment(?)#last" , "Segment has last pole visible" , true )\n    schema:register(XMLValueType.INT, basePath .. ".segments.segment(?)#gateIndex" , "Gate index" )\n    AnimatedObject.registerSavegameXMLPaths(schema, basePath .. ".segments.segment(?).animatedObject" )\n    schema:setXMLSpecializationType()\nend\n\n'})}),"\n",(0,s.jsx)(n.h3,{id:"registerxmlpaths",children:"registerXMLPaths"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Definition"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"registerXMLPaths()"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"any"}),(0,s.jsx)(n.th,{children:"schema"})]})}),(0,s.jsx)(n.tbody,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"any"}),(0,s.jsx)(n.td,{children:"basePath"})]})})]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Code"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:'function PlaceableFence.registerXMLPaths(schema, basePath)\n    schema:setXMLSpecializationType( "Fence" )\n    schema:register(XMLValueType.NODE_INDEX, basePath .. ".fence.poles#node" , "Group of pole variants" )\n    schema:register(XMLValueType.NODE_INDEX, basePath .. ".fence.panels#node" , "Group of panel variants" )\n    schema:register(XMLValueType.FLOAT, basePath .. ".fence.panels#length" , "Length of the panels" , 1 )\n    schema:register(XMLValueType.BOOL, basePath .. ".fence.panels#fixedLength" , "Panel length is fixed" , false )\n    schema:register(XMLValueType.ANGLE, basePath .. ".fence#maxVerticalAngle" , "Maximum angle for vertical offset" )\n        schema:register(XMLValueType.ANGLE, basePath .. ".fence#maxVerticalGateAngle" , "Maximum angle for vertical offset with gates" )\n            schema:register(XMLValueType.FLOAT, basePath .. ".fence#boundingCheckWidth" , "Width of the bounding box used to check collision" , 0.25 )\n            schema:register(XMLValueType.FLOAT, basePath .. ".fence#snapDistance" , "Snap distance" , nil )\n            schema:register(XMLValueType.INT, basePath .. ".fence#snapAngle" , "Snap angle in degrees" , nil )\n            schema:register(XMLValueType.FLOAT, basePath .. ".fence#snapCheckDistance" , "Snap distance" , nil )\n            schema:register(XMLValueType.BOOL, basePath .. ".fence#extendingOnly" , "Whether to only allow extending a segment and no attaching to the center" , false )\n            schema:register(XMLValueType.ANGLE, basePath .. ".fence#maxCornerAngle" , "Maximum angle between two connected segments" , 180 )\n            schema:register(XMLValueType.BOOL, basePath .. ".fence#supportsParallelSnapping" , "Whether parallel snapping is an option" , false )\n            schema:register(XMLValueType.BOOL, basePath .. ".fence#hasInvisiblePoles" , "Poles are not visible so another display method is used" , false )\n            schema:register(XMLValueType.NODE_INDEX, basePath .. ".fence.gate(?)#node" , "Gate node" )\n            schema:register(XMLValueType.FLOAT, basePath .. ".fence.gate(?)#length" , "Length of the gate from pole to pole" , 1 )\n            schema:register(XMLValueType.INT, basePath .. ".fence.gate(?)#triggerNode" , "Gate trigger node index from gate node" )\n            schema:register(XMLValueType.STRING, basePath .. ".fence.gate(?)#openText" , "Action open text" )\n            schema:register(XMLValueType.STRING, basePath .. ".fence.gate(?)#closeText" , "Action close text" )\n            schema:register(XMLValueType.FLOAT, basePath .. ".fence.gate(?)#openDuration" , "Duration of animation in seconds" )\n            schema:register(XMLValueType.INT, basePath .. ".fence.gate(?).door(?)#node" , "Node of the door" )\n            schema:register(XMLValueType.VECTOR_ROT, basePath .. ".fence.gate(?).door(?)#openRotation" , "Rotation of the node when fully open" )\n            schema:register(XMLValueType.VECTOR_TRANS, basePath .. ".fence.gate(?).door(?)#openTranslation" , "Translation of the node when fully open" )\n            AnimatedObjectBuilder.registerXMLPaths(schema, basePath .. ".fence.gate(?)" )\n            schema:setXMLSpecializationType()\n        end\n\n'})}),"\n",(0,s.jsx)(n.h3,{id:"removepickingnodesforsegment",children:"removePickingNodesForSegment"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Definition"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"removePickingNodesForSegment()"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,s.jsx)(n.table,{children:(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"any"}),(0,s.jsx)(n.th,{children:"segment"})]})})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Code"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:"function PlaceableFence:removePickingNodesForSegment(segment)\n    if segment = = self.spec_fence.previewSegment then\n        return\n    end\n\n    if segment.group ~ = nil then\n        local objects = { }\n        self:recursivelyAddPickingNodes(objects, segment.group)\n\n        for i = 1 , #objects do\n            g_currentMission:removeNodeObject(objects[i])\n        end\n    end\nend\n\n"})}),"\n",(0,s.jsx)(n.h3,{id:"savetoxmlfile",children:"saveToXMLFile"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Definition"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"saveToXMLFile()"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"any"}),(0,s.jsx)(n.th,{children:"xmlFile"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"any"}),(0,s.jsx)(n.td,{children:"key"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"any"}),(0,s.jsx)(n.td,{children:"usedModNames"})]})]})]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Code"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:'function PlaceableFence:saveToXMLFile(xmlFile, key, usedModNames)\n    local spec = self.spec_fence\n\n    xmlFile:setTable(key .. ".segments.segment" , spec.segments, function (path, segment, _)\n        xmlFile:setValue(path .. "#start" , segment.x1, segment.z1)\n        xmlFile:setValue(path .. "#end" , segment.x2, segment.z2)\n\n        if segment.gateIndex ~ = nil then\n            xmlFile:setValue(path .. "#gateIndex" , segment.gateIndex)\n            if segment.animatedObject ~ = nil then\n                segment.animatedObject:saveToXMLFile(xmlFile, path .. ".animatedObject" , usedModNames)\n            end\n        end\n\n        -- No need to save default value\n        if not segment.renderFirst then\n            xmlFile:setValue(path .. "#first" , false )\n        end\n        if not segment.renderLast then\n            xmlFile:setValue(path .. "#last" , false )\n        end\n    end )\nend\n\n'})}),"\n",(0,s.jsx)(n.h3,{id:"setownerfarmid",children:"setOwnerFarmId"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Definition"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"setOwnerFarmId()"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"any"}),(0,s.jsx)(n.th,{children:"superFunc"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"any"}),(0,s.jsx)(n.td,{children:"ownerFarmId"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"any"}),(0,s.jsx)(n.td,{children:"noEventSend"})]})]})]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Code"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:"function PlaceableFence:setOwnerFarmId(superFunc, ownerFarmId, noEventSend)\n    local spec = self.spec_fence\n\n    superFunc( self , ownerFarmId, noEventSend)\n\n    if spec.animatedObjects ~ = nil then\n        for _, animatedObject in ipairs(spec.animatedObjects) do\n            animatedObject:setOwnerFarmId(ownerFarmId, true )\n        end\n    end\nend\n\n"})}),"\n",(0,s.jsx)(n.h3,{id:"setpreviewsegment",children:"setPreviewSegment"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Definition"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"setPreviewSegment()"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,s.jsx)(n.table,{children:(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"any"}),(0,s.jsx)(n.th,{children:"segment"})]})})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Code"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:"function PlaceableFence:setPreviewSegment(segment)\n    local spec = self.spec_fence\n\n    -- Delete old preview nodes\n    if spec.previewSegment ~ = nil and spec.previewSegment.group ~ = nil and segment ~ = spec.previewSegment then\n        delete(spec.previewSegment.group)\n        spec.previewSegment.group = nil\n    end\n\n    spec.previewSegment = segment\n\n    if segment ~ = nil then\n        self:generateSegmentPoles(segment, false )\n    end\nend\n\n"})}),"\n",(0,s.jsx)(n.h3,{id:"updatedirtyareas",children:"updateDirtyAreas"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"Sets collision map and AI navigationmap dirty for AABB of given line"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Definition"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"updateDirtyAreas()"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"any"}),(0,s.jsx)(n.th,{children:"x1"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"any"}),(0,s.jsx)(n.td,{children:"z1"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"any"}),(0,s.jsx)(n.td,{children:"x2"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"any"}),(0,s.jsx)(n.td,{children:"z2"})]})]})]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Code"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:"function PlaceableFence:updateDirtyAreas(x1, z1, x2, z2)\n    local minX = math.min(x1, x2)\n    local maxX = math.max(x1, x2)\n    local minZ = math.min(z1, z2)\n    local maxZ = math.max(z1, z2)\n\n    g_densityMapHeightManager:setCollisionMapAreaDirty(minX, minZ, maxX, maxZ, true )\n    g_currentMission.aiSystem:setAreaDirty(minX, maxX, minZ, maxZ)\nend\n\n"})}),"\n",(0,s.jsx)(n.h3,{id:"updatesegmentshapes",children:"updateSegmentShapes"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Definition"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"updateSegmentShapes()"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,s.jsx)(n.table,{children:(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"any"}),(0,s.jsx)(n.th,{children:"segment"})]})})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Code"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:'function PlaceableFence:updateSegmentShapes(segment)\n    local spec = self.spec_fence\n    local isPreviewSegment = segment = = spec.previewSegment\n    local enablePhysics = not isPreviewSegment\n\n    -- Delete AO before deleting nodes so trigger is handled correctly and no double-delete occurs\n    local gateTime\n    if segment.animatedObject ~ = nil then\n        gateTime = segment.animatedObject.animation.time\n        segment.animatedObject:delete()\n        segment.animatedObject = nil\n    end\n\n    -- Create a group for all segment nodes so we can delete them at once when re-generating\n        if segment.group ~ = nil then\n            delete(segment.group)\n        end\n        segment.group = createTransformGroup( "fence_segment" )\n        link( self.rootNode, segment.group)\n\n        -- Create a pole for every xz pair.\n            for i = 1 , #segment.poles, 2 do\n                local x, z = segment.poles[i], segment.poles[i + 1 ]\n                local y = getTerrainHeightAtWorldPos(g_terrainNode, x, 0 , z)\n\n                -- If there is a first pole, use the shape.Otherwise use an empty TG so we can still rotate\n                local pole\n                local poleIsFake = false\n                if #spec.poles > 0 and(i > 1 or segment.renderFirst) and(i < #segment.poles - 2 or segment.renderLast) then\n                    local poleIndex = self:fakeRandomValueForPosition(x, y, z, #spec.poles)\n                    pole = clone(spec.poles[poleIndex], false , false , false )\n                else\n                        pole = createTransformGroup( "fence_firstPole" )\n                        poleIsFake = true\n                    end\n                    link(segment.group, pole)\n\n                    -- Set position\n                    setWorldTranslation(pole, x, y, z)\n\n                    if segment.gateIndex ~ = nil then\n                        -- Poles for gates:always rotate to the other side\n                            local prevX, prevZ = segment.poles[(i + 2 ) % 4 ], segment.poles[(i + 2 ) % 4 + 1 ]\n                            local dx, dz = x - prevX, z - prevZ\n                            local rotY = math.atan2(dx, dz) + math.pi\n\n                            setWorldRotation(pole, 0 , rotY, 0 )\n\n                            if enablePhysics and not poleIsFake then\n                                addToPhysics(getChildAt(pole, 0 ))\n                            end\n                        elseif i < #segment.poles - 2 then\n                                -- Next pole exists:connect it with a panel and rotate this one properly, but not if these are gate poles\n                                    -- Find position of the next pole so we can match it visually\n                                    local nextX, nextZ = segment.poles[i + 2 ], segment.poles[i + 3 ]\n                                    local nextY = getTerrainHeightAtWorldPos(g_terrainNode, nextX, 0 , nextZ)\n\n                                    local dx, dy, dz = x - nextX, y - nextY, z - nextZ\n                                    local rotY = math.atan2(dx, dz) + math.pi\n\n                                    -- Pole rotates into direction of fence\n                                    setWorldRotation(pole, 0 , rotY, 0 )\n\n                                    -- Find a panel and connect\n                                    local panelIndex = self:fakeRandomValueForPosition(x, y, z, #spec.panels)\n                                    local panel = clone(spec.panels[panelIndex], false , false , false )\n                                    link(pole, panel)\n\n                                    -- Scale fence to fit next pole.This is length on XZ plane only, as shader will transform along Y\n                                    local fenceLength = MathUtil.getPointPointDistance(x, z, nextX, nextZ)\n\n                                    -- Adjust panel distortion to match height of next fence\n                                    self:updatePanelVisuals(panel, dy, segment, i, fenceLength)\n\n                                    -- Adjust collision by rotating it to match terrain inclination\n                                    local col = getChildAt(panel, 0 )\n\n                                    local xDir, yDir, zDir = 0 , - dy, fenceLength\n                                    xDir, yDir, zDir = MathUtil.vector3Normalize(xDir, yDir, zDir)\n                                    local length = math.sqrt(dx * dx + dy * dy + dz * dz)\n\n                                    local offset = (length - fenceLength) * 0.5\n                                    local colX, colY, colZ = getTranslation(col)\n                                    colX = colX + xDir * offset\n                                    colY = colY + yDir * offset\n                                    colZ = colZ + zDir * offset\n\n                                    setDirection(col, xDir, yDir, zDir, 0 , 1 , 0 )\n                                    setTranslation(col, colX, colY, colZ)\n\n                                    if enablePhysics then\n                                        addToPhysics(col)\n                                    end\n\n                                    SpecializationUtil.raiseEvent( self , "onCreateSegmentPanel" , isPreviewSegment, segment, panel, i, dy)\n\n                                    if enablePhysics and not poleIsFake then\n                                        addToPhysics(getChildAt(pole, 0 ))\n                                    end\n                                elseif segment.renderLast then\n                                        -- End of the segment.We could look up the next segment but that is expensive\n                                        -- Instead, just align to the previous pole.If no previous pole, it is a single\n                                        -- pole and any rotation is fine so we can leave it.\n                                        if i > 2 then\n                                            local prevX, prevZ = segment.poles[i - 2 ], segment.poles[i - 1 ]\n                                            local dx, dz = x - prevX, z - prevZ\n                                            local rotY = math.atan2(dx, dz) + math.pi\n\n                                            setWorldRotation(pole, 0 , rotY, 0 )\n\n                                            if enablePhysics and not poleIsFake then\n                                                addToPhysics(getChildAt(pole, 0 ))\n                                            end\n                                        end\n                                    end\n                                end\n\n                                if segment.gateIndex ~ = nil then\n                                    local gateInfo = spec.gates[segment.gateIndex]\n\n                                    local gate = clone(gateInfo.node, false , false , false )\n                                    link(segment.group, gate)\n\n                                    local segmentTerrainY = getTerrainHeightAtWorldPos(g_terrainNode, segment.x1, 0 , segment.z1)\n                                    setWorldTranslation(gate, segment.x1, segmentTerrainY, segment.z1)\n\n                                    local dx, dz = segment.x1 - segment.x2, segment.z1 - segment.z2\n                                    local rotY = math.atan2(dx, dz) + math.pi\n                                    setWorldRotation(gate, 0 , rotY, 0 )\n\n                                    -- Only build animation on final placement\n                                    if not isPreviewSegment then\n                                        local animatedObject = AnimatedObject.new( self.isServer, self.isClient)\n                                        animatedObject:setOwnerFarmId( self:getOwnerFarmId(), false )\n\n                                        -- Note:two gates can start from the same pole, and then their end node can be at the same x or z.So need all 4\n                                        local saveId = string.format( "AnimatedObject_%s_gate_%d_%d_%d_%d" , self.configFileName, segment.x1, segment.z1, segment.x2, segment.x2)\n                                        local builder = animatedObject:builder( self.configFileName, saveId)\n\n                                        for _, door in ipairs(gateInfo.doors) do\n                                            local doorNode = getChildAt(gate, door.node)\n                                            builder:addSimplePart(doorNode, door.rotation, door.translation)\n                                            addToPhysics(doorNode)\n                                        end\n\n                                        local triggerNode = getChildAt(gate, gateInfo.triggerNode)\n                                        builder:setTrigger(triggerNode)\n                                        addToPhysics(triggerNode)\n\n                                        builder:setActions( "ACTIVATE_HANDTOOL" , gateInfo.openText, nil , gateInfo.closeText)\n                                        builder:setDuration(gateInfo.animationDuration * 1000 )\n\n                                        if self.xmlFile = = nil then\n                                            self.xmlFile = XMLFile.load( "placeableFence" , self.configFileName)\n                                        end\n                                        builder:setSounds( self.xmlFile.handle, string.format( "placeable.fence.gate(%d).sounds" , segment.gateIndex - 1 ), gate)\n\n                                        if not builder:build() then\n                                            animatedObject:delete()\n                                        else\n                                                animatedObject:register( true )\n\n                                                table.insert(spec.animatedObjects, animatedObject)\n                                                segment.animatedObject = animatedObject\n\n                                                if gateTime ~ = nil then\n                                                    animatedObject:setAnimTime(gateTime, true )\n                                                end\n\n                                                if self.isServer then\n                                                    -- Send one event to all clients with new AO so it is synced\n                                                    for i = 1 , #spec.segments do\n                                                        if spec.segments[i] = = segment then\n                                                            g_server:broadcastEvent( PlaceableFenceAddGateEvent.new( self , i, animatedObject), false , nil , self )\n                                                            break\n                                                        end\n                                                    end\n                                                end\n                                            end\n                                        else\n                                                -- In preview we show the gate at a slightly open angle to indicate open/close direction\n                                                for _, door in ipairs(gateInfo.doors) do\n                                                    local doorNode = getChildAt(gate, door.node)\n\n                                                    local alpha = 0.3\n\n                                                    if door.translation ~ = nil then\n                                                        local x1, y1, z1 = getTranslation(doorNode)\n                                                        local x2, y2, z2 = unpack(door.translation)\n\n                                                        setTranslation(doorNode, x1 + (x2 - x1) * alpha, y1 + (y2 - y1) * alpha, z1 + (z2 - z1) * alpha)\n                                                    end\n                                                    if door.rotation ~ = nil then\n                                                        local x1, y1, z1 = getRotation(doorNode)\n                                                        local x2, y2, z2 = unpack(door.rotation)\n\n                                                        setRotation(doorNode, x1 + (x2 - x1) * alpha, y1 + (y2 - y1) * alpha, z1 + (z2 - z1) * alpha)\n                                                    end\n                                                end\n                                            end\n                                        end\n\n                                        -- if enablePhysics then\n                                            -- addToPhysics(segment.group)\n                                            -- end\n                                        end\n\n'})}),"\n",(0,s.jsx)(n.h3,{id:"updatesegmentupdatequeue",children:"updateSegmentUpdateQueue"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Definition"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"updateSegmentUpdateQueue()"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Code"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:"function PlaceableFence:updateSegmentUpdateQueue()\n    local spec = self.spec_fence\n    if #spec.segmentsToUpdate > 0 then\n        local segment = spec.segmentsToUpdate[ 1 ]\n        table.remove(spec.segmentsToUpdate, 1 )\n\n        self:removePickingNodesForSegment(segment)\n        self:updateSegmentShapes(segment)\n        self:addPickingNodesForSegment(segment)\n\n        self:raiseActive()\n    end\nend\n\n"})})]})}function h(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(o,{...e})}):o(e)}}}]);