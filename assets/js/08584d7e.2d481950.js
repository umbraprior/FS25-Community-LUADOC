"use strict";(globalThis.webpackChunkfs25_community_luadoc=globalThis.webpackChunkfs25_community_luadoc||[]).push([[18160],{28453(e,n,t){t.d(n,{R:()=>o,x:()=>i});var s=t(96540);const l={},a=s.createContext(l);function o(e){const n=s.useContext(a);return s.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function i(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(l):e.components||l:o(e.components),s.createElement(a.Provider,{value:n},e.children)}},41850(e,n,t){t.r(n),t.d(n,{assets:()=>r,contentTitle:()=>i,default:()=>h,frontMatter:()=>o,metadata:()=>s,toc:()=>d});const s=JSON.parse('{"id":"script/Vehicles/VehicleCamera","title":"VehicleCamera","description":"VehicleCamera","source":"@site/../docs/script/Vehicles/VehicleCamera.md","sourceDirName":"script/Vehicles","slug":"/script/Vehicles/VehicleCamera","permalink":"/FS25-Community-LUADOC/script/Vehicles/VehicleCamera","draft":false,"unlisted":false,"tags":[],"version":"current","lastUpdatedAt":1767161192000,"frontMatter":{},"sidebar":"docsSidebar","previous":{"title":"VehicleActionControllerAction","permalink":"/FS25-Community-LUADOC/script/Vehicles/VehicleActionControllerAction"},"next":{"title":"VehicleCharacter","permalink":"/FS25-Community-LUADOC/script/Vehicles/VehicleCharacter"}}');var l=t(74848),a=t(28453);const o={},i=void 0,r={},d=[{value:"VehicleCamera",id:"vehiclecamera",level:2},{value:"actionEventLookLeftRight",id:"actioneventlookleftright",level:3},{value:"actionEventLookUpDown",id:"actioneventlookupdown",level:3},{value:"consoleCommandCameraYDebug",id:"consolecommandcameraydebug",level:3},{value:"consoleCommandLODDebug",id:"consolecommandloddebug",level:3},{value:"delete",id:"delete",level:3},{value:"getCollisionDistance",id:"getcollisiondistance",level:3},{value:"getTiltDirectionOffset",id:"gettiltdirectionoffset",level:3},{value:"loadFromXML",id:"loadfromxml",level:3},{value:"new",id:"new",level:3},{value:"onActivate",id:"onactivate",level:3},{value:"onActiveCameraSuspensionSettingChanged",id:"onactivecamerasuspensionsettingchanged",level:3},{value:"onCameraCollisionDetectionSettingChanged",id:"oncameracollisiondetectionsettingchanged",level:3},{value:"onDeactivate",id:"ondeactivate",level:3},{value:"onFovySettingChanged",id:"onfovysettingchanged",level:3},{value:"onPostLoad",id:"onpostload",level:3},{value:"raycastCallback",id:"raycastcallback",level:3},{value:"registerCameraSavegameXMLPaths",id:"registercamerasavegamexmlpaths",level:3},{value:"registerCameraXMLPaths",id:"registercameraxmlpaths",level:3},{value:"resetCamera",id:"resetcamera",level:3},{value:"saveToXMLFile",id:"savetoxmlfile",level:3},{value:"setCameraYDebugState",id:"setcameraydebugstate",level:3},{value:"setLODDebugState",id:"setloddebugstate",level:3},{value:"setSeparateCameraPose",id:"setseparatecamerapose",level:3},{value:"touchEventLookLeftRight",id:"toucheventlookleftright",level:3},{value:"touchEventLookUpDown",id:"toucheventlookupdown",level:3},{value:"touchEventZoomInOut",id:"toucheventzoominout",level:3},{value:"update",id:"update",level:3},{value:"updateRotateNodeRotation",id:"updaterotatenoderotation",level:3},{value:"zoomSmoothly",id:"zoomsmoothly",level:3}];function c(e){const n={a:"a",blockquote:"blockquote",code:"code",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,a.R)(),...e.components};return(0,l.jsxs)(l.Fragment,{children:[(0,l.jsx)(n.h2,{id:"vehiclecamera",children:"VehicleCamera"}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Description"})}),"\n",(0,l.jsxs)(n.blockquote,{children:["\n",(0,l.jsx)(n.p,{children:"Camera for vehicles"}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Functions"})}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsx)(n.li,{children:(0,l.jsx)(n.a,{href:"#actioneventlookleftright",children:"actionEventLookLeftRight"})}),"\n",(0,l.jsx)(n.li,{children:(0,l.jsx)(n.a,{href:"#actioneventlookupdown",children:"actionEventLookUpDown"})}),"\n",(0,l.jsx)(n.li,{children:(0,l.jsx)(n.a,{href:"#consolecommandcameraydebug",children:"consoleCommandCameraYDebug"})}),"\n",(0,l.jsx)(n.li,{children:(0,l.jsx)(n.a,{href:"#consolecommandloddebug",children:"consoleCommandLODDebug"})}),"\n",(0,l.jsx)(n.li,{children:(0,l.jsx)(n.a,{href:"#delete",children:"delete"})}),"\n",(0,l.jsx)(n.li,{children:(0,l.jsx)(n.a,{href:"#getcollisiondistance",children:"getCollisionDistance"})}),"\n",(0,l.jsx)(n.li,{children:(0,l.jsx)(n.a,{href:"#gettiltdirectionoffset",children:"getTiltDirectionOffset"})}),"\n",(0,l.jsx)(n.li,{children:(0,l.jsx)(n.a,{href:"#loadfromxml",children:"loadFromXML"})}),"\n",(0,l.jsx)(n.li,{children:(0,l.jsx)(n.a,{href:"#new",children:"new"})}),"\n",(0,l.jsx)(n.li,{children:(0,l.jsx)(n.a,{href:"#onactivate",children:"onActivate"})}),"\n",(0,l.jsx)(n.li,{children:(0,l.jsx)(n.a,{href:"#onactivecamerasuspensionsettingchanged",children:"onActiveCameraSuspensionSettingChanged"})}),"\n",(0,l.jsx)(n.li,{children:(0,l.jsx)(n.a,{href:"#oncameracollisiondetectionsettingchanged",children:"onCameraCollisionDetectionSettingChanged"})}),"\n",(0,l.jsx)(n.li,{children:(0,l.jsx)(n.a,{href:"#ondeactivate",children:"onDeactivate"})}),"\n",(0,l.jsx)(n.li,{children:(0,l.jsx)(n.a,{href:"#onfovysettingchanged",children:"onFovySettingChanged"})}),"\n",(0,l.jsx)(n.li,{children:(0,l.jsx)(n.a,{href:"#onpostload",children:"onPostLoad"})}),"\n",(0,l.jsx)(n.li,{children:(0,l.jsx)(n.a,{href:"#raycastcallback",children:"raycastCallback"})}),"\n",(0,l.jsx)(n.li,{children:(0,l.jsx)(n.a,{href:"#registercamerasavegamexmlpaths",children:"registerCameraSavegameXMLPaths"})}),"\n",(0,l.jsx)(n.li,{children:(0,l.jsx)(n.a,{href:"#registercameraxmlpaths",children:"registerCameraXMLPaths"})}),"\n",(0,l.jsx)(n.li,{children:(0,l.jsx)(n.a,{href:"#resetcamera",children:"resetCamera"})}),"\n",(0,l.jsx)(n.li,{children:(0,l.jsx)(n.a,{href:"#savetoxmlfile",children:"saveToXMLFile"})}),"\n",(0,l.jsx)(n.li,{children:(0,l.jsx)(n.a,{href:"#setcameraydebugstate",children:"setCameraYDebugState"})}),"\n",(0,l.jsx)(n.li,{children:(0,l.jsx)(n.a,{href:"#setloddebugstate",children:"setLODDebugState"})}),"\n",(0,l.jsx)(n.li,{children:(0,l.jsx)(n.a,{href:"#setseparatecamerapose",children:"setSeparateCameraPose"})}),"\n",(0,l.jsx)(n.li,{children:(0,l.jsx)(n.a,{href:"#toucheventlookleftright",children:"touchEventLookLeftRight"})}),"\n",(0,l.jsx)(n.li,{children:(0,l.jsx)(n.a,{href:"#toucheventlookupdown",children:"touchEventLookUpDown"})}),"\n",(0,l.jsx)(n.li,{children:(0,l.jsx)(n.a,{href:"#toucheventzoominout",children:"touchEventZoomInOut"})}),"\n",(0,l.jsx)(n.li,{children:(0,l.jsx)(n.a,{href:"#update",children:"update"})}),"\n",(0,l.jsx)(n.li,{children:(0,l.jsx)(n.a,{href:"#updaterotatenoderotation",children:"updateRotateNodeRotation"})}),"\n",(0,l.jsx)(n.li,{children:(0,l.jsx)(n.a,{href:"#zoomsmoothly",children:"zoomSmoothly"})}),"\n"]}),"\n",(0,l.jsx)(n.h3,{id:"actioneventlookleftright",children:"actionEventLookLeftRight"}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Description"})}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Definition"})}),"\n",(0,l.jsxs)(n.blockquote,{children:["\n",(0,l.jsx)(n.p,{children:"actionEventLookLeftRight()"}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,l.jsxs)(n.table,{children:[(0,l.jsx)(n.thead,{children:(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.th,{children:"any"}),(0,l.jsx)(n.th,{children:"actionName"})]})}),(0,l.jsxs)(n.tbody,{children:[(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{children:"any"}),(0,l.jsx)(n.td,{children:"inputValue"})]}),(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{children:"any"}),(0,l.jsx)(n.td,{children:"callbackState"})]}),(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{children:"any"}),(0,l.jsx)(n.td,{children:"isAnalog"})]}),(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{children:"any"}),(0,l.jsx)(n.td,{children:"isMouse"})]})]})]}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Code"})}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-lua",children:"function VehicleCamera:actionEventLookLeftRight(actionName, inputValue, callbackState, isAnalog, isMouse)\n    if isMouse then\n        inputValue = inputValue * 0.001 * 16.666\n    else\n            inputValue = inputValue * 0.001 * g_currentDt\n        end\n        self.lastInputValues.leftRight = self.lastInputValues.leftRight + inputValue\n\n        --#debug if self.cameraYDebugMode then\n            --#debug local mouseButtonLast, _ = g_inputBinding:getMouseButtonState()\n            --#debug if mouseButtonLast = = Input.MOUSE_BUTTON_MIDDLE then\n                --#debug local x, y, z = getTranslation(self.rotateNode)\n                --#debug setTranslation(self.rotateNode, x, y, z + inputValue)\n                --#debug end\n                --#debug end\n            end\n\n"})}),"\n",(0,l.jsx)(n.h3,{id:"actioneventlookupdown",children:"actionEventLookUpDown"}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Description"})}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Definition"})}),"\n",(0,l.jsxs)(n.blockquote,{children:["\n",(0,l.jsx)(n.p,{children:"actionEventLookUpDown()"}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,l.jsxs)(n.table,{children:[(0,l.jsx)(n.thead,{children:(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.th,{children:"any"}),(0,l.jsx)(n.th,{children:"actionName"})]})}),(0,l.jsxs)(n.tbody,{children:[(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{children:"any"}),(0,l.jsx)(n.td,{children:"inputValue"})]}),(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{children:"any"}),(0,l.jsx)(n.td,{children:"callbackState"})]}),(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{children:"any"}),(0,l.jsx)(n.td,{children:"isAnalog"})]}),(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{children:"any"}),(0,l.jsx)(n.td,{children:"isMouse"})]})]})]}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Code"})}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-lua",children:"function VehicleCamera:actionEventLookUpDown(actionName, inputValue, callbackState, isAnalog, isMouse)\n    if isMouse then\n        inputValue = inputValue * 0.001 * 16.666\n    else\n            inputValue = inputValue * 0.001 * g_currentDt\n        end\n        self.lastInputValues.upDown = self.lastInputValues.upDown + inputValue\n\n        --#debug if self.cameraYDebugMode then\n            --#debug local mouseButtonLast, _ = g_inputBinding:getMouseButtonState()\n            --#debug if mouseButtonLast = = Input.MOUSE_BUTTON_MIDDLE then\n                --#debug local x, y, z = getTranslation(self.rotateNode)\n                --#debug setTranslation(self.rotateNode, x, y + inputValue, z)\n                --#debug end\n                --#debug end\n            end\n\n"})}),"\n",(0,l.jsx)(n.h3,{id:"consolecommandcameraydebug",children:"consoleCommandCameraYDebug"}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Description"})}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Definition"})}),"\n",(0,l.jsxs)(n.blockquote,{children:["\n",(0,l.jsx)(n.p,{children:"consoleCommandCameraYDebug()"}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,l.jsx)(n.table,{children:(0,l.jsx)(n.thead,{children:(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.th,{children:"any"}),(0,l.jsx)(n.th,{children:"height"})]})})}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Code"})}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-lua",children:'function VehicleCamera.consoleCommandCameraYDebug(height)\n    if g_activeVehicleCamera ~ = nil then\n        g_activeVehicleCamera:setCameraYDebugState( not g_activeVehicleCamera.cameraYDebugMode, height)\n        return string.format( "(%s) Vehicle Camera Y Debug: %s" , g_activeVehicleCamera.vehicle:getName(), g_activeVehicleCamera.cameraYDebugMode)\n    end\n\n    return "Enter a vehicle first!"\nend\n\n'})}),"\n",(0,l.jsx)(n.h3,{id:"consolecommandloddebug",children:"consoleCommandLODDebug"}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Description"})}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Definition"})}),"\n",(0,l.jsxs)(n.blockquote,{children:["\n",(0,l.jsx)(n.p,{children:"consoleCommandLODDebug()"}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Code"})}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-lua",children:'function VehicleCamera.consoleCommandLODDebug()\n    if g_activeVehicleCamera ~ = nil then\n        g_activeVehicleCamera:setLODDebugState( not g_activeVehicleCamera.lodDebugMode)\n        return string.format( "(%s) Vehicle Camera LOD Debug: %s" , g_activeVehicleCamera.vehicle:getName(), g_activeVehicleCamera.lodDebugMode)\n    end\n\n    return "Enter a vehicle first!"\nend\n\n'})}),"\n",(0,l.jsx)(n.h3,{id:"delete",children:"delete"}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Description"})}),"\n",(0,l.jsxs)(n.blockquote,{children:["\n",(0,l.jsx)(n.p,{children:"Deleting vehicle camera"}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Definition"})}),"\n",(0,l.jsxs)(n.blockquote,{children:["\n",(0,l.jsx)(n.p,{children:"delete()"}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Code"})}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-lua",children:"function VehicleCamera:delete()\n    g_cameraManager:removeCamera( self.cameraNode)\n\n    self:onDeactivate()\n\n    if self.cameraNode ~ = nil and self.positionSmoothingParameter > 0 then\n        delete( self.cameraNode)\n        self.cameraNode = nil\n    end\n\n    if self.cameraWorldParent ~ = nil then\n        delete( self.cameraWorldParent)\n        self.cameraWorldParent = nil\n    end\n\n    g_messageCenter:unsubscribe(MessageType.SETTING_CHANGED[GameSettings.SETTING.ACTIVE_SUSPENSION_CAMERA], self )\n    g_messageCenter:unsubscribe(MessageType.SETTING_CHANGED[GameSettings.SETTING.FOV_Y], self )\n    g_messageCenter:unsubscribe(MessageType.SETTING_CHANGED[GameSettings.SETTING.CAMERA_CHECK_COLLISION], self )\nend\n\n"})}),"\n",(0,l.jsx)(n.h3,{id:"getcollisiondistance",children:"getCollisionDistance"}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Description"})}),"\n",(0,l.jsxs)(n.blockquote,{children:["\n",(0,l.jsx)(n.p,{children:"Get distance to collision"}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Definition"})}),"\n",(0,l.jsxs)(n.blockquote,{children:["\n",(0,l.jsx)(n.p,{children:"getCollisionDistance()"}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Return Values"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,l.jsxs)(n.table,{children:[(0,l.jsx)(n.thead,{children:(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.th,{children:"any"}),(0,l.jsx)(n.th,{children:"hasCollision"}),(0,l.jsx)(n.th,{children:"has collision"})]})}),(0,l.jsxs)(n.tbody,{children:[(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{children:"any"}),(0,l.jsx)(n.td,{children:"collisionDistance"}),(0,l.jsx)(n.td,{children:"distance to collision"})]}),(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{children:"any"}),(0,l.jsx)(n.td,{children:"normalX"}),(0,l.jsx)(n.td,{children:"normal x"})]}),(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{children:"any"}),(0,l.jsx)(n.td,{children:"normalY"}),(0,l.jsx)(n.td,{children:"normal y"})]}),(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{children:"any"}),(0,l.jsx)(n.td,{children:"normalZ"}),(0,l.jsx)(n.td,{children:"normal z"})]}),(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{children:"any"}),(0,l.jsx)(n.td,{children:"normalDotDir"}),(0,l.jsx)(n.td,{children:"normal dot direction"})]})]})]}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Code"})}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-lua",children:'function VehicleCamera:getCollisionDistance()\n    if not self.isCollisionEnabled then\n        return false , nil , nil , nil , nil , nil\n    end\n\n    --#profile RemoteProfiler.zoneBeginN("VehicleCamera:getCollisionDistance")\n\n    local raycastMask = VehicleCamera.raycastMask\n\n    local targetCamX, targetCamY, targetCamZ = localToWorld( self.rotateNode, self.transDirX * self.zoomTarget, self.transDirY * self.zoomTarget, self.transDirZ * self.zoomTarget)\n\n    local hasCollision = false\n    local collisionDistance = - 1\n    local normalX,normalY,normalZ\n    local normalDotDir\n    for _, raycastNode in ipairs( self.raycastNodes) do\n\n        hasCollision = false\n\n        local nodeX, nodeY, nodeZ = getWorldTranslation(raycastNode)\n        local dirX, dirY, dirZ = targetCamX - nodeX, targetCamY - nodeY, targetCamZ - nodeZ\n        local dirLength = MathUtil.vector3Length(dirX, dirY, dirZ)\n        dirX = dirX / dirLength\n        dirY = dirY / dirLength\n        dirZ = dirZ / dirLength\n\n        local startX = nodeX\n        local startY = nodeY\n        local startZ = nodeZ\n        local currentDistance = 0\n        local minDistance = self.transMin\n\n        while true do\n            if (dirLength - currentDistance) < = 0 then\n                break\n            end\n            self.raycastDistance = 0\n            raycastClosest(startX, startY, startZ, dirX, dirY, dirZ, dirLength - currentDistance, "raycastCallback" , self , raycastMask)\n\n            if self.raycastDistance ~ = 0 then\n                currentDistance = currentDistance + self.raycastDistance + 0.001\n                local ndotd = MathUtil.dotProduct( self.normalX, self.normalY, self.normalZ, dirX, dirY, dirZ)\n\n                local object = g_currentMission:getNodeObject( self.raycastTransformId)\n                local ignoreObject = object = = self.vehicle\n\n                if object ~ = nil and not ignoreObject then\n                    if object.rootVehicle = = self.vehicle.rootVehicle then\n                        ignoreObject = true\n                    end\n\n                    if not ignoreObject then\n                        local vehicles = self.vehicle:getChildVehicles()\n                        for i = 1 , #vehicles do\n                            local vehicle = vehicles[i]\n\n                            if object ~ = vehicle then\n                                local mountObject = object.dynamicMountObject or object.tensionMountObject or object.mountObject\n                                if mountObject ~ = nil and(mountObject = = vehicle or mountObject.rootVehicle = = vehicle) then\n                                    ignoreObject = true\n                                    break\n                                end\n                            end\n                        end\n                    end\n                end\n\n                -- ignore cut trees that are loaded to a vehicle\n                if not ignoreObject and getHasClassId( self.raycastTransformId, ClassIds.MESH_SPLIT_SHAPE) then\n                    ignoreObject = true\n                end\n\n                if not ignoreObject and getHasTrigger( self.raycastTransformId) then\n                    ignoreObject = true\n                end\n\n                if ignoreObject then\n                    if ndotd > 0 then\n                        minDistance = math.max(minDistance, currentDistance)\n                    end\n                else\n                        hasCollision = true\n                        -- we take the distance from the rotate node\n                        if raycastNode = = self.rotateNode then\n                            normalX,normalY,normalZ = self.normalX, self.normalY, self.normalZ\n\n                            -- for static buildings we allow less than min.distance\n                                -- for all other objects we limit by min.camera translation(e.g.if you load a dynamic object onto a pickup truck)\n                                    if getRigidBodyType( self.raycastTransformId) = = RigidBodyType.STATIC then\n                                        collisionDistance = currentDistance\n                                    else\n                                            collisionDistance = math.max( self.transMin, currentDistance)\n                                        end\n\n                                        normalDotDir = ndotd\n                                    end\n                                    break\n                                end\n                                startX = nodeX + dirX * currentDistance\n                                startY = nodeY + dirY * currentDistance\n                                startZ = nodeZ + dirZ * currentDistance\n                            else\n                                    break\n                                end\n                            end\n                            if not hasCollision then\n                                break\n                            end\n                        end\n\n                        --#profile RemoteProfiler.zoneEnd()\n\n                        return hasCollision, collisionDistance, normalX,normalY,normalZ, normalDotDir\n                    end\n\n'})}),"\n",(0,l.jsx)(n.h3,{id:"gettiltdirectionoffset",children:"getTiltDirectionOffset"}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Description"})}),"\n",(0,l.jsxs)(n.blockquote,{children:["\n",(0,l.jsx)(n.p,{children:"Set separate camera pose"}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Definition"})}),"\n",(0,l.jsxs)(n.blockquote,{children:["\n",(0,l.jsx)(n.p,{children:"getTiltDirectionOffset()"}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Code"})}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-lua",children:"function VehicleCamera:getTiltDirectionOffset()\n    if not self.isInside and g_gameSettings:getValue(GameSettings.SETTING.CAMERA_TILTING) and getHasTouchpad() then\n        local dx, dy, dz = getGravityDirection()\n        local tiltOffset = MathUtil.getHorizontalRotationFromDeviceGravity(dx, dy, dz)\n        return tiltOffset\n    end\n\n    return 0\nend\n\n"})}),"\n",(0,l.jsx)(n.h3,{id:"loadfromxml",children:"loadFromXML"}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Description"})}),"\n",(0,l.jsxs)(n.blockquote,{children:["\n",(0,l.jsx)(n.p,{children:"Load vehicle camera from xml file"}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Definition"})}),"\n",(0,l.jsxs)(n.blockquote,{children:["\n",(0,l.jsx)(n.p,{children:"loadFromXML(XMLFile xmlFile, string key, , )"}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,l.jsxs)(n.table,{children:[(0,l.jsx)(n.thead,{children:(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.th,{children:"XMLFile"}),(0,l.jsx)(n.th,{children:"xmlFile"}),(0,l.jsx)(n.th,{children:"XMLFile instance"})]})}),(0,l.jsxs)(n.tbody,{children:[(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{children:"string"}),(0,l.jsx)(n.td,{children:"key"}),(0,l.jsx)(n.td,{children:"key"})]}),(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{children:"any"}),(0,l.jsx)(n.td,{children:"savegame"}),(0,l.jsx)(n.td,{})]}),(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{children:"any"}),(0,l.jsx)(n.td,{children:"cameraIndex"}),(0,l.jsx)(n.td,{})]})]})]}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Return Values"})}),"\n\n\n\n\n\n\n\n\n",(0,l.jsx)(n.table,{children:(0,l.jsx)(n.thead,{children:(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.th,{children:"any"}),(0,l.jsx)(n.th,{children:"success"}),(0,l.jsx)(n.th,{children:"success"})]})})}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Code"})}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-lua",children:'function VehicleCamera:loadFromXML(xmlFile, key, savegame, cameraIndex)\n    XMLUtil.checkDeprecatedXMLElements(xmlFile, self.vehicle.configFileName, key .. "#index" , "#node" ) -- FS17 to FS19\n\n    self.cameraNode = xmlFile:getValue(key .. "#node" , nil , self.vehicle.components, self.vehicle.i3dMappings)\n    if self.cameraNode = = nil or not getHasClassId( self.cameraNode, ClassIds.CAMERA) then\n        Logging.xmlWarning(xmlFile, "Invalid camera node for camera \'%s\'.Must be a camera type!" , key)\n            return false\n        end\n\n        self.shadowFocusBoxNode = xmlFile:getValue(key .. "#shadowFocusBox" , nil , self.vehicle.components, self.vehicle.i3dMappings)\n        if self.shadowFocusBoxNode ~ = nil and( not getHasClassId( self.shadowFocusBoxNode, ClassIds.SHAPE) or not getShapeIsCPUMesh( self.shadowFocusBoxNode)) then\n            Logging.xmlWarning(xmlFile, "Invalid camera shadow focus box \'%s\'.Must be a shape and cpu mesh" , getName( self.shadowFocusBoxNode))\n            self.shadowFocusBoxNode = nil\n        end\n\n        if Platform.gameplay.hasShadowFocusBox then\n            if self.isInside and self.shadowFocusBoxNode = = nil then\n                Logging.xmlDevWarning(xmlFile, "Missing shadow focus box for indoor camera \'%s\'" , key)\n                end\n            else\n                    if self.shadowFocusBoxNode ~ = nil then\n                        Logging.xmlDevWarning(xmlFile, "Shadow focus box for camera \'%s\' not allowed on this platform" , key)\n                            self.shadowFocusBoxNode = nil\n                        end\n                    end\n\n                    self.isInside = xmlFile:getValue(key .. "#isInside" , false )\n                    self.allowHeadTracking = xmlFile:getValue(key .. "#allowHeadTracking" , self.isInside)\n                    self.useOutdoorSounds = xmlFile:getValue(key .. "#useOutdoorSounds" , not self.isInside)\n\n                    local lowResColHandlerHighPrio = self.isInside -- update precipitation occlusion cells directly next to the camera each frame to avoid visible particles inside the cabin\n                    local dofInfo\n                    if not self.isInside then\n                        dofInfo = g_depthOfFieldManager:createInfo( 0.5 , 1 , 0.3 , 400 , 1400 , false ) --DOF ON\n                        -- dofInfo = g_depthOfFieldManager:createInfo(nil, nil, nil, nil, nil, nil) --DOF OFF\n                    end\n                    g_cameraManager:addCamera( self.cameraNode, self.shadowFocusBoxNode, false , lowResColHandlerHighPrio, dofInfo)\n\n                    -- collect vehicle collision nodes to toggle PRECIPITATION_BLOCKING col bit when indoor camera is active\n                    if self.isInside then\n                        self.collisionNodes = { }\n\n                        I3DUtil.iterateRecursively( self.vehicle.rootNode, function (node)\n                            if getHasClassId(node, ClassIds.SHAPE) and(getRigidBodyType(node) ~ = RigidBodyType.NONE or getIsCompoundChild(node)) and bit32.btest(getCollisionFilterGroup(node), CollisionFlag.VEHICLE) then\n                                table.insert( self.collisionNodes, node)\n                            end\n                        end , true )\n                    end\n\n                    self.defaultFovY = getFovY( self.cameraNode)\n                    self.fovY = calculateFovY( self.defaultFovY)\n                    setFovY( self.cameraNode, self.fovY)\n\n                    self.isRotatable = xmlFile:getValue(key .. "#rotatable" , false )\n                    self.limit = xmlFile:getValue(key .. "#limit" , false )\n                    if self.limit then\n                        self.rotMinX = xmlFile:getValue(key .. "#rotMinX" )\n                        self.rotMaxX = xmlFile:getValue(key .. "#rotMaxX" )\n\n                        self.transMin = xmlFile:getValue(key .. "#transMin" )\n                        self.transMax = xmlFile:getValue(key .. "#transMax" )\n\n                        if self.transMax ~ = nil then\n                            self.transMax = math.max( self.transMin, self.transMax * Platform.gameplay.maxCameraZoomFactor)\n                        end\n\n                        if self.rotMinX = = nil or self.rotMaxX = = nil or self.transMin = = nil or self.transMax = = nil then\n                            Logging.xmlWarning(xmlFile, "Missing \'rotMinX\', \'rotMaxX\', \'transMin\' or \'transMax\' for camera \'%s\'" , key)\n                                return false\n                            end\n                        end\n\n                        if self.isRotatable then\n                            self.rotateNode = xmlFile:getValue(key .. "#rotateNode" , nil , self.vehicle.components, self.vehicle.i3dMappings)\n                            self.hasExtraRotationNode = self.rotateNode ~ = nil\n                        end\n\n                        local rotation = xmlFile:getValue(key .. "#rotation" , nil , true )\n                        if rotation ~ = nil then\n                            local rotationNode = self.cameraNode\n                            if self.rotateNode ~ = nil then\n                                rotationNode = self.rotateNode\n                            end\n                            setRotation(rotationNode, unpack(rotation))\n                        end\n                        local translation = xmlFile:getValue(key .. "#translation" , nil , true )\n                        if translation ~ = nil then\n                            setTranslation( self.cameraNode, unpack(translation))\n                        end\n\n                        self.allowTranslation = ( self.rotateNode ~ = nil and self.rotateNode ~ = self.cameraNode)\n\n                        self.useMirror = xmlFile:getValue(key .. "#useMirror" , false )\n                        self.useWorldXZRotation = xmlFile:getValue(key .. "#useWorldXZRotation" ) -- overrides the ingame setting\n                        self.resetCameraOnVehicleSwitch = xmlFile:getValue(key .. "#resetCameraOnVehicleSwitch" ) -- overrides the ingame setting\n                        self.suspensionNodeIndex = xmlFile:getValue(key .. "#suspensionNodeIndex" )\n\n                        if ( not Platform.gameplay.useWorldCameraInside and self.isInside) or\n                            ( not Platform.gameplay.useWorldCameraOutside and not self.isInside) then\n                            self.useWorldXZRotation = false\n                        end\n\n                        self.positionSmoothingParameter = 0\n                        self.lookAtSmoothingParameter = 0\n                        local useDefaultPositionSmoothing = xmlFile:getValue(key .. "#useDefaultPositionSmoothing" , true )\n                        if useDefaultPositionSmoothing then\n                            if self.isInside then\n                                self.positionSmoothingParameter = 0.128 -- 0.095\n                                self.lookAtSmoothingParameter = 0.176 -- 0.12\n                            else\n                                    self.positionSmoothingParameter = 0.016\n                                    self.lookAtSmoothingParameter = 0.022\n                                end\n                            end\n                            self.positionSmoothingParameter = xmlFile:getValue(key .. "#positionSmoothingParameter" , self.positionSmoothingParameter)\n                            self.lookAtSmoothingParameter = xmlFile:getValue(key .. "#lookAtSmoothingParameter" , self.lookAtSmoothingParameter)\n\n                            local useHeadTracking = g_gameSettings:getValue(GameSettings.SETTING.IS_HEAD_TRACKING_ENABLED) and isHeadTrackingAvailable() and self.allowHeadTracking\n                            if useHeadTracking then\n                                self.positionSmoothingParameter = 0\n                                self.lookAtSmoothingParameter = 0\n                            end\n\n                            self.cameraPositionNode = self.cameraNode\n                            if self.positionSmoothingParameter > 0 then\n                                -- create a node which indicates the target position of the camera\n                                self.cameraPositionNode = createTransformGroup( "cameraPositionNode" )\n                                local camIndex = getChildIndex( self.cameraNode)\n                                link(getParent( self.cameraNode), self.cameraPositionNode, camIndex)\n                                local x,y,z = getTranslation( self.cameraNode)\n                                local rx,ry,rz = getRotation( self.cameraNode)\n                                setTranslation( self.cameraPositionNode, x, y, z)\n                                setRotation( self.cameraPositionNode, rx, ry, rz)\n\n                                -- parent node of the camera in world space that is already aligned with the Y rotation to the target position\n                                -- this avoids gimbal lock issues when at 0 or 180 degree(#)\n                                self.cameraWorldParent = createTransformGroup( "cameraWorldParent" )\n                                link( self.cameraWorldParent, self.cameraNode)\n                            end\n                            self.rotYSteeringRotSpeed = xmlFile:getValue(key .. "#rotYSteeringRotSpeed" , 0 )\n\n                            if self.rotateNode = = nil or self.rotateNode = = self.cameraNode then\n                                self.rotateNode = self.cameraPositionNode\n                            end\n\n                            if useHeadTracking then\n                                local dx,_,dz = localDirectionToLocal( self.cameraPositionNode, getParent( self.cameraPositionNode), 0 , 0 , 1 )\n                                local tx,ty,tz = localToLocal( self.cameraPositionNode, getParent( self.cameraPositionNode), 0 , 0 , 0 )\n                                self.headTrackingNode = createTransformGroup( "headTrackingNode" )\n                                link(getParent( self.cameraPositionNode), self.headTrackingNode)\n                                setTranslation( self.headTrackingNode, tx, ty, tz)\n                                if math.abs(dx) + math.abs(dz) > 0.0001 then\n                                    setDirection( self.headTrackingNode, dx, 0 , dz, 0 , 1 , 0 )\n                                else\n                                        setRotation( self.headTrackingNode, 0 , 0 , 0 )\n                                    end\n                                end\n\n                                self.origRotX, self.origRotY, self.origRotZ = getRotation( self.rotateNode)\n                                self.rotX = self.origRotX\n                                self.rotY = self.origRotY\n                                self.rotZ = self.origRotZ\n\n                                self.origTransX, self.origTransY, self.origTransZ = getTranslation( self.cameraPositionNode)\n                                self.transX = self.origTransX\n                                self.transY = self.origTransY\n                                self.transZ = self.origTransZ\n\n                                local transLength = MathUtil.vector3Length( self.origTransX, self.origTransY, self.origTransZ) + 0.00001 -- prevent devision by zero\n                                self.zoom = transLength\n                                self.zoomTarget = transLength\n                                self.zoomDefault = transLength\n                                self.zoomLimitedTarget = - 1\n\n                                local trans1OverLength = 1.0 / transLength\n                                self.transDirX = trans1OverLength * self.origTransX\n                                self.transDirY = trans1OverLength * self.origTransY\n                                self.transDirZ = trans1OverLength * self.origTransZ\n                                if self.allowTranslation then\n                                    if transLength < = 0.01 then\n                                        Logging.xmlWarning(xmlFile, "Invalid camera translation for camera \'%s\'.Distance needs to be bigger than 0.01" , key)\n                                        end\n                                    end\n\n                                    table.insert( self.raycastNodes, self.rotateNode)\n\n                                    for _, raycastKey in xmlFile:iterator(key .. ".raycastNode" ) do\n                                        XMLUtil.checkDeprecatedXMLElements(xmlFile, self.vehicle.configFileName, raycastKey .. "#index" , raycastKey .. "#node" ) --FS17 to FS19\n\n                                        local node = xmlFile:getValue(raycastKey .. "#node" , nil , self.vehicle.components, self.vehicle.i3dMappings)\n                                        if node ~ = nil then\n                                            table.insert( self.raycastNodes, node)\n                                        end\n                                    end\n\n                                    local sx, sy, sz = getScale( self.cameraNode)\n                                    if sx ~ = 1 or sy ~ = 1 or sz ~ = 1 then\n                                        Logging.xmlWarning(xmlFile, "Vehicle camera with scale found for camera \'%s\'.Resetting to scale 1" , key)\n                                            setScale( self.cameraNode, 1 , 1 , 1 )\n                                        end\n\n                                        self.changeObjects = { }\n                                        ObjectChangeUtil.loadObjectChangeFromXML(xmlFile, key, self.changeObjects, self.vehicle.components, self.vehicle)\n                                        ObjectChangeUtil.setObjectChanges( self.changeObjects, false , self.vehicle, self.vehicle.setMovingToolDirty)\n\n                                        if not g_gameSettings:getValue(GameSettings.SETTING.RESET_CAMERA) or g_currentMission.vehicleSystem.isReloadRunning then\n                                            if savegame ~ = nil and not savegame.resetVehicles then\n                                                local cameraKey = string.format(savegame.key .. ".enterable.camera(%d)" , cameraIndex)\n                                                if savegame.xmlFile:hasProperty(cameraKey) then\n                                                    local rotX, rotY, rotZ = savegame.xmlFile:getValue(cameraKey .. "#rotation" , { self.rotX, self.rotY, self.rotZ } )\n                                                    if not( MathUtil.isNan(rotX) or MathUtil.isNan(rotY) or MathUtil.isNan(rotZ)) then\n                                                        self.rotX, self.rotY, self.rotZ = rotX, rotY, rotZ\n\n                                                        if self.allowTranslation then\n                                                            self.transX, self.transY, self.transZ = savegame.xmlFile:getValue(cameraKey .. "#translation" , { self.transX, self.transY, self.transZ } )\n\n                                                            self.zoom = savegame.xmlFile:getValue(cameraKey .. "#zoom" , self.zoom)\n                                                            self.zoomTarget = self.zoom\n                                                        end\n\n                                                        setTranslation( self.cameraPositionNode, self.transX, self.transY, self.transZ)\n                                                        setRotation( self.rotateNode, self.rotX, self.rotY, self.rotZ)\n\n                                                        if g_currentMission.vehicleSystem.isReloadRunning then\n                                                            local fovY = savegame.xmlFile:getValue(cameraKey .. "#fovY" )\n                                                            if fovY ~ = nil then\n                                                                setFovY( self.cameraNode, fovY)\n                                                            end\n                                                        end\n\n                                                        self.lodDebugModeLoaded = savegame.xmlFile:getValue(cameraKey .. "#lodDebugActive" , false )\n                                                        if self.lodDebugModeLoaded then\n                                                            self.loadDebugZoom = savegame.xmlFile:getValue(cameraKey .. "#lodDebugZoom" , self.zoom)\n                                                        end\n\n                                                        --#debug self.cameraYDebugModeLoaded = savegame.xmlFile:getValue(cameraKey .. "#cameraYDebugActive", false)\n                                                        --#debug if self.cameraYDebugModeLoaded then\n                                                            --#debug self.cameraYDebugHeight = savegame.xmlFile:getValue(cameraKey .. "#cameraYDebugHeight")\n                                                            --#debug end\n                                                        end\n                                                    end\n                                                end\n                                            end\n\n                                            return true\n                                        end\n\n'})}),"\n",(0,l.jsx)(n.h3,{id:"new",children:"new"}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Description"})}),"\n",(0,l.jsxs)(n.blockquote,{children:["\n",(0,l.jsx)(n.p,{children:"Creating vehicle camera"}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Definition"})}),"\n",(0,l.jsxs)(n.blockquote,{children:["\n",(0,l.jsx)(n.p,{children:"new(Vehicle vehicle, table? customMt)"}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,l.jsxs)(n.table,{children:[(0,l.jsx)(n.thead,{children:(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.th,{children:"Vehicle"}),(0,l.jsx)(n.th,{children:"vehicle"}),(0,l.jsx)(n.th,{children:"The vehicle that this camera belongs to."})]})}),(0,l.jsx)(n.tbody,{children:(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{children:"table?"}),(0,l.jsx)(n.td,{children:"customMt"}),(0,l.jsx)(n.td,{children:"Custom metatable."})]})})]}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Return Values"})}),"\n\n\n\n\n\n\n\n\n",(0,l.jsx)(n.table,{children:(0,l.jsx)(n.thead,{children:(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.th,{children:"table?"}),(0,l.jsx)(n.th,{children:"self"}),(0,l.jsx)(n.th,{children:"The created instance."})]})})}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Code"})}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-lua",children:'function VehicleCamera.new(vehicle, customMt)\n    local self = setmetatable( { } , customMt or VehicleCamera _mt)\n\n    self.vehicle = vehicle\n    self.isActivated = false\n\n    self.limitRotXDelta = 0\n\n    self.cameraNode = nil\n\n    self.raycastDistance = 0\n    self.normalX = 0\n    self.normalY = 0\n    self.normalZ = 0\n\n    self.raycastNodes = { }\n    self.disableCollisionTime = - 1\n\n    self.lookAtPosition = { 0 , 0 , 0 }\n    self.lookAtLastTargetPosition = { 0 , 0 , 0 }\n    self.position = { 0 , 0 , 0 }\n    self.lastTargetPosition = { 0 , 0 , 0 }\n    self.upVector = { 0 , 0 , 0 }\n    self.lastUpVector = { 0 , 0 , 0 }\n\n    self.lastInputValues = { }\n    self.lastInputValues.upDown = 0\n    self.lastInputValues.leftRight = 0\n\n    self.isCollisionEnabled = true\n    if g_modIsLoaded[ "FS22_disableVehicleCameraCollision" ] or g_isDevelopmentVersion then\n        self.isCollisionEnabled = g_gameSettings:getValue(GameSettings.SETTING.CAMERA_CHECK_COLLISION)\n        g_messageCenter:subscribe(MessageType.SETTING_CHANGED[GameSettings.SETTING.CAMERA_CHECK_COLLISION], self.onCameraCollisionDetectionSettingChanged, self )\n    end\n\n    g_messageCenter:subscribe(MessageType.SETTING_CHANGED[GameSettings.SETTING.ACTIVE_SUSPENSION_CAMERA], self.onActiveCameraSuspensionSettingChanged, self )\n    g_messageCenter:subscribe(MessageType.SETTING_CHANGED[GameSettings.SETTING.FOV_Y], self.onFovySettingChanged, self )\n\n    return self\nend\n\n'})}),"\n",(0,l.jsx)(n.h3,{id:"onactivate",children:"onActivate"}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Description"})}),"\n",(0,l.jsxs)(n.blockquote,{children:["\n",(0,l.jsx)(n.p,{children:"Called on activate"}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Definition"})}),"\n",(0,l.jsxs)(n.blockquote,{children:["\n",(0,l.jsx)(n.p,{children:"onActivate()"}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Code"})}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-lua",children:'function VehicleCamera:onActivate()\n    if self.cameraNode = = nil then\n        return\n    end\n\n    if g_addCheatCommands then\n        addConsoleCommand( "gsCameraAutoRotate" , "Auto rotate vehicle outdoor camera" , "consoleCommandSetAutoRotate" , self , "speed" )\n        addConsoleCommand( "gsCameraOffset" , "Offset vehicle outdoor camera target" , "consoleCommandSetOffset" , self , "x; y; z" )\n        addConsoleCommand( "gsCameraRotationSaveLoad" , "Save and load current camera rotation + zoom" , "consoleCommandRotationSaveLoad" , self )\n    end\n\n    self:onActiveCameraSuspensionSettingChanged(g_gameSettings:getValue(GameSettings.SETTING.ACTIVE_SUSPENSION_CAMERA))\n\n    self.isActivated = true\n    if not g_currentMission.vehicleSystem.isReloadRunning then\n        if ( self.resetCameraOnVehicleSwitch = = nil and g_gameSettings:getValue(GameSettings.SETTING.RESET_CAMERA)) or self.resetCameraOnVehicleSwitch then\n            self:resetCamera()\n        end\n    end\n\n    if g_cameraManager:getActiveCamera() ~ = self.cameraNode then\n        g_cameraManager:setActiveCamera( self.cameraNode)\n    end\n\n    local rx,ry,rz = getWorldRotation( self.rotateNode)\n    if MathUtil.isNan(rx) or MathUtil.isNan(ry) or MathUtil.isNan(rz) then\n        self:resetCamera()\n    end\n\n    if self.positionSmoothingParameter > 0 then\n        local xlook,ylook,zlook = getWorldTranslation( self.rotateNode)\n\n        -- inject offset from console command\n        xlook = xlook + ( self.offsetX or 0 )\n        ylook = ylook + ( self.offsetY or 0 )\n        zlook = zlook + ( self.offsetZ or 0 )\n\n        self.lookAtPosition[ 1 ] = xlook\n        self.lookAtPosition[ 2 ] = ylook\n        self.lookAtPosition[ 3 ] = zlook\n        self.lookAtLastTargetPosition[ 1 ] = xlook\n        self.lookAtLastTargetPosition[ 2 ] = ylook\n        self.lookAtLastTargetPosition[ 3 ] = zlook\n        local x,y,z = getWorldTranslation( self.cameraPositionNode)\n        self.position[ 1 ] = x\n        self.position[ 2 ] = y\n        self.position[ 3 ] = z\n        self.lastTargetPosition[ 1 ] = x\n        self.lastTargetPosition[ 2 ] = y\n        self.lastTargetPosition[ 3 ] = z\n        local upx, upy, upz = localDirectionToWorld( self.rotateNode, self:getTiltDirectionOffset(), 1 , 0 )\n        self.upVector[ 1 ] = upx\n        self.upVector[ 2 ] = upy\n        self.upVector[ 3 ] = upz\n        self.lastUpVector[ 1 ] = upx\n        self.lastUpVector[ 2 ] = upy\n        self.lastUpVector[ 3 ] = upz\n\n        setWorldRotation( self.cameraNode, rx,ry,rz)\n        setWorldTranslation( self.cameraNode, x,y,z)\n    end\n\n    self.lastInputValues = { }\n    self.lastInputValues.upDown = 0\n    self.lastInputValues.leftRight = 0\n\n    -- activate action event callbacks\n    g_inputBinding:beginActionEventsModification( Vehicle.INPUT_CONTEXT_NAME)\n    local _, actionEventId1 = g_inputBinding:registerActionEvent(InputAction.AXIS_LOOK_UPDOWN_VEHICLE, self , VehicleCamera.actionEventLookUpDown, false , false , true , true , nil )\n    local _, actionEventId2 = g_inputBinding:registerActionEvent(InputAction.AXIS_LOOK_LEFTRIGHT_VEHICLE, self , VehicleCamera.actionEventLookLeftRight, false , false , true , true , nil )\n    g_inputBinding:setActionEventTextVisibility(actionEventId1, false )\n    g_inputBinding:setActionEventTextVisibility(actionEventId2, false )\n    g_inputBinding:endActionEventsModification()\n\n    ObjectChangeUtil.setObjectChanges( self.changeObjects, true , self.vehicle, self.vehicle.setMovingToolDirty)\n\n    -- add PRECIPITATION_BLOCKING bit to cols\n    self:updatePrecipitationCollisions( true )\n\n    if g_touchHandler ~ = nil then\n        self.touchListenerPinch = g_touchHandler:registerGestureListener(TouchHandler.GESTURE_PINCH, VehicleCamera.touchEventZoomInOut, self )\n        self.touchListenerY = g_touchHandler:registerGestureListener(TouchHandler.GESTURE_AXIS_Y, VehicleCamera.touchEventLookUpDown, self )\n        self.touchListenerX = g_touchHandler:registerGestureListener(TouchHandler.GESTURE_AXIS_X, VehicleCamera.touchEventLookLeftRight, self )\n    end\n\n    g_activeVehicleCamera = self\n    if self.lodDebugModeLoaded then\n        self:setLODDebugState( self.lodDebugModeLoaded, self.loadDebugZoom)\n        self.lodDebugModeLoaded = nil\n    end\n    --#debug if self.cameraYDebugModeLoaded then\n        --#debug self:setCameraYDebugState(self.cameraYDebugModeLoaded, self.cameraYDebugHeight)\n        --#debug self.cameraYDebugModeLoaded = nil\n        --#debug end\n    end\n\n'})}),"\n",(0,l.jsx)(n.h3,{id:"onactivecamerasuspensionsettingchanged",children:"onActiveCameraSuspensionSettingChanged"}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Description"})}),"\n",(0,l.jsxs)(n.blockquote,{children:["\n",(0,l.jsx)(n.p,{children:"Called when camera suspension setting has changed"}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Definition"})}),"\n",(0,l.jsxs)(n.blockquote,{children:["\n",(0,l.jsx)(n.p,{children:"onActiveCameraSuspensionSettingChanged(boolean newState)"}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n",(0,l.jsx)(n.table,{children:(0,l.jsx)(n.thead,{children:(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.th,{children:"boolean"}),(0,l.jsx)(n.th,{children:"newState"}),(0,l.jsx)(n.th,{children:"new setting state"})]})})}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Code"})}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-lua",children:"function VehicleCamera:onActiveCameraSuspensionSettingChanged(newState)\n    if self.suspensionNode ~ = nil then\n        if self.lastActiveCameraSuspensionSetting ~ = newState then\n            if newState then\n                link( self.cameraSuspensionParentNode, self.cameraPositionNode)\n            else\n                    link( self.cameraBaseParentNode, self.cameraPositionNode)\n                end\n\n                self.lastActiveCameraSuspensionSetting = newState\n            end\n        end\n    end\n\n"})}),"\n",(0,l.jsx)(n.h3,{id:"oncameracollisiondetectionsettingchanged",children:"onCameraCollisionDetectionSettingChanged"}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Description"})}),"\n",(0,l.jsxs)(n.blockquote,{children:["\n",(0,l.jsx)(n.p,{children:"Called when camera collision detection setting has changed"}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Definition"})}),"\n",(0,l.jsxs)(n.blockquote,{children:["\n",(0,l.jsx)(n.p,{children:"onCameraCollisionDetectionSettingChanged(boolean newState)"}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n",(0,l.jsx)(n.table,{children:(0,l.jsx)(n.thead,{children:(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.th,{children:"boolean"}),(0,l.jsx)(n.th,{children:"newState"}),(0,l.jsx)(n.th,{children:"new setting state"})]})})}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Code"})}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-lua",children:"function VehicleCamera:onCameraCollisionDetectionSettingChanged(newState)\n    self.isCollisionEnabled = newState\nend\n\n"})}),"\n",(0,l.jsx)(n.h3,{id:"ondeactivate",children:"onDeactivate"}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Description"})}),"\n",(0,l.jsxs)(n.blockquote,{children:["\n",(0,l.jsx)(n.p,{children:"Called on deactivate"}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Definition"})}),"\n",(0,l.jsxs)(n.blockquote,{children:["\n",(0,l.jsx)(n.p,{children:"onDeactivate()"}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Code"})}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-lua",children:'function VehicleCamera:onDeactivate()\n    self.isActivated = false\n\n    removeConsoleCommand( "gsCameraAutoRotate" )\n    removeConsoleCommand( "gsCameraOffset" )\n    removeConsoleCommand( "gsCameraRotationSaveLoad" )\n\n    -- remove action event callbacks\n    g_inputBinding:beginActionEventsModification( Vehicle.INPUT_CONTEXT_NAME)\n    g_inputBinding:removeActionEventsByTarget( self )\n    g_inputBinding:endActionEventsModification()\n\n    ObjectChangeUtil.setObjectChanges( self.changeObjects, false , self.vehicle, self.vehicle.setMovingToolDirty)\n\n    -- remove PRECIPITATION_BLOCKING bit from cols\n    self:updatePrecipitationCollisions( false )\n\n    if g_touchHandler ~ = nil then\n        g_touchHandler:removeGestureListener( self.touchListenerPinch)\n        g_touchHandler:removeGestureListener( self.touchListenerY)\n        g_touchHandler:removeGestureListener( self.touchListenerX)\n    end\n\n    if self.lodDebugMode then\n        self:setLODDebugState( false )\n    end\n    --#debug if self.cameraYDebugMode then\n        --#debug self:setCameraYDebugState(false)\n        --#debug end\n        if g_activeVehicleCamera = = self then\n            g_activeVehicleCamera = nil\n        end\n    end\n\n'})}),"\n",(0,l.jsx)(n.h3,{id:"onfovysettingchanged",children:"onFovySettingChanged"}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Description"})}),"\n",(0,l.jsxs)(n.blockquote,{children:["\n",(0,l.jsx)(n.p,{children:"Called when camera fovy setting has changed"}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Definition"})}),"\n",(0,l.jsxs)(n.blockquote,{children:["\n",(0,l.jsx)(n.p,{children:"onFovySettingChanged()"}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Code"})}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-lua",children:"function VehicleCamera:onFovySettingChanged()\n    if self.cameraNode ~ = nil then\n        self.fovY = calculateFovY( self.defaultFovY)\n        setFovY( self.cameraNode, self.fovY)\n    end\nend\n\n"})}),"\n",(0,l.jsx)(n.h3,{id:"onpostload",children:"onPostLoad"}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Description"})}),"\n",(0,l.jsxs)(n.blockquote,{children:["\n",(0,l.jsx)(n.p,{children:"Called after loading"}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Definition"})}),"\n",(0,l.jsxs)(n.blockquote,{children:["\n",(0,l.jsx)(n.p,{children:"onPostLoad(table savegame)"}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n",(0,l.jsx)(n.table,{children:(0,l.jsx)(n.thead,{children:(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.th,{children:"table"}),(0,l.jsx)(n.th,{children:"savegame"}),(0,l.jsx)(n.th,{children:"savegame data"})]})})}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Code"})}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-lua",children:"function VehicleCamera:onPostLoad(savegame)\n    self.suspensionNode = nil\n    if self.suspensionNodeIndex ~ = nil and self.vehicle.getSuspensionNodeFromIndex ~ = nil then\n        self.suspensionNode = self.vehicle:getSuspensionNodeFromIndex( self.suspensionNodeIndex)\n        if self.suspensionNode = = nil then\n            Logging.warning( \"Vehicle Camera '%s' with invalid suspensionIndex '%s' found.\" , getName( self.cameraNode), self.suspensionNodeIndex)\n        end\n    end\n    if self.suspensionNode ~ = nil then\n        if self.suspensionNode.node ~ = nil then\n            -- at the suspension node Y offset to the camera position, so we move both together\n            -- like this we can set up the camera correctly in maya / editor and the ingame position still matches\n            if self.suspensionNode.startTranslationOffset ~ = nil then\n                local yOffset = self.suspensionNode.startTranslationOffset[ 2 ]\n                if yOffset ~ = 0 then\n                    self.origTransY = self.origTransY + yOffset\n                    setTranslation( self.cameraPositionNode, self.origTransX, self.origTransY, self.origTransZ)\n                end\n            end\n\n            self.cameraSuspensionParentNode = createTransformGroup( \"cameraSuspensionParentNode\" )\n            link( self.suspensionNode.node, self.cameraSuspensionParentNode)\n            setWorldTranslation( self.cameraSuspensionParentNode, getWorldTranslation(getParent( self.cameraPositionNode)))\n            setWorldQuaternion( self.cameraSuspensionParentNode, getWorldQuaternion(getParent( self.cameraPositionNode)))\n\n            self.cameraBaseParentNode = getParent( self.cameraPositionNode)\n\n            self.lastActiveCameraSuspensionSetting = false\n        else\n                Logging.warning( \"Vehicle Camera '%s' with invalid suspensionIndex '%s' found.CharacterTorso suspensions are not allowed.\" , getName( self.cameraNode), self.suspensionNodeIndex)\n                self.suspensionNode = nil\n            end\n        end\n    end\n\n"})}),"\n",(0,l.jsx)(n.h3,{id:"raycastcallback",children:"raycastCallback"}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Description"})}),"\n",(0,l.jsxs)(n.blockquote,{children:["\n",(0,l.jsx)(n.p,{children:"Raycast callback"}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Definition"})}),"\n",(0,l.jsxs)(n.blockquote,{children:["\n",(0,l.jsx)(n.p,{children:"raycastCallback(integer transformId, float x, float y, float z, float distance, float nx, float ny, float nz)"}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,l.jsxs)(n.table,{children:[(0,l.jsx)(n.thead,{children:(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.th,{children:"integer"}),(0,l.jsx)(n.th,{children:"transformId"}),(0,l.jsx)(n.th,{children:"id raycasted object"})]})}),(0,l.jsxs)(n.tbody,{children:[(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{children:"float"}),(0,l.jsx)(n.td,{children:"x"}),(0,l.jsx)(n.td,{children:"x raycast position"})]}),(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{children:"float"}),(0,l.jsx)(n.td,{children:"y"}),(0,l.jsx)(n.td,{children:"y raycast position"})]}),(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{children:"float"}),(0,l.jsx)(n.td,{children:"z"}),(0,l.jsx)(n.td,{children:"z raycast position"})]}),(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{children:"float"}),(0,l.jsx)(n.td,{children:"distance"}),(0,l.jsx)(n.td,{children:"distance to raycast position"})]}),(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{children:"float"}),(0,l.jsx)(n.td,{children:"nx"}),(0,l.jsx)(n.td,{children:"normal x"})]}),(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{children:"float"}),(0,l.jsx)(n.td,{children:"ny"}),(0,l.jsx)(n.td,{children:"normal y"})]}),(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{children:"float"}),(0,l.jsx)(n.td,{children:"nz"}),(0,l.jsx)(n.td,{children:"normal z"})]})]})]}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Code"})}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-lua",children:"function VehicleCamera:raycastCallback(transformId, x, y, z, distance, nx, ny, nz)\n    self.raycastDistance = distance\n    self.normalX = nx\n    self.normalY = ny\n    self.normalZ = nz\n    self.raycastTransformId = transformId\nend\n\n"})}),"\n",(0,l.jsx)(n.h3,{id:"registercamerasavegamexmlpaths",children:"registerCameraSavegameXMLPaths"}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Description"})}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Definition"})}),"\n",(0,l.jsxs)(n.blockquote,{children:["\n",(0,l.jsx)(n.p,{children:"registerCameraSavegameXMLPaths()"}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,l.jsxs)(n.table,{children:[(0,l.jsx)(n.thead,{children:(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.th,{children:"any"}),(0,l.jsx)(n.th,{children:"schema"})]})}),(0,l.jsx)(n.tbody,{children:(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{children:"any"}),(0,l.jsx)(n.td,{children:"basePath"})]})})]}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Code"})}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-lua",children:'function VehicleCamera.registerCameraSavegameXMLPaths(schema, basePath)\n    schema:register(XMLValueType.VECTOR_ROT, basePath .. "#rotation" , "Camera rotation" )\n    schema:register(XMLValueType.VECTOR_TRANS, basePath .. "#translation" , "Camera translation" )\n    schema:register(XMLValueType.FLOAT, basePath .. "#zoom" , "Camera zoom" )\n    schema:register(XMLValueType.ANGLE, basePath .. "#fovY" , "Custom Field of View Y" )\n    schema:register(XMLValueType.BOOL, basePath .. "#lodDebugActive" , "LOD Debug Mode Active" )\n    schema:register(XMLValueType.FLOAT, basePath .. "#lodDebugZoom" , "LOD Debug Mode Zoom Ref" )\n    schema:register(XMLValueType.BOOL, basePath .. "#cameraYDebugActive" , "Camera Y Debug Mode Active" )\n    schema:register(XMLValueType.FLOAT, basePath .. "#cameraYDebugHeight" , "Camera Y Debug Mode orthographic height" )\nend\n\n'})}),"\n",(0,l.jsx)(n.h3,{id:"registercameraxmlpaths",children:"registerCameraXMLPaths"}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Description"})}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Definition"})}),"\n",(0,l.jsxs)(n.blockquote,{children:["\n",(0,l.jsx)(n.p,{children:"registerCameraXMLPaths()"}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,l.jsxs)(n.table,{children:[(0,l.jsx)(n.thead,{children:(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.th,{children:"any"}),(0,l.jsx)(n.th,{children:"schema"})]})}),(0,l.jsx)(n.tbody,{children:(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{children:"any"}),(0,l.jsx)(n.td,{children:"basePath"})]})})]}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Code"})}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-lua",children:'function VehicleCamera.registerCameraXMLPaths(schema, basePath)\n    schema:register(XMLValueType.NODE_INDEX, basePath .. "#node" , "Camera node" )\n    schema:register(XMLValueType.BOOL, basePath .. "#rotatable" , "Camera is rotatable" , false )\n    schema:register(XMLValueType.BOOL, basePath .. "#limit" , "Has limits" , false )\n    schema:register(XMLValueType.FLOAT, basePath .. "#rotMinX" , "Min.X rotation" )\n    schema:register(XMLValueType.FLOAT, basePath .. "#rotMaxX" , "Max.X rotation" )\n    schema:register(XMLValueType.FLOAT, basePath .. "#transMin" , "Min.Z translation" )\n    schema:register(XMLValueType.FLOAT, basePath .. "#transMax" , "Max.Z translation" )\n\n    schema:register(XMLValueType.BOOL, basePath .. "#isInside" , "Is camera inside.Used for camera smoothing and fallback/default value for \'useOutdoorSounds\'" , false )\n        schema:register(XMLValueType.BOOL, basePath .. "#allowHeadTracking" , "Allow head tracking" , "isInside value" )\n        schema:register(XMLValueType.NODE_INDEX, basePath .. "#shadowFocusBox" , "Shadow focus box" )\n\n        schema:register(XMLValueType.BOOL, basePath .. "#useOutdoorSounds" , "Use outdoor sounds" , "false for \'isInside\' cameras, otherwise true" )\n            schema:register(XMLValueType.NODE_INDEX, basePath .. "#rotateNode" , "Rotate node" )\n            schema:register(XMLValueType.VECTOR_ROT, basePath .. "#rotation" , "Camera rotation" )\n            schema:register(XMLValueType.VECTOR_TRANS, basePath .. "#translation" , "Camera translation" )\n\n            schema:register(XMLValueType.BOOL, basePath .. "#useMirror" , "Use mirrors" , false )\n            schema:register(XMLValueType.BOOL, basePath .. "#useWorldXZRotation" , "Use world XZ rotation" )\n            schema:register(XMLValueType.BOOL, basePath .. "#resetCameraOnVehicleSwitch" , "Reset camera on vehicle switch" )\n            schema:register(XMLValueType.INT, basePath .. "#suspensionNodeIndex" , "Index of seat suspension node" )\n            schema:register(XMLValueType.BOOL, basePath .. "#useDefaultPositionSmoothing" , "Use default position smoothing parameters" , true )\n\n            schema:register(XMLValueType.FLOAT, basePath .. "#positionSmoothingParameter" , "Position smoothing parameter" , "0.128 for indoor / 0.016 for outside" )\n                schema:register(XMLValueType.FLOAT, basePath .. "#lookAtSmoothingParameter" , "Look at smoothing parameter" , "0.176 for indoor / 0.022 for outside" )\n\n                    schema:register(XMLValueType.ANGLE, basePath .. "#rotYSteeringRotSpeed" , "Rot Y steering rotation speed" , 0 )\n\n                    schema:register(XMLValueType.NODE_INDEX, basePath .. ".raycastNode(?)#node" , "Raycast node" )\n\n                    ObjectChangeUtil.registerObjectChangeXMLPaths(schema, basePath)\n                end\n\n'})}),"\n",(0,l.jsx)(n.h3,{id:"resetcamera",children:"resetCamera"}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Description"})}),"\n",(0,l.jsxs)(n.blockquote,{children:["\n",(0,l.jsx)(n.p,{children:"Reset camera to original pose"}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Definition"})}),"\n",(0,l.jsxs)(n.blockquote,{children:["\n",(0,l.jsx)(n.p,{children:"resetCamera()"}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Code"})}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-lua",children:"function VehicleCamera:resetCamera()\n    self.rotX = self.origRotX\n    self.rotY = self.origRotY\n    self.rotZ = self.origRotZ\n\n    self.transX = self.origTransX\n    self.transY = self.origTransY\n    self.transZ = self.origTransZ\n\n    local transLength = MathUtil.vector3Length( self.origTransX, self.origTransY, self.origTransZ)\n    self.zoom = transLength\n    self.zoomTarget = transLength\n    self.zoomLimitedTarget = - 1\n\n    self:updateRotateNodeRotation()\n    setTranslation( self.cameraPositionNode, self.transX, self.transY, self.transZ)\n\n    if self.positionSmoothingParameter > 0 then\n        local xlook,ylook,zlook = getWorldTranslation( self.rotateNode)\n        self.lookAtPosition[ 1 ] = xlook + ( self.offsetX or 0 )\n        self.lookAtPosition[ 2 ] = ylook + ( self.offsetY or 0 )\n        self.lookAtPosition[ 3 ] = zlook + ( self.offsetZ or 0 )\n        local x,y,z = getWorldTranslation( self.cameraPositionNode)\n        self.position[ 1 ] = x\n        self.position[ 2 ] = y\n        self.position[ 3 ] = z\n\n        self:setSeparateCameraPose()\n    end\nend\n\n"})}),"\n",(0,l.jsx)(n.h3,{id:"savetoxmlfile",children:"saveToXMLFile"}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Description"})}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Definition"})}),"\n",(0,l.jsxs)(n.blockquote,{children:["\n",(0,l.jsx)(n.p,{children:"saveToXMLFile()"}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,l.jsxs)(n.table,{children:[(0,l.jsx)(n.thead,{children:(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.th,{children:"any"}),(0,l.jsx)(n.th,{children:"xmlFile"})]})}),(0,l.jsxs)(n.tbody,{children:[(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{children:"any"}),(0,l.jsx)(n.td,{children:"key"})]}),(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{children:"any"}),(0,l.jsx)(n.td,{children:"usedModNames"})]})]})]}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Code"})}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-lua",children:'function VehicleCamera:saveToXMLFile(xmlFile, key, usedModNames)\n    xmlFile:setValue(key .. "#rotation" , self.rotX, self.rotY, self.rotZ)\n    xmlFile:setValue(key .. "#translation" , self.transX, self.transY, self.transZ)\n    xmlFile:setValue(key .. "#zoom" , self.zoom)\n    xmlFile:setValue(key .. "#fovY" , getFovY( self.cameraNode))\n\n    if self.lodDebugMode then\n        xmlFile:setValue(key .. "#lodDebugActive" , true )\n        xmlFile:setValue(key .. "#lodDebugZoom" , self.loadDebugZoom)\n    end\n    --#debug if self.cameraYDebugMode then\n        --#debug xmlFile:setValue(key .. "#cameraYDebugActive", true)\n        --#debug xmlFile:setValue(key .. "#cameraYDebugHeight", getOrthographicHeight(self.cameraNode))\n        --#debug end\n    end\n\n'})}),"\n",(0,l.jsx)(n.h3,{id:"setcameraydebugstate",children:"setCameraYDebugState"}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Description"})}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Definition"})}),"\n",(0,l.jsxs)(n.blockquote,{children:["\n",(0,l.jsx)(n.p,{children:"setCameraYDebugState()"}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,l.jsxs)(n.table,{children:[(0,l.jsx)(n.thead,{children:(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.th,{children:"any"}),(0,l.jsx)(n.th,{children:"state"})]})}),(0,l.jsx)(n.tbody,{children:(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{children:"any"}),(0,l.jsx)(n.td,{children:"height"})]})})]}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Code"})}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-lua",children:"function VehicleCamera:setCameraYDebugState(state, height)\n    if state ~ = self.cameraYDebugMode then\n        self.cameraYDebugMode = state\n        if self.cameraYDebugMode then\n            self.cameraYDebugHeight = tonumber(height) or 5\n            self.cameraYDebugZoom = self.zoom\n\n            self.rotX, self.rotY, self.rotZ = 0 , math.pi * 0.5 , 0\n            setRotation( self.rotateNode, self.rotX, self.rotY, self.rotZ)\n            setIsOrthographic( self.cameraNode, true )\n            setOrthographicHeight( self.cameraNode, tonumber(height) or 5 )\n            self.isRotatable = false\n\n            g_currentMission.hud:setIsVisible( false )\n        else\n                self.isRotatable = true\n                setIsOrthographic( self.cameraNode, false )\n\n                if self = = g_activeVehicleCamera then\n                    g_currentMission.hud:setIsVisible( true )\n                end\n            end\n        end\n    end\n\n"})}),"\n",(0,l.jsx)(n.h3,{id:"setloddebugstate",children:"setLODDebugState"}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Description"})}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Definition"})}),"\n",(0,l.jsxs)(n.blockquote,{children:["\n",(0,l.jsx)(n.p,{children:"setLODDebugState()"}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,l.jsxs)(n.table,{children:[(0,l.jsx)(n.thead,{children:(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.th,{children:"any"}),(0,l.jsx)(n.th,{children:"state"})]})}),(0,l.jsx)(n.tbody,{children:(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{children:"any"}),(0,l.jsx)(n.td,{children:"zoom"})]})})]}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Code"})}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-lua",children:"function VehicleCamera:setLODDebugState(state, zoom)\n    if state ~ = self.lodDebugMode then\n        self.lodDebugMode = state\n        if self.lodDebugMode then\n            self.transMaxOrig = self.transMax\n            self.transMax = 350\n            self.loadDebugZoom = zoom or self.zoom\n\n            setViewDistanceCoeff( 1 )\n            setLODDistanceCoeff( 1 )\n            setTerrainLODDistanceCoeff( 1 )\n        else\n                self.transMax = self.transMaxOrig\n                self.zoomTarget = self.zoomDefault\n                self.zoom = self.zoomDefault\n                setFovY( self.cameraNode, self.fovY)\n\n                setViewDistanceCoeff(g_settingsModel.percentValues[g_settingsModel:getValue( SettingsModel.SETTING.OBJECT_DRAW_DISTANCE)])\n                setLODDistanceCoeff(g_settingsModel.percentValues[g_settingsModel:getValue( SettingsModel.SETTING.LOD_DISTANCE)])\n                setTerrainLODDistanceCoeff(g_settingsModel.percentValues[g_settingsModel:getValue( SettingsModel.SETTING.TERRAIN_LOD_DISTANCE)])\n            end\n        end\n    end\n\n"})}),"\n",(0,l.jsx)(n.h3,{id:"setseparatecamerapose",children:"setSeparateCameraPose"}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Description"})}),"\n",(0,l.jsxs)(n.blockquote,{children:["\n",(0,l.jsx)(n.p,{children:"Set separate camera pose"}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Definition"})}),"\n",(0,l.jsxs)(n.blockquote,{children:["\n",(0,l.jsx)(n.p,{children:"setSeparateCameraPose()"}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Code"})}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-lua",children:'function VehicleCamera:setSeparateCameraPose()\n    if self.rotateNode ~ = self.cameraPositionNode then\n        local dx = self.position[ 1 ] - self.lookAtPosition[ 1 ]\n        local dy = self.position[ 2 ] - self.lookAtPosition[ 2 ]\n        local dz = self.position[ 3 ] - self.lookAtPosition[ 3 ]\n\n        local wdx, wdz = MathUtil.vector2Normalize(dx, dz)\n        setDirection( self.cameraWorldParent, wdx, 0 , wdz, 0 , 1 , 0 )\n\n        local upx, upy, upz = unpack( self.upVector)\n        if upx = = 0 and upy = = 0 and upz = = 0 then\n            upy = 1\n        end\n\n        if math.abs(dx) < 0.001 and math.abs(dz) < 0.001 then\n            upx = 0.1\n        end\n\n        dx,dy,dz = MathUtil.vector3Normalize(dx,dy,dz)\n        upx,upy,upz = MathUtil.vector3Normalize(upx,upy,upz)\n\n        setWorldDirection( self.cameraNode, dx, dy, dz, upx, upy, upz)\n    else\n            local dx, dy, dz = localDirectionToWorld( self.rotateNode, 0 , 0 , 1 )\n            local upx, upy, upz = localDirectionToWorld( self.rotateNode, self:getTiltDirectionOffset(), 1 , 0 )\n            setWorldDirection( self.cameraNode, dx, dy, dz, upx, upy, upz)\n        end\n        setWorldTranslation( self.cameraNode, self.position[ 1 ], self.position[ 2 ], self.position[ 3 ])\n\n        if self.lodDebugMode then\n            local _, _ , curZoom = localToLocal( self.cameraNode, self.rotateNode, 0 , 0 , 0 )\n            local l = math.atan( self.fovY) * self.loadDebugZoom\n            local mouseButtonLast, mouseButtonStateLast = g_inputBinding:getMouseButtonState()\n            if mouseButtonStateLast and mouseButtonLast = = Input.MOUSE_BUTTON_MIDDLE then\n                setFovY( self.cameraNode, self.fovY)\n            else\n                    setFovY( self.cameraNode, math.tan(l / math.max(curZoom, l)))\n                end\n                setTextAlignment(RenderText.ALIGN_CENTER)\n                renderText( 0.5 , 0.1 , 0.04 , string.format( "Distance: %d" , self.zoom))\n                setTextAlignment(RenderText.ALIGN_LEFT)\n            end\n        end\n\n'})}),"\n",(0,l.jsx)(n.h3,{id:"toucheventlookleftright",children:"touchEventLookLeftRight"}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Description"})}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Definition"})}),"\n",(0,l.jsxs)(n.blockquote,{children:["\n",(0,l.jsx)(n.p,{children:"touchEventLookLeftRight()"}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,l.jsx)(n.table,{children:(0,l.jsx)(n.thead,{children:(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.th,{children:"any"}),(0,l.jsx)(n.th,{children:"value"})]})})}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Code"})}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-lua",children:"function VehicleCamera:touchEventLookLeftRight(value)\n    if self.isActivated then\n        local factor = (g_screenAspectRatio) * 75\n        VehicleCamera.actionEventLookLeftRight( self , nil , value * factor, nil , nil , false )\n    end\nend\n\n"})}),"\n",(0,l.jsx)(n.h3,{id:"toucheventlookupdown",children:"touchEventLookUpDown"}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Description"})}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Definition"})}),"\n",(0,l.jsxs)(n.blockquote,{children:["\n",(0,l.jsx)(n.p,{children:"touchEventLookUpDown()"}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,l.jsx)(n.table,{children:(0,l.jsx)(n.thead,{children:(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.th,{children:"any"}),(0,l.jsx)(n.th,{children:"value"})]})})}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Code"})}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-lua",children:"function VehicleCamera:touchEventLookUpDown(value)\n    if self.isActivated then\n        local factor = (g_screenHeight * g_pixelSizeX) * - 75\n        VehicleCamera.actionEventLookUpDown( self , nil , value * factor, nil , nil , false )\n    end\nend\n\n"})}),"\n",(0,l.jsx)(n.h3,{id:"toucheventzoominout",children:"touchEventZoomInOut"}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Description"})}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Definition"})}),"\n",(0,l.jsxs)(n.blockquote,{children:["\n",(0,l.jsx)(n.p,{children:"touchEventZoomInOut()"}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,l.jsx)(n.table,{children:(0,l.jsx)(n.thead,{children:(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.th,{children:"any"}),(0,l.jsx)(n.th,{children:"value"})]})})}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Code"})}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-lua",children:"function VehicleCamera:touchEventZoomInOut(value)\n    if self.isActivated then\n        self:zoomSmoothly(value * 15 )\n    end\nend\n\n"})}),"\n",(0,l.jsx)(n.h3,{id:"update",children:"update"}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Description"})}),"\n",(0,l.jsxs)(n.blockquote,{children:["\n",(0,l.jsx)(n.p,{children:"Update"}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Definition"})}),"\n",(0,l.jsxs)(n.blockquote,{children:["\n",(0,l.jsx)(n.p,{children:"update(float dt)"}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n",(0,l.jsx)(n.table,{children:(0,l.jsx)(n.thead,{children:(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.th,{children:"float"}),(0,l.jsx)(n.th,{children:"dt"}),(0,l.jsx)(n.th,{children:"time since last call in ms"})]})})}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Code"})}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-lua",children:'function VehicleCamera:update(dt)\n    --#profile RemoteProfiler.zoneBeginN("VehicleCamera:update")\n\n    local target = self.zoomTarget\n    if self.zoomLimitedTarget > = 0 then\n        target = math.min( self.zoomLimitedTarget, self.zoomTarget)\n    end\n    self.zoom = target + ( math.pow( 0.99579 , dt) * ( self.zoom - target) )\n\n    --#debug if Input.isKeyPressed(Input.KEY_lalt) then\n        --#debug if self.origLimit = = nil then\n            --#debug self.origLimit = self.limit\n            --#debug end\n            --#debug self.limit = false\n            --#debug elseif self.lastInputValues.upDown ~ = 0 then\n                --#debug if self.origLimit ~ = nil then\n                    --#debug self.limit = self.origLimit\n                    --#debug end\n                    --#debug end\n\n                    if self.lastInputValues.upDown ~ = 0 then\n                        local value = self.lastInputValues.upDown * g_gameSettings:getValue(GameSettings.SETTING.CAMERA_SENSITIVITY)\n                        self.lastInputValues.upDown = 0\n                        value = g_gameSettings:getValue(GameSettings.SETTING.INVERT_Y_LOOK) and - value or value\n\n                        if self.isRotatable then\n                            if self.isActivated and not g_gui:getIsGuiVisible() then\n                                if self.limitRotXDelta > 0.001 then\n                                    self.rotX = math.min( self.rotX - value, self.rotX)\n                                elseif self.limitRotXDelta < - 0.001 then\n                                        self.rotX = math.max( self.rotX - value, self.rotX)\n                                    else\n                                            self.rotX = self.rotX - value\n                                        end\n\n                                        if self.limit then\n                                            self.rotX = math.min( self.rotMaxX, math.max( self.rotMinX, self.rotX))\n                                        end\n                                    end\n                                end\n                            end\n\n                            if self.lastInputValues.leftRight ~ = 0 or self.autoRotateOverride then\n                                local value = self.autoRotateOverride or( self.lastInputValues.leftRight * g_gameSettings:getValue(GameSettings.SETTING.CAMERA_SENSITIVITY))\n                                self.lastInputValues.leftRight = 0\n\n                                if self.isRotatable then\n                                    if self.isActivated and not g_gui:getIsGuiVisible() then\n                                        self.rotY = self.rotY - value\n                                    end\n                                end\n                            end\n\n                            --\n                            if g_gameSettings:getValue(GameSettings.SETTING.IS_HEAD_TRACKING_ENABLED) and isHeadTrackingAvailable() and self.allowHeadTracking and self.headTrackingNode ~ = nil then\n                                local tx,ty,tz = getHeadTrackingTranslation()\n                                local pitch,yaw,roll = getHeadTrackingRotation()\n                                if pitch ~ = nil then\n                                    local camParent = getParent( self.cameraNode)\n                                    local ctx,cty,ctz\n                                    local crx,cry,crz\n                                    if camParent ~ = 0 then\n                                        ctx, cty, ctz = localToLocal( self.headTrackingNode, camParent, tx, ty, tz)\n                                        crx, cry, crz = localRotationToLocal( self.headTrackingNode, camParent, pitch,yaw,roll)\n                                    else\n                                            ctx, cty, ctz = localToWorld( self.headTrackingNode, tx, ty, tz)\n                                            crx, cry, crz = localRotationToWorld( self.headTrackingNode, pitch,yaw,roll)\n                                        end\n\n                                        setRotation( self.cameraNode, crx, cry, crz)\n                                        setTranslation( self.cameraNode, ctx, cty, ctz)\n                                    end\n                                else\n                                        self:updateRotateNodeRotation()\n\n                                        if self.limit then\n                                            -- adjust rotation to avoid clipping with terrain\n                                            if self.isRotatable and(( self.useWorldXZRotation = = nil and g_gameSettings:getValue(GameSettings.SETTING.USE_WORLD_CAMERA)) or self.useWorldXZRotation) then\n                                                local numIterations = 4\n                                                for _ = 1 , numIterations do\n                                                    local transX, transY, transZ = self.transDirX * self.zoom, self.transDirY * self.zoom, self.transDirZ * self.zoom\n                                                    local x,y,z = localToWorld(getParent( self.cameraPositionNode), transX, transY, transZ)\n\n                                                    local terrainHeight = DensityMapHeightUtil.getHeightAtWorldPos(x, 0 ,z)\n\n                                                    local minHeight = terrainHeight + 0.9\n                                                    if y < minHeight then\n                                                        local h = math.sin( self.rotX) * self.zoom\n                                                        local h2 = h - (minHeight - y)\n                                                        self.rotX = math.asin( math.clamp(h2 / self.zoom, - 1 , 1 ))\n                                                        self:updateRotateNodeRotation()\n                                                    else\n                                                            break\n                                                        end\n                                                    end\n                                                end\n\n                                                -- adjust zoom to avoid collision with objects\n                                                if self.allowTranslation then\n\n                                                    self.limitRotXDelta = 0\n                                                    local hasCollision, collisionDistance, nx,ny,nz, normalDotDir = self:getCollisionDistance()\n                                                    if hasCollision then\n                                                        local distOffset = 0.1\n                                                        if normalDotDir ~ = nil then\n                                                            local absNormalDotDir = math.abs(normalDotDir)\n                                                            distOffset = MathUtil.lerp( 1.2 , 0.1 , absNormalDotDir * absNormalDotDir * ( 3 - 2 * absNormalDotDir))\n                                                        end\n                                                        collisionDistance = math.max(collisionDistance - distOffset, 0.01 )\n                                                        self.disableCollisionTime = g_currentMission.time + 400\n                                                        self.zoomLimitedTarget = collisionDistance\n                                                        if collisionDistance < self.zoom then\n                                                            self.zoom = collisionDistance\n                                                        end\n                                                        if self.isRotatable and nx ~ = nil and collisionDistance < self.transMin then\n                                                            local _,lny,_ = worldDirectionToLocal( self.rotateNode, nx,ny,nz)\n                                                            if lny > 0.5 then\n                                                                self.limitRotXDelta = 1\n                                                            elseif lny < - 0.5 then\n                                                                    self.limitRotXDelta = - 1\n                                                                end\n                                                            end\n                                                        else\n                                                                if self.disableCollisionTime < = g_currentMission.time then\n                                                                    self.zoomLimitedTarget = - 1\n                                                                end\n                                                            end\n                                                        end\n\n                                                    end\n                                                    self.transX, self.transY, self.transZ = self.transDirX * self.zoom, self.transDirY * self.zoom, self.transDirZ * self.zoom\n                                                    setTranslation( self.cameraPositionNode, self.transX, self.transY, self.transZ)\n\n                                                    if self.positionSmoothingParameter > 0 then\n\n                                                        local interpDt = g_physicsDt\n\n                                                        if self.vehicle.spec_rideable ~ = nil then\n                                                            interpDt = self.vehicle.spec_rideable.interpolationDt\n                                                        end\n\n                                                        if g_server = = nil then\n                                                            -- on clients, we interpolate the vehicles with dt, thus we need to use the same for camera interpolation\n                                                                interpDt = dt\n                                                            end\n                                                            if interpDt > 0 then\n                                                                local xlook,ylook,zlook = getWorldTranslation( self.rotateNode)\n                                                                local lookAtPos = self.lookAtPosition\n                                                                local lookAtLastPos = self.lookAtLastTargetPosition\n                                                                lookAtPos[ 1 ],lookAtPos[ 2 ],lookAtPos[ 3 ] = self:getSmoothed( self.lookAtSmoothingParameter, lookAtPos[ 1 ],lookAtPos[ 2 ],lookAtPos[ 3 ], xlook,ylook,zlook, lookAtLastPos[ 1 ],lookAtLastPos[ 2 ],lookAtLastPos[ 3 ], interpDt)\n                                                                lookAtLastPos[ 1 ],lookAtLastPos[ 2 ],lookAtLastPos[ 3 ] = xlook,ylook,zlook\n\n                                                                local x,y,z = getWorldTranslation( self.cameraPositionNode)\n                                                                local pos = self.position\n                                                                local lastPos = self.lastTargetPosition\n                                                                pos[ 1 ],pos[ 2 ],pos[ 3 ] = self:getSmoothed( self.positionSmoothingParameter, pos[ 1 ],pos[ 2 ],pos[ 3 ], x,y,z, lastPos[ 1 ],lastPos[ 2 ],lastPos[ 3 ], interpDt)\n                                                                lastPos[ 1 ],lastPos[ 2 ],lastPos[ 3 ] = x,y,z\n\n                                                                local upx, upy, upz = localDirectionToWorld( self.rotateNode, self:getTiltDirectionOffset(), 1 , 0 )\n                                                                local up = self.upVector\n                                                                local lastUp = self.lastUpVector\n                                                                up[ 1 ],up[ 2 ],up[ 3 ] = self:getSmoothed( self.positionSmoothingParameter, up[ 1 ],up[ 2 ],up[ 3 ], upx, upy, upz, lastUp[ 1 ],lastUp[ 2 ],lastUp[ 3 ], interpDt)\n                                                                lastUp[ 1 ],lastUp[ 2 ],lastUp[ 3 ] = upx, upy, upz\n\n                                                                self:setSeparateCameraPose()\n                                                            end\n                                                        end\n                                                    end\n\n                                                    if MathUtil.isNan( self.rotX) or MathUtil.isNan( self.rotY) or MathUtil.isNan( self.rotZ) then\n                                                        self:resetCamera()\n                                                    end\n\n                                                    --#debug if self.cameraYDebugMode then\n                                                        --#debug setTextAlignment(RenderText.ALIGN_CENTER)\n                                                        --#debug setTextBold(true)\n                                                        --#debug\n                                                        --#debug local x, y, z = getTranslation(self.rotateNode)\n                                                        --#debug local text = string.format("Camera Position: %.2f %.2f %.2f", x, y, z)\n                                                        --#debug\n                                                        --#debug setTextColor(0, 0, 0, 1)\n                                                        --#debug renderText(0.5, 0.01, 0.025, text)\n                                                        --#debug\n                                                        --#debug setTextColor(1, 1, 1, 1)\n                                                        --#debug renderText(0.499, 0.012, 0.025, text)\n                                                        --#debug\n                                                        --#debug setTextAlignment(RenderText.ALIGN_LEFT)\n                                                        --#debug setTextBold(false)\n                                                        --#debug end\n\n                                                        --#profile RemoteProfiler.zoneEnd()\n                                                    end\n\n'})}),"\n",(0,l.jsx)(n.h3,{id:"updaterotatenoderotation",children:"updateRotateNodeRotation"}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Description"})}),"\n",(0,l.jsxs)(n.blockquote,{children:["\n",(0,l.jsx)(n.p,{children:"Update rotation node rotation"}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Definition"})}),"\n",(0,l.jsxs)(n.blockquote,{children:["\n",(0,l.jsx)(n.p,{children:"updateRotateNodeRotation()"}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Code"})}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-lua",children:"function VehicleCamera:updateRotateNodeRotation()\n\n    local rotY = self.rotY\n    if self.rotYSteeringRotSpeed ~ = nil and self.rotYSteeringRotSpeed ~ = 0 and self.vehicle.spec_articulatedAxis ~ = nil and self.vehicle.spec_articulatedAxis.interpolatedRotatedTime ~ = nil then\n        rotY = rotY + self.vehicle.spec_articulatedAxis.interpolatedRotatedTime * self.rotYSteeringRotSpeed\n    end\n\n    if ( self.useWorldXZRotation = = nil and g_gameSettings:getValue(GameSettings.SETTING.USE_WORLD_CAMERA)) or self.useWorldXZRotation then\n\n        local vehicleDirectionX, _, vehicleDirectionZ = localDirectionToWorld(getParent( self.rotateNode), 0 , 0 , 1 )\n        vehicleDirectionX, vehicleDirectionZ = MathUtil.vector2Normalize(vehicleDirectionX, vehicleDirectionZ)\n\n        local newDx = math.cos( self.rotX) * ( math.cos(rotY) * vehicleDirectionX + math.sin(rotY) * vehicleDirectionZ)\n        local newDy = - math.sin( self.rotX)\n        local newDz = math.cos( self.rotX) * ( - math.sin(rotY) * vehicleDirectionX + math.cos(rotY) * vehicleDirectionZ)\n\n        newDx,newDy,newDz = worldDirectionToLocal(getParent( self.rotateNode), newDx,newDy,newDz)\n        local upx,upy,upz = worldDirectionToLocal(getParent( self.rotateNode), 0 , 1 , 0 )\n\n        -- worst case check\n        if math.abs( MathUtil.dotProduct(newDx,newDy,newDz, upx,upy,upz)) > ( 0.99 * MathUtil.vector3Length(newDx,newDy,newDz) * MathUtil.vector3Length(upx,upy,upz) ) then\n            setRotation( self.rotateNode, self.rotX, rotY, self.rotZ)\n        else\n                setDirection( self.rotateNode, newDx,newDy,newDz, upx,upy,upz)\n            end\n        else\n                setRotation( self.rotateNode, self.rotX, rotY, self.rotZ)\n            end\n        end\n\n"})}),"\n",(0,l.jsx)(n.h3,{id:"zoomsmoothly",children:"zoomSmoothly"}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Description"})}),"\n",(0,l.jsxs)(n.blockquote,{children:["\n",(0,l.jsx)(n.p,{children:"Zoom camera smoothly"}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Definition"})}),"\n",(0,l.jsxs)(n.blockquote,{children:["\n",(0,l.jsx)(n.p,{children:"zoomSmoothly(float offset)"}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n",(0,l.jsx)(n.table,{children:(0,l.jsx)(n.thead,{children:(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.th,{children:"float"}),(0,l.jsx)(n.th,{children:"offset"}),(0,l.jsx)(n.th,{children:"offset"})]})})}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Code"})}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-lua",children:"function VehicleCamera:zoomSmoothly(offset)\n    local transMin, transMax = self.transMin, self.transMax\n    --#debug if Input.isKeyPressed(Input.KEY_lalt) then\n        --#debug offset = offset * 0.1\n        --#debug transMin, transMax = 0, 100\n        --#debug end\n\n        if self.lodDebugMode then\n            offset = offset * 10\n        end\n\n        local zoomTarget = self.zoomTarget\n        if transMin ~ = nil and transMax ~ = nil and transMin ~ = transMax then\n            zoomTarget = math.min(transMax, math.max(transMin, self.zoomTarget + offset))\n        end\n        self.zoomTarget = zoomTarget\n\n        --#debug if self.cameraYDebugMode then\n            --#debug setOrthographicHeight(self.cameraNode, getOrthographicHeight(self.cameraNode) + offset * 0.1)\n            --#debug end\n        end\n\n"})})]})}function h(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,l.jsx)(n,{...e,children:(0,l.jsx)(c,{...e})}):c(e)}}}]);