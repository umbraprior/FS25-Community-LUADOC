"use strict";(globalThis.webpackChunkfs25_community_luadoc=globalThis.webpackChunkfs25_community_luadoc||[]).push([[40194],{28453(e,n,t){t.d(n,{R:()=>r,x:()=>l});var i=t(96540);const a={},s=i.createContext(a);function r(e){const n=i.useContext(s);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:r(e.components),i.createElement(s.Provider,{value:n},e.children)}},61867(e,n,t){t.r(n),t.d(n,{assets:()=>o,contentTitle:()=>l,default:()=>h,frontMatter:()=>r,metadata:()=>i,toc:()=>c});const i=JSON.parse('{"id":"script/Handtools/HandToolChainsaw","title":"HandToolChainsaw","description":"HandToolChainsaw","source":"@site/../docs/script/Handtools/HandToolChainsaw.md","sourceDirName":"script/Handtools","slug":"/script/Handtools/HandToolChainsaw","permalink":"/FS25-Community-LUADOC/script/Handtools/HandToolChainsaw","draft":false,"unlisted":false,"tags":[],"version":"current","lastUpdatedAt":1767161192000,"frontMatter":{},"sidebar":"docsSidebar","previous":{"title":"HandTool","permalink":"/FS25-Community-LUADOC/script/Handtools/HandTool"},"next":{"title":"HandToolFlashlight","permalink":"/FS25-Community-LUADOC/script/Handtools/HandToolFlashlight"}}');var a=t(74848),s=t(28453);const r={},l=void 0,o={},c=[{value:"HandToolChainsaw",id:"handtoolchainsaw",level:2},{value:"beginCutting",id:"begincutting",level:3},{value:"beginDelimbing",id:"begindelimbing",level:3},{value:"calculateCutPlane",id:"calculatecutplane",level:3},{value:"getChainSpeedFactor",id:"getchainspeedfactor",level:3},{value:"onCutAction",id:"oncutaction",level:3},{value:"onDelete",id:"ondelete",level:3},{value:"onDraw",id:"ondraw",level:3},{value:"onHeldEnd",id:"onheldend",level:3},{value:"onHeldStart",id:"onheldstart",level:3},{value:"onLoad",id:"onload",level:3},{value:"onPostLoad",id:"onpostload",level:3},{value:"onReadUpdateStream",id:"onreadupdatestream",level:3},{value:"onRegisterActionEvents",id:"onregisteractionevents",level:3},{value:"onRingLoadFinished",id:"onringloadfinished",level:3},{value:"onRollAction",id:"onrollaction",level:3},{value:"onUpdate",id:"onupdate",level:3},{value:"onWriteUpdateStream",id:"onwriteupdatestream",level:3},{value:"prerequisitesPresent",id:"prerequisitespresent",level:3},{value:"registerEventListeners",id:"registereventlisteners",level:3},{value:"registerFunctions",id:"registerfunctions",level:3},{value:"registerXMLPaths",id:"registerxmlpaths",level:3},{value:"setCurrentCutState",id:"setcurrentcutstate",level:3},{value:"stopCutting",id:"stopcutting",level:3},{value:"stopDelimbing",id:"stopdelimbing",level:3},{value:"testIfCutAllowed",id:"testifcutallowed",level:3},{value:"testIfCutValid",id:"testifcutvalid",level:3},{value:"testIfTooLow",id:"testiftoolow",level:3},{value:"updateCutting",id:"updatecutting",level:3},{value:"updateCuttingAnimation",id:"updatecuttinganimation",level:3},{value:"updateRingSelector",id:"updateringselector",level:3},{value:"updateSplitPlane",id:"updatesplitplane",level:3}];function d(e){const n={a:"a",blockquote:"blockquote",code:"code",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,s.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.h2,{id:"handtoolchainsaw",children:"HandToolChainsaw"}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Description"})}),"\n",(0,a.jsxs)(n.blockquote,{children:["\n",(0,a.jsx)(n.p,{children:"The hand tool specialisation for chainsaws."}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Functions"})}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.a,{href:"#begincutting",children:"beginCutting"})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.a,{href:"#begindelimbing",children:"beginDelimbing"})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.a,{href:"#calculatecutplane",children:"calculateCutPlane"})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.a,{href:"#getchainspeedfactor",children:"getChainSpeedFactor"})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.a,{href:"#oncutaction",children:"onCutAction"})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.a,{href:"#ondelete",children:"onDelete"})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.a,{href:"#ondraw",children:"onDraw"})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.a,{href:"#onheldend",children:"onHeldEnd"})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.a,{href:"#onheldstart",children:"onHeldStart"})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.a,{href:"#onload",children:"onLoad"})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.a,{href:"#onpostload",children:"onPostLoad"})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.a,{href:"#onreadupdatestream",children:"onReadUpdateStream"})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.a,{href:"#onregisteractionevents",children:"onRegisterActionEvents"})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.a,{href:"#onringloadfinished",children:"onRingLoadFinished"})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.a,{href:"#onrollaction",children:"onRollAction"})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.a,{href:"#onupdate",children:"onUpdate"})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.a,{href:"#onwriteupdatestream",children:"onWriteUpdateStream"})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.a,{href:"#prerequisitespresent",children:"prerequisitesPresent"})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.a,{href:"#registereventlisteners",children:"registerEventListeners"})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.a,{href:"#registerfunctions",children:"registerFunctions"})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.a,{href:"#registerxmlpaths",children:"registerXMLPaths"})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.a,{href:"#setcurrentcutstate",children:"setCurrentCutState"})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.a,{href:"#stopcutting",children:"stopCutting"})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.a,{href:"#stopdelimbing",children:"stopDelimbing"})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.a,{href:"#testifcutallowed",children:"testIfCutAllowed"})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.a,{href:"#testifcutvalid",children:"testIfCutValid"})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.a,{href:"#testiftoolow",children:"testIfTooLow"})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.a,{href:"#updatecutting",children:"updateCutting"})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.a,{href:"#updatecuttinganimation",children:"updateCuttingAnimation"})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.a,{href:"#updateringselector",children:"updateRingSelector"})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.a,{href:"#updatesplitplane",children:"updateSplitPlane"})}),"\n"]}),"\n",(0,a.jsx)(n.h3,{id:"begincutting",children:"beginCutting"}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Description"})}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Definition"})}),"\n",(0,a.jsxs)(n.blockquote,{children:["\n",(0,a.jsx)(n.p,{children:"beginCutting()"}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Code"})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-lua",children:'function HandToolChainsaw:beginCutting()\n    local spec = self.spec_chainsaw\n\n    if spec.ringNode ~ = nil then\n        setVisibility(spec.ringNode, false )\n    end\n\n    local player = self:getCarryingPlayer()\n    if player = = nil or not player.isOwner then\n        return\n    end\n\n    if spec.possibleTreeNode = = nil then\n        return\n    end\n\n    local cutX, _, cutZ = getWorldTranslation(spec.cameraRotationNode)\n    if not self:testIfCutAllowed(spec.possibleTreeNode, cutX, cutZ) then\n        local mission = g_currentMission\n        mission:showBlinkingWarning(g_i18n:getText( "warning_youAreNotAllowedToCutThisTree" ), 2000 )\n\n        return\n    end\n\n    local _, _, rotZ = getRotation(spec.cameraRotationNode)\n    self:setCurrentCutState(ChainsawCutState.CUTTING, rotZ < 0.7 )\n\n    -- Set the tree that is being cut.\n    spec.cuttingTreeNode = spec.possibleTreeNode\n\n    -- Reset the load and set the target RPM based on it.This will kick the chainsaw into max RPM.\n    self:setCurrentLoad( 0 )\n\n    -- Set the state.\n    spec.currentCutTime = 0\n\n    -- Calculate the amount of time the chainsaw will need to spin up to speed.\n    spec.currentTargetStartupTime = math.max( math.floor( self:getTimeToReachRPM( self:getMaxRPM()) * 1000 ), 0.00001 )\n\n    -- Calculate the oval-shaped area of the cut.\n    local cutArea = (spec.cutMaximumZ - spec.cutMinimumZ) * (spec.cutMaximumY - spec.cutMinimumY) * math.pi\n\n    -- Set the target cut time based on the area and startup time.\n    spec.currentTargetCutTime = (cutArea * spec.cutTimePerSquareMeter) + spec.currentTargetStartupTime\n\n    -- Calculate the very start of the cutting position, where the chainsaw is given some space to rev up.\n    spec.cutRevPositionX, spec.cutRevPositionY, spec.cutRevPositionZ = localToWorld(spec.splitPlaneNode, spec.cutMinimumY - ( 0.05 ), 0 , spec.cutMinimumZ)\n\n    -- Calculate the start and end position for the cut.\n    spec.cutStartPositionX, spec.cutStartPositionY, spec.cutStartPositionZ = localToWorld(spec.splitPlaneNode, spec.cutMinimumY, 0 , spec.cutMinimumZ)\n    spec.cutEndPositionX, spec.cutEndPositionY, spec.cutEndPositionZ = localToWorld(spec.splitPlaneNode, spec.cutMaximumY, 0 , spec.cutMinimumZ)\n\n    -- Attach the graphical node of the chainsaw to the cut guide node.\n    HandToolUtil.linkAndTransformRelativeToParent( self.graphicalNode, spec.cutNode, spec.cutGuideNode)\n\n    -- Lock the player\'s input so they cannot move or look around.\n    if player.inputComponent ~ = nil then\n        player.inputComponent:lock()\n    end\nend\n\n'})}),"\n",(0,a.jsx)(n.h3,{id:"begindelimbing",children:"beginDelimbing"}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Description"})}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Definition"})}),"\n",(0,a.jsxs)(n.blockquote,{children:["\n",(0,a.jsx)(n.p,{children:"beginDelimbing()"}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Code"})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-lua",children:"function HandToolChainsaw:beginDelimbing()\n    local spec = self.spec_chainsaw\n\n    local player = self:getCarryingPlayer()\n    if player = = nil or not player.isOwner then\n        return\n    end\n\n    self:setCurrentCutState(ChainsawCutState.DELIMBING, true )\n\n    -- Reset the load and set the target RPM based on it.This will kick the chainsaw into max RPM.\n    self:setCurrentLoad( 0 )\n    self:setTargetRPMToMax()\n\n    g_inputBinding:setActionEventTextVisibility(spec.activateActionId, false )\nend\n\n"})}),"\n",(0,a.jsx)(n.h3,{id:"calculatecutplane",children:"calculateCutPlane"}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Description"})}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Definition"})}),"\n",(0,a.jsxs)(n.blockquote,{children:["\n",(0,a.jsx)(n.p,{children:"calculateCutPlane()"}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Code"})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-lua",children:"function HandToolChainsaw:calculateCutPlane()\n    local spec = self.spec_chainsaw\n    local x, y, z = getWorldTranslation(spec.splitPlaneNode)\n    local downX, downY, downZ = localDirectionToWorld(spec.splitPlaneNode, 0 , - 1 , 0 )\n    local leftX, leftY, leftZ = localDirectionToWorld(spec.splitPlaneNode, 1 , 0 , 0 )\n    local planeWidth = spec.maximumCutDiameter\n    local planeDepth = spec.maximumCutDiameter + HandToolChainsaw.SPLIT_PLANE_OFFSET_Z\n\n    return x, y, z, downX, downY, downZ, leftX, leftY, leftZ, planeWidth, planeDepth\nend\n\n"})}),"\n",(0,a.jsx)(n.h3,{id:"getchainspeedfactor",children:"getChainSpeedFactor"}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Description"})}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Definition"})}),"\n",(0,a.jsxs)(n.blockquote,{children:["\n",(0,a.jsx)(n.p,{children:"getChainSpeedFactor()"}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Code"})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-lua",children:"function HandToolChainsaw:getChainSpeedFactor()\n    local motorizedSpec = self.spec_motorized\n    return MathUtil.inverseLerp( 0.3 , 1 , MathUtil.lerp(motorizedSpec.minRPM, motorizedSpec.maxRPM, motorizedSpec.currentRPM))\nend\n\n"})}),"\n",(0,a.jsx)(n.h3,{id:"oncutaction",children:"onCutAction"}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Description"})}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Definition"})}),"\n",(0,a.jsxs)(n.blockquote,{children:["\n",(0,a.jsx)(n.p,{children:"onCutAction()"}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,a.jsxs)(n.table,{children:[(0,a.jsx)(n.thead,{children:(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.th,{children:"any"}),(0,a.jsx)(n.th,{children:"_"})]})}),(0,a.jsx)(n.tbody,{children:(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:"any"}),(0,a.jsx)(n.td,{children:"inputValue"})]})})]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Code"})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-lua",children:"function HandToolChainsaw:onCutAction(_, inputValue)\n    -- Find if the input is being engaged or released.\n        local isInputDown = inputValue > 0\n\n        local spec = self.spec_chainsaw\n\n        spec.isCutting = isInputDown\n\n        -- If the input is released, handle cancelling the current action.\n        if not isInputDown then\n            if spec.currentCutState = = ChainsawCutState.CUTTING then\n                self:stopCutting( false )\n            elseif spec.currentCutState = = ChainsawCutState.DELIMBING then\n                    self:stopDelimbing()\n                else\n                        spec.currentCutState = ChainsawCutState.IDLE\n                    end\n\n                    return\n                end\n\n                -- Get the targeted tree.If there is no tree, start the delimbing state.\n                if spec.targetedTree = = nil then\n                    self:beginDelimbing()\n                    -- Otherwise; begin cutting.\n                else\n                        self:beginCutting()\n\n                        -- If cutting failed, start delimbing instead.This has the effect of revving up the chainsaw even if the cut was invalid.\n                            if spec.currentCutState ~ = ChainsawCutState.CUTTING then\n                                self:beginDelimbing()\n                            end\n                        end\n                    end\n\n"})}),"\n",(0,a.jsx)(n.h3,{id:"ondelete",children:"onDelete"}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Description"})}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Definition"})}),"\n",(0,a.jsxs)(n.blockquote,{children:["\n",(0,a.jsx)(n.p,{children:"onDelete()"}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Code"})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-lua",children:"function HandToolChainsaw:onDelete()\n    local spec = self.spec_chainsaw\n\n    -- Release the shared i3d file for the ring indicator.\n        if spec.ringSharedLoadRequestId ~ = nil then\n            g_i3DManager:releaseSharedI3DFile(spec.ringSharedLoadRequestId)\n            spec.ringSharedLoadRequestId = nil\n        end\n\n        -- Delete the animations and effects.\n        if spec.chainsAnimation ~ = nil then\n            g_animationManager:deleteAnimations(spec.chainsAnimation)\n        end\n        g_effectManager:deleteEffects(spec.effects)\n\n        g_soundManager:deleteSamples(spec.cutSamples)\n\n        -- Delete the cut guide node.\n        if spec.cutGuideNode ~ = nil then\n            delete(spec.cutGuideNode)\n            spec.cutGuideNode = nil\n        end\n\n        -- Delete the camera rotation node and set all its children to nil.\n        if spec.cameraRotationNode ~ = nil then\n            delete(spec.cameraRotationNode)\n            spec.cameraRotationNode = nil\n            spec.splitPlaneNode = nil\n            spec.ringNode = nil\n        end\n\n        -- Tell the player to remove trees from their targeter.\n        if self:getCarryingPlayer() ~ = nil then\n            self:getCarryingPlayer().targeter:removeTargetType( HandToolChainsaw )\n        end\n\n        if spec.crosshair ~ = nil then\n            spec.crosshair:delete()\n            spec.crosshair = nil\n        end\n    end\n\n"})}),"\n",(0,a.jsx)(n.h3,{id:"ondraw",children:"onDraw"}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Description"})}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Definition"})}),"\n",(0,a.jsxs)(n.blockquote,{children:["\n",(0,a.jsx)(n.p,{children:"onDraw()"}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Code"})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-lua",children:"function HandToolChainsaw:onDraw()\n    -- Only draw the crosshair as long as the player is not cutting.\n    local spec = self.spec_chainsaw\n    if spec.crosshair ~ = nil and spec.currentCutState = = ChainsawCutState.IDLE then\n        spec.crosshair:render()\n    end\nend\n\n"})}),"\n",(0,a.jsx)(n.h3,{id:"onheldend",children:"onHeldEnd"}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Description"})}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Definition"})}),"\n",(0,a.jsxs)(n.blockquote,{children:["\n",(0,a.jsx)(n.p,{children:"onHeldEnd()"}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Code"})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-lua",children:"function HandToolChainsaw:onHeldEnd()\n    local spec = self.spec_chainsaw\n    local carryingPlayer = self:getCarryingPlayer()\n    if carryingPlayer ~ = nil then\n        if carryingPlayer.isOwner then\n            carryingPlayer.targeter:removeTargetType( HandToolChainsaw )\n        end\n\n        if spec.playerWorkStylePreset ~ = nil then\n            carryingPlayer:applyCustomWorkStyle( nil )\n            carryingPlayer:setIsHoldingChainsaw( false )\n        end\n    end\n\n    -- Stop whatever the player is doing.\n    if spec.currentCutState = = ChainsawCutState.DELIMBING then\n        self:stopDelimbing()\n    elseif spec.currentCutState = = ChainsawCutState.CUTTING then\n            self:stopCutting( false )\n        end\n\n        g_animationManager:stopAnimations(spec.chainsAnimation)\n        spec.isPlayingChainAnimation = false\n\n        if spec.ringNode ~ = nil then\n            setVisibility(spec.ringNode, false )\n        end\n\n        spec.rollInput = 0\n    end\n\n"})}),"\n",(0,a.jsx)(n.h3,{id:"onheldstart",children:"onHeldStart"}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Description"})}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Definition"})}),"\n",(0,a.jsxs)(n.blockquote,{children:["\n",(0,a.jsx)(n.p,{children:"onHeldStart()"}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Code"})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-lua",children:"function HandToolChainsaw:onHeldStart()\n    local carryingPlayer = self:getCarryingPlayer()\n\n    if carryingPlayer ~ = nil then\n        -- Ensure trees are targeted.\n        if carryingPlayer.isOwner then\n            local targeter = carryingPlayer.targeter\n            targeter:addTargetType( HandToolChainsaw , HandToolChainsaw.TARGET_MASK, HandToolChainsaw.MINIMUM_CUT_DISTANCE, HandToolChainsaw.MAXIMUM_CUT_DISTANCE)\n            targeter:addFilterToTargetType( HandToolChainsaw , function (hitNode, x, y, z)\n                return hitNode ~ = nil and hitNode ~ = 0 and getHasClassId(hitNode, ClassIds.MESH_SPLIT_SHAPE)\n            end )\n        else\n                setTranslation( self.graphicalNode, 0 , 0 , 0 )\n                setRotation( self.graphicalNode, 0 , 0 , 0 )\n            end\n\n            local spec = self.spec_chainsaw\n            if spec.playerWorkStylePreset ~ = nil then\n                carryingPlayer:applyCustomWorkStyle(spec.playerWorkStylePreset)\n                carryingPlayer:setIsHoldingChainsaw( true )\n            end\n        end\n    end\n\n"})}),"\n",(0,a.jsx)(n.h3,{id:"onload",children:"onLoad"}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Description"})}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Definition"})}),"\n",(0,a.jsxs)(n.blockquote,{children:["\n",(0,a.jsx)(n.p,{children:"onLoad()"}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,a.jsxs)(n.table,{children:[(0,a.jsx)(n.thead,{children:(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.th,{children:"any"}),(0,a.jsx)(n.th,{children:"xmlFile"})]})}),(0,a.jsx)(n.tbody,{children:(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:"any"}),(0,a.jsx)(n.td,{children:"baseDirectory"})]})})]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Code"})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-lua",children:'function HandToolChainsaw:onLoad(xmlFile, baseDirectory)\n\n    local spec = self.spec_chainsaw\n\n    if HandToolChainsaw.WORLD_POSITION_COMPRESSION_PARAMS_XZ = = nil then\n        -- Accurate to 1cm with a 10m overlap.\n        local mission = g_currentMission\n        HandToolChainsaw.WORLD_POSITION_COMPRESSION_PARAMS_XZ = NetworkUtil.createWorldPositionCompressionParams(mission.terrainSize + 10 , 0.5 * (mission.terrainSize + 10 ), 0.01 )\n        HandToolChainsaw.WORLD_POSITION_COMPRESSION_PARAMS_Y = NetworkUtil.createWorldPositionCompressionParams( 1500 , 0 , 0.01 )\n    end\n\n    spec.dirtyFlag = self:getNextDirtyFlag()\n\n    spec.revText = g_i18n:getText( "action_revHandToolMotor" )\n    spec.cutText = g_i18n:getText( "action_startCuttingChainsaw" )\n    spec.rollText = g_i18n:getText( "action_rollChainsaw" )\n\n    -- Start the chainsaw in idle mode.\n    spec.currentCutState = ChainsawCutState.IDLE\n    spec.currentCutStateSent = spec.currentCutState\n    spec.isVerticalCut = true\n    spec.removedAttachmentsSent = false\n\n    spec.targetedTree = nil\n    spec.cuttingTreeNode = nil\n\n    spec.currentCutRoll = 0\n    spec.rollInput = 0\n\n    spec.isCutting = false\n\n    spec.cutMinimumY, spec.cutMaximumY, spec.cutMinimumZ, spec.cutMaximumZ = nil , nil , nil , nil\n    spec.cutStartPositionX, spec.cutStartPositionY, spec.cutStartPositionZ = 0 , 0 , 0\n    spec.cutEndPositionX, spec.cutEndPositionY, spec.cutEndPositionZ = 0 , 0 , 0\n\n    -- The curve used to animate the cutting animation, to appear as if the thickest part of the log takes longer to cut.\n        spec.smoothingCurve = BezierCurve.new( 0.11 , 0.54 , 0.91 , 0.5 )\n\n        spec.playerWorkStylePreset = xmlFile:getValue( "handTool.chainsaw.playerWorkStylePreset" )\n\n        spec.maximumDelimbDiameter = xmlFile:getValue( "handTool.chainsaw#maximumDelimbDiameter" , 1 )\n        spec.maximumCutDiameter = xmlFile:getValue( "handTool.chainsaw#maximumCutDiameter" , 1 )\n        spec.cutTimePerSquareMeter = xmlFile:getValue( "handTool.chainsaw#cutTimePerSquareMeter" , 1 ) * 1000\n        spec.currentCutTime = 0\n        spec.currentTargetCutTime = 0\n        spec.currentTargetStartupTime = 0\n        spec.startupTime = 1000\n\n        spec.cutNode = xmlFile:getValue( "handTool.chainsaw.cutNode#node" , nil , self.components, self.i3dMappings)\n        if spec.cutNode = = nil then\n            Logging.xmlWarning(xmlFile, "Chainsaw is missing cut node, root node will be used instead!" )\n            spec.cutNode = self.rootNode\n        end\n\n        spec.handNodeCutting = xmlFile:getValue( "handTool.chainsaw.handNode#cutting" , nil , self.components, self.i3dMappings)\n        spec.handNodeWalking = xmlFile:getValue( "handTool.chainsaw.handNode#walking" , nil , self.components, self.i3dMappings)\n\n        -- Get the filename for the target ring.\n            local ringI3DFilename = xmlFile:getValue( "handTool.chainsaw.ringSelector#filename" , nil )\n            if ringI3DFilename ~ = nil then\n                -- Begin loading the target ring.\n                ringI3DFilename = Utils.getFilename(ringI3DFilename, self.baseDirectory)\n                spec.ringSharedLoadRequestId = g_i3DManager:loadSharedI3DFileAsync(ringI3DFilename, true , false , HandToolChainsaw.onRingLoadFinished, self , nil )\n                spec.ringLoadingTask = self:createLoadingTask(spec)\n\n                -- Get the ring\'s scale offset.\n                spec.ringScaleOffset = xmlFile:getValue( "handTool.chainsaw.ringSelector#scaleOffset" , 0 )\n            end\n\n            -- Create the cut guide node.This interpolates between the start and end of a cut so that the chainsaw can position onto it.\n            spec.cutGuideNode = createTransformGroup( "chainsawCutGuideNode" )\n            link(getRootNode(), spec.cutGuideNode)\n\n            -- Create the rotation node.This follows the rotation of the player\'s camera so that the ring indicator is always relative to it.\n            spec.cameraRotationNode = createTransformGroup( "chainsawCameraRotationNode" )\n            link(getRootNode(), spec.cameraRotationNode)\n\n            -- Create the split plane node.This is attached to the rotation node and specifies the start of the split plane.\n            spec.splitPlaneNode = createTransformGroup( "chainsawSplitPlaneNode" )\n            link(spec.cameraRotationNode, spec.splitPlaneNode)\n            setRotation(spec.splitPlaneNode, 0 , 0 , - math.pi * 0.5 )\n            setTranslation(spec.splitPlaneNode, - 0.1 , spec.maximumCutDiameter / 2 , HandToolChainsaw.SPLIT_PLANE_OFFSET_Z)\n\n            if self.isClient then\n                spec.effectEndTime = 0\n                spec.isPlayingEffects = false\n                spec.effects = g_effectManager:loadEffect(xmlFile, "handTool.chainsaw.effects" , self.components, self , self.i3dMappings)\n                g_effectManager:setEffectTypeInfo(spec.effects, FillType.WOOD)\n\n                spec.isPlayingChainAnimation = false\n                spec.chainsAnimation = g_animationManager:loadAnimations(xmlFile, "handTool.chainsaw.chain" , self.components, spec, self.i3dMappings)\n\n                for i,animation in ipairs(spec.chainsAnimation) do\n                    spec.startupTime = math.max(spec.startupTime, animation.turnOnFadeTime)\n                end\n\n                spec.cutSamples = g_soundManager:loadSamplesFromXML(xmlFile, "handTool.chainsaw.sounds" , "cut" , baseDirectory, self.components, 0 , AudioGroup.VEHICLE, self.i3dMappings, self )\n            end\n\n            spec.delimbEffectDuration = 100\n\n            spec.lastDelimbPosX = 0\n            spec.lastDelimbPosY = 0\n            spec.lastDelimbPosZ = 0\n            spec.lastDelimbNormalX = 1\n            spec.lastDelimbNormalY = 0\n            spec.lastDelimbNormalZ = 0\n            spec.lastDelimbUpX = 0\n            spec.lastDelimbUpY = 1\n            spec.lastDelimbUpZ = 0\n\n            if self.isClient then\n                spec.crosshair = self:createCrosshairOverlay( "gui.crosshairDefault" )\n            end\n\n            -- force walk speed to 0.5 to match chainsaw walk animation\n            self.walkMultiplier = 0.5\n        end\n\n'})}),"\n",(0,a.jsx)(n.h3,{id:"onpostload",children:"onPostLoad"}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Description"})}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Definition"})}),"\n",(0,a.jsxs)(n.blockquote,{children:["\n",(0,a.jsx)(n.p,{children:"onPostLoad()"}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,a.jsx)(n.table,{children:(0,a.jsx)(n.thead,{children:(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.th,{children:"any"}),(0,a.jsx)(n.th,{children:"savegame"})]})})}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Code"})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-lua",children:"function HandToolChainsaw:onPostLoad(savegame)\n\n    local spec = self.spec_chainsaw\n    local motorizedSpec = self.spec_motorized\n\n    -- Set the RPM stats based on the motor.\n    self:setRPMGainPerSecond((motorizedSpec.maxRPM - motorizedSpec.minRPM) / (spec.startupTime * 0.001 ))\n    self:setRPMLossPerSecond(((motorizedSpec.maxRPM - motorizedSpec.minRPM) / (spec.startupTime * 0.001 )) * 1.2 )\nend\n\n"})}),"\n",(0,a.jsx)(n.h3,{id:"onreadupdatestream",children:"onReadUpdateStream"}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Description"})}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Definition"})}),"\n",(0,a.jsxs)(n.blockquote,{children:["\n",(0,a.jsx)(n.p,{children:"onReadUpdateStream()"}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,a.jsxs)(n.table,{children:[(0,a.jsx)(n.thead,{children:(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.th,{children:"any"}),(0,a.jsx)(n.th,{children:"streamId"})]})}),(0,a.jsxs)(n.tbody,{children:[(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:"any"}),(0,a.jsx)(n.td,{children:"timestamp"})]}),(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:"any"}),(0,a.jsx)(n.td,{children:"connection"})]})]})]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Code"})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-lua",children:"function HandToolChainsaw:onReadUpdateStream(streamId, timestamp, connection)\n    local spec = self.spec_chainsaw\n    local carryingPlayer = self:getCarryingPlayer()\n\n    if streamReadBool(streamId) then\n        local receivedState = ChainsawCutState.readStream(streamId)\n        local isVerticalCut = true\n        if receivedState = = ChainsawCutState.CUTTING then\n            isVerticalCut = streamReadBool(streamId)\n        end\n        -- only change the cut state on other players\n        if carryingPlayer = = nil or not carryingPlayer.isOwner then\n            self:setCurrentCutState(receivedState, isVerticalCut)\n        end\n\n        if not connection:getIsServer() then\n            if receivedState = = ChainsawCutState.DELIMBING then\n                spec.lastDelimbPosX = NetworkUtil.readCompressedWorldPosition(streamId, HandToolChainsaw.WORLD_POSITION_COMPRESSION_PARAMS_XZ)\n                spec.lastDelimbPosY = NetworkUtil.readCompressedWorldPosition(streamId, HandToolChainsaw.WORLD_POSITION_COMPRESSION_PARAMS_Y)\n                spec.lastDelimbPosZ = NetworkUtil.readCompressedWorldPosition(streamId, HandToolChainsaw.WORLD_POSITION_COMPRESSION_PARAMS_XZ)\n                spec.lastDelimbNormalX = NetworkUtil.readCompressedRange(streamId, - 1 , 1 , 12 )\n                spec.lastDelimbNormalY = NetworkUtil.readCompressedRange(streamId, - 1 , 1 , 12 )\n                spec.lastDelimbNormalZ = NetworkUtil.readCompressedRange(streamId, - 1 , 1 , 12 )\n                spec.lastDelimbUpX = NetworkUtil.readCompressedRange(streamId, - 1 , 1 , 12 )\n                spec.lastDelimbUpY = NetworkUtil.readCompressedRange(streamId, - 1 , 1 , 12 )\n                spec.lastDelimbUpZ = NetworkUtil.readCompressedRange(streamId, - 1 , 1 , 12 )\n            end\n        else\n                local removedAttachment = streamReadBool(streamId)\n                if removedAttachment then\n                    if carryingPlayer ~ = nil and carryingPlayer.isOwner then\n                        spec.effectEndTime = g_ time + spec.delimbEffectDuration\n                    end\n                end\n            end\n        end\n    end\n\n"})}),"\n",(0,a.jsx)(n.h3,{id:"onregisteractionevents",children:"onRegisterActionEvents"}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Description"})}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Definition"})}),"\n",(0,a.jsxs)(n.blockquote,{children:["\n",(0,a.jsx)(n.p,{children:"onRegisterActionEvents()"}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Code"})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-lua",children:"function HandToolChainsaw:onRegisterActionEvents()\n    local spec = self.spec_chainsaw\n\n    if not self:getIsActiveForInput( true ) then\n        return\n    end\n\n    local _, actionEventId = self:addActionEvent(InputAction.AXIS_ROTATE_HANDTOOL, self , HandToolChainsaw.onRollAction, false , false , true , true , nil )\n    g_inputBinding:setActionEventTextPriority(actionEventId, GS_PRIO_VERY_HIGH)\n    g_inputBinding:setActionEventText(actionEventId, string.format(spec.rollText, self.typeDesc))\n\n    _, actionEventId = self:addActionEvent(InputAction.ACTIVATE_HANDTOOL, self , HandToolChainsaw.onCutAction, true , true , false , true , nil )\n    spec.activateActionId = actionEventId\n    g_inputBinding:setActionEventTextPriority(actionEventId, GS_PRIO_VERY_HIGH)\n    g_inputBinding:setActionEventText(actionEventId, string.format(spec.revText, self.typeDesc))\nend\n\n"})}),"\n",(0,a.jsx)(n.h3,{id:"onringloadfinished",children:"onRingLoadFinished"}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Description"})}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Definition"})}),"\n",(0,a.jsxs)(n.blockquote,{children:["\n",(0,a.jsx)(n.p,{children:"onRingLoadFinished()"}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,a.jsxs)(n.table,{children:[(0,a.jsx)(n.thead,{children:(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.th,{children:"any"}),(0,a.jsx)(n.th,{children:"ringNode"})]})}),(0,a.jsx)(n.tbody,{children:(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:"any"}),(0,a.jsx)(n.td,{children:"failedReason"})]})})]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Code"})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-lua",children:'function HandToolChainsaw:onRingLoadFinished(ringNode, failedReason)\n    local spec = self.spec_chainsaw\n    -- Finish the loading.\n    self:finishLoadingTask(spec.ringLoadingTask)\n    spec.ringLoadingTask = nil\n\n    if ringNode = = nil or ringNode = = 0 then\n        Logging.error( "Chainsaw could not load ring indicator i3d!" )\n        return\n    end\n\n    spec.ringNode = getChildAt(ringNode, 0 )\n    setVisibility(spec.ringNode, false )\n    link(spec.cameraRotationNode, spec.ringNode)\n\n    delete(ringNode)\nend\n\n'})}),"\n",(0,a.jsx)(n.h3,{id:"onrollaction",children:"onRollAction"}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Description"})}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Definition"})}),"\n",(0,a.jsxs)(n.blockquote,{children:["\n",(0,a.jsx)(n.p,{children:"onRollAction()"}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,a.jsxs)(n.table,{children:[(0,a.jsx)(n.thead,{children:(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.th,{children:"any"}),(0,a.jsx)(n.th,{children:"_"})]})}),(0,a.jsx)(n.tbody,{children:(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:"any"}),(0,a.jsx)(n.td,{children:"inputDelta"})]})})]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Code"})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-lua",children:"function HandToolChainsaw:onRollAction(_, inputDelta)\n    local spec = self.spec_chainsaw\n    spec.rollInput = spec.rollInput + inputDelta\nend\n\n"})}),"\n",(0,a.jsx)(n.h3,{id:"onupdate",children:"onUpdate"}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Description"})}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Definition"})}),"\n",(0,a.jsxs)(n.blockquote,{children:["\n",(0,a.jsx)(n.p,{children:"onUpdate()"}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,a.jsx)(n.table,{children:(0,a.jsx)(n.thead,{children:(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.th,{children:"any"}),(0,a.jsx)(n.th,{children:"dt"})]})})}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Code"})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-lua",children:"function HandToolChainsaw:onUpdate(dt)\n    local spec = self.spec_chainsaw\n\n    local carryingPlayer = self:getCarryingPlayer()\n    if carryingPlayer = = nil then\n        return\n    end\n\n    -- If the carrying player is the owner, update the chainsaw as the owner player and do nothing more.\n        if carryingPlayer.isOwner then\n            if self:getIsHeld() then\n                -- Get the tree being aimed at and update the split plane accordingly.\n                spec.targetedTree = self:getCarryingPlayer().targeter.closestTargetsByKey[ HandToolChainsaw ]\n                spec.possibleTreeNode = nil\n\n                self:updateSplitPlane()\n\n                -- Handle roll input, as long as the player is not currently cutting.\n                if spec.currentCutState ~ = ChainsawCutState.CUTTING then\n                    if spec.rollInput ~ = 0 then\n                        spec.currentCutRoll = math.clamp(spec.currentCutRoll + ( HandToolChainsaw.ROTATION_SPEED * spec.rollInput * dt), - math.pi * 0.5 , math.pi * 0.5 )\n                        spec.rollInput = 0\n                    end\n\n                    -- Update the graphical rotation.\n                    if self.graphicalNode ~ = nil then\n                        local upX, upY, upZ = localDirectionToLocal(spec.cameraRotationNode, getParent( self.graphicalNode), 0 , 1 , 0 )\n                        local cameraNode = g_cameraManager:getActiveCamera()\n                        local dirX, dirY, dirZ = localDirectionToLocal(cameraNode, getParent( self.graphicalNode), 0 , 0 , - 1 )\n                        setDirection( self.graphicalNode, dirX, dirY, dirZ, upX, upY, upZ)\n                    end\n                end\n\n                local isCutPossible = false\n                if spec.currentCutState = = ChainsawCutState.IDLE or spec.currentCutState = = ChainsawCutState.CUTTING then\n                    local treeNode = spec.cuttingTreeNode\n                    if treeNode = = nil and spec.targetedTree ~ = nil then\n                        treeNode = spec.targetedTree.node\n                    end\n\n                    if treeNode ~ = nil then\n                        local cutX, _, cutZ = getWorldTranslation(spec.cameraRotationNode)\n                        if not self:testIfCutValid(treeNode, cutX, cutZ, spec.cutMinimumY, spec.cutMaximumY, spec.cutMinimumZ, spec.cutMaximumZ) then\n                            if spec.cuttingTreeNode ~ = nil then\n                                self:stopCutting( false )\n                            end\n                        else\n                                if spec.cuttingTreeNode = = nil then\n                                    spec.possibleTreeNode = treeNode\n                                end\n                                isCutPossible = true\n                            end\n                        end\n                    end\n\n                    -- If the player is not actively using the chainsaw, update the ring selector.\n                    if spec.currentCutState = = ChainsawCutState.IDLE then\n                        if isCutPossible then\n                            g_inputBinding:setActionEventText(spec.activateActionId, spec.cutText)\n                        else\n                                g_inputBinding:setActionEventText(spec.activateActionId, string.format(spec.revText, self.typeDesc))\n                            end\n                            g_inputBinding:setActionEventTextVisibility(spec.activateActionId, true )\n\n                            self:updateRingSelector(spec.targetedTree, isCutPossible, spec.cutMinimumY, spec.cutMaximumY, spec.cutMinimumZ, spec.cutMaximumZ)\n\n                        elseif spec.currentCutState = = ChainsawCutState.CUTTING then\n                                g_inputBinding:setActionEventTextVisibility(spec.activateActionId, false )\n                                self:updateCutting(dt)\n                            end\n                        end\n                    end\n\n                    if spec.currentCutState = = ChainsawCutState.DELIMBING then\n                        if carryingPlayer.isOwner then\n                            local x, y, z, normalX, normalY, normalZ, upX, upY, upZ = self:calculateCutPlane()\n\n                            spec.lastDelimbPosX = x\n                            spec.lastDelimbPosY = y\n                            spec.lastDelimbPosZ = z\n                            spec.lastDelimbNormalX = normalX\n                            spec.lastDelimbNormalY = normalY\n                            spec.lastDelimbNormalZ = normalZ\n                            spec.lastDelimbUpX = upX\n                            spec.lastDelimbUpY = upY\n                            spec.lastDelimbUpZ = upZ\n\n                            self:raiseDirtyFlags(spec.dirtyFlag)\n                        end\n\n                        if self.isServer then\n                            local x = spec.lastDelimbPosX\n                            local y = spec.lastDelimbPosY\n                            local z = spec.lastDelimbPosZ\n                            local normalX = spec.lastDelimbNormalX\n                            local normalY = spec.lastDelimbNormalY\n                            local normalZ = spec.lastDelimbNormalZ\n                            local upX = spec.lastDelimbUpX\n                            local upY = spec.lastDelimbUpY\n                            local upZ = spec.lastDelimbUpZ\n\n                            local planeWidth = spec.maximumDelimbDiameter\n                            local planeDepth = spec.maximumDelimbDiameter + HandToolChainsaw.SPLIT_PLANE_OFFSET_Z\n                            local removedAttachment = findAndRemoveSplitShapeAttachments(x, y, z, normalX, normalY, normalZ, upX, upY, upZ, 0.7 , planeWidth, planeDepth)\n\n                            if spec.removedAttachmentsSent ~ = removedAttachment then\n                                spec.removedAttachmentsSent = removedAttachment\n                                self:raiseDirtyFlags(spec.dirtyFlag)\n                            end\n\n                            if removedAttachment then\n                                spec.effectEndTime = g_ time + spec.delimbEffectDuration\n                            end\n                        end\n                    end\n\n                    if self.isClient then\n                        if spec.effectEndTime > g_ time then\n                            if not spec.isPlayingEffects then\n                                g_effectManager:startEffects(spec.effects)\n                                g_soundManager:playSamples(spec.cutSamples)\n                                spec.isPlayingEffects = true\n                            end\n                        else\n                                if spec.isPlayingEffects then\n                                    g_effectManager:stopEffects(spec.effects)\n                                    g_soundManager:stopSamples(spec.cutSamples)\n                                    spec.isPlayingEffects = false\n                                end\n                            end\n\n                            if self:getCurrentRPM() > self:getMinRPM() then\n                                if not spec.isPlayingChainAnimation then\n                                    g_animationManager:startAnimations(spec.chainsAnimation)\n                                    spec.isPlayingChainAnimation = true\n                                end\n                            else\n                                    if spec.isPlayingChainAnimation then\n                                        g_animationManager:stopAnimations(spec.chainsAnimation)\n                                        spec.isPlayingChainAnimation = false\n                                    end\n                                end\n                            end\n                        end\n\n"})}),"\n",(0,a.jsx)(n.h3,{id:"onwriteupdatestream",children:"onWriteUpdateStream"}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Description"})}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Definition"})}),"\n",(0,a.jsxs)(n.blockquote,{children:["\n",(0,a.jsx)(n.p,{children:"onWriteUpdateStream()"}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,a.jsxs)(n.table,{children:[(0,a.jsx)(n.thead,{children:(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.th,{children:"any"}),(0,a.jsx)(n.th,{children:"streamId"})]})}),(0,a.jsxs)(n.tbody,{children:[(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:"any"}),(0,a.jsx)(n.td,{children:"connection"})]}),(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:"any"}),(0,a.jsx)(n.td,{children:"dirtyMask"})]})]})]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Code"})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-lua",children:"function HandToolChainsaw:onWriteUpdateStream(streamId, connection, dirtyMask)\n    local spec = self.spec_chainsaw\n\n    if streamWriteBool(streamId, bit32.band(dirtyMask, spec.dirtyFlag) ~ = 0 ) then\n        ChainsawCutState.writeStream(streamId, spec.currentCutStateSent)\n        if spec.currentCutStateSent = = ChainsawCutState.CUTTING then\n            streamWriteBool(streamId, spec.isVerticalCut)\n        end\n\n        if connection:getIsServer() then\n            if spec.currentCutStateSent = = ChainsawCutState.DELIMBING then\n                NetworkUtil.writeCompressedWorldPosition(streamId, spec.lastDelimbPosX, HandToolChainsaw.WORLD_POSITION_COMPRESSION_PARAMS_XZ)\n                NetworkUtil.writeCompressedWorldPosition(streamId, spec.lastDelimbPosY, HandToolChainsaw.WORLD_POSITION_COMPRESSION_PARAMS_Y)\n                NetworkUtil.writeCompressedWorldPosition(streamId, spec.lastDelimbPosZ, HandToolChainsaw.WORLD_POSITION_COMPRESSION_PARAMS_XZ)\n\n                NetworkUtil.writeCompressedRange(streamId, spec.lastDelimbNormalX, - 1 , 1 , 12 )\n                NetworkUtil.writeCompressedRange(streamId, spec.lastDelimbNormalY, - 1 , 1 , 12 )\n                NetworkUtil.writeCompressedRange(streamId, spec.lastDelimbNormalZ, - 1 , 1 , 12 )\n                NetworkUtil.writeCompressedRange(streamId, spec.lastDelimbUpX, - 1 , 1 , 12 )\n                NetworkUtil.writeCompressedRange(streamId, spec.lastDelimbUpY, - 1 , 1 , 12 )\n                NetworkUtil.writeCompressedRange(streamId, spec.lastDelimbUpZ, - 1 , 1 , 12 )\n            end\n        else\n                streamWriteBool(streamId, spec.removedAttachmentsSent)\n            end\n        end\n    end\n\n"})}),"\n",(0,a.jsx)(n.h3,{id:"prerequisitespresent",children:"prerequisitesPresent"}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Description"})}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Definition"})}),"\n",(0,a.jsxs)(n.blockquote,{children:["\n",(0,a.jsx)(n.p,{children:"prerequisitesPresent()"}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,a.jsx)(n.table,{children:(0,a.jsx)(n.thead,{children:(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.th,{children:"any"}),(0,a.jsx)(n.th,{children:"specializations"})]})})}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Code"})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-lua",children:"function HandToolChainsaw.prerequisitesPresent(specializations)\n    return SpecializationUtil.hasSpecialization( HandToolMotorized , specializations)\nend\n\n"})}),"\n",(0,a.jsx)(n.h3,{id:"registereventlisteners",children:"registerEventListeners"}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Description"})}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Definition"})}),"\n",(0,a.jsxs)(n.blockquote,{children:["\n",(0,a.jsx)(n.p,{children:"registerEventListeners()"}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,a.jsx)(n.table,{children:(0,a.jsx)(n.thead,{children:(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.th,{children:"any"}),(0,a.jsx)(n.th,{children:"handToolType"})]})})}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Code"})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-lua",children:'function HandToolChainsaw.registerEventListeners(handToolType)\n    SpecializationUtil.registerEventListener(handToolType, "onDelete" , HandToolChainsaw )\n    SpecializationUtil.registerEventListener(handToolType, "onLoad" , HandToolChainsaw )\n    SpecializationUtil.registerEventListener(handToolType, "onPostLoad" , HandToolChainsaw )\n    SpecializationUtil.registerEventListener(handToolType, "onUpdate" , HandToolChainsaw )\n    SpecializationUtil.registerEventListener(handToolType, "onDraw" , HandToolChainsaw )\n    SpecializationUtil.registerEventListener(handToolType, "onWriteUpdateStream" , HandToolChainsaw )\n    SpecializationUtil.registerEventListener(handToolType, "onReadUpdateStream" , HandToolChainsaw )\n    SpecializationUtil.registerEventListener(handToolType, "onHeldStart" , HandToolChainsaw )\n    SpecializationUtil.registerEventListener(handToolType, "onHeldEnd" , HandToolChainsaw )\n    SpecializationUtil.registerEventListener(handToolType, "onRegisterActionEvents" , HandToolChainsaw )\nend\n\n'})}),"\n",(0,a.jsx)(n.h3,{id:"registerfunctions",children:"registerFunctions"}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Description"})}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Definition"})}),"\n",(0,a.jsxs)(n.blockquote,{children:["\n",(0,a.jsx)(n.p,{children:"registerFunctions()"}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,a.jsx)(n.table,{children:(0,a.jsx)(n.thead,{children:(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.th,{children:"any"}),(0,a.jsx)(n.th,{children:"handToolType"})]})})}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Code"})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-lua",children:'function HandToolChainsaw.registerFunctions(handToolType)\n    SpecializationUtil.registerFunction(handToolType, "calculateCutPlane" , HandToolChainsaw.calculateCutPlane)\n    SpecializationUtil.registerFunction(handToolType, "getChainSpeedFactor" , HandToolChainsaw.getChainSpeedFactor)\n    SpecializationUtil.registerFunction(handToolType, "testIfTooLow" , HandToolChainsaw.testIfTooLow)\n    SpecializationUtil.registerFunction(handToolType, "testIfCutAllowed" , HandToolChainsaw.testIfCutAllowed)\n    SpecializationUtil.registerFunction(handToolType, "testIfCutValid" , HandToolChainsaw.testIfCutValid)\n    SpecializationUtil.registerFunction(handToolType, "beginCutting" , HandToolChainsaw.beginCutting)\n    SpecializationUtil.registerFunction(handToolType, "stopCutting" , HandToolChainsaw.stopCutting)\n    SpecializationUtil.registerFunction(handToolType, "beginDelimbing" , HandToolChainsaw.beginDelimbing)\n    SpecializationUtil.registerFunction(handToolType, "stopDelimbing" , HandToolChainsaw.stopDelimbing)\n    SpecializationUtil.registerFunction(handToolType, "setCurrentCutState" , HandToolChainsaw.setCurrentCutState)\n    SpecializationUtil.registerFunction(handToolType, "updateCutting" , HandToolChainsaw.updateCutting)\n    SpecializationUtil.registerFunction(handToolType, "updateCuttingAnimation" , HandToolChainsaw.updateCuttingAnimation)\n    SpecializationUtil.registerFunction(handToolType, "updateSplitPlane" , HandToolChainsaw.updateSplitPlane)\n    SpecializationUtil.registerFunction(handToolType, "updateRingSelector" , HandToolChainsaw.updateRingSelector)\nend\n\n'})}),"\n",(0,a.jsx)(n.h3,{id:"registerxmlpaths",children:"registerXMLPaths"}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Description"})}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Definition"})}),"\n",(0,a.jsxs)(n.blockquote,{children:["\n",(0,a.jsx)(n.p,{children:"registerXMLPaths()"}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,a.jsx)(n.table,{children:(0,a.jsx)(n.thead,{children:(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.th,{children:"any"}),(0,a.jsx)(n.th,{children:"xmlSchema"})]})})}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Code"})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-lua",children:'function HandToolChainsaw.registerXMLPaths(xmlSchema)\n    xmlSchema:setXMLSpecializationType( "HandToolChainsaw" )\n    xmlSchema:register(XMLValueType.STRING, "handTool.chainsaw.playerWorkStylePreset" , "Name of the style preset" , nil , false )\n    xmlSchema:register(XMLValueType.FLOAT, "handTool.chainsaw#maximumCutDiameter" , "The maximum diameter in metres that can be cut" , 1 , false )\n    xmlSchema:register(XMLValueType.FLOAT, "handTool.chainsaw#maximumDelimbDiameter" , "The maximum diameter range in metres that is used for delimb" , 1 , false )\n        xmlSchema:register(XMLValueType.FLOAT, "handTool.chainsaw#cutTimePerSquareMeter" , "The time in seconds per square metre that the chainsaw takes to cut" , 1 , false )\n        xmlSchema:register(XMLValueType.STRING, "handTool.chainsaw.ringSelector#filename" , "The path of the ring selector i3d file" , nil , true )\n        xmlSchema:register(XMLValueType.FLOAT, "handTool.chainsaw.ringSelector#scaleOffset" , "The size in metres added onto the ring indicator\'s scale" , 0 , false )\n        xmlSchema:register(XMLValueType.NODE_INDEX, "handTool.chainsaw.cutNode#node" , "The name of the node used to position the chainsaw while cutting" , nil , false )\n            xmlSchema:register(XMLValueType.NODE_INDEX, "handTool.chainsaw.handNode#cutting" , "The name of the node used to position the chainsaw while cutting" , nil , false )\n                xmlSchema:register(XMLValueType.NODE_INDEX, "handTool.chainsaw.handNode#walking" , "The name of the node used to position the chainsaw while walking" , nil , false )\n                    AnimationManager.registerAnimationNodesXMLPaths(xmlSchema, "handTool.chainsaw.chain" )\n                    EffectManager.registerEffectXMLPaths(xmlSchema, "handTool.chainsaw.effects" )\n                    SoundManager.registerSampleXMLPaths(xmlSchema, "handTool.chainsaw.sounds" , "cut(?)" )\n                end\n\n'})}),"\n",(0,a.jsx)(n.h3,{id:"setcurrentcutstate",children:"setCurrentCutState"}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Description"})}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Definition"})}),"\n",(0,a.jsxs)(n.blockquote,{children:["\n",(0,a.jsx)(n.p,{children:"setCurrentCutState()"}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,a.jsxs)(n.table,{children:[(0,a.jsx)(n.thead,{children:(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.th,{children:"any"}),(0,a.jsx)(n.th,{children:"cutState"})]})}),(0,a.jsx)(n.tbody,{children:(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:"any"}),(0,a.jsx)(n.td,{children:"isVerticalCut"})]})})]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Code"})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-lua",children:"function HandToolChainsaw:setCurrentCutState(cutState, isVerticalCut)\n    local spec = self.spec_chainsaw\n\n    spec.currentCutState = cutState\n    spec.isVerticalCut = isVerticalCut\n\n    local carryingPlayer = self:getCarryingPlayer()\n\n    if self.isServer or(carryingPlayer ~ = nil and carryingPlayer.isOwner) then\n        spec.currentCutStateSent = spec.currentCutState\n        self:raiseDirtyFlags(spec.dirtyFlag)\n    end\n\n    if carryingPlayer ~ = nil then\n        carryingPlayer:setChainsawState(cutState = = ChainsawCutState.CUTTING, isVerticalCut)\n    end\nend\n\n"})}),"\n",(0,a.jsx)(n.h3,{id:"stopcutting",children:"stopCutting"}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Description"})}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Definition"})}),"\n",(0,a.jsxs)(n.blockquote,{children:["\n",(0,a.jsx)(n.p,{children:"stopCutting()"}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,a.jsx)(n.table,{children:(0,a.jsx)(n.thead,{children:(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.th,{children:"any"}),(0,a.jsx)(n.th,{children:"sliceTree"})]})})}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Code"})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-lua",children:"function HandToolChainsaw:stopCutting(sliceTree)\n    local spec = self.spec_chainsaw\n    local player = self:getCarryingPlayer()\n\n    if player = = nil or not player.isOwner then\n        return\n    end\n\n    -- Reset the tree that is being cut.\n    local cuttingTreeNode = spec.cuttingTreeNode\n    spec.cuttingTreeNode = nil\n\n    self:setCurrentCutState(ChainsawCutState.IDLE, true )\n\n    spec.currentCutTime = 0\n\n    -- Reset the load and RPM.\n    self:setCurrentLoad( 0 )\n    self:setTargetRPMToIdle()\n\n    if player.isOwner then\n        -- Reset the graphical node.\n        link( self.graphicalNodeParent, self.graphicalNode)\n        setTranslation( self.graphicalNode, 0 , 0 , 0 )\n\n        -- Unlock the player's input so they can move and look around.\n        player.inputComponent:unlock()\n    end\n\n    spec.effectEndTime = 0\n\n    -- If the tree should be sliced and there is a tree, slice it.\n    if sliceTree and cuttingTreeNode ~ = nil then\n        local x, y, z, downX, downY, downZ, leftX, leftY, leftZ, planeWidth, planeDepth = self:calculateCutPlane()\n\n        if self.isServer then\n            ChainsawUtil.cutSplitShape(cuttingTreeNode, x, y, z, downX, downY, downZ, leftX, leftY, leftZ, planeWidth, planeDepth, self:getOwnerFarmId())\n        else\n                g_client:getServerConnection():sendEvent( ChainsawCutEvent.new(cuttingTreeNode, x, y, z, downX, downY, downZ, leftX, leftY, leftZ, planeWidth, planeDepth, self:getOwnerFarmId()))\n            end\n        end\n    end\n\n"})}),"\n",(0,a.jsx)(n.h3,{id:"stopdelimbing",children:"stopDelimbing"}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Description"})}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Definition"})}),"\n",(0,a.jsxs)(n.blockquote,{children:["\n",(0,a.jsx)(n.p,{children:"stopDelimbing()"}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Code"})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-lua",children:"function HandToolChainsaw:stopDelimbing()\n    local spec = self.spec_chainsaw\n\n    self:setCurrentCutState(ChainsawCutState.IDLE, true )\n\n    spec.effectEndTime = 0\n\n    -- Reset the load and RPM.\n    self:setCurrentLoad( 0 )\n    self:setTargetRPMToIdle()\nend\n\n"})}),"\n",(0,a.jsx)(n.h3,{id:"testifcutallowed",children:"testIfCutAllowed"}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Description"})}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Definition"})}),"\n",(0,a.jsxs)(n.blockquote,{children:["\n",(0,a.jsx)(n.p,{children:"testIfCutAllowed()"}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,a.jsxs)(n.table,{children:[(0,a.jsx)(n.thead,{children:(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.th,{children:"any"}),(0,a.jsx)(n.th,{children:"treeNode"})]})}),(0,a.jsxs)(n.tbody,{children:[(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:"any"}),(0,a.jsx)(n.td,{children:"cutX"})]}),(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:"any"}),(0,a.jsx)(n.td,{children:"cutZ"})]})]})]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Code"})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-lua",children:"function HandToolChainsaw:testIfCutAllowed(treeNode, cutX, cutZ)\n    local carryingPlayer = self:getCarryingPlayer()\n    if carryingPlayer = = nil then\n        return false\n    end\n\n    local mission = g_currentMission\n    if not mission:getHasPlayerPermission( Farm.PERMISSION.CUT_TREES) then\n        return false\n    end\n\n    if not g_splitShapeManager:getIsShapeCutAllowed(cutX, cutZ, treeNode, carryingPlayer:getFarmId()) then\n        return false\n    end\n\n    return true\nend\n\n"})}),"\n",(0,a.jsx)(n.h3,{id:"testifcutvalid",children:"testIfCutValid"}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Description"})}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Definition"})}),"\n",(0,a.jsxs)(n.blockquote,{children:["\n",(0,a.jsx)(n.p,{children:"testIfCutValid()"}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,a.jsxs)(n.table,{children:[(0,a.jsx)(n.thead,{children:(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.th,{children:"any"}),(0,a.jsx)(n.th,{children:"treeNode"})]})}),(0,a.jsxs)(n.tbody,{children:[(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:"any"}),(0,a.jsx)(n.td,{children:"cutX"})]}),(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:"any"}),(0,a.jsx)(n.td,{children:"cutZ"})]}),(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:"any"}),(0,a.jsx)(n.td,{children:"minY"})]}),(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:"any"}),(0,a.jsx)(n.td,{children:"maxY"})]}),(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:"any"}),(0,a.jsx)(n.td,{children:"minZ"})]}),(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:"any"}),(0,a.jsx)(n.td,{children:"maxZ"})]})]})]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Code"})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-lua",children:"function HandToolChainsaw:testIfCutValid(treeNode, cutX, cutZ, minY, maxY, minZ, maxZ)\n    local spec = self.spec_chainsaw\n\n    if not self:testIfTooLow(treeNode, minY, maxY, minZ, maxZ) then\n        return false\n    end\n\n    -- Test if the given cut is too big.\n        if maxY - minY > = spec.maximumCutDiameter or maxZ - minZ > = spec.maximumCutDiameter then\n            return false\n        end\n\n        return true\n    end\n\n"})}),"\n",(0,a.jsx)(n.h3,{id:"testiftoolow",children:"testIfTooLow"}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Description"})}),"\n",(0,a.jsxs)(n.blockquote,{children:["\n",(0,a.jsx)(n.p,{children:"Using the given tree and given outputs from testSplitShape, determine if the split plane has any corners that are too\nclose to the roots of the tree or the terrain."}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Definition"})}),"\n",(0,a.jsxs)(n.blockquote,{children:["\n",(0,a.jsx)(n.p,{children:"testIfTooLow(integer treeNode, float minY, float maxY, float minZ, float maxZ)"}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,a.jsxs)(n.table,{children:[(0,a.jsx)(n.thead,{children:(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.th,{children:"integer"}),(0,a.jsx)(n.th,{children:"treeNode"}),(0,a.jsx)(n.th,{})]})}),(0,a.jsxs)(n.tbody,{children:[(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:"float"}),(0,a.jsx)(n.td,{children:"minY"}),(0,a.jsx)(n.td,{children:"The minimum y position of the split plane, relative to the split plane. (x in world space)."})]}),(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:"float"}),(0,a.jsx)(n.td,{children:"maxY"}),(0,a.jsx)(n.td,{children:"The maximum y position of the split plane, relative to the split plane. (x in world space)."})]}),(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:"float"}),(0,a.jsx)(n.td,{children:"minZ"}),(0,a.jsx)(n.td,{children:"The minimum z position of the split plane, relative to the split plane. (z in world space)."})]}),(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:"float"}),(0,a.jsx)(n.td,{children:"maxZ"}),(0,a.jsx)(n.td,{children:"The maximum z position of the split plane, relative to the split plane. (z in world space)."})]})]})]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Return Values"})}),"\n\n\n\n\n\n\n\n\n",(0,a.jsx)(n.table,{children:(0,a.jsx)(n.thead,{children:(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.th,{children:"float"}),(0,a.jsx)(n.th,{children:"isValid"}),(0,a.jsx)(n.th,{children:"True if all corners of the split plane are above the roots and terrain thresholds; otherwise false."})]})})}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Code"})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-lua",children:"function HandToolChainsaw:testIfTooLow(treeNode, minY, maxY, minZ, maxZ)\n\n    -- Return false if there is no tree.\n        if treeNode = = nil or treeNode = = 0 or not entityExists(treeNode) then\n            return false\n        end\n\n        -- Return false if the bounds are nil.\n            if minY = = nil or maxY = = nil or minZ = = nil or maxZ = = nil then\n                return false\n            end\n\n            -- If the tree has already been felled and is just being cut up, return true as the height check only applies to rooted trees.\n            if getRigidBodyType(treeNode) ~ = RigidBodyType.STATIC then\n                return true\n            end\n\n            local spec = self.spec_chainsaw\n\n            -- Calculate the position of each corner of the split plane bounds around the tree.\n            local x1, y1, z1 = localToWorld(spec.splitPlaneNode, minY, 0 , minZ)\n            local x2, y2, z2 = localToWorld(spec.splitPlaneNode, minY, 0 , maxZ)\n            local x3, y3, z3 = localToWorld(spec.splitPlaneNode, maxY, 0 , minZ)\n            local x4, y4, z4 = localToWorld(spec.splitPlaneNode, maxY, 0 , maxZ)\n\n            -- Calculate the vertical distance of each corner from the roots of the tree.\n            local _, distanceFromRootsY1 = worldToLocal(treeNode, x1, y1, z1)\n            local _, distanceFromRootsY2 = worldToLocal(treeNode, x2, y2, z2)\n            local _, distanceFromRootsY3 = worldToLocal(treeNode, x3, y3, z3)\n            local _, distanceFromRootsY4 = worldToLocal(treeNode, x4, y4, z4)\n\n            -- Calculate the validity of each root distance.\n            local rootDistanceValid1 = distanceFromRootsY1 > = HandToolChainsaw.ROOTS_HEIGHT_THRESHOLD\n            local rootDistanceValid2 = distanceFromRootsY2 > = HandToolChainsaw.ROOTS_HEIGHT_THRESHOLD\n            local rootDistanceValid3 = distanceFromRootsY3 > = HandToolChainsaw.ROOTS_HEIGHT_THRESHOLD\n            local rootDistanceValid4 = distanceFromRootsY4 > = HandToolChainsaw.ROOTS_HEIGHT_THRESHOLD\n\n            -- Calculate the vertical distance of each corner from the terrain.\n            local distanceFromTerrainY1 = y1 - getTerrainHeightAtWorldPos(g_terrainNode, x1, y1, z1)\n            local distanceFromTerrainY2 = y2 - getTerrainHeightAtWorldPos(g_terrainNode, x2, y2, z2)\n            local distanceFromTerrainY3 = y3 - getTerrainHeightAtWorldPos(g_terrainNode, x3, y3, z3)\n            local distanceFromTerrainY4 = y4 - getTerrainHeightAtWorldPos(g_terrainNode, x4, y4, z4)\n\n            -- Calculate the validity of each terrain distance.\n            local terrainDistanceValid1 = distanceFromTerrainY1 > = HandToolChainsaw.GROUND_DISTANCE_THRESHOLD\n            local terrainDistanceValid2 = distanceFromTerrainY2 > = HandToolChainsaw.GROUND_DISTANCE_THRESHOLD\n            local terrainDistanceValid3 = distanceFromTerrainY3 > = HandToolChainsaw.GROUND_DISTANCE_THRESHOLD\n            local terrainDistanceValid4 = distanceFromTerrainY4 > = HandToolChainsaw.GROUND_DISTANCE_THRESHOLD\n\n            -- If debug info is enabled, draw it.\n            if bit32.band( Player.DEBUG_DISPLAY_FLAG.HANDTOOLS, Player.currentDebugFlag) ~ = 0 then\n\n                -- Draw each corner around the split plane.\n                drawDebugPoint(x1, y1, z1, rootDistanceValid1 and 0 or 1 , rootDistanceValid1 and 1 or 0 , 0 , 1 , true )\n                drawDebugPoint(x2, y2, z2, rootDistanceValid2 and 0 or 1 , rootDistanceValid2 and 1 or 0 , 0 , 1 , true )\n                drawDebugPoint(x3, y3, z3, rootDistanceValid3 and 0 or 1 , rootDistanceValid3 and 1 or 0 , 0 , 1 , true )\n                drawDebugPoint(x4, y4, z4, rootDistanceValid4 and 0 or 1 , rootDistanceValid4 and 1 or 0 , 0 , 1 , true )\n\n                -- Draw lines going from each corner to the root height.\n                drawDebugLine(x1, y1, z1, rootDistanceValid1 and 0 or 1 , rootDistanceValid1 and 1 or 0 , 0 , x1, y1 - (distanceFromRootsY1 + HandToolChainsaw.ROOTS_HEIGHT_THRESHOLD), z1, 1 , 0 , 0 , true )\n                drawDebugLine(x2, y2, z2, rootDistanceValid2 and 0 or 1 , rootDistanceValid2 and 1 or 0 , 0 , x2, y2 - (distanceFromRootsY2 + HandToolChainsaw.ROOTS_HEIGHT_THRESHOLD), z2, 1 , 0 , 0 , true )\n                drawDebugLine(x3, y3, z3, rootDistanceValid3 and 0 or 1 , rootDistanceValid3 and 1 or 0 , 0 , x3, y3 - (distanceFromRootsY3 + HandToolChainsaw.ROOTS_HEIGHT_THRESHOLD), z3, 1 , 0 , 0 , true )\n                drawDebugLine(x4, y4, z4, rootDistanceValid4 and 0 or 1 , rootDistanceValid4 and 1 or 0 , 0 , x4, y4 - (distanceFromRootsY4 + HandToolChainsaw.ROOTS_HEIGHT_THRESHOLD), z4, 1 , 0 , 0 , true )\n\n                -- Draw lines going from each corner to the terrain height.\n                drawDebugLine(x1, y1, z1, terrainDistanceValid1 and 0 or 1 , terrainDistanceValid1 and 1 or 0 , 0 , x1, y1 - (distanceFromTerrainY1 + HandToolChainsaw.GROUND_DISTANCE_THRESHOLD), z1, 1 , 0 , 0 , true )\n                drawDebugLine(x2, y2, z2, terrainDistanceValid2 and 0 or 1 , terrainDistanceValid2 and 1 or 0 , 0 , x2, y2 - (distanceFromTerrainY2 + HandToolChainsaw.GROUND_DISTANCE_THRESHOLD), z2, 1 , 0 , 0 , true )\n                drawDebugLine(x3, y3, z3, terrainDistanceValid3 and 0 or 1 , terrainDistanceValid3 and 1 or 0 , 0 , x3, y3 - (distanceFromTerrainY3 + HandToolChainsaw.GROUND_DISTANCE_THRESHOLD), z3, 1 , 0 , 0 , true )\n                drawDebugLine(x4, y4, z4, terrainDistanceValid4 and 0 or 1 , terrainDistanceValid4 and 1 or 0 , 0 , x4, y4 - (distanceFromTerrainY4 + HandToolChainsaw.GROUND_DISTANCE_THRESHOLD), z4, 1 , 0 , 0 , true )\n            end\n\n            -- The cut is valid if every corner is far enough away from the roots and the terrain.\n                return rootDistanceValid1 and rootDistanceValid2 and rootDistanceValid3 and rootDistanceValid4\n                and terrainDistanceValid1 and terrainDistanceValid2 and terrainDistanceValid3 and terrainDistanceValid4\n            end\n\n"})}),"\n",(0,a.jsx)(n.h3,{id:"updatecutting",children:"updateCutting"}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Description"})}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Definition"})}),"\n",(0,a.jsxs)(n.blockquote,{children:["\n",(0,a.jsx)(n.p,{children:"updateCutting()"}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,a.jsx)(n.table,{children:(0,a.jsx)(n.thead,{children:(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.th,{children:"any"}),(0,a.jsx)(n.th,{children:"dt"})]})})}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Code"})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-lua",children:"function HandToolChainsaw:updateCutting(dt)\n    local spec = self.spec_chainsaw\n\n    local cutPositionX, cutPositionY, cutPositionZ = getWorldTranslation(spec.cameraRotationNode)\n\n    -- Handle getting the player's look position.On the server, this has to be assumed to be at the head, as the player has no targeter.\n    local player = self:getCarryingPlayer()\n\n    local playerTargeter = player.targeter\n    local playerLookX, playerLookY, playerLookZ = playerTargeter.lastRayX, playerTargeter.lastRayY, playerTargeter.lastRayZ\n\n    -- Update the cutting animation, RPM, and cut time.\n    self:updateCuttingAnimation(dt)\n    self:setTargetRPMToMax()\n    spec.currentCutTime = spec.currentCutTime + dt\n\n    -- Calculate the distance of the cut from the player.If it is too far, stop cutting.\n    local cutDistanceFromPlayer = MathUtil.vector3Length(playerLookX - cutPositionX, playerLookY - cutPositionY, playerLookZ - cutPositionZ)\n    if cutDistanceFromPlayer > = HandToolChainsaw.MAXIMUM_CUT_DISTANCE then\n        self:stopCutting( false )\n        return\n    end\n\n    -- If the cut time is past the target time, the cut is done, so stop cutting and slice the tree.\n    if spec.currentCutTime > = spec.currentTargetCutTime then\n        self:stopCutting( true )\n    end\nend\n\n"})}),"\n",(0,a.jsx)(n.h3,{id:"updatecuttinganimation",children:"updateCuttingAnimation"}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Description"})}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Definition"})}),"\n",(0,a.jsxs)(n.blockquote,{children:["\n",(0,a.jsx)(n.p,{children:"updateCuttingAnimation()"}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,a.jsx)(n.table,{children:(0,a.jsx)(n.thead,{children:(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.th,{children:"any"}),(0,a.jsx)(n.th,{children:"dt"})]})})}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Code"})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-lua",children:"function HandToolChainsaw:updateCuttingAnimation(dt)\n    local spec = self.spec_chainsaw\n\n    -- If the animation is still waiting for the chain to speed up, slowly move along the line which doesn't intersect the tree geometry.\n        local cutCurrentPositionX, cutCurrentPositionY, cutCurrentPositionZ\n        if spec.currentCutTime < = spec.currentTargetStartupTime then\n\n            -- Calculate the linear progress of the startup time, moving towards the cut start at a fixed rate.\n            local cutCurrentProgress = math.clamp(spec.currentCutTime / spec.currentTargetStartupTime, 0 , 1 )\n\n            -- Set the position of the cut guide.\n            cutCurrentPositionX, cutCurrentPositionY, cutCurrentPositionZ = MathUtil.vector3Lerp(spec.cutRevPositionX, spec.cutRevPositionY, spec.cutRevPositionZ,\n            spec.cutStartPositionX, spec.cutStartPositionY, spec.cutStartPositionZ, cutCurrentProgress)\n\n            -- There is no load on the chainsaw just yet, so set the load to 0.\n            self:setCurrentLoad( 0 )\n\n            -- Otherwise; if the animation is cutting through the tree, move along the main line.\n            else\n                    spec.effectEndTime = g_ time + 200\n\n                    -- Get the linear progress of the cut along the line, then apply the smoothing curve to it.\n                    local cutCurrentProgress = math.clamp((spec.currentCutTime - spec.currentTargetStartupTime) / (spec.currentTargetCutTime - spec.currentTargetStartupTime), 0 , 1 )\n                    cutCurrentProgress = spec.smoothingCurve:solve(cutCurrentProgress)\n\n                    -- Get the linear progress of the cut along the line of the previous frame, then apply the smoothing curve to it.\n                    local cutLastProgress = math.clamp(((spec.currentCutTime - spec.currentTargetStartupTime) - dt) / (spec.currentTargetCutTime - spec.currentTargetStartupTime), 0 , 1 )\n                    cutLastProgress = spec.smoothingCurve:solve(cutLastProgress)\n\n                    -- Calculate the linear speed of the cut with no smoothing applied, and the speed with smoothing applied.\n                    local linearSpeed = dt / (spec.currentTargetCutTime - spec.currentTargetStartupTime)\n                    local currentCutSpeed = math.max(cutCurrentProgress - cutLastProgress, 0.00001 )\n\n                    -- Calculate the current cut load.This is based on the smoothed speed of the cut compared to a linear cut.\n                    self:setCurrentLoad( math.clamp(linearSpeed / currentCutSpeed, 0 , 1 ))\n\n                    -- Set the position of the cut guide.\n                    cutCurrentPositionX, cutCurrentPositionY, cutCurrentPositionZ = MathUtil.vector3Lerp(spec.cutStartPositionX, spec.cutStartPositionY, spec.cutStartPositionZ,\n                    spec.cutEndPositionX, spec.cutEndPositionY, spec.cutEndPositionZ, cutCurrentProgress)\n                end\n\n                -- Position and orient the cut guide node.\n                setWorldTranslation(spec.cutGuideNode, cutCurrentPositionX, cutCurrentPositionY, cutCurrentPositionZ)\n                setWorldQuaternion(spec.cutGuideNode, getWorldQuaternion(spec.splitPlaneNode))\n            end\n\n"})}),"\n",(0,a.jsx)(n.h3,{id:"updateringselector",children:"updateRingSelector"}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Description"})}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Definition"})}),"\n",(0,a.jsxs)(n.blockquote,{children:["\n",(0,a.jsx)(n.p,{children:"updateRingSelector()"}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,a.jsxs)(n.table,{children:[(0,a.jsx)(n.thead,{children:(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.th,{children:"any"}),(0,a.jsx)(n.th,{children:"targetedTree"})]})}),(0,a.jsxs)(n.tbody,{children:[(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:"any"}),(0,a.jsx)(n.td,{children:"isCutPossible"})]}),(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:"any"}),(0,a.jsx)(n.td,{children:"cutMinimumY"})]}),(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:"any"}),(0,a.jsx)(n.td,{children:"cutMaximumY"})]}),(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:"any"}),(0,a.jsx)(n.td,{children:"cutMinimumZ"})]}),(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:"any"}),(0,a.jsx)(n.td,{children:"cutMaximumZ"})]})]})]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Code"})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-lua",children:'function HandToolChainsaw:updateRingSelector(targetedTree, isCutPossible, cutMinimumY, cutMaximumY, cutMinimumZ, cutMaximumZ)\n    local spec = self.spec_chainsaw\n    if spec.ringNode = = nil then\n        return\n    end\n\n    -- If there is no tree being aimed at, hide the ring indicator and do nothing more.\n        setVisibility(spec.ringNode, targetedTree ~ = nil )\n\n        if targetedTree = = nil then\n            return\n        end\n\n        -- Color the indicator ring based on the validity of the cut.\n        if isCutPossible then\n            setShaderParameter(spec.ringNode, "colorScale" , HandToolChainsaw.VALID_CUT_COLOR.r, HandToolChainsaw.VALID_CUT_COLOR.g, HandToolChainsaw.VALID_CUT_COLOR.b, 1 , false )\n        else\n                setShaderParameter(spec.ringNode, "colorScale" , HandToolChainsaw.INVALID_CUT_COLOR.r, HandToolChainsaw.INVALID_CUT_COLOR.g, HandToolChainsaw.INVALID_CUT_COLOR.b, 1 , false )\n            end\n\n            -- If no cut would be possible, do nothing more.\n                if cutMinimumY = = nil then\n                    return\n                end\n\n                -- Scale the ring indicator so that it covers the entire trunk/branch.\n                local ringScale = math.max(cutMaximumZ - cutMinimumZ, cutMaximumY - cutMinimumY) + spec.ringScaleOffset\n                setScale(spec.ringNode, 1 , ringScale, ringScale)\n\n                -- Centre the ring indictor in the middle of the trunk/branch.\n                local worldTreeCentreX, worldTreeCentreY, worldTreeCentreZ = localToWorld(spec.splitPlaneNode, (cutMinimumY + cutMaximumY) * 0.5 , 0 , (cutMinimumZ + cutMaximumZ) * 0.5 )\n                local localTreeCentreX, localTreeCentreY, localTreeCentreZ = worldToLocal(getParent(spec.ringNode), worldTreeCentreX, worldTreeCentreY, worldTreeCentreZ)\n                setTranslation(spec.ringNode, localTreeCentreX, localTreeCentreY, localTreeCentreZ)\n            end\n\n'})}),"\n",(0,a.jsx)(n.h3,{id:"updatesplitplane",children:"updateSplitPlane"}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Description"})}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Definition"})}),"\n",(0,a.jsxs)(n.blockquote,{children:["\n",(0,a.jsx)(n.p,{children:"updateSplitPlane()"}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Code"})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-lua",children:"function HandToolChainsaw:updateSplitPlane()\n    local spec = self.spec_chainsaw\n\n    if spec.currentCutState = = ChainsawCutState.DELIMBING then\n        local x, y, z = localToWorld( self.graphicalNode, 0 , - spec.maximumDelimbDiameter * 0.5 , 0 )\n        setWorldTranslation(spec.cameraRotationNode, x, y, z)\n\n        local cameraNode = g_cameraManager:getActiveCamera()\n        local upX, upY, upZ = localDirectionToWorld(cameraNode, 0 , 1 , 0 )\n        local dirX, dirY, dirZ = localDirectionToWorld(cameraNode, 0 , 0 , - 1 )\n        setDirection(spec.cameraRotationNode, dirX, dirY, dirZ, upX, upY, upZ)\n    else\n            local _, playerYaw = self:getCarryingPlayer().camera:getRotation()\n            setWorldRotation(spec.cameraRotationNode, 0 , playerYaw, 0 )\n        end\n\n        rotateAboutLocalAxis(spec.cameraRotationNode, spec.currentCutRoll, 0 , 0 , 1 )\n\n        spec.cutMinimumY, spec.cutMaximumY, spec.cutMinimumZ, spec.cutMaximumZ = nil , nil , nil , nil\n\n        -- If the cutting data should be kept, test against the currently cut tree.\n        if spec.currentCutState = = ChainsawCutState.CUTTING then\n            -- If there is no tree being cut, do nothing more.\n                if spec.cuttingTreeNode = = nil or not entityExists(spec.cuttingTreeNode) then\n                    return\n                end\n\n                -- Calculate the plane.\n                local x, y, z, downX, downY, downZ, leftX, leftY, leftZ, planeWidth, planeDepth = self:calculateCutPlane()\n\n                -- Test against the currently cut tree.\n                spec.cutMinimumY, spec.cutMaximumY, spec.cutMinimumZ, spec.cutMaximumZ = testSplitShape(spec.cuttingTreeNode, x, y, z, downX, downY, downZ, leftX, leftY, leftZ, planeWidth, planeDepth)\n\n            elseif spec.currentCutState = = ChainsawCutState.IDLE then\n                    -- If there is no tree being aimed at, do nothing more.\n                        if spec.targetedTree = = nil or not entityExists(spec.targetedTree.node) then\n                            return\n                        end\n\n                        -- Set the position of the rotation node to be at the ray hit position.\n                        setWorldTranslation(spec.cameraRotationNode, spec.targetedTree.x, spec.targetedTree.y, spec.targetedTree.z)\n\n                        -- Calculate the plane.\n                        local x, y, z, downX, downY, downZ, leftX, leftY, leftZ, planeWidth, planeDepth = self:calculateCutPlane()\n\n                        -- Test against the currently targeted tree.\n                        spec.cutMinimumY, spec.cutMaximumY, spec.cutMinimumZ, spec.cutMaximumZ = testSplitShape(spec.targetedTree.node, x, y, z, downX, downY, downZ, leftX, leftY, leftZ, planeWidth, planeDepth)\n                    end\n                end\n\n"})})]})}function h(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(d,{...e})}):d(e)}}}]);