"use strict";(globalThis.webpackChunkfs25_community_luadoc=globalThis.webpackChunkfs25_community_luadoc||[]).push([[11868],{9658(e,n,r){r.r(n),r.d(n,{assets:()=>o,contentTitle:()=>s,default:()=>h,frontMatter:()=>i,metadata:()=>t,toc:()=>d});const t=JSON.parse('{"id":"script/Vehicles/VehicleMotor","title":"VehicleMotor","description":"VehicleMotor","source":"@site/../docs/script/Vehicles/VehicleMotor.md","sourceDirName":"script/Vehicles","slug":"/script/Vehicles/VehicleMotor","permalink":"/FS25-Community-LUADOC/script/Vehicles/VehicleMotor","draft":false,"unlisted":false,"tags":[],"version":"current","lastUpdatedAt":1767161192000,"frontMatter":{},"sidebar":"docsSidebar","previous":{"title":"VehicleMaterialManager","permalink":"/FS25-Community-LUADOC/script/Vehicles/VehicleMaterialManager"},"next":{"title":"VehicleSystem","permalink":"/FS25-Community-LUADOC/script/Vehicles/VehicleSystem"}}');var a=r(74848),l=r(28453);const i={},s=void 0,o={},d=[{value:"VehicleMotor",id:"vehiclemotor",level:2},{value:"applyTargetGear",id:"applytargetgear",level:3},{value:"calculatePhysicalMaximumBackwardSpeed",id:"calculatephysicalmaximumbackwardspeed",level:3},{value:"calculatePhysicalMaximumForwardSpeed",id:"calculatephysicalmaximumforwardspeed",level:3},{value:"calculatePhysicalMaximumSpeed",id:"calculatephysicalmaximumspeed",level:3},{value:"changeDirection",id:"changedirection",level:3},{value:"delete",id:"delete",level:3},{value:"findGearChangeTargetGearPrediction",id:"findgearchangetargetgearprediction",level:3},{value:"getAccelerationLimit",id:"getaccelerationlimit",level:3},{value:"getBestGear",id:"getbestgear",level:3},{value:"getBestGearRatio",id:"getbestgearratio",level:3},{value:"getBestStartGear",id:"getbeststartgear",level:3},{value:"getBrakeForce",id:"getbrakeforce",level:3},{value:"getCanMotorRun",id:"getcanmotorrun",level:3},{value:"getClutchPedal",id:"getclutchpedal",level:3},{value:"getClutchRotSpeed",id:"getclutchrotspeed",level:3},{value:"getClutchRpm",id:"getclutchrpm",level:3},{value:"getCurMaxRpm",id:"getcurmaxrpm",level:3},{value:"getDampingRateFullThrottle",id:"getdampingratefullthrottle",level:3},{value:"getDampingRateZeroThrottleClutchDisengaged",id:"getdampingratezerothrottleclutchdisengaged",level:3},{value:"getDampingRateZeroThrottleClutchEngaged",id:"getdampingratezerothrottleclutchengaged",level:3},{value:"getDrivingDirection",id:"getdrivingdirection",level:3},{value:"getEqualizedMotorRpm",id:"getequalizedmotorrpm",level:3},{value:"getGearGroupToDisplay",id:"getgeargrouptodisplay",level:3},{value:"getGearInfoToDisplay",id:"getgearinfotodisplay",level:3},{value:"getGearRatio",id:"getgearratio",level:3},{value:"getGearRatioMultiplier",id:"getgearratiomultiplier",level:3},{value:"getGearToDisplay",id:"getgeartodisplay",level:3},{value:"getIsGearChangeAllowed",id:"getisgearchangeallowed",level:3},{value:"getIsGearGroupChangeAllowed",id:"getisgeargroupchangeallowed",level:3},{value:"getIsInNeutral",id:"getisinneutral",level:3},{value:"getLastModulatedMotorRpm",id:"getlastmodulatedmotorrpm",level:3},{value:"getLastMotorRpm",id:"getlastmotorrpm",level:3},{value:"getLastRealMotorRpm",id:"getlastrealmotorrpm",level:3},{value:"getManualClutchPedal",id:"getmanualclutchpedal",level:3},{value:"getMaxClutchTorque",id:"getmaxclutchtorque",level:3},{value:"getMaximumBackwardSpeed",id:"getmaximumbackwardspeed",level:3},{value:"getMaximumForwardSpeed",id:"getmaximumforwardspeed",level:3},{value:"getMaxRpm",id:"getmaxrpm",level:3},{value:"getMinMaxGearRatio",id:"getminmaxgearratio",level:3},{value:"getMinRpm",id:"getminrpm",level:3},{value:"getMotorAppliedTorque",id:"getmotorappliedtorque",level:3},{value:"getMotorAvailableTorque",id:"getmotoravailabletorque",level:3},{value:"getMotorExternalTorque",id:"getmotorexternaltorque",level:3},{value:"getMotorRotationAccelerationLimit",id:"getmotorrotationaccelerationlimit",level:3},{value:"getMotorRotSpeed",id:"getmotorrotspeed",level:3},{value:"getNonClampedMotorRpm",id:"getnonclampedmotorrpm",level:3},{value:"getPeakTorque",id:"getpeaktorque",level:3},{value:"getPtoMotorRpmRatio",id:"getptomotorrpmratio",level:3},{value:"getRequiredMotorRpmRange",id:"getrequiredmotorrpmrange",level:3},{value:"getRequiredRpmAtSpeedLimit",id:"getrequiredrpmatspeedlimit",level:3},{value:"getRotInertia",id:"getrotinertia",level:3},{value:"getSmoothedClutchPedal",id:"getsmoothedclutchpedal",level:3},{value:"getSmoothLoadPercentage",id:"getsmoothloadpercentage",level:3},{value:"getSpeedLimit",id:"getspeedlimit",level:3},{value:"getStartInGearFactor",id:"getstartingearfactor",level:3},{value:"getTorque",id:"gettorque",level:3},{value:"getTorqueAndSpeedValues",id:"gettorqueandspeedvalues",level:3},{value:"getTorqueCurve",id:"gettorquecurve",level:3},{value:"getTorqueCurveValue",id:"gettorquecurvevalue",level:3},{value:"getUseAutomaticGearShifting",id:"getuseautomaticgearshifting",level:3},{value:"getUseAutomaticGroupShifting",id:"getuseautomaticgroupshifting",level:3},{value:"new",id:"new",level:3},{value:"onManualClutchChanged",id:"onmanualclutchchanged",level:3},{value:"postLoad",id:"postload",level:3},{value:"readGearDataFromStream",id:"readgeardatafromstream",level:3},{value:"selectGear",id:"selectgear",level:3},{value:"selectGroup",id:"selectgroup",level:3},{value:"setAccelerationLimit",id:"setaccelerationlimit",level:3},{value:"setAutoGearChangeTime",id:"setautogearchangetime",level:3},{value:"setDampingRateScale",id:"setdampingratescale",level:3},{value:"setDirectionChange",id:"setdirectionchange",level:3},{value:"setDirectionChangeMode",id:"setdirectionchangemode",level:3},{value:"setEqualizedMotorRpm",id:"setequalizedmotorrpm",level:3},{value:"setExternalTorqueVirtualMultiplicator",id:"setexternaltorquevirtualmultiplicator",level:3},{value:"setGear",id:"setgear",level:3},{value:"setGearChangeTime",id:"setgearchangetime",level:3},{value:"setGearGroup",id:"setgeargroup",level:3},{value:"setGearGroups",id:"setgeargroups",level:3},{value:"setGearShiftMode",id:"setgearshiftmode",level:3},{value:"setLastRpm",id:"setlastrpm",level:3},{value:"setLowBrakeForce",id:"setlowbrakeforce",level:3},{value:"setManualShift",id:"setmanualshift",level:3},{value:"setMotorRotationAccelerationLimit",id:"setmotorrotationaccelerationlimit",level:3},{value:"setRotInertia",id:"setrotinertia",level:3},{value:"setRpmLimit",id:"setrpmlimit",level:3},{value:"setSpeedLimit",id:"setspeedlimit",level:3},{value:"setStartGearThreshold",id:"setstartgearthreshold",level:3},{value:"setTransmissionDirection",id:"settransmissiondirection",level:3},{value:"shiftGear",id:"shiftgear",level:3},{value:"shiftGroup",id:"shiftgroup",level:3},{value:"update",id:"update",level:3},{value:"updateGear",id:"updategear",level:3},{value:"updateSmoothLoadPercentage",id:"updatesmoothloadpercentage",level:3},{value:"updateStartGearValues",id:"updatestartgearvalues",level:3},{value:"writeGearDataToStream",id:"writegeardatatostream",level:3}];function c(e){const n={a:"a",blockquote:"blockquote",code:"code",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,l.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.h2,{id:"vehiclemotor",children:"VehicleMotor"}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Description"})}),"\n",(0,a.jsxs)(n.blockquote,{children:["\n",(0,a.jsx)(n.p,{children:"Class for vehicle motors"}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Functions"})}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.a,{href:"#applytargetgear",children:"applyTargetGear"})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.a,{href:"#calculatephysicalmaximumbackwardspeed",children:"calculatePhysicalMaximumBackwardSpeed"})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.a,{href:"#calculatephysicalmaximumforwardspeed",children:"calculatePhysicalMaximumForwardSpeed"})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.a,{href:"#calculatephysicalmaximumspeed",children:"calculatePhysicalMaximumSpeed"})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.a,{href:"#changedirection",children:"changeDirection"})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.a,{href:"#delete",children:"delete"})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.a,{href:"#findgearchangetargetgearprediction",children:"findGearChangeTargetGearPrediction"})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.a,{href:"#getaccelerationlimit",children:"getAccelerationLimit"})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.a,{href:"#getbestgear",children:"getBestGear"})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.a,{href:"#getbestgearratio",children:"getBestGearRatio"})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.a,{href:"#getbeststartgear",children:"getBestStartGear"})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.a,{href:"#getbrakeforce",children:"getBrakeForce"})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.a,{href:"#getcanmotorrun",children:"getCanMotorRun"})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.a,{href:"#getclutchpedal",children:"getClutchPedal"})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.a,{href:"#getclutchrotspeed",children:"getClutchRotSpeed"})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.a,{href:"#getclutchrpm",children:"getClutchRpm"})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.a,{href:"#getcurmaxrpm",children:"getCurMaxRpm"})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.a,{href:"#getdampingratefullthrottle",children:"getDampingRateFullThrottle"})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.a,{href:"#getdampingratezerothrottleclutchdisengaged",children:"getDampingRateZeroThrottleClutchDisengaged"})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.a,{href:"#getdampingratezerothrottleclutchengaged",children:"getDampingRateZeroThrottleClutchEngaged"})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.a,{href:"#getdrivingdirection",children:"getDrivingDirection"})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.a,{href:"#getequalizedmotorrpm",children:"getEqualizedMotorRpm"})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.a,{href:"#getgeargrouptodisplay",children:"getGearGroupToDisplay"})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.a,{href:"#getgearinfotodisplay",children:"getGearInfoToDisplay"})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.a,{href:"#getgearratio",children:"getGearRatio"})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.a,{href:"#getgearratiomultiplier",children:"getGearRatioMultiplier"})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.a,{href:"#getgeartodisplay",children:"getGearToDisplay"})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.a,{href:"#getisgearchangeallowed",children:"getIsGearChangeAllowed"})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.a,{href:"#getisgeargroupchangeallowed",children:"getIsGearGroupChangeAllowed"})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.a,{href:"#getisinneutral",children:"getIsInNeutral"})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.a,{href:"#getlastmodulatedmotorrpm",children:"getLastModulatedMotorRpm"})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.a,{href:"#getlastmotorrpm",children:"getLastMotorRpm"})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.a,{href:"#getlastrealmotorrpm",children:"getLastRealMotorRpm"})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.a,{href:"#getmanualclutchpedal",children:"getManualClutchPedal"})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.a,{href:"#getmaxclutchtorque",children:"getMaxClutchTorque"})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.a,{href:"#getmaximumbackwardspeed",children:"getMaximumBackwardSpeed"})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.a,{href:"#getmaximumforwardspeed",children:"getMaximumForwardSpeed"})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.a,{href:"#getmaxrpm",children:"getMaxRpm"})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.a,{href:"#getminmaxgearratio",children:"getMinMaxGearRatio"})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.a,{href:"#getminrpm",children:"getMinRpm"})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.a,{href:"#getmotorappliedtorque",children:"getMotorAppliedTorque"})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.a,{href:"#getmotoravailabletorque",children:"getMotorAvailableTorque"})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.a,{href:"#getmotorexternaltorque",children:"getMotorExternalTorque"})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.a,{href:"#getmotorrotationaccelerationlimit",children:"getMotorRotationAccelerationLimit"})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.a,{href:"#getmotorrotspeed",children:"getMotorRotSpeed"})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.a,{href:"#getnonclampedmotorrpm",children:"getNonClampedMotorRpm"})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.a,{href:"#getpeaktorque",children:"getPeakTorque"})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.a,{href:"#getptomotorrpmratio",children:"getPtoMotorRpmRatio"})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.a,{href:"#getrequiredmotorrpmrange",children:"getRequiredMotorRpmRange"})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.a,{href:"#getrequiredrpmatspeedlimit",children:"getRequiredRpmAtSpeedLimit"})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.a,{href:"#getrotinertia",children:"getRotInertia"})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.a,{href:"#getsmoothedclutchpedal",children:"getSmoothedClutchPedal"})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.a,{href:"#getsmoothloadpercentage",children:"getSmoothLoadPercentage"})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.a,{href:"#getspeedlimit",children:"getSpeedLimit"})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.a,{href:"#getstartingearfactor",children:"getStartInGearFactor"})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.a,{href:"#gettorque",children:"getTorque"})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.a,{href:"#gettorqueandspeedvalues",children:"getTorqueAndSpeedValues"})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.a,{href:"#gettorquecurve",children:"getTorqueCurve"})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.a,{href:"#gettorquecurvevalue",children:"getTorqueCurveValue"})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.a,{href:"#getuseautomaticgearshifting",children:"getUseAutomaticGearShifting"})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.a,{href:"#getuseautomaticgroupshifting",children:"getUseAutomaticGroupShifting"})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.a,{href:"#new",children:"new"})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.a,{href:"#onmanualclutchchanged",children:"onManualClutchChanged"})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.a,{href:"#postload",children:"postLoad"})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.a,{href:"#readgeardatafromstream",children:"readGearDataFromStream"})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.a,{href:"#selectgear",children:"selectGear"})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.a,{href:"#selectgroup",children:"selectGroup"})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.a,{href:"#setaccelerationlimit",children:"setAccelerationLimit"})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.a,{href:"#setautogearchangetime",children:"setAutoGearChangeTime"})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.a,{href:"#setdampingratescale",children:"setDampingRateScale"})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.a,{href:"#setdirectionchange",children:"setDirectionChange"})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.a,{href:"#setdirectionchangemode",children:"setDirectionChangeMode"})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.a,{href:"#setequalizedmotorrpm",children:"setEqualizedMotorRpm"})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.a,{href:"#setexternaltorquevirtualmultiplicator",children:"setExternalTorqueVirtualMultiplicator"})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.a,{href:"#setgear",children:"setGear"})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.a,{href:"#setgearchangetime",children:"setGearChangeTime"})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.a,{href:"#setgeargroup",children:"setGearGroup"})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.a,{href:"#setgeargroups",children:"setGearGroups"})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.a,{href:"#setgearshiftmode",children:"setGearShiftMode"})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.a,{href:"#setlastrpm",children:"setLastRpm"})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.a,{href:"#setlowbrakeforce",children:"setLowBrakeForce"})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.a,{href:"#setmanualshift",children:"setManualShift"})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.a,{href:"#setmotorrotationaccelerationlimit",children:"setMotorRotationAccelerationLimit"})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.a,{href:"#setrotinertia",children:"setRotInertia"})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.a,{href:"#setrpmlimit",children:"setRpmLimit"})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.a,{href:"#setspeedlimit",children:"setSpeedLimit"})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.a,{href:"#setstartgearthreshold",children:"setStartGearThreshold"})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.a,{href:"#settransmissiondirection",children:"setTransmissionDirection"})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.a,{href:"#shiftgear",children:"shiftGear"})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.a,{href:"#shiftgroup",children:"shiftGroup"})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.a,{href:"#update",children:"update"})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.a,{href:"#updategear",children:"updateGear"})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.a,{href:"#updatesmoothloadpercentage",children:"updateSmoothLoadPercentage"})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.a,{href:"#updatestartgearvalues",children:"updateStartGearValues"})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.a,{href:"#writegeardatatostream",children:"writeGearDataToStream"})}),"\n"]}),"\n",(0,a.jsx)(n.h3,{id:"applytargetgear",children:"applyTargetGear"}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Description"})}),"\n",(0,a.jsxs)(n.blockquote,{children:["\n",(0,a.jsx)(n.p,{children:"Apply target gear"}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Definition"})}),"\n",(0,a.jsxs)(n.blockquote,{children:["\n",(0,a.jsx)(n.p,{children:"applyTargetGear()"}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Code"})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-lua",children:'function VehicleMotor:applyTargetGear()\n    local gearRatioMultiplier = self:getGearRatioMultiplier()\n    self.gear = self.targetGear\n\n    if self.gearShiftMode ~ = VehicleMotor.SHIFT_MODE_MANUAL_CLUTCH then\n        if self.currentGears[ self.gear] ~ = nil then\n            self.minGearRatio = self.currentGears[ self.gear].ratio * gearRatioMultiplier\n            self.maxGearRatio = self.minGearRatio\n        else\n                self.minGearRatio = 0\n                self.maxGearRatio = 0\n            end\n        end\n\n        self.gearChangeTime = self.gearChangeTimeOrig\n\n        local directionMultiplier = self.directionChangeUseGear and self.currentDirection or 1\n        SpecializationUtil.raiseEvent( self.vehicle, "onGearChanged" , self.gear * directionMultiplier, self.targetGear * directionMultiplier, 0 , self.previousGear)\n    end\n\n'})}),"\n",(0,a.jsx)(n.h3,{id:"calculatephysicalmaximumbackwardspeed",children:"calculatePhysicalMaximumBackwardSpeed"}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Description"})}),"\n",(0,a.jsxs)(n.blockquote,{children:["\n",(0,a.jsx)(n.p,{children:"Returns physical maximum backward speed"}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Definition"})}),"\n",(0,a.jsxs)(n.blockquote,{children:["\n",(0,a.jsx)(n.p,{children:"calculatePhysicalMaximumBackwardSpeed()"}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Return Values"})}),"\n\n\n\n\n\n\n\n\n",(0,a.jsx)(n.table,{children:(0,a.jsx)(n.thead,{children:(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.th,{children:"any"}),(0,a.jsx)(n.th,{children:"physicalMaxBackwardSpeed"}),(0,a.jsx)(n.th,{children:"physical maximum backward speed"})]})})}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Code"})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-lua",children:"function VehicleMotor:calculatePhysicalMaximumBackwardSpeed()\n    return VehicleMotor.calculatePhysicalMaximumSpeed( self.minBackwardGearRatio, self.backwardGears or self.forwardGears, self.maxRpm)\nend\n\n"})}),"\n",(0,a.jsx)(n.h3,{id:"calculatephysicalmaximumforwardspeed",children:"calculatePhysicalMaximumForwardSpeed"}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Description"})}),"\n",(0,a.jsxs)(n.blockquote,{children:["\n",(0,a.jsx)(n.p,{children:"Returns physical maximum forward speed"}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Definition"})}),"\n",(0,a.jsxs)(n.blockquote,{children:["\n",(0,a.jsx)(n.p,{children:"calculatePhysicalMaximumForwardSpeed()"}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Return Values"})}),"\n\n\n\n\n\n\n\n\n",(0,a.jsx)(n.table,{children:(0,a.jsx)(n.thead,{children:(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.th,{children:"any"}),(0,a.jsx)(n.th,{children:"physicalMaxForwardSpeed"}),(0,a.jsx)(n.th,{children:"physical maximum forward speed"})]})})}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Code"})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-lua",children:"function VehicleMotor:calculatePhysicalMaximumForwardSpeed()\n    return VehicleMotor.calculatePhysicalMaximumSpeed( self.minForwardGearRatio, self.forwardGears, self.maxRpm)\nend\n\n"})}),"\n",(0,a.jsx)(n.h3,{id:"calculatephysicalmaximumspeed",children:"calculatePhysicalMaximumSpeed"}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Description"})}),"\n",(0,a.jsxs)(n.blockquote,{children:["\n",(0,a.jsx)(n.p,{children:"Returns physical maximum speed"}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Definition"})}),"\n",(0,a.jsxs)(n.blockquote,{children:["\n",(0,a.jsx)(n.p,{children:"calculatePhysicalMaximumSpeed(float minGearRatio, table gears, integer maxRpm)"}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,a.jsxs)(n.table,{children:[(0,a.jsx)(n.thead,{children:(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.th,{children:"float"}),(0,a.jsx)(n.th,{children:"minGearRatio"}),(0,a.jsx)(n.th,{children:"min gear ratio"})]})}),(0,a.jsxs)(n.tbody,{children:[(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:"table"}),(0,a.jsx)(n.td,{children:"gears"}),(0,a.jsx)(n.td,{children:"gears"})]}),(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:"integer"}),(0,a.jsx)(n.td,{children:"maxRpm"}),(0,a.jsx)(n.td,{children:"max rpm"})]})]})]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Return Values"})}),"\n\n\n\n\n\n\n\n\n",(0,a.jsx)(n.table,{children:(0,a.jsx)(n.thead,{children:(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.th,{children:"integer"}),(0,a.jsx)(n.th,{children:"physicalMaxSpeed"}),(0,a.jsx)(n.th,{children:"physical maximum speed"})]})})}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Code"})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-lua",children:"function VehicleMotor.calculatePhysicalMaximumSpeed(minGearRatio, gears, maxRpm)\n    local minRatio\n    if minGearRatio ~ = nil then\n        minRatio = minGearRatio\n    elseif gears ~ = nil then\n            minRatio = math.huge\n            for _, gear in pairs(gears) do\n                minRatio = math.min(minRatio, gear.ratio)\n            end\n        else\n                printCallstack()\n                return 0\n            end\n\n            return maxRpm * math.pi / ( 30 * minRatio)\n        end\n\n"})}),"\n",(0,a.jsx)(n.h3,{id:"changedirection",children:"changeDirection"}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Description"})}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Definition"})}),"\n",(0,a.jsxs)(n.blockquote,{children:["\n",(0,a.jsx)(n.p,{children:"changeDirection()"}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,a.jsxs)(n.table,{children:[(0,a.jsx)(n.thead,{children:(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.th,{children:"any"}),(0,a.jsx)(n.th,{children:"direction"})]})}),(0,a.jsx)(n.tbody,{children:(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:"any"}),(0,a.jsx)(n.td,{children:"force"})]})})]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Code"})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-lua",children:'function VehicleMotor:changeDirection(direction, force)\n    local targetDirection\n    if direction = = nil then\n        targetDirection = - self.currentDirection\n    else\n            targetDirection = direction\n        end\n\n        if self.backwardGears = = nil and self.forwardGears = = nil then\n            self.currentDirection = targetDirection\n            SpecializationUtil.raiseEvent( self.vehicle, "onGearDirectionChanged" , self.currentDirection)\n            return\n        end\n\n        local changeAllowed = ( self.directionChangeUseGroup and not self.gearGroupChangedIsLocked)\n        or( self.directionChangeUseGear and not self.gearChangedIsLocked)\n        or( not self.directionChangeUseGear and not self.directionChangeUseGroup)\n        if changeAllowed then\n            if targetDirection ~ = self.currentDirection or force then\n                self.currentDirection = targetDirection\n\n                if self.directionChangeTime > 0 then\n                    self.directionChangeTimer = self.directionChangeTime\n                    self.gear = 0\n                    self.minGearRatio = 0\n                    self.maxGearRatio = 0\n                end\n\n                local oldGearGroupIndex = self.activeGearGroupIndex\n                if self.currentDirection < 0 then\n                    if self.directionChangeUseGear then\n                        self.directionLastGear = self.targetGear\n                        if not self:getUseAutomaticGearShifting() or not self.lastManualShifterActive then\n                            self.targetGear = self.directionChangeGearIndex\n                        end\n\n                        self.currentGears = self.backwardGears or self.forwardGears\n                    elseif self.directionChangeUseGroup then\n                            self.directionLastGroup = self.activeGearGroupIndex\n                            self.activeGearGroupIndex = self.directionChangeGroupIndex\n                        end\n                    else\n                            if self.directionChangeUseGear then\n                                if not self:getUseAutomaticGearShifting() or not self.lastManualShifterActive then\n                                    if self.directionLastGear > 0 then\n                                        self.targetGear = not self:getUseAutomaticGearShifting() and self.directionLastGear or self.defaultForwardGear\n                                    else\n                                            self.targetGear = self.defaultForwardGear\n                                        end\n                                    end\n\n                                    self.currentGears = self.forwardGears\n                                elseif self.directionChangeUseGroup then\n                                        if self.directionLastGroup > 0 then\n                                            self.activeGearGroupIndex = self.directionLastGroup\n                                        else\n                                                self.activeGearGroupIndex = self.defaultGearGroup\n                                            end\n                                        end\n                                    end\n\n                                    SpecializationUtil.raiseEvent( self.vehicle, "onGearDirectionChanged" , self.currentDirection)\n\n                                    local directionMultiplier = self.directionChangeUseGear and self.currentDirection or 1\n                                    SpecializationUtil.raiseEvent( self.vehicle, "onGearChanged" , self.gear * directionMultiplier, self.targetGear * directionMultiplier, self.directionChangeTime, self.previousGear)\n\n                                    if self.activeGearGroupIndex ~ = oldGearGroupIndex then\n                                        SpecializationUtil.raiseEvent( self.vehicle, "onGearGroupChanged" , self.activeGearGroupIndex, self.directionChangeTime)\n                                    end\n\n                                    if self.directionChangeTime = = 0 then\n                                        self:applyTargetGear()\n                                    end\n                                end\n                            end\n                        end\n\n'})}),"\n",(0,a.jsx)(n.h3,{id:"delete",children:"delete"}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Description"})}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Definition"})}),"\n",(0,a.jsxs)(n.blockquote,{children:["\n",(0,a.jsx)(n.p,{children:"delete()"}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Code"})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-lua",children:"function VehicleMotor:delete()\n    g_messageCenter:unsubscribeAll( self )\nend\n\n"})}),"\n",(0,a.jsx)(n.h3,{id:"findgearchangetargetgearprediction",children:"findGearChangeTargetGearPrediction"}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Description"})}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Definition"})}),"\n",(0,a.jsxs)(n.blockquote,{children:["\n",(0,a.jsx)(n.p,{children:"findGearChangeTargetGearPrediction()"}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,a.jsxs)(n.table,{children:[(0,a.jsx)(n.thead,{children:(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.th,{children:"any"}),(0,a.jsx)(n.th,{children:"curGear"})]})}),(0,a.jsxs)(n.tbody,{children:[(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:"any"}),(0,a.jsx)(n.td,{children:"gears"})]}),(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:"any"}),(0,a.jsx)(n.td,{children:"gearSign"})]}),(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:"any"}),(0,a.jsx)(n.td,{children:"gearChangeTimer"})]}),(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:"any"}),(0,a.jsx)(n.td,{children:"acceleratorPedal"})]}),(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:"any"}),(0,a.jsx)(n.td,{children:"dt"})]})]})]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Code"})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-lua",children:'function VehicleMotor:findGearChangeTargetGearPrediction(curGear, gears, gearSign, gearChangeTimer, acceleratorPedal, dt)\n    local newGear = curGear\n    local gearRatioMultiplier = self:getGearRatioMultiplier()\n\n    local minAllowedRpm, maxAllowedRpm = self.minRpm, self.maxRpm\n    --print(string.format("rpmRange [%.2f %.2f]", minAllowedRpm, maxAllowedRpm))\n    local gearRatio = math.abs(gears[curGear].ratio * gearRatioMultiplier)\n\n    local differentialRotSpeed = math.max( self.differentialRotSpeed * gearSign, 0.0001 )\n    local differentialRpm = differentialRotSpeed * 30 / math.pi\n    local clutchRpm = differentialRpm * gearRatio\n    --log("differentialRpm", differentialRpm, "gearRatio", gearRatio, "clutchRpm", clutchRpm, "gearSign", gearSign, "self.differentialRotSpeed", self.differentialRotSpeed)\n\n    -- 1.Predict the velocity of the vehicle after the gear change\n    local diffSpeedAfterChange\n    if math.abs(acceleratorPedal) < 0.0001 then\n        -- Assume that we will continue decelerating with 80% of the current deceleration\n        local brakeAcc = math.min( self.differentialRotAccelerationSmoothed * gearSign * 0.8 , 0 )\n        diffSpeedAfterChange = math.max(differentialRotSpeed + brakeAcc * self.gearChangeTime * 0.001 , 0 )\n        --print(string.format("brake expectedAcc: %.3f realAcc %.3f %.3f max: %.2f gr: %.2f speed: %.2f", brakeAcc, self.vehicle.lastSpeedAcceleration*1000*1000, self.differentialRotAccelerationSmoothed, maxExpectedAcc, gearRatio, self.vehicle.lastSpeedReal*1000))\n    else\n            -- Ignore wheels mass as it is usually negligible and the calculation below is not correct when the differential acceleration is not uniformely distributed\n            --[[local neededWheelsInertiaTorque = 0\n            local specWheels = self.vehicle.spec_wheels\n            for _, wheel in pairs(specWheels.wheels) do\n                local invRotInterita = 2.0 / (wheel.mass*wheel.radius * wheel.radius)\n                neededWheelsInertiaTorque = neededWheelsInertiaTorque + invRotInterita * self.differentialRotAcceleration * wheel.radius\n            end\n            neededWheelsInertiaTorque = neededWheelsInertiaTorque / (gearRatio*gearRatio)]]\n\n            local lastMotorRotSpeed = self.motorRotSpeed - self.motorRotAcceleration * (g_physicsDtLastValidNonInterpolated * 0.001 )\n            local lastDampedMotorRotSpeed = lastMotorRotSpeed / ( 1.0 + self.dampingRateFullThrottle / self.rotInertia * g_physicsDtLastValidNonInterpolated * 0.001 )\n\n            local neededInertiaTorque = ( self.motorRotSpeed - lastDampedMotorRotSpeed) / (g_physicsDtLastValidNonInterpolated * 0.001 ) * self.rotInertia\n\n            local lastMotorTorque = ( self.motorAppliedTorque - self.motorExternalTorque - neededInertiaTorque)\n\n            --print(string.format("load: %.3f expected torque: %.3f neededPtoTorque %.3f neededInertiaTorque %.4f", self.motorAppliedTorque, self.motorAvailableTorque, self.motorExternalTorque, neededInertiaTorque))\n\n            local totalMass = self.vehicle:getTotalMass()\n            local expectedAcc = lastMotorTorque * gearRatio / totalMass -- differential rad/s^2\n\n            -- The the difference in acceleration is due to gravity and thus will pull back the vehicle when changing gears and some other reasons(non-accounted mass(e.g.trees), collisions, wheel damping, wheel mass, .. .)\n            -- Use a fixed factor of 90% to separate the effect of the gravity\n            local uncalculatedAccFactor = 0.9\n            local gravityAcc = math.max(expectedAcc * uncalculatedAccFactor - math.max( self.differentialRotAccelerationSmoothed * gearSign, 0 ), 0 )\n\n            --print(string.format("expectedAcc: %.3f realAcc: %.3f %.3f gravityAcc: %.3f gr: %.2f mass %.1f speed: %.3f dt %.2fms", expectedAcc, self.vehicle.lastSpeedAcceleration*1000*1000, self.differentialRotAcceleration, gravityAcc, gearRatio, totalMass, self.vehicle.lastSpeedReal*1000, g_physicsDtLastValidNonInterpolated))\n\n            diffSpeedAfterChange = math.max(differentialRotSpeed - gravityAcc * self.gearChangeTime * 0.001 , 0 )\n\n            --log("differentialRotSpeed", differentialRotSpeed, "gravityAcc", gravityAcc, "expectedAcc", expectedAcc, "self.differentialRotAccelerationSmoothed", self.differentialRotAccelerationSmoothed, "gearRatio", gearRatio, "lastMotorTorque", lastMotorTorque, "neededInertiaTorque", neededInertiaTorque, "lastDampedMotorRotSpeed", lastDampedMotorRotSpeed, "lastMotorRotSpeed", lastMotorRotSpeed)\n        end\n\n        -- 2.Find the gear that gives the maximum power in the valid rpm range after the gear change\n        -- If none is valid, store the gear that will get closest to the valid rpm range\n\n        -- TODO allow some clutch slippage to extend the possible rpm range(e.g.when accelerating and switching from gear 1 to gear 2)\n\n        local maxPower = 0\n        local maxPowerGear = 0\n        for gear = 1 , #gears do\n            local rpm\n            if gear = = curGear then\n                rpm = clutchRpm\n            else\n                    rpm = diffSpeedAfterChange * math.abs(gears[gear].ratio * gearRatioMultiplier) * 30 / math.pi\n                end\n\n                -- if we could start in this gear we allow changes, no matter of rpm and power\n                    local startInGearFactor = self:getStartInGearFactor(gears[gear].ratio * gearRatioMultiplier)\n                    local minRpmFactor = 1\n                    if startInGearFactor < self.startGearThreshold then\n                        minRpmFactor = 0\n                    end\n\n                    -- current gear is always allowed since clutchRpm could be slightly higher or lower then the limits due to float 32\n                    if (rpm < = maxAllowedRpm and rpm > = minAllowedRpm * minRpmFactor) or gear = = curGear then\n                        local power = self:getTorqueCurveValue(rpm) * rpm\n                        --print(string.format(" power %.2f @ %.d %d", power, gear, rpm))\n                        if power > = maxPower then\n                            maxPower = power\n                            maxPowerGear = gear\n                        end\n                    end\n                end\n\n                --local curPower = self:getTorqueCurveValue(clutchRpm) * clutchRpm\n                --print(string.format("power %.2f @ %d rpms: %.2f %.2f diffSpeedAfterChange: %.10f drpm: %.2f", curPower, curGear, clutchRpm, diffSpeedAfterChange * gearRatio * 30 / math.pi, diffSpeedAfterChange, self.differentialRotAccelerationSmoothed * gearRatio * 30 / math.pi))\n\n                local neededPowerPct = 0.5\n\n                -- 3.Find the gear with the best tradeoff(lots of power with low rpm)\n                -- Or use the the gear will get closest to the valid rpm range if none of the gears are good\n                    if maxPowerGear ~ = 0 then\n                        local bestTradeoff = 0\n\n                        for gear = #gears, 1 , - 1 do\n                            local validGear = false\n                            local nextRpm\n                            if gear = = curGear then\n                                nextRpm = clutchRpm\n                            else\n                                    nextRpm = diffSpeedAfterChange * math.abs(gears[gear].ratio * gearRatioMultiplier) * 30 / math.pi\n                                end\n\n                                -- if we could start in this gear we allow changes, no matter of rpm and power\n                                    local startInGearFactor = self:getStartInGearFactor(gears[gear].ratio * gearRatioMultiplier)\n                                    local minRpmFactor = 1\n                                    local neededPowerPctGear = neededPowerPct\n                                    if startInGearFactor < self.startGearThreshold then\n                                        neededPowerPctGear = 0\n                                        minRpmFactor = 0\n                                    end\n\n                                    if nextRpm < = maxAllowedRpm and nextRpm > = minAllowedRpm * minRpmFactor or gear = = curGear then\n                                        local nextPower = self:getTorqueCurveValue(nextRpm) * nextRpm\n\n                                        -- Choose the gear if it gets close enough to the max power\n                                            if nextPower > = maxPower * neededPowerPctGear or gear = = curGear then\n                                                local powerFactor = (nextPower - maxPower * neededPowerPctGear) / (maxPower * ( 1 - neededPowerPctGear)) -- 0 when at 60% of maxPower, 1 when at maxPower\n                                                local curSpeedRpm = differentialRpm * math.abs(gears[gear].ratio * gearRatioMultiplier)\n                                                local rpmFactor = math.clamp((maxAllowedRpm - curSpeedRpm) / math.max(maxAllowedRpm - minAllowedRpm, 0.001 ), 0 , 2 )\n                                                if rpmFactor > 1 then\n                                                    rpmFactor = 1 - (rpmFactor - 1 ) * 4\n                                                end\n\n                                                local gearChangeFactor\n                                                if gear = = curGear then\n                                                    gearChangeFactor = 1\n                                                else\n                                                        gearChangeFactor = math.min( - gearChangeTimer / 2000 , 0.9 ) -- the longer we wait, the less penality we add for gear changes\n                                                        end\n\n                                                        local rpmPreferenceFactor = 0\n                                                        -- when shifting down the lower gear should have a higher rpm, otherwise we penalize it with -1\n                                                        if gear < curGear then\n                                                            rpmPreferenceFactor = math.clamp((nextRpm - clutchRpm) / 250 , - 1 , 0 )\n                                                        end\n\n                                                        -- when starting with a preselected/higher gear we force to use it as long as the factor is still valid\n                                                        if gear < self.bestGearSelected then\n                                                            local factor = self:getStartInGearFactor(gearRatio)\n                                                            if factor < self.startGearThreshold then\n                                                                gearChangeFactor = - 4\n                                                            end\n                                                        end\n\n                                                        -- prefer middle rpm range instead of upper and lower 20% of range\n                                                        rpmPreferenceFactor = rpmPreferenceFactor - ( 1 - math.min( math.sin(rpmFactor * math.pi) * 5 , 2 )) * 0.7\n\n                                                        -- if multiple gears are able to stay in the prefered rpm range, we always prefer the gear we are in until it\'s getting out of the range\n                                                            -- this prevents to much shifting when we have a lot of gears with small ratio steps\n                                                            -- only apply if rpmPreferenceFactor is postive so we do not negative influence the current gear\n                                                                if gear = = curGear and rpmPreferenceFactor > 0 then\n                                                                    rpmPreferenceFactor = rpmPreferenceFactor * 1.5\n                                                                end\n\n                                                                if math.abs(acceleratorPedal) < 0.0001 then\n                                                                    rpmFactor = 1 - rpmFactor -- choose a high rpm when decelerating\n                                                                else\n                                                                        rpmFactor = rpmFactor * 2\n                                                                    end\n\n                                                                    -- when just rolling allow downshifting to use motor brake when below 25% of rpm range\n                                                                    -- so we avoid hitting always the highest rpm on the lower gear(would be better for motor break, but sounds stupid)\n                                                                        if math.abs(acceleratorPedal) < 0.0001 then\n                                                                            if (clutchRpm - minRpmFactor) / (maxAllowedRpm - minRpmFactor) > 0.25 then\n                                                                                if gear < curGear then\n                                                                                    powerFactor = 0\n                                                                                    rpmFactor = 0\n                                                                                elseif gear = = curGear then\n                                                                                        powerFactor = 1\n                                                                                        rpmFactor = 1\n                                                                                    end\n                                                                                end\n                                                                            end\n\n                                                                            -- if we could start in the gear we don\'t care about the power and rpm preference\n                                                                                -- only apply to higher gears, so we won\'t accidentally rate lower gears higher than current gear if current gear is in higher rpms\n                                                                                    if gear > curGear then\n                                                                                        if startInGearFactor < self.startGearThreshold then\n                                                                                            powerFactor = 1\n                                                                                            rpmPreferenceFactor = 1\n                                                                                        end\n                                                                                    end\n\n                                                                                    local tradeoff = powerFactor + rpmFactor + gearChangeFactor + rpmPreferenceFactor\n\n                                                                                    if tradeoff > = bestTradeoff then\n                                                                                        bestTradeoff = tradeoff\n                                                                                        newGear = gear\n                                                                                        -- print(string.format("better tradeoff %.2f with %d power: %.2f vs %.2f @ %d rpm %.2f/%.2f vs %.2f factors: %.2f %.2f %.2f %.2f", tradeoff, gear, nextPower, maxPower, maxPowerGear, nextRpm, curSpeedRpm, clutchRpm, powerFactor, rpmFactor, gearChangeFactor, rpmPreferenceFactor))\n                                                                                        --else\n                                                                                            -- print(string.format("worse tradeoff %.2f with %d power: %.2f vs %.2f @ %d rpm %.2f/%.2f vs %.2f factors: %.2f %.2f %.2f %.2f", tradeoff, gear, nextPower, maxPower, maxPowerGear, nextRpm, curSpeedRpm, clutchRpm, powerFactor, rpmFactor, gearChangeFactor, rpmPreferenceFactor))\n                                                                                        end\n\n                                                                                        if VehicleDebug.state = = VehicleDebug.DEBUG_TRANSMISSION then\n                                                                                            gears[gear].lastTradeoff = tradeoff\n                                                                                            gears[gear].lastDiffSpeedAfterChange = gear = = curGear and diffSpeedAfterChange or nil\n                                                                                            gears[gear].lastPowerFactor = powerFactor\n                                                                                            gears[gear].lastRpmFactor = rpmFactor\n                                                                                            gears[gear].lastGearChangeFactor = gearChangeFactor\n                                                                                            gears[gear].lastRpmPreferenceFactor = rpmPreferenceFactor\n                                                                                            gears[gear].lastNextPower = nextPower\n                                                                                            gears[gear].nextPowerValid = true\n                                                                                            gears[gear].lastNextRpm = nextRpm\n                                                                                            gears[gear].nextRpmValid = true\n                                                                                            gears[gear].lastMaxPower = maxPower\n                                                                                            gears[gear].lastHasPower = true\n                                                                                        end\n\n                                                                                        validGear = true\n                                                                                    else\n                                                                                            if VehicleDebug.state = = VehicleDebug.DEBUG_TRANSMISSION then\n                                                                                                gears[gear].lastNextPower = nextPower\n                                                                                            end\n                                                                                        end\n                                                                                    end\n\n                                                                                    if not validGear then\n                                                                                        if VehicleDebug.state = = VehicleDebug.DEBUG_TRANSMISSION then\n                                                                                            gears[gear].lastTradeoff = 0\n                                                                                            gears[gear].lastPowerFactor = 0\n                                                                                            gears[gear].lastRpmFactor = 0\n                                                                                            gears[gear].lastGearChangeFactor = 0\n                                                                                            gears[gear].lastRpmPreferenceFactor = 0\n                                                                                            gears[gear].lastDiffSpeedAfterChange = gear = = curGear and diffSpeedAfterChange or nil\n                                                                                            gears[gear].lastNextRpm = nextRpm\n                                                                                            gears[gear].nextRpmValid = nextRpm < = maxAllowedRpm and nextRpm > = minAllowedRpm * minRpmFactor\n                                                                                            gears[gear].nextPowerValid = false\n                                                                                            gears[gear].lastMaxPower = maxPower\n                                                                                            gears[gear].lastHasPower = false\n                                                                                        end\n                                                                                    end\n                                                                                end\n                                                                            else\n                                                                                    local minDiffGear = 0\n                                                                                    local minDiff = math.huge\n                                                                                    for gear = 1 ,#gears do\n                                                                                        local rpm = diffSpeedAfterChange * math.abs(gears[gear].ratio * gearRatioMultiplier) * 30 / math.pi\n                                                                                        local diff = math.max(rpm - maxAllowedRpm, minAllowedRpm - rpm)\n                                                                                        if diff < minDiff then\n                                                                                            --print(string.format("better min diff gear: %d diff: %.2f rpm: %.2f" , gear, diff, rpm))\n                                                                                            minDiff = diff\n                                                                                            minDiffGear = gear\n                                                                                        end\n                                                                                    end\n                                                                                    newGear = minDiffGear\n                                                                                end\n\n                                                                                return newGear\n                                                                            end\n\n'})}),"\n",(0,a.jsx)(n.h3,{id:"getaccelerationlimit",children:"getAccelerationLimit"}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Description"})}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Definition"})}),"\n",(0,a.jsxs)(n.blockquote,{children:["\n",(0,a.jsx)(n.p,{children:"getAccelerationLimit()"}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Code"})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-lua",children:"function VehicleMotor:getAccelerationLimit()\n    return self.accelerationLimit\nend\n\n"})}),"\n",(0,a.jsx)(n.h3,{id:"getbestgear",children:"getBestGear"}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Description"})}),"\n",(0,a.jsxs)(n.blockquote,{children:["\n",(0,a.jsx)(n.p,{children:"Returns best gear"}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Definition"})}),"\n",(0,a.jsxs)(n.blockquote,{children:["\n",(0,a.jsx)(n.p,{children:"getBestGear(float acceleration, float wheelSpeedRpm, float accSafeMotorRpm, float requiredMotorPower, float\nrequiredMotorRpm)"}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,a.jsxs)(n.table,{children:[(0,a.jsx)(n.thead,{children:(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.th,{children:"float"}),(0,a.jsx)(n.th,{children:"acceleration"}),(0,a.jsx)(n.th,{children:"acceleration"})]})}),(0,a.jsxs)(n.tbody,{children:[(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:"float"}),(0,a.jsx)(n.td,{children:"wheelSpeedRpm"}),(0,a.jsx)(n.td,{children:"wheel speed rpm"})]}),(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:"float"}),(0,a.jsx)(n.td,{children:"accSafeMotorRpm"}),(0,a.jsx)(n.td,{children:"acc save motor rpm"})]}),(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:"float"}),(0,a.jsx)(n.td,{children:"requiredMotorPower"}),(0,a.jsx)(n.td,{children:"required wheel torque"})]}),(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:"float"}),(0,a.jsx)(n.td,{children:"requiredMotorRpm"}),(0,a.jsx)(n.td,{children:"required motor rpm"})]})]})]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Return Values"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,a.jsxs)(n.table,{children:[(0,a.jsx)(n.thead,{children:(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.th,{children:"float"}),(0,a.jsx)(n.th,{children:"bestGear"}),(0,a.jsx)(n.th,{children:"best gear"})]})}),(0,a.jsx)(n.tbody,{children:(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:"float"}),(0,a.jsx)(n.td,{children:"gearRatio"}),(0,a.jsx)(n.td,{children:"gear ratio"})]})})]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Code"})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-lua",children:"function VehicleMotor:getBestGear(acceleration, wheelSpeedRpm, accSafeMotorRpm, requiredMotorPower, requiredMotorRpm)\n    if math.abs(acceleration) < 0.001 then\n        acceleration = 1\n        if wheelSpeedRpm < 0 then\n            acceleration = - 1\n        end\n    end\n    if acceleration > 0 then\n        if self.minForwardGearRatio ~ = nil then\n            wheelSpeedRpm = math.max(wheelSpeedRpm, 0 )\n            local bestGearRatio = self:getBestGearRatio(wheelSpeedRpm, self.minForwardGearRatio, self.maxForwardGearRatio, accSafeMotorRpm, requiredMotorPower, requiredMotorRpm)\n            return 1 , bestGearRatio\n        else\n                return 1 , self.forwardGears[ 1 ].ratio\n            end\n        else\n                if self.minBackwardGearRatio ~ = nil then\n                    wheelSpeedRpm = math.max( - wheelSpeedRpm, 0 )\n                    local bestGearRatio = self:getBestGearRatio(wheelSpeedRpm, self.minBackwardGearRatio, self.maxBackwardGearRatio, accSafeMotorRpm, requiredMotorPower, requiredMotorRpm)\n                    return - 1 , - bestGearRatio\n                else\n                        if self.backwardGears ~ = nil then\n                            return - 1 , - self.backwardGears[ 1 ].ratio\n                        else\n                                return 1 , self.forwardGears[ 1 ].ratio\n                            end\n                        end\n                    end\n                end\n\n"})}),"\n",(0,a.jsx)(n.h3,{id:"getbestgearratio",children:"getBestGearRatio"}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Description"})}),"\n",(0,a.jsxs)(n.blockquote,{children:["\n",(0,a.jsx)(n.p,{children:"Returns best gear ratio"}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Definition"})}),"\n",(0,a.jsxs)(n.blockquote,{children:["\n",(0,a.jsx)(n.p,{children:"getBestGearRatio(float wheelSpeedRpm, float minRatio, float maxRatio, float accSafeMotorRpm, float requiredMotorPower,\nfloat requiredMotorRpm)"}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,a.jsxs)(n.table,{children:[(0,a.jsx)(n.thead,{children:(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.th,{children:"float"}),(0,a.jsx)(n.th,{children:"wheelSpeedRpm"}),(0,a.jsx)(n.th,{children:"wheel speed rpm"})]})}),(0,a.jsxs)(n.tbody,{children:[(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:"float"}),(0,a.jsx)(n.td,{children:"minRatio"}),(0,a.jsx)(n.td,{children:"min ratio"})]}),(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:"float"}),(0,a.jsx)(n.td,{children:"maxRatio"}),(0,a.jsx)(n.td,{children:"max ratio"})]}),(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:"float"}),(0,a.jsx)(n.td,{children:"accSafeMotorRpm"}),(0,a.jsx)(n.td,{children:"acc save motor rpm"})]}),(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:"float"}),(0,a.jsx)(n.td,{children:"requiredMotorPower"}),(0,a.jsx)(n.td,{children:"the required motor power [kW] (can be bigger than what the motor can actually achieve)"})]}),(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:"float"}),(0,a.jsx)(n.td,{children:"requiredMotorRpm"}),(0,a.jsx)(n.td,{children:"fixed motor rpm to be used (if not 0)"})]})]})]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Return Values"})}),"\n\n\n\n\n\n\n\n\n",(0,a.jsx)(n.table,{children:(0,a.jsx)(n.thead,{children:(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.th,{children:"float"}),(0,a.jsx)(n.th,{children:"bestGearRatio"}),(0,a.jsx)(n.th,{children:"best gear ratio"})]})})}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Code"})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-lua",children:'function VehicleMotor:getBestGearRatio(wheelSpeedRpm, minRatio, maxRatio, accSafeMotorRpm, requiredMotorPower, requiredMotorRpm)\n\n    if requiredMotorRpm ~ = 0 then\n        local gearRatio = math.max(requiredMotorRpm - accSafeMotorRpm, requiredMotorRpm * 0.8 ) / math.max(wheelSpeedRpm, 0.001 )\n        gearRatio = math.clamp(gearRatio, minRatio, maxRatio)\n        return gearRatio\n    end\n\n    -- Use a minimum wheel rpm to avoid that gearRatio is ignored\n    wheelSpeedRpm = math.max(wheelSpeedRpm, 0.0001 )\n\n    local bestMotorPower = 0\n    local bestGearRatio = minRatio\n    --local bestRPM = 0\n    -- TODO make this more efficient\n    for gearRatio = minRatio, maxRatio, 0.5 do\n        local motorRpm = wheelSpeedRpm * gearRatio\n        if motorRpm > self.maxRpm - accSafeMotorRpm then\n            break\n        end\n        local motorPower = self:getTorqueCurveValue( math.max(motorRpm, self.minRpm)) * motorRpm * math.pi / 30\n        if motorPower > bestMotorPower then\n            bestMotorPower = motorPower\n            bestGearRatio = gearRatio\n            --bestRPM = motorRpm\n        end\n\n        if motorPower > = requiredMotorPower then\n            break\n        end\n    end\n    --print(string.format("Selected best gear: %f, %.2fkW rpm %.2f wheel %.2f", bestGearRatio, bestMotorPower, bestRPM, wheelSpeedRpm,))\n\n    return bestGearRatio\nend\n\n'})}),"\n",(0,a.jsx)(n.h3,{id:"getbeststartgear",children:"getBestStartGear"}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Description"})}),"\n",(0,a.jsxs)(n.blockquote,{children:["\n",(0,a.jsx)(n.p,{children:"Returns the highest gear possible to start"}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Definition"})}),"\n",(0,a.jsxs)(n.blockquote,{children:["\n",(0,a.jsx)(n.p,{children:"getBestStartGear(table gears)"}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n",(0,a.jsx)(n.table,{children:(0,a.jsx)(n.thead,{children:(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.th,{children:"table"}),(0,a.jsx)(n.th,{children:"gears"}),(0,a.jsx)(n.th,{children:"gears"})]})})}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Return Values"})}),"\n\n\n\n\n\n\n\n\n",(0,a.jsx)(n.table,{children:(0,a.jsx)(n.thead,{children:(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.th,{children:"table"}),(0,a.jsx)(n.th,{children:"bestGear"}),(0,a.jsx)(n.th,{children:"best gear to start"})]})})}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Code"})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-lua",children:"function VehicleMotor:getBestStartGear(gears)\n    local directionMultiplier = self.directionChangeUseGroup and 1 or self.currentDirection\n\n    -- search for the first gear that is below our start gear threshold\n        -- we start at the highest gear and go downwards\n        -- if we don't find any gear below the threshold we return the lowest gear\n\n            local minFactor = math.huge\n            local minFactorGear, minFactorGroup = 1 , 1\n\n            local maxFactor = 0\n            local maxFactorGear, maxFactorGroup = 1 , 1 -- use min gear in min group as default return value\n            if self.gearGroups ~ = nil then\n                if self:getUseAutomaticGroupShifting() then\n                    local start, limit, step = # self.gearGroups, 1 , - 1\n                    if self.currentDirection < 0 then\n                        start, limit, step = 1 , # self.gearGroups, 1\n                    end\n\n                    for j = start, limit, step do\n                        local groupRatio = self.gearGroups[j].ratio * directionMultiplier\n                        if math.sign(groupRatio) = = self.currentDirection or not self.directionChangeUseGroup then\n                            for i = #gears, 1 , - 1 do\n                                local factor = self:getStartInGearFactor(gears[i].ratio * groupRatio)\n                                if factor < self.startGearThreshold and maxFactor = = 0 then\n                                    maxFactor = factor\n                                    maxFactorGear = i\n                                    maxFactorGroup = j\n                                end\n\n                                if factor < minFactor then\n                                    minFactor = factor\n                                    minFactorGear = i\n                                    minFactorGroup = j\n                                end\n                            end\n                        end\n                    end\n                end\n            else\n                    local gearRatioMultiplier = self:getGearRatioMultiplier()\n                    for i = #gears, 1 , - 1 do\n                        local factor = self:getStartInGearFactor(gears[i].ratio * gearRatioMultiplier)\n                        if factor < self.startGearThreshold and maxFactor = = 0 then\n                            maxFactor = factor\n                            maxFactorGear = i\n                        end\n\n                        if factor < minFactor then\n                            minFactor = factor\n                            minFactorGear = i\n                        end\n                    end\n                end\n\n                -- return the gear with the lowest factor if we don't find any gear below self.startGearThreshold\n                    if maxFactor = = 0 then\n                        return minFactorGear, minFactorGroup\n                    end\n\n                    return maxFactorGear, maxFactorGroup\n                end\n\n"})}),"\n",(0,a.jsx)(n.h3,{id:"getbrakeforce",children:"getBrakeForce"}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Description"})}),"\n",(0,a.jsxs)(n.blockquote,{children:["\n",(0,a.jsx)(n.p,{children:"Returns brake force"}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Definition"})}),"\n",(0,a.jsxs)(n.blockquote,{children:["\n",(0,a.jsx)(n.p,{children:"getBrakeForce()"}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Return Values"})}),"\n\n\n\n\n\n\n\n\n",(0,a.jsx)(n.table,{children:(0,a.jsx)(n.thead,{children:(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.th,{children:"table"}),(0,a.jsx)(n.th,{children:"brakeForce"}),(0,a.jsx)(n.th,{children:"brake force"})]})})}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Code"})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-lua",children:"function VehicleMotor:getBrakeForce()\n    return self.brakeForce\nend\n\n"})}),"\n",(0,a.jsx)(n.h3,{id:"getcanmotorrun",children:"getCanMotorRun"}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Description"})}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Definition"})}),"\n",(0,a.jsxs)(n.blockquote,{children:["\n",(0,a.jsx)(n.p,{children:"getCanMotorRun()"}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Code"})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-lua",children:"function VehicleMotor:getCanMotorRun()\n    if self.gearShiftMode = = VehicleMotor.SHIFT_MODE_MANUAL_CLUTCH then\n        if not self.vehicle:getIsMotorStarted() then\n            if self.backwardGears or self.forwardGears then\n                if self.manualClutchValue = = 0 and self.maxGearRatio ~ = 0 then\n                    local factor = 1\n                    local motorRpm = self:getNonClampedMotorRpm()\n                    if motorRpm > 0 then\n                        factor = ( self:getClutchRpm() + 50 ) / motorRpm\n                    end\n\n                    if factor < 0.2 then\n                        return false , VehicleMotor.REASON_CLUTCH_NOT_ENGAGED\n                    end\n                end\n            end\n        end\n    end\n\n    return true\nend\n\n"})}),"\n",(0,a.jsx)(n.h3,{id:"getclutchpedal",children:"getClutchPedal"}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Description"})}),"\n",(0,a.jsxs)(n.blockquote,{children:["\n",(0,a.jsx)(n.p,{children:"Returns clutch pedal state"}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Definition"})}),"\n",(0,a.jsxs)(n.blockquote,{children:["\n",(0,a.jsx)(n.p,{children:"getClutchPedal()"}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Return Values"})}),"\n\n\n\n\n\n\n\n\n",(0,a.jsx)(n.table,{children:(0,a.jsx)(n.thead,{children:(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.th,{children:"table"}),(0,a.jsx)(n.th,{children:"state"}),(0,a.jsx)(n.th,{children:"state [0-1]"})]})})}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Code"})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-lua",children:"function VehicleMotor:getClutchPedal()\n    if not self.vehicle.isServer or self.gearShiftMode = = VehicleMotor.SHIFT_MODE_MANUAL_CLUTCH then\n        return self.manualClutchValue\n    end\n\n    local clutchRpm = self:getNonClampedMotorRpm()\n    if clutchRpm = = 0 then\n        return 0\n    end\n\n    return 1 - math.max( math.min(( self:getClutchRotSpeed() * 30 / math.pi + 50 ) / clutchRpm, 1 ), 0 ) -- have 50 rpm tolerance\nend\n\n"})}),"\n",(0,a.jsx)(n.h3,{id:"getclutchrotspeed",children:"getClutchRotSpeed"}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Description"})}),"\n",(0,a.jsxs)(n.blockquote,{children:["\n",(0,a.jsx)(n.p,{children:"Returns clutch rot speed"}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Definition"})}),"\n",(0,a.jsxs)(n.blockquote,{children:["\n",(0,a.jsx)(n.p,{children:"getClutchRotSpeed()"}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Return Values"})}),"\n\n\n\n\n\n\n\n\n",(0,a.jsx)(n.table,{children:(0,a.jsx)(n.thead,{children:(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.th,{children:"table"}),(0,a.jsx)(n.th,{children:"rotSpeed"}),(0,a.jsx)(n.th,{children:"rot speed"})]})})}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Code"})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-lua",children:"function VehicleMotor:getClutchRotSpeed()\n    return self.differentialRotSpeed * self.gearRatio\nend\n\n"})}),"\n",(0,a.jsx)(n.h3,{id:"getclutchrpm",children:"getClutchRpm"}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Description"})}),"\n",(0,a.jsxs)(n.blockquote,{children:["\n",(0,a.jsx)(n.p,{children:"Returns clutch rpm"}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Definition"})}),"\n",(0,a.jsxs)(n.blockquote,{children:["\n",(0,a.jsx)(n.p,{children:"getClutchRpm()"}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Return Values"})}),"\n\n\n\n\n\n\n\n\n",(0,a.jsx)(n.table,{children:(0,a.jsx)(n.thead,{children:(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.th,{children:"table"}),(0,a.jsx)(n.th,{children:"clutchRpm"}),(0,a.jsx)(n.th,{children:"clutch rpm"})]})})}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Code"})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-lua",children:"function VehicleMotor:getClutchRpm()\n    return self.differentialRotSpeed * self.gearRatio * 30 / math.pi\nend\n\n"})}),"\n",(0,a.jsx)(n.h3,{id:"getcurmaxrpm",children:"getCurMaxRpm"}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Description"})}),"\n",(0,a.jsxs)(n.blockquote,{children:["\n",(0,a.jsx)(n.p,{children:"Returns current max rpm"}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Definition"})}),"\n",(0,a.jsxs)(n.blockquote,{children:["\n",(0,a.jsx)(n.p,{children:"getCurMaxRpm()"}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Return Values"})}),"\n\n\n\n\n\n\n\n\n",(0,a.jsx)(n.table,{children:(0,a.jsx)(n.thead,{children:(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.th,{children:"table"}),(0,a.jsx)(n.th,{children:"maxRpm"}),(0,a.jsx)(n.th,{children:"current max rpm"})]})})}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Code"})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-lua",children:"function VehicleMotor:getCurMaxRpm()\n    local maxRpm = self.maxRpm\n\n    local gearRatio = self:getGearRatio()\n    if gearRatio ~ = 0 then\n        --local speedLimit = self.speedLimit * 0.277778\n        local speedLimit = math.min( self.speedLimit, math.max( self.speedLimitAcc, self.vehicle.lastSpeedReal * 3600 )) * 0.277778\n        if gearRatio > 0 then\n            speedLimit = math.min(speedLimit, self.maxForwardSpeed)\n        else\n                speedLimit = math.min(speedLimit, self.maxBackwardSpeed)\n            end\n\n            maxRpm = math.min(maxRpm, speedLimit * 30 / math.pi * math.abs(gearRatio))\n        end\n\n        maxRpm = math.min(maxRpm, self.rpmLimit)\n        return maxRpm\n    end\n\n"})}),"\n",(0,a.jsx)(n.h3,{id:"getdampingratefullthrottle",children:"getDampingRateFullThrottle"}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Description"})}),"\n",(0,a.jsxs)(n.blockquote,{children:["\n",(0,a.jsx)(n.p,{children:"Returns the damping rate of the motor if the acceleration pedal is 1"}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Definition"})}),"\n",(0,a.jsxs)(n.blockquote,{children:["\n",(0,a.jsx)(n.p,{children:"getDampingRateFullThrottle()"}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Return Values"})}),"\n\n\n\n\n\n\n\n\n",(0,a.jsx)(n.table,{children:(0,a.jsx)(n.thead,{children:(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.th,{children:"table"}),(0,a.jsx)(n.th,{children:"dampingRate"}),(0,a.jsx)(n.th,{children:"damping rate [t m^2 s^-1]"})]})})}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Code"})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-lua",children:"function VehicleMotor:getDampingRateFullThrottle()\n    return self.dampingRateFullThrottle\nend\n\n"})}),"\n",(0,a.jsx)(n.h3,{id:"getdampingratezerothrottleclutchdisengaged",children:"getDampingRateZeroThrottleClutchDisengaged"}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Description"})}),"\n",(0,a.jsxs)(n.blockquote,{children:["\n",(0,a.jsx)(n.p,{children:"Returns the damping rate of the motor if the acceleration pedal is 0 and the clutch is disengaged"}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Definition"})}),"\n",(0,a.jsxs)(n.blockquote,{children:["\n",(0,a.jsx)(n.p,{children:"getDampingRateZeroThrottleClutchDisengaged()"}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Return Values"})}),"\n\n\n\n\n\n\n\n\n",(0,a.jsx)(n.table,{children:(0,a.jsx)(n.thead,{children:(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.th,{children:"table"}),(0,a.jsx)(n.th,{children:"dampingRate"}),(0,a.jsx)(n.th,{children:"damping rate [t m^2 s^-1]"})]})})}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Code"})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-lua",children:"function VehicleMotor:getDampingRateZeroThrottleClutchDisengaged()\n    return self.dampingRateZeroThrottleClutchDisengaged\nend\n\n"})}),"\n",(0,a.jsx)(n.h3,{id:"getdampingratezerothrottleclutchengaged",children:"getDampingRateZeroThrottleClutchEngaged"}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Description"})}),"\n",(0,a.jsxs)(n.blockquote,{children:["\n",(0,a.jsx)(n.p,{children:"Returns the damping rate of the motor if the acceleration pedal is 0 and the clutch is engaged"}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Definition"})}),"\n",(0,a.jsxs)(n.blockquote,{children:["\n",(0,a.jsx)(n.p,{children:"getDampingRateZeroThrottleClutchEngaged()"}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Return Values"})}),"\n\n\n\n\n\n\n\n\n",(0,a.jsx)(n.table,{children:(0,a.jsx)(n.thead,{children:(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.th,{children:"table"}),(0,a.jsx)(n.th,{children:"dampingRate"}),(0,a.jsx)(n.th,{children:"damping rate [t m^2 s^-1]"})]})})}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Code"})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-lua",children:"function VehicleMotor:getDampingRateZeroThrottleClutchEngaged()\n    return self.dampingRateZeroThrottleClutchEngaged\nend\n\n"})}),"\n",(0,a.jsx)(n.h3,{id:"getdrivingdirection",children:"getDrivingDirection"}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Description"})}),"\n",(0,a.jsxs)(n.blockquote,{children:["\n",(0,a.jsx)(n.p,{children:"Returns the current driving direction or preselected direction"}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Definition"})}),"\n",(0,a.jsxs)(n.blockquote,{children:["\n",(0,a.jsx)(n.p,{children:"getDrivingDirection()"}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Code"})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-lua",children:"function VehicleMotor:getDrivingDirection()\n    if self.directionChangeMode = = VehicleMotor.DIRECTION_CHANGE_MODE_MANUAL or self.gearShiftMode ~ = VehicleMotor.SHIFT_MODE_AUTOMATIC or( self.backwardGears or self.forwardGears) then\n        return self.currentDirection * self.transmissionDirection\n    else\n            if self.vehicle:getLastSpeed() > 0.95 then\n                return self.vehicle.movingDirection * self.transmissionDirection\n            end\n        end\n\n        return 0\n    end\n\n"})}),"\n",(0,a.jsx)(n.h3,{id:"getequalizedmotorrpm",children:"getEqualizedMotorRpm"}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Description"})}),"\n",(0,a.jsxs)(n.blockquote,{children:["\n",(0,a.jsx)(n.p,{children:"Returns equalized motor rpm"}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Definition"})}),"\n",(0,a.jsxs)(n.blockquote,{children:["\n",(0,a.jsx)(n.p,{children:"getEqualizedMotorRpm()"}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Return Values"})}),"\n\n\n\n\n\n\n\n\n",(0,a.jsx)(n.table,{children:(0,a.jsx)(n.thead,{children:(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.th,{children:"table"}),(0,a.jsx)(n.th,{children:"equalizedMotorRpm"}),(0,a.jsx)(n.th,{children:"equalized motor rpm"})]})})}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Code"})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-lua",children:"function VehicleMotor:getEqualizedMotorRpm()\n    return self.equalizedMotorRpm\nend\n\n"})}),"\n",(0,a.jsx)(n.h3,{id:"getgeargrouptodisplay",children:"getGearGroupToDisplay"}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Description"})}),"\n",(0,a.jsxs)(n.blockquote,{children:["\n",(0,a.jsx)(n.p,{children:"Returns the current gear group"}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Definition"})}),"\n",(0,a.jsxs)(n.blockquote,{children:["\n",(0,a.jsx)(n.p,{children:"getGearGroupToDisplay()"}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,a.jsx)(n.table,{children:(0,a.jsx)(n.thead,{children:(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.th,{children:"any"}),(0,a.jsx)(n.th,{children:"isDashboard"})]})})}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Return Values"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,a.jsxs)(n.table,{children:[(0,a.jsx)(n.thead,{children:(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.th,{children:"any"}),(0,a.jsx)(n.th,{children:"group"}),(0,a.jsx)(n.th,{children:"group"})]})}),(0,a.jsx)(n.tbody,{children:(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:"any"}),(0,a.jsx)(n.td,{children:"groupsAvailable"}),(0,a.jsx)(n.td,{children:"groupsAvailable"})]})})]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Code"})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-lua",children:'function VehicleMotor:getGearGroupToDisplay(isDashboard)\n    local gearGroupName, available = "N" , false\n    if self.backwardGears or self.forwardGears then\n        if self.gearGroups ~ = nil then\n            if self.activeGearGroupIndex > 0 then\n                local gearGroup = self.gearGroups[ self.activeGearGroupIndex]\n                if gearGroup ~ = nil then\n                    if isDashboard then\n                        gearGroupName = gearGroup.dashboardName or gearGroup.name\n                    else\n                            gearGroupName = gearGroup.name\n                        end\n                    end\n                end\n\n                available = true\n            end\n        end\n\n        return gearGroupName, available\n    end\n\n'})}),"\n",(0,a.jsx)(n.h3,{id:"getgearinfotodisplay",children:"getGearInfoToDisplay"}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Description"})}),"\n",(0,a.jsxs)(n.blockquote,{children:["\n",(0,a.jsx)(n.p,{children:"Returns the current gear information to display"}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Definition"})}),"\n",(0,a.jsxs)(n.blockquote,{children:["\n",(0,a.jsx)(n.p,{children:"getGearInfoToDisplay()"}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Return Values"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,a.jsxs)(n.table,{children:[(0,a.jsx)(n.thead,{children:(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.th,{children:"any"}),(0,a.jsx)(n.th,{children:"gear"}),(0,a.jsx)(n.th,{children:"gear"})]})}),(0,a.jsxs)(n.tbody,{children:[(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:"any"}),(0,a.jsx)(n.td,{children:"available"}),(0,a.jsx)(n.td,{children:"gears are available"})]}),(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:"any"}),(0,a.jsx)(n.td,{children:"isAutomatic"}),(0,a.jsx)(n.td,{children:"is variable transmission"})]}),(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:"any"}),(0,a.jsx)(n.td,{children:"prevGearName"}),(0,a.jsx)(n.td,{children:"previous gear name"})]}),(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:"any"}),(0,a.jsx)(n.td,{children:"nextGearName"}),(0,a.jsx)(n.td,{children:"next gear name"})]}),(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:"any"}),(0,a.jsx)(n.td,{children:"prevPrevGearName"}),(0,a.jsx)(n.td,{children:"second previous gear name"})]}),(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:"any"}),(0,a.jsx)(n.td,{children:"nextNextGearName"}),(0,a.jsx)(n.td,{children:"second next gear name"})]}),(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:"any"}),(0,a.jsx)(n.td,{children:"isGearChanging"}),(0,a.jsx)(n.td,{children:"is currently changing the gear"})]})]})]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Code"})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-lua",children:'function VehicleMotor:getGearInfoToDisplay()\n    local gearName, available = "N" , false\n    local prevGearName, nextGearName\n    local prevPrevGearName, nextNextGearName\n    local isAutomatic = false\n    local isGearChanging = false\n\n    if self.backwardGears or self.forwardGears then\n        if self.targetGear > 0 then\n            local gear = self.currentGears[ self.targetGear]\n            if gear ~ = nil then\n                local displayDirection = self.currentDirection\n                local gearNameDirection = self.currentGears = = self.forwardGears and self.currentDirection or 1\n\n                gearName = gearNameDirection = = 1 and gear.name or gear.reverseName\n\n                local prevGear = self.currentGears[ self.targetGear + 1 * - displayDirection]\n                if prevGear ~ = nil then\n                    prevGearName = gearNameDirection = = 1 and prevGear.name or prevGear.reverseName\n\n                    prevGear = self.currentGears[ self.targetGear + 2 * - displayDirection]\n                    if prevGear ~ = nil then\n                        prevPrevGearName = gearNameDirection = = 1 and prevGear.name or prevGear.reverseName\n                    end\n                end\n\n                local nextGear = self.currentGears[ self.targetGear + 1 * displayDirection]\n                if nextGear ~ = nil then\n                    nextGearName = gearNameDirection = = 1 and nextGear.name or nextGear.reverseName\n\n                    nextGear = self.currentGears[ self.targetGear + 2 * displayDirection]\n                    if nextGear ~ = nil then\n                        nextNextGearName = gearNameDirection = = 1 and nextGear.name or nextGear.reverseName\n                    end\n                end\n\n                if self.gear ~ = self.targetGear then\n                    isGearChanging = true\n                end\n            end\n        end\n\n        available = true\n    else\n            local direction = self:getDrivingDirection()\n            if direction > 0 then\n                gearName = "D"\n                prevGearName = "N"\n            elseif direction < 0 then\n                    gearName = "R"\n                    nextGearName = "N"\n                else\n                        nextGearName = "D"\n                        prevGearName = "R"\n                    end\n\n                    isAutomatic = true\n                end\n\n                return gearName, available, isAutomatic, prevGearName, nextGearName, prevPrevGearName, nextNextGearName, isGearChanging\n            end\n\n'})}),"\n",(0,a.jsx)(n.h3,{id:"getgearratio",children:"getGearRatio"}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Description"})}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Definition"})}),"\n",(0,a.jsxs)(n.blockquote,{children:["\n",(0,a.jsx)(n.p,{children:"getGearRatio()"}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Code"})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-lua",children:"function VehicleMotor:getGearRatio()\n    return self.gearRatio\nend\n\n"})}),"\n",(0,a.jsx)(n.h3,{id:"getgearratiomultiplier",children:"getGearRatioMultiplier"}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Description"})}),"\n",(0,a.jsxs)(n.blockquote,{children:["\n",(0,a.jsx)(n.p,{children:"Returns ratio from current selected gear group or 1 if non is defined"}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Definition"})}),"\n",(0,a.jsxs)(n.blockquote,{children:["\n",(0,a.jsx)(n.p,{children:"getGearRatioMultiplier()"}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Return Values"})}),"\n\n\n\n\n\n\n\n\n",(0,a.jsx)(n.table,{children:(0,a.jsx)(n.thead,{children:(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.th,{children:"any"}),(0,a.jsx)(n.th,{children:"ratio"}),(0,a.jsx)(n.th,{children:"ratio"})]})})}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Code"})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-lua",children:"function VehicleMotor:getGearRatioMultiplier()\n    local multiplier = self.directionChangeUseGroup and 1 or self.currentDirection\n    if self.gearGroups ~ = nil then\n        if self.activeGearGroupIndex = = 0 then\n            return 0\n        end\n\n        local group = self.gearGroups[ self.activeGearGroupIndex]\n        if group ~ = nil then\n            return group.ratio * multiplier\n        end\n    end\n\n    return multiplier\nend\n\n"})}),"\n",(0,a.jsx)(n.h3,{id:"getgeartodisplay",children:"getGearToDisplay"}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Description"})}),"\n",(0,a.jsxs)(n.blockquote,{children:["\n",(0,a.jsx)(n.p,{children:"Returns the current gear as string"}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Definition"})}),"\n",(0,a.jsxs)(n.blockquote,{children:["\n",(0,a.jsx)(n.p,{children:"getGearToDisplay()"}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,a.jsx)(n.table,{children:(0,a.jsx)(n.thead,{children:(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.th,{children:"any"}),(0,a.jsx)(n.th,{children:"isDashboard"})]})})}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Return Values"})}),"\n\n\n\n\n\n\n\n\n",(0,a.jsx)(n.table,{children:(0,a.jsx)(n.thead,{children:(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.th,{children:"any"}),(0,a.jsx)(n.th,{children:"gear"}),(0,a.jsx)(n.th,{children:"gear"})]})})}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Code"})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-lua",children:'function VehicleMotor:getGearToDisplay(isDashboard)\n    local gearName = "N"\n\n    if self.backwardGears or self.forwardGears then\n        if self.targetGear > 0 then\n            local gear = self.currentGears[ self.targetGear]\n            if gear ~ = nil then\n                local gearNameDirection = self.currentGears = = self.forwardGears and self.currentDirection or 1\n\n                if isDashboard then\n                    gearName = gearNameDirection = = 1 and(gear.dashboardName or gear.name) or(gear.dashboardReverseName or gear.reverseName)\n                else\n                        gearName = gearNameDirection = = 1 and gear.name or gear.reverseName\n                    end\n                end\n            end\n        else\n                local direction = self:getDrivingDirection()\n                if direction > 0 then\n                    gearName = "D"\n                elseif direction < 0 then\n                        gearName = "R"\n                    end\n                end\n\n                return gearName\n            end\n\n'})}),"\n",(0,a.jsx)(n.h3,{id:"getisgearchangeallowed",children:"getIsGearChangeAllowed"}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Description"})}),"\n",(0,a.jsxs)(n.blockquote,{children:["\n",(0,a.jsx)(n.p,{children:"Returns is shifting is allowed due to clutch pedal state"}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Definition"})}),"\n",(0,a.jsxs)(n.blockquote,{children:["\n",(0,a.jsx)(n.p,{children:"getIsGearChangeAllowed()"}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Return Values"})}),"\n\n\n\n\n\n\n\n\n",(0,a.jsx)(n.table,{children:(0,a.jsx)(n.thead,{children:(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.th,{children:"any"}),(0,a.jsx)(n.th,{children:"allowed"}),(0,a.jsx)(n.th,{children:"allowed"})]})})}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Code"})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-lua",children:"function VehicleMotor:getIsGearChangeAllowed()\n    if self.gearShiftMode = = VehicleMotor.SHIFT_MODE_MANUAL_CLUTCH then\n        if self.gearType ~ = VehicleMotor.TRANSMISSION_TYPE.POWERSHIFT then\n            return self.manualClutchValue > 0.5\n        end\n    end\n\n    return true\nend\n\n"})}),"\n",(0,a.jsx)(n.h3,{id:"getisgeargroupchangeallowed",children:"getIsGearGroupChangeAllowed"}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Description"})}),"\n",(0,a.jsxs)(n.blockquote,{children:["\n",(0,a.jsx)(n.p,{children:"Returns is shifting is allowed due to clutch pedal state"}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Definition"})}),"\n",(0,a.jsxs)(n.blockquote,{children:["\n",(0,a.jsx)(n.p,{children:"getIsGearGroupChangeAllowed()"}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Return Values"})}),"\n\n\n\n\n\n\n\n\n",(0,a.jsx)(n.table,{children:(0,a.jsx)(n.thead,{children:(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.th,{children:"any"}),(0,a.jsx)(n.th,{children:"allowed"}),(0,a.jsx)(n.th,{children:"allowed"})]})})}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Code"})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-lua",children:"function VehicleMotor:getIsGearGroupChangeAllowed()\n    if self.gearGroups = = nil then\n        return false\n    end\n\n    if self.gearShiftMode = = VehicleMotor.SHIFT_MODE_MANUAL_CLUTCH then\n        if self.groupType ~ = VehicleMotor.TRANSMISSION_TYPE.POWERSHIFT then\n            return self.manualClutchValue > 0.5\n        end\n    end\n\n    return true\nend\n\n"})}),"\n",(0,a.jsx)(n.h3,{id:"getisinneutral",children:"getIsInNeutral"}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Description"})}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Definition"})}),"\n",(0,a.jsxs)(n.blockquote,{children:["\n",(0,a.jsx)(n.p,{children:"getIsInNeutral()"}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Code"})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-lua",children:"function VehicleMotor:getIsInNeutral()\n    if self.backwardGears or self.forwardGears then\n        if self.gear = = 0 and self.targetGear = = 0 then\n            return true\n        end\n    end\n\n    return false\nend\n\n"})}),"\n",(0,a.jsx)(n.h3,{id:"getlastmodulatedmotorrpm",children:"getLastModulatedMotorRpm"}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Description"})}),"\n",(0,a.jsxs)(n.blockquote,{children:["\n",(0,a.jsx)(n.p,{children:"Returns last motor rpm modulated"}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Definition"})}),"\n",(0,a.jsxs)(n.blockquote,{children:["\n",(0,a.jsx)(n.p,{children:"getLastModulatedMotorRpm()"}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Return Values"})}),"\n\n\n\n\n\n\n\n\n",(0,a.jsx)(n.table,{children:(0,a.jsx)(n.thead,{children:(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.th,{children:"any"}),(0,a.jsx)(n.th,{children:"lastModulatedMotorRpm"}),(0,a.jsx)(n.th,{children:"last modulated motor rpm"})]})})}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Code"})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-lua",children:"function VehicleMotor:getLastModulatedMotorRpm()\n    local modulationIntensity = math.clamp(( self.smoothedLoadPercentage - MODULATION_RPM_MIN_REF_LOAD) / (MODULATION_RPM_MAX_REF_LOAD - MODULATION_RPM_MIN_REF_LOAD), MODULATION_RPM_MIN_INTENSITY, 1 )\n    local modulationOffset = self.lastModulationPercentage * (MODULATION_RPM_MAX_OFFSET * modulationIntensity) * self.constantRpmCharge\n\n    -- apply only if clutch is released since with slipping clutch the rpm is already decreased\n        local loadChangeChargeDrop = 0\n        if self:getClutchPedal() < 0.1 and self.minGearRatio > 0 then\n            local rpmRange = self.maxRpm - self.minRpm\n            local dropScale = ( self.lastMotorRpm - self.minRpm) / rpmRange * 0.5\n            loadChangeChargeDrop = self.loadPercentageChangeCharge * rpmRange * dropScale\n        else\n                self.loadPercentageChangeCharge = 0\n            end\n\n            if self.lastMotorRpm = = 0 then\n                return 0\n            end\n\n            return self.lastMotorRpm + modulationOffset - loadChangeChargeDrop\n        end\n\n"})}),"\n",(0,a.jsx)(n.h3,{id:"getlastmotorrpm",children:"getLastMotorRpm"}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Description"})}),"\n",(0,a.jsxs)(n.blockquote,{children:["\n",(0,a.jsx)(n.p,{children:"Returns last motor rpm damped"}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Definition"})}),"\n",(0,a.jsxs)(n.blockquote,{children:["\n",(0,a.jsx)(n.p,{children:"getLastMotorRpm()"}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Return Values"})}),"\n\n\n\n\n\n\n\n\n",(0,a.jsx)(n.table,{children:(0,a.jsx)(n.thead,{children:(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.th,{children:"any"}),(0,a.jsx)(n.th,{children:"lastMotorRpm"}),(0,a.jsx)(n.th,{children:"last motor rpm"})]})})}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Code"})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-lua",children:"function VehicleMotor:getLastMotorRpm()\n    return self.lastMotorRpm\nend\n\n"})}),"\n",(0,a.jsx)(n.h3,{id:"getlastrealmotorrpm",children:"getLastRealMotorRpm"}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Description"})}),"\n",(0,a.jsxs)(n.blockquote,{children:["\n",(0,a.jsx)(n.p,{children:"Returns last motor rpm real"}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Definition"})}),"\n",(0,a.jsxs)(n.blockquote,{children:["\n",(0,a.jsx)(n.p,{children:"getLastRealMotorRpm()"}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Return Values"})}),"\n\n\n\n\n\n\n\n\n",(0,a.jsx)(n.table,{children:(0,a.jsx)(n.thead,{children:(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.th,{children:"any"}),(0,a.jsx)(n.th,{children:"lastMotorRpm"}),(0,a.jsx)(n.th,{children:"last motor rpm"})]})})}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Code"})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-lua",children:"function VehicleMotor:getLastRealMotorRpm()\n    return self.lastRealMotorRpm\nend\n\n"})}),"\n",(0,a.jsx)(n.h3,{id:"getmanualclutchpedal",children:"getManualClutchPedal"}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Description"})}),"\n",(0,a.jsxs)(n.blockquote,{children:["\n",(0,a.jsx)(n.p,{children:"Returns manual clutch pedal state"}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Definition"})}),"\n",(0,a.jsxs)(n.blockquote,{children:["\n",(0,a.jsx)(n.p,{children:"getManualClutchPedal()"}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Return Values"})}),"\n\n\n\n\n\n\n\n\n",(0,a.jsx)(n.table,{children:(0,a.jsx)(n.thead,{children:(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.th,{children:"any"}),(0,a.jsx)(n.th,{children:"state"}),(0,a.jsx)(n.th,{children:"state [0-1]"})]})})}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Code"})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-lua",children:"function VehicleMotor:getManualClutchPedal()\n    if self.gearShiftMode = = VehicleMotor.SHIFT_MODE_MANUAL_CLUTCH then\n        return self.manualClutchValue\n    end\n\n    return 0\nend\n\n"})}),"\n",(0,a.jsx)(n.h3,{id:"getmaxclutchtorque",children:"getMaxClutchTorque"}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Description"})}),"\n",(0,a.jsxs)(n.blockquote,{children:["\n",(0,a.jsx)(n.p,{children:"Returns max clutch torque"}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Definition"})}),"\n",(0,a.jsxs)(n.blockquote,{children:["\n",(0,a.jsx)(n.p,{children:"getMaxClutchTorque()"}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Return Values"})}),"\n\n\n\n\n\n\n\n\n",(0,a.jsx)(n.table,{children:(0,a.jsx)(n.thead,{children:(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.th,{children:"any"}),(0,a.jsx)(n.th,{children:"maxClutchTorque"}),(0,a.jsx)(n.th,{children:"max clutch torque"})]})})}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Code"})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-lua",children:"function VehicleMotor:getMaxClutchTorque()\n    return self.maxClutchTorque\nend\n\n"})}),"\n",(0,a.jsx)(n.h3,{id:"getmaximumbackwardspeed",children:"getMaximumBackwardSpeed"}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Description"})}),"\n",(0,a.jsxs)(n.blockquote,{children:["\n",(0,a.jsx)(n.p,{children:"Returns maximum backward speed"}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Definition"})}),"\n",(0,a.jsxs)(n.blockquote,{children:["\n",(0,a.jsx)(n.p,{children:"getMaximumBackwardSpeed()"}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Return Values"})}),"\n\n\n\n\n\n\n\n\n",(0,a.jsx)(n.table,{children:(0,a.jsx)(n.thead,{children:(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.th,{children:"any"}),(0,a.jsx)(n.th,{children:"maxBackwardSpeed"}),(0,a.jsx)(n.th,{children:"maximum backward speed"})]})})}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Code"})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-lua",children:"function VehicleMotor:getMaximumBackwardSpeed()\n    return self.maxBackwardSpeed\nend\n\n"})}),"\n",(0,a.jsx)(n.h3,{id:"getmaximumforwardspeed",children:"getMaximumForwardSpeed"}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Description"})}),"\n",(0,a.jsxs)(n.blockquote,{children:["\n",(0,a.jsx)(n.p,{children:"Returns maximum forward speed"}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Definition"})}),"\n",(0,a.jsxs)(n.blockquote,{children:["\n",(0,a.jsx)(n.p,{children:"getMaximumForwardSpeed()"}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Return Values"})}),"\n\n\n\n\n\n\n\n\n",(0,a.jsx)(n.table,{children:(0,a.jsx)(n.thead,{children:(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.th,{children:"any"}),(0,a.jsx)(n.th,{children:"maxForwardSpeed"}),(0,a.jsx)(n.th,{children:"maximum forward speed"})]})})}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Code"})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-lua",children:"function VehicleMotor:getMaximumForwardSpeed()\n    return self.maxForwardSpeed\nend\n\n"})}),"\n",(0,a.jsx)(n.h3,{id:"getmaxrpm",children:"getMaxRpm"}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Description"})}),"\n",(0,a.jsxs)(n.blockquote,{children:["\n",(0,a.jsx)(n.p,{children:"Returns max rpm"}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Definition"})}),"\n",(0,a.jsxs)(n.blockquote,{children:["\n",(0,a.jsx)(n.p,{children:"getMaxRpm()"}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Return Values"})}),"\n\n\n\n\n\n\n\n\n",(0,a.jsx)(n.table,{children:(0,a.jsx)(n.thead,{children:(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.th,{children:"any"}),(0,a.jsx)(n.th,{children:"maxRpm"}),(0,a.jsx)(n.th,{children:"max rpm"})]})})}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Code"})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-lua",children:"function VehicleMotor:getMaxRpm()\n    return self.maxRpm\nend\n\n"})}),"\n",(0,a.jsx)(n.h3,{id:"getminmaxgearratio",children:"getMinMaxGearRatio"}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Description"})}),"\n",(0,a.jsxs)(n.blockquote,{children:["\n",(0,a.jsx)(n.p,{children:"Returns currently selected minimum and maximum gear ratio\nGear ratios for driving backwards are negative. Min/max always refers to the absolute value\nFor regular gear box transmission, the minimum and maximum gear ratios are identical"}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Definition"})}),"\n",(0,a.jsxs)(n.blockquote,{children:["\n",(0,a.jsx)(n.p,{children:"getMinMaxGearRatio()"}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Return Values"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,a.jsxs)(n.table,{children:[(0,a.jsx)(n.thead,{children:(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.th,{children:"any"}),(0,a.jsx)(n.th,{children:"minGearRatio"}),(0,a.jsx)(n.th,{children:"minimum gear ratio"})]})}),(0,a.jsx)(n.tbody,{children:(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:"any"}),(0,a.jsx)(n.td,{children:"maxGearRatio"}),(0,a.jsx)(n.td,{children:"maximum gear ratio"})]})})]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Code"})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-lua",children:"function VehicleMotor:getMinMaxGearRatio()\n    local minRatio = self.minGearRatio\n    local maxRatio = self.maxGearRatio\n\n    if self.minGearRatio ~ = 0 or self.maxGearRatio ~ = 0 then\n        if self.clutchSlippingTimer = = self.clutchSlippingTime then\n            -- use high max gear ratio for smooth acceleration since we are not in a speed where we can fully engage the gear\n                maxRatio = math.max( 350 , self.maxGearRatio) * math.sign( self.maxGearRatio)\n            elseif self.clutchSlippingTimer > 0 then\n                    -- after we reached 75% of the min.needed differential speed we slowly fade into the target gear ratio\n                    minRatio = MathUtil.lerp(minRatio, self.clutchSlippingGearRatio, self.clutchSlippingTimer / self.clutchSlippingTime)\n                    maxRatio = MathUtil.lerp(maxRatio, self.clutchSlippingGearRatio, self.clutchSlippingTimer / self.clutchSlippingTime)\n                end\n            end\n\n            return minRatio, maxRatio\n        end\n\n"})}),"\n",(0,a.jsx)(n.h3,{id:"getminrpm",children:"getMinRpm"}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Description"})}),"\n",(0,a.jsxs)(n.blockquote,{children:["\n",(0,a.jsx)(n.p,{children:"Returns min rpm"}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Definition"})}),"\n",(0,a.jsxs)(n.blockquote,{children:["\n",(0,a.jsx)(n.p,{children:"getMinRpm()"}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Return Values"})}),"\n\n\n\n\n\n\n\n\n",(0,a.jsx)(n.table,{children:(0,a.jsx)(n.thead,{children:(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.th,{children:"any"}),(0,a.jsx)(n.th,{children:"minRpm"}),(0,a.jsx)(n.th,{children:"min rpm"})]})})}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Code"})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-lua",children:"function VehicleMotor:getMinRpm()\n    return self.minRpm\nend\n\n"})}),"\n",(0,a.jsx)(n.h3,{id:"getmotorappliedtorque",children:"getMotorAppliedTorque"}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Description"})}),"\n",(0,a.jsxs)(n.blockquote,{children:["\n",(0,a.jsx)(n.p,{children:"Returns the last applied torque to the motor"}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Definition"})}),"\n",(0,a.jsxs)(n.blockquote,{children:["\n",(0,a.jsx)(n.p,{children:"getMotorAppliedTorque()"}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Return Values"})}),"\n\n\n\n\n\n\n\n\n",(0,a.jsx)(n.table,{children:(0,a.jsx)(n.thead,{children:(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.th,{children:"any"}),(0,a.jsx)(n.th,{children:"appliedTorque"}),(0,a.jsx)(n.th,{children:"torque [kN]"})]})})}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Code"})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-lua",children:"function VehicleMotor:getMotorAppliedTorque()\n    return self.motorAppliedTorque\nend\n\n"})}),"\n",(0,a.jsx)(n.h3,{id:"getmotoravailabletorque",children:"getMotorAvailableTorque"}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Description"})}),"\n",(0,a.jsxs)(n.blockquote,{children:["\n",(0,a.jsx)(n.p,{children:"Returns the last total available motor torque"}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Definition"})}),"\n",(0,a.jsxs)(n.blockquote,{children:["\n",(0,a.jsx)(n.p,{children:"getMotorAvailableTorque()"}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Return Values"})}),"\n\n\n\n\n\n\n\n\n",(0,a.jsx)(n.table,{children:(0,a.jsx)(n.thead,{children:(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.th,{children:"any"}),(0,a.jsx)(n.th,{children:"torque"}),(0,a.jsx)(n.th,{children:"external torque [kN]"})]})})}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Code"})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-lua",children:"function VehicleMotor:getMotorAvailableTorque()\n    return self.motorAvailableTorque\nend\n\n"})}),"\n",(0,a.jsx)(n.h3,{id:"getmotorexternaltorque",children:"getMotorExternalTorque"}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Description"})}),"\n",(0,a.jsxs)(n.blockquote,{children:["\n",(0,a.jsx)(n.p,{children:"Returns the last applied external torque (torque used by external power consumers like the PTO)"}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Definition"})}),"\n",(0,a.jsxs)(n.blockquote,{children:["\n",(0,a.jsx)(n.p,{children:"getMotorExternalTorque()"}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Return Values"})}),"\n\n\n\n\n\n\n\n\n",(0,a.jsx)(n.table,{children:(0,a.jsx)(n.thead,{children:(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.th,{children:"any"}),(0,a.jsx)(n.th,{children:"externalTorque"}),(0,a.jsx)(n.th,{children:"external torque [kN]"})]})})}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Code"})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-lua",children:"function VehicleMotor:getMotorExternalTorque()\n    return self.motorExternalTorque\nend\n\n"})}),"\n",(0,a.jsx)(n.h3,{id:"getmotorrotationaccelerationlimit",children:"getMotorRotationAccelerationLimit"}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Description"})}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Definition"})}),"\n",(0,a.jsxs)(n.blockquote,{children:["\n",(0,a.jsx)(n.p,{children:"getMotorRotationAccelerationLimit()"}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Code"})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-lua",children:"function VehicleMotor:getMotorRotationAccelerationLimit()\n    return self.motorRotationAccelerationLimit\nend\n\n"})}),"\n",(0,a.jsx)(n.h3,{id:"getmotorrotspeed",children:"getMotorRotSpeed"}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Description"})}),"\n",(0,a.jsxs)(n.blockquote,{children:["\n",(0,a.jsx)(n.p,{children:"Returns motor rot speed"}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Definition"})}),"\n",(0,a.jsxs)(n.blockquote,{children:["\n",(0,a.jsx)(n.p,{children:"getMotorRotSpeed()"}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Return Values"})}),"\n\n\n\n\n\n\n\n\n",(0,a.jsx)(n.table,{children:(0,a.jsx)(n.thead,{children:(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.th,{children:"any"}),(0,a.jsx)(n.th,{children:"rotSpeed"}),(0,a.jsx)(n.th,{children:"rot speed"})]})})}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Code"})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-lua",children:"function VehicleMotor:getMotorRotSpeed()\n    return self.motorRotSpeed\nend\n\n"})}),"\n",(0,a.jsx)(n.h3,{id:"getnonclampedmotorrpm",children:"getNonClampedMotorRpm"}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Description"})}),"\n",(0,a.jsxs)(n.blockquote,{children:["\n",(0,a.jsx)(n.p,{children:"Returns non clamped motor rpm"}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Definition"})}),"\n",(0,a.jsxs)(n.blockquote,{children:["\n",(0,a.jsx)(n.p,{children:"getNonClampedMotorRpm()"}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Return Values"})}),"\n\n\n\n\n\n\n\n\n",(0,a.jsx)(n.table,{children:(0,a.jsx)(n.thead,{children:(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.th,{children:"any"}),(0,a.jsx)(n.th,{children:"nonClampedMotorRpm"}),(0,a.jsx)(n.th,{children:"non clamped motor rpm"})]})})}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Code"})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-lua",children:"function VehicleMotor:getNonClampedMotorRpm()\n    return self.motorRotSpeed * 30 / math.pi\nend\n\n"})}),"\n",(0,a.jsx)(n.h3,{id:"getpeaktorque",children:"getPeakTorque"}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Description"})}),"\n",(0,a.jsxs)(n.blockquote,{children:["\n",(0,a.jsx)(n.p,{children:"Returns max torque"}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Definition"})}),"\n",(0,a.jsxs)(n.blockquote,{children:["\n",(0,a.jsx)(n.p,{children:"getPeakTorque()"}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Return Values"})}),"\n\n\n\n\n\n\n\n\n",(0,a.jsx)(n.table,{children:(0,a.jsx)(n.thead,{children:(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.th,{children:"any"}),(0,a.jsx)(n.th,{children:"maxMotorTorque"}),(0,a.jsx)(n.th,{children:"max motor torque"})]})})}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Code"})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-lua",children:"function VehicleMotor:getPeakTorque()\n    return self.peakMotorTorque\nend\n\n"})}),"\n",(0,a.jsx)(n.h3,{id:"getptomotorrpmratio",children:"getPtoMotorRpmRatio"}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Description"})}),"\n",(0,a.jsxs)(n.blockquote,{children:["\n",(0,a.jsx)(n.p,{children:"Returns pto motor rpm ratio"}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Definition"})}),"\n",(0,a.jsxs)(n.blockquote,{children:["\n",(0,a.jsx)(n.p,{children:"getPtoMotorRpmRatio()"}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Return Values"})}),"\n\n\n\n\n\n\n\n\n",(0,a.jsx)(n.table,{children:(0,a.jsx)(n.thead,{children:(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.th,{children:"any"}),(0,a.jsx)(n.th,{children:"ptoMotorRpmRatio"}),(0,a.jsx)(n.th,{children:"pto motor rpm ratio"})]})})}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Code"})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-lua",children:"function VehicleMotor:getPtoMotorRpmRatio()\n    return self.ptoMotorRpmRatio\nend\n\n"})}),"\n",(0,a.jsx)(n.h3,{id:"getrequiredmotorrpmrange",children:"getRequiredMotorRpmRange"}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Description"})}),"\n",(0,a.jsxs)(n.blockquote,{children:["\n",(0,a.jsx)(n.p,{children:"Returns the currently required motor rpm range (e.g. defined by the activated pto)"}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Definition"})}),"\n",(0,a.jsxs)(n.blockquote,{children:["\n",(0,a.jsx)(n.p,{children:"getRequiredMotorRpmRange()"}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Return Values"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,a.jsxs)(n.table,{children:[(0,a.jsx)(n.thead,{children:(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.th,{children:"any"}),(0,a.jsx)(n.th,{children:"minRequiredRpm"}),(0,a.jsx)(n.th,{children:"min required rpm"})]})}),(0,a.jsx)(n.tbody,{children:(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:"any"}),(0,a.jsx)(n.td,{children:"minRequiredRpm"}),(0,a.jsx)(n.td,{children:"max required rpm"})]})})]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Code"})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-lua",children:"function VehicleMotor:getRequiredMotorRpmRange()\n    local motorPtoRpm = math.min( PowerConsumer.getMaxPtoRpm( self.vehicle) * self.ptoMotorRpmRatio, self.maxRpm)\n    if motorPtoRpm ~ = 0 then\n        return motorPtoRpm, self.maxRpm\n    end\n    return self.minRpm, self.maxRpm\nend\n\n"})}),"\n",(0,a.jsx)(n.h3,{id:"getrequiredrpmatspeedlimit",children:"getRequiredRpmAtSpeedLimit"}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Description"})}),"\n",(0,a.jsxs)(n.blockquote,{children:["\n",(0,a.jsx)(n.p,{children:"Returns the rpm while driving with this gear ratio"}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Definition"})}),"\n",(0,a.jsxs)(n.blockquote,{children:["\n",(0,a.jsx)(n.p,{children:"getRequiredRpmAtSpeedLimit(float ratio)"}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n",(0,a.jsx)(n.table,{children:(0,a.jsx)(n.thead,{children:(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.th,{children:"float"}),(0,a.jsx)(n.th,{children:"ratio"}),(0,a.jsx)(n.th,{children:"gear ratio to check"})]})})}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Return Values"})}),"\n\n\n\n\n\n\n\n\n",(0,a.jsx)(n.table,{children:(0,a.jsx)(n.thead,{children:(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.th,{children:"float"}),(0,a.jsx)(n.th,{children:"rpm"}),(0,a.jsx)(n.th,{children:"rpm"})]})})}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Code"})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-lua",children:"function VehicleMotor:getRequiredRpmAtSpeedLimit(ratio)\n    -- use vehicle speed limit(normally from working tool) and cruise control speed, not motor speed limit to avoid issues with ai since the ai is permanently controlling the motor speed limit on headlands\n    -- this leads to permanent gear shifts and wrong starting gears\n    local speedLimit = math.min( self.vehicle:getSpeedLimit( true ), math.max( self.speedLimitAcc, self.vehicle.lastSpeedReal * 3600 ))\n    if self.vehicle:getCruiseControlState() = = Drivable.CRUISECONTROL_STATE_ACTIVE then\n        speedLimit = math.min(speedLimit, self.vehicle:getCruiseControlSpeed())\n    end\n\n    speedLimit = ratio > 0 and math.min(speedLimit, self.maxForwardSpeed * 3.6 ) or math.min(speedLimit, self.maxBackwardSpeed * 3.6 )\n    return speedLimit / 3.6 * 30 / math.pi * math.abs(ratio)\nend\n\n"})}),"\n",(0,a.jsx)(n.h3,{id:"getrotinertia",children:"getRotInertia"}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Description"})}),"\n",(0,a.jsxs)(n.blockquote,{children:["\n",(0,a.jsx)(n.p,{children:"Returns rotation inertia"}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Definition"})}),"\n",(0,a.jsxs)(n.blockquote,{children:["\n",(0,a.jsx)(n.p,{children:"getRotInertia()"}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Return Values"})}),"\n\n\n\n\n\n\n\n\n",(0,a.jsx)(n.table,{children:(0,a.jsx)(n.thead,{children:(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.th,{children:"float"}),(0,a.jsx)(n.th,{children:"rotInertia"}),(0,a.jsx)(n.th,{children:"rotation inertia"})]})})}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Code"})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-lua",children:"function VehicleMotor:getRotInertia()\n    return self.rotInertia\nend\n\n"})}),"\n",(0,a.jsx)(n.h3,{id:"getsmoothedclutchpedal",children:"getSmoothedClutchPedal"}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Description"})}),"\n",(0,a.jsxs)(n.blockquote,{children:["\n",(0,a.jsx)(n.p,{children:"Returns smoothed clutch pedal state"}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Definition"})}),"\n",(0,a.jsxs)(n.blockquote,{children:["\n",(0,a.jsx)(n.p,{children:"getSmoothedClutchPedal()"}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Return Values"})}),"\n\n\n\n\n\n\n\n\n",(0,a.jsx)(n.table,{children:(0,a.jsx)(n.thead,{children:(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.th,{children:"float"}),(0,a.jsx)(n.th,{children:"state"}),(0,a.jsx)(n.th,{children:"state [0-1]"})]})})}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Code"})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-lua",children:"function VehicleMotor:getSmoothedClutchPedal()\n    return self.lastSmoothedClutchPedal\nend\n\n"})}),"\n",(0,a.jsx)(n.h3,{id:"getsmoothloadpercentage",children:"getSmoothLoadPercentage"}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Description"})}),"\n",(0,a.jsxs)(n.blockquote,{children:["\n",(0,a.jsx)(n.p,{children:"Returns the last smoothed load percentage"}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Definition"})}),"\n",(0,a.jsxs)(n.blockquote,{children:["\n",(0,a.jsx)(n.p,{children:"getSmoothLoadPercentage()"}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Return Values"})}),"\n\n\n\n\n\n\n\n\n",(0,a.jsx)(n.table,{children:(0,a.jsx)(n.thead,{children:(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.th,{children:"float"}),(0,a.jsx)(n.th,{children:"load"}),(0,a.jsx)(n.th,{children:"load [0-1]"})]})})}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Code"})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-lua",children:"function VehicleMotor:getSmoothLoadPercentage()\n    local modulationIntensity = math.clamp(( self.smoothedLoadPercentage - MODULATION_LOAD_MIN_REF_LOAD) / (MODULATION_LOAD_MAX_REF_LOAD - MODULATION_LOAD_MIN_REF_LOAD), MODULATION_LOAD_MIN_INTENSITY, 1 )\n    return self.smoothedLoadPercentage - self.lastModulationPercentage * (MODULATION_LOAD_MAX_OFFSET * modulationIntensity)\nend\n\n"})}),"\n",(0,a.jsx)(n.h3,{id:"getspeedlimit",children:"getSpeedLimit"}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Description"})}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Definition"})}),"\n",(0,a.jsxs)(n.blockquote,{children:["\n",(0,a.jsx)(n.p,{children:"getSpeedLimit()"}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Code"})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-lua",children:"function VehicleMotor:getSpeedLimit()\n    return self.speedLimit\nend\n\n"})}),"\n",(0,a.jsx)(n.h3,{id:"getstartingearfactor",children:"getStartInGearFactor"}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Description"})}),"\n",(0,a.jsxs)(n.blockquote,{children:["\n",(0,a.jsx)(n.p,{children:"Returns factor which defines if the vehicle can start with the given gear ratio"}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Definition"})}),"\n",(0,a.jsxs)(n.blockquote,{children:["\n",(0,a.jsx)(n.p,{children:"getStartInGearFactor(float ratio)"}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n",(0,a.jsx)(n.table,{children:(0,a.jsx)(n.thead,{children:(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.th,{children:"float"}),(0,a.jsx)(n.th,{children:"ratio"}),(0,a.jsx)(n.th,{children:"gear ratio to check"})]})})}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Return Values"})}),"\n\n\n\n\n\n\n\n\n",(0,a.jsx)(n.table,{children:(0,a.jsx)(n.thead,{children:(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.th,{children:"float"}),(0,a.jsx)(n.th,{children:"startFactor"}),(0,a.jsx)(n.th,{children:"start factor"})]})})}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Code"})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-lua",children:"function VehicleMotor:getStartInGearFactor(ratio)\n    -- if we cannot run the gear with at least 25% rpm with the current speed limit we skip it\n        if self:getRequiredRpmAtSpeedLimit(ratio) < self.minRpm + ( self.maxRpm - self.minRpm) * 0.25 then\n            return math.huge\n        end\n\n        local slope = self.startGearValues.slope\n        if ratio < 0 then\n            slope = - slope\n        end\n\n        local slopePowerFactor = (( self.startGearValues.availablePower / 100 - 1 ) / 2 ) ^ 2 * 2 + 1\n        local slopeFactor = 1 + math.max(slope, 0 ) / (slopePowerFactor * 0.06981 ) -- 4 degrees\n        return self.startGearValues.massFactor * slopeFactor / ( math.abs(ratio) / 300 )\n    end\n\n"})}),"\n",(0,a.jsx)(n.h3,{id:"gettorque",children:"getTorque"}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Description"})}),"\n",(0,a.jsxs)(n.blockquote,{children:["\n",(0,a.jsx)(n.p,{children:"Returns torque of the motor at the current rpm with the given accelerator pedal"}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Definition"})}),"\n",(0,a.jsxs)(n.blockquote,{children:["\n",(0,a.jsx)(n.p,{children:"getTorque(float acceleration)"}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n",(0,a.jsx)(n.table,{children:(0,a.jsx)(n.thead,{children:(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.th,{children:"float"}),(0,a.jsx)(n.th,{children:"acceleration"}),(0,a.jsx)(n.th,{children:"acceleration"})]})})}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Return Values"})}),"\n\n\n\n\n\n\n\n\n",(0,a.jsx)(n.table,{children:(0,a.jsx)(n.thead,{children:(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.th,{children:"float"}),(0,a.jsx)(n.th,{children:"torque"}),(0,a.jsx)(n.th,{children:"torque"})]})})}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Code"})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-lua",children:"function VehicleMotor:getTorque(acceleration)\n    -- Note:the torque curve is undefined outside the min/max rpm range.Clamping makes the curve flat at the outside range\n    local torque = self:getTorqueCurveValue( math.clamp( self.motorRotSpeed * 30 / math.pi, self.minRpm, self.maxRpm))\n    torque = torque * math.abs(acceleration)\n    return torque\nend\n\n"})}),"\n",(0,a.jsx)(n.h3,{id:"gettorqueandspeedvalues",children:"getTorqueAndSpeedValues"}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Description"})}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Definition"})}),"\n",(0,a.jsxs)(n.blockquote,{children:["\n",(0,a.jsx)(n.p,{children:"getTorqueAndSpeedValues()"}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Code"})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-lua",children:"function VehicleMotor:getTorqueAndSpeedValues()\n    local rotationSpeeds = { }\n    local torques = { }\n    for _,v in ipairs( self:getTorqueCurve().keyframes) do\n        table.insert(rotationSpeeds, v.time * math.pi / 30 )\n        table.insert(torques, self:getTorqueCurveValue(v.time ))\n    end\n\n    return torques, rotationSpeeds\nend\n\n"})}),"\n",(0,a.jsx)(n.h3,{id:"gettorquecurve",children:"getTorqueCurve"}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Description"})}),"\n",(0,a.jsxs)(n.blockquote,{children:["\n",(0,a.jsx)(n.p,{children:"Returns torque curve"}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Definition"})}),"\n",(0,a.jsxs)(n.blockquote,{children:["\n",(0,a.jsx)(n.p,{children:"getTorqueCurve()"}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Return Values"})}),"\n\n\n\n\n\n\n\n\n",(0,a.jsx)(n.table,{children:(0,a.jsx)(n.thead,{children:(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.th,{children:"float"}),(0,a.jsx)(n.th,{children:"torqueCurve"}),(0,a.jsx)(n.th,{children:"torque curve"})]})})}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Code"})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-lua",children:"function VehicleMotor:getTorqueCurve()\n    return self.torqueCurve\nend\n\n"})}),"\n",(0,a.jsx)(n.h3,{id:"gettorquecurvevalue",children:"getTorqueCurveValue"}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Description"})}),"\n",(0,a.jsxs)(n.blockquote,{children:["\n",(0,a.jsx)(n.p,{children:"Returns torque of the motor at the given rpm"}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Definition"})}),"\n",(0,a.jsxs)(n.blockquote,{children:["\n",(0,a.jsx)(n.p,{children:"getTorqueCurveValue(float rpm)"}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n",(0,a.jsx)(n.table,{children:(0,a.jsx)(n.thead,{children:(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.th,{children:"float"}),(0,a.jsx)(n.th,{children:"rpm"}),(0,a.jsx)(n.th,{children:"rpm"})]})})}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Return Values"})}),"\n\n\n\n\n\n\n\n\n",(0,a.jsx)(n.table,{children:(0,a.jsx)(n.thead,{children:(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.th,{children:"float"}),(0,a.jsx)(n.th,{children:"torque"}),(0,a.jsx)(n.th,{children:"torque"})]})})}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Code"})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-lua",children:"function VehicleMotor:getTorqueCurveValue(rpm)\n    local damage = 1 - ( self.vehicle:getVehicleDamage() * VehicleMotor.DAMAGE_TORQUE_REDUCTION)\n    return self:getTorqueCurve():get(rpm) * damage\nend\n\n"})}),"\n",(0,a.jsx)(n.h3,{id:"getuseautomaticgearshifting",children:"getUseAutomaticGearShifting"}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Description"})}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Definition"})}),"\n",(0,a.jsxs)(n.blockquote,{children:["\n",(0,a.jsx)(n.p,{children:"getUseAutomaticGearShifting()"}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Code"})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-lua",children:"function VehicleMotor:getUseAutomaticGearShifting()\n    if self.gearShiftMode = = VehicleMotor.SHIFT_MODE_AUTOMATIC then\n        return true\n    end\n\n    if not self.manualShiftGears then\n        return true\n    end\n\n    return false\nend\n\n"})}),"\n",(0,a.jsx)(n.h3,{id:"getuseautomaticgroupshifting",children:"getUseAutomaticGroupShifting"}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Description"})}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Definition"})}),"\n",(0,a.jsxs)(n.blockquote,{children:["\n",(0,a.jsx)(n.p,{children:"getUseAutomaticGroupShifting()"}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Code"})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-lua",children:"function VehicleMotor:getUseAutomaticGroupShifting()\n    if self.gearShiftMode = = VehicleMotor.SHIFT_MODE_AUTOMATIC then\n        return true\n    end\n\n    if not self.manualShiftGroups then\n        return true\n    end\n\n    return false\nend\n\n"})}),"\n",(0,a.jsx)(n.h3,{id:"new",children:"new"}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Description"})}),"\n",(0,a.jsxs)(n.blockquote,{children:["\n",(0,a.jsx)(n.p,{children:"Creating new motor"}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Definition"})}),"\n",(0,a.jsxs)(n.blockquote,{children:["\n",(0,a.jsx)(n.p,{children:"new(integer minRpm, integer maxRpm, float maxForwardSpeed, float maxBackwardSpeed, table torqueCurve, float\nbrakeForce, float forwardGears, float backwardGears, float minForwardGearRatio, float maxForwardGearRatio, float\nminBackwardGearRatio, float maxBackwardGearRatio, integer ptoMotorRpmRatio, , )"}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,a.jsxs)(n.table,{children:[(0,a.jsx)(n.thead,{children:(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.th,{children:"integer"}),(0,a.jsx)(n.th,{children:"minRpm"}),(0,a.jsx)(n.th,{children:"min rpm"})]})}),(0,a.jsxs)(n.tbody,{children:[(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:"integer"}),(0,a.jsx)(n.td,{children:"maxRpm"}),(0,a.jsx)(n.td,{children:"max rpm"})]}),(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:"float"}),(0,a.jsx)(n.td,{children:"maxForwardSpeed"}),(0,a.jsx)(n.td,{children:"max forward speed"})]}),(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:"float"}),(0,a.jsx)(n.td,{children:"maxBackwardSpeed"}),(0,a.jsx)(n.td,{children:"max backward speed"})]}),(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:"table"}),(0,a.jsx)(n.td,{children:"torqueCurve"}),(0,a.jsx)(n.td,{children:"torque curve (AnimCurve)"})]}),(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:"float"}),(0,a.jsx)(n.td,{children:"brakeForce"}),(0,a.jsx)(n.td,{children:"brake force"})]}),(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:"float"}),(0,a.jsx)(n.td,{children:"forwardGears"}),(0,a.jsx)(n.td,{children:"list of gear ratios to use when driving forwards (in decreasing order)"})]}),(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:"float"}),(0,a.jsx)(n.td,{children:"backwardGears"}),(0,a.jsx)(n.td,{children:"list of gear ratios to use when driving backwards (in decreasing order)"})]}),(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:"float"}),(0,a.jsx)(n.td,{children:"minForwardGearRatio"}),(0,a.jsx)(n.td,{children:"min forward gear ratio"})]}),(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:"float"}),(0,a.jsx)(n.td,{children:"maxForwardGearRatio"}),(0,a.jsx)(n.td,{children:"max forward gear ratio"})]}),(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:"float"}),(0,a.jsx)(n.td,{children:"minBackwardGearRatio"}),(0,a.jsx)(n.td,{children:"min backward gear ratio"})]}),(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:"float"}),(0,a.jsx)(n.td,{children:"maxBackwardGearRatio"}),(0,a.jsx)(n.td,{children:"max backward gear ratio"})]}),(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:"integer"}),(0,a.jsx)(n.td,{children:"ptoMotorRpmRatio"}),(0,a.jsx)(n.td,{children:"pto motor rpm ratio"})]}),(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:"any"}),(0,a.jsx)(n.td,{children:"ptoMotorRpmRatio"}),(0,a.jsx)(n.td,{})]}),(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:"any"}),(0,a.jsx)(n.td,{children:"minSpeed"}),(0,a.jsx)(n.td,{})]})]})]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Return Values"})}),"\n\n\n\n\n\n\n\n\n",(0,a.jsx)(n.table,{children:(0,a.jsx)(n.thead,{children:(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.th,{children:"any"}),(0,a.jsx)(n.th,{children:"motorInstance"}),(0,a.jsx)(n.th,{children:"motor instance"})]})})}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Code"})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-lua",children:"function VehicleMotor.new(vehicle, minRpm, maxRpm, maxForwardSpeed, maxBackwardSpeed, torqueCurve, brakeForce, forwardGears, backwardGears, minForwardGearRatio, maxForwardGearRatio, minBackwardGearRatio, maxBackwardGearRatio, ptoMotorRpmRatio, minSpeed)\n\n    local self = setmetatable( { } , VehicleMotor _mt)\n\n    self.vehicle = vehicle\n    self.minRpm = minRpm\n    self.maxRpm = maxRpm\n    self.minSpeed = minSpeed\n    self.maxForwardSpeed = maxForwardSpeed -- speed in m/s\n    self.maxBackwardSpeed = maxBackwardSpeed\n\n    self.maxClutchTorque = 5 -- amount of torque that can be transferred from motor to clutch/wheels [t m s^-2]\n\n    self.torqueCurve = torqueCurve\n    self.brakeForce = brakeForce\n\n    self.lastAcceleratorPedal = 0\n    self.idleGearChangeTimer = 0 -- if this timer reaches 0 the automatic gear change while not moving is allowed\n        self.doSecondBestGearSelection = 0\n\n        self.gear = 0\n        self.bestGearSelected = 0\n        self.minGearRatio = 0\n        self.maxGearRatio = 0\n        self.allowGearChangeTimer = 0\n        self.allowGearChangeDirection = 0\n\n        self.forwardGears = forwardGears\n        self.backwardGears = backwardGears\n        self.currentGears = self.forwardGears\n        self.minForwardGearRatio = minForwardGearRatio\n        self.maxForwardGearRatio = maxForwardGearRatio\n        self.minBackwardGearRatio = minBackwardGearRatio\n        self.maxBackwardGearRatio = maxBackwardGearRatio\n\n        self.transmissionDirection = 1\n\n        self.maxClutchSpeedDifference = 0\n        self.defaultForwardGear = 1\n        if self.forwardGears ~ = nil then\n            for i = 1 , # self.forwardGears do\n                self.maxClutchSpeedDifference = math.max( self.maxClutchSpeedDifference, self.minRpm / self.forwardGears[i].ratio * math.pi / 30 )\n                if self.forwardGears[i].default then\n                    self.defaultForwardGear = i\n                end\n            end\n        end\n\n        self.defaultBackwardGear = 1\n        if self.backwardGears ~ = nil then\n            for i = 1 , # self.backwardGears do\n                self.maxClutchSpeedDifference = math.max( self.maxClutchSpeedDifference, self.minRpm / self.backwardGears[i].ratio * math.pi / 30 )\n                if self.backwardGears[i].default then\n                    self.defaultBackwardGear = i\n                end\n            end\n        end\n\n        self.gearType = VehicleMotor.TRANSMISSION_TYPE.DEFAULT\n        self.groupType = VehicleMotor.TRANSMISSION_TYPE.DEFAULT\n\n        self.manualTargetGear = nil\n        self.targetGear = 0\n        self.previousGear = 0\n        self.gearChangeTimer = - 1\n        self.gearChangeTime = 250\n        self.gearChangeTimeOrig = self.gearChangeTime\n        self.autoGearChangeTimer = - 1\n        self.autoGearChangeTime = 1000\n        self.manualClutchValue = 0\n        self.stallTimer = 0\n        self.lastGearChangeTime = 0\n        self.gearChangeTimeAutoReductionTime = 500\n        self.gearChangeTimeAutoReductionTimer = 0\n\n        self.lastManualShifterActive = false\n\n        self.clutchSlippingTime = 1000\n        self.clutchSlippingTimer = 0\n        self.clutchSlippingGearRatio = 0\n\n        self.groupChangeTime = 500\n        self.groupChangeTimer = 0\n        self.gearGroupUpShiftTime = 3000\n        self.gearGroupUpShiftTimer = 0\n\n        self.currentDirection = 1 -- current used gear direction\n        self.directionChangeTimer = 0\n        self.directionChangeTime = 500\n        self.directionChangeUseGear = false -- use a backward gear for direction change buttons\n            self.directionChangeGearIndex = 1 -- backward gear to activate if direction changes\n                self.directionLastGear = - 1 -- last forward gear, activated if direction is changed again\n                    self.directionChangeUseGroup = false -- use a group for direction change buttons\n                        self.directionChangeGroupIndex = 1 -- group to activate if direction changes\n                            self.directionLastGroup = - 1 -- last selected group, acitvated if direction changes again\n                                self.directionChangeUseInverse = true -- if true the forward gears are just inverted for driving backwards\n\n                                    self.gearChangedIsLocked = false\n                                    self.gearGroupChangedIsLocked = false\n\n                                    self.startGearValues = {\n                                    slope = 0 ,\n                                    mass = 0 ,\n                                    lastMass = 0 ,\n                                    maxForce = 0 ,\n                                    massDirectionDifferenceXZ = 0 ,\n                                    massDirectionDifferenceY = 0 ,\n                                    massDirectionFactor = 0 ,\n                                    availablePower = 0 ,\n                                    massFactor = 0\n                                    }\n\n                                    self.startGearThreshold = VehicleMotor.GEAR_START_THRESHOLD\n\n                                    self.lastSmoothedClutchPedal = 0\n\n                                    self.lastRealMotorRpm = 0\n                                    self.lastMotorRpm = 0\n\n                                    self.lastModulationPercentage = 0\n                                    self.lastModulationTimer = 0\n\n                                    self.rawLoadPercentage = 0\n                                    self.rawLoadPercentageBuffer = 0\n                                    self.rawLoadPercentageBufferIndex = 0\n                                    self.smoothedLoadPercentage = 0\n                                    self.loadPercentageChangeCharge = 0\n\n                                    self.accelerationLimitLoadScale = 1\n                                    self.accelerationLimitLoadScaleTimer = 0\n                                    self.accelerationLimitLoadScaleDelay = 2000 -- after running this time at max acceleration we decrease the motor load slowly again\n\n                                    self.constantRpmCharge = 0\n                                    self.constantAccelerationCharge = 0\n\n                                    self.lastTurboScale = 0\n                                    self.blowOffValveState = 0\n\n                                    self.overSpeedTimer = 0\n\n                                    self.rpmLimit = math.huge\n                                    self.speedLimit = math.huge -- Speed limit in km/h\n                                    self.speedLimitAcc = math.huge\n\n                                    self.accelerationLimit = 2 -- m s^-2\n\n                                    self.motorRotationAccelerationLimit = (maxRpm - minRpm) * math.pi / 30 / 2 -- rad s^-2 default accelerate from min rpm to max rpm in 2 sec\n\n                                    self.equalizedMotorRpm = 0\n\n                                    self.requiredMotorPower = 0\n\n                                    if self.maxForwardSpeed = = nil then\n                                        self.maxForwardSpeed = self:calculatePhysicalMaximumForwardSpeed()\n                                    end\n                                    if self.maxBackwardSpeed = = nil then\n                                        self.maxBackwardSpeed = self:calculatePhysicalMaximumBackwardSpeed()\n                                    end\n\n                                    -- saving the original values to be able to inverse them\n                                    self.maxForwardSpeedOrigin = self.maxForwardSpeed\n                                    self.maxBackwardSpeedOrigin = self.maxBackwardSpeed\n                                    self.minForwardGearRatioOrigin = self.minForwardGearRatio\n                                    self.maxForwardGearRatioOrigin = self.maxForwardGearRatio\n                                    self.minBackwardGearRatioOrigin = self.minBackwardGearRatio\n                                    self.maxBackwardGearRatioOrigin = self.maxBackwardGearRatio\n\n                                    self.peakMotorTorque = self.torqueCurve:getMaximum()\n\n                                    -- Calculate peak power.Assume we have a linear interpolation on the torque values\n                                    -- For each segment, find the maximum power(D[torque(x, i) * x] = = 0) and take the maximum segment\n                                    -- D[ ((x-x0) / (x1-x0) (y1-y0) + y0) x] = = 0\n                                    -- -> (x1 y0 - x0 y1) / (2(y0 - y1)) if y0 ! = y1\n                                        self.peakMotorPower = 0\n                                        self.peakMotorPowerRotSpeed = 0\n                                        local numKeyFrames = # self.torqueCurve.keyframes\n                                        if numKeyFrames > = 2 then\n                                            for i = 2 ,numKeyFrames do\n                                                local v0 = self.torqueCurve.keyframes[i - 1 ]\n                                                local v1 = self.torqueCurve.keyframes[i]\n                                                local torque0 = self.torqueCurve:getFromKeyframes(v0, v0, i - 1 , i - 1 , 0 )\n                                                local torque1 = self.torqueCurve:getFromKeyframes(v1, v1, i, i, 0 )\n                                                local rpm, torque\n                                                if math.abs(torque0 - torque1) > 0.0001 then\n                                                    rpm = (v1.time * torque0 - v0.time * torque1) / ( 2.0 * (torque0 - torque1))\n                                                    rpm = math.min( math.max(rpm, v0.time ), v1.time )\n                                                    torque = self.torqueCurve:getFromKeyframes(v0, v1, i - 1 , i, (v1.time - rpm) / (v1.time - v0.time ))\n                                                else\n                                                        rpm = v0.time\n                                                        torque = torque0\n                                                    end\n                                                    local power = torque * rpm\n                                                    if power > self.peakMotorPower then\n                                                        self.peakMotorPower = power\n                                                        self.peakMotorPowerRotSpeed = rpm\n                                                    end\n                                                end\n                                                -- Convert from rpm to rad/s\n                                                self.peakMotorPower = self.peakMotorPower * math.pi / 30\n                                                self.peakMotorPowerRotSpeed = self.peakMotorPowerRotSpeed * math.pi / 30\n                                            else\n                                                    local v = self.torqueCurve.keyframes[ 1 ]\n                                                    local rotSpeed = v.time * math.pi / 30\n                                                    local torque = self.torqueCurve:getFromKeyframes(v, v, 1 , 1 , 0 )\n                                                    self.peakMotorPower = rotSpeed * torque\n                                                    self.peakMotorPowerRotSpeed = rotSpeed\n                                                end\n\n                                                self.ptoMotorRpmRatio = ptoMotorRpmRatio\n\n                                                self.rotInertia = self.peakMotorTorque / 600 -- Rotational inertia of the motor, mostly defined by the flywheel [t m^2]\n                                                self.dampingRateFullThrottle = VehicleMotor.DEFAULT_DAMPING_RATE_FULL_THROTTLE -- Damping rate of the motor if the acceleration pedal is 1 [t m^2 s^-1]\n                                                    self.dampingRateZeroThrottleClutchEngaged = VehicleMotor.DEFAULT_DAMPING_RATE_ZERO_THROTTLE_CLUTCH_EN -- Damping rate of the motor if the acceleration pedal is 0 and the clutch is engaged [t m^2 s^-1]\n                                                        self.dampingRateZeroThrottleClutchDisengaged = VehicleMotor.DEFAULT_DAMPING_RATE_ZERO_THROTTLE_CLUTCH_DIS -- Damping rate of the motor if the acceleration pedal is 0 and the clutch is disengaged [t m^2 s^-1]\n\n                                                            -- Motor properties as read from the physics engine\n                                                            self.gearRatio = 0\n                                                            self.motorRotSpeed = 0 -- motor rotation speed [rad/s]\n                                                            self.motorRotSpeedClutchEngaged = 0 -- additional rotation speed when clutch is engaged\n                                                            self.motorRotAcceleration = 0 -- motor rotation acceleration [rad/s^2]\n                                                            self.motorRotAccelerationSmoothed = 0 -- motor rotation acceleration smoothed [rad/s^2]\n\n                                                            self.motorAvailableTorque, self.lastMotorAvailableTorque = 0 , 0 -- torque that was available to the physics simulation [kN = = t m/s^2]\n                                                            self.motorAppliedTorque, self.lastMotorAppliedTorque = 0 , 0 -- torque that was applied(< = available), can be smaller when acceleration/speed is limited [kN = = t m/s^2]\n                                                            self.motorExternalTorque, self.lastMotorExternalTorque = 0 , 0 -- torque that was removed from the motor and was not applied to the wheels(e.g.PTO) [kN = = t m/s^2]\n\n                                                            -- externalTorqueVirtualMultiplicator:is used to have virtually more motor load due to external torque(pto) but still reduce the motor by the same external torque\n                                                            -- like this we can increase the motor load without cutting the motor to hard so we cannot accelerate anymore\n                                                            self.externalTorqueVirtualMultiplicator = 1\n\n                                                            self.differentialRotSpeed = 0 -- rotation speed of the main differential [rad/s]\n                                                            self.differentialRotAcceleration = 0 -- rotation accleration of the main differential [rad/s^2]\n                                                            self.differentialRotAccelerationSmoothed = 0 -- smoothed rotation accleration of the main differential [rad/s^2]\n\n                                                            self.differentialRotAccelerationIndex = 1\n                                                            self.differentialRotAccelerationSamples = { }\n                                                            for _ = 1 , 10 do\n                                                                table.insert( self.differentialRotAccelerationSamples, 0 )\n                                                            end\n\n                                                            self.lastDifference = 0\n\n                                                            self.directionChangeMode = g_gameSettings:getValue(GameSettings.SETTING.DIRECTION_CHANGE_MODE)\n                                                            self.gearShiftMode = g_gameSettings:getValue(GameSettings.SETTING.GEAR_SHIFT_MODE)\n\n                                                            return self\n                                                        end\n\n"})}),"\n",(0,a.jsx)(n.h3,{id:"onmanualclutchchanged",children:"onManualClutchChanged"}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Description"})}),"\n",(0,a.jsxs)(n.blockquote,{children:["\n",(0,a.jsx)(n.p,{children:"Called when manual clutch value changes"}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Definition"})}),"\n",(0,a.jsxs)(n.blockquote,{children:["\n",(0,a.jsx)(n.p,{children:"onManualClutchChanged(float value)"}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n",(0,a.jsx)(n.table,{children:(0,a.jsx)(n.thead,{children:(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.th,{children:"float"}),(0,a.jsx)(n.th,{children:"value"}),(0,a.jsx)(n.th,{children:"value"})]})})}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Code"})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-lua",children:"function VehicleMotor:onManualClutchChanged(clutchValue)\n    self.manualClutchValue = clutchValue\nend\n\n"})}),"\n",(0,a.jsx)(n.h3,{id:"postload",children:"postLoad"}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Description"})}),"\n",(0,a.jsxs)(n.blockquote,{children:["\n",(0,a.jsx)(n.p,{children:"Post load motor"}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Definition"})}),"\n",(0,a.jsxs)(n.blockquote,{children:["\n",(0,a.jsx)(n.p,{children:"postLoad(table savegame)"}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n",(0,a.jsx)(n.table,{children:(0,a.jsx)(n.thead,{children:(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.th,{children:"table"}),(0,a.jsx)(n.th,{children:"savegame"}),(0,a.jsx)(n.th,{children:"savegame information"})]})})}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Code"})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-lua",children:'function VehicleMotor:postLoad(savegame)\n    if self.gearGroups ~ = nil then\n        SpecializationUtil.raiseEvent( self.vehicle, "onGearGroupChanged" , self.activeGearGroupIndex, 0 )\n    end\nend\n\n'})}),"\n",(0,a.jsx)(n.h3,{id:"readgeardatafromstream",children:"readGearDataFromStream"}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Description"})}),"\n",(0,a.jsxs)(n.blockquote,{children:["\n",(0,a.jsx)(n.p,{children:"Reads current gear data from stream"}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Definition"})}),"\n",(0,a.jsxs)(n.blockquote,{children:["\n",(0,a.jsx)(n.p,{children:"readGearDataFromStream()"}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,a.jsx)(n.table,{children:(0,a.jsx)(n.thead,{children:(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.th,{children:"any"}),(0,a.jsx)(n.th,{children:"streamId"})]})})}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Code"})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-lua",children:'function VehicleMotor:readGearDataFromStream(streamId)\n    self.currentDirection = streamReadUIntN(streamId, 2 ) - 1\n\n    if streamReadBool(streamId) then\n        local gear = streamReadUIntN(streamId, 6 )\n        local changingGear = streamReadBool(streamId)\n\n        if streamReadBool(streamId) then\n            self.currentGears = self.forwardGears\n        else\n                self.currentGears = self.backwardGears\n            end\n\n            local activeGearGroupIndex\n            if self.gearGroups ~ = nil then\n                activeGearGroupIndex = streamReadUIntN(streamId, 5 )\n            end\n\n            if gear ~ = self.gear then\n                if changingGear and self.gear ~ = 0 then\n                    self.lastGearChangeTime = g_ time\n                end\n\n                self.previousGear = self.gear\n                self.gear = changingGear and 0 or gear\n                self.targetGear = gear\n\n                local directionMultiplier = self.directionChangeUseGear and self.currentDirection or 1\n                SpecializationUtil.raiseEvent( self.vehicle, "onGearChanged" , self.gear * directionMultiplier, self.targetGear * directionMultiplier, 0 , self.previousGear)\n            end\n\n            if activeGearGroupIndex ~ = self.activeGearGroupIndex then\n                self.activeGearGroupIndex = activeGearGroupIndex\n                SpecializationUtil.raiseEvent( self.vehicle, "onGearGroupChanged" , self.activeGearGroupIndex, self.groupType = = VehicleMotor.TRANSMISSION_TYPE.DEFAULT and self.groupChangeTime or 0 )\n            end\n        end\n    end\n\n'})}),"\n",(0,a.jsx)(n.h3,{id:"selectgear",children:"selectGear"}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Description"})}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Definition"})}),"\n",(0,a.jsxs)(n.blockquote,{children:["\n",(0,a.jsx)(n.p,{children:"selectGear()"}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,a.jsxs)(n.table,{children:[(0,a.jsx)(n.thead,{children:(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.th,{children:"any"}),(0,a.jsx)(n.th,{children:"gearIndex"})]})}),(0,a.jsx)(n.tbody,{children:(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:"any"}),(0,a.jsx)(n.td,{children:"activation"})]})})]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Code"})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-lua",children:'function VehicleMotor:selectGear(gearIndex, activation)\n    if activation then\n        if self.gear ~ = gearIndex then\n            if self:getIsGearChangeAllowed() then\n                if self.currentGears[gearIndex] ~ = nil then\n                    self:setGear(gearIndex, true )\n                    self.lastManualShifterActive = true\n                end\n            else\n                    SpecializationUtil.raiseEvent( self.vehicle, "onClutchCreaking" , false , false , gearIndex)\n                end\n            end\n        else\n                -- go into neutral state if any gear input action is released\n                    self:setGear( 0 , false )\n                    self.lastManualShifterActive = true\n                end\n            end\n\n'})}),"\n",(0,a.jsx)(n.h3,{id:"selectgroup",children:"selectGroup"}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Description"})}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Definition"})}),"\n",(0,a.jsxs)(n.blockquote,{children:["\n",(0,a.jsx)(n.p,{children:"selectGroup()"}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,a.jsxs)(n.table,{children:[(0,a.jsx)(n.thead,{children:(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.th,{children:"any"}),(0,a.jsx)(n.th,{children:"groupIndex"})]})}),(0,a.jsx)(n.tbody,{children:(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:"any"}),(0,a.jsx)(n.td,{children:"activation"})]})})]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Code"})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-lua",children:'function VehicleMotor:selectGroup(groupIndex, activation)\n    if activation then\n        if self:getIsGearGroupChangeAllowed() then\n            if self.gearGroups ~ = nil then\n                if self.gearGroups[groupIndex] ~ = nil then\n                    self:setGearGroup(groupIndex, true )\n                end\n            end\n        else\n                if self.activeGearGroupIndex ~ = groupIndex then\n                    SpecializationUtil.raiseEvent( self.vehicle, "onClutchCreaking" , false , true , nil , groupIndex)\n                end\n            end\n        else\n                -- go into neutral state if any group input action is released\n                    self:setGearGroup( 0 , false )\n                end\n            end\n\n'})}),"\n",(0,a.jsx)(n.h3,{id:"setaccelerationlimit",children:"setAccelerationLimit"}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Description"})}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Definition"})}),"\n",(0,a.jsxs)(n.blockquote,{children:["\n",(0,a.jsx)(n.p,{children:"setAccelerationLimit()"}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,a.jsx)(n.table,{children:(0,a.jsx)(n.thead,{children:(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.th,{children:"any"}),(0,a.jsx)(n.th,{children:"accelerationLimit"})]})})}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Code"})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-lua",children:"function VehicleMotor:setAccelerationLimit(accelerationLimit)\n    self.accelerationLimit = accelerationLimit\nend\n\n"})}),"\n",(0,a.jsx)(n.h3,{id:"setautogearchangetime",children:"setAutoGearChangeTime"}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Description"})}),"\n",(0,a.jsxs)(n.blockquote,{children:["\n",(0,a.jsx)(n.p,{children:"Sets the time that needs to pass since the last gear change until an automatic gear change is allowed"}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Definition"})}),"\n",(0,a.jsxs)(n.blockquote,{children:["\n",(0,a.jsx)(n.p,{children:"setAutoGearChangeTime(float autoGearChangeTime)"}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n",(0,a.jsx)(n.table,{children:(0,a.jsx)(n.thead,{children:(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.th,{children:"float"}),(0,a.jsx)(n.th,{children:"autoGearChangeTime"}),(0,a.jsx)(n.th,{children:"automatic gear change time [ms]"})]})})}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Code"})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-lua",children:"function VehicleMotor:setAutoGearChangeTime(autoGearChangeTime)\n    self.autoGearChangeTime = autoGearChangeTime\n    self.autoGearChangeTimer = math.min( self.autoGearChangeTimer, autoGearChangeTime)\nend\n\n"})}),"\n",(0,a.jsx)(n.h3,{id:"setdampingratescale",children:"setDampingRateScale"}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Description"})}),"\n",(0,a.jsxs)(n.blockquote,{children:["\n",(0,a.jsx)(n.p,{children:"Scales all damping rate values with this factor"}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Definition"})}),"\n",(0,a.jsxs)(n.blockquote,{children:["\n",(0,a.jsx)(n.p,{children:"setDampingRateScale(float dampingRateScale)"}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n",(0,a.jsx)(n.table,{children:(0,a.jsx)(n.thead,{children:(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.th,{children:"float"}),(0,a.jsx)(n.th,{children:"dampingRateScale"}),(0,a.jsx)(n.th,{children:"scale of damping rate [0-1]"})]})})}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Code"})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-lua",children:"function VehicleMotor:setDampingRateScale(dampingRateScale)\n    self.dampingRateFullThrottle = VehicleMotor.DEFAULT_DAMPING_RATE_FULL_THROTTLE * dampingRateScale\n    self.dampingRateZeroThrottleClutchEngaged = VehicleMotor.DEFAULT_DAMPING_RATE_ZERO_THROTTLE_CLUTCH_EN * dampingRateScale\n    self.dampingRateZeroThrottleClutchDisengaged = VehicleMotor.DEFAULT_DAMPING_RATE_ZERO_THROTTLE_CLUTCH_DIS * dampingRateScale\nend\n\n"})}),"\n",(0,a.jsx)(n.h3,{id:"setdirectionchange",children:"setDirectionChange"}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Description"})}),"\n",(0,a.jsxs)(n.blockquote,{children:["\n",(0,a.jsx)(n.p,{children:"Set power shift stages"}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Definition"})}),"\n",(0,a.jsxs)(n.blockquote,{children:["\n",(0,a.jsx)(n.p,{children:"setDirectionChange(table gearGroups, , , , )"}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,a.jsxs)(n.table,{children:[(0,a.jsx)(n.thead,{children:(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.th,{children:"table"}),(0,a.jsx)(n.th,{children:"gearGroups"}),(0,a.jsx)(n.th,{children:"gearGroups"})]})}),(0,a.jsxs)(n.tbody,{children:[(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:"any"}),(0,a.jsx)(n.td,{children:"directionChangeGearIndex"}),(0,a.jsx)(n.td,{})]}),(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:"any"}),(0,a.jsx)(n.td,{children:"directionChangeUseGroup"}),(0,a.jsx)(n.td,{})]}),(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:"any"}),(0,a.jsx)(n.td,{children:"directionChangeGroupIndex"}),(0,a.jsx)(n.td,{})]}),(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:"any"}),(0,a.jsx)(n.td,{children:"directionChangeTime"}),(0,a.jsx)(n.td,{})]})]})]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Code"})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-lua",children:"function VehicleMotor:setDirectionChange(directionChangeUseGear, directionChangeGearIndex, directionChangeUseGroup, directionChangeGroupIndex, directionChangeTime)\n    self.directionChangeUseGear = directionChangeUseGear\n    self.directionChangeGearIndex = directionChangeGearIndex\n    self.directionChangeUseGroup = directionChangeUseGroup\n    self.directionChangeGroupIndex = directionChangeGroupIndex\n    self.directionChangeTime = directionChangeTime\n    self.directionChangeUseInverse = not directionChangeUseGear and not directionChangeUseGroup\nend\n\n"})}),"\n",(0,a.jsx)(n.h3,{id:"setdirectionchangemode",children:"setDirectionChangeMode"}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Description"})}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Definition"})}),"\n",(0,a.jsxs)(n.blockquote,{children:["\n",(0,a.jsx)(n.p,{children:"setDirectionChangeMode()"}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,a.jsx)(n.table,{children:(0,a.jsx)(n.thead,{children:(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.th,{children:"any"}),(0,a.jsx)(n.th,{children:"directionChangeMode"})]})})}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Code"})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-lua",children:"function VehicleMotor:setDirectionChangeMode(directionChangeMode)\n    self.directionChangeMode = directionChangeMode\nend\n\n"})}),"\n",(0,a.jsx)(n.h3,{id:"setequalizedmotorrpm",children:"setEqualizedMotorRpm"}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Description"})}),"\n",(0,a.jsxs)(n.blockquote,{children:["\n",(0,a.jsx)(n.p,{children:"Sets equalized motor rpm"}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Definition"})}),"\n",(0,a.jsxs)(n.blockquote,{children:["\n",(0,a.jsx)(n.p,{children:"setEqualizedMotorRpm(float equalizedMotorRpm)"}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n",(0,a.jsx)(n.table,{children:(0,a.jsx)(n.thead,{children:(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.th,{children:"float"}),(0,a.jsx)(n.th,{children:"equalizedMotorRpm"}),(0,a.jsx)(n.th,{children:"equalized motor rpm"})]})})}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Code"})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-lua",children:"function VehicleMotor:setEqualizedMotorRpm(rpm)\n    self.equalizedMotorRpm = rpm\n    self:setLastRpm(rpm)\nend\n\n"})}),"\n",(0,a.jsx)(n.h3,{id:"setexternaltorquevirtualmultiplicator",children:"setExternalTorqueVirtualMultiplicator"}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Description"})}),"\n",(0,a.jsxs)(n.blockquote,{children:["\n",(0,a.jsx)(n.p,{children:"Sets the virtual external torque multiplicator"}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Definition"})}),"\n",(0,a.jsxs)(n.blockquote,{children:["\n",(0,a.jsx)(n.p,{children:"setExternalTorqueVirtualMultiplicator()"}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,a.jsx)(n.table,{children:(0,a.jsx)(n.thead,{children:(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.th,{children:"any"}),(0,a.jsx)(n.th,{children:"externalTorqueVirtualMultiplicator"})]})})}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Return Values"})}),"\n\n\n\n\n\n\n\n\n",(0,a.jsx)(n.table,{children:(0,a.jsx)(n.thead,{children:(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.th,{children:"any"}),(0,a.jsx)(n.th,{children:"externalTorqueVirtualMultiplicator"}),(0,a.jsx)(n.th,{children:"virtual external torque multiplicator"})]})})}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Code"})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-lua",children:"function VehicleMotor:setExternalTorqueVirtualMultiplicator(externalTorqueVirtualMultiplicator)\n    self.externalTorqueVirtualMultiplicator = externalTorqueVirtualMultiplicator or 1\nend\n\n"})}),"\n",(0,a.jsx)(n.h3,{id:"setgear",children:"setGear"}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Description"})}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Definition"})}),"\n",(0,a.jsxs)(n.blockquote,{children:["\n",(0,a.jsx)(n.p,{children:"setGear()"}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,a.jsxs)(n.table,{children:[(0,a.jsx)(n.thead,{children:(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.th,{children:"any"}),(0,a.jsx)(n.th,{children:"gearIndex"})]})}),(0,a.jsx)(n.tbody,{children:(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:"any"}),(0,a.jsx)(n.td,{children:"isLocked"})]})})]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Code"})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-lua",children:'function VehicleMotor:setGear(gearIndex, isLocked)\n    if gearIndex ~ = self.targetGear then\n        if self.gearChangeTime = = 0 and self.targetGear > gearIndex then\n            self.loadPercentageChangeCharge = 1\n        end\n\n        if self.gearShiftMode ~ = VehicleMotor.SHIFT_MODE_MANUAL_CLUTCH then\n            self.targetGear = gearIndex\n            self.previousGear = self.gear\n            self.gear = 0\n            self.minGearRatio = 0\n            self.maxGearRatio = 0\n            self.autoGearChangeTimer = self.autoGearChangeTime\n            self.gearChangeTimer = self.gearChangeTime\n        else\n                self.targetGear = gearIndex\n                self.previousGear = self.gear\n                self.gear = gearIndex\n            end\n\n            self.lastGearChangeTime = g_ time\n\n            local directionMultiplier = self.directionChangeUseGear and self.currentDirection or 1\n            SpecializationUtil.raiseEvent( self.vehicle, "onGearChanged" , self.gear * directionMultiplier, self.targetGear * directionMultiplier, self.gearChangeTime, self.previousGear)\n        end\n    end\n\n'})}),"\n",(0,a.jsx)(n.h3,{id:"setgearchangetime",children:"setGearChangeTime"}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Description"})}),"\n",(0,a.jsxs)(n.blockquote,{children:["\n",(0,a.jsx)(n.p,{children:"Sets the time it takes change gears"}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Definition"})}),"\n",(0,a.jsxs)(n.blockquote,{children:["\n",(0,a.jsx)(n.p,{children:"setGearChangeTime(float gearChangeTime)"}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n",(0,a.jsx)(n.table,{children:(0,a.jsx)(n.thead,{children:(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.th,{children:"float"}),(0,a.jsx)(n.th,{children:"gearChangeTime"}),(0,a.jsx)(n.th,{children:"gear change time [ms]"})]})})}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Code"})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-lua",children:"function VehicleMotor:setGearChangeTime(gearChangeTime)\n    self.gearChangeTime = gearChangeTime\n    self.gearChangeTimeOrig = gearChangeTime\n    self.gearChangeTimer = math.min( self.gearChangeTimer, gearChangeTime)\n\n    self.gearType = gearChangeTime = = 0 and VehicleMotor.TRANSMISSION_TYPE.POWERSHIFT or VehicleMotor.TRANSMISSION_TYPE.DEFAULT\nend\n\n"})}),"\n",(0,a.jsx)(n.h3,{id:"setgeargroup",children:"setGearGroup"}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Description"})}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Definition"})}),"\n",(0,a.jsxs)(n.blockquote,{children:["\n",(0,a.jsx)(n.p,{children:"setGearGroup()"}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,a.jsxs)(n.table,{children:[(0,a.jsx)(n.thead,{children:(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.th,{children:"any"}),(0,a.jsx)(n.th,{children:"groupIndex"})]})}),(0,a.jsx)(n.tbody,{children:(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:"any"}),(0,a.jsx)(n.td,{children:"isLocked"})]})})]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Code"})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-lua",children:'function VehicleMotor:setGearGroup(groupIndex, isLocked)\n    local lastActiveGearGroupIndex = self.activeGearGroupIndex\n    self.activeGearGroupIndex = groupIndex\n    self.gearGroupChangedIsLocked = isLocked\n\n    if self.activeGearGroupIndex ~ = lastActiveGearGroupIndex then\n        if self.groupType = = VehicleMotor.TRANSMISSION_TYPE.POWERSHIFT and self.activeGearGroupIndex > lastActiveGearGroupIndex then\n            self.loadPercentageChangeCharge = 1\n        end\n\n        if self.directionChangeUseGroup then\n            if self.activeGearGroupIndex > 0 then\n                local group = self.gearGroups[ self.activeGearGroupIndex]\n                self.currentDirection = math.sign(group.ratio)\n            else\n                    self.currentDirection = 1\n                end\n            end\n\n            if self.gearShiftMode ~ = VehicleMotor.SHIFT_MODE_MANUAL_CLUTCH then\n                if self.groupType = = VehicleMotor.TRANSMISSION_TYPE.DEFAULT then\n                    self.groupChangeTimer = self.groupChangeTime\n                    self.gear = 0\n                    self.minGearRatio = 0\n                    self.maxGearRatio = 0\n                elseif self.groupType = = VehicleMotor.TRANSMISSION_TYPE.POWERSHIFT then\n                        self:applyTargetGear()\n                    end\n                end\n\n                SpecializationUtil.raiseEvent( self.vehicle, "onGearGroupChanged" , self.activeGearGroupIndex, self.groupType = = VehicleMotor.TRANSMISSION_TYPE.DEFAULT and self.groupChangeTime or 0 )\n            end\n        end\n\n'})}),"\n",(0,a.jsx)(n.h3,{id:"setgeargroups",children:"setGearGroups"}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Description"})}),"\n",(0,a.jsxs)(n.blockquote,{children:["\n",(0,a.jsx)(n.p,{children:"Set power shift stages"}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Definition"})}),"\n",(0,a.jsxs)(n.blockquote,{children:["\n",(0,a.jsx)(n.p,{children:"setGearGroups(table gearGroups, , )"}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,a.jsxs)(n.table,{children:[(0,a.jsx)(n.thead,{children:(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.th,{children:"table"}),(0,a.jsx)(n.th,{children:"gearGroups"}),(0,a.jsx)(n.th,{children:"gearGroups"})]})}),(0,a.jsxs)(n.tbody,{children:[(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:"any"}),(0,a.jsx)(n.td,{children:"groupType"}),(0,a.jsx)(n.td,{})]}),(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:"any"}),(0,a.jsx)(n.td,{children:"groupChangeTime"}),(0,a.jsx)(n.td,{})]})]})]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Code"})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-lua",children:"function VehicleMotor:setGearGroups(gearGroups, groupType, groupChangeTime)\n    self.gearGroups = gearGroups\n    self.groupType = VehicleMotor.TRANSMISSION_TYPE[ string.upper(groupType)] or VehicleMotor.TRANSMISSION_TYPE.DEFAULT\n    self.groupChangeTime = groupChangeTime\n\n    if gearGroups ~ = nil then\n        self.numGearGroups = #gearGroups\n        self.defaultGearGroup = 1\n\n        -- use first forward gear group\n        for i = 1 , self.numGearGroups do\n            if self.gearGroups[i].ratio > 0 then\n                self.defaultGearGroup = i\n                break\n            end\n        end\n\n        -- use group with default attribute set\n        for i = 1 , self.numGearGroups do\n            if self.gearGroups[i].isDefault then\n                self.defaultGearGroup = i\n                break\n            end\n        end\n\n        self.activeGearGroupIndex = self.defaultGearGroup\n    end\nend\n\n"})}),"\n",(0,a.jsx)(n.h3,{id:"setgearshiftmode",children:"setGearShiftMode"}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Description"})}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Definition"})}),"\n",(0,a.jsxs)(n.blockquote,{children:["\n",(0,a.jsx)(n.p,{children:"setGearShiftMode()"}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,a.jsx)(n.table,{children:(0,a.jsx)(n.thead,{children:(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.th,{children:"any"}),(0,a.jsx)(n.th,{children:"gearShiftMode"})]})})}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Code"})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-lua",children:"function VehicleMotor:setGearShiftMode(gearShiftMode)\n    self.gearShiftMode = gearShiftMode\n\n    -- use default manual gear shift mode as we don't have a manual clutch on this transmission\n    if self.gearShiftMode = = VehicleMotor.SHIFT_MODE_MANUAL_CLUTCH then\n        if self.gearType = = VehicleMotor.TRANSMISSION_TYPE.POWERSHIFT then\n            self.gearShiftMode = VehicleMotor.SHIFT_MODE_MANUAL\n        end\n    end\nend\n\n"})}),"\n",(0,a.jsx)(n.h3,{id:"setlastrpm",children:"setLastRpm"}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Description"})}),"\n",(0,a.jsxs)(n.blockquote,{children:["\n",(0,a.jsx)(n.p,{children:"Sets last motor rpm"}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Definition"})}),"\n",(0,a.jsxs)(n.blockquote,{children:["\n",(0,a.jsx)(n.p,{children:"setLastRpm(float lastRpm)"}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n",(0,a.jsx)(n.table,{children:(0,a.jsx)(n.thead,{children:(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.th,{children:"float"}),(0,a.jsx)(n.th,{children:"lastRpm"}),(0,a.jsx)(n.th,{children:"new last motor rpm"})]})})}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Code"})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-lua",children:'function VehicleMotor:setLastRpm(lastRpm)\n    local oldMotorRpm = self.lastMotorRpm\n\n    self.lastRealMotorRpm = lastRpm\n\n    local interpolationSpeed = 0.05\n\n    -- fast rpm drop for power shift transmissions to have a clear audible drop\n        if self.gearType = = VehicleMotor.TRANSMISSION_TYPE.POWERSHIFT and(g_ time - self.lastGearChangeTime) < 200 then\n            interpolationSpeed = 0.2\n        end\n\n        self.lastMotorRpm = self.lastMotorRpm * ( 1 - interpolationSpeed) + self.lastRealMotorRpm * interpolationSpeed\n\n        -- calculate turbo speed scale depending on rpm and motor load\n        local rpmPercentage = ( self.lastMotorRpm - math.max( self.lastPtoRpm or self.minRpm, self.minRpm)) / ( self.maxRpm - self.minRpm)\n        local targetTurboRpm = rpmPercentage * self:getSmoothLoadPercentage()\n        self.lastTurboScale = self.lastTurboScale * 0.95 + targetTurboRpm * 0.05\n\n        local blowOffValveState = self.blowOffValveState\n        if self.lastAcceleratorPedal = = 0 or( self.minGearRatio = = 0 and self.autoGearChangeTime > 0 ) then\n            self.blowOffValveState = self.lastTurboScale\n        else\n                self.blowOffValveState = 0\n            end\n\n            if ( self.blowOffValveState > 0 ) ~ = (blowOffValveState > 0 ) then\n                SpecializationUtil.raiseEvent( self.vehicle, "onMotorBlowOffValveChanged" , self.blowOffValveState)\n            end\n\n            self.constantRpmCharge = 1 - math.min( math.abs( self.lastMotorRpm - oldMotorRpm) * 0.15 , 1 )\n        end\n\n'})}),"\n",(0,a.jsx)(n.h3,{id:"setlowbrakeforce",children:"setLowBrakeForce"}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Description"})}),"\n",(0,a.jsxs)(n.blockquote,{children:["\n",(0,a.jsx)(n.p,{children:"Set low brake force"}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Definition"})}),"\n",(0,a.jsxs)(n.blockquote,{children:["\n",(0,a.jsx)(n.p,{children:"setLowBrakeForce(float lowBrakeForceScale, float lowBrakeForceSpeedLimit)"}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,a.jsxs)(n.table,{children:[(0,a.jsx)(n.thead,{children:(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.th,{children:"float"}),(0,a.jsx)(n.th,{children:"lowBrakeForceScale"}),(0,a.jsx)(n.th,{children:"low brake force scale"})]})}),(0,a.jsx)(n.tbody,{children:(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:"float"}),(0,a.jsx)(n.td,{children:"lowBrakeForceSpeedLimit"}),(0,a.jsx)(n.td,{children:"low brake force speed limit"})]})})]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Code"})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-lua",children:"function VehicleMotor:setLowBrakeForce(lowBrakeForceScale, lowBrakeForceSpeedLimit)\n    self.lowBrakeForceScale = lowBrakeForceScale\n    self.lowBrakeForceSpeedLimit = lowBrakeForceSpeedLimit\nend\n\n"})}),"\n",(0,a.jsx)(n.h3,{id:"setmanualshift",children:"setManualShift"}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Description"})}),"\n",(0,a.jsxs)(n.blockquote,{children:["\n",(0,a.jsx)(n.p,{children:"Sets the manual shift settings"}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Definition"})}),"\n",(0,a.jsxs)(n.blockquote,{children:["\n",(0,a.jsx)(n.p,{children:"setManualShift(boolean gears, boolean groups)"}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,a.jsxs)(n.table,{children:[(0,a.jsx)(n.thead,{children:(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.th,{children:"boolean"}),(0,a.jsx)(n.th,{children:"gears"}),(0,a.jsx)(n.th,{children:"gears can be shifted manually"})]})}),(0,a.jsx)(n.tbody,{children:(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:"boolean"}),(0,a.jsx)(n.td,{children:"groups"}),(0,a.jsx)(n.td,{children:"groups can be shifted manually"})]})})]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Code"})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-lua",children:"function VehicleMotor:setManualShift(manualShiftGears, manualShiftGroups)\n    self.manualShiftGears = manualShiftGears\n    self.manualShiftGroups = manualShiftGroups\nend\n\n"})}),"\n",(0,a.jsx)(n.h3,{id:"setmotorrotationaccelerationlimit",children:"setMotorRotationAccelerationLimit"}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Description"})}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Definition"})}),"\n",(0,a.jsxs)(n.blockquote,{children:["\n",(0,a.jsx)(n.p,{children:"setMotorRotationAccelerationLimit()"}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,a.jsx)(n.table,{children:(0,a.jsx)(n.thead,{children:(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.th,{children:"any"}),(0,a.jsx)(n.th,{children:"limit"})]})})}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Code"})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-lua",children:"function VehicleMotor:setMotorRotationAccelerationLimit(limit)\n    self.motorRotationAccelerationLimit = limit\nend\n\n"})}),"\n",(0,a.jsx)(n.h3,{id:"setrotinertia",children:"setRotInertia"}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Description"})}),"\n",(0,a.jsxs)(n.blockquote,{children:["\n",(0,a.jsx)(n.p,{children:"Sets rotation inertia"}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Definition"})}),"\n",(0,a.jsxs)(n.blockquote,{children:["\n",(0,a.jsx)(n.p,{children:"setRotInertia(float rotInertia)"}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n",(0,a.jsx)(n.table,{children:(0,a.jsx)(n.thead,{children:(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.th,{children:"float"}),(0,a.jsx)(n.th,{children:"rotInertia"}),(0,a.jsx)(n.th,{children:"rotation inertia"})]})})}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Code"})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-lua",children:"function VehicleMotor:setRotInertia(rotInertia)\n    self.rotInertia = rotInertia\nend\n\n"})}),"\n",(0,a.jsx)(n.h3,{id:"setrpmlimit",children:"setRpmLimit"}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Description"})}),"\n",(0,a.jsxs)(n.blockquote,{children:["\n",(0,a.jsx)(n.p,{children:"Sets rpm limit"}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Definition"})}),"\n",(0,a.jsxs)(n.blockquote,{children:["\n",(0,a.jsx)(n.p,{children:"setRpmLimit(float limit)"}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n",(0,a.jsx)(n.table,{children:(0,a.jsx)(n.thead,{children:(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.th,{children:"float"}),(0,a.jsx)(n.th,{children:"limit"}),(0,a.jsx)(n.th,{children:"new limit"})]})})}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Code"})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-lua",children:"function VehicleMotor:setRpmLimit(rpmLimit)\n    self.rpmLimit = rpmLimit\nend\n\n"})}),"\n",(0,a.jsx)(n.h3,{id:"setspeedlimit",children:"setSpeedLimit"}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Description"})}),"\n",(0,a.jsxs)(n.blockquote,{children:["\n",(0,a.jsx)(n.p,{children:"Sets speed limit"}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Definition"})}),"\n",(0,a.jsxs)(n.blockquote,{children:["\n",(0,a.jsx)(n.p,{children:"setSpeedLimit(float limit)"}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n",(0,a.jsx)(n.table,{children:(0,a.jsx)(n.thead,{children:(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.th,{children:"float"}),(0,a.jsx)(n.th,{children:"limit"}),(0,a.jsx)(n.th,{children:"new limit"})]})})}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Code"})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-lua",children:"function VehicleMotor:setSpeedLimit(limit)\n    self.speedLimit = math.max(limit, self.minSpeed)\nend\n\n"})}),"\n",(0,a.jsx)(n.h3,{id:"setstartgearthreshold",children:"setStartGearThreshold"}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Description"})}),"\n",(0,a.jsxs)(n.blockquote,{children:["\n",(0,a.jsx)(n.p,{children:"Sets custom start gear threshold"}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Definition"})}),"\n",(0,a.jsxs)(n.blockquote,{children:["\n",(0,a.jsx)(n.p,{children:"setStartGearThreshold(float lowBrakeForceScale, float lowBrakeForceSpeedLimit)"}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,a.jsxs)(n.table,{children:[(0,a.jsx)(n.thead,{children:(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.th,{children:"float"}),(0,a.jsx)(n.th,{children:"lowBrakeForceScale"}),(0,a.jsx)(n.th,{children:"low brake force scale"})]})}),(0,a.jsx)(n.tbody,{children:(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:"float"}),(0,a.jsx)(n.td,{children:"lowBrakeForceSpeedLimit"}),(0,a.jsx)(n.td,{children:"low brake force speed limit"})]})})]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Code"})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-lua",children:"function VehicleMotor:setStartGearThreshold(startGearThreshold)\n    self.startGearThreshold = startGearThreshold\nend\n\n"})}),"\n",(0,a.jsx)(n.h3,{id:"settransmissiondirection",children:"setTransmissionDirection"}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Description"})}),"\n",(0,a.jsxs)(n.blockquote,{children:["\n",(0,a.jsx)(n.p,{children:"Switches the gear ratios by the given direction"}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Definition"})}),"\n",(0,a.jsxs)(n.blockquote,{children:["\n",(0,a.jsx)(n.p,{children:"setTransmissionDirection(integer direction)"}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n",(0,a.jsx)(n.table,{children:(0,a.jsx)(n.thead,{children:(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.th,{children:"integer"}),(0,a.jsx)(n.th,{children:"direction"}),(0,a.jsx)(n.th,{children:"direction"})]})})}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Code"})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-lua",children:"function VehicleMotor:setTransmissionDirection(direction)\n    if direction > 0 then\n        self.maxForwardSpeed = self.maxForwardSpeedOrigin\n        self.maxBackwardSpeed = self.maxBackwardSpeedOrigin\n        self.minForwardGearRatio = self.minForwardGearRatioOrigin\n        self.maxForwardGearRatio = self.maxForwardGearRatioOrigin\n        self.minBackwardGearRatio = self.minBackwardGearRatioOrigin\n        self.maxBackwardGearRatio = self.maxBackwardGearRatioOrigin\n    else\n            self.maxForwardSpeed = self.maxBackwardSpeedOrigin\n            self.maxBackwardSpeed = self.maxForwardSpeedOrigin\n            self.minForwardGearRatio = self.minBackwardGearRatioOrigin\n            self.maxForwardGearRatio = self.maxBackwardGearRatioOrigin\n            self.minBackwardGearRatio = self.minForwardGearRatioOrigin\n            self.maxBackwardGearRatio = self.maxForwardGearRatioOrigin\n        end\n\n        self.transmissionDirection = direction\n    end\n\n"})}),"\n",(0,a.jsx)(n.h3,{id:"shiftgear",children:"shiftGear"}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Description"})}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Definition"})}),"\n",(0,a.jsxs)(n.blockquote,{children:["\n",(0,a.jsx)(n.p,{children:"shiftGear()"}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,a.jsx)(n.table,{children:(0,a.jsx)(n.thead,{children:(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.th,{children:"any"}),(0,a.jsx)(n.th,{children:"up"})]})})}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Code"})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-lua",children:'function VehicleMotor:shiftGear(up)\n    if not self.gearChangedIsLocked then\n        if self:getIsGearChangeAllowed() then\n            local newGear\n            if up then\n                newGear = self.targetGear + 1 * self.currentDirection\n            else\n                    newGear = self.targetGear - 1 * self.currentDirection\n                end\n\n                if self.currentDirection > 0 or self.backwardGears = = nil then\n                    if newGear > # self.forwardGears then\n                        newGear = # self.forwardGears\n                    end\n                elseif self.currentDirection < 0 or self.backwardGears ~ = nil then\n                        if newGear > # self.backwardGears then\n                            newGear = # self.backwardGears\n                        end\n                    end\n\n                    if newGear ~ = self.targetGear then\n                        if self.currentDirection > 0 then\n                            if newGear < 0 then\n                                self:changeDirection( - 1 )\n                                newGear = 1\n                            end\n                        else\n                                if newGear < 0 then\n                                    self:changeDirection( 1 )\n                                    newGear = 1\n                                end\n                            end\n\n                            self:setGear(newGear)\n                            self.lastManualShifterActive = false\n                        end\n                    else\n                            SpecializationUtil.raiseEvent( self.vehicle, "onClutchCreaking" , true , false )\n                        end\n                    end\n                end\n\n'})}),"\n",(0,a.jsx)(n.h3,{id:"shiftgroup",children:"shiftGroup"}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Description"})}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Definition"})}),"\n",(0,a.jsxs)(n.blockquote,{children:["\n",(0,a.jsx)(n.p,{children:"shiftGroup()"}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,a.jsx)(n.table,{children:(0,a.jsx)(n.thead,{children:(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.th,{children:"any"}),(0,a.jsx)(n.th,{children:"up"})]})})}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Code"})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-lua",children:'function VehicleMotor:shiftGroup(up)\n    if not self.gearGroupChangedIsLocked then\n        if self:getIsGearGroupChangeAllowed() then\n            if self.gearGroups ~ = nil then\n                local newGearGroupIndex\n                if up then\n                    newGearGroupIndex = self.activeGearGroupIndex + 1\n                else\n                        newGearGroupIndex = self.activeGearGroupIndex - 1\n                    end\n\n                    self:setGearGroup( math.clamp(newGearGroupIndex, 1 , self.numGearGroups))\n                end\n            else\n                    SpecializationUtil.raiseEvent( self.vehicle, "onClutchCreaking" , true , true )\n                end\n            end\n        end\n\n'})}),"\n",(0,a.jsx)(n.h3,{id:"update",children:"update"}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Description"})}),"\n",(0,a.jsxs)(n.blockquote,{children:["\n",(0,a.jsx)(n.p,{children:"Update the state of the motor (sync with physics simulation)"}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Definition"})}),"\n",(0,a.jsxs)(n.blockquote,{children:["\n",(0,a.jsx)(n.p,{children:"update(float dt)"}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n",(0,a.jsx)(n.table,{children:(0,a.jsx)(n.thead,{children:(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.th,{children:"float"}),(0,a.jsx)(n.th,{children:"dt"}),(0,a.jsx)(n.th,{children:"time since last call in ms"})]})})}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Code"})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-lua",children:"function VehicleMotor:update(dt)\n    local vehicle = self.vehicle\n    if next(vehicle.spec_motorized.differentials) ~ = nil and vehicle.spec_motorized.motorizedNode ~ = nil then\n        local lastMotorRotSpeed = self.motorRotSpeed\n        local lastDiffRotSpeed = self.differentialRotSpeed\n        self.motorRotSpeed, self.differentialRotSpeed, self.gearRatio = getMotorRotationSpeed(vehicle.spec_motorized.motorizedNode)\n\n        if self.gearShiftMode ~ = VehicleMotor.SHIFT_MODE_MANUAL_CLUTCH then\n            -- dynamically adjust the max gear ratio while starting in a gear and have not reached the min.differential speed\n                -- this simulates clutch slipping and allows a smooth acceleration\n                if ( self.backwardGears or self.forwardGears) and self.gearRatio ~ = 0 and self.maxGearRatio ~ = 0 then\n                    if self.lastAcceleratorPedal ~ = 0 then\n                        local minDifferentialSpeed = self.minRpm / math.abs( self.maxGearRatio) * math.pi / 30\n                        if math.abs( self.differentialRotSpeed) < minDifferentialSpeed * 0.75 then\n                            self.clutchSlippingTimer = self.clutchSlippingTime\n                            self.clutchSlippingGearRatio = self.gearRatio\n                        else\n                                self.clutchSlippingTimer = math.max( self.clutchSlippingTimer - dt, 0 )\n                            end\n                        end\n                    end\n                end\n\n                if not self:getUseAutomaticGearShifting() then\n                    local accelerationPedal = self.lastAcceleratorPedal * self.currentDirection\n\n                    -- calculate additional rpm if clutch is engaged and user is pressing the accelerator pedal\n                        local clutchValue = 0\n                        if ( self.minGearRatio = = 0 and self.maxGearRatio = = 0 ) or self.manualClutchValue > 0.1 then\n                            clutchValue = 1\n                        end\n                        local direction = clutchValue * accelerationPedal\n                        if direction = = 0 then\n                            direction = - 1\n                        end\n\n                        local accelerationSpeed = direction > 0 and( self.motorRotationAccelerationLimit * 0.02 ) or self.dampingRateZeroThrottleClutchEngaged * 30 * math.pi\n                        local minRotSpeed = self.minRpm * math.pi / 30\n                        local maxRotSpeed = self.maxRpm * math.pi / 30\n                        self.motorRotSpeedClutchEngaged = math.min( math.max( self.motorRotSpeedClutchEngaged + direction * accelerationSpeed * dt, minRotSpeed), minRotSpeed + (maxRotSpeed - minRotSpeed) * accelerationPedal)\n                        self.motorRotSpeed = math.max( self.motorRotSpeed, self.motorRotSpeedClutchEngaged)\n                    end\n\n                    if g_physicsDtNonInterpolated > 0.0 and not getIsSleeping(vehicle.rootNode) then\n                        self.lastMotorAvailableTorque, self.lastMotorAppliedTorque, self.lastMotorExternalTorque = getMotorTorque(vehicle.spec_motorized.motorizedNode)\n                    end\n\n                    self.motorAvailableTorque, self.motorAppliedTorque, self.motorExternalTorque = self.lastMotorAvailableTorque, self.lastMotorAppliedTorque, self.lastMotorExternalTorque\n\n                    -- apply virtual pto torque factor\n                    self.motorAppliedTorque = self.motorAppliedTorque - self.motorExternalTorque\n                    self.motorExternalTorque = math.min( self.motorExternalTorque * self.externalTorqueVirtualMultiplicator, self.motorAvailableTorque - self.motorAppliedTorque)\n                    self.motorAppliedTorque = self.motorAppliedTorque + self.motorExternalTorque\n\n                    local motorRotAcceleration, differentialRotAcceleration = 0 , 0\n                    if g_physicsDtNonInterpolated > 0 then\n                        motorRotAcceleration = ( self.motorRotSpeed - lastMotorRotSpeed) / (g_physicsDtNonInterpolated * 0.001 )\n                        differentialRotAcceleration = ( self.differentialRotSpeed - lastDiffRotSpeed) / (g_physicsDtNonInterpolated * 0.001 )\n                    end\n\n                    self.motorRotAcceleration = motorRotAcceleration\n                    self.motorRotAccelerationSmoothed = 0.8 * self.motorRotAccelerationSmoothed + 0.2 * motorRotAcceleration\n\n                    self.differentialRotAcceleration = differentialRotAcceleration\n                    self.differentialRotAccelerationSmoothed = 0.8 * self.differentialRotAccelerationSmoothed + 0.2 * differentialRotAcceleration\n\n                    self.requiredMotorPower = math.huge\n                else\n                        local _, gearRatio = self:getMinMaxGearRatio()\n                        self.differentialRotSpeed = WheelsUtil.computeDifferentialRotSpeedNonMotor(vehicle)\n                        self.motorRotSpeed = math.max( math.abs( self.differentialRotSpeed * gearRatio), 0 )\n                        self.gearRatio = gearRatio\n                    end\n\n                    -- the clamped motor rpm always is higher-equal than the required rpm by the pto\n                    --local ptoRpm = math.min(PowerConsumer.getMaxPtoRpm(self.vehicle)*self.ptoMotorRpmRatio, self.maxRpm)\n                    -- smoothing for raise/fall of ptoRpm\n                        if self.lastPtoRpm = = nil then\n                            self.lastPtoRpm = self.minRpm\n                        end\n                        local ptoRpm = PowerConsumer.getMaxPtoRpm( self.vehicle) * self.ptoMotorRpmRatio\n                        if ptoRpm > self.lastPtoRpm then\n                            self.lastPtoRpm = math.min(ptoRpm, self.lastPtoRpm + self.maxRpm * dt / 2000 )\n                        elseif ptoRpm < self.lastPtoRpm then\n                                self.lastPtoRpm = math.max( self.minRpm, self.lastPtoRpm - self.maxRpm * dt / 1000 )\n                            end\n\n                            -- client will recieve this value from the server\n                            if self.vehicle.isServer then\n                                local clampedMotorRpm = math.max( self.motorRotSpeed * 30 / math.pi, math.min( self.lastPtoRpm, self.maxRpm), self.minRpm)\n                                self:setLastRpm(clampedMotorRpm)\n\n                                self.equalizedMotorRpm = clampedMotorRpm\n\n                                local rawLoadPercentage = self:getMotorAppliedTorque() / math.max( self:getMotorAvailableTorque(), 0.0001 )\n                                self.rawLoadPercentageBuffer = self.rawLoadPercentageBuffer + rawLoadPercentage\n                                self.rawLoadPercentageBufferIndex = self.rawLoadPercentageBufferIndex + 1\n                                if self.rawLoadPercentageBufferIndex > = 2 then\n                                    self.rawLoadPercentage = self.rawLoadPercentageBuffer / 2\n                                    self.rawLoadPercentageBuffer = 0\n                                    self.rawLoadPercentageBufferIndex = 0\n                                end\n\n                                if self.rawLoadPercentage < 0.01 and self.lastAcceleratorPedal < 0.2\n                                    and not(( self.backwardGears or self.forwardGears) and self.gear = = 0 and self.targetGear ~ = 0 ) then\n                                    -- while rolling but not currently changing gears\n                                        self.rawLoadPercentage = - 1\n                                    else\n                                            -- normal driving load is at 0 while motor is at idle load to keep it running and at 1 while it's at max load\n                                                local idleLoadPct = 0.05 -- TODO change to real idle percentage\n                                                self.rawLoadPercentage = ( self.rawLoadPercentage - idleLoadPct) / ( 1 - idleLoadPct)\n                                            end\n\n                                            local accelerationPercentage = math.min(( self.vehicle.lastSpeedAcceleration * 1000 * 1000 * self.vehicle.movingDirection) / self.accelerationLimit, 1 )\n                                            if accelerationPercentage < 0.95 and self.lastAcceleratorPedal > 0.2 then\n                                                self.accelerationLimitLoadScale = 1\n                                                self.accelerationLimitLoadScaleTimer = self.accelerationLimitLoadScaleDelay\n                                            else\n                                                    if self.accelerationLimitLoadScaleTimer > 0 then\n                                                        self.accelerationLimitLoadScaleTimer = self.accelerationLimitLoadScaleTimer - dt\n\n                                                        local alpha = math.max( self.accelerationLimitLoadScaleTimer / self.accelerationLimitLoadScaleDelay, 0 )\n                                                        self.accelerationLimitLoadScale = math.sin(( 1 - alpha) * 3.14 ) * 0.85\n                                                    end\n                                                end\n\n                                                if accelerationPercentage > 0 then\n                                                    self.rawLoadPercentage = math.max( self.rawLoadPercentage, accelerationPercentage * self.accelerationLimitLoadScale)\n                                                end\n\n                                                -- while we are not accelerating the constantAccelerationCharge is at 1, so the max.raw load from the engine is used.If we are accelerating we use only 80% of the load\n                                                    self.constantAccelerationCharge = 1 - math.min(( math.abs( self.vehicle.lastSpeedAcceleration) * 1000 * 1000 ) / self.accelerationLimit, 1 )\n                                                    if self.rawLoadPercentage > 0 then\n                                                        self.rawLoadPercentage = self.rawLoadPercentage * MAX_ACCELERATION_LOAD + self.rawLoadPercentage * ( 1 - MAX_ACCELERATION_LOAD) * self.constantAccelerationCharge\n                                                    end\n\n                                                    if self.backwardGears or self.forwardGears then\n                                                        if self:getUseAutomaticGearShifting() then\n                                                            -- if we are in automatic mode and we are stuck in one gear for a while we try to reduce the shifting time\n                                                                -- like this are are not loosing too much speed while shifting and more gears are an option\n                                                                    -- especially helpfull if we picked the wrong gear in field work\n                                                                        if self.constantRpmCharge > 0.99 then\n                                                                            if self.maxRpm - clampedMotorRpm < 50 then\n                                                                                self.gearChangeTimeAutoReductionTimer = math.min( self.gearChangeTimeAutoReductionTimer + dt, self.gearChangeTimeAutoReductionTime)\n                                                                                self.gearChangeTime = self.gearChangeTimeOrig * ( 1 - self.gearChangeTimeAutoReductionTimer / self.gearChangeTimeAutoReductionTime)\n                                                                            else\n                                                                                    self.gearChangeTimeAutoReductionTimer = 0\n                                                                                    self.gearChangeTime = self.gearChangeTimeOrig\n                                                                                end\n                                                                            else\n                                                                                    self.gearChangeTimeAutoReductionTimer = 0\n                                                                                    self.gearChangeTime = self.gearChangeTimeOrig\n                                                                                end\n                                                                            end\n                                                                        end\n                                                                    end\n\n                                                                    self:updateSmoothLoadPercentage(dt, self.rawLoadPercentage)\n\n                                                                    self.idleGearChangeTimer = math.max( self.idleGearChangeTimer - dt, 0 )\n\n                                                                    if self.forwardGears or self.backwardGears then\n                                                                        self:updateStartGearValues(dt)\n\n                                                                        local clutchPedal = self:getClutchPedal()\n                                                                        self.lastSmoothedClutchPedal = self.lastSmoothedClutchPedal * 0.9 + clutchPedal * 0.1\n                                                                    end\n\n                                                                    self.lastModulationTimer = self.lastModulationTimer + dt * MODULATION_SPEED\n                                                                    self.lastModulationPercentage = math.sin( self.lastModulationTimer) * math.sin(( self.lastModulationTimer + 2 ) * 0.3 ) * 0.8 + math.cos( self.lastModulationTimer * 5 ) * 0.2\n                                                                end\n\n"})}),"\n",(0,a.jsx)(n.h3,{id:"updategear",children:"updateGear"}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Description"})}),"\n",(0,a.jsxs)(n.blockquote,{children:["\n",(0,a.jsx)(n.p,{children:"Update gear"}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Definition"})}),"\n",(0,a.jsxs)(n.blockquote,{children:["\n",(0,a.jsx)(n.p,{children:"updateGear(float acceleratorPedal, , )"}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,a.jsxs)(n.table,{children:[(0,a.jsx)(n.thead,{children:(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.th,{children:"float"}),(0,a.jsx)(n.th,{children:"acceleratorPedal"}),(0,a.jsx)(n.th,{children:"acceleratorPedal"})]})}),(0,a.jsxs)(n.tbody,{children:[(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:"any"}),(0,a.jsx)(n.td,{children:"brakePedal"}),(0,a.jsx)(n.td,{})]}),(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:"any"}),(0,a.jsx)(n.td,{children:"dt"}),(0,a.jsx)(n.td,{})]})]})]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Return Values"})}),"\n\n\n\n\n\n\n\n\n",(0,a.jsx)(n.table,{children:(0,a.jsx)(n.thead,{children:(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.th,{children:"any"}),(0,a.jsx)(n.th,{children:"adjustedAcceleratorPedal"}),(0,a.jsx)(n.th,{children:"the adjusted accelerator pedal for the current gear situation (e.g. 0 while switching gears)"})]})})}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Code"})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-lua",children:'function VehicleMotor:updateGear(acceleratorPedal, brakePedal, dt)\n    self.lastAcceleratorPedal = acceleratorPedal\n    local adjAcceleratorPedal = acceleratorPedal\n    if self.gearChangeTimer > = 0 then\n        self.gearChangeTimer = self.gearChangeTimer - dt\n        if self.gearChangeTimer < 0 then\n            if self.targetGear ~ = 0 then\n                self.allowGearChangeTimer = 3000\n                self.allowGearChangeDirection = math.sign( self.targetGear - self.previousGear)\n\n                self:applyTargetGear()\n            end\n        end\n        adjAcceleratorPedal = 0\n    elseif self.groupChangeTimer > 0 or self.directionChangeTimer > 0 then\n            self.groupChangeTimer = self.groupChangeTimer - dt\n            self.directionChangeTimer = self.directionChangeTimer - dt\n            if self.groupChangeTimer < 0 and self.directionChangeTimer < 0 then\n                self:applyTargetGear()\n            end\n        else\n                local gearSign = 0\n                if acceleratorPedal > 0 then\n                    if self.minForwardGearRatio ~ = nil then\n                        self.minGearRatio = self.minForwardGearRatio\n                        self.maxGearRatio = self.maxForwardGearRatio\n                    else\n                            gearSign = 1\n                        end\n                    elseif acceleratorPedal < 0 then\n                            if self.minBackwardGearRatio ~ = nil then\n                                self.minGearRatio = - self.minBackwardGearRatio\n                                self.maxGearRatio = - self.maxBackwardGearRatio\n                            else\n                                    gearSign = - 1\n                                end\n                            else\n                                    if self.maxGearRatio > 0 then\n                                        if self.minForwardGearRatio = = nil then\n                                            gearSign = 1\n                                        end\n                                    elseif self.maxGearRatio < 0 then\n                                            if self.minBackwardGearRatio = = nil then\n                                                gearSign = - 1\n                                            end\n                                        end\n                                    end\n\n                                    local newGear = self.gear\n                                    local forceGearChange = false\n\n                                    -- skip gear change timer when we apply the new gear already after the directionChangeTime\n                                    local skipGearChangeTimer = false\n                                    if self.backwardGears or self.forwardGears then\n                                        if self:getUseAutomaticGearShifting() then\n                                            self.autoGearChangeTimer = self.autoGearChangeTimer - dt\n\n                                            -- the users action to accelerate will always allow shfting\n                                            -- this is just to avoid shifting while vehicle is not moving, but shfting conditions change(attaching tool, lowering/lifting tool etc.)\n                                                if self.vehicle:getIsAutomaticShiftingAllowed() or acceleratorPedal ~ = 0 then\n                                                    -- slower than 1,08km/h\n                                                    if math.abs( self.vehicle.lastSpeed) < 0.0003 then\n                                                        local directionChanged = false\n                                                        local trySelectBestGear = false\n                                                        local allowGearOverwritting = false\n                                                        if gearSign < 0 and( self.currentDirection = = 1 or self.gear = = 0 ) then\n                                                            self:changeDirection( - 1 , true )\n                                                            directionChanged = true\n                                                            skipGearChangeTimer = self.directionChangeTime > 0\n                                                        elseif gearSign > 0 and( self.currentDirection = = - 1 or self.gear = = 0 ) then\n                                                                self:changeDirection( 1 , true )\n                                                                directionChanged = true\n                                                                skipGearChangeTimer = self.directionChangeTime > 0\n                                                            elseif self.lastAcceleratorPedal = = 0 and self.idleGearChangeTimer < = 0 then\n                                                                    trySelectBestGear = true\n                                                                    self.doSecondBestGearSelection = 3\n                                                                elseif self.doSecondBestGearSelection > 0 and self.lastAcceleratorPedal ~ = 0 then\n                                                                        self.doSecondBestGearSelection = self.doSecondBestGearSelection - 1\n                                                                        if self.doSecondBestGearSelection = = 0 then\n                                                                            -- do another try for the best gear directly after acceleration started\n                                                                                -- the selected gear may not be correct due to an active speed limit(when accelerating with cruise control)\n                                                                                trySelectBestGear = true\n                                                                                allowGearOverwritting = true\n                                                                            end\n                                                                        end\n\n                                                                        if directionChanged then\n                                                                            if self.targetGear ~ = self.gear then\n                                                                                newGear = self.targetGear\n                                                                            end\n\n                                                                            trySelectBestGear = true\n                                                                        end\n\n                                                                        if trySelectBestGear then\n                                                                            local bestGear, maxFactorGroup = self:getBestStartGear( self.currentGears)\n                                                                            if bestGear ~ = self.gear or bestGear ~ = self.bestGearSelected then\n                                                                                newGear = bestGear\n\n                                                                                if bestGear > 1 or allowGearOverwritting then\n                                                                                    self.bestGearSelected = bestGear\n                                                                                    self.allowGearChangeTimer = 0\n                                                                                end\n                                                                            end\n\n                                                                            if self:getUseAutomaticGroupShifting() then\n                                                                                if maxFactorGroup ~ = nil and maxFactorGroup ~ = self.activeGearGroupIndex then\n                                                                                    self:setGearGroup(maxFactorGroup)\n                                                                                end\n                                                                            end\n                                                                        end\n                                                                    else\n                                                                            if self.gear ~ = 0 then\n                                                                                if self.autoGearChangeTimer < = 0 then\n                                                                                    if math.sign(acceleratorPedal) ~ = math.sign( self.currentDirection) then\n                                                                                        acceleratorPedal = 0\n                                                                                    end\n                                                                                    newGear = self:findGearChangeTargetGearPrediction( self.gear, self.currentGears, self.currentDirection, self.autoGearChangeTimer, acceleratorPedal, dt)\n\n                                                                                    if self:getUseAutomaticGroupShifting() then\n                                                                                        if self.gearGroups ~ = nil then\n                                                                                            -- if we are in the highest gear and the maximum rpm range(50rpm threshold) we shift one group up\n                                                                                                if self.activeGearGroupIndex < # self.gearGroups then\n                                                                                                    if math.abs( math.min( self:getLastRealMotorRpm(), self.maxRpm) - self.maxRpm) < 50 then\n                                                                                                        if self.gear = = # self.currentGears then\n                                                                                                            -- if in the highest gear we immediately shift up\n                                                                                                                local nextRatio = self.gearGroups[ self.activeGearGroupIndex + 1 ].ratio\n                                                                                                                if math.sign( self.gearGroups[ self.activeGearGroupIndex].ratio) = = math.sign(nextRatio) then\n                                                                                                                    self:shiftGroup( true )\n\n                                                                                                                    -- search for the best gear in the new group and force the selection of this gear after the group shift\n                                                                                                                        newGear = self:findGearChangeTargetGearPrediction( self.targetGear, self.currentGears, self.currentDirection, self.autoGearChangeTimer, acceleratorPedal, dt)\n                                                                                                                        forceGearChange = true\n                                                                                                                    end\n                                                                                                                elseif self.groupType = = VehicleMotor.TRANSMISSION_TYPE.POWERSHIFT then\n                                                                                                                        -- if we are stuck in a gear we wait a few seconds and then shift up\n                                                                                                                            -- this only applies for power shift groups since we expect a normal group shift with clutch is also not possible like the gear shift\n                                                                                                                                if math.sign( self.gearGroups[ self.activeGearGroupIndex].ratio) = = math.sign( self.gearGroups[ self.activeGearGroupIndex + 1 ].ratio) then\n                                                                                                                                    self.gearGroupUpShiftTimer = self.gearGroupUpShiftTimer + dt\n                                                                                                                                    if self.gearGroupUpShiftTimer > self.gearGroupUpShiftTime then\n                                                                                                                                        self.gearGroupUpShiftTimer = 0\n                                                                                                                                        self:shiftGroup( true )\n                                                                                                                                    end\n                                                                                                                                else\n                                                                                                                                        self.gearGroupUpShiftTimer = 0\n                                                                                                                                    end\n                                                                                                                                end\n                                                                                                                            else\n                                                                                                                                    self.gearGroupUpShiftTimer = 0\n                                                                                                                                end\n                                                                                                                            else\n                                                                                                                                    self.gearGroupUpShiftTimer = 0\n                                                                                                                                end\n\n                                                                                                                                -- in case we are in the first gear and below 25% of the rpm and in the group we are we would not have any gear to start we shift a group down\n                                                                                                                                if self.gear = = 1 then\n                                                                                                                                    if self.lastRealMotorRpm < self.minRpm + ( self.maxRpm - self.minRpm) * 0.25 then\n                                                                                                                                        local _, maxFactorGroup = self:getBestStartGear( self.currentGears)\n                                                                                                                                        if maxFactorGroup < self.activeGearGroupIndex then\n                                                                                                                                            if math.sign( self.gearGroups[maxFactorGroup].ratio) = = math.sign( self.gearGroups[ self.activeGearGroupIndex].ratio) then\n                                                                                                                                                self:setGearGroup(maxFactorGroup)\n                                                                                                                                            end\n                                                                                                                                        end\n                                                                                                                                    end\n                                                                                                                                end\n                                                                                                                            end\n                                                                                                                        end\n                                                                                                                    end\n                                                                                                                    newGear = math.min( math.max(newGear, 1 ), # self.currentGears)\n                                                                                                                end\n                                                                                                            end\n\n                                                                                                            -- prevent transmission from downshifting when it just upshifted.So at least try the new gear for 3sec, maybe we get the rpm higher\n                                                                                                                self.allowGearChangeTimer = self.allowGearChangeTimer - dt\n                                                                                                                if self.allowGearChangeTimer > 0 and acceleratorPedal * self.currentDirection > 0 then\n                                                                                                                    if newGear < self.gear then\n                                                                                                                        if self.allowGearChangeDirection ~ = math.sign(newGear - self.gear) then\n                                                                                                                            newGear = self.gear\n                                                                                                                        end\n                                                                                                                    end\n                                                                                                                end\n                                                                                                            end\n                                                                                                        end\n                                                                                                    end\n                                                                                                    if newGear ~ = self.gear or forceGearChange then\n                                                                                                        if newGear ~ = self.bestGearSelected then\n                                                                                                            self.bestGearSelected = - 1\n                                                                                                        end\n\n                                                                                                        self.targetGear = newGear\n                                                                                                        self.previousGear = self.gear\n                                                                                                        self.gear = 0\n                                                                                                        self.minGearRatio = 0\n                                                                                                        self.maxGearRatio = 0\n\n                                                                                                        if not skipGearChangeTimer then\n                                                                                                            self.autoGearChangeTimer = self.autoGearChangeTime\n                                                                                                            self.gearChangeTimer = self.gearChangeTime\n                                                                                                        end\n\n                                                                                                        self.lastGearChangeTime = g_ time\n                                                                                                        adjAcceleratorPedal = 0\n\n                                                                                                        local directionMultiplier = self.directionChangeUseGear and self.currentDirection or 1\n                                                                                                        SpecializationUtil.raiseEvent( self.vehicle, "onGearChanged" , self.gear * directionMultiplier, self.targetGear * directionMultiplier, self.gearChangeTimer, self.previousGear)\n\n                                                                                                        if self.gearChangeTimer = = 0 then\n                                                                                                            self.gearChangeTimer = - 1\n                                                                                                            self.allowGearChangeTimer = 3000\n                                                                                                            self.allowGearChangeDirection = math.sign( self.targetGear - self.previousGear)\n\n                                                                                                            self:applyTargetGear()\n                                                                                                        end\n                                                                                                    end\n                                                                                                end\n\n                                                                                                if self.gearShiftMode = = VehicleMotor.SHIFT_MODE_MANUAL_CLUTCH then\n                                                                                                    if self.backwardGears or self.forwardGears then\n                                                                                                        local curRatio, tarRatio\n                                                                                                        if self.currentGears[ self.gear] ~ = nil then\n                                                                                                            tarRatio = self.currentGears[ self.gear].ratio * self:getGearRatioMultiplier()\n\n                                                                                                            local differentialRotSpeed = math.max( math.abs( self.differentialRotSpeed), 0.0001 )\n                                                                                                            curRatio = math.min( self.motorRotSpeed / differentialRotSpeed, 5000 )\n                                                                                                        end\n\n                                                                                                        local ratio = 0\n                                                                                                        if tarRatio ~ = nil then\n                                                                                                            ratio = MathUtil.lerp( math.abs(tarRatio), math.abs(curRatio), math.min( self.manualClutchValue, 0.9 ) / 0.9 * 0.5 ) * math.sign(tarRatio)\n                                                                                                        end\n                                                                                                        self.minGearRatio, self.maxGearRatio = ratio, ratio\n\n                                                                                                        if self.manualClutchValue = = 0 and self.maxGearRatio ~ = 0 then\n                                                                                                            local factor = 1\n                                                                                                            local motorRpm = self:getNonClampedMotorRpm()\n                                                                                                            if motorRpm > 0 then\n                                                                                                                factor = ( self:getClutchRpm() + 50 ) / motorRpm\n                                                                                                            end\n\n                                                                                                            if factor < 0.2 then\n                                                                                                                self.stallTimer = self.stallTimer + dt\n\n                                                                                                                if self.stallTimer > 500 then\n                                                                                                                    self.vehicle:stopMotor()\n                                                                                                                    self.stallTimer = 0\n                                                                                                                end\n                                                                                                            else\n                                                                                                                    self.stallTimer = 0\n                                                                                                                end\n                                                                                                            else\n                                                                                                                    self.stallTimer = 0\n                                                                                                                end\n                                                                                                            end\n                                                                                                        end\n\n                                                                                                        if self:getUseAutomaticGearShifting() then\n                                                                                                            if math.abs( self.vehicle.lastSpeed) > 0.0003 then\n                                                                                                                if self.backwardGears or self.forwardGears then\n                                                                                                                    if ( self.currentDirection > 0 and adjAcceleratorPedal < 0 ) -- driving forwards and braking\n                                                                                                                        or( self.currentDirection < 0 and adjAcceleratorPedal > 0 ) then -- driving backwards and braking\n                                                                                                                        adjAcceleratorPedal = 0\n                                                                                                                        brakePedal = 1\n                                                                                                                    end\n                                                                                                                end\n                                                                                                            end\n                                                                                                        end\n\n                                                                                                        return adjAcceleratorPedal, brakePedal\n                                                                                                    end\n\n'})}),"\n",(0,a.jsx)(n.h3,{id:"updatesmoothloadpercentage",children:"updateSmoothLoadPercentage"}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Description"})}),"\n",(0,a.jsxs)(n.blockquote,{children:["\n",(0,a.jsx)(n.p,{children:"Update smoothed motor load percentage"}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Definition"})}),"\n",(0,a.jsxs)(n.blockquote,{children:["\n",(0,a.jsx)(n.p,{children:"updateSmoothLoadPercentage(float dt, float rawLoadPercentage)"}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,a.jsxs)(n.table,{children:[(0,a.jsx)(n.thead,{children:(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.th,{children:"float"}),(0,a.jsx)(n.th,{children:"dt"}),(0,a.jsx)(n.th,{children:"time since last update"})]})}),(0,a.jsx)(n.tbody,{children:(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:"float"}),(0,a.jsx)(n.td,{children:"rawLoadPercentage"}),(0,a.jsx)(n.td,{children:"raw load percentage from motor"})]})})]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Code"})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-lua",children:"function VehicleMotor:updateSmoothLoadPercentage(dt, rawLoadPercentage)\n    local lastSmoothedLoad = self.smoothedLoadPercentage\n\n    local maxSpeed = self:getMaximumForwardSpeed() * 3.6\n    if self.vehicle.movingDirection < 0 then\n        maxSpeed = self:getMaximumBackwardSpeed() * 3.6\n    end\n\n    local speedPercentage = math.max( math.min( self.vehicle:getLastSpeed() / maxSpeed, 1 ), 0 )\n\n    -- adjustment factor is 0.65 at min speed and 0.05 at max speed(so we counteract fast acceleration changes at max speed)\n    local factor = 0.05 + ( 1 - speedPercentage) * 0.3\n    if rawLoadPercentage < self.smoothedLoadPercentage then\n        if self.gearType ~ = VehicleMotor.TRANSMISSION_TYPE.POWERSHIFT or(g_ time - self.lastGearChangeTime) > 200 then\n            factor = factor * 0.2\n\n            -- rapid load drop while clutch is engaged\n                if self:getClutchPedal() > 0.75 then\n                    factor = factor * 5\n                end\n\n                -- if we are decelerating we want to have -1 load immediately\n                    if rawLoadPercentage < 0 then\n                        factor = factor * 2.5\n                    end\n                else\n                        -- while power shifting we reduce the load drop to have almost no load difference, only rpm difference\n                            factor = factor * 0.05\n                        end\n                    end\n                    local invFactor = 1 - factor\n\n                    self.smoothedLoadPercentage = invFactor * self.smoothedLoadPercentage + factor * rawLoadPercentage\n\n                    -- load change charge that is increased while the load increases really fast and fades out afterwards\n                        -- used to drop the motor rpm\n                        local difference = math.max( self.smoothedLoadPercentage - lastSmoothedLoad, 0 )\n                        self.loadPercentageChangeCharge = self.loadPercentageChangeCharge + difference\n                        self.loadPercentageChangeCharge = math.min( math.max( self.loadPercentageChangeCharge - dt * 0.0005 , 0 ), 1 )\n                    end\n\n"})}),"\n",(0,a.jsx)(n.h3,{id:"updatestartgearvalues",children:"updateStartGearValues"}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Description"})}),"\n",(0,a.jsxs)(n.blockquote,{children:["\n",(0,a.jsx)(n.p,{children:"Update the gear start parameters"}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Definition"})}),"\n",(0,a.jsxs)(n.blockquote,{children:["\n",(0,a.jsx)(n.p,{children:"updateStartGearValues(table gears)"}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n",(0,a.jsx)(n.table,{children:(0,a.jsx)(n.thead,{children:(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.th,{children:"table"}),(0,a.jsx)(n.th,{children:"gears"}),(0,a.jsx)(n.th,{children:"gears"})]})})}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Return Values"})}),"\n\n\n\n\n\n\n\n\n",(0,a.jsx)(n.table,{children:(0,a.jsx)(n.thead,{children:(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.th,{children:"table"}),(0,a.jsx)(n.th,{children:"bestGear"}),(0,a.jsx)(n.th,{children:"best gear to start"})]})})}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Code"})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-lua",children:'function VehicleMotor:updateStartGearValues(dt)\n    local totalMass = self.vehicle:getTotalMass()\n    local totalMassOnGround = 0 -- total mass of vehicles with wheels, excluding self.vehicle\n    local vehicleMass = self.vehicle:getTotalMass( true )\n\n    -- if the mass changes faster than 10kg/sec\n        if math.abs(totalMass - self.startGearValues.lastMass) > 0.00001 * dt then\n            self.startGearValues.lastMass = totalMass\n            self.idleGearChangeTimer = 500 -- block gear changing while mass is changing(e.g.while vehicle is filling)\n            end\n\n            -- get maxForce sum of all tools attached and calculate the mass of all wheeled tools\n            local maxForce = 0\n            local vehicles = self.vehicle:getChildVehicles()\n            for _, vehicle in ipairs(vehicles) do\n                if vehicle ~ = self.vehicle then\n                    if vehicle.spec_powerConsumer ~ = nil then\n                        if vehicle.spec_powerConsumer.maxForce ~ = nil then\n                            local multiplier = vehicle:getPowerMultiplier()\n                            if multiplier ~ = 0 then\n                                maxForce = maxForce + vehicle.spec_powerConsumer.maxForce\n                            end\n                        end\n                    end\n\n                    if vehicle.spec_leveler ~ = nil then\n                        maxForce = maxForce + math.abs(vehicle.spec_leveler.lastForce)\n                    end\n\n                    if vehicle.spec_wheels ~ = nil then\n                        if #vehicle.spec_wheels.wheels > 0 then\n                            totalMassOnGround = totalMassOnGround + vehicle:getTotalMass( true )\n                        end\n                    end\n                end\n            end\n\n            -- get average center of mass and direction of all attachments that got wheels and\n            local comX, comY, comZ = 0 , 0 , 0\n            local dirX, dirY, dirZ = 0 , 0 , 0\n            for _, vehicle in ipairs(vehicles) do\n                if vehicle ~ = self.vehicle then\n                    if vehicle.spec_wheels ~ = nil then\n                        if #vehicle.spec_wheels.wheels > 0 then\n                            local objectMass = vehicle:getTotalMass( true )\n                            local percentage = objectMass / totalMassOnGround\n                            local cx, cy, cz = vehicle:getOverallCenterOfMass()\n                            comX, comY, comZ = comX + cx * percentage, comY + cy * percentage, comZ + cz * percentage\n\n                            local iDirX, iDirY, iDirZ = vehicle:getVehicleWorldDirection()\n                            dirX, dirY, dirZ = dirX + iDirX * percentage, dirY + iDirY * percentage, dirZ + iDirZ * percentage\n                        end\n                    end\n                end\n            end\n\n            local vdx, vdy, vdz = self.vehicle:getVehicleWorldDirection()\n\n            if VehicleDebug.state = = VehicleDebug.DEBUG_TRANSMISSION then\n                local vX, vY, vZ = getWorldTranslation( self.vehicle.components[ 1 ].node)\n                DebugGizmo.renderAtPosition(comX, comY, comZ, dirX, dirY, dirZ, 0 , 1 , 0 , "TOOLS DIR" )\n                DebugGizmo.renderAtPosition(vX, vY, vZ, vdx, vdy, vdz, 0 , 1 , 0 , "VEHICLE DIR" )\n            end\n\n            -- increase the calculated mass depending in which angle the tools are to the motorized vehicle\n            -- X&Z difference normal influence and the Y difference has a higher(factor 6.6) influence\n            local diffXZ, diffY = 0 , 0\n            if dirX ~ = 0 or dirY ~ = 0 or dirZ ~ = 0 then\n                diffXZ = math.max( math.abs(dirX - vdx), math.abs(dirZ - vdz))\n\n                -- only use positive direction offset if trailer is "below" the tractor\n                    diffY = math.max(dirY - vdy, 0 )\n                end\n\n                -- full direction mass incluence is only used while additional weight is 5 tons\n                    -- so for really light tools it has more or less no impact since the tractor can also easily pull them out of there position\n                        local massDirectionInfluenceFactor = math.min((totalMass - vehicleMass) / 5 , 1 )\n\n                        self.startGearValues.massDirectionDifferenceXZ = diffXZ\n                        self.startGearValues.massDirectionDifferenceY = diffY\n                        self.startGearValues.massDirectionFactor = ( 1 + diffXZ * massDirectionInfluenceFactor) * ( 1 + (diffY / 0.15 ) * massDirectionInfluenceFactor)\n\n                        -- we use directly the PowerConsumer functions since the external torque is 0 while the clutch is engaged\n                            local neededPtoTorque = PowerConsumer.getTotalConsumedPtoTorque( self.vehicle, nil , nil , true ) / self:getPtoMotorRpmRatio()\n                            local ptoPower = self.peakMotorPowerRotSpeed * neededPtoTorque\n                            self.startGearValues.availablePower = self.peakMotorPower - ptoPower\n\n                            -- if we have a tool force active we increase it while the pto consumes power\n                                local maxForcePowerFactor = 1 + (ptoPower / self.peakMotorPower) * 0.75\n\n                                -- max force is influencing the mass to tow by factor 2 in tons\n                                local mass = (totalMass + (maxForce * maxForcePowerFactor)) / vehicleMass\n                                mass = ((mass - 1 ) * 0.5 + 1 ) * vehicleMass\n\n                                self.startGearValues.maxForce = maxForce\n                                self.startGearValues.mass = mass\n                                self.startGearValues.slope = self.vehicle:getVehicleWorldXRot()\n\n                                self.startGearValues.massFactor = ( self.startGearValues.mass * self.startGearValues.massDirectionFactor) / ((( self.startGearValues.availablePower / 100 - 1 ) * 50 + 100 ) * 0.4 )\n                            end\n\n'})}),"\n",(0,a.jsx)(n.h3,{id:"writegeardatatostream",children:"writeGearDataToStream"}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Description"})}),"\n",(0,a.jsxs)(n.blockquote,{children:["\n",(0,a.jsx)(n.p,{children:"Writes current gear data to stream"}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Definition"})}),"\n",(0,a.jsxs)(n.blockquote,{children:["\n",(0,a.jsx)(n.p,{children:"writeGearDataToStream()"}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,a.jsx)(n.table,{children:(0,a.jsx)(n.thead,{children:(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.th,{children:"any"}),(0,a.jsx)(n.th,{children:"streamId"})]})})}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Code"})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-lua",children:"function VehicleMotor:writeGearDataToStream(streamId)\n    streamWriteUIntN(streamId, math.sign( self.currentDirection) + 1 , 2 )\n\n    if streamWriteBool(streamId, self.backwardGears ~ = nil or self.forwardGears ~ = nil ) then\n        streamWriteUIntN(streamId, self.targetGear, 6 )\n        streamWriteBool(streamId, self.targetGear ~ = self.gear)\n        streamWriteBool(streamId, self.currentGears = = self.forwardGears)\n\n        if self.gearGroups ~ = nil then\n            streamWriteUIntN(streamId, self.activeGearGroupIndex, 5 )\n        end\n    end\nend\n\n"})})]})}function h(e={}){const{wrapper:n}={...(0,l.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(c,{...e})}):c(e)}},28453(e,n,r){r.d(n,{R:()=>i,x:()=>s});var t=r(96540);const a={},l=t.createContext(a);function i(e){const n=t.useContext(l);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function s(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:i(e.components),t.createElement(l.Provider,{value:n},e.children)}}}]);