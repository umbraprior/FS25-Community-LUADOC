"use strict";(globalThis.webpackChunkfs25_community_luadoc=globalThis.webpackChunkfs25_community_luadoc||[]).push([[85372],{28453(e,n,t){t.d(n,{R:()=>r,x:()=>s});var a=t(96540);const i={},l=a.createContext(i);function r(e){const n=a.useContext(l);return a.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function s(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:r(e.components),a.createElement(l.Provider,{value:n},e.children)}},99791(e,n,t){t.r(n),t.d(n,{assets:()=>o,contentTitle:()=>s,default:()=>p,frontMatter:()=>r,metadata:()=>a,toc:()=>d});const a=JSON.parse('{"id":"script/Hud/ExtendedSprayerHUDExtension","title":"ExtendedSprayerHUDExtension","description":"ExtendedSprayerHUDExtension","source":"@site/../docs/script/Hud/ExtendedSprayerHUDExtension.md","sourceDirName":"script/Hud","slug":"/script/Hud/ExtendedSprayerHUDExtension","permalink":"/FS25-Community-LUADOC/script/Hud/ExtendedSprayerHUDExtension","draft":false,"unlisted":false,"tags":[],"version":"current","lastUpdatedAt":1767161192000,"frontMatter":{},"sidebar":"docsSidebar","previous":{"title":"ExtendedSowingMachineHUDExtension","permalink":"/FS25-Community-LUADOC/script/Hud/ExtendedSowingMachineHUDExtension"},"next":{"title":"HUDTextButtonElement","permalink":"/FS25-Community-LUADOC/script/Hud/HUDTextButtonElement"}}');var i=t(74848),l=t(28453);const r={},s=void 0,o={},d=[{value:"ExtendedSprayerHUDExtension",id:"extendedsprayerhudextension",level:2},{value:"delete",id:"delete",level:3},{value:"draw",id:"draw",level:3},{value:"getHeight",id:"getheight",level:3},{value:"new",id:"new",level:3},{value:"setColorBlindMode",id:"setcolorblindmode",level:3}];function c(e){const n={a:"a",blockquote:"blockquote",code:"code",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,l.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.h2,{id:"extendedsprayerhudextension",children:"ExtendedSprayerHUDExtension"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Description"})}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsx)(n.p,{children:"Custom HUD drawing extension for precision farming sprayers\nDisplays the pH / Nitrogen actual and target values"}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Functions"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"#delete",children:"delete"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"#draw",children:"draw"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"#getheight",children:"getHeight"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"#new",children:"new"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"#setcolorblindmode",children:"setColorBlindMode"})}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"delete",children:"delete"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Description"})}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsx)(n.p,{children:"Delete this instance and clean up resources."}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Definition"})}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsx)(n.p,{children:"delete()"}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Code"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lua",children:"function ExtendedSprayerHUDExtension:delete()\n    self.backgroundTop:delete()\n    self.backgroundMiddle:delete()\n    self.backgroundBottom:delete()\n\n    self.gradient:delete()\n    self.gradientInactive:delete()\n    self.actualBar:delete()\n    self.targetBar:delete()\n    self.targetFlag:delete()\n    self.setValueBar:delete()\n    self.footerSeparationBar:delete()\n\n    g_messageCenter:unsubscribeAll( self )\n\n    self.vehicle = nil\n    self.extendedSprayer = nil\nend\n\n"})}),"\n",(0,i.jsx)(n.h3,{id:"draw",children:"draw"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Description"})}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsx)(n.p,{children:"Draw mixing ratio information for a mixing wagon when it is active."}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Definition"})}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsx)(n.p,{children:"draw()"}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"any"}),(0,i.jsx)(n.th,{children:"inputHelpDisplay"})]})}),(0,i.jsxs)(n.tbody,{children:[(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"any"}),(0,i.jsx)(n.td,{children:"posX"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"any"}),(0,i.jsx)(n.td,{children:"posY"})]})]})]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Code"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lua",children:'function ExtendedSprayerHUDExtension:draw(inputHelpDisplay, posX, posY)\n    local vehicle = self.vehicle\n    local spec = self.extendedSprayer\n\n    if spec = = nil then\n        return posY\n    end\n\n    local headline = self.texts.headline_ph_lime\n\n    local applicationRate = 0\n    local applicationRateReal = 0\n    local applicationRateStr = "%.2f t/ha"\n\n    local changeBarText = ""\n\n    local minValue = 0\n    local maxValue = 0\n\n    self.hasValidValues = false\n\n    local soilTypeName = ""\n\n    if spec.lastTouchedSoilType ~ = 0 and self.soilMap ~ = nil then\n        local soilType = self.soilMap:getSoilTypeByIndex(spec.lastTouchedSoilType)\n        if soilType ~ = nil then\n            soilTypeName = soilType.name\n        end\n    end\n\n    local hasLimeLoaded = false\n    local fillTypeDesc\n    local sourceVehicle, fillUnitIndex = ExtendedSprayer.getFillTypeSourceVehicle(vehicle)\n    local sprayFillType = sourceVehicle:getFillUnitFillType(fillUnitIndex)\n    fillTypeDesc = g_fillTypeManager:getFillTypeByIndex(sprayFillType)\n    local massPerLiter = (fillTypeDesc.massPerLiter / FillTypeManager.MASS_SCALE)\n    if sprayFillType = = FillType.LIME then\n        hasLimeLoaded = true\n    end\n\n    local descriptionText = ""\n    local stepResolution\n\n    local enableZeroTargetFlag = false\n\n    if hasLimeLoaded then\n        self.gradient:setSliceId( self.isColorBlindMode and ExtendedSprayerHUDExtension.SLICES.COLOR_BLIND_GRADIENT or ExtendedSprayerHUDExtension.SLICES.PH_GRADIENT)\n        self.gradientInactive:setSliceId( self.isColorBlindMode and ExtendedSprayerHUDExtension.SLICES.COLOR_BLIND_GRADIENT or ExtendedSprayerHUDExtension.SLICES.PH_GRADIENT)\n\n        local pHChanged = 0\n        applicationRate = spec.lastLitersPerHectar * massPerLiter\n        if not spec.sprayAmountAutoMode then\n            local requiredLitersPerHa = self.pHMap:getLimeUsageByStateChange(spec.sprayAmountManual)\n            pHChanged = self.pHMap:getPhValueFromChangedStates(spec.sprayAmountManual)\n            applicationRate = requiredLitersPerHa * massPerLiter\n\n            if pHChanged > 0 then\n                changeBarText = string.format( "pH +%s" , formatDecimalNumber(pHChanged))\n            end\n        end\n\n        if spec.phActualValue ~ = 0 and spec.phTargetValue ~ = 0 and self.vehicle.isOnField then\n            local pHActual = self.pHMap:getPhValueFromInternalValue(spec.phActualValue)\n            local pHTarget = self.pHMap:getPhValueFromInternalValue(spec.phTargetValue)\n\n            self.actualValue = pHActual\n            self.setValue = pHActual + pHChanged\n            self.targetValue = pHTarget\n\n            if spec.sprayAmountAutoMode then\n                pHChanged = self.targetValue - self.actualValue\n                if pHChanged > 0 then\n                    changeBarText = string.format( "pH +%s" , formatDecimalNumber(pHChanged))\n                end\n\n                self.setValue = self.targetValue\n            end\n\n            self.actualValueStr = "pH %.3f"\n            if soilTypeName ~ = "" then\n                if spec.sprayAmountAutoMode then\n                    descriptionText = string.format( self.texts.description_limeAuto, soilTypeName, formatDecimalNumber(pHTarget))\n                else\n                        descriptionText = string.format( self.texts.description_limeManual, soilTypeName, formatDecimalNumber(pHTarget))\n                    end\n                end\n\n                self.hasValidValues = true\n            end\n\n            if self.pHMap ~ = nil then\n                minValue, maxValue = self.pHMap:getMinMaxValue()\n            end\n\n            stepResolution = spec.pHMap:getPhValueFromChangedStates( 1 )\n        else\n                self.gradient:setSliceId( self.isColorBlindMode and ExtendedSprayerHUDExtension.SLICES.COLOR_BLIND_GRADIENT or ExtendedSprayerHUDExtension.SLICES.N_GRADIENT)\n                self.gradientInactive:setSliceId( self.isColorBlindMode and ExtendedSprayerHUDExtension.SLICES.COLOR_BLIND_GRADIENT or ExtendedSprayerHUDExtension.SLICES.N_GRADIENT)\n\n                local litersPerHectar = spec.lastLitersPerHectar\n                local nitrogenChanged = 0\n                if not spec.sprayAmountAutoMode then\n                    litersPerHectar = self.nitrogenMap:getFertilizerUsageByStateChange(spec.sprayAmountManual, sprayFillType)\n                    nitrogenChanged = self.nitrogenMap:getNitrogenFromChangedStates(spec.sprayAmountManual)\n\n                    if nitrogenChanged > 0 then\n                        changeBarText = string.format( "+%dkg N/ha" , nitrogenChanged)\n                    end\n                end\n\n                if spec.isSolidFertilizerSprayer then\n                    headline = self.texts.headline_n_solidFertilizer\n                    applicationRateStr = "%d kg/ha"\n                    applicationRate = litersPerHectar * massPerLiter * 1000\n                elseif spec.isLiquidFertilizerSprayer then\n                        headline = self.texts.headline_n_liquidFertilizer\n                        applicationRateStr = "%d l/ha"\n                        applicationRate = litersPerHectar\n                    elseif spec.isSlurryTanker then\n                            headline = self.texts.headline_n_slurryTanker\n                            applicationRateStr = "%.1f m\xb3/ha"\n                            applicationRate = litersPerHectar / 1000\n\n                            if spec.sprayAmountAutoMode and soilTypeName ~ = "" then\n                                descriptionText = string.format( self.texts.description_slurryAuto, soilTypeName)\n                            end\n                        elseif spec.isManureSpreader then\n                                headline = self.texts.headline_n_manureSpreader\n                                applicationRateStr = "%.1f t/ha"\n                                applicationRate = litersPerHectar * massPerLiter\n\n                                if spec.sprayAmountAutoMode and soilTypeName ~ = "" then\n                                    descriptionText = string.format( self.texts.description_manureAuto, soilTypeName)\n                                end\n                            end\n\n                            if spec.nActualValue > 0 and spec.nTargetValue > 0 and self.vehicle.isOnField and not spec.isDoingMissionWork then\n                                local nActual = self.nitrogenMap:getNitrogenValueFromInternalValue( math.clamp(spec.nActualValue, 0 , self.nitrogenMap.maxValue))\n                                local nTarget = self.nitrogenMap:getNitrogenValueFromInternalValue( math.clamp(spec.nTargetValue, 0 , self.nitrogenMap.maxValue))\n\n                                self.actualValue = nActual\n                                self.setValue = nActual + nitrogenChanged\n                                self.targetValue = nTarget\n\n                                if spec.sprayAmountAutoMode then\n                                    nitrogenChanged = self.targetValue - self.actualValue\n                                    if nitrogenChanged > 0 then\n                                        changeBarText = string.format( "+%dkg N/ha" , nitrogenChanged)\n                                    end\n\n                                    self.setValue = self.targetValue\n                                end\n\n                                self.actualValueStr = "%dkg N/ha"\n\n                                local forcedFruitType\n                                if vehicle.spec_sowingMachine ~ = nil then\n                                    forcedFruitType = vehicle.spec_sowingMachine.workAreaParameters.seedsFruitType\n                                end\n\n                                local fruitTypeIndex = forcedFruitType or spec.nApplyAutoModeFruitType\n                                if fruitTypeIndex ~ = nil then\n                                    local fillType = g_fillTypeManager:getFillTypeByIndex(g_fruitTypeManager:getFillTypeIndexByFruitTypeIndex(fruitTypeIndex))\n                                    if fillType ~ = nil then\n                                        if fillType ~ = FillType.UNKNOWN and soilTypeName ~ = "" then\n                                            if nTarget > 0 then\n                                                if spec.sprayAmountAutoMode then\n                                                    descriptionText = string.format( self.texts.description_fertilizerAutoFruit, fillType.title, soilTypeName)\n                                                else\n                                                        descriptionText = string.format( self.texts.description_fertilizerManualFruit, fillType.title, soilTypeName)\n                                                    end\n                                                else\n                                                        descriptionText = self.texts.description_noFertilizerRequired\n                                                        enableZeroTargetFlag = true\n                                                    end\n                                                end\n                                            end\n                                        end\n\n                                        if descriptionText = = "" and soilTypeName ~ = "" then\n                                            if spec.sprayAmountAutoMode then\n                                                descriptionText = string.format( self.texts.description_fertilizerAutoNoFruit, soilTypeName)\n\n                                                if self.nitrogenMap ~ = nil then\n                                                    local fruitTypeIndex = self.nitrogenMap:getFruitTypeIndexByFruitRequirementIndex(spec.nApplyAutoModeFruitRequirementDefaultIndex)\n                                                    if fruitTypeIndex ~ = nil then\n                                                        local fillType = g_fillTypeManager:getFillTypeByIndex(g_fruitTypeManager:getFillTypeIndexByFruitTypeIndex(fruitTypeIndex))\n                                                        if fillType ~ = nil then\n                                                            descriptionText = string.format( self.texts.description_fertilizerAutoNoFruitDefault, fillType.title, soilTypeName)\n                                                        end\n                                                    end\n                                                end\n                                            else\n                                                    descriptionText = string.format( self.texts.description_fertilizerManualNoFruit, soilTypeName)\n                                                end\n                                            end\n\n                                            self.hasValidValues = true\n                                        end\n\n                                        if self.nitrogenMap ~ = nil then\n                                            minValue, maxValue = self.nitrogenMap:getMinMaxValue()\n\n                                            local nAmount = spec.lastNitrogenProportion\n                                            if nAmount = = 0 then\n                                                nAmount = self.nitrogenMap:getNitrogenAmountFromFillType(sprayFillType)\n                                            end\n\n                                            if spec.isSlurryTanker then\n                                                local str = " (~%skgN/m\xb3)"\n                                                if sourceVehicle.getIsUsingExactNitrogenAmount ~ = nil and sourceVehicle:getIsUsingExactNitrogenAmount() then\n                                                    str = " (%skgN/m\xb3)"\n                                                end\n\n                                                applicationRateStr = applicationRateStr .. string.format(str, MathUtil.round(nAmount * 1000 , 1 ))\n                                            else\n                                                    applicationRateStr = applicationRateStr .. string.format( " (%s%%%%N)" , MathUtil.round(nAmount * 100 , 1 ))\n                                                end\n\n                                                stepResolution = self.nitrogenMap:getNitrogenFromChangedStates( 1 )\n                                            end\n                                        end\n\n                                        if spec.sprayAmountAutoMode then\n                                            applicationRateStr = applicationRateStr .. string.format( " (%s)" , self.texts.automaticShort)\n                                            soilTypeName = ""\n                                        end\n\n                                        self.actualPos = math.min(( self.actualValue - minValue) / (maxValue - minValue), 1 )\n                                        self.setValuePos = math.min(( self.setValue - minValue) / (maxValue - minValue), 1 )\n                                        self.targetPos = math.min(( self.targetValue - minValue) / (maxValue - minValue), 1 )\n\n                                        local totalHeight = self:getHeight()\n                                        local middleHeight = totalHeight - self.backgroundTop.height - self.backgroundBottom.height\n\n                                        self.backgroundTop:setPosition(posX, posY - self.backgroundTop.height)\n                                        self.backgroundMiddle:setPosition(posX, posY - self.backgroundTop.height - middleHeight)\n                                        self.backgroundBottom:setPosition(posX, posY - self.backgroundTop.height - middleHeight - self.backgroundBottom.height)\n                                        self.backgroundMiddle:setDimension( nil , middleHeight)\n                                        self.backgroundTop:render()\n                                        self.backgroundMiddle:render()\n                                        self.backgroundBottom:render()\n\n                                        local centerX = posX + self.backgroundTop.width * 0.5\n\n                                        setTextColor( 1 , 1 , 1 , 1 )\n                                        setTextBold( true )\n                                        setTextAlignment(RenderText.ALIGN_CENTER)\n                                        renderLimitedText(centerX, posY - self.textHeightHeadline * 1.1 , self.textHeightHeadline, headline, self.contentMaxWidth)\n                                        setTextBold( false )\n\n                                        -- gradient\n                                        local gradientPosX = centerX - self.gradientInactive.width * 0.5 + self.gradientPosX\n                                        local gradientPosY = posY + self.gradientPosY\n                                        if not self.hasValidValues then\n                                            gradientPosY = gradientPosY + ( self.actualBar.height - self.gradientInactive.height) + self.textHeight\n                                        end\n\n                                        self.gradientInactive:setPosition(gradientPosX, gradientPosY)\n                                        self.gradientInactive:render()\n\n                                        local gradientVisibilePos = 0\n                                        if self.hasValidValues then\n                                            gradientVisibilePos = self.actualPos\n                                        end\n\n                                        self.gradient:setPosition(gradientPosX, gradientPosY)\n                                        self.gradient:setDimension(gradientVisibilePos * self.gradientInactive.width)\n\n                                        local uvs = self.gradient.uvs\n                                        local uv5 = uvs[ 1 ] + (uvs[ 5 ] - uvs[ 1 ]) * gradientVisibilePos\n                                        local uv7 = uvs[ 3 ] + (uvs[ 7 ] - uvs[ 3 ]) * gradientVisibilePos\n                                        setOverlayUVs( self.gradient.overlayId, uvs[ 1 ], uvs[ 2 ], uvs[ 3 ], uvs[ 4 ], uv5, uvs[ 6 ], uv7, uvs[ 8 ])\n                                        self.gradient:render()\n\n                                        local labelMin\n                                        local labelMax\n                                        if hasLimeLoaded then\n                                            labelMin = string.format( "pH\\n%s" , minValue)\n                                            labelMax = string.format( "pH\\n%s" , maxValue)\n                                        else\n                                                labelMin = string.format( "%s\\nkg/ha" , minValue)\n                                                labelMax = string.format( "%s\\nkg/ha" , maxValue)\n                                            end\n\n                                            local widthDiff = ( self.backgroundTop.width - self.gradientInactive.width) * 0.25\n                                            renderLimitedText(posX + widthDiff, gradientPosY + self.gradientInactive.height * 0.85 , self.gradientInactive.height * 1.3 , labelMin)\n                                            renderLimitedText(posX + self.backgroundTop.width - widthDiff, gradientPosY + self.gradientInactive.height * 0.85 , self.gradientInactive.height * 1.3 , labelMax)\n\n                                            local additionalChangeLineHeight = 0\n\n                                            -- actual\n                                            local changeBarRendered = false\n                                            if self.hasValidValues then\n                                                -- target\n                                                local targetBarX, targetBarY\n                                                local showFlag = self.targetPos ~ = 0 or enableZeroTargetFlag\n                                                if showFlag then\n                                                    targetBarX = gradientPosX + self.gradientInactive.width * self.targetPos - self.targetBar.width * 0.5\n                                                    targetBarY = gradientPosY\n                                                    self.targetBar:setPosition(targetBarX, targetBarY)\n                                                    self.targetBar:render()\n\n                                                    self.targetFlag:setPosition(targetBarX, targetBarY + self.targetBar.height)\n                                                    self.targetFlag:render()\n                                                end\n\n                                                local actualBarText\n                                                local actualBarTextOffset = self.actualBar.height + self.textHeight * 1.1\n                                                local actualBarSkipFlagCollisionCheck = false\n                                                if self.actualPos ~ = self.targetPos then\n                                                    actualBarText = string.format( self.texts.actualValue, string.format( self.actualValueStr, self.actualValue))\n                                                elseif spec.sprayAmountAutoMode or self.targetPos = = self.setValuePos then\n                                                        if self.targetPos ~ = 0 then\n                                                            actualBarText = string.format( self.texts.targetReached, string.format( self.actualValueStr, self.actualValue))\n                                                            actualBarTextOffset = - self.textHeight * 0.7\n                                                            actualBarSkipFlagCollisionCheck = true\n                                                            changeBarRendered = true\n                                                        end\n                                                    end\n\n                                                    if actualBarText ~ = nil then\n                                                        local actualBarX = gradientPosX + self.gradientInactive.width * self.actualPos - self.actualBar.width * 0.5\n                                                        local actualBarY = gradientPosY + ( self.gradientInactive.height - self.actualBar.height) * 0.5\n\n                                                        self.actualBar:setPosition(actualBarX, actualBarY)\n                                                        self.actualBar:render()\n\n                                                        local actualTextWidth = getTextWidth( self.textHeight * 0.7 , actualBarText)\n                                                        actualBarX = math.max( math.min(actualBarX, (posX + self.backgroundTop.width) - actualTextWidth * 0.5 ), posX + actualTextWidth * 0.5 )\n\n                                                        if not actualBarSkipFlagCollisionCheck and showFlag then\n                                                            local rightTextBorder = actualBarX + actualTextWidth * 0.5\n                                                            if rightTextBorder > targetBarX and rightTextBorder < targetBarX + self.targetFlag.width * 0.5 then\n                                                                actualBarX = targetBarX - actualTextWidth * 0.5 - self.pixelSizeX\n                                                            end\n\n                                                            local leftTextBorder = actualBarX - actualTextWidth * 0.5\n                                                            if (leftTextBorder > targetBarX and leftTextBorder < targetBarX + self.targetFlag.width * 0.5 )\n                                                                or(targetBarX > leftTextBorder and targetBarX < rightTextBorder) then\n                                                                actualBarX = targetBarX + self.targetFlag.width + self.pixelSizeX + actualTextWidth * 0.5\n                                                            end\n                                                        end\n\n                                                        renderLimitedText(actualBarX, actualBarY + actualBarTextOffset, self.textHeight * 0.7 , actualBarText)\n                                                    end\n\n                                                    if self.setValuePos > self.actualPos then\n                                                        local goodColor = ExtendedSprayerHUDExtension.COLOR.SET_VALUE_BAR_GOOD\n                                                        local badColor = ExtendedSprayerHUDExtension.COLOR.SET_VALUE_BAR_BAD\n                                                        local difference = math.min(( math.abs( self.setValue - self.targetValue) / stepResolution) / 3 , 1 )\n                                                        local differenceInv = 1 - difference\n                                                        local r, g, b, a = difference * badColor[ 1 ] + differenceInv * goodColor[ 1 ],\n                                                        difference * badColor[ 2 ] + differenceInv * goodColor[ 2 ],\n                                                        difference * badColor[ 3 ] + differenceInv * goodColor[ 3 ],\n                                                        1\n                                                        local setValueBarX = gradientPosX + self.gradientInactive.width * self.actualPos\n                                                        local setValueBarY = gradientPosY - self.gradientInactive.height - self.setValueBar.height\n                                                        self.setValueBar:setPosition(setValueBarX, setValueBarY)\n                                                        self.setValueBar:setDimension( self.gradientInactive.width * ( math.min( self.setValuePos, 1 ) - self.actualPos))\n                                                        self.setValueBar:setColor(r, g, b, a)\n                                                        self.setValueBar:render()\n\n                                                        local setBarTextX = setValueBarX + self.setValueBar.width * 0.5\n                                                        local setBarTextY = setValueBarY + self.setValueBar.height * 0.2\n                                                        local setTextWidth = getTextWidth( self.setValueBar.height * 0.9 , changeBarText)\n                                                        if setTextWidth > self.setValueBar.width * 0.95 then\n                                                            setBarTextY = setValueBarY - self.setValueBar.height\n                                                            additionalChangeLineHeight = self.setValueBar.height\n                                                        end\n                                                        renderLimitedText(setBarTextX, setBarTextY, self.setValueBar.height * 0.9 , changeBarText)\n\n                                                        changeBarRendered = true\n                                                    end\n                                                else\n                                                        descriptionText = self.texts.invalidValues\n                                                    end\n\n                                                    local bottomPosY = posY - self:getHeight()\n\n                                                    if descriptionText ~ = "" and self.additionalDisplayHeight ~ = 0 then\n                                                        setTextAlignment(RenderText.ALIGN_CENTER)\n                                                        renderLimitedText(centerX, bottomPosY + self.footerOffset + self.textHeight * 1.85 , self.textHeight, descriptionText, self.contentMaxWidth)\n                                                    end\n\n                                                    self.footerSeparationBar:setPosition(centerX - self.footerSeparationBar.width * 0.5 , bottomPosY + self.footerOffset + self.textHeight * 1.3 )\n                                                    self.footerSeparationBar:render()\n\n                                                    -- footer\n                                                    setTextAlignment(RenderText.ALIGN_LEFT)\n                                                    local sideOffset = ( self.backgroundTop.width - self.contentMaxWidth) * 0.5\n                                                    local rateText = self.texts.applicationRate .. " " .. string.format(applicationRateStr, applicationRate, applicationRateReal)\n                                                    local rateWidth = renderLimitedText(posX + sideOffset, bottomPosY + self.footerOffset, self.textHeight, rateText, self.contentMaxWidth)\n\n                                                    if soilTypeName ~ = "" then\n                                                        local maxWidth = self.contentMaxWidth - rateWidth - self.footerTextSpacing\n                                                        setTextAlignment(RenderText.ALIGN_RIGHT)\n                                                        renderLimitedText(posX + self.backgroundTop.width - sideOffset, bottomPosY + self.footerOffset, self.textHeight, string.format( self.texts.soilType, soilTypeName), maxWidth)\n                                                    end\n\n                                                    -- do that at the end so we give the ui some time to increase the window height and then render the text above\n                                                    self.additionalDisplayHeight = additionalChangeLineHeight\n                                                    if descriptionText ~ = "" then\n                                                        self.additionalDisplayHeight = self.additionalDisplayHeight + self.additionalTextHeightOffset\n                                                    end\n                                                    if not self.hasValidValues then\n                                                        self.additionalDisplayHeight = self.additionalDisplayHeight - self.invalidHeightOffset\n                                                    elseif not changeBarRendered then\n                                                            self.additionalDisplayHeight = self.additionalDisplayHeight - self.noSetBarHeightOffset\n                                                        end\n\n                                                        return bottomPosY\n                                                    end\n\n'})}),"\n",(0,i.jsx)(n.h3,{id:"getheight",children:"getHeight"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Description"})}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsx)(n.p,{children:"Get this HUD extension's display height."}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Definition"})}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsx)(n.p,{children:"getHeight()"}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Return Values"})}),"\n\n\n\n\n\n\n\n\n",(0,i.jsx)(n.table,{children:(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"any"}),(0,i.jsx)(n.th,{children:"Display"}),(0,i.jsx)(n.th,{children:"height in screen space"})]})})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Code"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lua",children:"function ExtendedSprayerHUDExtension:getHeight()\n    return( self.displayHeight or 0 ) + ( self.additionalDisplayHeight or 0 )\nend\n\n"})}),"\n",(0,i.jsx)(n.h3,{id:"new",children:"new"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Description"})}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsx)(n.p,{children:"Create a new instance of ExtendedSprayerHUDExtension."}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Definition"})}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsx)(n.p,{children:"new(table vehicle, )"}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"table"}),(0,i.jsx)(n.th,{children:"vehicle"}),(0,i.jsx)(n.th,{children:"Vehicle which has the specialization required by a sub-class"})]})}),(0,i.jsx)(n.tbody,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"any"}),(0,i.jsx)(n.td,{children:"customMt"}),(0,i.jsx)(n.td,{})]})})]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Code"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lua",children:'function ExtendedSprayerHUDExtension.new(vehicle, customMt)\n    local self = setmetatable( { } , customMt or ExtendedSprayerHUDExtension _mt)\n\n    self.priority = GS_PRIO_LOW\n\n    self.vehicle = vehicle\n    self.extendedSprayer = vehicle[ ExtendedSprayer.SPEC_TABLE_NAME]\n\n    self.backgroundTop = g_overlayManager:createOverlay( "precisionFarming.shortcutBox_top" , 0 , 0 , 0 , 0 )\n    self.backgroundMiddle = g_overlayManager:createOverlay( "precisionFarming.shortcutBox_middle" , 0 , 0 , 0 , 0 )\n    self.backgroundBottom = g_overlayManager:createOverlay( "precisionFarming.shortcutBox_bottom" , 0 , 0 , 0 , 0 )\n\n    local r, g, b, a = unpack(HUD.COLOR.BACKGROUND)\n    self.backgroundTop:setColor(r, g, b, a)\n    self.backgroundMiddle:setColor(r, g, b, a)\n    self.backgroundBottom:setColor(r, g, b, a)\n\n    self.gradient = g_overlayManager:createOverlay( ExtendedSprayerHUDExtension.SLICES.PH_GRADIENT, 0 , 0 , 0 , 0 )\n\n    self.gradientInactive = g_overlayManager:createOverlay( ExtendedSprayerHUDExtension.SLICES.PH_GRADIENT, 0 , 0 , 0 , 0 )\n    self.gradientInactive:setColor( 0.4 , 0.4 , 0.4 , 1 )\n\n    self.actualBar = g_overlayManager:createOverlay( "precisionFarming.filled" , 0 , 0 , 0 , 0 )\n    self.actualBar:setColor( unpack( ExtendedSprayerHUDExtension.COLOR.ACTUAL_BAR))\n\n    self.targetBar = g_overlayManager:createOverlay( "precisionFarming.target_bar" , 0 , 0 , 0 , 0 )\n\n    self.targetFlag = g_overlayManager:createOverlay( "precisionFarming.target_flag" , 0 , 0 , 0 , 0 )\n\n    self.setValueBar = g_overlayManager:createOverlay( "precisionFarming.filled" , 0 , 0 , 0 , 0 )\n    self.setValueBar:setColor( unpack( ExtendedSprayerHUDExtension.COLOR.SET_VALUE_BAR_GOOD))\n\n    self.footerSeparationBar = g_overlayManager:createOverlay( "precisionFarming.filled" , 0 , 0 , 0 , 0 )\n    self.footerSeparationBar:setColor( unpack( ExtendedSprayerHUDExtension.COLOR.SEPARATOR_BAR))\n\n    self.actualPos = 0.34\n    self.targetPos = 0.8\n\n    self.actualValue = 0\n    self.actualValueStr = "%.3f"\n\n    self.setValue = 0\n    self.targetValue = 0\n\n    self.hasValidValues = false\n\n    self.soilMap = g_precisionFarming.soilMap\n    self.pHMap = g_precisionFarming.pHMap\n    self.nitrogenMap = g_precisionFarming.nitrogenMap\n\n    self.texts = { }\n    self.texts.headline_ph_lime = g_i18n:getText( "hudExtensionSprayer_headline_ph_lime" , ExtendedSprayerHUDExtension.MOD_NAME)\n    self.texts.headline_n_solidFertilizer = g_i18n:getText( "hudExtensionSprayer_headline_n_solidFertilizer" , ExtendedSprayerHUDExtension.MOD_NAME)\n    self.texts.headline_n_liquidFertilizer = g_i18n:getText( "hudExtensionSprayer_headline_n_liquidFertilizer" , ExtendedSprayerHUDExtension.MOD_NAME)\n    self.texts.headline_n_slurryTanker = g_i18n:getText( "hudExtensionSprayer_headline_n_slurryTanker" , ExtendedSprayerHUDExtension.MOD_NAME)\n    self.texts.headline_n_manureSpreader = g_i18n:getText( "hudExtensionSprayer_headline_n_manureSpreader" , ExtendedSprayerHUDExtension.MOD_NAME)\n    self.texts.actualValue = g_i18n:getText( "hudExtensionSprayer_actualValue" , ExtendedSprayerHUDExtension.MOD_NAME)\n    self.texts.newValue = g_i18n:getText( "hudExtensionSprayer_newValue" , ExtendedSprayerHUDExtension.MOD_NAME)\n    self.texts.targetReached = g_i18n:getText( "hudExtensionSprayer_targetReached" , ExtendedSprayerHUDExtension.MOD_NAME)\n    self.texts.applicationRate = g_i18n:getText( "hudExtensionSprayer_applicationRate" , ExtendedSprayerHUDExtension.MOD_NAME)\n    self.texts.soilType = g_i18n:getText( "hudExtensionSprayer_soilType" , ExtendedSprayerHUDExtension.MOD_NAME)\n    self.texts.unknown = g_i18n:getText( "hudExtensionSprayer_unknown" , ExtendedSprayerHUDExtension.MOD_NAME)\n    self.texts.automaticShort = g_i18n:getText( "hudExtensionSprayer_automaticShort" , ExtendedSprayerHUDExtension.MOD_NAME)\n    self.texts.description_limeAuto = g_i18n:getText( "hudExtensionSprayer_description_limeAuto" , ExtendedSprayerHUDExtension.MOD_NAME)\n    self.texts.description_limeManual = g_i18n:getText( "hudExtensionSprayer_description_limeManual" , ExtendedSprayerHUDExtension.MOD_NAME)\n    self.texts.description_slurryAuto = g_i18n:getText( "hudExtensionSprayer_description_slurryAuto" , ExtendedSprayerHUDExtension.MOD_NAME)\n    self.texts.description_manureAuto = g_i18n:getText( "hudExtensionSprayer_description_manureAuto" , ExtendedSprayerHUDExtension.MOD_NAME)\n    self.texts.description_fertilizerAutoFruit = g_i18n:getText( "hudExtensionSprayer_description_fertilizerAutoFruit" , ExtendedSprayerHUDExtension.MOD_NAME)\n    self.texts.description_fertilizerAutoNoFruit = g_i18n:getText( "hudExtensionSprayer_description_fertilizerAutoNoFruit" , ExtendedSprayerHUDExtension.MOD_NAME)\n    self.texts.description_fertilizerAutoNoFruitDefault = g_i18n:getText( "hudExtensionSprayer_description_fertilizerAutoNoFruitDefault" , ExtendedSprayerHUDExtension.MOD_NAME)\n    self.texts.description_fertilizerManualFruit = g_i18n:getText( "hudExtensionSprayer_description_fertilizerManualFruit" , ExtendedSprayerHUDExtension.MOD_NAME)\n    self.texts.description_fertilizerManualNoFruit = g_i18n:getText( "hudExtensionSprayer_description_fertilizerManualNoFruit" , ExtendedSprayerHUDExtension.MOD_NAME)\n    self.texts.description_noFertilizerRequired = g_i18n:getText( "hudExtensionSprayer_description_noFertilizerRequired" , ExtendedSprayerHUDExtension.MOD_NAME)\n    self.texts.invalidValues = g_i18n:getText( "hudExtensionSprayer_invalidValues" , ExtendedSprayerHUDExtension.MOD_NAME)\n\n    self.actualValueStr = self.texts.unknown\n\n    self.isColorBlindMode = g_gameSettings:getValue(GameSettings.SETTING.USE_COLORBLIND_MODE) or false\n\n    g_messageCenter:subscribe(MessageType.SETTING_CHANGED[GameSettings.SETTING.USE_COLORBLIND_MODE], self.setColorBlindMode, self )\n    g_messageCenter:subscribe(MessageType.SETTING_CHANGED[GameSettings.SETTING.UI_SCALE], self.storeScaledValues, self )\n\n    self:storeScaledValues()\n\n    return self\nend\n\n'})}),"\n",(0,i.jsx)(n.h3,{id:"setcolorblindmode",children:"setColorBlindMode"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Description"})}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsx)(n.p,{children:"Determine if the HUD extension should be drawn."}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Definition"})}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsx)(n.p,{children:"setColorBlindMode()"}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,i.jsx)(n.table,{children:(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"any"}),(0,i.jsx)(n.th,{children:"isActive"})]})})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Code"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lua",children:"function ExtendedSprayerHUDExtension:setColorBlindMode(isActive)\n    if isActive ~ = self.isColorBlindMode then\n        self.isColorBlindMode = isActive\n\n        self.pHMap:setMinimapRequiresUpdate( true )\n        self.nitrogenMap:setMinimapRequiresUpdate( true )\n    end\nend\n\n"})})]})}function p(e={}){const{wrapper:n}={...(0,l.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(c,{...e})}):c(e)}}}]);