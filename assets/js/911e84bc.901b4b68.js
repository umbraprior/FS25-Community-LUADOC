"use strict";(globalThis.webpackChunkfs25_community_luadoc=globalThis.webpackChunkfs25_community_luadoc||[]).push([[81258],{3526(e,n,i){i.r(n),i.d(n,{assets:()=>d,contentTitle:()=>a,default:()=>h,frontMatter:()=>r,metadata:()=>t,toc:()=>o});const t=JSON.parse('{"id":"script/Specializations/Pipe","title":"Pipe","description":"Pipe","source":"@site/../docs/script/Specializations/Pipe.md","sourceDirName":"script/Specializations","slug":"/script/Specializations/Pipe","permalink":"/FS25-Community-LUADOC/script/Specializations/Pipe","draft":false,"unlisted":false,"tags":[],"version":"current","lastUpdatedAt":1767161192000,"frontMatter":{},"sidebar":"docsSidebar","previous":{"title":"Pickup","permalink":"/FS25-Community-LUADOC/script/Specializations/Pickup"},"next":{"title":"PlaceableAI","permalink":"/FS25-Community-LUADOC/script/Specializations/PlaceableAI"}}');var s=i(74848),l=i(28453);const r={},a=void 0,d={},o=[{value:"Pipe",id:"pipe",level:2},{value:"actionControllerPipeEvent",id:"actioncontrollerpipeevent",level:3},{value:"actionEventToggleDischargeToGround",id:"actioneventtoggledischargetoground",level:3},{value:"actionEventTogglePipe",id:"actioneventtogglepipe",level:3},{value:"getCanBeSelected",id:"getcanbeselected",level:3},{value:"getCanBeTurnedOn",id:"getcanbeturnedon",level:3},{value:"getCanToggleDischargeToGround",id:"getcantoggledischargetoground",level:3},{value:"getCanToggleDischargeToObject",id:"getcantoggledischargetoobject",level:3},{value:"getCurrentPipeState",id:"getcurrentpipestate",level:3},{value:"getIsAIPreparingToDrive",id:"getisaipreparingtodrive",level:3},{value:"getIsAIReadyToDrive",id:"getisaireadytodrive",level:3},{value:"getIsDischargeNodeActive",id:"getisdischargenodeactive",level:3},{value:"getIsFoldAllowed",id:"getisfoldallowed",level:3},{value:"getIsMovingToolActive",id:"getismovingtoolactive",level:3},{value:"getIsNextCoverStateAllowed",id:"getisnextcoverstateallowed",level:3},{value:"getIsPipeStateChangeAllowed",id:"getispipestatechangeallowed",level:3},{value:"getPipeDischargeNodeIndex",id:"getpipedischargenodeindex",level:3},{value:"getRequiresPower",id:"getrequirespower",level:3},{value:"getTurnedOnNotAllowedWarning",id:"getturnedonnotallowedwarning",level:3},{value:"handleDischarge",id:"handledischarge",level:3},{value:"handleDischargeRaycast",id:"handledischargeraycast",level:3},{value:"initSpecialization",id:"initspecialization",level:3},{value:"loadCoverFromXML",id:"loadcoverfromxml",level:3},{value:"loadMovingToolFromXML",id:"loadmovingtoolfromxml",level:3},{value:"loadPipeNodes",id:"loadpipenodes",level:3},{value:"loadUnloadingTriggers",id:"loadunloadingtriggers",level:3},{value:"onAIImplementPrepareForTransport",id:"onaiimplementpreparefortransport",level:3},{value:"onDelete",id:"ondelete",level:3},{value:"onDeletePipeObject",id:"ondeletepipeobject",level:3},{value:"onDischargeStateChanged",id:"ondischargestatechanged",level:3},{value:"onLoad",id:"onload",level:3},{value:"onMovingToolChanged",id:"onmovingtoolchanged",level:3},{value:"onPostLoad",id:"onpostload",level:3},{value:"onReadStream",id:"onreadstream",level:3},{value:"onReadUpdateStream",id:"onreadupdatestream",level:3},{value:"onRegisterActionEvents",id:"onregisteractionevents",level:3},{value:"onRootVehicleChanged",id:"onrootvehiclechanged",level:3},{value:"onUpdate",id:"onupdate",level:3},{value:"onUpdateTick",id:"onupdatetick",level:3},{value:"onWriteStream",id:"onwritestream",level:3},{value:"onWriteUpdateStream",id:"onwriteupdatestream",level:3},{value:"prerequisitesPresent",id:"prerequisitespresent",level:3},{value:"registerEventListeners",id:"registereventlisteners",level:3},{value:"registerFunctions",id:"registerfunctions",level:3},{value:"registerOverwrittenFunctions",id:"registeroverwrittenfunctions",level:3},{value:"registers",id:"registers",level:3},{value:"saveToXMLFile",id:"savetoxmlfile",level:3},{value:"setPipeDischargeToGround",id:"setpipedischargetoground",level:3},{value:"setPipeState",id:"setpipestate",level:3},{value:"unloadingTriggerCallback",id:"unloadingtriggercallback",level:3},{value:"updateActionEventText",id:"updateactioneventtext",level:3},{value:"updateBendingRegulationNodes",id:"updatebendingregulationnodes",level:3},{value:"updateNearestObjectInTriggers",id:"updatenearestobjectintriggers",level:3},{value:"updatePipeNodes",id:"updatepipenodes",level:3}];function c(e){const n={a:"a",blockquote:"blockquote",code:"code",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,l.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.h2,{id:"pipe",children:"Pipe"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"Specialization for vehicles unloading via (foldable) pipe/conveyor (combine, augar wagon, potato/sugarBeet\nharvester, ...)"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Functions"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#actioncontrollerpipeevent",children:"actionControllerPipeEvent"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#actioneventtoggledischargetoground",children:"actionEventToggleDischargeToGround"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#actioneventtogglepipe",children:"actionEventTogglePipe"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#getcanbeselected",children:"getCanBeSelected"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#getcanbeturnedon",children:"getCanBeTurnedOn"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#getcantoggledischargetoground",children:"getCanToggleDischargeToGround"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#getcantoggledischargetoobject",children:"getCanToggleDischargeToObject"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#getcurrentpipestate",children:"getCurrentPipeState"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#getisaipreparingtodrive",children:"getIsAIPreparingToDrive"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#getisaireadytodrive",children:"getIsAIReadyToDrive"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#getisdischargenodeactive",children:"getIsDischargeNodeActive"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#getisfoldallowed",children:"getIsFoldAllowed"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#getismovingtoolactive",children:"getIsMovingToolActive"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#getisnextcoverstateallowed",children:"getIsNextCoverStateAllowed"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#getispipestatechangeallowed",children:"getIsPipeStateChangeAllowed"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#getpipedischargenodeindex",children:"getPipeDischargeNodeIndex"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#getrequirespower",children:"getRequiresPower"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#getturnedonnotallowedwarning",children:"getTurnedOnNotAllowedWarning"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#handledischarge",children:"handleDischarge"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#handledischargeraycast",children:"handleDischargeRaycast"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#initspecialization",children:"initSpecialization"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#loadcoverfromxml",children:"loadCoverFromXML"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#loadmovingtoolfromxml",children:"loadMovingToolFromXML"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#loadpipenodes",children:"loadPipeNodes"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#loadunloadingtriggers",children:"loadUnloadingTriggers"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#onaiimplementpreparefortransport",children:"onAIImplementPrepareForTransport"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#ondelete",children:"onDelete"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#ondeletepipeobject",children:"onDeletePipeObject"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#ondischargestatechanged",children:"onDischargeStateChanged"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#onload",children:"onLoad"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#onmovingtoolchanged",children:"onMovingToolChanged"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#onpostload",children:"onPostLoad"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#onreadstream",children:"onReadStream"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#onreadupdatestream",children:"onReadUpdateStream"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#onregisteractionevents",children:"onRegisterActionEvents"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#onrootvehiclechanged",children:"onRootVehicleChanged"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#onupdate",children:"onUpdate"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#onupdatetick",children:"onUpdateTick"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#onwritestream",children:"onWriteStream"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#onwriteupdatestream",children:"onWriteUpdateStream"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#prerequisitespresent",children:"prerequisitesPresent"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#registereventlisteners",children:"registerEventListeners"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#registerfunctions",children:"registerFunctions"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#registeroverwrittenfunctions",children:"registerOverwrittenFunctions"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#registers",children:"registers"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#savetoxmlfile",children:"saveToXMLFile"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#setpipedischargetoground",children:"setPipeDischargeToGround"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#setpipestate",children:"setPipeState"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#unloadingtriggercallback",children:"unloadingTriggerCallback"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#updateactioneventtext",children:"updateActionEventText"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#updatebendingregulationnodes",children:"updateBendingRegulationNodes"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#updatenearestobjectintriggers",children:"updateNearestObjectInTriggers"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#updatepipenodes",children:"updatePipeNodes"})}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"actioncontrollerpipeevent",children:"actionControllerPipeEvent"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Definition"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"actionControllerPipeEvent()"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"any"}),(0,s.jsx)(n.th,{children:"self"})]})}),(0,s.jsx)(n.tbody,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"any"}),(0,s.jsx)(n.td,{children:"direction"})]})})]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Code"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:"function Pipe.actionControllerPipeEvent( self , direction)\n    local spec = self.spec_pipe\n    if direction > 0 then\n        local autoAimState, _ = next(spec.autoAimingStates)\n        self:setPipeState(autoAimState)\n    else\n            self:setPipeState( 1 )\n        end\n\n        return true\n    end\n\n"})}),"\n",(0,s.jsx)(n.h3,{id:"actioneventtoggledischargetoground",children:"actionEventToggleDischargeToGround"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Definition"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"actionEventToggleDischargeToGround()"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"any"}),(0,s.jsx)(n.th,{children:"self"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"any"}),(0,s.jsx)(n.td,{children:"actionName"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"any"}),(0,s.jsx)(n.td,{children:"inputValue"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"any"}),(0,s.jsx)(n.td,{children:"callbackState"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"any"}),(0,s.jsx)(n.td,{children:"isAnalog"})]})]})]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Code"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:"function Pipe.actionEventToggleDischargeToGround( self , actionName, inputValue, callbackState, isAnalog)\n    self:setPipeDischargeToGround()\nend\n\n"})}),"\n",(0,s.jsx)(n.h3,{id:"actioneventtogglepipe",children:"actionEventTogglePipe"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Definition"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"actionEventTogglePipe()"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"any"}),(0,s.jsx)(n.th,{children:"self"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"any"}),(0,s.jsx)(n.td,{children:"actionName"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"any"}),(0,s.jsx)(n.td,{children:"inputValue"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"any"}),(0,s.jsx)(n.td,{children:"callbackState"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"any"}),(0,s.jsx)(n.td,{children:"isAnalog"})]})]})]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Code"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:"function Pipe.actionEventTogglePipe( self , actionName, inputValue, callbackState, isAnalog)\n    local spec = self.spec_pipe\n    local nextState = spec.targetState + 1\n    if nextState > spec.numStates then\n        nextState = 1\n    end\n    if self:getIsPipeStateChangeAllowed(nextState) then\n        self:setPipeState(nextState)\n    elseif nextState ~ = 1 and self:getIsPipeStateChangeAllowed( 1 ) then\n            -- also try to close the pipe if other states are not allowed\n                self:setPipeState( 1 )\n            end\n        end\n\n"})}),"\n",(0,s.jsx)(n.h3,{id:"getcanbeselected",children:"getCanBeSelected"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Definition"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"getCanBeSelected()"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,s.jsx)(n.table,{children:(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"any"}),(0,s.jsx)(n.th,{children:"superFunc"})]})})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Code"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:"function Pipe:getCanBeSelected(superFunc)\n    return true\nend\n\n"})}),"\n",(0,s.jsx)(n.h3,{id:"getcanbeturnedon",children:"getCanBeTurnedOn"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Definition"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"getCanBeTurnedOn()"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,s.jsx)(n.table,{children:(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"any"}),(0,s.jsx)(n.th,{children:"superFunc"})]})})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Code"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:"function Pipe:getCanBeTurnedOn(superFunc)\n    local spec = self.spec_pipe\n\n    if spec.hasMovablePipe then\n        if next(spec.turnOnAllowedStates) ~ = nil then\n            local isAllowed = false\n            for pipeState,_ in pairs(spec.turnOnAllowedStates) do\n                if pipeState = = spec.currentState then\n                    isAllowed = true\n                    break\n                end\n            end\n            if not isAllowed then\n                return false\n            end\n        end\n    end\n\n    return superFunc( self )\nend\n\n"})}),"\n",(0,s.jsx)(n.h3,{id:"getcantoggledischargetoground",children:"getCanToggleDischargeToGround"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Definition"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"getCanToggleDischargeToGround()"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,s.jsx)(n.table,{children:(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"any"}),(0,s.jsx)(n.th,{children:"superFunc"})]})})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Code"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:"function Pipe:getCanToggleDischargeToGround(superFunc)\n    local spec = self.spec_pipe\n    if spec.automaticDischarge and spec.toggleableDischargeToGround then\n        return false\n    end\n\n    return superFunc( self )\nend\n\n"})}),"\n",(0,s.jsx)(n.h3,{id:"getcantoggledischargetoobject",children:"getCanToggleDischargeToObject"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Definition"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"getCanToggleDischargeToObject()"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,s.jsx)(n.table,{children:(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"any"}),(0,s.jsx)(n.th,{children:"superFunc"})]})})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Code"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:"function Pipe:getCanToggleDischargeToObject(superFunc)\n    local spec = self.spec_pipe\n    if spec.automaticDischarge then\n        return false\n    end\n\n    return superFunc( self )\nend\n\n"})}),"\n",(0,s.jsx)(n.h3,{id:"getcurrentpipestate",children:"getCurrentPipeState"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Definition"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"getCurrentPipeState()"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Code"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:"function Pipe:getCurrentPipeState()\n    return self.spec_pipe.currentState\nend\n\n"})}),"\n",(0,s.jsx)(n.h3,{id:"getisaipreparingtodrive",children:"getIsAIPreparingToDrive"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Definition"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"getIsAIPreparingToDrive()"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,s.jsx)(n.table,{children:(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"any"}),(0,s.jsx)(n.th,{children:"superFunc"})]})})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Code"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:"function Pipe:getIsAIPreparingToDrive(superFunc)\n    local spec = self.spec_pipe\n    if spec.hasMovablePipe then\n        if spec.currentState ~ = spec.targetState then\n            return true\n        end\n    end\n\n    return superFunc( self )\nend\n\n"})}),"\n",(0,s.jsx)(n.h3,{id:"getisaireadytodrive",children:"getIsAIReadyToDrive"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Definition"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"getIsAIReadyToDrive()"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,s.jsx)(n.table,{children:(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"any"}),(0,s.jsx)(n.th,{children:"superFunc"})]})})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Code"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:"function Pipe:getIsAIReadyToDrive(superFunc)\n    local spec = self.spec_pipe\n    if spec.hasMovablePipe then\n        if spec.currentState ~ = 1 then\n            return false\n        end\n    end\n\n    return superFunc( self )\nend\n\n"})}),"\n",(0,s.jsx)(n.h3,{id:"getisdischargenodeactive",children:"getIsDischargeNodeActive"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Definition"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"getIsDischargeNodeActive()"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"any"}),(0,s.jsx)(n.th,{children:"superFunc"})]})}),(0,s.jsx)(n.tbody,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"any"}),(0,s.jsx)(n.td,{children:"dischargeNode"})]})})]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Code"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:"function Pipe:getIsDischargeNodeActive(superFunc, dischargeNode)\n    local spec = self.spec_pipe\n    if dischargeNode.index = = self:getPipeDischargeNodeIndex() then\n        -- do an explicit true check to avoid nil issues\n            return spec.unloadingStates[spec.currentState] = = true\n        end\n\n        return superFunc( self , dischargeNode)\n    end\n\n"})}),"\n",(0,s.jsx)(n.h3,{id:"getisfoldallowed",children:"getIsFoldAllowed"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Definition"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"getIsFoldAllowed()"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"any"}),(0,s.jsx)(n.th,{children:"superFunc"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"any"}),(0,s.jsx)(n.td,{children:"direction"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"any"}),(0,s.jsx)(n.td,{children:"onAiTurnOn"})]})]})]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Code"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:"function Pipe:getIsFoldAllowed(superFunc, direction, onAiTurnOn)\n    local spec = self.spec_pipe\n\n    if spec.hasMovablePipe then\n        if spec.currentState > spec.foldMaxState or spec.currentState < spec.foldMinState then\n            return false , spec.texts.warningFoldingPipe\n        end\n    end\n\n    return superFunc( self , direction, onAiTurnOn)\nend\n\n"})}),"\n",(0,s.jsx)(n.h3,{id:"getismovingtoolactive",children:"getIsMovingToolActive"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Definition"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"getIsMovingToolActive()"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"any"}),(0,s.jsx)(n.th,{children:"superFunc"})]})}),(0,s.jsx)(n.tbody,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"any"}),(0,s.jsx)(n.td,{children:"movingTool"})]})})]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Code"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:"function Pipe:getIsMovingToolActive(superFunc, movingTool)\n    local spec = self.spec_pipe\n    if movingTool.freezingPipeStates ~ = nil then\n        for _, state in pairs(movingTool.freezingPipeStates) do\n            if spec.currentState = = state or spec.targetState = = state or spec.currentState = = 0 then\n                return false\n            end\n        end\n    end\n\n    return superFunc( self , movingTool)\nend\n\n"})}),"\n",(0,s.jsx)(n.h3,{id:"getisnextcoverstateallowed",children:"getIsNextCoverStateAllowed"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Definition"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"getIsNextCoverStateAllowed()"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"any"}),(0,s.jsx)(n.th,{children:"superFunc"})]})}),(0,s.jsx)(n.tbody,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"any"}),(0,s.jsx)(n.td,{children:"nextState"})]})})]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Code"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:"function Pipe:getIsNextCoverStateAllowed(superFunc, nextState)\n    if not superFunc( self , nextState) then\n        return false\n    end\n\n    local spec = self.spec_pipe\n    local cover = self.spec_cover.covers[nextState]\n    if nextState ~ = 0 then\n        if spec.currentState < cover.minPipeState or spec.currentState > cover.maxPipeState then\n            return false\n        end\n    end\n\n    return true\nend\n\n"})}),"\n",(0,s.jsx)(n.h3,{id:"getispipestatechangeallowed",children:"getIsPipeStateChangeAllowed"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Definition"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"getIsPipeStateChangeAllowed()"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,s.jsx)(n.table,{children:(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"any"}),(0,s.jsx)(n.th,{children:"pipeState"})]})})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Code"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:"function Pipe:getIsPipeStateChangeAllowed(pipeState)\n    local spec = self.spec_pipe\n\n    if not spec.isStateChangeAllowed then\n        return false\n    end\n\n    local foldAnimTime\n    if self.getFoldAnimTime ~ = nil then\n        foldAnimTime = self:getFoldAnimTime()\n    end\n\n    if foldAnimTime ~ = nil and(foldAnimTime < spec.foldMinTime or foldAnimTime > spec.foldMaxTime) then\n        return false\n    end\n\n    return true\nend\n\n"})}),"\n",(0,s.jsx)(n.h3,{id:"getpipedischargenodeindex",children:"getPipeDischargeNodeIndex"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Definition"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"getPipeDischargeNodeIndex()"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,s.jsx)(n.table,{children:(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"any"}),(0,s.jsx)(n.th,{children:"state"})]})})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Code"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:"function Pipe:getPipeDischargeNodeIndex(state)\n    local spec = self.spec_pipe\n\n    if state = = nil then\n        state = spec.currentState\n    end\n\n    if spec.dischargeNodeMapping[state] ~ = nil then\n        return spec.dischargeNodeMapping[state]\n    end\n\n    return spec.dischargeNodeIndex\nend\n\n"})}),"\n",(0,s.jsx)(n.h3,{id:"getrequirespower",children:"getRequiresPower"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Definition"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"getRequiresPower()"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,s.jsx)(n.table,{children:(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"any"}),(0,s.jsx)(n.th,{children:"superFunc"})]})})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Code"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:"function Pipe:getRequiresPower(superFunc)\n    local spec = self.spec_pipe\n    if spec.automaticDischarge then\n        local dischargeNode = self:getDischargeNodeByIndex( self:getPipeDischargeNodeIndex())\n        if dischargeNode ~ = nil then\n            if spec.isAsyncRaycastActive and dischargeNode.lastDischargeObject ~ = nil then\n                return true\n            elseif not spec.isAsyncRaycastActive and dischargeNode.dischargeObject ~ = nil then\n                    return true\n                end\n            end\n        end\n\n        if spec.currentState ~ = spec.targetState then\n            return true\n        end\n\n        return superFunc( self )\n    end\n\n"})}),"\n",(0,s.jsx)(n.h3,{id:"getturnedonnotallowedwarning",children:"getTurnedOnNotAllowedWarning"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Definition"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"getTurnedOnNotAllowedWarning()"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,s.jsx)(n.table,{children:(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"any"}),(0,s.jsx)(n.th,{children:"superFunc"})]})})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Code"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:"function Pipe:getTurnedOnNotAllowedWarning(superFunc)\n    local spec = self.spec_pipe\n\n    if spec.hasMovablePipe then\n        if next(spec.turnOnAllowedStates) ~ = nil then\n            local isAllowed = false\n            for pipeState,_ in pairs(spec.turnOnAllowedStates) do\n                if pipeState = = spec.currentState then\n                    isAllowed = true\n                    break\n                end\n            end\n            if not isAllowed then\n                return spec.texts.turnOnStateWarning\n            end\n        end\n    end\n\n    return superFunc( self )\nend\n\n"})}),"\n",(0,s.jsx)(n.h3,{id:"handledischarge",children:"handleDischarge"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Definition"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"handleDischarge()"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"any"}),(0,s.jsx)(n.th,{children:"superFunc"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"any"}),(0,s.jsx)(n.td,{children:"dischargeNode"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"any"}),(0,s.jsx)(n.td,{children:"dischargedLiters"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"any"}),(0,s.jsx)(n.td,{children:"minDropReached"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"any"}),(0,s.jsx)(n.td,{children:"hasMinDropFillLevel"})]})]})]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Code"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:"function Pipe:handleDischarge(superFunc, dischargeNode, dischargedLiters, minDropReached, hasMinDropFillLevel)\n    local spec = self.spec_pipe\n    if spec.automaticDischarge then\n        -- do nothing if it is pipe dischargenode\n            if dischargeNode.index ~ = self:getPipeDischargeNodeIndex() then\n                superFunc( self , dischargeNode, dischargedLiters, minDropReached, hasMinDropFillLevel)\n            end\n        else\n                superFunc( self , dischargeNode, dischargedLiters, minDropReached, hasMinDropFillLevel)\n            end\n        end\n\n"})}),"\n",(0,s.jsx)(n.h3,{id:"handledischargeraycast",children:"handleDischargeRaycast"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Definition"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"handleDischargeRaycast()"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"any"}),(0,s.jsx)(n.th,{children:"superFunc"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"any"}),(0,s.jsx)(n.td,{children:"dischargeNode"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"any"}),(0,s.jsx)(n.td,{children:"hitObject"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"any"}),(0,s.jsx)(n.td,{children:"hitShape"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"any"}),(0,s.jsx)(n.td,{children:"hitDistance"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"any"}),(0,s.jsx)(n.td,{children:"hitFillUnitIndex"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"any"}),(0,s.jsx)(n.td,{children:"hitTerrain"})]})]})]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Code"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:"function Pipe:handleDischargeRaycast(superFunc, dischargeNode, hitObject, hitShape, hitDistance, hitFillUnitIndex, hitTerrain)\n    local spec = self.spec_pipe\n    if spec.automaticDischarge then\n        local stopDischarge = false\n        if self:getIsPowered() and hitObject ~ = nil then\n            local fillType = self:getDischargeFillType(dischargeNode)\n            local allowFillType = hitObject:getFillUnitAllowsFillType(hitFillUnitIndex, fillType)\n            if allowFillType and hitObject:getFillUnitFreeCapacity(hitFillUnitIndex, fillType, self:getOwnerFarmId()) > 0 then\n                self:setDischargeState( Dischargeable.DISCHARGE_STATE_OBJECT, true )\n            else\n                    stopDischarge = true\n                end\n            elseif self:getIsPowered() and spec.toggleableDischargeToGround and spec.dischargeToGroundState then\n                    self:setDischargeState( Dischargeable.DISCHARGE_STATE_GROUND, true )\n                else\n                        stopDischarge = true\n                    end\n\n                    if stopDischarge and self:getDischargeState() = = Dischargeable.DISCHARGE_STATE_OBJECT then\n                        self:setDischargeState( Dischargeable.DISCHARGE_STATE_OFF, true )\n                    end\n\n                    return\n                end\n\n                superFunc( self , dischargeNode, hitObject, hitShape, hitDistance, hitFillUnitIndex, hitTerrain)\n            end\n\n"})}),"\n",(0,s.jsx)(n.h3,{id:"initspecialization",children:"initSpecialization"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"Called on specialization initializing"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Definition"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"initSpecialization()"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Code"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:'function Pipe.initSpecialization()\n    g_vehicleConfigurationManager:addConfigurationType( "pipe" , g_i18n:getText( "configuration_pipe" ), "pipe" , VehicleConfigurationItem )\n\n    local schema = Vehicle.xmlSchema\n    schema:setXMLSpecializationType( "Pipe" )\n\n    AnimationManager.registerAnimationNodesXMLPaths(schema, "vehicle.pipe.animationNodes" )\n\n    schema:addDelayedRegistrationFunc( "Cylindered:movingTool" , function (cSchema, cKey)\n        cSchema:register(XMLValueType.VECTOR_N, cKey .. "#freezingPipeStates" , "Freezing pipe states" )\n    end )\n\n    schema:register(XMLValueType.INT, Cover.COVER_XML_KEY .. "#minPipeState" , "Min.pipe state" , 0 )\n    schema:register(XMLValueType.INT, Cover.COVER_XML_KEY .. "#maxPipeState" , "Max.pipe state" , "inf." )\n\n    Pipe.registers(schema, "vehicle.pipe" )\n    Pipe.registers(schema, "vehicle.pipe.pipeConfigurations.pipeConfiguration(?)" )\n\n    schema:setXMLSpecializationType()\n\n    local schemaSavegame = Vehicle.xmlSchemaSavegame\n    schemaSavegame:register(XMLValueType.INT, "vehicles.vehicle(?).pipe#state" , "Current pipe state" )\n    schemaSavegame:register(XMLValueType.BOOL, "vehicles.vehicle(?).pipe#isStateChangeAllowed" , "If pipe state change is allowed" )\nend\n\n'})}),"\n",(0,s.jsx)(n.h3,{id:"loadcoverfromxml",children:"loadCoverFromXML"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Definition"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"loadCoverFromXML()"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"any"}),(0,s.jsx)(n.th,{children:"superFunc"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"any"}),(0,s.jsx)(n.td,{children:"xmlFile"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"any"}),(0,s.jsx)(n.td,{children:"key"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"any"}),(0,s.jsx)(n.td,{children:"cover"})]})]})]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Code"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:'function Pipe:loadCoverFromXML(superFunc, xmlFile, key, cover)\n    cover.minPipeState = xmlFile:getValue(key .. "#minPipeState" , 0 )\n    cover.maxPipeState = xmlFile:getValue(key .. "#maxPipeState" , math.huge)\n\n    return superFunc( self , xmlFile, key, cover)\nend\n\n'})}),"\n",(0,s.jsx)(n.h3,{id:"loadmovingtoolfromxml",children:"loadMovingToolFromXML"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Definition"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"loadMovingToolFromXML()"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"any"}),(0,s.jsx)(n.th,{children:"superFunc"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"any"}),(0,s.jsx)(n.td,{children:"xmlFile"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"any"}),(0,s.jsx)(n.td,{children:"key"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"any"}),(0,s.jsx)(n.td,{children:"entry"})]})]})]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Code"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:'function Pipe:loadMovingToolFromXML(superFunc, xmlFile, key, entry)\n    if not superFunc( self , xmlFile, key, entry) then\n        return false\n    end\n\n    entry.freezingPipeStates = xmlFile:getValue(key .. "#freezingPipeStates" , nil , true )\n\n    return true\nend\n\n'})}),"\n",(0,s.jsx)(n.h3,{id:"loadpipenodes",children:"loadPipeNodes"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Definition"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"loadPipeNodes()"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"any"}),(0,s.jsx)(n.th,{children:"pipeNodes"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"any"}),(0,s.jsx)(n.td,{children:"xmlFile"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"any"}),(0,s.jsx)(n.td,{children:"baseKey"})]})]})]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Code"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:'function Pipe:loadPipeNodes(pipeNodes, xmlFile, baseKey)\n    local spec = self.spec_pipe\n\n    local maxPriority = 0\n    local i = 0\n    while true do\n        local key = string.format( "%s(%d)" , baseKey, i)\n        if not xmlFile:hasProperty(key) then\n            break\n        end\n        local node = xmlFile:getValue(key .. "#node" , nil , self.components, self.i3dMappings)\n        if node ~ = nil then\n            local entry = { }\n            entry.node = node\n            entry.autoAimXRotation = xmlFile:getValue(key .. "#autoAimXRotation" , false )\n            entry.autoAimYRotation = xmlFile:getValue(key .. "#autoAimYRotation" , false )\n            entry.autoAimInvertZ = xmlFile:getValue(key .. "#autoAimInvertZ" , false )\n            entry.states = { }\n\n            entry.subPipeNode = xmlFile:getValue(key .. "#subPipeNode" , nil , self.components, self.i3dMappings)\n            if entry.subPipeNode ~ = nil then\n                local x1, _, _ = getRotation(entry.node)\n                local x2, _, _ = localRotationToLocal(entry.subPipeNode, getParent(entry.node), 0 , 0 , 0 )\n                entry.subPipeNodeRatio = xmlFile:getValue(key .. "#subPipeNodeRatio" , math.abs(x1 / x2))\n            end\n\n            XMLUtil.checkDeprecatedXMLElements( self.xmlFile, key .. ".state1" , key .. ".state" ) -- FS19 to FS21\n\n            for state = 1 , spec.numStates do\n                local stateKey = key .. string.format( ".state(%d)" , state - 1 )\n                entry.states[state] = { }\n\n                local x, y, z = xmlFile:getValue(stateKey .. "#translation" , { getTranslation(node) } )\n                if state = = 1 then\n                    setTranslation(node, x, y, z)\n                end\n                entry.states[state].translation = { x, y, z }\n\n                x, y, z = xmlFile:getValue(stateKey .. "#rotation" , { getRotation(node) } )\n                if state = = 1 then\n                    setRotation(node, x, y, z)\n                end\n                entry.states[state].rotation = { x, y, z }\n            end\n\n            local x, y, z = xmlFile:getValue(key .. "#translationSpeeds" )\n            if x ~ = nil and y ~ = nil and z ~ = nil then\n                x, y, z = x * 0.001 , y * 0.001 , z * 0.001\n                if x ~ = 0 or y ~ = 0 or z ~ = 0 then\n                    entry.translationSpeeds = { x, y, z }\n                end\n            end\n            x, y, z = xmlFile:getValue(key .. "#rotationSpeeds" )\n            if x ~ = nil and y ~ = nil and z ~ = nil then\n                x, y, z = x * 0.001 , y * 0.001 , z * 0.001\n                if x ~ = 0 or y ~ = 0 or z ~ = 0 then\n                    entry.rotationSpeeds = { x, y, z }\n                end\n            end\n\n            entry.minRotationLimits = xmlFile:getValue(key .. "#minRotationLimits" , nil , true )\n            entry.maxRotationLimits = xmlFile:getValue(key .. "#maxRotationLimits" , nil , true )\n\n            entry.foldPriority = xmlFile:getValue(key .. "#foldPriority" , 0 )\n            maxPriority = math.max(entry.foldPriority, maxPriority)\n\n            x, y, z = getTranslation(node)\n            entry.curTranslation = { x, y, z }\n\n            x, y, z = getRotation(node)\n            entry.curRotation = { x, y, z }\n            entry.lastTargetRotation = { x, y, z }\n\n            entry.bendingRegulation = xmlFile:getValue(key .. "#bendingRegulation" , 0 )\n\n            entry.regulationNodes = { }\n\n            local j = 0\n            while true do\n                local regKey = string.format( "%s.bendingRegulationNode(%d)" , key, j)\n                if not xmlFile:hasProperty(regKey) then\n                    break\n                end\n\n                local regulationNode = { }\n                regulationNode.node = xmlFile:getValue(regKey .. "#node" , nil , self.components, self.i3dMappings)\n                if regulationNode.node ~ = nil then\n                    regulationNode.startRotation = { getRotation(regulationNode.node) }\n\n                    local axis = xmlFile:getValue(regKey .. "#axis" , 1 )\n                    local direction = xmlFile:getValue(regKey .. "#direction" , 1 )\n\n                    regulationNode.weights = { 0 , 0 , 0 }\n                    regulationNode.weights[ math.clamp(axis, 1 , 3 )] = direction\n\n                    table.insert(entry.regulationNodes, regulationNode)\n                else\n                        Logging.xmlWarning( self.xmlFile, "Failed to load bendingRegulationNode \'%s\'" , regKey)\n                    end\n\n                    j = j + 1\n                end\n\n                entry.moveSamples = g_soundManager:loadSamplesFromXML( self.xmlFile, key, "moveSound" , self.baseDirectory, self.components, 0 , AudioGroup.VEHICLE, self.i3dMappings, self )\n                entry.moveSamplesPlayTimer = 0\n\n                table.insert(pipeNodes, entry)\n            end\n            i = i + 1\n        end\n\n        for _, pipeNode in ipairs(pipeNodes) do\n            pipeNode.inverseFoldPriority = maxPriority - pipeNode.foldPriority\n        end\n    end\n\n'})}),"\n",(0,s.jsx)(n.h3,{id:"loadunloadingtriggers",children:"loadUnloadingTriggers"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Definition"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"loadUnloadingTriggers()"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"any"}),(0,s.jsx)(n.th,{children:"unloadingTriggers"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"any"}),(0,s.jsx)(n.td,{children:"xmlFile"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"any"}),(0,s.jsx)(n.td,{children:"baseKey"})]})]})]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Code"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:'function Pipe:loadUnloadingTriggers(unloadingTriggers, xmlFile, baseKey)\n    local i = 0\n    while true do\n        local key = string.format( "%s(%d)" , baseKey, i)\n        if not xmlFile:hasProperty(key) then\n            break\n        end\n\n        XMLUtil.checkDeprecatedXMLElements( self.xmlFile, key .. "#index" , key .. "#node" ) --FS17 to FS19\n\n        local node = xmlFile:getValue(key .. "#node" , nil , self.components, self.i3dMappings)\n        if node ~ = nil then\n            if CollisionFlag.getHasMaskFlagSet(node, CollisionFlag.FILLABLE) then\n                table.insert(unloadingTriggers, { node = node } )\n            else\n                    Logging.xmlWarning( self.xmlFile, "Missing collision filter mask %s.Please add this bit to unload trigger node \'%s\' in \'%s\'" , CollisionFlag.getBitAndName(CollisionFlag.FILLABLE), getName(node), key)\n                end\n            end\n            i = i + 1\n        end\n    end\n\n'})}),"\n",(0,s.jsx)(n.h3,{id:"onaiimplementpreparefortransport",children:"onAIImplementPrepareForTransport"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Definition"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"onAIImplementPrepareForTransport()"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Code"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:"function Pipe:onAIImplementPrepareForTransport()\n    local spec = self.spec_pipe\n    if spec.hasMovablePipe then\n        if self:getIsPipeStateChangeAllowed( 1 ) then\n            self:setPipeState( 1 )\n        end\n    end\nend\n\n"})}),"\n",(0,s.jsx)(n.h3,{id:"ondelete",children:"onDelete"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Definition"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"onDelete()"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Code"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:'function Pipe:onDelete()\n    local spec = self.spec_pipe\n\n    if spec.objectsInTriggers ~ = nil then\n        for object, _ in pairs(spec.objectsInTriggers) do\n            if object.removeDeleteListener ~ = nil then\n                object:removeDeleteListener( self , "onDeletePipeObject" )\n            end\n        end\n        table.clear(spec.objectsInTriggers)\n    end\n\n    if spec.unloadTriggersInTriggers ~ = nil then\n        for object, _ in pairs(spec.unloadTriggersInTriggers) do\n            if object.removeDeleteListener ~ = nil then\n                object:removeDeleteListener( self , "onDeletePipeObject" )\n            end\n        end\n        table.clear(spec.unloadTriggersInTriggers)\n    end\n\n    if spec.unloadingTriggers ~ = nil then\n        for _, trigger in pairs(spec.unloadingTriggers) do\n            removeTrigger(trigger.node)\n        end\n        table.clear(spec.unloadingTriggers)\n    end\n\n    if spec.nodes ~ = nil then\n        for _, pipeNode in ipairs(spec.nodes) do\n            g_soundManager:deleteSamples(pipeNode.moveSamples)\n        end\n    end\n\n    if spec.sideNotificationData ~ = nil then\n        g_currentMission.hud:removeSideNotificationProgressBar(spec.sideNotificationData.progressBar)\n    end\n\n    g_animationManager:deleteAnimations(spec.animationNodes)\nend\n\n'})}),"\n",(0,s.jsx)(n.h3,{id:"ondeletepipeobject",children:"onDeletePipeObject"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Definition"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"onDeletePipeObject()"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,s.jsx)(n.table,{children:(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"any"}),(0,s.jsx)(n.th,{children:"object"})]})})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Code"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:"function Pipe:onDeletePipeObject(object)\n    local spec = self.spec_pipe\n    if spec.objectsInTriggers[object] ~ = nil then\n        spec.objectsInTriggers[object] = nil\n        spec.numObjectsInTriggers = spec.numObjectsInTriggers - 1\n    end\n\n    if spec.unloadTriggersInTriggers[object] ~ = nil then\n        spec.unloadTriggersInTriggers[object] = nil\n        spec.numUnloadTriggersInTriggers = spec.numUnloadTriggersInTriggers - 1\n    end\nend\n\n"})}),"\n",(0,s.jsx)(n.h3,{id:"ondischargestatechanged",children:"onDischargeStateChanged"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"Called on discharge state change"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Definition"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"onDischargeStateChanged()"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,s.jsx)(n.table,{children:(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"any"}),(0,s.jsx)(n.th,{children:"state"})]})})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Code"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:"function Pipe:onDischargeStateChanged(state)\n    if self.isClient then\n        local spec = self.spec_pipe\n        local dischargeNode = self:getCurrentDischargeNode()\n        local dischargeNodeIndex = nil\n        if dischargeNode ~ = nil then\n            dischargeNodeIndex = dischargeNode.index\n        end\n        if dischargeNodeIndex = = self:getPipeDischargeNodeIndex() then\n            if state = = Dischargeable.DISCHARGE_STATE_OFF then\n                g_animationManager:stopAnimations(spec.animationNodes)\n            else\n                    g_animationManager:startAnimations(spec.animationNodes)\n                    g_animationManager:setFillType(spec.animationNodes, self:getFillUnitLastValidFillType(dischargeNode.fillUnitIndex))\n                end\n            end\n        end\n    end\n\n"})}),"\n",(0,s.jsx)(n.h3,{id:"onload",children:"onLoad"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Definition"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"onLoad()"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,s.jsx)(n.table,{children:(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"any"}),(0,s.jsx)(n.th,{children:"savegame"})]})})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Code"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:'function Pipe:onLoad(savegame)\n    local spec = self.spec_pipe\n\n    local pipeConfigurationId = Utils.getNoNil( self.configurations[ "pipe" ], 1 )\n    local baseKey = string.format( "vehicle.pipe.pipeConfigurations.pipeConfiguration(%d)" , pipeConfigurationId - 1 )\n\n    -- fallback key\n    if not self.xmlFile:hasProperty(baseKey) then\n        baseKey = "vehicle.pipe"\n    end\n\n    XMLUtil.checkDeprecatedXMLElements( self.xmlFile, "vehicle.pipeEffect.effectNode" , baseKey .. ".pipeEffect.effectNode" ) --FS17 to FS19\n    XMLUtil.checkDeprecatedXMLElements( self.xmlFile, "vehicle.overloading.trailerTriggers.trailerTrigger(0)#index" , baseKey .. ".unloadingTriggers.unloadingTrigger(0)#node" ) --FS17 to FS19\n    XMLUtil.checkDeprecatedXMLElements( self.xmlFile, "vehicle.pipe#raycastNodeIndex" , baseKey .. ".raycast#node" ) --FS17 to FS19\n    XMLUtil.checkDeprecatedXMLElements( self.xmlFile, "vehicle.pipe#raycastDistance" , baseKey .. ".raycast#maxDistance" ) --FS17 to FS19\n    XMLUtil.checkDeprecatedXMLElements( self.xmlFile, "vehicle.pipe#effectExtraDistanceOnTrailer" , baseKey .. ".raycast#extraDistance" ) --FS17 to FS19\n    XMLUtil.checkDeprecatedXMLElements( self.xmlFile, "vehicle.pipe#animName" , baseKey .. ".animation#name" ) --FS17 to FS19\n    XMLUtil.checkDeprecatedXMLElements( self.xmlFile, "vehicle.pipe#animSpeedScale" , baseKey .. ".animation#speedScale" ) --FS17 to FS19\n    XMLUtil.checkDeprecatedXMLElements( self.xmlFile, "vehicle.pipe#animSpeedScale" , baseKey .. ".animation#speedScale" ) --FS17 to FS19\n    XMLUtil.checkDeprecatedXMLElements( self.xmlFile, "vehicle.pipe.node#node" , baseKey .. ".node#node" ) --FS17 to FS19\n    XMLUtil.checkDeprecatedXMLElements( self.xmlFile, "vehicle.pipe#numStates" , baseKey .. ".states#num" ) --FS17 to FS19\n    XMLUtil.checkDeprecatedXMLElements( self.xmlFile, "vehicle.pipe#unloadingStates" , baseKey .. ".states#unloading" ) --FS17 to FS19\n    XMLUtil.checkDeprecatedXMLElements( self.xmlFile, "vehicle.pipe#autoAimingStates" , baseKey .. ".states#autoAiming" ) --FS17 to FS19\n    XMLUtil.checkDeprecatedXMLElements( self.xmlFile, "vehicle.pipe#turnOnAllowed" , baseKey .. ".states#turnOnAllowed" ) --FS17 to FS19\n\n    spec.dischargeNodeIndex = self.xmlFile:getValue(baseKey .. "#dischargeNodeIndex" , 1 )\n    spec.forceDischargeNodeIndex = self.xmlFile:getValue(baseKey .. "#forceDischargeNodeIndex" , true )\n    if spec.forceDischargeNodeIndex then\n        self:setCurrentDischargeNodeIndex(spec.dischargeNodeIndex)\n    end\n\n    spec.isStateChangeAllowed = true\n    spec.automaticDischarge = self.xmlFile:getValue(baseKey .. "#automaticDischarge" , true )\n    spec.toggleableDischargeToGround = self.xmlFile:getValue(baseKey .. "#toggleableDischargeToGround" , false )\n    spec.dischargeToGroundState = self.xmlFile:getValue(baseKey .. "#defaultDischargeToGroundState" , false )\n\n    spec.unloadingTriggers = { }\n    spec.objectsInTriggers = { }\n    spec.unloadTriggersInTriggers = { }\n    spec.numObjectsInTriggers = 0\n    spec.numUnloadTriggersInTriggers = 0\n    spec.nearestObjectInTriggers = { objectId = nil , fillUnitIndex = 0 , isDischargeObject = false }\n    spec.nearestObjectInTriggersSent = { objectId = nil , fillUnitIndex = 0 , isDischargeObject = false }\n\n    self:loadUnloadingTriggers(spec.unloadingTriggers, self.xmlFile, baseKey .. ".unloadingTriggers.unloadingTrigger" )\n    if #spec.unloadingTriggers = = 0 then\n        Logging.xmlWarning( self.xmlFile, "No \'unloadingTriggers\' defined for pipe \'vehicle.pipe\'!" )\n        else\n                for _, trigger in pairs(spec.unloadingTriggers) do\n                    addTrigger(trigger.node, "unloadingTriggerCallback" , self )\n                    setTriggerReportStatics(trigger.node, true ) -- so we can detect static exactFillRootNodes of unloading stations\n                end\n            end\n\n            spec.animation = { }\n            spec.animation.name = self.xmlFile:getValue(baseKey .. ".animation#name" )\n            spec.animation.speedScale = self.xmlFile:getValue(baseKey .. ".animation#speedScale" , 1 )\n\n            spec.currentState = 1\n            spec.targetState = 1\n            spec.numStates = self.xmlFile:getValue(baseKey .. ".states#num" , 0 )\n\n            spec.nodes = { }\n            self:loadPipeNodes(spec.nodes, self.xmlFile, baseKey .. ".pipeNodes.pipeNode" )\n            spec.hasMovablePipe = #spec.nodes > 0 or spec.animation.name ~ = nil\n\n            local function loadState(target, xmlFile, key)\n                local i = 0\n                local states = xmlFile:getValue(key, nil , true )\n                if states ~ = nil then\n                    for _, state in ipairs(states) do\n                        target[state] = true\n                        i = i + 1\n                    end\n                end\n\n                return i\n            end\n\n            spec.unloadingStates = { }\n            spec.autoAimingStates = { }\n            spec.turnOnAllowedStates = { }\n            spec.numUnloadingStates = loadState(spec.unloadingStates, self.xmlFile, baseKey .. ".states#unloading" )\n            spec.numAutoAimingStates = loadState(spec.autoAimingStates, self.xmlFile, baseKey .. ".states#autoAiming" )\n            spec.numTurnOnAllowedStates = loadState(spec.turnOnAllowedStates, self.xmlFile, baseKey .. ".states#turnOnAllowed" )\n\n            spec.dischargeNodeMapping = { }\n            local i = 0\n            while true do\n                local stateKey = string.format( "%s.states.state(%d)" , baseKey, i)\n                if not self.xmlFile:hasProperty(stateKey) then\n                    break\n                end\n\n                local stateIndex = self.xmlFile:getValue(stateKey .. "#stateIndex" )\n                local dischargeNodeIndex = self.xmlFile:getValue(stateKey .. "#dischargeNodeIndex" )\n\n                if stateIndex ~ = nil and dischargeNodeIndex ~ = nil then\n                    spec.dischargeNodeMapping[stateIndex] = dischargeNodeIndex\n                end\n\n                i = i + 1\n            end\n\n            if self.isClient then\n                spec.animationNodes = g_animationManager:loadAnimations( self.xmlFile, "vehicle.pipe.animationNodes" , self.components, self , self.i3dMappings)\n            end\n\n            spec.foldMinTime = self.xmlFile:getValue(baseKey .. "#foldMinLimit" , 0.0 )\n            spec.foldMaxTime = self.xmlFile:getValue(baseKey .. "#foldMaxLimit" , 1.0 )\n            spec.foldMinState = self.xmlFile:getValue(baseKey .. "#foldMinState" , 1 )\n            spec.foldMaxState = self.xmlFile:getValue(baseKey .. "#foldMaxState" , spec.numStates)\n\n            spec.aiFoldedPipeUsesTrailerSpace = self.xmlFile:getValue(baseKey .. "#aiFoldedPipeUsesTrailerSpace" , false )\n\n            spec.texts = { }\n            spec.texts.warningFoldingPipe = g_i18n:getText( "warning_foldingNotWhilePipeExtended" )\n            spec.texts.turnOnStateWarning = string.format( self.xmlFile:getValue(baseKey .. "#turnOnStateWarning" , "warning_firstSetPipeState" , self.customEnvironment), self.typeDesc)\n            spec.texts.pipeIn = self.xmlFile:getValue(baseKey .. "#pipeInText" , "action_pipeIn" , self.customEnvironment)\n            spec.texts.pipeOut = self.xmlFile:getValue(baseKey .. "#pipeOutText" , "action_pipeOut" , self.customEnvironment)\n            spec.texts.startTipToGround = g_i18n:getText( "action_startTipToGround" )\n            spec.texts.stopTipToGround = g_i18n:getText( "action_stopTipToGround" )\n\n            spec.sideNotificationData = { }\n            spec.sideNotificationData.objectId = nil\n            spec.sideNotificationData.fillUnitIndex = nil\n            spec.sideNotificationData.progressBar = g_currentMission.hud:addSideNotificationProgressBar( "" , "" , "" )\n\n            spec.sideNotificationTime = 0\n\n            spec.dirtyFlag = self:getNextDirtyFlag()\n\n            spec.lastFillTime = - 1000\n            spec.lastEmptyTime = - 1000\n\n            if not self.isServer then\n                SpecializationUtil.removeEventListener( self , "onUpdateTick" , Pipe )\n            end\n        end\n\n'})}),"\n",(0,s.jsx)(n.h3,{id:"onmovingtoolchanged",children:"onMovingToolChanged"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Definition"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"onMovingToolChanged()"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"any"}),(0,s.jsx)(n.th,{children:"tool"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"any"}),(0,s.jsx)(n.td,{children:"transSpeed"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"any"}),(0,s.jsx)(n.td,{children:"dt"})]})]})]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Code"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:"function Pipe:onMovingToolChanged(tool, transSpeed, dt)\n    local spec = self.spec_pipe\n    for _, pipeNode in ipairs(spec.nodes) do\n        if pipeNode.node = = tool.node then\n            pipeNode.curTranslation = { tool.curTrans[ 1 ], tool.curTrans[ 2 ], tool.curTrans[ 3 ] }\n            pipeNode.curRotation = { tool.curRot[ 1 ], tool.curRot[ 2 ], tool.curRot[ 3 ] }\n        end\n    end\nend\n\n"})}),"\n",(0,s.jsx)(n.h3,{id:"onpostload",children:"onPostLoad"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Definition"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"onPostLoad()"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,s.jsx)(n.table,{children:(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"any"}),(0,s.jsx)(n.th,{children:"savegame"})]})})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Code"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:'function Pipe:onPostLoad(savegame)\n    local spec = self.spec_pipe\n\n    if savegame ~ = nil and not savegame.resetVehicles then\n        spec.isStateChangeAllowed = savegame.xmlFile:getValue(savegame.key .. ".pipe#isStateChangeAllowed" , spec.isStateChangeAllowed)\n\n        local pipeState = savegame.xmlFile:getValue(savegame.key .. ".pipe#state" , spec.currentState)\n        self:setPipeState(pipeState, true )\n        self:updatePipeNodes( 999999 )\n        spec.currentState = spec.targetState -- set the current state as the pipe has been fully updated\n\n        if spec.animation.name ~ = nil then\n            local targetTime = 0\n            if pipeState ~ = 1 then\n                targetTime = 1\n            end\n\n            self:setAnimationTime(spec.animation.name, targetTime, true )\n        end\n    end\nend\n\n'})}),"\n",(0,s.jsx)(n.h3,{id:"onreadstream",children:"onReadStream"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Definition"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"onReadStream()"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"any"}),(0,s.jsx)(n.th,{children:"streamId"})]})}),(0,s.jsx)(n.tbody,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"any"}),(0,s.jsx)(n.td,{children:"connection"})]})})]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Code"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:"function Pipe:onReadStream(streamId, connection)\n    local spec = self.spec_pipe\n\n    local pipeState = streamReadUIntN(streamId, 2 )\n    self:setPipeState(pipeState, true )\n\n    if streamReadBool(streamId) then\n        spec.nearestObjectInTriggers.objectId = NetworkUtil.readNodeObjectId(streamId)\n        spec.nearestObjectInTriggers.fillUnitIndex = streamReadUIntN(streamId, 4 )\n        spec.nearestObjectInTriggers.isDischargeObject = streamReadBool(streamId)\n    end\nend\n\n"})}),"\n",(0,s.jsx)(n.h3,{id:"onreadupdatestream",children:"onReadUpdateStream"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Definition"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"onReadUpdateStream()"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"any"}),(0,s.jsx)(n.th,{children:"streamId"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"any"}),(0,s.jsx)(n.td,{children:"timestamp"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"any"}),(0,s.jsx)(n.td,{children:"connection"})]})]})]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Code"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:"function Pipe:onReadUpdateStream(streamId, timestamp, connection)\n    if connection:getIsServer() then\n        if streamReadBool(streamId) then\n            local spec = self.spec_pipe\n            if streamReadBool(streamId) then\n                spec.nearestObjectInTriggers.objectId = NetworkUtil.readNodeObjectId(streamId)\n                spec.nearestObjectInTriggers.fillUnitIndex = streamReadUIntN(streamId, 4 )\n                spec.nearestObjectInTriggers.isDischargeObject = streamReadBool(streamId)\n            else\n                    spec.nearestObjectInTriggers.objectId = nil\n                    spec.nearestObjectInTriggers.fillUnitIndex = 0\n                    spec.nearestObjectInTriggers.isDischargeObject = false\n                end\n            end\n        end\n    end\n\n"})}),"\n",(0,s.jsx)(n.h3,{id:"onregisteractionevents",children:"onRegisterActionEvents"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Definition"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"onRegisterActionEvents()"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"any"}),(0,s.jsx)(n.th,{children:"isActiveForInput"})]})}),(0,s.jsx)(n.tbody,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"any"}),(0,s.jsx)(n.td,{children:"isActiveForInputIgnoreSelection"})]})})]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Code"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:"function Pipe:onRegisterActionEvents(isActiveForInput, isActiveForInputIgnoreSelection)\n    if self.isClient then\n        local spec = self.spec_pipe\n        self:clearActionEventsTable(spec.actionEvents)\n\n        if isActiveForInputIgnoreSelection and spec.hasMovablePipe then\n            local _, actionEventId = self:addPoweredActionEvent(spec.actionEvents, InputAction.TOGGLE_PIPE, self , Pipe.actionEventTogglePipe, false , true , false , true , nil )\n            g_inputBinding:setActionEventTextPriority(actionEventId, GS_PRIO_HIGH)\n            self:updateActionEventText()\n\n            if spec.toggleableDischargeToGround then\n                _, actionEventId = self:addActionEvent(spec.actionEvents, InputAction.TOGGLE_TIPSTATE_GROUND, self , Pipe.actionEventToggleDischargeToGround, false , true , false , true , nil )\n                g_inputBinding:setActionEventTextPriority(actionEventId, GS_PRIO_NORMAL)\n                g_inputBinding:setActionEventText(actionEventId, spec.dischargeToGroundState and spec.texts.stopTipToGround or spec.texts.startTipToGround)\n            end\n        end\n    end\nend\n\n"})}),"\n",(0,s.jsx)(n.h3,{id:"onrootvehiclechanged",children:"onRootVehicleChanged"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"Called if root vehicle changes"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Definition"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"onRootVehicleChanged(table rootVehicle)"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n",(0,s.jsx)(n.table,{children:(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"table"}),(0,s.jsx)(n.th,{children:"rootVehicle"}),(0,s.jsx)(n.th,{children:"root vehicle"})]})})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Code"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:'function Pipe:onRootVehicleChanged(rootVehicle)\n    local spec = self.spec_pipe\n    if spec.hasMovablePipe and spec.numAutoAimingStates > 0 then\n        local actionController = rootVehicle.actionController\n        if actionController ~ = nil then\n            if spec.controlledAction ~ = nil then\n                spec.controlledAction:updateParent(actionController)\n                return\n            end\n\n            local autoAimState, _ = next(spec.autoAimingStates)\n\n            spec.controlledAction = actionController:registerAction( "pipe" , nil , 2 )\n            spec.controlledAction:setCallback( self , Pipe.actionControllerPipeEvent)\n            spec.controlledAction:addAIEventListener( self , "onAIFieldWorkerEnd" , - 1 )\n            spec.controlledAction:setFinishedFunctions( self , Pipe.getCurrentPipeState, autoAimState, 1 )\n        else\n                if spec.controlledAction ~ = nil then\n                    spec.controlledAction:remove()\n                    spec.controlledAction = nil\n                end\n            end\n        end\n    end\n\n'})}),"\n",(0,s.jsx)(n.h3,{id:"onupdate",children:"onUpdate"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Definition"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"onUpdate()"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"any"}),(0,s.jsx)(n.th,{children:"dt"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"any"}),(0,s.jsx)(n.td,{children:"isActiveForInput"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"any"}),(0,s.jsx)(n.td,{children:"isActiveForInputIgnoreSelection"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"any"}),(0,s.jsx)(n.td,{children:"isSelected"})]})]})]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Code"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:'function Pipe:onUpdate(dt, isActiveForInput, isActiveForInputIgnoreSelection, isSelected)\n    local spec = self.spec_pipe\n\n    self:updateActionEventText()\n\n    if spec.hasMovablePipe then\n        self:updatePipeNodes(dt)\n    end\n\n    if self.isClient then\n        if spec.sideNotificationTime > 0 then\n            spec.sideNotificationTime = math.max(spec.sideNotificationTime - dt, 0 )\n        end\n\n        if isActiveForInputIgnoreSelection then\n            local targetObject = NetworkUtil.getObject(spec.nearestObjectInTriggers.objectId)\n            local fillUnitIndex = spec.nearestObjectInTriggers.fillUnitIndex\n            if not spec.nearestObjectInTriggers.isDischargeObject then\n                targetObject = nil\n            end\n\n            if targetObject = = nil and spec.sideNotificationTime > 0 and spec.sideNotificationData.objectId ~ = nil then\n                targetObject = NetworkUtil.getObject(spec.sideNotificationData.objectId)\n                fillUnitIndex = spec.sideNotificationData.fillUnitIndex\n\n                if targetObject = = nil then\n                    spec.sideNotificationData.objectId = nil\n                end\n            end\n\n            if targetObject ~ = nil then\n                local fillType = targetObject:getFillUnitFillType(fillUnitIndex)\n                if fillType ~ = FillType.UNKNOWN then\n                    local fillLevel = targetObject:getFillUnitFillLevel(fillUnitIndex)\n                    local capacity = targetObject:getFillUnitCapacity(fillUnitIndex)\n                    if capacity ~ = nil and capacity > 0 then\n                        local fillLevelPct = fillLevel / capacity\n\n                        local fillTypeDesc = g_fillTypeManager:getFillTypeByIndex(fillType)\n                        local text = string.format( "%d%s %s" , fillLevel, fillTypeDesc.unitShort or "" , fillTypeDesc.title)\n\n                        if spec.nearestObjectInTriggers.objectId ~ = nil then\n                            spec.sideNotificationData.objectId = spec.nearestObjectInTriggers.objectId\n                            spec.sideNotificationData.fillUnitIndex = fillUnitIndex\n                            spec.sideNotificationTime = 5000\n                        end\n\n                        local progressBar = spec.sideNotificationData.progressBar\n                        progressBar.title = targetObject:getFullName()\n                        progressBar.text = text\n                        progressBar.progress = fillLevelPct\n                        g_currentMission.hud:markSideNotificationProgressBarForDrawing(progressBar)\n                    end\n                end\n            end\n        end\n    end\nend\n\n'})}),"\n",(0,s.jsx)(n.h3,{id:"onupdatetick",children:"onUpdateTick"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Definition"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"onUpdateTick()"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"any"}),(0,s.jsx)(n.th,{children:"dt"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"any"}),(0,s.jsx)(n.td,{children:"isActiveForInput"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"any"}),(0,s.jsx)(n.td,{children:"isActiveForInputIgnoreSelection"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"any"}),(0,s.jsx)(n.td,{children:"isSelected"})]})]})]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Code"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:"function Pipe:onUpdateTick(dt, isActiveForInput, isActiveForInputIgnoreSelection, isSelected)\n    if self.isServer then\n        self:updateNearestObjectInTriggers()\n\n        local spec = self.spec_pipe\n        local objectChanged = spec.nearestObjectInTriggers.objectId ~ = spec.nearestObjectInTriggersSent.objectId\n        local fillUnitChanged = spec.nearestObjectInTriggers.fillUnitIndex ~ = spec.nearestObjectInTriggersSent.fillUnitIndex\n        local dischargeObjectChanged = spec.nearestObjectInTriggers.isDischargeObject ~ = spec.nearestObjectInTriggersSent.isDischargeObject\n        if objectChanged or fillUnitChanged or dischargeObjectChanged then\n            spec.nearestObjectInTriggersSent.objectId = spec.nearestObjectInTriggers.objectId\n            spec.nearestObjectInTriggersSent.fillUnitIndex = spec.nearestObjectInTriggers.fillUnitIndex\n            spec.nearestObjectInTriggersSent.isDischargeObject = spec.nearestObjectInTriggers.isDischargeObject\n            self:raiseDirtyFlags(spec.dirtyFlag)\n        end\n\n        -- automatic unfold pipe if trailer is in trigger\n            -- only applies if the pipe is not auto aiming - then we unfold the pipe once the vehicle is activated\n                if spec.numAutoAimingStates = = 0 and Platform.gameplay.automaticPipeUnfolding and not self:getIsAIActive() then\n                    local unfoldPipe = spec.nearestObjectInTriggers.objectId ~ = nil or spec.numUnloadTriggersInTriggers > 0\n\n                    -- only unfold if the vehicle is filled\n                        local dischargeNode = self:getDischargeNodeByIndex( self:getPipeDischargeNodeIndex())\n                        if dischargeNode ~ = nil then\n                            local capacity = self:getFillUnitCapacity(dischargeNode.fillUnitIndex)\n                            local fillLevel = self:getFillUnitFillLevel(dischargeNode.fillUnitIndex)\n                            unfoldPipe = unfoldPipe and((capacity = = math.huge and( self.getIsTurnedOn = = nil or self:getIsTurnedOn())) or fillLevel > 0 )\n                        end\n\n                        if unfoldPipe then\n                            if spec.targetState = = 1 then\n                                local unloadingState, _ = next(spec.unloadingStates)\n                                if self:getIsPipeStateChangeAllowed(unloadingState) then\n                                    self:setPipeState(unloadingState)\n                                end\n                            end\n                        else\n                                if spec.targetState > 1 then\n                                    if self:getIsPipeStateChangeAllowed( 1 ) then\n                                        self:setPipeState( 1 )\n                                    end\n                                end\n                            end\n\n                            if unfoldPipe then\n                                self:raiseActive()\n                            end\n                        end\n                    end\n                end\n\n"})}),"\n",(0,s.jsx)(n.h3,{id:"onwritestream",children:"onWriteStream"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Definition"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"onWriteStream()"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"any"}),(0,s.jsx)(n.th,{children:"streamId"})]})}),(0,s.jsx)(n.tbody,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"any"}),(0,s.jsx)(n.td,{children:"connection"})]})})]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Code"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:"function Pipe:onWriteStream(streamId, connection)\n    local spec = self.spec_pipe\n\n    streamWriteUIntN(streamId, spec.targetState, 2 )\n\n    if streamWriteBool(streamId, spec.nearestObjectInTriggersSent.objectId ~ = nil ) then\n        NetworkUtil.writeNodeObjectId(streamId, spec.nearestObjectInTriggersSent.objectId)\n        streamWriteUIntN(streamId, spec.nearestObjectInTriggersSent.fillUnitIndex, 4 )\n        streamWriteBool(streamId, spec.nearestObjectInTriggersSent.isDischargeObject)\n    end\nend\n\n"})}),"\n",(0,s.jsx)(n.h3,{id:"onwriteupdatestream",children:"onWriteUpdateStream"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Definition"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"onWriteUpdateStream()"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"any"}),(0,s.jsx)(n.th,{children:"streamId"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"any"}),(0,s.jsx)(n.td,{children:"connection"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"any"}),(0,s.jsx)(n.td,{children:"dirtyMask"})]})]})]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Code"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:"function Pipe:onWriteUpdateStream(streamId, connection, dirtyMask)\n    if not connection:getIsServer() then\n        local spec = self.spec_pipe\n        if streamWriteBool(streamId, bit32.band(dirtyMask, spec.dirtyFlag) ~ = 0 ) then\n            if streamWriteBool(streamId, spec.nearestObjectInTriggersSent.objectId ~ = nil ) then\n                NetworkUtil.writeNodeObjectId(streamId, spec.nearestObjectInTriggersSent.objectId)\n                streamWriteUIntN(streamId, spec.nearestObjectInTriggersSent.fillUnitIndex, 4 )\n                streamWriteBool(streamId, spec.nearestObjectInTriggersSent.isDischargeObject)\n            end\n        end\n    end\nend\n\n"})}),"\n",(0,s.jsx)(n.h3,{id:"prerequisitespresent",children:"prerequisitesPresent"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Definition"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"prerequisitesPresent()"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,s.jsx)(n.table,{children:(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"any"}),(0,s.jsx)(n.th,{children:"specializations"})]})})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Code"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:"function Pipe.prerequisitesPresent(specializations)\n    return SpecializationUtil.hasSpecialization( FillUnit , specializations) and SpecializationUtil.hasSpecialization( Dischargeable , specializations)\nend\n\n"})}),"\n",(0,s.jsx)(n.h3,{id:"registereventlisteners",children:"registerEventListeners"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Definition"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"registerEventListeners()"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,s.jsx)(n.table,{children:(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"any"}),(0,s.jsx)(n.th,{children:"vehicleType"})]})})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Code"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:'function Pipe.registerEventListeners(vehicleType)\n    SpecializationUtil.registerEventListener(vehicleType, "onLoad" , Pipe )\n    SpecializationUtil.registerEventListener(vehicleType, "onPostLoad" , Pipe )\n    SpecializationUtil.registerEventListener(vehicleType, "onDelete" , Pipe )\n    SpecializationUtil.registerEventListener(vehicleType, "onReadStream" , Pipe )\n    SpecializationUtil.registerEventListener(vehicleType, "onWriteStream" , Pipe )\n    SpecializationUtil.registerEventListener(vehicleType, "onReadUpdateStream" , Pipe )\n    SpecializationUtil.registerEventListener(vehicleType, "onWriteUpdateStream" , Pipe )\n    SpecializationUtil.registerEventListener(vehicleType, "onUpdate" , Pipe )\n    SpecializationUtil.registerEventListener(vehicleType, "onUpdateTick" , Pipe )\n    SpecializationUtil.registerEventListener(vehicleType, "onMovingToolChanged" , Pipe )\n    SpecializationUtil.registerEventListener(vehicleType, "onRegisterActionEvents" , Pipe )\n    SpecializationUtil.registerEventListener(vehicleType, "onDischargeStateChanged" , Pipe )\n    SpecializationUtil.registerEventListener(vehicleType, "onAIImplementPrepareForTransport" , Pipe )\n    SpecializationUtil.registerEventListener(vehicleType, "onRootVehicleChanged" , Pipe )\nend\n\n'})}),"\n",(0,s.jsx)(n.h3,{id:"registerfunctions",children:"registerFunctions"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Definition"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"registerFunctions()"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,s.jsx)(n.table,{children:(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"any"}),(0,s.jsx)(n.th,{children:"vehicleType"})]})})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Code"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:'function Pipe.registerFunctions(vehicleType)\n    SpecializationUtil.registerFunction(vehicleType, "loadUnloadingTriggers" , Pipe.loadUnloadingTriggers)\n    SpecializationUtil.registerFunction(vehicleType, "loadPipeNodes" , Pipe.loadPipeNodes)\n    SpecializationUtil.registerFunction(vehicleType, "getIsPipeStateChangeAllowed" , Pipe.getIsPipeStateChangeAllowed)\n    SpecializationUtil.registerFunction(vehicleType, "setPipeState" , Pipe.setPipeState)\n    SpecializationUtil.registerFunction(vehicleType, "getCurrentPipeState" , Pipe.getCurrentPipeState)\n    SpecializationUtil.registerFunction(vehicleType, "updatePipeNodes" , Pipe.updatePipeNodes)\n    SpecializationUtil.registerFunction(vehicleType, "updateBendingRegulationNodes" , Pipe.updateBendingRegulationNodes)\n    SpecializationUtil.registerFunction(vehicleType, "unloadingTriggerCallback" , Pipe.unloadingTriggerCallback)\n    SpecializationUtil.registerFunction(vehicleType, "updateNearestObjectInTriggers" , Pipe.updateNearestObjectInTriggers)\n    SpecializationUtil.registerFunction(vehicleType, "updateActionEventText" , Pipe.updateActionEventText)\n    SpecializationUtil.registerFunction(vehicleType, "onDeletePipeObject" , Pipe.onDeletePipeObject)\n    SpecializationUtil.registerFunction(vehicleType, "getPipeDischargeNodeIndex" , Pipe.getPipeDischargeNodeIndex)\n    SpecializationUtil.registerFunction(vehicleType, "setPipeDischargeToGround" , Pipe.setPipeDischargeToGround)\n    SpecializationUtil.registerFunction(vehicleType, "setIsPipeStateChangeAllowed" , Pipe.setIsPipeStateChangeAllowed)\nend\n\n'})}),"\n",(0,s.jsx)(n.h3,{id:"registeroverwrittenfunctions",children:"registerOverwrittenFunctions"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Definition"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"registerOverwrittenFunctions()"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,s.jsx)(n.table,{children:(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"any"}),(0,s.jsx)(n.th,{children:"vehicleType"})]})})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Code"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:'function Pipe.registerOverwrittenFunctions(vehicleType)\n    SpecializationUtil.registerOverwrittenFunction(vehicleType, "getIsDischargeNodeActive" , Pipe.getIsDischargeNodeActive)\n    SpecializationUtil.registerOverwrittenFunction(vehicleType, "getCanBeTurnedOn" , Pipe.getCanBeTurnedOn)\n    SpecializationUtil.registerOverwrittenFunction(vehicleType, "getTurnedOnNotAllowedWarning" , Pipe.getTurnedOnNotAllowedWarning)\n    SpecializationUtil.registerOverwrittenFunction(vehicleType, "getIsFoldAllowed" , Pipe.getIsFoldAllowed)\n    SpecializationUtil.registerOverwrittenFunction(vehicleType, "handleDischarge" , Pipe.handleDischarge)\n    SpecializationUtil.registerOverwrittenFunction(vehicleType, "handleDischargeRaycast" , Pipe.handleDischargeRaycast)\n    SpecializationUtil.registerOverwrittenFunction(vehicleType, "getCanToggleDischargeToObject" , Pipe.getCanToggleDischargeToObject)\n    SpecializationUtil.registerOverwrittenFunction(vehicleType, "getCanToggleDischargeToGround" , Pipe.getCanToggleDischargeToGround)\n    SpecializationUtil.registerOverwrittenFunction(vehicleType, "getRequiresPower" , Pipe.getRequiresPower)\n    SpecializationUtil.registerOverwrittenFunction(vehicleType, "loadMovingToolFromXML" , Pipe.loadMovingToolFromXML)\n    SpecializationUtil.registerOverwrittenFunction(vehicleType, "getIsMovingToolActive" , Pipe.getIsMovingToolActive)\n    SpecializationUtil.registerOverwrittenFunction(vehicleType, "loadCoverFromXML" , Pipe.loadCoverFromXML)\n    SpecializationUtil.registerOverwrittenFunction(vehicleType, "getIsNextCoverStateAllowed" , Pipe.getIsNextCoverStateAllowed)\n    SpecializationUtil.registerOverwrittenFunction(vehicleType, "getCanBeSelected" , Pipe.getCanBeSelected)\n    SpecializationUtil.registerOverwrittenFunction(vehicleType, "getIsAIReadyToDrive" , Pipe.getIsAIReadyToDrive)\n    SpecializationUtil.registerOverwrittenFunction(vehicleType, "getIsAIPreparingToDrive" , Pipe.getIsAIPreparingToDrive)\nend\n\n'})}),"\n",(0,s.jsx)(n.h3,{id:"registers",children:"registers"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"Called on specialization initializing"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Definition"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"registers()"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"any"}),(0,s.jsx)(n.th,{children:"schema"})]})}),(0,s.jsx)(n.tbody,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"any"}),(0,s.jsx)(n.td,{children:"basePath"})]})})]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Code"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:'function Pipe.registers(schema, basePath)\n    schema:register(XMLValueType.L10N_STRING, basePath .. "#pipeInText" , "Text to show for pipe extending action" , "action_pipeIn" )\n        schema:register(XMLValueType.L10N_STRING, basePath .. "#pipeOutText" , "Text to show for pipe retracting action" , "action_pipeOut" )\n            schema:register(XMLValueType.L10N_STRING, basePath .. "#turnOnStateWarning" , "Turn on warning" , "warning_firstSetPipeState" )\n            schema:register(XMLValueType.INT, basePath .. "#dischargeNodeIndex" , "Discharge node index" , 1 )\n            schema:register(XMLValueType.BOOL, basePath .. "#forceDischargeNodeIndex" , "Force discharge node selection while changing pipe state.Can be deactivated e.g.if the selection is done by trailer spec etc." , true )\n                schema:register(XMLValueType.BOOL, basePath .. "#automaticDischarge" , "Pipe is automatically starting to discharge as soon as it hits the trailer" , true )\n                schema:register(XMLValueType.BOOL, basePath .. "#toggleableDischargeToGround" , "Defines if the discharge to ground can be enabled separately" , false )\n                    schema:register(XMLValueType.BOOL, basePath .. "#defaultDischargeToGroundState" , "Discharge to ground is enabled by default if #toggleableDischargeToGround is set" , false )\n                        schema:register(XMLValueType.NODE_INDEX, basePath .. ".unloadingTriggers.unloadingTrigger(?)#node" , "Unload trigger node" )\n\n                        schema:register(XMLValueType.STRING, basePath .. ".animation#name" , "Pipe animation name" )\n                        schema:register(XMLValueType.FLOAT, basePath .. ".animation#speedScale" , "Pipe animation speed scale" , 1 )\n                        schema:register(XMLValueType.INT, basePath .. ".states#num" , "Number of pipe states" , 0 )\n\n                        schema:register(XMLValueType.NODE_INDEX, basePath .. ".pipeNodes.pipeNode(?)#node" , "Pipe node" )\n                        schema:register(XMLValueType.NODE_INDEX, basePath .. ".pipeNodes.pipeNode(?)#subPipeNode" , "Sub pipe node(Target rotation is divided between these two nodes depending on the X rotation ratio between #node and #node parent and #subPipeNode and #node parent)" )\n                        schema:register(XMLValueType.FLOAT, basePath .. ".pipeNodes.pipeNode(?)#subPipeNodeRatio" , "Ratio between usage of this pipe node and sub node [0-1]" , "Calculated based on rotation in i3d file" )\n                        schema:register(XMLValueType.BOOL, basePath .. ".pipeNodes.pipeNode(?)#autoAimXRotation" , "Auto aim X rotation" , false )\n                        schema:register(XMLValueType.BOOL, basePath .. ".pipeNodes.pipeNode(?)#autoAimYRotation" , "Auto aim Y rotation" , false )\n                        schema:register(XMLValueType.BOOL, basePath .. ".pipeNodes.pipeNode(?)#autoAimInvertZ" , "Auto aim invert Z axis" , false )\n\n                        schema:register(XMLValueType.VECTOR_TRANS, basePath .. ".pipeNodes.pipeNode(?).state(?)#translation" , "State translation" )\n                        schema:register(XMLValueType.VECTOR_ROT, basePath .. ".pipeNodes.pipeNode(?).state(?)#rotation" , "State translation" )\n\n                        schema:register(XMLValueType.VECTOR_TRANS, basePath .. ".pipeNodes.pipeNode(?)#translationSpeeds" , "Translation speeds" )\n                        schema:register(XMLValueType.VECTOR_ROT, basePath .. ".pipeNodes.pipeNode(?)#rotationSpeeds" , "Rotation speeds" )\n\n                        schema:register(XMLValueType.VECTOR_ROT, basePath .. ".pipeNodes.pipeNode(?)#minRotationLimits" , "Min.rotation limit" )\n                        schema:register(XMLValueType.VECTOR_ROT, basePath .. ".pipeNodes.pipeNode(?)#maxRotationLimits" , "Max.rotation limit" )\n\n                        schema:register(XMLValueType.INT, basePath .. ".pipeNodes.pipeNode(?)#foldPriority" , "Fold priority" , 0 )\n                        schema:register(XMLValueType.FLOAT, basePath .. ".pipeNodes.pipeNode(?)#bendingRegulation" , "Bending angle regulation" , 0 )\n\n                        schema:register(XMLValueType.NODE_INDEX, basePath .. ".pipeNodes.pipeNode(?).bendingRegulationNode(?)#node" , "Bending regulation node" , 0 )\n                        schema:register(XMLValueType.INT, basePath .. ".pipeNodes.pipeNode(?).bendingRegulationNode(?)#axis" , "Bending regulation axis" , 0 )\n                        schema:register(XMLValueType.INT, basePath .. ".pipeNodes.pipeNode(?).bendingRegulationNode(?)#direction" , "Bending regulation direction" , 0 )\n\n                        SoundManager.registerSampleXMLPaths(schema, basePath .. ".pipeNodes.pipeNode(?)" , "moveSound(?)" )\n\n                        schema:register(XMLValueType.VECTOR_N, basePath .. ".states#unloading" , "Unloading states" )\n                        schema:register(XMLValueType.VECTOR_N, basePath .. ".states#autoAiming" , "Auto aim states" )\n                        schema:register(XMLValueType.VECTOR_N, basePath .. ".states#turnOnAllowed" , "Turn on allowed states" )\n\n                        schema:register(XMLValueType.INT, basePath .. ".states.state(?)#stateIndex" , "State index" )\n                        schema:register(XMLValueType.INT, basePath .. ".states.state(?)#dischargeNodeIndex" , "Discharge node index" )\n\n                        schema:register(XMLValueType.FLOAT, basePath .. "#foldMinLimit" , "Fold min.limit" , 0 )\n                        schema:register(XMLValueType.FLOAT, basePath .. "#foldMaxLimit" , "Fold max.limit" , 1 )\n\n                        schema:register(XMLValueType.INT, basePath .. "#foldMinState" , "Fold min.state" , 1 )\n                        schema:register(XMLValueType.INT, basePath .. "#foldMaxState" , "Fold max.state" , "Num.of states" )\n\n                        schema:register(XMLValueType.BOOL, basePath .. "#aiFoldedPipeUsesTrailerSpace" , "Defines if the folded pipe uses the space of the trailer to discharge" , false )\n                        end\n\n'})}),"\n",(0,s.jsx)(n.h3,{id:"savetoxmlfile",children:"saveToXMLFile"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Definition"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"saveToXMLFile()"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"any"}),(0,s.jsx)(n.th,{children:"xmlFile"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"any"}),(0,s.jsx)(n.td,{children:"key"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"any"}),(0,s.jsx)(n.td,{children:"usedModNames"})]})]})]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Code"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:'function Pipe:saveToXMLFile(xmlFile, key, usedModNames)\n    local spec = self.spec_pipe\n    if spec.numStates > 0 then\n        xmlFile:setValue(key .. "#state" , math.clamp(spec.currentState, 1 , spec.numStates))\n    end\n\n    xmlFile:setValue(key .. "#isStateChangeAllowed" , spec.isStateChangeAllowed)\nend\n\n'})}),"\n",(0,s.jsx)(n.h3,{id:"setpipedischargetoground",children:"setPipeDischargeToGround"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Definition"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"setPipeDischargeToGround()"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"any"}),(0,s.jsx)(n.th,{children:"state"})]})}),(0,s.jsx)(n.tbody,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"any"}),(0,s.jsx)(n.td,{children:"noEventSend"})]})})]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Code"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:"function Pipe:setPipeDischargeToGround(state, noEventSend)\n    local spec = self.spec_pipe\n    if state = = nil then\n        state = not spec.dischargeToGroundState\n    end\n\n    if state ~ = spec.dischargeToGroundState then\n        spec.dischargeToGroundState = state\n\n        local actionEvent = spec.actionEvents[InputAction.TOGGLE_TIPSTATE_GROUND]\n        if actionEvent ~ = nil then\n            g_inputBinding:setActionEventText(actionEvent.actionEventId, state and spec.texts.stopTipToGround or spec.texts.startTipToGround)\n        end\n\n        SetPipeDischargeToGroundEvent.sendEvent( self , state, noEventSend)\n    end\nend\n\n"})}),"\n",(0,s.jsx)(n.h3,{id:"setpipestate",children:"setPipeState"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Definition"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"setPipeState()"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"any"}),(0,s.jsx)(n.th,{children:"pipeState"})]})}),(0,s.jsx)(n.tbody,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"any"}),(0,s.jsx)(n.td,{children:"noEventSend"})]})})]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Code"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:"function Pipe:setPipeState(pipeState, noEventSend)\n    local spec = self.spec_pipe\n\n    pipeState = math.min(pipeState, spec.numStates)\n    if spec.targetState ~ = pipeState then\n        if noEventSend = = nil or noEventSend = = false then\n            if g_server ~ = nil then\n                g_server:broadcastEvent( SetPipeStateEvent.new( self , pipeState))\n            else\n                    g_client:getServerConnection():sendEvent( SetPipeStateEvent.new( self , pipeState), nil , nil , self )\n                end\n            end\n            spec.targetState = pipeState\n            spec.currentState = 0\n\n            if spec.animation ~ = nil then\n                if pipeState = = 1 then\n                    self:playAnimation(spec.animation.name, - spec.animation.speedScale, self:getAnimationTime(spec.animation.name), true )\n                else\n                        self:playAnimation(spec.animation.name, spec.animation.speedScale, self:getAnimationTime(spec.animation.name), true )\n                    end\n                end\n\n                if spec.forceDischargeNodeIndex then\n                    self:setCurrentDischargeNodeIndex( self:getPipeDischargeNodeIndex(pipeState))\n                end\n            end\n        end\n\n"})}),"\n",(0,s.jsx)(n.h3,{id:"unloadingtriggercallback",children:"unloadingTriggerCallback"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Definition"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"unloadingTriggerCallback()"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"any"}),(0,s.jsx)(n.th,{children:"triggerId"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"any"}),(0,s.jsx)(n.td,{children:"otherId"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"any"}),(0,s.jsx)(n.td,{children:"onEnter"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"any"}),(0,s.jsx)(n.td,{children:"onLeave"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"any"}),(0,s.jsx)(n.td,{children:"onStay"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"any"}),(0,s.jsx)(n.td,{children:"otherShapeId"})]})]})]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Code"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:'function Pipe:unloadingTriggerCallback(triggerId, otherId, onEnter, onLeave, onStay, otherShapeId)\n    if onEnter or onLeave then\n        local object = g_currentMission:getNodeObject(otherId)\n\n        if object ~ = nil and object ~ = self and object:isa( Vehicle ) then\n            if object.getFillUnitIndexFromNode ~ = nil then\n                local fillUnitIndex = object:getFillUnitIndexFromNode(otherId)\n                if fillUnitIndex ~ = nil then\n                    local spec = self.spec_pipe\n\n                    local dischargeNode = self:getDischargeNodeByIndex( self:getPipeDischargeNodeIndex())\n                    if dischargeNode ~ = nil then\n                        local fillTypes = self:getFillUnitSupportedFillTypes(dischargeNode.fillUnitIndex)\n\n                        -- objects is only valid if it supports at least one of the harvesters fill types\n                            local objectSupportsFillType = false\n                            for fillType, _ in pairs(fillTypes) do\n                                if object:getFillUnitSupportsFillType(fillUnitIndex, fillType) then\n                                    objectSupportsFillType = true\n                                    break\n                                end\n                            end\n\n                            if objectSupportsFillType then\n                                if onEnter then\n                                    if spec.objectsInTriggers[object] = = nil then\n                                        spec.objectsInTriggers[object] = 0\n                                        spec.numObjectsInTriggers = spec.numObjectsInTriggers + 1\n                                        if object.addDeleteListener ~ = nil then\n                                            object:addDeleteListener( self , "onDeletePipeObject" )\n                                        end\n                                    end\n\n                                    spec.objectsInTriggers[object] = spec.objectsInTriggers[object] + 1\n                                    self:raiseActive()\n                                else\n                                        spec.objectsInTriggers[object] = spec.objectsInTriggers[object] - 1\n                                        if spec.objectsInTriggers[object] = = 0 then\n                                            spec.objectsInTriggers[object] = nil\n                                            spec.numObjectsInTriggers = spec.numObjectsInTriggers - 1\n                                            if object.removeDeleteListener ~ = nil then\n                                                object:removeDeleteListener( self , "onDeletePipeObject" )\n                                            end\n                                        end\n                                    end\n                                end\n                            end\n                        end\n                    end\n                elseif object ~ = nil and object ~ = self and object:isa( UnloadTrigger ) then\n                        local spec = self.spec_pipe\n                        if onEnter then\n                            if spec.unloadTriggersInTriggers[object] = = nil then\n                                spec.unloadTriggersInTriggers[object] = 0\n                                spec.numUnloadTriggersInTriggers = spec.numUnloadTriggersInTriggers + 1\n                                if object.addDeleteListener ~ = nil then\n                                    object:addDeleteListener( self , "onDeletePipeObject" )\n                                end\n                            end\n\n                            spec.unloadTriggersInTriggers[object] = spec.unloadTriggersInTriggers[object] + 1\n                            self:raiseActive()\n                        else\n                                spec.unloadTriggersInTriggers[object] = spec.unloadTriggersInTriggers[object] - 1\n                                if spec.unloadTriggersInTriggers[object] = = 0 then\n                                    spec.unloadTriggersInTriggers[object] = nil\n                                    spec.numUnloadTriggersInTriggers = spec.numUnloadTriggersInTriggers - 1\n                                    if object.removeDeleteListener ~ = nil then\n                                        object:removeDeleteListener( self , "onDeletePipeObject" )\n                                    end\n                                end\n                            end\n                        end\n                    end\n                end\n\n'})}),"\n",(0,s.jsx)(n.h3,{id:"updateactioneventtext",children:"updateActionEventText"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Definition"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"updateActionEventText()"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Code"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:'function Pipe:updateActionEventText()\n    local spec = self.spec_pipe\n\n    -- check if action event already exists.Nil on loading\n        local actionEvent = spec.actionEvents[InputAction.TOGGLE_PIPE]\n        if actionEvent ~ = nil then\n            local showAction = false\n            if spec.targetState = = spec.numStates then\n                if self:getIsPipeStateChangeAllowed( 1 ) then\n                    g_inputBinding:setActionEventText(actionEvent.actionEventId, spec.texts.pipeIn)\n                    showAction = true\n                end\n            else\n                    local nextState = spec.targetState + 1\n                    if self:getIsPipeStateChangeAllowed(nextState) then\n                        local pipeStateName = ""\n                        if spec.numUnloadingStates > 1 and spec.numUnloadingStates ~ = spec.numStates then\n                            pipeStateName = string.format( " [%d]" , nextState - 1 )\n                            local dischargeNodeIndex = self:getPipeDischargeNodeIndex(nextState)\n                            local dischargeNode = self:getDischargeNodeByIndex(dischargeNodeIndex)\n                            local fillTypeIndex = self:getFillUnitFillType(dischargeNode.fillUnitIndex)\n                            if fillTypeIndex ~ = FillType.UNKNOWN then\n                                local fillType = g_fillTypeManager:getFillTypeByIndex(fillTypeIndex)\n                                if fillType ~ = nil then\n                                    pipeStateName = string.format( " [%d, %s]" , nextState - 1 , fillType.title)\n                                end\n                            end\n                        end\n\n                        g_inputBinding:setActionEventText(actionEvent.actionEventId, string.format(spec.texts.pipeOut, pipeStateName))\n                        showAction = true\n                    end\n                end\n\n                g_inputBinding:setActionEventActive(actionEvent.actionEventId, showAction)\n            end\n        end\n\n'})}),"\n",(0,s.jsx)(n.h3,{id:"updatebendingregulationnodes",children:"updateBendingRegulationNodes"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Definition"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"updateBendingRegulationNodes()"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"any"}),(0,s.jsx)(n.th,{children:"pipeNode"})]})}),(0,s.jsx)(n.tbody,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"any"}),(0,s.jsx)(n.td,{children:"distance"})]})})]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Code"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:"function Pipe:updateBendingRegulationNodes(pipeNode, distance)\n    local _, dirY, _ = localDirectionToWorld(pipeNode.node, 0 , 1 , 0 )\n\n    for _, regulationNode in ipairs(pipeNode.regulationNodes) do\n        local regulationAngle = dirY * pipeNode.bendingRegulation\n        local weights = regulationNode.weights\n        local startRotation = regulationNode.startRotation\n        setRotation(regulationNode.node, startRotation[ 1 ] + weights[ 1 ] * regulationAngle,\n        startRotation[ 2 ] + weights[ 2 ] * regulationAngle,\n        startRotation[ 3 ] + weights[ 3 ] * regulationAngle)\n\n        if VehicleDebug.state = = VehicleDebug.DEBUG then\n            local x1, y1, z1 = getWorldTranslation(regulationNode.node)\n            local x2, y2, z2 = localToWorld(regulationNode.node, 0 , - 10 , 0 )\n            drawDebugLine(x1, y1, z1, 0 , 0 , 1 , x2, y2, z2, 0 , 0 , 1 )\n        end\n    end\n\n    return math.sin(dirY * pipeNode.bendingRegulation) * distance\nend\n\n"})}),"\n",(0,s.jsx)(n.h3,{id:"updatenearestobjectintriggers",children:"updateNearestObjectInTriggers"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Definition"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"updateNearestObjectInTriggers()"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Code"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:"function Pipe:updateNearestObjectInTriggers()\n    local spec = self.spec_pipe\n\n    spec.nearestObjectInTriggers.objectId = nil\n    spec.nearestObjectInTriggers.fillUnitIndex = 0\n    spec.nearestObjectInTriggers.isDischargeObject = false\n\n    local minDistance = math.huge\n    local dischargeNode = self:getDischargeNodeByIndex( self:getPipeDischargeNodeIndex())\n    if dischargeNode ~ = nil then\n        local checkNode = Utils.getNoNil(dischargeNode.node, self.components[ 1 ].node)\n\n        for object, _ in pairs(spec.objectsInTriggers) do\n            local outputFillType = self:getFillUnitLastValidFillType(dischargeNode.fillUnitIndex)\n\n            for fillUnitIndex, _ in ipairs(object.spec_fillUnit.fillUnits) do\n                local allowedToFillByPipe = object:getFillUnitSupportsToolType(fillUnitIndex, ToolType.DISCHARGEABLE)\n                local supportsFillType = object:getFillUnitSupportsFillType(fillUnitIndex, outputFillType) or outputFillType = = FillType.UNKNOWN\n                local freeCapacity = object:getFillUnitFreeCapacity(fillUnitIndex, outputFillType, self:getOwnerFarmId())\n\n                if allowedToFillByPipe and supportsFillType and freeCapacity > 0 then\n                    local targetPoint = object:getFillUnitAutoAimTargetNode(fillUnitIndex)\n                    local exactFillRootNode = object:getFillUnitExactFillRootNode(fillUnitIndex)\n\n                    if targetPoint = = nil then\n                        targetPoint = exactFillRootNode\n                    end\n\n                    if targetPoint ~ = nil then\n                        local distance = calcDistanceFrom(checkNode, targetPoint)\n                        if distance < minDistance then\n                            minDistance = distance\n                            spec.nearestObjectInTriggers.objectId = NetworkUtil.getObjectId(object)\n                            spec.nearestObjectInTriggers.fillUnitIndex = fillUnitIndex\n\n                            if object = = dischargeNode.dischargeObject and fillUnitIndex = = dischargeNode.dischargeFillUnitIndex then\n                                spec.nearestObjectInTriggers.isDischargeObject = true\n                            end\n                        end\n                    end\n                end\n            end\n        end\n    else\n            Logging.xmlWarning( self.xmlFile, \"Unable to find discharge node index '%d' for pipe\" , self:getPipeDischargeNodeIndex())\n            end\n        end\n\n"})}),"\n",(0,s.jsx)(n.h3,{id:"updatepipenodes",children:"updatePipeNodes"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Definition"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"updatePipeNodes()"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,s.jsx)(n.table,{children:(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"any"}),(0,s.jsx)(n.th,{children:"dt"})]})})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Code"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:'function Pipe:updatePipeNodes(dt)\n    local spec = self.spec_pipe\n    local object = nil\n    if spec.nearestObjectInTriggers.objectId ~ = nil then\n        object = NetworkUtil.getObject(spec.nearestObjectInTriggers.objectId)\n\n        if object ~ = nil and not object:getIsSynchronized() then\n            object = nil\n        end\n\n        if object ~ = nil and(object.rootNode = = nil or not entityExists(object.rootNode)) then\n            object = nil\n        end\n    end\n\n    local doAutoAiming = object ~ = nil and spec.autoAimingStates[spec.currentState]\n\n    if spec.currentState ~ = spec.targetState or doAutoAiming then\n        local priority = spec.targetState ~ = spec.numStates and "foldPriority" or "inverseFoldPriority"\n\n        local fillAutoAimTargetNode\n        local autoAimX, autoAimY, autoAimZ\n        if doAutoAiming then\n            fillAutoAimTargetNode = object:getFillUnitAutoAimTargetNode(spec.nearestObjectInTriggers.fillUnitIndex)\n            if fillAutoAimTargetNode = = nil then\n                fillAutoAimTargetNode = object:getFillUnitExactFillRootNode(spec.nearestObjectInTriggers.fillUnitIndex)\n            end\n\n            autoAimX, autoAimY, autoAimZ = getWorldTranslation(fillAutoAimTargetNode)\n\n            if VehicleDebug.state = = VehicleDebug.DEBUG then\n                DebugGizmo.renderAtPositionSimple(autoAimX, autoAimY, autoAimZ, getName(fillAutoAimTargetNode))\n            end\n\n            if object.isActive and self.updateLoopIndex ~ = object.updateLoopIndex then\n                object:addExactFillRootAimToUpdate( self , self.updatePipeNodes)\n                return\n            end\n        end\n\n        local moved = false\n        for i = 1 , #spec.nodes do\n            local nodeMoved = false\n            local pipeNode = spec.nodes[i]\n\n            local nodeAutoAimY = autoAimY\n            if pipeNode.bendingRegulation > 0 then\n                if fillAutoAimTargetNode ~ = nil then\n                    local distance = calcDistanceFrom(pipeNode.node, fillAutoAimTargetNode)\n                    local regulation = self:updateBendingRegulationNodes(pipeNode, distance)\n                    nodeAutoAimY = autoAimY - regulation\n                end\n            end\n\n            local state = pipeNode.states[spec.targetState]\n            if pipeNode.translationSpeeds ~ = nil then\n                for axis = 1 , 3 do\n                    if math.abs(pipeNode.curTranslation[axis] - state.translation[axis]) > 0.000001 then\n                        nodeMoved = true\n                        if pipeNode.curTranslation[axis] < state.translation[axis] then\n                            pipeNode.curTranslation[axis] = math.min(pipeNode.curTranslation[axis] + dt * pipeNode.translationSpeeds[axis], state.translation[axis])\n                        else\n                                pipeNode.curTranslation[axis] = math.max(pipeNode.curTranslation[axis] - dt * pipeNode.translationSpeeds[axis], state.translation[axis])\n                            end\n                        end\n                    end\n                    setTranslation(pipeNode.node, pipeNode.curTranslation[ 1 ],pipeNode.curTranslation[ 2 ],pipeNode.curTranslation[ 3 ])\n                end\n                if pipeNode.rotationSpeeds ~ = nil then\n                    local changed = false\n                    for axis = 1 , 3 do\n                        local targetRotation = state.rotation[axis]\n                        if doAutoAiming then\n                            if pipeNode.autoAimXRotation and axis = = 1 then\n                                local x, y, z = getWorldTranslation(pipeNode.node)\n\n                                if VehicleDebug.state = = VehicleDebug.DEBUG then\n                                    if pipeNode.subPipeNode = = nil then\n                                        drawDebugLine(x, y, z, 1 , 0 , 0 , autoAimX, nodeAutoAimY, autoAimZ, 1 , 0 , 0 )\n                                    else\n                                            local x1, y1, z1 = getWorldTranslation(pipeNode.node)\n                                            local x2, y2, z2 = localToWorld(pipeNode.node, 0 , 0 , 3 )\n                                            drawDebugLine(x1, y1, z1, 1 , 1 , 0 , x2, y2, z2, 1 , 1 , 0 )\n\n                                            DebugGizmo.renderAtPositionSimple(x2, y2, z2, string.format( "ratio: %.2f" , pipeNode.subPipeNodeRatio))\n                                        end\n                                    end\n\n                                    local _, lDirY, lDirZ = worldDirectionToLocal(getParent(pipeNode.node), autoAimX - x, nodeAutoAimY - y, autoAimZ - z)\n                                    targetRotation = - math.atan2(lDirY, lDirZ)\n\n                                    if pipeNode.subPipeNode ~ = nil then\n                                        targetRotation = targetRotation * pipeNode.subPipeNodeRatio\n                                    end\n\n                                    if pipeNode.autoAimInvertZ then\n                                        targetRotation = targetRotation + math.pi\n                                    end\n                                    targetRotation = MathUtil.normalizeRotationForShortestPath(targetRotation, pipeNode.curRotation[axis])\n                                elseif pipeNode.autoAimYRotation and axis = = 2 then\n                                        local x, y, z = getWorldTranslation(pipeNode.node)\n                                        local lDirX, _, lDirZ = worldDirectionToLocal(getParent(pipeNode.node), autoAimX - x, nodeAutoAimY - y, autoAimZ - z)\n                                        targetRotation = math.atan2(lDirX, lDirZ)\n                                        if pipeNode.autoAimInvertZ then\n                                            targetRotation = targetRotation + math.pi\n                                        end\n                                        targetRotation = MathUtil.normalizeRotationForShortestPath(targetRotation, pipeNode.curRotation[axis])\n                                    end\n                                end\n                                if pipeNode.minRotationLimits ~ = nil and pipeNode.maxRotationLimits ~ = nil then\n                                    if math.abs(targetRotation) > ( 2 * math.pi) then\n                                        targetRotation = targetRotation % ( 2 * math.pi)\n                                    end\n\n                                    if pipeNode.minRotationLimits[axis] ~ = nil then\n                                        targetRotation = math.max(targetRotation, pipeNode.minRotationLimits[axis])\n                                    end\n                                    if pipeNode.maxRotationLimits[axis] ~ = nil then\n                                        targetRotation = math.min(targetRotation, pipeNode.maxRotationLimits[axis])\n                                    end\n                                end\n                                if math.abs(pipeNode.curRotation[axis] - targetRotation) > 0.00001 then\n                                    changed = true\n                                    local rotationAllowed = true\n                                    -- priorities only while folding the pipe, not while auto aiming\n                                        if not doAutoAiming then\n                                            for j = 1 , #spec.nodes do\n                                                local pipeNodeToCheck = spec.nodes[j]\n                                                if pipeNodeToCheck[priority] > pipeNode[priority] then\n                                                    for l = 1 , 3 do\n                                                        if pipeNodeToCheck.curRotation[l] ~ = pipeNodeToCheck.lastTargetRotation[l] then\n                                                            rotationAllowed = false\n                                                            break\n                                                        end\n                                                    end\n                                                end\n                                            end\n                                        end\n\n                                        if rotationAllowed then\n                                            if math.abs(pipeNode.curRotation[axis] - targetRotation) > dt * pipeNode.rotationSpeeds[axis] * 0.95 then\n                                                if pipeNode.moveSamplesPlayTimer < = 0 then\n                                                    g_soundManager:playSamples(pipeNode.moveSamples)\n                                                end\n                                                pipeNode.moveSamplesPlayTimer = 250\n                                            end\n\n                                            nodeMoved = true\n                                            if pipeNode.curRotation[axis] < targetRotation then\n                                                pipeNode.curRotation[axis] = math.min(pipeNode.curRotation[axis] + dt * pipeNode.rotationSpeeds[axis], targetRotation)\n                                            else\n                                                    pipeNode.curRotation[axis] = math.max(pipeNode.curRotation[axis] - dt * pipeNode.rotationSpeeds[axis], targetRotation)\n                                                end\n                                                if pipeNode.curRotation[axis] > 2 * math.pi then\n                                                    pipeNode.curRotation[axis] = pipeNode.curRotation[axis] - 2 * math.pi\n                                                elseif pipeNode.curRotation[axis] < - 2 * math.pi then\n                                                        pipeNode.curRotation[axis] = pipeNode.curRotation[axis] + 2 * math.pi\n                                                    end\n\n                                                    pipeNode.lastTargetRotation[axis] = targetRotation\n                                                end\n                                            end\n                                        end\n\n                                        if changed then\n                                            setRotation(pipeNode.node, pipeNode.curRotation[ 1 ], pipeNode.curRotation[ 2 ], pipeNode.curRotation[ 3 ])\n                                        end\n                                    end\n                                    moved = moved or nodeMoved\n\n                                    if nodeMoved and self.setMovingToolDirty ~ = nil then\n                                        self:setMovingToolDirty(pipeNode.node)\n                                    end\n                                end\n\n                                if #spec.nodes = = 0 and spec.animation.name ~ = nil then\n                                    if self:getIsAnimationPlaying(spec.animation.name) then\n                                        moved = true\n                                    end\n                                end\n\n                                if not moved then\n                                    spec.currentState = spec.targetState\n                                end\n                            else\n                                    if self:getDischargeState() = = Dischargeable.DISCHARGE_STATE_GROUND then\n                                        local dischargeNode = self:getDischargeNodeByIndex( self:getPipeDischargeNodeIndex())\n                                        if dischargeNode ~ = nil then\n                                            for _,pipeNode in ipairs(spec.nodes) do\n                                                if pipeNode.bendingRegulation > 0 then\n                                                    self:updateBendingRegulationNodes(pipeNode, dischargeNode.dischargeDistance)\n                                                end\n                                            end\n                                        end\n                                    end\n                                end\n\n                                for _, pipeNode in ipairs(spec.nodes) do\n                                    pipeNode.moveSamplesPlayTimer = pipeNode.moveSamplesPlayTimer - dt\n                                    if pipeNode.moveSamplesPlayTimer < 0 then\n                                        g_soundManager:stopSamples(pipeNode.moveSamples)\n                                        pipeNode.moveSamplesPlayTimer = 0\n                                    end\n                                end\n                            end\n\n'})})]})}function h(e={}){const{wrapper:n}={...(0,l.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(c,{...e})}):c(e)}},28453(e,n,i){i.d(n,{R:()=>r,x:()=>a});var t=i(96540);const s={},l=t.createContext(s);function r(e){const n=t.useContext(l);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:r(e.components),t.createElement(l.Provider,{value:n},e.children)}}}]);