"use strict";(globalThis.webpackChunkfs25_community_luadoc=globalThis.webpackChunkfs25_community_luadoc||[]).push([[29878],{28453(e,n,l){l.d(n,{R:()=>s,x:()=>r});var i=l(96540);const t={},o=i.createContext(t);function s(e){const n=i.useContext(o);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:s(e.components),i.createElement(o.Provider,{value:n},e.children)}},80424(e,n,l){l.r(n),l.d(n,{assets:()=>a,contentTitle:()=>r,default:()=>f,frontMatter:()=>s,metadata:()=>i,toc:()=>c});const i=JSON.parse('{"id":"script/GUI/BoxLayoutElement","title":"BoxLayoutElement","description":"BoxLayoutElement","source":"@site/../docs/script/GUI/BoxLayoutElement.md","sourceDirName":"script/GUI","slug":"/script/GUI/BoxLayoutElement","permalink":"/FS25-Community-LUADOC/script/GUI/BoxLayoutElement","draft":false,"unlisted":false,"tags":[],"version":"current","lastUpdatedAt":1767161192000,"frontMatter":{},"sidebar":"docsSidebar","previous":{"title":"BitmapElement","permalink":"/FS25-Community-LUADOC/script/GUI/BitmapElement"},"next":{"title":"BreadcrumbsElement","permalink":"/FS25-Community-LUADOC/script/GUI/BreadcrumbsElement"}}');var t=l(74848),o=l(28453);const s={},r=void 0,a={},c=[{value:"BoxLayoutElement",id:"boxlayoutelement",level:2},{value:"addElement",id:"addelement",level:3},{value:"applyCellPositions",id:"applycellpositions",level:3},{value:"canReceiveFocus",id:"canreceivefocus",level:3},{value:"copyAttributes",id:"copyattributes",level:3},{value:"focusLinkCells",id:"focuslinkcells",level:3},{value:"getIsElementIncluded",id:"getiselementincluded",level:3},{value:"loadFromXML",id:"loadfromxml",level:3},{value:"loadProfile",id:"loadprofile",level:3},{value:"new",id:"new",level:3},{value:"onFocusLeave",id:"onfocusleave",level:3},{value:"onGuiSetupFinished",id:"onguisetupfinished",level:3},{value:"removeElement",id:"removeelement",level:3},{value:"updateAbsolutePosition",id:"updateabsoluteposition",level:3},{value:"updateLayoutCells",id:"updatelayoutcells",level:3}];function d(e){const n={a:"a",blockquote:"blockquote",code:"code",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,o.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.h2,{id:"boxlayoutelement",children:"BoxLayoutElement"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Description"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:'Layout element which lays out child elements in regular rows or columns.\nExceptions are elements whose "layoutIgnore" property is true.\nUsed layers: "image" for a background image.'}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Parent"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.a,{href:"?version=script&category=43&class=428",children:"BitmapElement"})}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Functions"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#addelement",children:"addElement"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#applycellpositions",children:"applyCellPositions"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#canreceivefocus",children:"canReceiveFocus"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#copyattributes",children:"copyAttributes"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#focuslinkcells",children:"focusLinkCells"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#getiselementincluded",children:"getIsElementIncluded"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#loadfromxml",children:"loadFromXML"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#loadprofile",children:"loadProfile"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#new",children:"new"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#onfocusleave",children:"onFocusLeave"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#onguisetupfinished",children:"onGuiSetupFinished"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#removeelement",children:"removeElement"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#updateabsoluteposition",children:"updateAbsolutePosition"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#updatelayoutcells",children:"updateLayoutCells"})}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"addelement",children:"addElement"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Description"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Definition"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"addElement()"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,t.jsx)(n.table,{children:(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"any"}),(0,t.jsx)(n.th,{children:"element"})]})})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Code"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:"function BoxLayoutElement:addElement(element)\n    BoxLayoutElement:superClass().addElement( self , element)\n\n    -- reset element screen alignment to avoid interference with layouting\n    element:setAnchor( 0 , 0 )\n    element:setPivot( 0 , 0 )\n\n    if self.autoValidateLayout then\n        self:invalidateLayout()\n    end\nend\n\n"})}),"\n",(0,t.jsx)(n.h3,{id:"applycellpositions",children:"applyCellPositions"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Description"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"Apply layout positions to all given cells' elements."}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Definition"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"applyCellPositions(integer offsetX, integer offsetX)"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"integer"}),(0,t.jsx)(n.th,{children:"offsetX"}),(0,t.jsx)(n.th,{children:"additional offsets in x-direction, used for example in ScrollingLayouts, defaults to 0"})]})}),(0,t.jsx)(n.tbody,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"integer"}),(0,t.jsx)(n.td,{children:"offsetX"}),(0,t.jsx)(n.td,{children:"additional offsets in y-direction, used for example in ScrollingLayouts, defaults to 0"})]})})]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Code"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:"function BoxLayoutElement:applyCellPositions(offsetX, offsetY)\n    local offsets = { offsetX or 0 , offsetY or 0 }\n    local flowDirection = self.flowDirection = = BoxLayoutElement.FLOW_VERTICAL and 2 or 1\n    local lateralDirection = self.flowDirection = = BoxLayoutElement.FLOW_VERTICAL and 1 or 2\n\n    local flowOffset = self.alignment[lateralDirection] * ( self.absSize[lateralDirection] - self.totalLateralSize) + offsets[lateralDirection]\n\n    local flowIndexStart, flowIndexEnd = 1 , # self.cells\n    local flowDir = self.fillDirections[lateralDirection]\n\n    -- swap values if negative direction:\n        if flowDir = = - 1 then\n            flowIndexStart, flowIndexEnd = flowIndexEnd, flowIndexStart\n        end\n\n        for flowIndex = flowIndexStart, flowIndexEnd, flowDir do\n            local flow = self.cells[flowIndex]\n\n            if flow = = nil or #flow = = 0 then\n                break\n            end\n\n            local cellIndexStart, cellIndexEnd = 1 , #flow\n            local cellDir = self.fillDirections[flowDirection]\n\n            -- swap values if negative direction:\n                if cellDir = = - 1 then\n                    cellIndexStart, cellIndexEnd = cellIndexEnd, cellIndexStart\n                end\n\n                local cellOffset = self.alignment[flowDirection] * ( self.absSize[flowDirection] - self.flowSizes[flowIndex]) + offsets[flowDirection]\n\n                for cellIndex = cellIndexStart, cellIndexEnd, cellDir do\n                    local cell = flow[cellIndex]\n\n                    if cell = = nil then\n                        break\n                    end\n\n                    -- reset element screen alignment to avoid interference with layouting\n                    cell:setAnchor( 0 , 0 )\n                    cell:setPivot( 0 , 0 )\n\n                    local cellLateralOffset = flowOffset\n                    if self.fitFlowToElements then\n                        local cellLateralSize = cell.absSize[lateralDirection] + cell.margin[lateralDirection] + cell.margin[lateralDirection + 2 ]\n                        cellLateralOffset = flowOffset + self.alignment[lateralDirection] * ( self.lateralFlowSizes[flowIndex] - cellLateralSize)\n                    end\n\n                    local cellPos = { cellOffset, cellLateralOffset }\n\n                    --add left and bottom margin to position\n                    cell:setPosition(cellPos[flowDirection] + cell.margin[ 1 ], cellPos[lateralDirection] + cell.margin[ 4 ])\n\n                    cellOffset = cellOffset + cell.absSize[flowDirection] + self.elementSpacing + cell.margin[flowDirection] + cell.margin[flowDirection + 2 ]\n                end\n\n                flowOffset = flowOffset + self.lateralFlowSizes[flowIndex]\n            end\n        end\n\n"})}),"\n",(0,t.jsx)(n.h3,{id:"canreceivefocus",children:"canReceiveFocus"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Description"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Definition"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"canReceiveFocus()"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Code"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:"function BoxLayoutElement:canReceiveFocus()\n    -- element can receive focus if any sub elements are ready to receive focus\n        if self.handleFocus then\n            for _, v in ipairs( self.elements) do\n                if (v:canReceiveFocus()) then\n                    return true\n                end\n            end\n        end\n        return false\n    end\n\n"})}),"\n",(0,t.jsx)(n.h3,{id:"copyattributes",children:"copyAttributes"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Description"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Definition"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"copyAttributes()"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,t.jsx)(n.table,{children:(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"any"}),(0,t.jsx)(n.th,{children:"src"})]})})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Code"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:"function BoxLayoutElement:copyAttributes(src)\n    BoxLayoutElement:superClass().copyAttributes( self , src)\n\n    self.alignment = table.clone(src.alignment)\n    self.fillDirections = table.clone(src.fillDirections)\n\n    self.autoValidateLayout = src.autoValidateLayout\n    self.useFullVisibility = src.useFullVisibility\n    self.layoutToleranceX = src.layoutToleranceX\n    self.layoutToleranceY = src.layoutToleranceY\n\n    self.flowDirection = src.flowDirection\n    self.focusDirection = src.focusDirection\n    self.numFlows = src.numFlows\n    self.lateralFlowSize = src.lateralFlowSize\n    self.fitFlowToElements = src.fitFlowToElements\n    self.elementSpacing = src.elementSpacing\n\n    self.wrapAround = src.wrapAround\n    self.rememberLastFocus = src.rememberLastFocus\nend\n\n"})}),"\n",(0,t.jsx)(n.h3,{id:"focuslinkcells",children:"focusLinkCells"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Description"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"Link layout cells' elements for focus navigation."}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Definition"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"focusLinkCells()"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Code"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:"function BoxLayoutElement:focusLinkCells()\n    local prevElement = nil\n    local firstElement = nil\n    local lastElement = nil\n    self.defaultFocusTarget = nil\n\n    -- determine first and last elements:\n    for _, flow in pairs( self.cells) do\n        for _, cell in pairs(flow) do\n            if not firstElement then\n                firstElement = cell:findFirstFocusable( true )\n\n                --we want the first element to actually be able to recieve focus, findFirstFocusable() returns the element itself if no child can be focused, and we cannot change that without further changes that are risky\n                    if not firstElement:canReceiveFocus() then\n                        firstElement = nil\n                    else\n                            self.defaultFocusTarget = firstElement\n                        end\n                    else\n                            lastElement = cell:findFirstFocusable( true )\n                        end\n                    end\n                end\n\n                --we need to reset this here so self.incomingFocusTargets does not have references to deleted items if layout is now empty after being filled before\n                    self.incomingFocusTargets = { }\n\n                    -- link elements\n                    for _, flow in pairs( self.cells) do\n                        for _, cell in pairs(flow) do\n                            local element = cell:findFirstFocusable( true )\n\n                            if element:canReceiveFocus() then\n                                self:focusLinkChildElement(element, prevElement, firstElement, lastElement)\n                                prevElement = element\n                            end\n                        end\n                    end\n                end\n\n"})}),"\n",(0,t.jsx)(n.h3,{id:"getiselementincluded",children:"getIsElementIncluded"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Description"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Definition"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"getIsElementIncluded()"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"any"}),(0,t.jsx)(n.th,{children:"element"})]})}),(0,t.jsx)(n.tbody,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"any"}),(0,t.jsx)(n.td,{children:"ignoreVisibility"})]})})]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Code"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:"function BoxLayoutElement:getIsElementIncluded(element, ignoreVisibility)\n    return not element.ignoreLayout and ignoreVisibility or(element:getIsVisibleNonRec() and self.useFullVisibility) or(element.visible and not self.useFullVisibility)\nend\n\n"})}),"\n",(0,t.jsx)(n.h3,{id:"loadfromxml",children:"loadFromXML"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Description"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Definition"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"loadFromXML()"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"any"}),(0,t.jsx)(n.th,{children:"xmlFile"})]})}),(0,t.jsx)(n.tbody,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"any"}),(0,t.jsx)(n.td,{children:"key"})]})})]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Code"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:'function BoxLayoutElement:loadFromXML(xmlFile, key)\n    BoxLayoutElement:superClass().loadFromXML( self , xmlFile, key)\n\n    local alignmentX = getXMLString(xmlFile, key .. "#alignmentX" )\n    if alignmentX ~ = nil then\n        alignmentX = string.lower(alignmentX)\n        if alignmentX = = "right" then\n            self.alignment[ 1 ] = BoxLayoutElement.ALIGN_RIGHT\n        elseif alignmentX = = "center" then\n                self.alignment[ 1 ] = BoxLayoutElement.ALIGN_CENTER\n            else\n                    self.alignment[ 1 ] = BoxLayoutElement.ALIGN_LEFT\n                end\n            end\n\n            local alignmentY = getXMLString(xmlFile, key .. "#alignmentY" )\n            if alignmentY ~ = nil then\n                alignmentY = string.lower(alignmentY)\n                if alignmentY = = "bottom" then\n                    self.alignment[ 2 ] = BoxLayoutElement.ALIGN_BOTTOM\n                elseif alignmentY = = "middle" then\n                        self.alignment[ 2 ] = BoxLayoutElement.ALIGN_MIDDLE\n                    else\n                            self.alignment[ 2 ] = BoxLayoutElement.ALIGN_TOP\n                        end\n                    end\n\n                    local fillDirectionX = getXMLString(xmlFile, key .. "#fillDirectionX" )\n                    if fillDirectionX ~ = nil then\n                        if fillDirectionX = = "leftToRight" then\n                            self.fillDirections[ 1 ] = BoxLayoutElement.FILL_DIRECTION_LEFT_TO_RIGHT\n                        elseif fillDirectionX = = "rightToLeft" then\n                                self.fillDirections[ 1 ] = BoxLayoutElement.FILL_DIRECTION_RIGHT_TO_LEFT\n                            end\n                        end\n\n                        local fillDirectionY = getXMLString(xmlFile, key .. "#fillDirectionY" )\n                        if fillDirectionY ~ = nil then\n                            if fillDirectionY = = "topToBottom" then\n                                self.fillDirections[ 2 ] = BoxLayoutElement.FILL_DIRECTION_TOP_TO_BOTTOM\n                            elseif fillDirectionY = = "bottomToTop" then\n                                    self.fillDirections[ 2 ] = BoxLayoutElement.FILL_DIRECTION_BOTTOM_TO_TOP\n                                end\n                            end\n\n                            self.flowDirection = getXMLString(xmlFile, key .. "#flowDirection" ) or self.flowDirection\n                            self.focusDirection = getXMLString(xmlFile, key .. "#focusDirection" ) or self.flowDirection -- use flow direction as default\n                            self.numFlows = getXMLInt(xmlFile, key .. "#numFlows" ) or self.numFlows\n\n                            local isXValue = self.flowDirection = = BoxLayoutElement.FLOW_HORIZONTAL\n                            self.elementSpacing = GuiUtils.getNormalizedValue(getXMLString(xmlFile, key .. "#elementSpacing" ), isXValue) or self.elementSpacing\n                            self.lateralFlowSize = GuiUtils.getNormalizedValue(getXMLString(xmlFile, key .. "#lateralFlowSize" ), not isXValue) or self.lateralFlowSize\n                            self.fitFlowToElements = Utils.getNoNil(getXMLBool(xmlFile, key .. "#fitFlowToElements" ), self.lateralFlowSize = = 0 )\n\n                            self.autoValidateLayout = Utils.getNoNil(getXMLBool(xmlFile, key .. "#autoValidateLayout" ), self.autoValidateLayout)\n                            self.useFullVisibility = Utils.getNoNil(getXMLBool(xmlFile, key .. "#useFullVisibility" ), self.useFullVisibility)\n\n                            self.wrapAround = Utils.getNoNil(getXMLBool(xmlFile, key .. "#wrapAround" ), self.wrapAround)\n                            self.rememberLastFocus = Utils.getNoNil(getXMLBool(xmlFile, key .. "#rememberLastFocus" ), self.rememberLastFocus)\n                        end\n\n'})}),"\n",(0,t.jsx)(n.h3,{id:"loadprofile",children:"loadProfile"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Description"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Definition"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"loadProfile()"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"any"}),(0,t.jsx)(n.th,{children:"profile"})]})}),(0,t.jsx)(n.tbody,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"any"}),(0,t.jsx)(n.td,{children:"applyProfile"})]})})]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Code"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:'function BoxLayoutElement:loadProfile(profile, applyProfile)\n    BoxLayoutElement:superClass().loadProfile( self , profile, applyProfile)\n\n    local alignmentX = profile:getValue( "alignmentX" )\n    if alignmentX ~ = nil then\n        alignmentX = string.lower(alignmentX)\n        if alignmentX = = "right" then\n            self.alignment[ 1 ] = BoxLayoutElement.ALIGN_RIGHT\n        elseif alignmentX = = "center" then\n                self.alignment[ 1 ] = BoxLayoutElement.ALIGN_CENTER\n            else\n                    self.alignment[ 1 ] = BoxLayoutElement.ALIGN_LEFT\n                end\n            end\n\n            local alignmentY = profile:getValue( "alignmentY" )\n            if alignmentY ~ = nil then\n                alignmentY = string.lower(alignmentY)\n                if alignmentY = = "bottom" then\n                    self.alignment[ 2 ] = BoxLayoutElement.ALIGN_BOTTOM\n                elseif alignmentY = = "middle" then\n                        self.alignment[ 2 ] = BoxLayoutElement.ALIGN_MIDDLE\n                    else\n                            self.alignment[ 2 ] = BoxLayoutElement.ALIGN_TOP\n                        end\n                    end\n\n                    local fillDirectionX = profile:getValue( "fillDirectionX" )\n                    if fillDirectionX ~ = nil then\n                        if fillDirectionX = = "leftToRight" then\n                            self.fillDirections[ 1 ] = BoxLayoutElement.FILL_DIRECTION_LEFT_TO_RIGHT\n                        elseif fillDirectionX = = "rightToLeft" then\n                                self.fillDirections[ 1 ] = BoxLayoutElement.FILL_DIRECTION_RIGHT_TO_LEFT\n                            end\n                        end\n\n                        local fillDirectionY = profile:getValue( "fillDirectionY" )\n                        if fillDirectionY ~ = nil then\n                            if fillDirectionY = = "topToBottom" then\n                                self.fillDirections[ 2 ] = BoxLayoutElement.FILL_DIRECTION_TOP_TO_BOTTOM\n                            elseif fillDirectionY = = "bottomToTop" then\n                                    self.fillDirections[ 2 ] = BoxLayoutElement.FILL_DIRECTION_BOTTOM_TO_TOP\n                                end\n                            end\n\n                            self.autoValidateLayout = profile:getBool( "autoValidateLayout" , self.autoValidateLayout)\n                            self.useFullVisibility = profile:getBool( "useFullVisibility" , self.useFullVisibility)\n\n                            self.flowDirection = profile:getValue( "flowDirection" ) or self.flowDirection\n                            self.focusDirection = profile:getValue( "focusDirection" , self.flowDirection)\n                            self.numFlows = profile:getNumber( "numFlows" , self.numFlows)\n\n                            local isXValue = self.flowDirection = = BoxLayoutElement.FLOW_HORIZONTAL\n                            self.elementSpacing = GuiUtils.getNormalizedValue(profile:getValue( "elementSpacing" , self.elementSpacing), isXValue)\n                            self.lateralFlowSize = GuiUtils.getNormalizedValue(profile:getValue( "lateralFlowSize" , self.lateralFlowSize), not isXValue)\n                            self.fitFlowToElements = profile:getBool( "fitFlowToElements" , self.lateralFlowSize = = 0 )\n\n                            self.wrapAround = profile:getBool( "wrapAround" , self.wrapAround)\n                            self.rememberLastFocus = profile:getBool( "rememberLastFocus" , self.rememberLastFocus)\n                        end\n\n'})}),"\n",(0,t.jsx)(n.h3,{id:"new",children:"new"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Description"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Definition"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"new()"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"any"}),(0,t.jsx)(n.th,{children:"target"})]})}),(0,t.jsx)(n.tbody,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"any"}),(0,t.jsx)(n.td,{children:"custom_mt"})]})})]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Code"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:"function BoxLayoutElement.new(target, custom_mt)\n    if custom_mt = = nil then\n        custom_mt = BoxLayoutElement _mt\n    end\n    local self = BitmapElement.new(target, custom_mt)\n\n    self.autoValidateLayout = false\n    self.useFullVisibility = true\n\n    self.wrapAround = false\n    self.alignment = { BoxLayoutElement.ALIGN_LEFT, BoxLayoutElement.ALIGN_TOP }\n    self.flowDirection = BoxLayoutElement.FLOW_HORIZONTAL\n    self.fillDirections = { BoxLayoutElement.FILL_DIRECTION_LEFT_TO_RIGHT, BoxLayoutElement.FILL_DIRECTION_TOP_TO_BOTTOM }\n    self.numFlows = 1 -- number of flows(columns or rows, depending on flow direction)\n    self.lateralFlowSize = 0 -- lateral size of flow(column width or row height, depending on flow direction)\n    self.fitFlowToElements = true -- ignore lateral flow size and fit flows to element dimensions\n    self.layoutToleranceX, self.layoutToleranceY = 0 , 0\n\n    self.rememberLastFocus = false\n    self.lastFocusElement = nil\n    self.incomingFocusTargets = { }\n    self.defaultFocusTarget = nil -- first focusable element of the current layout state\n\n    self.cells = { } -- saved data for all cells in format [flowIndex][cell]\n        self.flowSizes = { }\n        self.lateralFlowSizes = { }\n        self.totalLateralSize = 0\n        self.maxFlowSize = 0\n        self.elementSpacing = 0\n\n        return self\n    end\n\n"})}),"\n",(0,t.jsx)(n.h3,{id:"onfocusleave",children:"onFocusLeave"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Description"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Definition"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"onFocusLeave()"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Code"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:"function BoxLayoutElement:onFocusLeave()\n    BoxLayoutElement:superClass().onFocusLeave( self )\n\n    if self.rememberLastFocus then\n        local lastFocus = FocusManager:getFocusedElement()\n        if lastFocus:isChildOf( self ) then\n            self.lastFocusElement = lastFocus\n        end\n    end\nend\n\n"})}),"\n",(0,t.jsx)(n.h3,{id:"onguisetupfinished",children:"onGuiSetupFinished"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Description"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Definition"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"onGuiSetupFinished()"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Code"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:"function BoxLayoutElement:onGuiSetupFinished()\n    BoxLayoutElement:superClass().onGuiSetupFinished( self )\n    self.layoutToleranceX = BoxLayoutElement.LAYOUT_TOLERANCE * g_pixelSizeX\n    self.layoutToleranceY = BoxLayoutElement.LAYOUT_TOLERANCE * g_pixelSizeY\n\n    self:invalidateLayout()\nend\n\n"})}),"\n",(0,t.jsx)(n.h3,{id:"removeelement",children:"removeElement"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Description"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Definition"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"removeElement()"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,t.jsx)(n.table,{children:(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"any"}),(0,t.jsx)(n.th,{children:"element"})]})})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Code"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:"function BoxLayoutElement:removeElement(element)\n    BoxLayoutElement:superClass().removeElement( self , element)\n\n    if self.autoValidateLayout then\n        self:invalidateLayout()\n    end\nend\n\n"})}),"\n",(0,t.jsx)(n.h3,{id:"updateabsoluteposition",children:"updateAbsolutePosition"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Description"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Definition"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"updateAbsolutePosition()"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Code"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:"function BoxLayoutElement:updateAbsolutePosition()\n    BoxLayoutElement:superClass().updateAbsolutePosition( self )\n\n    self:applyCellPositions()\nend\n\n"})}),"\n",(0,t.jsx)(n.h3,{id:"updatelayoutcells",children:"updateLayoutCells"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Description"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"Extract a flow / cell data table from this box layout's elements.\nAlso save some values like flow sizes for later use"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Definition"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"updateLayoutCells(boolean ignoreVisibility)"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n",(0,t.jsx)(n.table,{children:(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"boolean"}),(0,t.jsx)(n.th,{children:"ignoreVisibility"}),(0,t.jsx)(n.th,{children:"Visibility flag for element eligibility"})]})})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Code"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:"function BoxLayoutElement:updateLayoutCells(ignoreVisibility)\n    -- get property indices to match flow direction\n    self.cells = { { } }\n    local indices = BoxLayoutElement.FLOW_INDICES[ self.flowDirection]\n    local lateralIndices = BoxLayoutElement.FLOW_INDICES[ BoxLayoutElement.FLOW_LATERAL_TABLE[ self.flowDirection]]\n\n    local flowTolerance = self.layoutToleranceX\n    local lateralTolerance = self.layoutToleranceY\n    if self.flowDirection = = BoxLayoutElement.FLOW_VERTICAL then\n        flowTolerance, lateralTolerance = lateralTolerance, flowTolerance\n    end\n\n    local currentFlowSize = 0\n    local maxLateralSize = 0\n    local currentFlow = 1\n    local count = 1\n\n    self.flowSizes = { }\n    self.lateralFlowSizes = { }\n    self.maxFlowSize = 0\n    self.totalLateralSize = 0\n\n    --we rebuild the whole layout, in case there were some changes to individual elements or values\n    for i, element in ipairs( self.elements) do\n        if self:getIsElementIncluded(element, ignoreVisibility) then\n            local elementFlowSize = element.absSize[indices.ELEMENT_SIZE] + element.margin[indices.ELEMENT_MARGIN_LOWER] + element.margin[indices.ELEMENT_MARGIN_UPPER]\n            local elementLateralSize = element.absSize[lateralIndices.ELEMENT_SIZE] + element.margin[lateralIndices.ELEMENT_MARGIN_LOWER] + element.margin[lateralIndices.ELEMENT_MARGIN_UPPER]\n\n            --element would overflow, we start a new flow if possible(number of current flows < self.numFlows)\n                if currentFlowSize + elementFlowSize + self.elementSpacing - flowTolerance > self.absSize[indices.LAYOUT_FLOW_SIZE] and( self.numFlows = = 0 or currentFlow < self.numFlows) then\n                    currentFlow = currentFlow + 1\n                    currentFlowSize = 0\n                    maxLateralSize = 0\n                    count = 1\n\n                    table.insert( self.cells, { } )\n                end\n\n                self.cells[currentFlow][count] = element\n\n                currentFlowSize = currentFlowSize + elementFlowSize\n                self.flowSizes[currentFlow] = currentFlowSize\n                currentFlowSize = currentFlowSize + self.elementSpacing\n                self.maxFlowSize = math.max( self.maxFlowSize, currentFlowSize)\n\n                --if self.fitFlowToElements is true, we save the biggest lateral size of an element in the flow, and the flow will be resized to that value.if not, we use self.lateralFlowSize\n                    local lateralFlowSize = self.fitFlowToElements and elementLateralSize or self.lateralFlowSize\n                    maxLateralSize = math.max(maxLateralSize, lateralFlowSize)\n                    self.lateralFlowSizes[currentFlow] = maxLateralSize\n\n                    count = count + 1\n                end\n            end\n\n            -- we cannot do this calculation directly in the above loop, because we dont know what the maxLateralSize of a flow will be(a bigger element could be added later on)\n                for _, size in pairs( self.lateralFlowSizes) do\n                    self.totalLateralSize = self.totalLateralSize + size\n                end\n            end\n\n"})})]})}function f(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}}}]);