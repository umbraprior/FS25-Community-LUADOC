"use strict";(globalThis.webpackChunkfs25_community_luadoc=globalThis.webpackChunkfs25_community_luadoc||[]).push([[91410],{5717(e,n,l){l.r(n),l.d(n,{assets:()=>r,contentTitle:()=>t,default:()=>f,frontMatter:()=>s,metadata:()=>i,toc:()=>o});const i=JSON.parse('{"id":"script/Contracts/FieldManager","title":"FieldManager","description":"FieldManager","source":"@site/../docs/script/Contracts/FieldManager.md","sourceDirName":"script/Contracts","slug":"/script/Contracts/FieldManager","permalink":"/FS25-Community-LUADOC/script/Contracts/FieldManager","draft":false,"unlisted":false,"tags":[],"version":"current","lastUpdatedAt":1767161192000,"frontMatter":{},"sidebar":"docsSidebar","previous":{"title":"Field","permalink":"/FS25-Community-LUADOC/script/Contracts/Field"},"next":{"title":"PlaceableConfigurationDataObjectChange","permalink":"/FS25-Community-LUADOC/script/Data/PlaceableConfigurationDataObjectChange"}}');var a=l(74848),d=l(28453);const s={},t=void 0,r={},o=[{value:"FieldManager",id:"fieldmanager",level:2},{value:"delete",id:"delete",level:3},{value:"initDataStructures",id:"initdatastructures",level:3},{value:"loadFromXMLFile",id:"loadfromxmlfile",level:3},{value:"loadMapData",id:"loadmapdata",level:3},{value:"new",id:"new",level:3},{value:"saveToXMLFile",id:"savetoxmlfile",level:3},{value:"unloadMapData",id:"unloadmapdata",level:3}];function c(e){const n={a:"a",blockquote:"blockquote",code:"code",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,d.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.h2,{id:"fieldmanager",children:"FieldManager"}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Description"})}),"\n",(0,a.jsxs)(n.blockquote,{children:["\n",(0,a.jsx)(n.p,{children:"This class handles all functionality for AI fields and the NPCs handling them."}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Parent"})}),"\n",(0,a.jsxs)(n.blockquote,{children:["\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.a,{href:"?version=script&category=18&class=187",children:"AbstractManager"})}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Functions"})}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.a,{href:"#delete",children:"delete"})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.a,{href:"#initdatastructures",children:"initDataStructures"})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.a,{href:"#loadfromxmlfile",children:"loadFromXMLFile"})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.a,{href:"#loadmapdata",children:"loadMapData"})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.a,{href:"#new",children:"new"})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.a,{href:"#savetoxmlfile",children:"saveToXMLFile"})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.a,{href:"#unloadmapdata",children:"unloadMapData"})}),"\n"]}),"\n",(0,a.jsx)(n.h3,{id:"delete",children:"delete"}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Description"})}),"\n",(0,a.jsxs)(n.blockquote,{children:["\n",(0,a.jsx)(n.p,{children:"Deletes field manager"}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Definition"})}),"\n",(0,a.jsxs)(n.blockquote,{children:["\n",(0,a.jsx)(n.p,{children:"delete()"}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Code"})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-lua",children:"function FieldManager:delete()\nend\n\n"})}),"\n",(0,a.jsx)(n.h3,{id:"initdatastructures",children:"initDataStructures"}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Description"})}),"\n",(0,a.jsxs)(n.blockquote,{children:["\n",(0,a.jsx)(n.p,{children:"Initialize data structures"}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Definition"})}),"\n",(0,a.jsxs)(n.blockquote,{children:["\n",(0,a.jsx)(n.p,{children:"initDataStructures()"}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Code"})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-lua",children:"function FieldManager:initDataStructures()\n    self.fields = { }\n    self.farmlandIdFieldMapping = { }\n    self.currentFieldPartitionIndex = nil\n    self.nextCheckTime = 0\n    self.nextUpdateTime = 0\n    self.nextFieldCheckIndex = 0\n    self.updateTasks = { }\n    self.fieldNumUpdateTasks = { }\n    self.pendingFieldUpdatesMapping = { }\n    self.pendingFieldUpdates = { }\n\n    self.fieldStateUpdateIndex = 0\n    self.fieldsDoStateUpdate = { }\n\n    self.debugField = nil\nend\n\n"})}),"\n",(0,a.jsx)(n.h3,{id:"loadfromxmlfile",children:"loadFromXMLFile"}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Description"})}),"\n",(0,a.jsxs)(n.blockquote,{children:["\n",(0,a.jsx)(n.p,{children:"Load field savegame data"}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Definition"})}),"\n",(0,a.jsxs)(n.blockquote,{children:["\n",(0,a.jsx)(n.p,{children:"loadFromXMLFile(string xmlFilename)"}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n",(0,a.jsx)(n.table,{children:(0,a.jsx)(n.thead,{children:(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.th,{children:"string"}),(0,a.jsx)(n.th,{children:"xmlFilename"}),(0,a.jsx)(n.th,{children:"savegame xml file name"})]})})}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Code"})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-lua",children:'function FieldManager:loadFromXMLFile(xmlFilename)\n    local xmlFile = XMLFile.load( "fields" , xmlFilename, FieldManager.xmlSchemaSavegame)\n    if xmlFile = = nil then\n        return\n    end\n\n    for _, key in xmlFile:iterator( "fields.field" ) do\n        local fieldId = xmlFile:getInt(key .. "#id" )\n        if fieldId ~ = nil then\n            local field = self:getFieldById(fieldId)\n            if field ~ = nil then\n                field:loadFromXMLFile(xmlFile, key)\n            end\n        end\n    end\n\n    self.pendingFieldUpdates = { }\n    self.pendingFieldUpdatesMapping = { }\n    for _, key in xmlFile:iterator( "fields.pendingUpdate" ) do\n        local fieldId = xmlFile:getInt(key .. "#fieldId" )\n        if fieldId ~ = nil then\n            local field = self:getFieldById(fieldId)\n            if field ~ = nil then\n                table.insert( self.pendingFieldUpdates, field)\n                self.pendingFieldUpdatesMapping[field] = true\n            end\n        end\n    end\n\n    for _, key in xmlFile:iterator( "fields.task" ) do\n        local className = xmlFile:getString(key .. "#className" , "FieldUpdateTask" )\n        local class = ClassUtil.getClassObject(className)\n        if class ~ = nil then\n            local updateTask = class.new()\n            if updateTask:loadFromXMLFile(xmlFile, key) then\n                self:addFieldUpdateTask(updateTask)\n            end\n        end\n    end\n\n    xmlFile:delete()\nend\n\n'})}),"\n",(0,a.jsx)(n.h3,{id:"loadmapdata",children:"loadMapData"}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Description"})}),"\n",(0,a.jsxs)(n.blockquote,{children:["\n",(0,a.jsx)(n.p,{children:"Load data on map load"}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Definition"})}),"\n",(0,a.jsxs)(n.blockquote,{children:["\n",(0,a.jsx)(n.p,{children:"loadMapData(XMLFile xmlFile, , )"}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,a.jsxs)(n.table,{children:[(0,a.jsx)(n.thead,{children:(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.th,{children:"XMLFile"}),(0,a.jsx)(n.th,{children:"xmlFile"}),(0,a.jsx)(n.th,{children:"map xml file instance"})]})}),(0,a.jsxs)(n.tbody,{children:[(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:"any"}),(0,a.jsx)(n.td,{children:"missionInfo"}),(0,a.jsx)(n.td,{})]}),(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:"any"}),(0,a.jsx)(n.td,{children:"baseDirectory"}),(0,a.jsx)(n.td,{})]})]})]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Return Values"})}),"\n\n\n\n\n\n\n\n\n",(0,a.jsx)(n.table,{children:(0,a.jsx)(n.thead,{children:(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.th,{children:"any"}),(0,a.jsx)(n.th,{children:"true"}),(0,a.jsx)(n.th,{children:"if loading was successful else false"})]})})}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Code"})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-lua",children:'function FieldManager:loadMapData(xmlFile, missionInfo, baseDirectory)\n    FieldManager:superClass().loadMapData( self )\n\n    local mission = g_currentMission\n    self.mission = mission\n    mission:addUpdateable( self )\n\n    local fieldGroundSystem = mission.fieldGroundSystem\n    self.groundTypeSown = FieldGroundType.getValueByType(FieldGroundType.SOWN)\n    self.sprayTypeFertilizer = FieldSprayType.getValueByType(FieldSprayType.FERTILIZER)\n    self.sprayTypeLime = FieldSprayType.getValueByType(FieldSprayType.LIME)\n    self.sprayLevelMaxValue = fieldGroundSystem:getMaxValue(FieldDensityMap.SPRAY_LEVEL)\n    self.plowLevelMaxValue = Platform.gameplay.usePlowCounter and fieldGroundSystem:getMaxValue(FieldDensityMap.PLOW_LEVEL) or 0\n    self.limeLevelMaxValue = Platform.gameplay.useLimeCounter and fieldGroundSystem:getMaxValue(FieldDensityMap.LIME_LEVEL) or 0\n\n    -- create list of valid/available fruit types\n    self.availableFruitTypeIndices = { }\n    for _, fruitType in ipairs(g_fruitTypeManager:getFruitTypes()) do\n        if fruitType.useForFieldMissions and fruitType.allowsSeeding then\n            table.insert( self.availableFruitTypeIndices, fruitType.index)\n        end\n    end\n    self.fruitTypesCount = # self.availableFruitTypeIndices\n\n    self.fieldIndexToCheck = 1\n\n    local farmlandInfoLayer = g_farmlandManager:getLocalMap()\n    local modifier = DensityMapModifier.new(farmlandInfoLayer, 0 , g_farmlandManager.numberOfBits, g_terrainNode)\n    local filter = DensityMapFilter.new(modifier)\n\n    -- Connect farmlands to fields first.We need the farmlands to skip overriding owned fields(in order to have working starter fields)\n    for i, field in ipairs( self.fields) do\n        g_asyncTaskManager:addSubtask( function ()\n            local isValid = true\n            local posX, posZ = field:getCenterOfFieldWorldPosition()\n            local farmland = g_farmlandManager:getFarmlandAtWorldPosition(posX, posZ)\n            if farmland ~ = nil then\n                if self.farmlandIdFieldMapping[farmland.id] ~ = nil then\n                    Logging.error( "FieldManager - There already exists field \'%d\' on farmland \'%s\'" , i, farmland.id)\n                    isValid = false\n                end\n\n                filter:setValueCompareParams(DensityValueCompareType.NOTEQUAL, farmland.id)\n                modifier:clearPolygonPoints()\n\n                for _, point in ipairs(field:getPolygonPoints()) do\n                    local x, _, z = getWorldTranslation(point)\n                    modifier:addPolygonPointWorldCoords(x, z)\n                end\n\n                local _, numPixels, _ = modifier:executeGet(filter)\n\n                if numPixels > 0 then\n                    local numFarmlands = #g_farmlandManager:getFarmlands()\n                    for j = 0 , numFarmlands do\n                        if j ~ = farmland.id then\n                            filter:setValueCompareParams(DensityValueCompareType.EQUAL, j)\n                            local _, numPixelsI, _ = modifier:executeGet(filter)\n                            if numPixelsI > 0 then\n                                Logging.error( "FieldManager - Field \'%d\' with center on farmland \'%d\' touches farmland \'%d\' with \'%d\' pixels" , i, farmland.id, j, numPixelsI)\n                                isValid = false\n                            end\n                        end\n                    end\n                end\n            else\n                    Logging.error( "FieldManager - Failed to find farmland in center of field \'%s\' at %d %d" , i, posX, posZ)\n                    isValid = false\n                end\n\n                if isValid then\n                    field:setFarmland(farmland)\n                    farmland:setField(field)\n                    self.farmlandIdFieldMapping[farmland.id] = field\n                end\n            end , string.format( "FieldManager:loadMapData - Field \'%d\'" , i))\n        end\n\n        -- New save game\n        if not mission.missionInfo.isValid and g_server ~ = nil and not Profiler.IS_INITIALIZED then\n            local preplantedFields = { }\n\n            local filename = getXMLString(xmlFile, "map.fields#filename" )\n            if filename ~ = nil then\n                local xmlFilename = Utils.getFilename(filename, baseDirectory)\n                local fieldsXMLFile = XMLFile.load( "fieldsXML" , xmlFilename, FieldManager.xmlSchema)\n                if fieldsXMLFile ~ = nil then\n                    for _, fieldKey in fieldsXMLFile:iterator( "map.fields.field" ) do\n                        g_asyncTaskManager:addSubtask( function ()\n                            local fieldId = fieldsXMLFile:getValue(fieldKey .. "#fieldId" )\n                            local field = self:getFieldById(fieldId)\n                            if field ~ = nil then\n                                local className = fieldsXMLFile:getString(fieldKey .. "#className" , "FieldUpdateTask" )\n                                local class = ClassUtil.getClassObject(className)\n                                if class ~ = nil then\n                                    local updateTask = class.new()\n                                    if updateTask:loadFromXMLFile(fieldsXMLFile, fieldKey) then\n                                        self:addFieldUpdateTask(updateTask)\n                                        preplantedFields[field] = true\n                                    end\n                                end\n                            end\n                        end )\n                    end\n\n                    g_asyncTaskManager:addSubtask( function ()\n                        fieldsXMLFile:delete()\n                    end )\n                end\n            end\n\n            for _, field in pairs( self.fields) do\n                g_asyncTaskManager:addSubtask( function ()\n                    if not field:getHasOwner() and field.isMissionAllowed and preplantedFields[field] = = nil then\n                        -- Plan a random fruit for the NPC\n                            local fruitIndex = table.getRandomElement( self.availableFruitTypeIndices)\n                            if field.grassMissionOnly then\n                                fruitIndex = FruitType.GRASS\n                            end\n\n                            local fruitTypeDesc = g_fruitTypeManager:getFruitTypeByIndex(fruitIndex)\n                            if fruitTypeDesc = = nil then\n                                return\n                            end\n\n                            local growthState = fruitTypeDesc:getRandomInitialState(g_currentMission.missionInfo.growthMode)\n                            local weedState = 0\n                            local stoneLevel = 0\n                            local groundType = FieldGroundType.SOWN\n                            local groundAngle = field:getAngle()\n                            local sprayType = FieldSprayType.NONE\n                            local sprayLevel = math.random( 0 , self.sprayLevelMaxValue)\n                            local plowLevel = math.random( 0 , self.plowLevelMaxValue)\n                            local limeLevel = math.random( 0 , self.limeLevelMaxValue)\n\n                            if growthState ~ = nil then\n                                if fruitTypeDesc.plantsWeed then\n                                    -- Add some randomness:older plants have higher chance of older weeds\n                                    if growthState > 4 then\n                                        weedState = math.random( 3 , 9 )\n                                    else\n                                            weedState = math.random( 1 , 7 )\n                                        end\n                                    end\n\n                                    groundType = fruitTypeDesc:getGrowthStateGroundType(growthState) or groundType\n                                else\n                                        fruitIndex = nil\n\n                                        groundType = math.random() < 0.5 and FieldGroundType.CULTIVATED or FieldGroundType.PLOWED\n                                        if groundType = = FieldGroundType.PLOWED then\n                                            plowLevel = self.plowLevelMaxValue\n                                        end\n\n                                        if sprayLevel > 0 then\n                                            sprayType = math.random() < 0.7 and FieldSprayType.LIQUID_MANURE or FieldSprayType.MANURE\n                                        end\n                                        if limeLevel > 0 and math.random() < 0.1 then\n                                            sprayType = FieldSprayType.LIME\n                                        end\n                                    end\n\n                                    if not mission.missionInfo.plowingRequiredEnabled then\n                                        plowLevel = self.plowLevelMaxValue\n                                    end\n\n                                    local task = FieldUpdateTask.new()\n                                    task:setField(field)\n                                    task:setFruit(fruitIndex, growthState)\n                                    task:setWeedState(weedState)\n                                    task:setStoneLevel(stoneLevel)\n                                    task:setGroundType(groundType)\n                                    task:setGroundAngle(groundAngle)\n                                    task:setSprayType(sprayType)\n                                    task:setSprayLevel(sprayLevel)\n                                    task:setLimeLevel(limeLevel)\n                                    task:setPlowLevel(plowLevel)\n                                    task:clearHeight()\n\n                                    self:addFieldUpdateTask(task)\n                                end\n                            end )\n                        end\n                    end\n\n                    g_asyncTaskManager:addSubtask( function ()\n                        if mission:getIsServer() then\n                            if g_addCheatCommands then\n                                addConsoleCommand( "gsFieldSetState" , "Opens UI to set state for specific field(s)" , "consoleCommandSetFieldState" , self , "[fieldId]; [fruitName]; [growthState]" )\n                                    addConsoleCommand( "gsFieldSetGround" , "Opens UI to set state for specific field(s)" , "consoleCommandSetFieldGround" , self , "[fieldId]; [groundTypeName]; [angle]; [groundLayer]; [fertilizerState]; [plowingState]; [weedState]; [limeState]; [stubbleState]; [buyField]; [removeFoliage]" )\n                                    end\n                                end\n\n                                if g_addCheatCommands then\n                                    addConsoleCommand( "gsFieldToggleStatus" , "Shows field status" , "consoleCommandToggleDebugFieldStatus" , self )\n                                    addConsoleCommand( "gsFieldToggleNPCLogging" , "Toggle field npc action logging" , "consoleCommandToggleDebugFieldNPCLogging" , self )\n                                end\n                            end )\n\n                            -- On clients, force all fields to have some value so map at least shows them\n                            g_asyncTaskManager:addSubtask( function ()\n                                if not mission:getIsServer() then\n                                    for _, field in pairs( self.fields) do\n                                        local task = FieldUpdateTask.new()\n                                        task:setField(field)\n                                        task:setGroundType(FieldGroundType.CULTIVATED)\n                                        task:setGroundAngle(field:getAngle())\n                                        self:addFieldUpdateTask(task)\n                                    end\n                                end\n\n                                -- run pending update tasks\n                                while true do\n                                    local task = table.remove( self.updateTasks, 1 )\n                                    if task = = nil then\n                                        break\n                                    end\n\n                                    g_asyncTaskManager:addSubtask( function ()\n                                        task:start()\n                                        while not task:getIsFinished() do\n                                            task:update( 1 )\n                                        end\n                                        self:onFinishFieldUpdateTask(task)\n                                    end )\n                                end\n                            end )\n\n                            g_messageCenter:subscribe(MessageType.FINISHED_GROWTH_PERIOD, self.onFinishedGrowthPeriod, self )\n                            g_messageCenter:subscribe(MessageType.MISSION_GENERATION_START, self.onMissionGenerationStart, self )\n                            g_messageCenter:subscribe(MessageType.MISSION_GENERATION_END, self.onMissionGenerationEnd, self )\n\n                            local cellsize = 0.5 --g_currentMission.terrainSize / self.defaultMissionMapWidth\n                            self.debugBitVectorMap = DebugBitVectorMap.newSimple( 5 , cellsize, false , 0.1 )\n                            local fieldState = FieldState.new()\n                            local textColor = Color.new( 1 , 1 , 1 , 0.7 )\n                            self.debugBitVectorMap:createWithCustomFunc( function (instance, startWorldX, startWorldZ, widthWorldX, widthWorldZ, heightWorldX, heightWorldZ)\n                                local centerX = (startWorldX + widthWorldX) * 0.5 --(startWorldX + widthWorldX + heightWorldX) / 3\n                                local centerZ = (startWorldZ + heightWorldZ) * 0.5 --(startWorldZ + widthWorldZ + heightWorldZ) / 3\n\n                                fieldState:update(centerX, centerZ)\n\n                                if fieldState.groundType = = 0 then\n                                    return 0\n                                end\n\n                                local y = getTerrainHeightAtWorldPos(g_terrainNode, centerX, 0 , centerZ)\n                                fieldState:drawDebugAtWorldPosition(centerX, y, centerZ, 0.008 , textColor)\n\n                                return 1\n                            end )\n                            self.debugBitVectorMap.getShouldBeDrawn = function ()\n                                return FieldManager.DEBUG_SHOW_FIELDSTATUS\n                            end\n                            g_debugManager:addElement( self.debugBitVectorMap)\n                        end\n\n'})}),"\n",(0,a.jsx)(n.h3,{id:"new",children:"new"}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Description"})}),"\n",(0,a.jsxs)(n.blockquote,{children:["\n",(0,a.jsx)(n.p,{children:"Creating manager"}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Definition"})}),"\n",(0,a.jsxs)(n.blockquote,{children:["\n",(0,a.jsx)(n.p,{children:"new(table customMt)"}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n",(0,a.jsx)(n.table,{children:(0,a.jsx)(n.thead,{children:(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.th,{children:"table"}),(0,a.jsx)(n.th,{children:"customMt"}),(0,a.jsx)(n.th,{children:"custom metatable"})]})})}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Return Values"})}),"\n\n\n\n\n\n\n\n\n",(0,a.jsx)(n.table,{children:(0,a.jsx)(n.thead,{children:(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.th,{children:"table"}),(0,a.jsx)(n.th,{children:"instance"}),(0,a.jsx)(n.th,{children:"of the field manager"})]})})}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Code"})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-lua",children:"function FieldManager.new(customMt)\n    local self = AbstractManager.new(customMt or FieldManager _mt)\n\n    return self\nend\n\n"})}),"\n",(0,a.jsx)(n.h3,{id:"savetoxmlfile",children:"saveToXMLFile"}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Description"})}),"\n",(0,a.jsxs)(n.blockquote,{children:["\n",(0,a.jsx)(n.p,{children:"Write field data"}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Definition"})}),"\n",(0,a.jsxs)(n.blockquote,{children:["\n",(0,a.jsx)(n.p,{children:"saveToXMLFile(string xmlFilename)"}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n",(0,a.jsx)(n.table,{children:(0,a.jsx)(n.thead,{children:(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.th,{children:"string"}),(0,a.jsx)(n.th,{children:"xmlFilename"}),(0,a.jsx)(n.th,{children:"file path"})]})})}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Code"})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-lua",children:'function FieldManager:saveToXMLFile(xmlFilename)\n    local xmlFile = XMLFile.create( "fields" , xmlFilename, "fields" , FieldManager.xmlSchemaSavegame)\n\n    for k, field in ipairs( self.fields) do\n        local key = string.format( "fields.field(%d)" , k - 1 )\n        local id = field:getId()\n        if id ~ = nil then\n            xmlFile:setInt(key .. "#id" , field:getId())\n            field:saveToXMLFile(xmlFile, key)\n        end\n    end\n\n    if self.pendingFieldUpdates ~ = nil then\n        for k, field in ipairs( self.pendingFieldUpdates) do\n            local id = field:getId()\n            if id ~ = nil then\n                local key = string.format( "fields.pendingUpdate(%d)" , k - 1 )\n                xmlFile:setInt(key .. "#fieldId" , id)\n            end\n        end\n    end\n\n    for k, updateTask in ipairs( self.updateTasks) do\n        local needsSaving = updateTask.needsSaving\n        if needsSaving or needsSaving = = nil then\n            local key = string.format( "fields.task(%d)" , k - 1 )\n            xmlFile:setString(key .. "#className" , ClassUtil.getClassNameByObject(updateTask))\n            updateTask:saveToXMLFile(xmlFile, key)\n        end\n    end\n\n    xmlFile:save()\n    xmlFile:delete()\nend\n\n'})}),"\n",(0,a.jsx)(n.h3,{id:"unloadmapdata",children:"unloadMapData"}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Description"})}),"\n",(0,a.jsxs)(n.blockquote,{children:["\n",(0,a.jsx)(n.p,{children:"Unload data on mission delete"}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Definition"})}),"\n",(0,a.jsxs)(n.blockquote,{children:["\n",(0,a.jsx)(n.p,{children:"unloadMapData()"}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Code"})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-lua",children:'function FieldManager:unloadMapData()\n    if self.mission ~ = nil then\n        self.mission:removeUpdateable( self )\n    end\n\n    for _, field in pairs( self.fields) do\n        field:delete()\n    end\n    self.fields = { }\n    self.fieldsToCheck = nil\n    self.fieldsToUpdate = nil\n\n    self.fieldGroundSystem = nil\n    self.mission = nil\n\n    g_messageCenter:unsubscribeAll( self )\n\n    removeConsoleCommand( "gsFieldSetState" )\n    removeConsoleCommand( "gsFieldSetGround" )\n    removeConsoleCommand( "gsFieldToggleStatus" )\n    removeConsoleCommand( "gsFieldToggleNPCLogging" )\n\n    FieldManager:superClass().unloadMapData( self )\nend\n\n'})})]})}function f(e={}){const{wrapper:n}={...(0,d.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(c,{...e})}):c(e)}},28453(e,n,l){l.d(n,{R:()=>s,x:()=>t});var i=l(96540);const a={},d=i.createContext(a);function s(e){const n=i.useContext(d);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function t(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:s(e.components),i.createElement(d.Provider,{value:n},e.children)}}}]);