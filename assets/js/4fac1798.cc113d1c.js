"use strict";(globalThis.webpackChunkfs25_community_luadoc=globalThis.webpackChunkfs25_community_luadoc||[]).push([[42190],{28453(e,n,s){s.d(n,{R:()=>r,x:()=>a});var l=s(96540);const t={},i=l.createContext(t);function r(e){const n=l.useContext(i);return l.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:r(e.components),l.createElement(i.Provider,{value:n},e.children)}},89338(e,n,s){s.r(n),s.d(n,{assets:()=>d,contentTitle:()=>a,default:()=>h,frontMatter:()=>r,metadata:()=>l,toc:()=>o});const l=JSON.parse('{"id":"script/Wheels/WheelPhysics","title":"WheelPhysics","description":"WheelPhysics","source":"@site/../docs/script/Wheels/WheelPhysics.md","sourceDirName":"script/Wheels","slug":"/script/Wheels/WheelPhysics","permalink":"/FS25-Community-LUADOC/script/Wheels/WheelPhysics","draft":false,"unlisted":false,"tags":[],"version":"current","lastUpdatedAt":1767161192000,"frontMatter":{},"sidebar":"docsSidebar","previous":{"title":"WheelManager","permalink":"/FS25-Community-LUADOC/script/Wheels/WheelManager"},"next":{"title":"WheelSteering","permalink":"/FS25-Community-LUADOC/script/Wheels/WheelSteering"}}');var t=s(74848),i=s(28453);const r={},a=void 0,d={},o=[{value:"WheelPhysics",id:"wheelphysics",level:2},{value:"addToPhysics",id:"addtophysics",level:3},{value:"clientUpdate",id:"clientupdate",level:3},{value:"finalize",id:"finalize",level:3},{value:"getGroundAttributes",id:"getgroundattributes",level:3},{value:"getIsOnField",id:"getisonfield",level:3},{value:"getSurfaceSoundAttributes",id:"getsurfacesoundattributes",level:3},{value:"getTireLoad",id:"gettireload",level:3},{value:"getVisualInfo",id:"getvisualinfo",level:3},{value:"loadAdditionalWheel",id:"loadadditionalwheel",level:3},{value:"loadFromXML",id:"loadfromxml",level:3},{value:"new",id:"new",level:3},{value:"postLoad",id:"postload",level:3},{value:"postUpdate",id:"postupdate",level:3},{value:"readStream",id:"readstream",level:3},{value:"registerAdditionalWheelXMLPaths",id:"registeradditionalwheelxmlpaths",level:3},{value:"registerXMLPaths",id:"registerxmlpaths",level:3},{value:"removeFromPhysics",id:"removefromphysics",level:3},{value:"serverUpdate",id:"serverupdate",level:3},{value:"setDisplacementAllowed",id:"setdisplacementallowed",level:3},{value:"setDisplacementCollisionEnabled",id:"setdisplacementcollisionenabled",level:3},{value:"setSteeringValues",id:"setsteeringvalues",level:3},{value:"setSuspensionMultipliers",id:"setsuspensionmultipliers",level:3},{value:"setTorqueDirection",id:"settorquedirection",level:3},{value:"setWheelShapeWidth",id:"setwheelshapewidth",level:3},{value:"updateBase",id:"updatebase",level:3},{value:"updateContact",id:"updatecontact",level:3},{value:"updateContactClient",id:"updatecontactclient",level:3},{value:"updateFriction",id:"updatefriction",level:3},{value:"updateInterpolation",id:"updateinterpolation",level:3},{value:"updateNetInfo",id:"updatenetinfo",level:3},{value:"updatePhysics",id:"updatephysics",level:3},{value:"updateShapePosition",id:"updateshapeposition",level:3},{value:"updateSink",id:"updatesink",level:3},{value:"updateSteeringAngle",id:"updatesteeringangle",level:3},{value:"updateTick",id:"updatetick",level:3},{value:"updateTireFriction",id:"updatetirefriction",level:3},{value:"updateXDriveSpeed",id:"updatexdrivespeed",level:3},{value:"waterRaycastCallback",id:"waterraycastcallback",level:3},{value:"writeStream",id:"writestream",level:3}];function c(e){const n={a:"a",blockquote:"blockquote",code:"code",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,i.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.h2,{id:"wheelphysics",children:"WheelPhysics"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Description"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"Stores physics data and functions to update the physic wheel"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Functions"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#addtophysics",children:"addToPhysics"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#clientupdate",children:"clientUpdate"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#finalize",children:"finalize"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#getgroundattributes",children:"getGroundAttributes"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#getisonfield",children:"getIsOnField"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#getsurfacesoundattributes",children:"getSurfaceSoundAttributes"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#gettireload",children:"getTireLoad"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#getvisualinfo",children:"getVisualInfo"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#loadadditionalwheel",children:"loadAdditionalWheel"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#loadfromxml",children:"loadFromXML"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#new",children:"new"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#postload",children:"postLoad"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#postupdate",children:"postUpdate"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#readstream",children:"readStream"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#registeradditionalwheelxmlpaths",children:"registerAdditionalWheelXMLPaths"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#registerxmlpaths",children:"registerXMLPaths"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#removefromphysics",children:"removeFromPhysics"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#serverupdate",children:"serverUpdate"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#setdisplacementallowed",children:"setDisplacementAllowed"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#setdisplacementcollisionenabled",children:"setDisplacementCollisionEnabled"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#setsteeringvalues",children:"setSteeringValues"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#setsuspensionmultipliers",children:"setSuspensionMultipliers"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#settorquedirection",children:"setTorqueDirection"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#setwheelshapewidth",children:"setWheelShapeWidth"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#updatebase",children:"updateBase"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#updatecontact",children:"updateContact"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#updatecontactclient",children:"updateContactClient"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#updatefriction",children:"updateFriction"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#updateinterpolation",children:"updateInterpolation"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#updatenetinfo",children:"updateNetInfo"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#updatephysics",children:"updatePhysics"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#updateshapeposition",children:"updateShapePosition"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#updatesink",children:"updateSink"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#updatesteeringangle",children:"updateSteeringAngle"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#updatetick",children:"updateTick"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#updatetirefriction",children:"updateTireFriction"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#updatexdrivespeed",children:"updateXDriveSpeed"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#waterraycastcallback",children:"waterRaycastCallback"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#writestream",children:"writeStream"})}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"addtophysics",children:"addToPhysics"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Description"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Definition"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"addToPhysics()"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,t.jsx)(n.table,{children:(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"any"}),(0,t.jsx)(n.th,{children:"brakeForce"})]})})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Code"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:"function WheelPhysics:addToPhysics(brakeForce)\n    self.netInfo.xDriveLastRaw = 0\n    self.updateWheel = false\n\n    self:updateBase()\n    self:updateTireFriction()\n\n    self:updatePhysics(brakeForce, 0 )\nend\n\n"})}),"\n",(0,t.jsx)(n.h3,{id:"clientupdate",children:"clientUpdate"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Description"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Definition"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"clientUpdate()"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"any"}),(0,t.jsx)(n.th,{children:"dt"})]})}),(0,t.jsxs)(n.tbody,{children:[(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"any"}),(0,t.jsx)(n.td,{children:"currentUpdateIndex"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"any"}),(0,t.jsx)(n.td,{children:"groundWetness"})]})]})]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Code"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:"function WheelPhysics:clientUpdate(dt, currentUpdateIndex, groundWetness)\n    if self.vehicle.isActive then\n        if currentUpdateIndex = = self.wheel.updateIndex then\n            self:updateContactClient()\n        end\n    end\nend\n\n"})}),"\n",(0,t.jsx)(n.h3,{id:"finalize",children:"finalize"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Description"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Definition"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"finalize()"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Code"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:"function WheelPhysics:finalize()\n    local positionY = self.positionY + self.deltaY\n    self.netInfo = { }\n    self.netInfo.xDrive = 0\n    self.netInfo.xDriveDiff = 0 -- radian per ms\n    self.netInfo.xDriveSpeed = 0 -- radian per second\n    self.netInfo.xDriveLastRaw = 0\n    self.netInfo.x = self.positionX\n    self.netInfo.y = positionY\n    self.netInfo.z = self.positionZ\n    self.netInfo.suspensionLength = self.deltaY\n\n    self.netInfo.lastSpeedSmoothed = 0 -- wheel speed in m/sec\n    self.netInfo.slip = 0 -- wheel slip(0 = no slip, 1 = full slip)\n\n    -- The suspension elongates by 20% of the specified susp travel\n    self.netInfo.sync = { yMin = - 5 , yRange = 10 }\n    self.netInfo.yMin = positionY - 1.2 * self.suspTravel\n\n    local vehicleNode = self.vehicle.vehicleNodes[ self.wheel.node]\n    if vehicleNode ~ = nil and vehicleNode.component ~ = nil and vehicleNode.component.motorized = = nil then\n        vehicleNode.component.motorized = true\n    end\n\n    local additionalMass = self.wheel:getMass() - self.baseMass\n    self.restLoad = self.restLoad + additionalMass\n\n    self.maxLatStiffness = self.maxLatStiffness * self.restLoad\n    self.maxLatStiffnessLoad = self.maxLatStiffnessLoad * self.restLoad\n\n    self.networkInterpolators = { }\n    self.networkInterpolators.xDriveDiff = InterpolatorValue.new( 0 )\n    self.networkInterpolators.position = InterpolatorPosition.new( self.netInfo.x, self.netInfo.y, self.netInfo.z)\n    self.networkInterpolators.suspensionLength = InterpolatorValue.new( self.netInfo.suspensionLength)\nend\n\n"})}),"\n",(0,t.jsx)(n.h3,{id:"getgroundattributes",children:"getGroundAttributes"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Description"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Definition"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"getGroundAttributes()"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Code"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:"function WheelPhysics:getGroundAttributes()\n    return self.trackColor[ 1 ], self.trackColor[ 2 ], self.trackColor[ 3 ], self.groundDepth, self.lastTerrainAttribute, math.max( self.trackAlpha, self.dirtAmount), self.colorBlendWithTerrain\nend\n\n"})}),"\n",(0,t.jsx)(n.h3,{id:"getisonfield",children:"getIsOnField"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Description"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Definition"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"getIsOnField()"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Code"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:"function WheelPhysics:getIsOnField()\n    local isOnField = self.hasSnowContact\n    if self.densityType ~ = FieldGroundType.NONE and self.densityType ~ = FieldGroundType.GRASS and self.densityType ~ = FieldGroundType.GRASS_CUT then\n        isOnField = true\n    end\n\n    return isOnField\nend\n\n"})}),"\n",(0,t.jsx)(n.h3,{id:"getsurfacesoundattributes",children:"getSurfaceSoundAttributes"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Description"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Definition"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"getSurfaceSoundAttributes()"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Code"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:'function WheelPhysics:getSurfaceSoundAttributes()\n    if self.contact = = WheelContactType.GROUND then\n        if self.hasWaterContact then\n            return "shallowWater" , nil\n        elseif self.densityType ~ = FieldGroundType.NONE then\n                return "field" , nil\n            else\n                    return nil , self.lastTerrainAttribute\n                end\n            elseif self.contact = = WheelContactType.GROUND_HEIGHT then\n                    if self.hasSnowContact then\n                        return "snow" , nil\n                    end\n                elseif self.contact = = WheelContactType.OBJECT then\n                        return "asphalt" , nil\n                    end\n\n                    return nil , nil\n                end\n\n'})}),"\n",(0,t.jsx)(n.h3,{id:"gettireload",children:"getTireLoad"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Description"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Definition"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"getTireLoad()"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Code"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:"function WheelPhysics:getTireLoad()\n    if self.wheelShapeCreated then\n        local gravity = 9.81\n\n        local tireLoad = getWheelShapeContactForce( self.wheel.node, self.wheelShape)\n        if tireLoad ~ = nil then\n            local nx, ny, nz = getWheelShapeContactNormal( self.wheel.node, self.wheelShape)\n            local dx, dy, dz = localDirectionToWorld( self.wheel.node, self.directionX, self.directionY, self.directionZ)\n            tireLoad = - tireLoad * MathUtil.dotProduct(dx, dy, dz, nx, ny, nz)\n\n            return(tireLoad + math.max(ny * gravity, 0.0 ) * self.wheel:getMass()) / gravity\n        end\n    end\n\n    return 0\nend\n\n"})}),"\n",(0,t.jsx)(n.h3,{id:"getvisualinfo",children:"getVisualInfo"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Description"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Definition"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"getVisualInfo()"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Code"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:"function WheelPhysics:getVisualInfo()\n    local steeringAngle = 0\n    if self.showSteeringAngle ~ = false then\n        steeringAngle = self.steeringAngle * self.steeringAngleFactorInv\n    end\n\n    return self.netInfo.x, self.netInfo.y, self.netInfo.z, self.netInfo.xDrive, self.netInfo.suspensionLength - self.deltaYOriginal, steeringAngle\nend\n\n"})}),"\n",(0,t.jsx)(n.h3,{id:"loadadditionalwheel",children:"loadAdditionalWheel"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Description"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Definition"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"loadAdditionalWheel()"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,t.jsx)(n.table,{children:(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"any"}),(0,t.jsx)(n.th,{children:"xmlObject"})]})})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Code"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:'function WheelPhysics:loadAdditionalWheel(xmlObject)\n    self.mass = self.mass + xmlObject:getValue( ".physics#mass" , 0 )\n\n    self.maxLatStiffness = self.maxLatStiffness + xmlObject:getValue( ".physics#maxLatStiffness" , 0 )\n    self.maxLongStiffness = self.maxLongStiffness + xmlObject:getValue( ".physics#maxLongStiffness" , 0 )\nend\n\n'})}),"\n",(0,t.jsx)(n.h3,{id:"loadfromxml",children:"loadFromXML"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Description"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Definition"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"loadFromXML()"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,t.jsx)(n.table,{children:(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"any"}),(0,t.jsx)(n.th,{children:"xmlObject"})]})})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Code"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:'function WheelPhysics:loadFromXML(xmlObject)\n    self.radius = xmlObject:getValue( ".physics#radius" )\n    if self.radius = = nil then\n        xmlObject:xmlWarning( ".physics#radius" , "No radius defined for wheel! Using default value of 0.5!" )\n            self.radius = 0.5\n        end\n        self.radiusOriginal = self.radius\n\n        self.width = xmlObject:getValue( ".physics#width" )\n        if self.width = = nil then\n            xmlObject:xmlWarning( ".physics#width" , "No width defined for wheel! Using default value of 0.5!" )\n                self.width = 0.5\n            end\n\n            self.wheelShapeWidth = self.width\n            self.wheelShapeWidthOffset = 0\n\n            self.mass = xmlObject:getValue( ".physics#mass" , 0.1 )\n            self.baseMass = self.mass\n\n            self.restLoad = xmlObject:getValue( ".physics#restLoad" , 1 ) -- [t]\n            self.frictionScale = xmlObject:getValue( ".physics#frictionScale" , 1 )\n            if self.frictionScale < = 0 then\n                self.frictionScale = 0.01\n                xmlObject:xmlWarning( ".physics#frictionScale" , "Wheel \'frictionScale\' set to \'0\'.This is not allowed!" )\n            end\n\n            self.maxLongStiffness = xmlObject:getValue( ".physics#maxLongStiffness" , 30 ) -- [t / rad]\n            self.maxLatStiffness = xmlObject:getValue( ".physics#maxLatStiffness" , 40 ) -- xml is ratio to restLoad [1/rad], final value is [t / rad]\n            self.maxLatStiffnessLoad = xmlObject:getValue( ".physics#maxLatStiffnessLoad" , 2 ) -- xml is ratio to restLoad, final value is [t]\n\n            self.xOffset = xmlObject:getValue( ".physics#xOffset" , 0.0 )\n            self.yOffset = xmlObject:getValue( ".physics#yOffset" , 0.0 )\n            self.zOffset = xmlObject:getValue( ".physics#zOffset" , 0.0 )\n            self.useReprOffset = xmlObject:getValue( ".physics#useReprOffset" , false )\n            if self.xOffset ~ = 0 or self.yOffset ~ = 0 or self.zOffset ~ = 0 then\n                -- move drivenode in y direction.Use convert yOffset from driveNode local space to driveNodeParent local space to translate according to directions\n                if self.useReprOffset then\n                    setTranslation( self.wheel.repr, localToLocal( self.wheel.repr, getParent( self.wheel.repr), self.wheel.isLeft and self.xOffset or - self.xOffset, self.yOffset, self.zOffset))\n                else\n                        setTranslation( self.wheel.driveNode, localToLocal( self.wheel.driveNode, getParent( self.wheel.driveNode), self.wheel.isLeft and self.xOffset or - self.xOffset, self.yOffset, self.zOffset))\n                    end\n                end\n\n                self.showSteeringAngle = xmlObject:getValue( ".physics#showSteeringAngle" )\n                self.steeringAngleFactor = xmlObject:getValue( ".physics#steeringAngleFactor" , self.steeringAngleFactor or 1 )\n                self.steeringAngleFactorInv = 1 / self.steeringAngleFactor\n                self.suspTravel = xmlObject:getValue( ".physics#suspTravel" , 0.01 )\n                local initialCompression = xmlObject:getValue( ".physics#initialCompression" )\n                if initialCompression ~ = nil then\n                    self.deltaY = ( 1 - initialCompression * 0.01 ) * self.suspTravel\n                else\n                        self.deltaY = xmlObject:getValue( ".physics#deltaY" , 0.0 )\n                    end\n                    self.deltaYOriginal = self.deltaY\n                    self.spring = xmlObject:getValue( ".physics#spring" , 0 ) * Vehicle.SPRING_SCALE\n\n                    self.brakeFactor = xmlObject:getValue( ".physics#brakeFactor" , 1 )\n                    self.autoHoldBrakeFactor = xmlObject:getValue( ".physics#autoHoldBrakeFactor" , self.brakeFactor)\n\n                    self.dampingMultiplier = 1\n                    self.springMultiplier = 1\n\n                    self.damperCompressionLowSpeed = xmlObject:getValue( ".physics#damperCompressionLowSpeed" )\n                    self.damperRelaxationLowSpeed = xmlObject:getValue( ".physics#damperRelaxationLowSpeed" )\n                    if self.damperRelaxationLowSpeed = = nil then\n                        self.damperRelaxationLowSpeed = xmlObject:getValue( ".physics#damper" , self.damperCompressionLowSpeed or 0 )\n                    end\n                    -- by default, the high speed relaxation damper is set to 90% of the low speed relaxation damper\n                    self.damperRelaxationHighSpeed = xmlObject:getValue( ".physics#damperRelaxationHighSpeed" , self.damperRelaxationLowSpeed * 0.7 )\n\n                    -- by default, we set the low speed compression damper to 90% of the low speed relaxation damper\n                    if self.damperCompressionLowSpeed = = nil then\n                        self.damperCompressionLowSpeed = self.damperRelaxationLowSpeed * 0.9\n                    end\n                    -- by default, the high speed compression damper is set to 20% of the low speed compression damper\n                    self.damperCompressionHighSpeed = xmlObject:getValue( ".physics#damperCompressionHighSpeed" , self.damperCompressionLowSpeed * 0.2 )\n                    self.damperCompressionLowSpeedThreshold = xmlObject:getValue( ".physics#damperCompressionLowSpeedThreshold" , 0.1016 ) -- default 4 inch / s\n                    self.damperRelaxationLowSpeedThreshold = xmlObject:getValue( ".physics#damperRelaxationLowSpeedThreshold" , 0.1524 ) -- default 6 inch / s\n\n                    self.forcePointRatio = xmlObject:getValue( ".physics#forcePointRatio" , 0 )\n                    if self.forcePointRatio < 0 or self.forcePointRatio > 1 then\n                        xmlObject:xmlWarning( ".physics#forcePointRatio" , "Invalid value for \'forcePointRatio\'.Must be between 0 and 1.Defaulting to 0!" )\n                            self.forcePointRatio = 0\n                        end\n\n                        self.driveMode = xmlObject:getValue( ".physics#driveMode" , 0 )\n\n                        self.isSynchronized = xmlObject:getValue( ".physics#isSynchronized" , true )\n                        self.tipOcclusionAreaGroupId = xmlObject:getValue( ".physics#tipOcclusionAreaGroupId" )\n\n                        self.useReprDirection = xmlObject:getValue( ".physics#useReprDirection" , false )\n                        self.useDriveNodeDirection = xmlObject:getValue( ".physics#useDriveNodeDirection" , false )\n\n                        self.rotationDamping = xmlObject:getValue( ".physics#rotationDamping" , self.mass * 0.035 )\n\n                        local tireTypeName = xmlObject:getValue( ".physics#tireType" , "mud" )\n                        self.tireType = WheelsUtil.getTireType(tireTypeName)\n                        if self.tireType = = nil then\n                            xmlObject:xmlWarning( ".physics#tireType" , "Failed to find tire type \'%s\'.Defaulting to \'mud\'!" , tireTypeName)\n                            self.tireType = WheelsUtil.getTireType( "mud" )\n                        end\n\n                        self.fieldDirtMultiplier = xmlObject:getValue( ".physics#fieldDirtMultiplier" , 75 )\n                        self.streetDirtMultiplier = xmlObject:getValue( ".physics#streetDirtMultiplier" , - 150 )\n                        self.waterWetnessFactor = xmlObject:getValue( ".physics#waterWetnessFactor" , 20 )\n                        self.minDirtPercentage = xmlObject:getValue( ".physics#minDirtPercentage" , 0.35 )\n                        self.maxDirtOffset = xmlObject:getValue( ".physics#maxDirtOffset" , 0.5 )\n                        self.dirtColorChangeSpeed = 1 / (xmlObject:getValue( ".physics#dirtColorChangeSpeed" , 20 ) * 1000 )\n\n                        self.versatileYRot = xmlObject:getValue( ".physics#versatileYRot" , false )\n                        self.forceVersatility = xmlObject:getValue( ".physics#forceVersatility" , false )\n                        self.supportsWheelSink = xmlObject:getValue( ".physics#supportsWheelSink" , true ) and self.vehicle.isServer\n\n                        -- old wheel sink attribute from fs22 define if the wheel deforms the displacement or not\n                            if not Platform.gameplay.wheelTerrainDisplacement or not self.supportsWheelSink then\n                                self.collisionMask = bit32.band( WheelPhysics.COLLISION_MASK, bit32.bnot(CollisionFlag.TERRAIN_DISPLACEMENT)) -- remove TERRAIN_DISPLACEMENT from mask\n                            end\n\n                            self.extraSinkSupported = xmlObject:getValue( ".physics.extraSink#supported" , false )\n                            self.extraSinkMaxValue = xmlObject:getValue( ".physics.extraSink#maxValue" , self.radius * 0.2 )\n\n                            self.rotSpeed = xmlObject:getValue( ".physics#rotSpeed" , 0 )\n                            self.rotSpeedNeg = xmlObject:getValue( ".physics#rotSpeedNeg" , 0 )\n                            self.rotMax = xmlObject:getValue( ".physics#rotMax" , 0 )\n                            self.rotMin = xmlObject:getValue( ".physics#rotMin" , 0 )\n\n                            self.invertRotLimit = xmlObject:getValue( ".physics#invertRotLimit" , false )\n                            self.rotSpeedLimit = xmlObject:getValue( ".physics#rotSpeedLimit" )\n\n                            local maxInnerSpacing = xmlObject:getValue( ".physics#maxInnerSpacing" )\n                            if maxInnerSpacing ~ = nil then\n                                local offset = ( self.width * 0.5 ) - maxInnerSpacing\n                                if offset > 0 then\n                                    local x, y, z = localToLocal( self.wheel.driveNode, getParent( self.wheel.driveNode), self.wheel.isLeft and offset or - offset, 0 , 0 )\n                                    setTranslation( self.wheel.driveNode, x, y, z)\n                                end\n                            end\n\n                            self.positionX, self.positionY, self.positionZ = localToLocal( self.wheel.driveNode, self.wheel.node, 0 , 0 , 0 )\n\n                            if self.useReprDirection then\n                                self.directionX, self.directionY, self.directionZ = localDirectionToLocal( self.wheel.repr, self.wheel.node, 0 , - 1 , 0 )\n                                self.axleX, self.axleY, self.axleZ = localDirectionToLocal( self.wheel.repr, self.wheel.node, 1 , 0 , 0 )\n                            elseif self.useDriveNodeDirection then\n                                    self.directionX, self.directionY, self.directionZ = localDirectionToLocal( self.wheel.driveNodeDirectionNode, self.wheel.node, 0 , - 1 , 0 )\n                                    self.axleX, self.axleY, self.axleZ = localDirectionToLocal( self.wheel.driveNodeDirectionNode, self.wheel.node, 1 , 0 , 0 )\n                                else\n                                        self.directionX, self.directionY, self.directionZ = 0 , - 1 , 0\n                                        self.axleX, self.axleY, self.axleZ = 1 , 0 , 0\n                                    end\n\n                                    self.steeringCenterOffsetX, self.steeringCenterOffsetY, self.steeringCenterOffsetZ = 0 , 0 , 0\n                                    if self.wheel.repr ~ = self.wheel.driveNode then\n                                        self.steeringCenterOffsetX, self.steeringCenterOffsetY, self.steeringCenterOffsetZ = localToLocal( self.wheel.driveNode, self.wheel.repr, 0 , 0 , 0 )\n                                        self.steeringCenterOffsetX = - self.steeringCenterOffsetX\n                                        self.steeringCenterOffsetY = - self.steeringCenterOffsetY\n                                        self.steeringCenterOffsetZ = - self.steeringCenterOffsetZ\n                                    end\n\n                                    return true\n                                end\n\n'})}),"\n",(0,t.jsx)(n.h3,{id:"new",children:"new"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Description"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Definition"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"new()"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,t.jsx)(n.table,{children:(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"any"}),(0,t.jsx)(n.th,{children:"wheel"})]})})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Code"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:"function WheelPhysics.new(wheel)\n    local self = setmetatable( { } , { __index = WheelPhysics } )\n\n    self.wheel = wheel\n    self.vehicle = wheel.vehicle\n\n    self.wheelShape = 0\n    self.wheelShapeCreationFrameIndex = math.huge\n    self.wheelShapeCreated = false\n\n    self.torque = 0\n    self.torqueDirection = 1\n\n    self.dirtAmount = 0\n    self.trackAlpha = 0\n    self.groundColor = { 0 , 0 , 0 }\n    self.fieldGroundColor = { 0 , 0 , 0 }\n    self.trackColor = { 0 , 0 , 0 }\n    self.groundDepth = 0\n    self.colorBlendWithTerrain = 1\n    self.lastTerrainAttribute = 0\n\n    self.contact = WheelContactType.NONE\n    self.hasWaterContact = false\n    self.hasSnowContact = false\n    self.snowScale = 0\n    self.lastSnowScale = 0\n    self.steeringAngle = 0\n    self.hasGroundContact = false\n    self.lastContactObjectAllowsTireTracks = true\n    self.densityBits = 0\n    self.densityType = FieldGroundType.NONE\n\n    self.displacementScale = 1\n    self.displacementAllowed = true\n    self.displacementCollisionEnabled = true\n\n    self.sink = 0\n    self.sinkTarget = 0\n\n    self.hasSoilContact = false\n\n    self.tireGroundFrictionCoeff = 1.0 -- This will be changed dynamically based on the tire-ground pair\n\n    return self\nend\n\n"})}),"\n",(0,t.jsx)(n.h3,{id:"postload",children:"postLoad"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Description"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Definition"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"postLoad()"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Code"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:"function WheelPhysics:postLoad()\nend\n\n"})}),"\n",(0,t.jsx)(n.h3,{id:"postupdate",children:"postUpdate"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Description"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Definition"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"postUpdate()"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,t.jsx)(n.table,{children:(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"any"}),(0,t.jsx)(n.th,{children:"dt"})]})})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Code"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:"function WheelPhysics:postUpdate(dt)\n    if self.isPositionDirty then\n        self:updateBase()\n    end\n\n    if self.isFrictionDirty then\n        self:updateTireFriction()\n    end\nend\n\n"})}),"\n",(0,t.jsx)(n.h3,{id:"readstream",children:"readStream"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Description"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Definition"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"readStream()"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"any"}),(0,t.jsx)(n.th,{children:"streamId"})]})}),(0,t.jsx)(n.tbody,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"any"}),(0,t.jsx)(n.td,{children:"updateInterpolation"})]})})]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Code"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:"function WheelPhysics:readStream(streamId, updateInterpolation)\n    local xDriveDirection = streamReadBool(streamId) and 1 or - 1\n    local xDriveDiff = streamReadUIntN(streamId, WheelPhysics.X_DRIVE_NUM_BITS)\n    xDriveDiff = xDriveDiff / WheelPhysics.X_DRIVE_MAX_VALUE\n    xDriveDiff = 1 - (( 1 - xDriveDiff) ^ ( 1 / 4 ))\n    xDriveDiff = xDriveDiff * WheelPhysics.X_DRIVE_MAX_REAL_VALUE * xDriveDirection\n    if updateInterpolation then\n        self.networkInterpolators.xDriveDiff:setValue(xDriveDiff)\n    else\n            self.networkInterpolators.xDriveDiff:setTargetValue(xDriveDiff)\n        end\n\n        local y = streamReadUIntN(streamId, 8 )\n        y = y / 255 * self.netInfo.sync.yRange + self.netInfo.sync.yMin\n        if updateInterpolation then\n            self.netInfo.y = y\n            self.networkInterpolators.position:setPosition( self.netInfo.x, y, self.netInfo.z)\n        else\n                self.networkInterpolators.position:setTargetPosition( self.netInfo.x, y, self.netInfo.z)\n            end\n\n            local suspLength = streamReadUIntN(streamId, 7 )\n            if updateInterpolation then\n                self.netInfo.suspensionLength = suspLength / 100\n                self.networkInterpolators.suspensionLength:setValue(suspLength / 100 )\n            else\n                    self.networkInterpolators.suspensionLength:setTargetValue(suspLength / 100 )\n                end\n\n                if self.wheel.syncContactState then\n                    self.contact = streamReadUIntN(streamId, 2 ) + 1\n                    self.lastContactObjectAllowsTireTracks = streamReadBool(streamId)\n                end\n\n                if self.versatileYRot then\n                    local yRot = streamReadUIntN(streamId, 9 )\n                    self.steeringAngle = yRot / 511 * math.pi * 2\n                end\n            end\n\n"})}),"\n",(0,t.jsx)(n.h3,{id:"registeradditionalwheelxmlpaths",children:"registerAdditionalWheelXMLPaths"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Description"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Definition"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"registerAdditionalWheelXMLPaths()"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"any"}),(0,t.jsx)(n.th,{children:"schema"})]})}),(0,t.jsx)(n.tbody,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"any"}),(0,t.jsx)(n.td,{children:"key"})]})})]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Code"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:'function WheelPhysics.registerAdditionalWheelXMLPaths(schema, key)\n    schema:register(XMLValueType.FLOAT, key .. ".physics#mass" , "Wheel mass(to.)" , 0 )\n    schema:register(XMLValueType.FLOAT, key .. ".physics#maxLongStiffness" , "Max.longitude stiffness" )\n    schema:register(XMLValueType.FLOAT, key .. ".physics#maxLatStiffness" , "Max.latitude stiffness" )\nend\n\n'})}),"\n",(0,t.jsx)(n.h3,{id:"registerxmlpaths",children:"registerXMLPaths"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Description"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Definition"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"registerXMLPaths()"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"any"}),(0,t.jsx)(n.th,{children:"schema"})]})}),(0,t.jsx)(n.tbody,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"any"}),(0,t.jsx)(n.td,{children:"key"})]})})]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Code"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:'function WheelPhysics.registerXMLPaths(schema, key)\n    schema:register(XMLValueType.FLOAT, key .. ".physics#xOffset" , "Moves the default position of the drive node on the X axis" , 0 )\n    schema:register(XMLValueType.FLOAT, key .. ".physics#yOffset" , "Moves the default position of the drive node on the Y axis" , 0 )\n    schema:register(XMLValueType.FLOAT, key .. ".physics#zOffset" , "Moves the default position of the drive node on the Z axis" , 0 )\n    schema:register(XMLValueType.BOOL, key .. ".physics#useReprOffset" , "Defines if the x/y/z offset attribute is applied to the repr or driveNode" , false )\n        schema:register(XMLValueType.BOOL, key .. ".physics#showSteeringAngle" , "Show steering angle" , true )\n        schema:register(XMLValueType.FLOAT, key .. ".physics#steeringAngleFactor" , "Scale factor for physics steering angle to steer more than the visuals show" , 1 )\n            schema:register(XMLValueType.FLOAT, key .. ".physics#suspTravel" , "Suspension travel" , 0.01 )\n            schema:register(XMLValueType.FLOAT, key .. ".physics#initialCompression" , "Initial compression value" )\n            schema:register(XMLValueType.FLOAT, key .. ".physics#deltaY" , "Delta Y" , 0 )\n            schema:register(XMLValueType.FLOAT, key .. ".physics#spring" , "Spring" , 0 )\n            schema:register(XMLValueType.FLOAT, key .. ".physics#brakeFactor" , "Brake factor" , 1 )\n            schema:register(XMLValueType.FLOAT, key .. ".physics#autoHoldBrakeFactor" , "Auto hold brake factor" , "brakeFactor" )\n\n            schema:register(XMLValueType.FLOAT, key .. ".physics#damper" , "Damper" , 0 )\n            schema:register(XMLValueType.FLOAT, key .. ".physics#damperCompressionLowSpeed" , "Damper compression on low speeds" )\n            schema:register(XMLValueType.FLOAT, key .. ".physics#damperCompressionHighSpeed" , "Damper compression on high speeds" )\n            schema:register(XMLValueType.FLOAT, key .. ".physics#damperCompressionLowSpeedThreshold" , "Damper compression on low speeds threshold" , 0.1016 )\n            schema:register(XMLValueType.FLOAT, key .. ".physics#damperRelaxationLowSpeed" , "Damper relaxation on low speeds" )\n            schema:register(XMLValueType.FLOAT, key .. ".physics#damperRelaxationHighSpeed" , "Damper relaxation on high speeds" )\n            schema:register(XMLValueType.FLOAT, key .. ".physics#damperRelaxationLowSpeedThreshold" , "Damper relaxation on low speeds threshold" , 0.1524 )\n\n            schema:register(XMLValueType.FLOAT, key .. ".physics#forcePointRatio" , "Force point ratio" , 0 )\n            schema:register(XMLValueType.INT, key .. ".physics#driveMode" , "Drive mode" , 0 )\n\n            schema:register(XMLValueType.BOOL, key .. ".physics#isSynchronized" , "Wheel is synchronized in multiplayer" , true )\n            schema:register(XMLValueType.INT, key .. ".physics#tipOcclusionAreaGroupId" , "Tip occlusion area group id" )\n\n            schema:register(XMLValueType.BOOL, key .. ".physics#useReprDirection" , "Use repr direction instead of component direction" , false )\n            schema:register(XMLValueType.BOOL, key .. ".physics#useDriveNodeDirection" , "Use drive node direction instead of component direction" , false )\n\n            schema:register(XMLValueType.FLOAT, key .. ".physics#mass" , "Wheel mass(to.)" , 0.1 )\n            schema:register(XMLValueType.FLOAT, key .. ".physics#radius" , "Wheel radius" , 0.5 )\n            schema:register(XMLValueType.FLOAT, key .. ".physics#width" , "Wheel width" , 0.6 )\n\n            schema:register(XMLValueType.FLOAT, key .. ".physics#visualOffset" , "Radius offset of visual wheel in percentage(0-1).Not used on the game." )\n\n            schema:register(XMLValueType.FLOAT, key .. ".physics#widthOffset" , "Wheel width offset" , 0 )\n            schema:register(XMLValueType.FLOAT, key .. ".physics#restLoad" , "Wheel load while resting" , 1.0 )\n                schema:register(XMLValueType.FLOAT, key .. ".physics#maxLongStiffness" , "Max.longitude stiffness" )\n                schema:register(XMLValueType.FLOAT, key .. ".physics#maxLatStiffness" , "Max.latitude stiffness" )\n                schema:register(XMLValueType.FLOAT, key .. ".physics#maxLatStiffnessLoad" , "Max.latitude stiffness load" )\n                schema:register(XMLValueType.FLOAT, key .. ".physics#frictionScale" , "Wheel friction scale" , 1.0 )\n                schema:register(XMLValueType.FLOAT, key .. ".physics#rotationDamping" , "Rotation damping " , "mass * 0.035" )\n                schema:register(XMLValueType.STRING, key .. ".physics#tireType" , "Tire type(mud, offRoad, street, crawler)" )\n\n                schema:register(XMLValueType.FLOAT, key .. ".physics#fieldDirtMultiplier" , "Field dirt multiplier" , 75 )\n                schema:register(XMLValueType.FLOAT, key .. ".physics#streetDirtMultiplier" , "Street dirt multiplier" , - 150 )\n                schema:register(XMLValueType.FLOAT, key .. ".physics#waterWetnessFactor" , "Factor for wheel wetness while driving in water" , 20 )\n                    schema:register(XMLValueType.FLOAT, key .. ".physics#minDirtPercentage" , "Min.dirt scale while cleaning on street drive" , 0.35 )\n                        schema:register(XMLValueType.FLOAT, key .. ".physics#maxDirtOffset" , "Max.dirt amount offset to global dirt node" , 0.5 )\n                        schema:register(XMLValueType.FLOAT, key .. ".physics#dirtColorChangeSpeed" , "Defines speed to change the dirt color(sec)" , 20 )\n\n                        schema:register(XMLValueType.BOOL, key .. ".physics#versatileYRot" , "Do versatile Y rotation" , false )\n                        schema:register(XMLValueType.BOOL, key .. ".physics#forceVersatility" , "Force versatility, also if no ground contact" , false )\n                            schema:register(XMLValueType.BOOL, key .. ".physics#supportsWheelSink" , "The wheel is allowed to deform the terrain displacement collision and \'sink\' into the terrain" , true )\n\n                            schema:register(XMLValueType.BOOL, key .. ".physics.extraSink#supported" , "Additional sinking into the terrain independent of the adjustment of the terrain displacement. (FS22 in prior style)" , false )\n                            schema:register(XMLValueType.FLOAT, key .. ".physics.extraSink#maxValue" , "Max.sink value in meter" , "20% of the wheel radius" )\n\n                            schema:register(XMLValueType.ANGLE, key .. ".physics#rotSpeed" , "Rotation speed" )\n                            schema:register(XMLValueType.ANGLE, key .. ".physics#rotSpeedNeg" , "Rotation speed in negative direction" )\n                            schema:register(XMLValueType.ANGLE, key .. ".physics#rotMax" , "Max.rotation" )\n                            schema:register(XMLValueType.ANGLE, key .. ".physics#rotMin" , "Min.rotation" )\n\n                            schema:register(XMLValueType.BOOL, key .. ".physics#invertRotLimit" , "Invert the rotation limits" )\n                            schema:register(XMLValueType.FLOAT, key .. ".physics#rotSpeedLimit" , "Rotation speed limit" )\n\n                            schema:register(XMLValueType.FLOAT, key .. ".physics#maxInnerSpacing" , "Defines a maximum spacing to the inside which is now allowed to be exceeded by the tire, if so, the tire will be moved out automatically" )\n                            end\n\n'})}),"\n",(0,t.jsx)(n.h3,{id:"removefromphysics",children:"removeFromPhysics"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Description"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Definition"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"removeFromPhysics()"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Code"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:"function WheelPhysics:removeFromPhysics()\n    self.wheelShape = 0\n    self.wheelShapeCreationFrameIndex = math.huge\n    self.wheelShapeCreated = false\nend\n\n"})}),"\n",(0,t.jsx)(n.h3,{id:"serverupdate",children:"serverUpdate"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Description"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Definition"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"serverUpdate()"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"any"}),(0,t.jsx)(n.th,{children:"dt"})]})}),(0,t.jsxs)(n.tbody,{children:[(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"any"}),(0,t.jsx)(n.td,{children:"currentUpdateIndex"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"any"}),(0,t.jsx)(n.td,{children:"groundWetness"})]})]})]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Code"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:"function WheelPhysics:serverUpdate(dt, currentUpdateIndex, groundWetness)\n    if self.vehicle.isActive then\n        if currentUpdateIndex = = self.wheel.updateIndex then\n            self:updateContact()\n        end\n\n        if self.extraSinkSupported then\n            self:updateSink(dt, groundWetness)\n        end\n\n        if self.vehicle.isServer then\n            self:updateFriction(dt, groundWetness)\n        end\n\n        local brakeForce = 0\n        if self.wheel.brakePedal > 0 then\n            brakeForce = self.vehicle:getBrakeForce() * self.wheel.brakePedal\n        end\n\n        self:updatePhysics(brakeForce)\n        self:updateSteeringAngle(dt)\n    end\n\n    self:updateNetInfo(dt)\nend\n\n"})}),"\n",(0,t.jsx)(n.h3,{id:"setdisplacementallowed",children:"setDisplacementAllowed"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Description"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Definition"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"setDisplacementAllowed()"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,t.jsx)(n.table,{children:(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"any"}),(0,t.jsx)(n.th,{children:"displacementAllowed"})]})})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Code"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:"function WheelPhysics:setDisplacementAllowed(displacementAllowed)\n    self.displacementAllowed = displacementAllowed\n\n    if self.vehicle.isServer and self.vehicle.isAddedToPhysics then\n        setWheelShapeTerrainDisplacement( self.wheel.node, self.wheelShape, self.displacementAllowed and self.displacementScale or 0 )\n    end\nend\n\n"})}),"\n",(0,t.jsx)(n.h3,{id:"setdisplacementcollisionenabled",children:"setDisplacementCollisionEnabled"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Description"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Definition"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"setDisplacementCollisionEnabled()"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,t.jsx)(n.table,{children:(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"any"}),(0,t.jsx)(n.th,{children:"displacementCollisionEnabled"})]})})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Code"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:"function WheelPhysics:setDisplacementCollisionEnabled(displacementCollisionEnabled)\n    self.displacementCollisionEnabled = displacementCollisionEnabled\n\n    local oldCollisionMask = self.collisionMask\n    if not Platform.gameplay.wheelTerrainDisplacement or not self.supportsWheelSink or not self.displacementCollisionEnabled then\n        self.collisionMask = bit32.band( WheelPhysics.COLLISION_MASK, bit32.bnot(CollisionFlag.TERRAIN_DISPLACEMENT)) -- remove TERRAIN_DISPLACEMENT from mask\n    else\n            self.collisionMask = nil\n        end\n\n        if self.collisionMask ~ = oldCollisionMask then\n            self:updateBase()\n        end\n    end\n\n"})}),"\n",(0,t.jsx)(n.h3,{id:"setsteeringvalues",children:"setSteeringValues"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Description"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Definition"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"setSteeringValues()"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"any"}),(0,t.jsx)(n.th,{children:"rotMin"})]})}),(0,t.jsxs)(n.tbody,{children:[(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"any"}),(0,t.jsx)(n.td,{children:"rotMax"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"any"}),(0,t.jsx)(n.td,{children:"rotSpeed"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"any"}),(0,t.jsx)(n.td,{children:"rotSpeedNeg"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"any"}),(0,t.jsx)(n.td,{children:"inverted"})]})]})]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Code"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:"function WheelPhysics:setSteeringValues(rotMin, rotMax, rotSpeed, rotSpeedNeg, inverted)\n    self.rotMin = rotMin\n    self.rotMax = rotMax\n\n    if self.invertRotLimit then\n        inverted = not inverted\n    end\n\n    if inverted then\n        rotSpeed, rotSpeedNeg = - rotSpeedNeg, - rotSpeed\n    end\n\n    self.rotSpeed = rotSpeed\n    self.rotSpeedNeg = rotSpeedNeg\nend\n\n"})}),"\n",(0,t.jsx)(n.h3,{id:"setsuspensionmultipliers",children:"setSuspensionMultipliers"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Description"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Definition"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"setSuspensionMultipliers()"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"any"}),(0,t.jsx)(n.th,{children:"springMultiplier"})]})}),(0,t.jsx)(n.tbody,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"any"}),(0,t.jsx)(n.td,{children:"dampingMultiplier"})]})})]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Code"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:"function WheelPhysics:setSuspensionMultipliers(springMultiplier, dampingMultiplier)\n    self.springMultiplier = springMultiplier or 1\n    self.dampingMultiplier = dampingMultiplier or 1\n\n    self.isPositionDirty = true\nend\n\n"})}),"\n",(0,t.jsx)(n.h3,{id:"settorquedirection",children:"setTorqueDirection"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Description"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Definition"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"setTorqueDirection()"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,t.jsx)(n.table,{children:(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"any"}),(0,t.jsx)(n.th,{children:"torqueDirection"})]})})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Code"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:"function WheelPhysics:setTorqueDirection(torqueDirection)\n    torqueDirection = torqueDirection > = 0 and 1 or - 1\n    if torqueDirection ~ = self.torqueDirection then\n        self.torqueDirection = torqueDirection\n        self:updateBase()\n    end\nend\n\n"})}),"\n",(0,t.jsx)(n.h3,{id:"setwheelshapewidth",children:"setWheelShapeWidth"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Description"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Definition"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"setWheelShapeWidth()"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"any"}),(0,t.jsx)(n.th,{children:"width"})]})}),(0,t.jsx)(n.tbody,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"any"}),(0,t.jsx)(n.td,{children:"offset"})]})})]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Code"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:"function WheelPhysics:setWheelShapeWidth(width, offset)\n    self.wheelShapeWidth, self.wheelShapeWidthOffset = width or self.wheelShapeWidth, offset or self.wheelShapeWidthOffset\n\n    self.isPositionDirty = true\nend\n\n"})}),"\n",(0,t.jsx)(n.h3,{id:"updatebase",children:"updateBase"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Description"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Definition"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"updateBase()"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Code"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:"function WheelPhysics:updateBase()\n    if self.vehicle.isServer and self.vehicle.isAddedToPhysics then\n        local positionX, positionY, positionZ = self.positionX - self.directionX * self.deltaY, self.positionY - self.directionY * self.deltaY, self.positionZ - self.directionZ * self.deltaY\n\n        --#debug if VehicleDebug.state = = VehicleDebug.DEBUG_ATTRIBUTES then\n            --#debug local x1, y1, z1 = localToWorld(self.wheel.node, self.positionX, self.positionY, self.positionZ)\n            --#debug local x2, y2, z2 = localToWorld(self.wheel.node, positionX, positionY, positionZ)\n            --#debug drawDebugLine(x1, y1, z1, 1, 0, 0, x2, y2, z2, 0, 1, 0, false)\n            --#debug end\n\n            if self.wheelShape = = 0 then\n                self.wheelShapeCreationFrameIndex = g_updateLoopIndex\n                self.wheelShapeCreated = false\n            end\n\n            local spring = self.spring * self.springMultiplier\n            local damperCompressionLowSpeed = self.damperCompressionLowSpeed * self.dampingMultiplier\n            local damperCompressionHighSpeed = self.damperCompressionHighSpeed * self.dampingMultiplier\n            local damperRelaxationLowSpeed = self.damperRelaxationLowSpeed * self.dampingMultiplier\n            local damperRelaxationHighSpeed = self.damperRelaxationHighSpeed * self.dampingMultiplier\n\n            local collisionGroup = WheelPhysics.COLLISION_GROUP\n            local collisionMask = self.collisionMask or WheelPhysics.COLLISION_MASK\n            self.wheelShape = createWheelShape( self.wheel.node, positionX, positionY, positionZ, self.radius, self.suspTravel, spring, damperCompressionLowSpeed, damperCompressionHighSpeed, self.damperCompressionLowSpeedThreshold, damperRelaxationLowSpeed, damperRelaxationHighSpeed, self.damperRelaxationLowSpeedThreshold, self.wheel:getMass(), collisionGroup, collisionMask, self.wheelShape)\n\n            local forcePointY = positionY - self.radius * self.forcePointRatio\n            local steeringX, steeringY, steeringZ = localToLocal(getParent( self.wheel.repr), self.wheel.node, self.wheel.startPositionX, self.wheel.startPositionY + self.deltaY, self.wheel.startPositionZ)\n            setWheelShapeForcePoint( self.wheel.node, self.wheelShape, self.positionX, forcePointY, positionZ)\n            setWheelShapeSteeringCenter( self.wheel.node, self.wheelShape, steeringX, steeringY, steeringZ)\n\n            local direction = self.torqueDirection\n            setWheelShapeDirection( self.wheel.node, self.wheelShape, self.directionX, self.directionY, self.directionZ, self.axleX * direction, self.axleY * direction, self.axleZ * direction)\n            setWheelShapeWidth( self.wheel.node, self.wheelShape, self.wheelShapeWidth, self.wheelShapeWidthOffset)\n\n            setWheelShapeTerrainDisplacement( self.wheel.node, self.wheelShape, self.displacementAllowed and self.displacementScale or 0 )\n\n            self.isPositionDirty = false\n        end\n    end\n\n"})}),"\n",(0,t.jsx)(n.h3,{id:"updatecontact",children:"updateContact"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Description"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Definition"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"updateContact()"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Code"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:'function WheelPhysics:updateContact()\n    -- using netinfo because of tire deformation\n    local nx, ny, nz = self.netInfo.x, self.netInfo.y, self.netInfo.z\n\n    local cx, cy, cz = localToWorld( self.wheel.node, nx, ny, nz)\n    raycastClosestAsync(cx, cy, cz, 0 , - 1 , 0 , self.radius + 0.25 , "waterRaycastCallback" , self , CollisionFlag.WATER)\n\n    local wx, wy, wz = localToWorld( self.wheel.node, nx, ny - self.radius, nz)\n\n    local mission = g_currentMission\n    if g_updateLoopIndex - self.wheelShapeCreationFrameIndex > 2 then\n        self.wheelShapeCreated = true\n\n        local contactX, contactY, contactZ, _ = getWheelShapeContactPoint( self.wheel.node, self.wheelShape)\n        self.hasGroundContact = contactX ~ = nil\n        if self.hasGroundContact then\n            self.lastContactX, self.lastContactY, self.lastContactZ = contactX, contactY, contactZ\n        end\n\n        --wheelSpeed = getWheelShapeAxleSpeed(self.wheel.node, self.wheelShape)\n        local contactObject, _ = getWheelShapeContactObject( self.wheel.node, self.wheelShape)\n        if contactObject ~ = 0 then\n            local heightTypeIndex = getDensityMapHeightTypeAtWorldPos(g_densityMapHeightManager.terrainDetailHeightUpdater, wx, wy, wz, 0 )\n            if heightTypeIndex ~ = 0 then\n                self.contact = WheelContactType.GROUND_HEIGHT\n                self.lastContactObjectAllowsTireTracks = true\n            elseif contactObject = = g_terrainNode then\n                    self.contact = WheelContactType.GROUND\n                    self.lastContactObjectAllowsTireTracks = true\n                elseif self.hasGroundContact then\n                        self.contact = WheelContactType.OBJECT\n                        self.lastContactObjectAllowsTireTracks = entityExists(contactObject) and getRigidBodyType(contactObject) = = RigidBodyType.STATIC and getUserAttribute(contactObject, "noTireTracks" ) ~ = true\n                    else\n                            self.contact = WheelContactType.NONE\n                            self.lastContactObjectAllowsTireTracks = false\n                        end\n                    else\n                            self.contact = WheelContactType.NONE\n                            self.lastContactObjectAllowsTireTracks = false\n                        end\n                    end\n\n                    if self.contact = = WheelContactType.GROUND then\n                        local groundTypeMapId, groundTypeFirstChannel, groundTypeNumChannels = mission.fieldGroundSystem:getDensityMapData(FieldDensityMap.GROUND_TYPE)\n                        self.densityBits = getDensityAtWorldPos(groundTypeMapId, wx, wy, wz)\n                        local densityType = bit32.band(bit32.rshift( self.densityBits, groundTypeFirstChannel), 2 ^ groundTypeNumChannels - 1 )\n                        self.densityType = FieldGroundType.getTypeByValue(densityType)\n                    else\n                            self.densityBits = 0\n                            self.densityType = FieldGroundType.NONE\n                        end\n\n                        if self.contact = = WheelContactType.GROUND_HEIGHT then\n                            local densityHeightBits = getDensityAtWorldPos(mission.terrainDetailHeightId, wx, wy, wz)\n                            local numChannels = g_densityMapHeightManager.heightTypeNumChannels\n                            local heightType = bit32.band(densityHeightBits, 2 ^ numChannels - 1 )\n                            self.hasSnowContact = heightType = = mission.snowSystem.snowHeightTypeIndex\n                        else\n                                self.hasSnowContact = false\n                            end\n                        end\n\n'})}),"\n",(0,t.jsx)(n.h3,{id:"updatecontactclient",children:"updateContactClient"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Description"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Definition"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"updateContactClient()"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Code"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:"function WheelPhysics:updateContactClient()\n    local mission = g_currentMission\n\n    local nx, ny, nz = self.netInfo.x, self.netInfo.y, self.netInfo.z\n    local wx, wy, wz = localToWorld( self.wheel.node, nx, ny - self.radius, nz)\n\n    if self.contact = = WheelContactType.GROUND then\n        local groundTypeMapId, groundTypeFirstChannel, groundTypeNumChannels = mission.fieldGroundSystem:getDensityMapData(FieldDensityMap.GROUND_TYPE)\n        self.densityBits = getDensityAtWorldPos(groundTypeMapId, wx, wy, wz)\n        local densityType = bit32.band(bit32.rshift( self.densityBits, groundTypeFirstChannel), 2 ^ groundTypeNumChannels - 1 )\n        self.densityType = FieldGroundType.getTypeByValue(densityType)\n    else\n            self.densityBits = 0\n            self.densityType = FieldGroundType.NONE\n        end\n\n        if self.contact = = WheelContactType.GROUND_HEIGHT then\n            local densityHeightBits = getDensityAtWorldPos(mission.terrainDetailHeightId, wx, wy, wz)\n            local numChannels = g_densityMapHeightManager.heightTypeNumChannels\n            local heightType = bit32.band(densityHeightBits, 2 ^ numChannels - 1 )\n            self.hasSnowContact = heightType = = mission.snowSystem.snowHeightTypeIndex\n        else\n                self.hasSnowContact = false\n            end\n        end\n\n"})}),"\n",(0,t.jsx)(n.h3,{id:"updatefriction",children:"updateFriction"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Description"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Definition"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"updateFriction()"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"any"}),(0,t.jsx)(n.th,{children:"dt"})]})}),(0,t.jsx)(n.tbody,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"any"}),(0,t.jsx)(n.td,{children:"groundWetness"})]})})]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Code"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:"function WheelPhysics:updateFriction(dt, groundWetness)\n    local isOnField = self.densityType ~ = FieldGroundType.NONE\n\n    local snowScale = 0\n    if self.hasSnowContact then\n        groundWetness = 0\n        snowScale = 1\n    end\n\n    local groundType = WheelsUtil.getGroundType(isOnField, self.contact ~ = WheelContactType.GROUND, self.groundDepth)\n    local coeff = WheelsUtil.getTireFriction( self.tireType, groundType, groundWetness, snowScale)\n    if self.vehicle:getLastSpeed() > 0.2 then\n        if coeff ~ = self.tireGroundFrictionCoeff then\n            self.tireGroundFrictionCoeff = coeff\n            self.isFrictionDirty = true\n        end\n    end\nend\n\n"})}),"\n",(0,t.jsx)(n.h3,{id:"updateinterpolation",children:"updateInterpolation"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Description"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Definition"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"updateInterpolation()"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"any"}),(0,t.jsx)(n.th,{children:"dt"})]})}),(0,t.jsx)(n.tbody,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"any"}),(0,t.jsx)(n.td,{children:"interpolationAlpha"})]})})]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Code"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:'function WheelPhysics:updateInterpolation(dt, interpolationAlpha)\n    --#profile RemoteProfiler.zoneBeginN("updateInterpolation")\n    self.netInfo.x, self.netInfo.y, self.netInfo.z = self.networkInterpolators.position:getInterpolatedValues(interpolationAlpha)\n    self.netInfo.suspensionLength = self.networkInterpolators.suspensionLength:getInterpolatedValue(interpolationAlpha)\n\n    local xDriveDiff = self.networkInterpolators.xDriveDiff:getInterpolatedValue(interpolationAlpha)\n    self.netInfo.xDrive = ( self.netInfo.xDrive + xDriveDiff * dt) % ( 2 * math.pi)\n    --#profile RemoteProfiler.zoneEnd()\n\n    self:updateXDriveSpeed(dt)\n    self:updateSteeringAngle(dt)\nend\n\n'})}),"\n",(0,t.jsx)(n.h3,{id:"updatenetinfo",children:"updateNetInfo"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Description"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Definition"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"updateNetInfo()"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,t.jsx)(n.table,{children:(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"any"}),(0,t.jsx)(n.th,{children:"dt"})]})})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Code"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:"function WheelPhysics:updateNetInfo(dt)\n    if self.updateWheel then\n        local x, y, z, xDrive, suspensionLength = getWheelShapePosition( self.wheel.node, self.wheelShape)\n\n        if self.torqueDirection < 0 then\n            self.netInfo.xDrive = self.netInfo.xDrive - (xDrive - self.netInfo.xDriveLastRaw)\n        else\n                self.netInfo.xDrive = self.netInfo.xDrive + (xDrive - self.netInfo.xDriveLastRaw)\n            end\n            self.netInfo.xDriveLastRaw = xDrive\n\n            if self.dirtyFlag ~ = nil and( self.netInfo.x ~ = x or self.netInfo.z ~ = z) then\n                self.vehicle:raiseDirtyFlags( self.dirtyFlag)\n            end\n\n            --fill netinfo(on server)\n            self.netInfo.x = x\n            self.netInfo.y = y\n            self.netInfo.z = z\n            self.netInfo.suspensionLength = suspensionLength\n\n            self.netInfo.xDriveDiff = 0\n            self:updateXDriveSpeed( math.max(g_physicsDtNonInterpolated, 0.001 ))\n        else\n                self.updateWheel = true\n            end\n        end\n\n"})}),"\n",(0,t.jsx)(n.h3,{id:"updatephysics",children:"updatePhysics"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Description"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Definition"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"updatePhysics()"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"any"}),(0,t.jsx)(n.th,{children:"brakeForce"})]})}),(0,t.jsx)(n.tbody,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"any"}),(0,t.jsx)(n.td,{children:"torque"})]})})]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Code"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:"function WheelPhysics:updatePhysics(brakeForce, torque)\n    if self.vehicle.isServer and self.vehicle.isAddedToPhysics then\n        setWheelShapeProps( self.wheel.node, self.wheelShape, torque or self.torque, (brakeForce or 0 ) * self.brakeFactor, self.steeringAngle, self.rotationDamping)\n        setWheelShapeAutoHoldBrakeForce( self.wheel.node, self.wheelShape, (brakeForce or 0 ) * self.autoHoldBrakeFactor)\n    end\nend\n\n"})}),"\n",(0,t.jsx)(n.h3,{id:"updateshapeposition",children:"updateShapePosition"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Description"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Definition"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"updateShapePosition()"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Code"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:"function WheelPhysics:updateShapePosition()\n    self.positionX, self.positionY, self.positionZ = localToLocal(getParent( self.wheel.repr), self.wheel.node, self.wheel.startPositionX - self.steeringCenterOffsetX, self.wheel.startPositionY - self.steeringCenterOffsetY, self.wheel.startPositionZ - self.steeringCenterOffsetZ)\n    if self.useReprDirection then\n        self.directionX, self.directionY, self.directionZ = localDirectionToLocal( self.wheel.repr, self.wheel.node, 0 , - 1 , 0 )\n        self.axleX, self.axleY, self.axleZ = localDirectionToLocal( self.wheel.repr, self.wheel.node, 1 , 0 , 0 )\n    elseif self.useDriveNodeDirection then\n            self.directionX, self.directionY, self.directionZ = localDirectionToLocal( self.wheel.driveNodeDirectionNode, self.wheel.node, 0 , - 1 , 0 )\n            self.axleX, self.axleY, self.axleZ = localDirectionToLocal( self.wheel.driveNodeDirectionNode, self.wheel.node, 1 , 0 , 0 )\n        end\n\n        -- update the wheel base in the post update to have only one per frame\n        -- in case a wheel is updated from multiple movingTools/Parts\n        -- additionally this ensures that the vehicle is added to the physics\n        self.isPositionDirty = true\n    end\n\n"})}),"\n",(0,t.jsx)(n.h3,{id:"updatesink",children:"updateSink"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Description"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Definition"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"updateSink()"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"any"}),(0,t.jsx)(n.th,{children:"dt"})]})}),(0,t.jsx)(n.tbody,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"any"}),(0,t.jsx)(n.td,{children:"groundWetness"})]})})]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Code"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:"function WheelPhysics:updateSink(dt, groundWetness)\n    if self.wheelShape ~ = 0 then\n        local sinkTarget = self.sinkTarget\n        local lastSpeed = self.vehicle:getLastSpeed()\n        local interpolationFactor = 1\n\n        if self.contact ~ = WheelContactType.NONE and lastSpeed > 0.3 then\n            sinkTarget = WheelPhysics.MAX_SINK[ self.densityType] or 0\n\n            -- if we are in water and we already sink, we increase the sink\n                if self.hasWaterContact and sinkTarget ~ = 0 then\n                    sinkTarget = math.max(sinkTarget, WheelPhysics.WATER_SINK)\n                end\n\n                sinkTarget = math.min(sinkTarget, self.extraSinkMaxValue)\n            elseif self.contact = = WheelContactType.NONE then\n                    sinkTarget = 0\n                    lastSpeed = 10\n                    interpolationFactor = 0.075 -- smoother interpolation back to normal radius in case we directly sink again after having ground contact -> this avoid jittering\n                end\n\n                if self.sinkTarget < sinkTarget then\n                    self.sinkTarget = math.min(sinkTarget, self.sinkTarget + ( 0.05 * math.min( 30 , math.max( 0 , lastSpeed - 0.2 )) * (dt / 1000 ) * interpolationFactor))\n                elseif self.sinkTarget > sinkTarget then\n                        self.sinkTarget = math.max(sinkTarget, self.sinkTarget - ( 0.05 * math.min( 30 , math.max( 0 , lastSpeed - 0.2 )) * (dt / 1000 ) * interpolationFactor))\n                    end\n\n                    if math.abs( self.sink - self.sinkTarget) > 0.001 then\n                        self.sink = self.sinkTarget\n\n                        local deltaY = self.deltaYOriginal + self.sink\n                        if deltaY ~ = self.deltaY then\n                            self.deltaY = deltaY\n\n                            self.isPositionDirty = true\n                        end\n                    end\n                end\n            end\n\n"})}),"\n",(0,t.jsx)(n.h3,{id:"updatesteeringangle",children:"updateSteeringAngle"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Description"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Definition"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"updateSteeringAngle()"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,t.jsx)(n.table,{children:(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"any"}),(0,t.jsx)(n.th,{children:"dt"})]})})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Code"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:'function WheelPhysics:updateSteeringAngle(dt)\n    --#profile RemoteProfiler.zoneBeginN("updateSteeringAngle")\n    local steeringAngle = self.steeringAngle\n    local rotatedTime = self.vehicle.rotatedTime\n\n    if self.wheel.steering.steeringAxleScale ~ = nil and self.wheel.steering.steeringAxleScale ~ = 0 then\n        local steeringAxleAngle = 0\n        if self.vehicle.spec_attachable ~ = nil then\n            steeringAxleAngle = self.vehicle.spec_attachable.steeringAxleAngle\n        end\n        steeringAngle = math.clamp(steeringAxleAngle * self.wheel.steering.steeringAxleScale, self.wheel.steering.steeringAxleRotMin, self.wheel.steering.steeringAxleRotMax)\n    elseif self.versatileYRot and self.vehicle:getIsVersatileYRotActive( self.wheel) then\n            if self.vehicle.isServer then\n                if self.forceVersatility or self.hasGroundContact then\n                    steeringAngle = Utils.getVersatileRotation( self.wheel.repr, self.wheel.node, dt, self.positionX, self.positionY, self.positionZ, self.steeringAngle, self.rotMin, self.rotMax)\n                end\n            end\n        elseif ( self.rotSpeed ~ = 0 and self.rotMax ~ = nil and self.rotMin ~ = nil ) or self.wheel.forceSteeringAngleUpdate then\n                if rotatedTime > 0 or self.rotSpeedNeg = = nil then\n                    steeringAngle = rotatedTime * self.rotSpeed\n                else\n                        steeringAngle = rotatedTime * self.rotSpeedNeg\n                    end\n                    if steeringAngle > self.rotMax then\n                        steeringAngle = self.rotMax\n                    elseif steeringAngle < self.rotMin then\n                            steeringAngle = self.rotMin\n                        end\n                        if self.vehicle.customSteeringAngleFunction then\n\n                            --#profile RemoteProfiler.zoneBeginN("updateSteeringAngle-vehicle")\n                            steeringAngle = self.vehicle:updateSteeringAngle( self.wheel, dt, steeringAngle)\n                            --#profile RemoteProfiler.zoneEnd()\n                        end\n                    end\n\n                    self.steeringAngle = steeringAngle\n                    --#profile RemoteProfiler.zoneEnd()\n                end\n\n'})}),"\n",(0,t.jsx)(n.h3,{id:"updatetick",children:"updateTick"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Description"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Definition"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"updateTick()"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"any"}),(0,t.jsx)(n.th,{children:"dt"})]})}),(0,t.jsxs)(n.tbody,{children:[(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"any"}),(0,t.jsx)(n.td,{children:"groundWetness"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"any"}),(0,t.jsx)(n.td,{children:"currentUpdateDistance"})]})]})]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Code"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:"function WheelPhysics:updateTick(dt, groundWetness, currentUpdateDistance)\n    if self.rotSpeedLimit ~ = nil then\n        local dir = - 1\n        if self:getLastSpeed() < = self.rotSpeedLimit then\n            dir = 1\n        end\n\n        self.currentRotSpeedAlpha = math.clamp( self.currentRotSpeedAlpha + dir * (dt / 1000 ), 0 , 1 )\n        self.rotSpeed = self.rotSpeedDefault * self.currentRotSpeedAlpha\n        self.rotSpeedNeg = self.rotSpeedNegDefault * self.currentRotSpeedAlpha\n    end\n\n    if currentUpdateDistance < TireTracks.MAX_CREATION_DISTANCE or currentUpdateDistance < WheelEffects.MAX_UPDATE_DISTANCE then\n        self.hasSoilContact = false\n\n        -- update color\n        local wx, wy, wz = getWorldTranslation( self.wheel.driveNode)\n        local targetDirtAmount, targetAlpha = 0 , 0\n        if self.contact = = WheelContactType.GROUND then\n            local isOnField = self.densityType ~ = FieldGroundType.NONE\n            local colorBlendWithTerrain = 1\n\n            local r, g, b, depth, t\n            if isOnField then\n                r, g, b, depth = g_currentMission.fieldGroundSystem:getFieldGroundTyreTrackColor( self.densityBits)\n                t = 1 -- 1 is the materialId for dirt\n\n                    targetDirtAmount = 1\n                    if self.densityType = = FieldGroundType.GRASS then\n                        targetDirtAmount = 0.7\n                    elseif self.densityType = = FieldGroundType.GRASS_CUT then\n                            targetDirtAmount = 0.6\n                        else\n                                self.hasSoilContact = true\n                            end\n                            self.fieldGroundColor[ 1 ] = r\n                            self.fieldGroundColor[ 2 ] = g\n                            self.fieldGroundColor[ 3 ] = b\n\n                            colorBlendWithTerrain = 0.75\n                        else\n                                r, g, b, depth, t = getTerrainAttributesAtWorldPos(g_terrainNode, wx, wy, wz, true , true , true , true , false )\n                                self.groundColor[ 1 ] = r\n                                self.groundColor[ 2 ] = g\n                                self.groundColor[ 3 ] = b\n\n                                if depth > 0 then\n                                    targetAlpha = 0.5\n                                end\n                            end\n\n                            self.groundDepth = depth\n                            self.colorBlendWithTerrain = colorBlendWithTerrain\n                            self.lastTerrainAttribute = t\n                        elseif self.contact = = WheelContactType.GROUND_HEIGHT then\n                                self.groundDepth = 1\n                                targetAlpha = 1\n                                self.colorBlendWithTerrain = 0\n                            elseif self.contact = = WheelContactType.OBJECT then\n                                    -- no depth to tyre tracks on road etc.\n                                    self.groundDepth = 0\n                                end\n\n                                if targetDirtAmount ~ = self.dirtAmount then\n                                    if targetDirtAmount < self.dirtAmount then\n                                        local maxTrackLength = 30 * ( 1 + groundWetness)\n                                        local speedFactor = math.min( self.vehicle:getLastSpeed(), 20 ) / 20\n                                        maxTrackLength = maxTrackLength * ( 2 - speedFactor)\n                                        self.dirtAmount = math.max( self.dirtAmount - self.vehicle.lastMovedDistance / maxTrackLength, targetDirtAmount)\n                                    else\n                                            self.dirtAmount = math.min( self.dirtAmount + self.vehicle.lastMovedDistance, targetDirtAmount)\n                                        end\n                                    end\n\n                                    -- fade over 0.5m\n                                    if targetAlpha ~ = self.trackAlpha then\n                                        if targetAlpha > self.trackAlpha then\n                                            self.trackAlpha = math.min( self.trackAlpha + self.vehicle.lastMovedDistance * 2 , targetAlpha)\n                                        else\n                                                self.trackAlpha = math.max( self.trackAlpha - self.vehicle.lastMovedDistance * 2 , targetAlpha)\n                                            end\n                                        end\n\n                                        if self.groundDepth > 0 then\n                                            for i = 1 , 3 do\n                                                self.trackColor[i] = self.fieldGroundColor[i] * self.dirtAmount + self.groundColor[i] * ( 1 - self.dirtAmount)\n                                            end\n                                        else\n                                                for i = 1 , 3 do\n                                                    self.trackColor[i] = self.fieldGroundColor[i]\n                                                end\n                                            end\n                                        end\n                                    end\n\n"})}),"\n",(0,t.jsx)(n.h3,{id:"updatetirefriction",children:"updateTireFriction"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Description"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Definition"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"updateTireFriction()"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Code"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:"function WheelPhysics:updateTireFriction()\n    if self.vehicle.isServer and self.vehicle.isAddedToPhysics then\n        setWheelShapeTireFriction( self.wheel.node, self.wheelShape, self.maxLongStiffness, self.maxLatStiffness, self.maxLatStiffnessLoad, self.frictionScale * self.tireGroundFrictionCoeff)\n        self.isFrictionDirty = false\n    end\nend\n\n"})}),"\n",(0,t.jsx)(n.h3,{id:"updatexdrivespeed",children:"updateXDriveSpeed"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Description"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Definition"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"updateXDriveSpeed()"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,t.jsx)(n.table,{children:(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"any"}),(0,t.jsx)(n.th,{children:"dt"})]})})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Code"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:'function WheelPhysics:updateXDriveSpeed(dt)\n    --#profile RemoteProfiler.zoneBeginN("updateXDriveSpeed")\n    local xDrive = self.netInfo.xDrive\n\n    -- calculate xDriveSpeed\n    if self.netInfo.xDriveBefore = = nil then\n        self.netInfo.xDriveBefore = xDrive\n    end\n\n    local xDriveDiff = xDrive - self.netInfo.xDriveBefore\n    if xDriveDiff > math.pi then\n        self.netInfo.xDriveBefore = self.netInfo.xDriveBefore + ( 2 * math.pi)\n    elseif xDriveDiff < - math.pi then\n            self.netInfo.xDriveBefore = self.netInfo.xDriveBefore - ( 2 * math.pi)\n        end\n        self.netInfo.xDriveDiff = (xDrive - self.netInfo.xDriveBefore) / dt\n        self.netInfo.xDriveSpeed = self.netInfo.xDriveDiff * 1000\n        self.netInfo.xDriveBefore = xDrive\n\n        local speed = MathUtil.rpmToMps( self.netInfo.xDriveSpeed / 6.283185 * 60 , self.radius)\n        self.netInfo.lastSpeedSmoothed = self.netInfo.lastSpeedSmoothed * 0.9 + speed * 0.1\n        self.netInfo.slip = math.clamp( self.netInfo.lastSpeedSmoothed / math.max( self.vehicle.lastSpeedSmoothed, 0.00000001 ), 1 , 2 ) - 1\n        --#profile RemoteProfiler.zoneEnd()\n    end\n\n'})}),"\n",(0,t.jsx)(n.h3,{id:"waterraycastcallback",children:"waterRaycastCallback"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Description"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Definition"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"waterRaycastCallback()"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"any"}),(0,t.jsx)(n.th,{children:"actorId"})]})}),(0,t.jsxs)(n.tbody,{children:[(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"any"}),(0,t.jsx)(n.td,{children:"x"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"any"}),(0,t.jsx)(n.td,{children:"y"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"any"}),(0,t.jsx)(n.td,{children:"z"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"any"}),(0,t.jsx)(n.td,{children:"distance"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"any"}),(0,t.jsx)(n.td,{children:"nx"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"any"}),(0,t.jsx)(n.td,{children:"ny"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"any"}),(0,t.jsx)(n.td,{children:"nz"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"any"}),(0,t.jsx)(n.td,{children:"subShapeIndex"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"any"}),(0,t.jsx)(n.td,{children:"shapeId"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"any"}),(0,t.jsx)(n.td,{children:"isLast"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"any"}),(0,t.jsx)(n.td,{children:"..."})]})]})]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Code"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:"function WheelPhysics:waterRaycastCallback(actorId, x, y, z, distance, nx, ny, nz, subShapeIndex, shapeId, isLast, .. .)\n    if actorId ~ = 0 then\n        local terrainHeight = getTerrainHeightAtWorldPos(g_terrainNode, x, 0 , z)\n        self.hasWaterContact = y > terrainHeight\n    elseif isLast then\n            self.hasWaterContact = false\n        end\n    end\n\n"})}),"\n",(0,t.jsx)(n.h3,{id:"writestream",children:"writeStream"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Description"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Definition"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"writeStream()"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,t.jsx)(n.table,{children:(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"any"}),(0,t.jsx)(n.th,{children:"streamId"})]})})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Code"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:"function WheelPhysics:writeStream(streamId)\n    local xDriveDiff = math.clamp( math.abs( self.netInfo.xDriveDiff) / WheelPhysics.X_DRIVE_MAX_REAL_VALUE, 0 , 1 )\n    streamWriteBool(streamId, self.netInfo.xDriveDiff > = 0 )\n    xDriveDiff = 1 - (( 1 - xDriveDiff) ^ 4 )\n    streamWriteUIntN(streamId, xDriveDiff * WheelPhysics.X_DRIVE_MAX_VALUE, WheelPhysics.X_DRIVE_NUM_BITS)\n\n    streamWriteUIntN(streamId, math.clamp( math.floor(( self.netInfo.y - self.netInfo.sync.yMin) / self.netInfo.sync.yRange * 255 ), 0 , 255 ), 8 )\n\n    streamWriteUIntN(streamId, math.clamp( self.netInfo.suspensionLength * 100 , 0 , 128 ), 7 )\n\n    if self.wheel.syncContactState then\n        streamWriteUIntN(streamId, self.contact - 1 , 2 )\n        streamWriteBool(streamId, self.lastContactObjectAllowsTireTracks)\n    end\n\n    if self.versatileYRot then\n        local yRot = self.steeringAngle % ( math.pi * 2 )\n        streamWriteUIntN(streamId, math.clamp( math.floor(yRot / ( math.pi * 2 ) * 511 ), 0 , 511 ), 9 )\n    end\nend\n\n"})})]})}function h(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(c,{...e})}):c(e)}}}]);