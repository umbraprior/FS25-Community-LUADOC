"use strict";(globalThis.webpackChunkfs25_community_luadoc=globalThis.webpackChunkfs25_community_luadoc||[]).push([[27569],{25370(e,n,i){i.r(n),i.d(n,{assets:()=>s,contentTitle:()=>o,default:()=>h,frontMatter:()=>a,metadata:()=>t,toc:()=>c});const t=JSON.parse('{"id":"script/AI/AIDriveStrategyCombine","title":"AIDriveStrategyCombine","description":"AIDriveStrategyCombine","source":"@site/../docs/script/AI/AIDriveStrategyCombine.md","sourceDirName":"script/AI","slug":"/script/AI/AIDriveStrategyCombine","permalink":"/FS25-Community-LUADOC/script/AI/AIDriveStrategyCombine","draft":false,"unlisted":false,"tags":[],"version":"current","lastUpdatedAt":1767161192000,"frontMatter":{},"sidebar":"docsSidebar","previous":{"title":"AIDriveStrategyBaler","permalink":"/FS25-Community-LUADOC/script/AI/AIDriveStrategyBaler"},"next":{"title":"AIDriveStrategyConveyor","permalink":"/FS25-Community-LUADOC/script/AI/AIDriveStrategyConveyor"}}');var l=i(74848),r=i(28453);const a={},o=void 0,s={},c=[{value:"AIDriveStrategyCombine",id:"aidrivestrategycombine",level:2},{value:"getDriveData",id:"getdrivedata",level:3},{value:"new",id:"new",level:3},{value:"setAIVehicle",id:"setaivehicle",level:3},{value:"update",id:"update",level:3},{value:"updateDriving",id:"updatedriving",level:3}];function d(e){const n={a:"a",blockquote:"blockquote",code:"code",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,r.R)(),...e.components};return(0,l.jsxs)(l.Fragment,{children:[(0,l.jsx)(n.h2,{id:"aidrivestrategycombine",children:"AIDriveStrategyCombine"}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Description"})}),"\n",(0,l.jsxs)(n.blockquote,{children:["\n",(0,l.jsx)(n.p,{children:"drive strategy to"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsx)(n.li,{children:"stop vehicle if grain tank of combine is full"}),"\n",(0,l.jsx)(n.li,{children:"open/close pipe\n> Copyright (C) GIANTS Software GmbH, Confidential, All Rights Reserved."}),"\n"]}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Parent"})}),"\n",(0,l.jsxs)(n.blockquote,{children:["\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.a,{href:"?version=script&category=4&class=148",children:"AIDriveStrategy"})}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Functions"})}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsx)(n.li,{children:(0,l.jsx)(n.a,{href:"#getdrivedata",children:"getDriveData"})}),"\n",(0,l.jsx)(n.li,{children:(0,l.jsx)(n.a,{href:"#new",children:"new"})}),"\n",(0,l.jsx)(n.li,{children:(0,l.jsx)(n.a,{href:"#setaivehicle",children:"setAIVehicle"})}),"\n",(0,l.jsx)(n.li,{children:(0,l.jsx)(n.a,{href:"#update",children:"update"})}),"\n",(0,l.jsx)(n.li,{children:(0,l.jsx)(n.a,{href:"#updatedriving",children:"updateDriving"})}),"\n"]}),"\n",(0,l.jsx)(n.h3,{id:"getdrivedata",children:"getDriveData"}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Description"})}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Definition"})}),"\n",(0,l.jsxs)(n.blockquote,{children:["\n",(0,l.jsx)(n.p,{children:"getDriveData()"}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,l.jsxs)(n.table,{children:[(0,l.jsx)(n.thead,{children:(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.th,{children:"any"}),(0,l.jsx)(n.th,{children:"dt"})]})}),(0,l.jsxs)(n.tbody,{children:[(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{children:"any"}),(0,l.jsx)(n.td,{children:"vX"})]}),(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{children:"any"}),(0,l.jsx)(n.td,{children:"vY"})]}),(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{children:"any"}),(0,l.jsx)(n.td,{children:"vZ"})]})]})]}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Code"})}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-lua",children:'function AIDriveStrategyCombine:getDriveData(dt, vX,vY,vZ)\n    local rootVehicle = self.vehicle.rootVehicle\n    local isTurning = rootVehicle.getAIFieldWorkerIsTurning ~ = nil and rootVehicle:getAIFieldWorkerIsTurning()\n    local isCornerCutOutActive = rootVehicle.getAIFieldWorkerIsCornerCutOutActive ~ = nil and rootVehicle:getAIFieldWorkerIsCornerCutOutActive()\n\n    local allowedToDrive = true\n    local waitForStraw = false\n    local maxSpeed = math.huge\n\n    for _, combine in pairs( self.combines) do\n        if combine.spec_pipe ~ = nil then\n            local trailerInTrigger = false\n            local invalidTrailerInTrigger = false\n            local fillLevel = 0\n            local capacity = 0\n\n            local dischargeNode = combine:getCurrentDischargeNode()\n            if dischargeNode ~ = nil then\n                fillLevel = combine:getFillUnitFillLevel(dischargeNode.fillUnitIndex)\n                capacity = combine:getFillUnitCapacity(dischargeNode.fillUnitIndex)\n            end\n\n            local trailer = NetworkUtil.getObject(combine.spec_pipe.nearestObjectInTriggers.objectId)\n            if trailer ~ = nil then\n                trailerInTrigger = true\n            end\n\n            if combine.spec_pipe.nearestObjectInTriggerIgnoreFillLevel then\n                invalidTrailerInTrigger = true\n            end\n\n            local currentPipeTargetState = combine.spec_pipe.targetState\n            local currentPipeState = combine.spec_pipe.currentState\n            local turnOnAllowedStates = combine.spec_pipe.turnOnAllowedStates\n            if next(turnOnAllowedStates) = = nil then\n                turnOnAllowedStates = nil\n            end\n\n            if capacity = = math.huge then\n                -- forage harvesters\n                if currentPipeTargetState ~ = 2 then\n                    combine:setPipeState( 2 )\n                end\n\n                if not isTurning and not isCornerCutOutActive then\n                    local targetObject, _ = combine:getDischargeTargetObject(dischargeNode)\n                    allowedToDrive = trailerInTrigger and targetObject ~ = nil\n\n                    if VehicleDebug.state = = VehicleDebug.DEBUG_AI then\n                        if not trailerInTrigger then\n                            self.vehicle:addAIDebugText( "COMBINE -> Waiting for trailer enter the trigger" )\n                            elseif trailerInTrigger and targetObject = = nil then\n                                    self.vehicle:addAIDebugText( "COMBINE -> Waiting for pipe hitting the trailer" )\n                                    end\n                                end\n                            end\n                        else\n                                -- combine harvesters\n                                local pipeState = currentPipeTargetState\n\n                                if fillLevel > ( 0.8 * capacity) then\n                                    if not self.beaconLightsActive then\n                                        self.vehicle:setAIMapHotspotBlinking( true )\n                                        self.vehicle:setBeaconLightsVisibility( true )\n                                        self.beaconLightsActive = true\n                                    end\n\n                                    if not self.notificationGrainTankWarningShown and self.vehicle:getOwnerFarmId() = = g_localPlayer.farmId then\n                                        g_currentMission:addIngameNotification(FSBaseMission.INGAME_NOTIFICATION_CRITICAL, string.format(g_i18n:getText( "ai_messageErrorTankIsNearlyFull" ), self.vehicle:getCurrentHelper().name) )\n                                        self.notificationGrainTankWarningShown = true\n                                    end\n                                else\n                                        if self.beaconLightsActive then\n                                            self.vehicle:setAIMapHotspotBlinking( false )\n                                            self.vehicle:setBeaconLightsVisibility( false )\n                                            self.beaconLightsActive = false\n                                        end\n\n                                        self.notificationGrainTankWarningShown = false\n                                    end\n\n                                    if fillLevel = = capacity then\n                                        pipeState = 2\n                                        self.wasCompletelyFull = true\n                                        if not self.notificationFullGrainTankShown and self.vehicle:getOwnerFarmId() = = g_localPlayer.farmId then\n                                            g_currentMission:addIngameNotification(FSBaseMission.INGAME_NOTIFICATION_CRITICAL, string.format(g_i18n:getText( "ai_messageErrorTankIsFull" ), self.vehicle:getCurrentHelper().name) )\n                                            self.notificationFullGrainTankShown = true\n                                        end\n                                    else\n                                            self.notificationFullGrainTankShown = false\n                                        end\n\n                                        if trailerInTrigger then\n                                            -- if we have to turn off while lifting the pipe, we only lift if we have something loaded\n                                                if turnOnAllowedStates ~ = nil and turnOnAllowedStates[ 2 ] ~ = true then\n                                                    if fillLevel > 0.1 then\n                                                        pipeState = 2\n                                                    end\n                                                else\n                                                        pipeState = 2\n                                                    end\n                                                end\n\n                                                if not trailerInTrigger then\n                                                    if fillLevel < capacity * 0.8 then\n                                                        self.wasCompletelyFull = false\n\n                                                        if not combine:getIsTurnedOn() and combine:getCanBeTurnedOn() then\n                                                            combine:aiImplementStartLine()\n                                                            for i, implement in ipairs( self.vehicle:getAttachedAIImplements()) do\n                                                                implement.object:aiImplementStartLine()\n                                                            end\n                                                        end\n                                                    end\n                                                end\n\n                                                if ( not trailerInTrigger and not invalidTrailerInTrigger) and fillLevel < capacity then\n                                                    pipeState = 1\n                                                end\n\n                                                if fillLevel < 0.1 then\n                                                    if not combine.spec_pipe.aiFoldedPipeUsesTrailerSpace then\n                                                        if not trailerInTrigger and not invalidTrailerInTrigger then\n                                                            pipeState = 1\n                                                        end\n\n                                                        if not combine:getIsTurnedOn() and combine:getCanBeTurnedOn() then\n                                                            combine:aiImplementStartLine()\n                                                            for i, implement in ipairs( self.vehicle:getAttachedAIImplements()) do\n                                                                implement.object:aiImplementStartLine()\n                                                            end\n                                                        end\n                                                    end\n\n                                                    self.wasCompletelyFull = false\n                                                end\n\n                                                if currentPipeTargetState ~ = pipeState then\n                                                    combine:setPipeState(pipeState)\n                                                end\n\n                                                allowedToDrive = fillLevel < capacity\n\n                                                if turnOnAllowedStates ~ = nil and turnOnAllowedStates[currentPipeState] ~ = true then\n                                                    allowedToDrive = false\n                                                    if VehicleDebug.state = = VehicleDebug.DEBUG_AI then\n                                                        self.vehicle:addAIDebugText( "COMBINE -> Stopping AI because we cannot overload while harvesting" )\n                                                        end\n                                                    end\n\n                                                    if pipeState = = 2 and self.wasCompletelyFull then\n                                                        allowedToDrive = false\n                                                        if VehicleDebug.state = = VehicleDebug.DEBUG_AI then\n                                                            self.vehicle:addAIDebugText( "COMBINE -> Waiting for trailer to unload" )\n                                                            end\n                                                        end\n\n                                                        local freeFillLevel = capacity - fillLevel\n                                                        if freeFillLevel < self.slowDownFillLevel then\n                                                            -- we want to drive at least 2 km/h to avoid combine stops too early\n                                                            maxSpeed = 2 + (freeFillLevel / self.slowDownFillLevel) * self.slowDownStartSpeed\n\n                                                            if VehicleDebug.state = = VehicleDebug.DEBUG_AI then\n                                                                self.vehicle:addAIDebugText( string.format( "COMBINE -> Slow down because nearly full: %.2f" , maxSpeed))\n                                                            end\n                                                        end\n                                                    end\n\n                                                    if isTurning and trailerInTrigger and capacity ~ = math.huge then\n                                                        if combine:getCanDischargeToObject(dischargeNode) then\n                                                            local spec_combine = combine.spec_combine\n\n                                                            -- also include the delay buffer slots, so we fully empty the vehicle while a trailer is in range\n                                                                if spec_combine.loadingDelay > 0 then\n                                                                    for i = 1 , #spec_combine.loadingDelaySlots do\n                                                                        local slot = spec_combine.loadingDelaySlots[i]\n                                                                        if slot.valid then\n                                                                            fillLevel = fillLevel + slot.fillLevelDelta\n                                                                        end\n                                                                    end\n                                                                end\n\n                                                                if fillLevel > 0 then\n                                                                    allowedToDrive = false\n                                                                end\n\n                                                                if VehicleDebug.state = = VehicleDebug.DEBUG_AI then\n                                                                    if not allowedToDrive then\n                                                                        self.vehicle:addAIDebugText( "COMBINE -> Unload to trailer on headland" )\n                                                                    end\n                                                                end\n                                                            end\n                                                        end\n\n                                                        if not trailerInTrigger then\n                                                            if combine.spec_combine.isSwathActive then\n                                                                if combine.spec_combine.strawPSenabled then\n                                                                    waitForStraw = true\n                                                                end\n                                                            end\n                                                        end\n                                                    else\n                                                            local fillLevel = combine:getFillUnitFillLevel(combine.spec_combine.fillUnitIndex)\n                                                            if fillLevel < 0.1 then\n                                                                if not combine:getIsTurnedOn() and combine:getCanBeTurnedOn() then\n                                                                    combine:aiImplementStartLine()\n                                                                    for i, implement in ipairs( self.vehicle:getAttachedAIImplements()) do\n                                                                        implement.object:aiImplementStartLine()\n                                                                    end\n                                                                end\n                                                            end\n                                                        end\n                                                    end\n\n                                                    if isTurning and waitForStraw then\n                                                        if not self.waitForStrawModeActive then\n                                                            self.waitForStrawModeActive = true\n                                                            self.waitForStrawModeStartPosition[ 1 ], self.waitForStrawModeStartPosition[ 2 ] = vX, vZ\n                                                        end\n\n                                                        if VehicleDebug.state = = VehicleDebug.DEBUG_AI then\n                                                            self.vehicle:addAIDebugText( "COMBINE -> Waiting for straw to drop" )\n                                                            end\n\n                                                            local x, _, z = localToWorld( self.vehicle:getAIDirectionNode(), 0 , 0 , - 10 )\n                                                            local dist = MathUtil.vector2Length(vX - x, vZ - z)\n                                                            return x, z, false , 6 , dist\n                                                        else\n                                                                if self.waitForStrawModeActive then\n                                                                    self.waitForStrawModeActive = false\n                                                                    self.waitForStrawModeReturnToStart = true\n                                                                    self.waitForStrawModeLastPosition[ 1 ], self.waitForStrawModeLastPosition[ 2 ] = vX, vZ\n                                                                    self.waitForStrawModeReturnToStartDistance = MathUtil.vector2Length(vX - self.waitForStrawModeStartPosition[ 1 ], vZ - self.waitForStrawModeStartPosition[ 2 ])\n                                                                end\n\n                                                                if self.waitForStrawModeReturnToStart then\n                                                                    local movedDistance = MathUtil.vector2Length(vX - self.waitForStrawModeLastPosition[ 1 ], vZ - self.waitForStrawModeLastPosition[ 2 ])\n                                                                    self.waitForStrawModeLastPosition[ 1 ], self.waitForStrawModeLastPosition[ 2 ] = vX, vZ\n\n                                                                    self.waitForStrawModeReturnToStartDistance = self.waitForStrawModeReturnToStartDistance - movedDistance\n                                                                    if self.waitForStrawModeReturnToStartDistance < 0 then\n                                                                        self.waitForStrawModeReturnToStart = false\n                                                                    else\n                                                                            if VehicleDebug.state = = VehicleDebug.DEBUG_AI then\n                                                                                self.vehicle:addAIDebugText( string.format( "COMBINE -> Returning to turn start position(%.1fm)" , self.waitForStrawModeReturnToStartDistance))\n                                                                            end\n\n                                                                            local x, z = self.waitForStrawModeStartPosition[ 1 ], self.waitForStrawModeStartPosition[ 2 ]\n                                                                            local dist = MathUtil.vector2Length(vX - x, vZ - z)\n\n                                                                            return x, z, true , 10 , dist\n                                                                        end\n                                                                    end\n\n                                                                    if not allowedToDrive then\n                                                                        return 0 , 1 , true , 0 , math.huge\n                                                                    else\n                                                                            return nil , nil , nil , maxSpeed, nil\n                                                                        end\n                                                                    end\n                                                                end\n\n'})}),"\n",(0,l.jsx)(n.h3,{id:"new",children:"new"}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Description"})}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Definition"})}),"\n",(0,l.jsxs)(n.blockquote,{children:["\n",(0,l.jsx)(n.p,{children:"new()"}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,l.jsxs)(n.table,{children:[(0,l.jsx)(n.thead,{children:(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.th,{children:"any"}),(0,l.jsx)(n.th,{children:"reconstructionData"})]})}),(0,l.jsx)(n.tbody,{children:(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{children:"any"}),(0,l.jsx)(n.td,{children:"customMt"})]})})]}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Code"})}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-lua",children:"function AIDriveStrategyCombine.new(reconstructionData, customMt)\n    local self = AIDriveStrategy.new(reconstructionData, customMt or AIDriveStrategyCombine _mt)\n\n    self.combines = { }\n\n    self.notificationFullGrainTankShown = false\n    self.notificationGrainTankWarningShown = false\n\n    self.beaconLightsActive = false\n\n    self.slowDownFillLevel = 200\n    self.slowDownStartSpeed = 20\n\n    self.forageHarvesterFoundTimer = 0\n\n    self.waitForStrawModeActive = false\n    self.waitForStrawModeStartPosition = { 0 , 0 }\n    self.waitForStrawModeLastPosition = { 0 , 0 }\n    self.waitForStrawModeReturnToStart = false\n    self.waitForStrawModeReturnToStartDistance = 0\n\n    return self\nend\n\n"})}),"\n",(0,l.jsx)(n.h3,{id:"setaivehicle",children:"setAIVehicle"}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Description"})}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Definition"})}),"\n",(0,l.jsxs)(n.blockquote,{children:["\n",(0,l.jsx)(n.p,{children:"setAIVehicle()"}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,l.jsx)(n.table,{children:(0,l.jsx)(n.thead,{children:(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.th,{children:"any"}),(0,l.jsx)(n.th,{children:"vehicle"})]})})}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Code"})}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-lua",children:"function AIDriveStrategyCombine:setAIVehicle(vehicle)\n    AIDriveStrategyCombine:superClass().setAIVehicle( self , vehicle)\n\n    for _, childVehicle in pairs( self.vehicle.rootVehicle.childVehicles) do\n        if SpecializationUtil.hasSpecialization( Combine , childVehicle.specializations) then\n            table.insert( self.combines, childVehicle)\n        end\n    end\nend\n\n"})}),"\n",(0,l.jsx)(n.h3,{id:"update",children:"update"}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Description"})}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Definition"})}),"\n",(0,l.jsxs)(n.blockquote,{children:["\n",(0,l.jsx)(n.p,{children:"update()"}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,l.jsx)(n.table,{children:(0,l.jsx)(n.thead,{children:(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.th,{children:"any"}),(0,l.jsx)(n.th,{children:"dt"})]})})}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Code"})}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-lua",children:"function AIDriveStrategyCombine:update(dt)\n    for _, combine in pairs( self.combines) do\n        if combine.spec_pipe ~ = nil then\n            local capacity = 0\n\n            local dischargeNode = combine:getCurrentDischargeNode()\n            if dischargeNode ~ = nil then\n                capacity = combine:getFillUnitCapacity(dischargeNode.fillUnitIndex)\n            end\n\n            if capacity = = math.huge then\n                local rootVehicle = self.vehicle.rootVehicle\n                if rootVehicle.getAIFieldWorkerIsTurning ~ = nil and not rootVehicle:getAIFieldWorkerIsTurning() then\n                    local trailer = NetworkUtil.getObject(combine.spec_pipe.nearestObjectInTriggers.objectId)\n                    if trailer ~ = nil then\n                        local trailerFillUnitIndex = combine.spec_pipe.nearestObjectInTriggers.fillUnitIndex\n                        local fillType = combine:getDischargeFillType(dischargeNode)\n                        if fillType = = FillType.UNKNOWN then\n                            -- if nothing is in combine fillUnit we just check if we're targetting the trailer with the trailers first fill type or the current fill type if something is loaded\n                                fillType = trailer:getFillUnitFillType(trailerFillUnitIndex)\n                                if fillType = = FillType.UNKNOWN then\n                                    fillType = trailer:getFillUnitFirstSupportedFillType(trailerFillUnitIndex)\n                                end\n                                combine:setForcedFillTypeIndex(fillType)\n                            else\n                                    -- otherwise we check if the fill type of the combine is supported on the trailer\n                                        combine:setForcedFillTypeIndex( nil )\n                                    end\n                                end\n                            end\n                        end\n                    end\n                end\n            end\n\n"})}),"\n",(0,l.jsx)(n.h3,{id:"updatedriving",children:"updateDriving"}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Description"})}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Definition"})}),"\n",(0,l.jsxs)(n.blockquote,{children:["\n",(0,l.jsx)(n.p,{children:"updateDriving()"}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,l.jsx)(n.table,{children:(0,l.jsx)(n.thead,{children:(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.th,{children:"any"}),(0,l.jsx)(n.th,{children:"dt"})]})})}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Code"})}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-lua",children:"function AIDriveStrategyCombine:updateDriving(dt)\nend\n\n"})})]})}function h(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,l.jsx)(n,{...e,children:(0,l.jsx)(d,{...e})}):d(e)}},28453(e,n,i){i.d(n,{R:()=>a,x:()=>o});var t=i(96540);const l={},r=t.createContext(l);function a(e){const n=t.useContext(r);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(l):e.components||l:a(e.components),t.createElement(r.Provider,{value:n},e.children)}}}]);