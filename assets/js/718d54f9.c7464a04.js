"use strict";(globalThis.webpackChunkfs25_community_luadoc=globalThis.webpackChunkfs25_community_luadoc||[]).push([[355],{28453(n,e,l){l.d(e,{R:()=>d,x:()=>r});var t=l(96540);const i={},s=t.createContext(i);function d(n){const e=t.useContext(s);return t.useMemo(function(){return"function"==typeof n?n(e):{...e,...n}},[e,n])}function r(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(i):n.components||i:d(n.components),t.createElement(s.Provider,{value:e},n.children)}},62455(n,e,l){l.r(e),l.d(e,{assets:()=>o,contentTitle:()=>r,default:()=>h,frontMatter:()=>d,metadata:()=>t,toc:()=>c});const t=JSON.parse('{"id":"script/Utils/DynamicDataGrid","title":"DynamicDataGrid","description":"DynamicDataGrid","source":"@site/../docs/script/Utils/DynamicDataGrid.md","sourceDirName":"script/Utils","slug":"/script/Utils/DynamicDataGrid","permalink":"/FS25-Community-LUADOC/script/Utils/DynamicDataGrid","draft":false,"unlisted":false,"tags":[],"version":"current","lastUpdatedAt":1767161192000,"frontMatter":{},"sidebar":"docsSidebar","previous":{"title":"DataGrid","permalink":"/FS25-Community-LUADOC/script/Utils/DataGrid"},"next":{"title":"Fence","permalink":"/FS25-Community-LUADOC/script/Utils/Fence"}}');var i=l(74848),s=l(28453);const d={},r=void 0,o={},c=[{value:"DynamicDataGrid",id:"dynamicdatagrid",level:2},{value:"delete",id:"delete",level:3},{value:"getCellFromWorldPosition",id:"getcellfromworldposition",level:3},{value:"getGridIndicesByWorldPosition",id:"getgridindicesbyworldposition",level:3},{value:"getGridSnappedPosition",id:"getgridsnappedposition",level:3},{value:"getLocalIndicesByWorldPosition",id:"getlocalindicesbyworldposition",level:3},{value:"getWorldPositionByLocalIndices",id:"getworldpositionbylocalindices",level:3},{value:"new",id:"new",level:3}];function a(n){const e={a:"a",blockquote:"blockquote",code:"code",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,s.R)(),...n.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(e.h2,{id:"dynamicdatagrid",children:"DynamicDataGrid"}),"\n",(0,i.jsx)(e.p,{children:(0,i.jsx)(e.strong,{children:"Functions"})}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:(0,i.jsx)(e.a,{href:"#delete",children:"delete"})}),"\n",(0,i.jsx)(e.li,{children:(0,i.jsx)(e.a,{href:"#getcellfromworldposition",children:"getCellFromWorldPosition"})}),"\n",(0,i.jsx)(e.li,{children:(0,i.jsx)(e.a,{href:"#getgridindicesbyworldposition",children:"getGridIndicesByWorldPosition"})}),"\n",(0,i.jsx)(e.li,{children:(0,i.jsx)(e.a,{href:"#getgridsnappedposition",children:"getGridSnappedPosition"})}),"\n",(0,i.jsx)(e.li,{children:(0,i.jsx)(e.a,{href:"#getlocalindicesbyworldposition",children:"getLocalIndicesByWorldPosition"})}),"\n",(0,i.jsx)(e.li,{children:(0,i.jsx)(e.a,{href:"#getworldpositionbylocalindices",children:"getWorldPositionByLocalIndices"})}),"\n",(0,i.jsx)(e.li,{children:(0,i.jsx)(e.a,{href:"#new",children:"new"})}),"\n"]}),"\n",(0,i.jsx)(e.h3,{id:"delete",children:"delete"}),"\n",(0,i.jsx)(e.p,{children:(0,i.jsx)(e.strong,{children:"Description"})}),"\n",(0,i.jsxs)(e.blockquote,{children:["\n",(0,i.jsx)(e.p,{children:"Calls the delete function on every cell, then cleans up."}),"\n"]}),"\n",(0,i.jsx)(e.p,{children:(0,i.jsx)(e.strong,{children:"Definition"})}),"\n",(0,i.jsxs)(e.blockquote,{children:["\n",(0,i.jsx)(e.p,{children:"delete()"}),"\n"]}),"\n",(0,i.jsx)(e.p,{children:(0,i.jsx)(e.strong,{children:"Code"})}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-lua",children:"function DynamicDataGrid:delete()\n\n    -- Go over each cell in the data.\n    for columnIndex = self.localStartIndex, self.localEndIndex do\n        for rowIndex = self.localStartIndex, self.localEndIndex do\n\n            -- Get the cell.\n            local cell = self:getCellFromLocalIndices(columnIndex, rowIndex)\n\n            -- If the cell has a delete function, call it.\n                if cell and cell.delete then\n                    cell:delete()\n                end\n            end\n        end\n\n        -- Unset the grid.\n        self.grid = nil\n    end\n\n"})}),"\n",(0,i.jsx)(e.h3,{id:"getcellfromworldposition",children:"getCellFromWorldPosition"}),"\n",(0,i.jsx)(e.p,{children:(0,i.jsx)(e.strong,{children:"Description"})}),"\n",(0,i.jsxs)(e.blockquote,{children:["\n",(0,i.jsx)(e.p,{children:"Gets and returns the cell that exists at the given world position."}),"\n"]}),"\n",(0,i.jsx)(e.p,{children:(0,i.jsx)(e.strong,{children:"Definition"})}),"\n",(0,i.jsxs)(e.blockquote,{children:["\n",(0,i.jsx)(e.p,{children:"getCellFromWorldPosition(float worldX, float worldZ, boolean clamp)"}),"\n"]}),"\n",(0,i.jsx)(e.p,{children:(0,i.jsx)(e.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,i.jsxs)(e.table,{children:[(0,i.jsx)(e.thead,{children:(0,i.jsxs)(e.tr,{children:[(0,i.jsx)(e.th,{children:"float"}),(0,i.jsx)(e.th,{children:"worldX"}),(0,i.jsx)(e.th,{children:"The x position in the world."})]})}),(0,i.jsxs)(e.tbody,{children:[(0,i.jsxs)(e.tr,{children:[(0,i.jsx)(e.td,{children:"float"}),(0,i.jsx)(e.td,{children:"worldZ"}),(0,i.jsx)(e.td,{children:"The z position in the world."})]}),(0,i.jsxs)(e.tr,{children:[(0,i.jsx)(e.td,{children:"boolean"}),(0,i.jsx)(e.td,{children:"clamp"}),(0,i.jsx)(e.td,{children:"True if the position should be clamped within the grid; defaults to false."})]})]})]}),"\n",(0,i.jsx)(e.p,{children:(0,i.jsx)(e.strong,{children:"Return Values"})}),"\n\n\n\n\n\n\n\n\n",(0,i.jsx)(e.table,{children:(0,i.jsx)(e.thead,{children:(0,i.jsxs)(e.tr,{children:[(0,i.jsx)(e.th,{children:"boolean"}),(0,i.jsx)(e.th,{children:"cell"}),(0,i.jsx)(e.th,{children:"The cell at the given position, or nil if none was found."})]})})}),"\n",(0,i.jsx)(e.p,{children:(0,i.jsx)(e.strong,{children:"Code"})}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-lua",children:"function DynamicDataGrid:getCellFromWorldPosition(worldX, worldZ, clamp)\n\n    -- Calculate the indices.\n    local xIndex, zIndex = self:getLocalIndicesByWorldPosition(worldX, worldZ)\n\n    -- If the indices should be clamped, do so.\n        if clamp then\n            xIndex = math.clamp(xIndex, self.localStartIndex, self.localEndIndex)\n            zIndex = math.clamp(zIndex, self.localStartIndex, self.localEndIndex)\n        end\n\n        -- Get the row.\n        local xrows = self.grid[ self.centreIndex + xIndex]\n\n        -- If the row exists, return the cell at the column on the row.\n        if xrows ~ = nil then\n            return xrows[ self.centreIndex + zIndex]\n        end\n\n        -- Return nil if nothing was found.\n            return nil\n        end\n\n"})}),"\n",(0,i.jsx)(e.h3,{id:"getgridindicesbyworldposition",children:"getGridIndicesByWorldPosition"}),"\n",(0,i.jsx)(e.p,{children:(0,i.jsx)(e.strong,{children:"Description"})}),"\n",(0,i.jsxs)(e.blockquote,{children:["\n",(0,i.jsx)(e.p,{children:"Gets the grid indices of the given position. The grid index is from 1 - rowColumnCount, essentially allowing the\nunderlying 2D array to be indexed."}),"\n"]}),"\n",(0,i.jsx)(e.p,{children:(0,i.jsx)(e.strong,{children:"Definition"})}),"\n",(0,i.jsxs)(e.blockquote,{children:["\n",(0,i.jsx)(e.p,{children:"getGridIndicesByWorldPosition(float worldX, float worldZ)"}),"\n"]}),"\n",(0,i.jsx)(e.p,{children:(0,i.jsx)(e.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,i.jsxs)(e.table,{children:[(0,i.jsx)(e.thead,{children:(0,i.jsxs)(e.tr,{children:[(0,i.jsx)(e.th,{children:"float"}),(0,i.jsx)(e.th,{children:"worldX"}),(0,i.jsx)(e.th,{children:"The x position in the world."})]})}),(0,i.jsx)(e.tbody,{children:(0,i.jsxs)(e.tr,{children:[(0,i.jsx)(e.td,{children:"float"}),(0,i.jsx)(e.td,{children:"worldZ"}),(0,i.jsx)(e.td,{children:"The z position in the world."})]})})]}),"\n",(0,i.jsx)(e.p,{children:(0,i.jsx)(e.strong,{children:"Return Values"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,i.jsxs)(e.table,{children:[(0,i.jsx)(e.thead,{children:(0,i.jsxs)(e.tr,{children:[(0,i.jsx)(e.th,{children:"float"}),(0,i.jsx)(e.th,{children:"indexX"}),(0,i.jsx)(e.th,{children:"The x index of the position."})]})}),(0,i.jsx)(e.tbody,{children:(0,i.jsxs)(e.tr,{children:[(0,i.jsx)(e.td,{children:"float"}),(0,i.jsx)(e.td,{children:"indexZ"}),(0,i.jsx)(e.td,{children:"The z index of the position."})]})})]}),"\n",(0,i.jsx)(e.p,{children:(0,i.jsx)(e.strong,{children:"Code"})}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-lua",children:"function DynamicDataGrid:getGridIndicesByWorldPosition(worldX, worldZ)\n\n    local worldIndexX, worldIndexZ = self:getWorldIndicesByWorldPosition(worldX, worldZ)\n    local currentIndexX, currentIndexZ = self:getWorldIndicesByWorldPosition( self.lastPosition.x, self.lastPosition.z)\n\n    -- Convert the position to an index, then offset it by the centre index to map it to 1 - rowColumnCount.\n    worldIndexX = (worldIndexX - currentIndexX) + self.centreIndex\n    worldIndexZ = (worldIndexZ - currentIndexZ) + self.centreIndex\n\n    return worldIndexX, worldIndexZ\nend\n\n"})}),"\n",(0,i.jsx)(e.h3,{id:"getgridsnappedposition",children:"getGridSnappedPosition"}),"\n",(0,i.jsx)(e.p,{children:(0,i.jsx)(e.strong,{children:"Description"})}),"\n",(0,i.jsxs)(e.blockquote,{children:["\n",(0,i.jsx)(e.p,{children:"Calculates and returns the given position snapped to the grid."}),"\n"]}),"\n",(0,i.jsx)(e.p,{children:(0,i.jsx)(e.strong,{children:"Definition"})}),"\n",(0,i.jsxs)(e.blockquote,{children:["\n",(0,i.jsx)(e.p,{children:"getGridSnappedPosition(float x, float z)"}),"\n"]}),"\n",(0,i.jsx)(e.p,{children:(0,i.jsx)(e.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,i.jsxs)(e.table,{children:[(0,i.jsx)(e.thead,{children:(0,i.jsxs)(e.tr,{children:[(0,i.jsx)(e.th,{children:"float"}),(0,i.jsx)(e.th,{children:"x"}),(0,i.jsx)(e.th,{children:"The x position."})]})}),(0,i.jsx)(e.tbody,{children:(0,i.jsxs)(e.tr,{children:[(0,i.jsx)(e.td,{children:"float"}),(0,i.jsx)(e.td,{children:"z"}),(0,i.jsx)(e.td,{children:"The z position."})]})})]}),"\n",(0,i.jsx)(e.p,{children:(0,i.jsx)(e.strong,{children:"Return Values"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,i.jsxs)(e.table,{children:[(0,i.jsx)(e.thead,{children:(0,i.jsxs)(e.tr,{children:[(0,i.jsx)(e.th,{children:"float"}),(0,i.jsx)(e.th,{children:"snappedX"}),(0,i.jsx)(e.th,{children:"The snapped x position."})]})}),(0,i.jsx)(e.tbody,{children:(0,i.jsxs)(e.tr,{children:[(0,i.jsx)(e.td,{children:"float"}),(0,i.jsx)(e.td,{children:"snappedZ"}),(0,i.jsx)(e.td,{children:"The snapped z position."})]})})]}),"\n",(0,i.jsx)(e.p,{children:(0,i.jsx)(e.strong,{children:"Code"})}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-lua",children:"function DynamicDataGrid:getGridSnappedPosition(x, z)\n\n    local snappedX = math.floor(x / self.tileSize) * self.tileSize\n    local snappedZ = math.floor(z / self.tileSize) * self.tileSize\n\n    -- Apply the half cell offset to the position.\n    snappedX = snappedX + ( self.tileSize / 2.0 )\n    snappedZ = snappedZ + ( self.tileSize / 2.0 )\n\n    return snappedX, snappedZ\nend\n\n"})}),"\n",(0,i.jsx)(e.h3,{id:"getlocalindicesbyworldposition",children:"getLocalIndicesByWorldPosition"}),"\n",(0,i.jsx)(e.p,{children:(0,i.jsx)(e.strong,{children:"Description"})}),"\n",(0,i.jsxs)(e.blockquote,{children:["\n",(0,i.jsx)(e.p,{children:"Calculates and returns the index relative to the position of the grid, so that the index 0, 0 is the centre of the\ngrid."}),"\n"]}),"\n",(0,i.jsx)(e.p,{children:(0,i.jsx)(e.strong,{children:"Definition"})}),"\n",(0,i.jsxs)(e.blockquote,{children:["\n",(0,i.jsx)(e.p,{children:"getLocalIndicesByWorldPosition(float worldX, float worldZ)"}),"\n"]}),"\n",(0,i.jsx)(e.p,{children:(0,i.jsx)(e.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,i.jsxs)(e.table,{children:[(0,i.jsx)(e.thead,{children:(0,i.jsxs)(e.tr,{children:[(0,i.jsx)(e.th,{children:"float"}),(0,i.jsx)(e.th,{children:"worldX"}),(0,i.jsx)(e.th,{children:"The x position in the world."})]})}),(0,i.jsx)(e.tbody,{children:(0,i.jsxs)(e.tr,{children:[(0,i.jsx)(e.td,{children:"float"}),(0,i.jsx)(e.td,{children:"worldZ"}),(0,i.jsx)(e.td,{children:"The z position in the world."})]})})]}),"\n",(0,i.jsx)(e.p,{children:(0,i.jsx)(e.strong,{children:"Return Values"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,i.jsxs)(e.table,{children:[(0,i.jsx)(e.thead,{children:(0,i.jsxs)(e.tr,{children:[(0,i.jsx)(e.th,{children:"float"}),(0,i.jsx)(e.th,{children:"indexX"}),(0,i.jsx)(e.th,{children:"The local x index of the position."})]})}),(0,i.jsx)(e.tbody,{children:(0,i.jsxs)(e.tr,{children:[(0,i.jsx)(e.td,{children:"float"}),(0,i.jsx)(e.td,{children:"indexZ"}),(0,i.jsx)(e.td,{children:"The local z index of the position."})]})})]}),"\n",(0,i.jsx)(e.p,{children:(0,i.jsx)(e.strong,{children:"Code"})}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-lua",children:"function DynamicDataGrid:getLocalIndicesByWorldPosition(worldX, worldZ)\n\n    local currentIndexX, currentIndexZ = self:getWorldIndicesByWorldPosition( self.lastPosition.x, self.lastPosition.z)\n    local worldIndexX, worldIndexZ = self:getWorldIndicesByWorldPosition(worldX, worldZ)\n\n    -- Convert the position to an index.\n    local localIndexX = (worldIndexX - currentIndexX)\n    local localIndexZ = (worldIndexZ - currentIndexZ)\n\n    return localIndexX, localIndexZ\nend\n\n"})}),"\n",(0,i.jsx)(e.h3,{id:"getworldpositionbylocalindices",children:"getWorldPositionByLocalIndices"}),"\n",(0,i.jsx)(e.p,{children:(0,i.jsx)(e.strong,{children:"Description"})}),"\n",(0,i.jsxs)(e.blockquote,{children:["\n",(0,i.jsx)(e.p,{children:"Calculates the world position of the centre of the cell at the position defined by the current position and given cell\noffset."}),"\n"]}),"\n",(0,i.jsx)(e.p,{children:(0,i.jsx)(e.strong,{children:"Definition"})}),"\n",(0,i.jsxs)(e.blockquote,{children:["\n",(0,i.jsx)(e.p,{children:"getWorldPositionByLocalIndices(float localIndexX, float localIndexZ)"}),"\n"]}),"\n",(0,i.jsx)(e.p,{children:(0,i.jsx)(e.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,i.jsxs)(e.table,{children:[(0,i.jsx)(e.thead,{children:(0,i.jsxs)(e.tr,{children:[(0,i.jsx)(e.th,{children:"float"}),(0,i.jsx)(e.th,{children:"localIndexX"}),(0,i.jsx)(e.th,{children:"The x index of the cell relative to the centre cell."})]})}),(0,i.jsx)(e.tbody,{children:(0,i.jsxs)(e.tr,{children:[(0,i.jsx)(e.td,{children:"float"}),(0,i.jsx)(e.td,{children:"localIndexZ"}),(0,i.jsx)(e.td,{children:"The z index of the cell relative to the centre cell."})]})})]}),"\n",(0,i.jsx)(e.p,{children:(0,i.jsx)(e.strong,{children:"Return Values"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,i.jsxs)(e.table,{children:[(0,i.jsx)(e.thead,{children:(0,i.jsxs)(e.tr,{children:[(0,i.jsx)(e.th,{children:"float"}),(0,i.jsx)(e.th,{children:"worldX"}),(0,i.jsx)(e.th,{children:"The world x position of the centre of the cell."})]})}),(0,i.jsx)(e.tbody,{children:(0,i.jsxs)(e.tr,{children:[(0,i.jsx)(e.td,{children:"float"}),(0,i.jsx)(e.td,{children:"worldZ"}),(0,i.jsx)(e.td,{children:"The world z position of the centre of the cell."})]})})]}),"\n",(0,i.jsx)(e.p,{children:(0,i.jsx)(e.strong,{children:"Code"})}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-lua",children:"function DynamicDataGrid:getWorldPositionByLocalIndices(localIndexX, localIndexZ)\n\n    local currentIndexX, currentIndexZ = self:getWorldIndicesByWorldPosition( self.lastPosition.x, self.lastPosition.z)\n\n    -- Return the world position.\n    return self:getGridSnappedPositionByLocalIndices(currentIndexX + localIndexX, currentIndexZ + localIndexZ)\nend\n\n"})}),"\n",(0,i.jsx)(e.h3,{id:"new",children:"new"}),"\n",(0,i.jsx)(e.p,{children:(0,i.jsx)(e.strong,{children:"Description"})}),"\n",(0,i.jsxs)(e.blockquote,{children:["\n",(0,i.jsx)(e.p,{children:"Creating dynamic data grid"}),"\n"]}),"\n",(0,i.jsx)(e.p,{children:(0,i.jsx)(e.strong,{children:"Definition"})}),"\n",(0,i.jsxs)(e.blockquote,{children:["\n",(0,i.jsx)(e.p,{children:"new()"}),"\n"]}),"\n",(0,i.jsx)(e.p,{children:(0,i.jsx)(e.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,i.jsxs)(e.table,{children:[(0,i.jsx)(e.thead,{children:(0,i.jsxs)(e.tr,{children:[(0,i.jsx)(e.th,{children:"any"}),(0,i.jsx)(e.th,{children:"size"})]})}),(0,i.jsxs)(e.tbody,{children:[(0,i.jsxs)(e.tr,{children:[(0,i.jsx)(e.td,{children:"any"}),(0,i.jsx)(e.td,{children:"tileSize"})]}),(0,i.jsxs)(e.tr,{children:[(0,i.jsx)(e.td,{children:"any"}),(0,i.jsx)(e.td,{children:"startX"})]}),(0,i.jsxs)(e.tr,{children:[(0,i.jsx)(e.td,{children:"any"}),(0,i.jsx)(e.td,{children:"startZ"})]}),(0,i.jsxs)(e.tr,{children:[(0,i.jsx)(e.td,{children:"any"}),(0,i.jsx)(e.td,{children:"cellConstructor"})]}),(0,i.jsxs)(e.tr,{children:[(0,i.jsx)(e.td,{children:"any"}),(0,i.jsx)(e.td,{children:"customMt"})]})]})]}),"\n",(0,i.jsx)(e.p,{children:(0,i.jsx)(e.strong,{children:"Code"})}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-lua",children:'function DynamicDataGrid.new(size, tileSize, startX, startZ, cellConstructor, customMt)\n\n    -- Ensure the arguments are valid.\n    --#debug assert(size ~ = nil, "Grid size was missing")\n    --#debug assert(type(size) = = "number", "Grid size was not number")\n    --#debug assert(size > 0, "Grid size was 0 or lower")\n\n    --#debug assert(tileSize ~ = nil, "Tile size was missing")\n    --#debug assert(type(tileSize) = = "number", "Tile size was not number")\n    --#debug assert(tileSize > 0, "Tile size was 0 or lower")\n\n    --#debug if startX ~ = nil then\n        --#debug assert(type(startX) = = "number", "Starting x position was not a number")\n        --#debug assert(startZ ~ = nil, "Starting x position was given, but not z position")\n        --#debug assert(type(startZ) = = "number", "Starting z position was not a number")\n        --#debug end\n        --#debug if startZ ~ = nil then\n            --#debug assert(startX ~ = nil, "Starting z position was given, but not x position")\n            --#debug assert(type(startZ) = = "number", "Starting z position was not a number")\n            --#debug end\n\n            --#debug if cellConstructor ~ = nil then\n                --#debug assert(type(cellConstructor) = = "function", "Given cell constructor was not a function")\n                    --#debug end\n\n                    -- Create the instance.\n                    local self = setmetatable( { } , customMt or DynamicDataGrid _mt)\n\n                    -- The size variables.\n                    self.tileSize = tileSize or 1\n                    self.size = size or 20\n                    self.rowColumnCount = math.ceil( self.size / self.tileSize)\n\n                    -- Calculate the centre index.\n                    self.centreIndex = math.floor( self.rowColumnCount * 0.5 ) + 1\n                    self.localStartIndex = 1 - self.centreIndex\n                    self.localEndIndex = ( self.localStartIndex + self.rowColumnCount) - 1\n\n                    -- The last set position and its related indices.\n                    self.lastPosition = { x = 0 , z = 0 }\n\n                    -- Set the positional data if a position was given.\n                        if startX and startZ then\n                            self.lastPosition.x = startX\n                            self.lastPosition.z = startZ\n                        end\n\n                        -- Keep track of any cells that get moved.\n                        self.movedCells = { }\n\n                        -- Create the grid.\n                        self.grid = { }\n                        for columnIndex = self.localStartIndex, self.localEndIndex do\n\n                            -- Create the column.\n                            local column = { }\n\n                            -- Add each cell to the column.If a constructor was given, use that; otherwise just create an empty table.\n                            for rowIndex = self.localStartIndex, self.localEndIndex do\n                                local cell\n                                if cellConstructor then\n                                    local cellWorldX, cellWorldZ = self:getWorldPositionByLocalIndices(columnIndex, rowIndex)\n                                    cell = cellConstructor(cellWorldX, cellWorldZ)\n                                else\n                                        cell = { }\n                                    end\n                                    table.insert(column, cell)\n                                end\n\n                                -- Insert the column into the grid.\n                                table.insert( self.grid, column)\n                            end\n\n                            -- The y offset.\n                            self.yOffset = 0.05\n\n                            -- Return the created instance.\n                            return self\n                        end\n\n'})})]})}function h(n={}){const{wrapper:e}={...(0,s.R)(),...n.components};return e?(0,i.jsx)(e,{...n,children:(0,i.jsx)(a,{...n})}):a(n)}}}]);