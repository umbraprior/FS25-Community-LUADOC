"use strict";(globalThis.webpackChunkfs25_community_luadoc=globalThis.webpackChunkfs25_community_luadoc||[]).push([[60668],{28453(e,n,t){t.d(n,{R:()=>l,x:()=>a});var i=t(96540);const s={},r=i.createContext(s);function l(e){const n=i.useContext(r);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:l(e.components),i.createElement(r.Provider,{value:n},e.children)}},36670(e,n,t){t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>a,default:()=>h,frontMatter:()=>l,metadata:()=>i,toc:()=>o});const i=JSON.parse('{"id":"script/Specializations/WoodHarvester","title":"WoodHarvester","description":"WoodHarvester","source":"@site/../docs/script/Specializations/WoodHarvester.md","sourceDirName":"script/Specializations","slug":"/script/Specializations/WoodHarvester","permalink":"/FS25-Community-LUADOC/script/Specializations/WoodHarvester","draft":false,"unlisted":false,"tags":[],"version":"current","lastUpdatedAt":1767161192000,"frontMatter":{},"sidebar":"docsSidebar","previous":{"title":"WoodCrusher","permalink":"/FS25-Community-LUADOC/script/Specializations/WoodCrusher"},"next":{"title":"WorkArea","permalink":"/FS25-Community-LUADOC/script/Specializations/WorkArea"}}');var s=t(74848),r=t(28453);const l={},a=void 0,c={},o=[{value:"WoodHarvester",id:"woodharvester",level:2},{value:"actionEventCutTree",id:"actioneventcuttree",level:3},{value:"actionEventDropTree",id:"actioneventdroptree",level:3},{value:"actionEventSetCutlength",id:"actioneventsetcutlength",level:3},{value:"actionEventTiltHeader",id:"actioneventtiltheader",level:3},{value:"cutTree",id:"cuttree",level:3},{value:"dropWoodHarvesterTree",id:"dropwoodharvestertree",level:3},{value:"findSplitShapesInRange",id:"findsplitshapesinrange",level:3},{value:"getAutoAlignHasValidTree",id:"getautoalignhasvalidtree",level:3},{value:"getCanBeSelected",id:"getcanbeselected",level:3},{value:"getCanSplitShapeBeAccessed",id:"getcansplitshapebeaccessed",level:3},{value:"getConsumingLoad",id:"getconsumingload",level:3},{value:"getDoConsumePtoPower",id:"getdoconsumeptopower",level:3},{value:"getIsAutoTreeAlignmentAllowed",id:"getisautotreealignmentallowed",level:3},{value:"getIsFoldAllowed",id:"getisfoldallowed",level:3},{value:"getIsWoodHarvesterTiltStateAllowed",id:"getiswoodharvestertiltstateallowed",level:3},{value:"getSpecValueMaxTreeSize",id:"getspecvaluemaxtreesize",level:3},{value:"getSupportsAutoTreeAlignment",id:"getsupportsautotreealignment",level:3},{value:"initSpecialization",id:"initspecialization",level:3},{value:"loadSpecValueMaxTreeSize",id:"loadspecvaluemaxtreesize",level:3},{value:"loadWoodHarvesterHeaderTiltFromXML",id:"loadwoodharvesterheadertiltfromxml",level:3},{value:"onCutTree",id:"oncuttree",level:3},{value:"onDeactivate",id:"ondeactivate",level:3},{value:"onDelete",id:"ondelete",level:3},{value:"onDelimbTree",id:"ondelimbtree",level:3},{value:"onDraw",id:"ondraw",level:3},{value:"onLoad",id:"onload",level:3},{value:"onLoadFinished",id:"onloadfinished",level:3},{value:"onPostLoad",id:"onpostload",level:3},{value:"onReadStream",id:"onreadstream",level:3},{value:"onReadUpdateStream",id:"onreadupdatestream",level:3},{value:"onRegisterActionEvents",id:"onregisteractionevents",level:3},{value:"onRegisterDashboardValueTypes",id:"onregisterdashboardvaluetypes",level:3},{value:"onStateChange",id:"onstatechange",level:3},{value:"onTurnedOff",id:"onturnedoff",level:3},{value:"onTurnedOn",id:"onturnedon",level:3},{value:"onUpdate",id:"onupdate",level:3},{value:"onUpdateTick",id:"onupdatetick",level:3},{value:"onVehicleSettingChanged",id:"onvehiclesettingchanged",level:3},{value:"onWriteStream",id:"onwritestream",level:3},{value:"onWriteUpdateStream",id:"onwriteupdatestream",level:3},{value:"prerequisitesPresent",id:"prerequisitespresent",level:3},{value:"registerEventListeners",id:"registereventlisteners",level:3},{value:"registerEvents",id:"registerevents",level:3},{value:"registerFunctions",id:"registerfunctions",level:3},{value:"registerOverwrittenFunctions",id:"registeroverwrittenfunctions",level:3},{value:"saveToXMLFile",id:"savetoxmlfile",level:3},{value:"setLastTreeDiameter",id:"setlasttreediameter",level:3},{value:"setWoodHarvesterCutLengthIndex",id:"setwoodharvestercutlengthindex",level:3},{value:"setWoodHarvesterTiltState",id:"setwoodharvestertiltstate",level:3},{value:"woodHarvesterSplitShapeCallback",id:"woodharvestersplitshapecallback",level:3}];function d(e){const n={a:"a",blockquote:"blockquote",code:"code",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,r.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.h2,{id:"woodharvester",children:"WoodHarvester"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"Specialization for wood harvesters including grabbing, felling, delimbing and cutting of certrain types of trees"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Functions"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#actioneventcuttree",children:"actionEventCutTree"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#actioneventdroptree",children:"actionEventDropTree"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#actioneventsetcutlength",children:"actionEventSetCutlength"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#actioneventtiltheader",children:"actionEventTiltHeader"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#cuttree",children:"cutTree"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#dropwoodharvestertree",children:"dropWoodHarvesterTree"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#findsplitshapesinrange",children:"findSplitShapesInRange"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#getautoalignhasvalidtree",children:"getAutoAlignHasValidTree"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#getcanbeselected",children:"getCanBeSelected"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#getcansplitshapebeaccessed",children:"getCanSplitShapeBeAccessed"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#getconsumingload",children:"getConsumingLoad"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#getdoconsumeptopower",children:"getDoConsumePtoPower"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#getisautotreealignmentallowed",children:"getIsAutoTreeAlignmentAllowed"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#getisfoldallowed",children:"getIsFoldAllowed"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#getiswoodharvestertiltstateallowed",children:"getIsWoodHarvesterTiltStateAllowed"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#getspecvaluemaxtreesize",children:"getSpecValueMaxTreeSize"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#getsupportsautotreealignment",children:"getSupportsAutoTreeAlignment"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#initspecialization",children:"initSpecialization"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#loadspecvaluemaxtreesize",children:"loadSpecValueMaxTreeSize"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#loadwoodharvesterheadertiltfromxml",children:"loadWoodHarvesterHeaderTiltFromXML"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#oncuttree",children:"onCutTree"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#ondeactivate",children:"onDeactivate"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#ondelete",children:"onDelete"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#ondelimbtree",children:"onDelimbTree"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#ondraw",children:"onDraw"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#onload",children:"onLoad"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#onloadfinished",children:"onLoadFinished"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#onpostload",children:"onPostLoad"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#onreadstream",children:"onReadStream"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#onreadupdatestream",children:"onReadUpdateStream"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#onregisteractionevents",children:"onRegisterActionEvents"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#onregisterdashboardvaluetypes",children:"onRegisterDashboardValueTypes"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#onstatechange",children:"onStateChange"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#onturnedoff",children:"onTurnedOff"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#onturnedon",children:"onTurnedOn"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#onupdate",children:"onUpdate"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#onupdatetick",children:"onUpdateTick"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#onvehiclesettingchanged",children:"onVehicleSettingChanged"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#onwritestream",children:"onWriteStream"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#onwriteupdatestream",children:"onWriteUpdateStream"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#prerequisitespresent",children:"prerequisitesPresent"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#registereventlisteners",children:"registerEventListeners"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#registerevents",children:"registerEvents"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#registerfunctions",children:"registerFunctions"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#registeroverwrittenfunctions",children:"registerOverwrittenFunctions"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#savetoxmlfile",children:"saveToXMLFile"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#setlasttreediameter",children:"setLastTreeDiameter"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#setwoodharvestercutlengthindex",children:"setWoodHarvesterCutLengthIndex"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#setwoodharvestertiltstate",children:"setWoodHarvesterTiltState"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#woodharvestersplitshapecallback",children:"woodHarvesterSplitShapeCallback"})}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"actioneventcuttree",children:"actionEventCutTree"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Definition"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"actionEventCutTree()"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"any"}),(0,s.jsx)(n.th,{children:"self"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"any"}),(0,s.jsx)(n.td,{children:"actionName"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"any"}),(0,s.jsx)(n.td,{children:"inputValue"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"any"}),(0,s.jsx)(n.td,{children:"callbackState"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"any"}),(0,s.jsx)(n.td,{children:"isAnalog"})]})]})]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Code"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:"function WoodHarvester.actionEventCutTree( self , actionName, inputValue, callbackState, isAnalog)\n    local spec = self.spec_woodHarvester\n    if self:getIsTurnedOn() then\n        if g_ time - spec.lastCutEventTime > spec.cutEventCoolDownTime then\n            if spec.hasAttachedSplitShape then\n                if not spec.isAttachedSplitShapeMoving and self:getAnimationTime(spec.cutAnimation.name) = = 1 then\n                    if spec.automaticCuttingIsDirty then\n                        self:cutTree( 0 )\n                        spec.lastCutEventTime = g_ time\n                    else\n                            self:cutTree(spec.currentCutLength)\n                            spec.lastCutEventTime = g_ time\n                        end\n                    end\n                elseif spec.curSplitShape ~ = nil and spec.cutTimer = = - 1 then\n                        self:cutTree( 0 )\n                        spec.lastCutEventTime = g_ time\n                    end\n                end\n            else\n                    g_currentMission:showBlinkingWarning(spec.texts.warningFirstTurnOnTheTool, 2000 )\n                end\n            end\n\n"})}),"\n",(0,s.jsx)(n.h3,{id:"actioneventdroptree",children:"actionEventDropTree"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Definition"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"actionEventDropTree()"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"any"}),(0,s.jsx)(n.th,{children:"self"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"any"}),(0,s.jsx)(n.td,{children:"actionName"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"any"}),(0,s.jsx)(n.td,{children:"inputValue"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"any"}),(0,s.jsx)(n.td,{children:"callbackState"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"any"}),(0,s.jsx)(n.td,{children:"isAnalog"})]})]})]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Code"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:"function WoodHarvester.actionEventDropTree( self , actionName, inputValue, callbackState, isAnalog)\n    self:dropWoodHarvesterTree()\nend\n\n"})}),"\n",(0,s.jsx)(n.h3,{id:"actioneventsetcutlength",children:"actionEventSetCutlength"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Definition"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"actionEventSetCutlength()"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"any"}),(0,s.jsx)(n.th,{children:"self"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"any"}),(0,s.jsx)(n.td,{children:"actionName"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"any"}),(0,s.jsx)(n.td,{children:"inputValue"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"any"}),(0,s.jsx)(n.td,{children:"callbackState"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"any"}),(0,s.jsx)(n.td,{children:"isAnalog"})]})]})]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Code"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:"function WoodHarvester.actionEventSetCutlength( self , actionName, inputValue, callbackState, isAnalog)\n    local spec = self.spec_woodHarvester\n\n    if not spec.isAttachedSplitShapeMoving then\n        local cutLengthIndex = spec.currentCutLengthIndex + callbackState\n        if cutLengthIndex > #spec.cutLengths then\n            cutLengthIndex = 1\n        elseif cutLengthIndex < 1 then\n                cutLengthIndex = #spec.cutLengths\n            end\n\n            self:setWoodHarvesterCutLengthIndex(cutLengthIndex)\n        end\n    end\n\n"})}),"\n",(0,s.jsx)(n.h3,{id:"actioneventtiltheader",children:"actionEventTiltHeader"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Definition"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"actionEventTiltHeader()"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"any"}),(0,s.jsx)(n.th,{children:"self"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"any"}),(0,s.jsx)(n.td,{children:"actionName"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"any"}),(0,s.jsx)(n.td,{children:"inputValue"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"any"}),(0,s.jsx)(n.td,{children:"callbackState"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"any"}),(0,s.jsx)(n.td,{children:"isAnalog"})]})]})]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Code"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:"function WoodHarvester.actionEventTiltHeader( self , actionName, inputValue, callbackState, isAnalog)\n    local spec = self.spec_woodHarvester\n\n    if self:getIsWoodHarvesterTiltStateAllowed(spec.headerJointTilt) and not spec.hasAttachedSplitShape then\n        self:setWoodHarvesterTiltState()\n    end\nend\n\n"})}),"\n",(0,s.jsx)(n.h3,{id:"cuttree",children:"cutTree"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Definition"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"cutTree()"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"any"}),(0,s.jsx)(n.th,{children:"length"})]})}),(0,s.jsx)(n.tbody,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"any"}),(0,s.jsx)(n.td,{children:"noEventSend"})]})})]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Code"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:"function WoodHarvester:cutTree(length, noEventSend)\n    local spec = self.spec_woodHarvester\n    WoodHarvesterCutTreeEvent.sendEvent( self , length, noEventSend)\n    if self.isServer then\n        if length = = 0 then\n            if spec.attachedSplitShape ~ = nil or spec.curSplitShape ~ = nil then\n                -- while we pick up trees from the ground we skip the cutting\n                    if spec.attachedSplitShape = = nil and spec.curSplitShape ~ = nil and getRigidBodyType(spec.curSplitShape) ~ = RigidBodyType.STATIC then\n                        spec.cutTimer = 0\n                        if spec.cutAnimation.name ~ = nil then\n                            self:setAnimationTime(spec.cutAnimation.name, 0 , true )\n                            self:playAnimation(spec.cutAnimation.name, 999999 , self:getAnimationTime(spec.cutAnimation.name))\n                        end\n                    else\n                            spec.cutTimer = 100\n                            if spec.cutAnimation.name ~ = nil then\n                                self:setAnimationTime(spec.cutAnimation.name, 0 , true )\n                                self:playAnimation(spec.cutAnimation.name, spec.cutAnimation.speedScale, self:getAnimationTime(spec.cutAnimation.name))\n                            end\n                        end\n                    end\n                elseif length > 0 and spec.attachedSplitShape ~ = nil then\n                        spec.attachedSplitShapeTargetY = spec.attachedSplitShapeLastCutY + length * spec.cutAttachDirection\n\n                        self:onDelimbTree( true )\n                        if g_server ~ = nil then\n                            g_server:broadcastEvent( WoodHarvesterOnDelimbTreeEvent.new( self , true ), nil , nil , self )\n                        end\n                    end\n                end\n\n                spec.automaticCuttingIsDirty = false\n            end\n\n"})}),"\n",(0,s.jsx)(n.h3,{id:"dropwoodharvestertree",children:"dropWoodHarvesterTree"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Definition"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"dropWoodHarvesterTree()"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,s.jsx)(n.table,{children:(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"any"}),(0,s.jsx)(n.th,{children:"noEventSend"})]})})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Code"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:'function WoodHarvester:dropWoodHarvesterTree(noEventSend)\n    if self.isServer then\n        local spec = self.spec_woodHarvester\n\n        if spec.attachedSplitShapeJointIndex ~ = nil then\n            removeJoint(spec.attachedSplitShapeJointIndex)\n            spec.attachedSplitShapeJointIndex = nil\n        end\n        spec.attachedSplitShape = nil\n\n        self:onDelimbTree( false )\n        g_server:broadcastEvent( WoodHarvesterOnDelimbTreeEvent.new( self , false ), nil , nil , self )\n\n        SpecializationUtil.raiseEvent( self , "onCutTree" , 0 , false , false )\n        g_server:broadcastEvent( WoodHarvesterOnCutTreeEvent.new( self , 0 ), nil , nil , self )\n    end\n\n    WoodHarvesterDropTreeEvent.sendEvent( self , noEventSend)\nend\n\n'})}),"\n",(0,s.jsx)(n.h3,{id:"findsplitshapesinrange",children:"findSplitShapesInRange"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"Searches for split shapes in range"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Definition"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"findSplitShapesInRange(float yOffset, boolean skipCutAnimation)"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"float"}),(0,s.jsx)(n.th,{children:"yOffset"}),(0,s.jsx)(n.th,{children:"y offset for search"})]})}),(0,s.jsx)(n.tbody,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"boolean"}),(0,s.jsx)(n.td,{children:"skipCutAnimation"}),(0,s.jsx)(n.td,{children:"skip cut animation"})]})})]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Code"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:'function WoodHarvester:findSplitShapesInRange(yOffset, skipCutAnimation)\n    local spec = self.spec_woodHarvester\n    if spec.attachedSplitShape = = nil and spec.cutNode ~ = nil then\n        local x,y,z = localToWorld(spec.cutNode, yOffset or 0 , 0 , 0 )\n        local nx,ny,nz = localDirectionToWorld(spec.cutNode, 1 , 0 , 0 )\n        local yx,yy,yz = localDirectionToWorld(spec.cutNode, 0 , 1 , 0 )\n\n        if spec.curSplitShape = = nil and(spec.cutReleasedComponentJoint = = nil or spec.cutReleasedComponentJointRotLimitX = = 0 ) then\n            local shape, minY, maxY, minZ, maxZ = findSplitShape(x,y,z, nx,ny,nz, yx,yy,yz, spec.cutSizeY, spec.cutSizeZ)\n\n            if shape ~ = 0 then\n                if not g_splitShapeManager:getSplitShapeAllowsHarvester(shape) then\n                    spec.warnInvalidTree = true\n                else\n                        if self:getCanSplitShapeBeAccessed(x, z, shape) then\n                            local treeDx,treeDy,treeDz = localDirectionToWorld(shape, 0 , 1 , 0 ) -- wood harvester trees always grow in the y direction\n                            local cosTreeAngle = MathUtil.dotProduct(nx,ny,nz, treeDx,treeDy,treeDz)\n\n                            local angleLimit = 0.2617 -- 15\xb0 angle for standing trees\n                                if getRigidBodyType(shape) ~ = RigidBodyType.STATIC then\n                                    angleLimit = 0.6981 -- 40\xb0 angle for logs laying on the ground\n                                    end\n\n                                    -- Only allow cutting if the cut header is approximately parallel to the tree\n                                        -- allow in both directions, so we can also pickup split shapes in any rotation\n                                        local angle = 1.57079 - math.abs( math.acos(cosTreeAngle) - 1.57079 )\n                                        if angle < = angleLimit then\n                                            local radius = math.max(maxY - minY, maxZ - minZ) * 0.5 * cosTreeAngle\n\n                                            --#debug local x1, y1, z1 = localToWorld(spec.cutNode, yOffset or 0, minY, minZ)\n                                            --#debug local x2, y2, z2 = localToWorld(spec.cutNode, yOffset or 0, minY, maxZ)\n                                            --#debug local x3, y3, z3 = localToWorld(spec.cutNode, yOffset or 0, maxY, minZ)\n                                            --#debug Utils.renderTextAtWorldPosition((x1+x3) / 2, (y1+y3) / 2, (z1+z3) / 2, string.format("diam: %.1f/%.1f", radius*2, spec.cutMaxRadius*2), getCorrectTextSize(0.012), 0)\n                                            --#debug DebugPlane.renderWithPositions(x1, y1, z1, x2, y2, z2, x3, y3, z3, Color.PRESETS.GREEN)\n\n                                            if radius > spec.cutMaxRadius then\n                                                spec.warnInvalidTreeRadius = true\n\n                                                -- check one meter higher if the tree would fit and then display different warning\n                                                    x, y, z = localToWorld(spec.cutNode, yOffset or 0 + 1 , 0 , 0 )\n                                                    shape, minY, maxY, minZ, maxZ = findSplitShape(x,y,z, nx,ny,nz, yx,yy,yz, spec.cutSizeY, spec.cutSizeZ)\n                                                    if shape ~ = 0 then\n                                                        radius = math.max(maxY - minY, maxZ - minZ) * 0.5 * math.cos(angle)\n\n                                                        --#debug x1, y1, z1 = localToWorld(spec.cutNode, yOffset or 0 + 1, minY, minZ)\n                                                        --#debug x2, y2, z2 = localToWorld(spec.cutNode, yOffset or 0 + 1, minY, maxZ)\n                                                        --#debug x3, y3, z3 = localToWorld(spec.cutNode, yOffset or 0 + 1, maxY, minZ)\n                                                        --#debug Utils.renderTextAtWorldPosition((x1+x3) / 2, (y1+y3) / 2, (z1+z3) / 2, string.format("diam: %.1f/%.1f", radius*2, spec.cutMaxRadius*2), getCorrectTextSize(0.012), 0)\n                                                        --#debug DebugPlane.renderWithPositions(x1, y1, z1, x2, y2, z2, x3, y3, z3, Color.PRESETS.GREEN)\n\n                                                        if radius < = spec.cutMaxRadius then\n                                                            spec.warnInvalidTreeRadius = false\n                                                            spec.warnInvalidTreePosition = true\n                                                        end\n                                                    end\n                                                else\n                                                        self:setLastTreeDiameter( math.max(maxY - minY, maxZ - minZ))\n                                                        spec.curSplitShape = shape\n\n                                                        if skipCutAnimation then\n                                                            self:setAnimationTime(spec.cutAnimation.name, 1 , true )\n                                                            spec.cutTimer = 0\n                                                        end\n                                                    end\n                                                end\n                                            else\n                                                    spec.warnTreeNotOwned = true\n                                                end\n                                            end\n                                        end\n                                    end\n                                end\n                            end\n\n'})}),"\n",(0,s.jsx)(n.h3,{id:"getautoalignhasvalidtree",children:"getAutoAlignHasValidTree"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Definition"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"getAutoAlignHasValidTree()"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"any"}),(0,s.jsx)(n.th,{children:"superFunc"})]})}),(0,s.jsx)(n.tbody,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"any"}),(0,s.jsx)(n.td,{children:"radius"})]})})]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Code"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:"function WoodHarvester:getAutoAlignHasValidTree(superFunc, radius)\n    local spec = self.spec_woodHarvester\n    return spec.curSplitShape ~ = nil , radius < = spec.cutMaxRadius\nend\n\n"})}),"\n",(0,s.jsx)(n.h3,{id:"getcanbeselected",children:"getCanBeSelected"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Definition"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"getCanBeSelected()"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,s.jsx)(n.table,{children:(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"any"}),(0,s.jsx)(n.th,{children:"superFunc"})]})})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Code"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:"function WoodHarvester:getCanBeSelected(superFunc)\n    return true\nend\n\n"})}),"\n",(0,s.jsx)(n.h3,{id:"getcansplitshapebeaccessed",children:"getCanSplitShapeBeAccessed"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Definition"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"getCanSplitShapeBeAccessed()"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"any"}),(0,s.jsx)(n.th,{children:"x"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"any"}),(0,s.jsx)(n.td,{children:"z"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"any"}),(0,s.jsx)(n.td,{children:"shape"})]})]})]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Code"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:"function WoodHarvester:getCanSplitShapeBeAccessed(x, z, shape)\n    return g_splitShapeManager:getIsShapeCutAllowed(x, z, shape, self:getActiveFarm(), self:getOwnerConnection())\nend\n\n"})}),"\n",(0,s.jsx)(n.h3,{id:"getconsumingload",children:"getConsumingLoad"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Definition"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"getConsumingLoad()"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,s.jsx)(n.table,{children:(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"any"}),(0,s.jsx)(n.th,{children:"superFunc"})]})})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Code"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:"function WoodHarvester:getConsumingLoad(superFunc)\n    local value, count = superFunc( self )\n\n    local loadPercentage = 0\n\n    local spec = self.spec_woodHarvester\n    if spec.isAttachedSplitShapeMoving or self:getIsAnimationPlaying(spec.cutAnimation.name) then\n        loadPercentage = 1\n    end\n\n    return value + loadPercentage, count + 1\nend\n\n"})}),"\n",(0,s.jsx)(n.h3,{id:"getdoconsumeptopower",children:"getDoConsumePtoPower"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"Returns if should consume pto power"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Definition"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"getDoConsumePtoPower()"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,s.jsx)(n.table,{children:(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"any"}),(0,s.jsx)(n.th,{children:"superFunc"})]})})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Return Values"})}),"\n\n\n\n\n\n\n\n\n",(0,s.jsx)(n.table,{children:(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"any"}),(0,s.jsx)(n.th,{children:"consume"}),(0,s.jsx)(n.th,{children:"consumePtoPower"})]})})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Code"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:"function WoodHarvester:getDoConsumePtoPower(superFunc)\n    return superFunc( self ) or self:getIsTurnedOn()\nend\n\n"})}),"\n",(0,s.jsx)(n.h3,{id:"getisautotreealignmentallowed",children:"getIsAutoTreeAlignmentAllowed"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Definition"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"getIsAutoTreeAlignmentAllowed()"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,s.jsx)(n.table,{children:(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"any"}),(0,s.jsx)(n.th,{children:"superFunc"})]})})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Code"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:"function WoodHarvester:getIsAutoTreeAlignmentAllowed(superFunc)\n    local spec = self.spec_woodHarvester\n    if spec.hasAttachedSplitShape then\n        return false\n    end\n\n    return superFunc( self )\nend\n\n"})}),"\n",(0,s.jsx)(n.h3,{id:"getisfoldallowed",children:"getIsFoldAllowed"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Definition"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"getIsFoldAllowed()"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"any"}),(0,s.jsx)(n.th,{children:"superFunc"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"any"}),(0,s.jsx)(n.td,{children:"direction"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"any"}),(0,s.jsx)(n.td,{children:"onAiTurnOn"})]})]})]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Code"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:"function WoodHarvester:getIsFoldAllowed(superFunc, direction, onAiTurnOn)\n    local spec = self.spec_woodHarvester\n    if spec.hasAttachedSplitShape then\n        return false , spec.texts.warningFoldingTreeMounted\n    end\n\n    return superFunc( self , direction, onAiTurnOn)\nend\n\n"})}),"\n",(0,s.jsx)(n.h3,{id:"getiswoodharvestertiltstateallowed",children:"getIsWoodHarvesterTiltStateAllowed"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Definition"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"getIsWoodHarvesterTiltStateAllowed()"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,s.jsx)(n.table,{children:(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"any"}),(0,s.jsx)(n.th,{children:"headerTilt"})]})})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Code"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:"function WoodHarvester:getIsWoodHarvesterTiltStateAllowed(headerTilt)\n    return true\nend\n\n"})}),"\n",(0,s.jsx)(n.h3,{id:"getspecvaluemaxtreesize",children:"getSpecValueMaxTreeSize"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Definition"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"getSpecValueMaxTreeSize()"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"any"}),(0,s.jsx)(n.th,{children:"storeItem"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"any"}),(0,s.jsx)(n.td,{children:"realItem"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"any"}),(0,s.jsx)(n.td,{children:"configurations"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"any"}),(0,s.jsx)(n.td,{children:"saleItem"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"any"}),(0,s.jsx)(n.td,{children:"returnValues"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"any"}),(0,s.jsx)(n.td,{children:"returnRange"})]})]})]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Code"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:'function WoodHarvester.getSpecValueMaxTreeSize(storeItem, realItem, configurations, saleItem, returnValues, returnRange)\n    if storeItem.specs.woodHarvesterMaxTreeSize ~ = nil then\n        local value = storeItem.specs.woodHarvesterMaxTreeSize * 2 * 100\n        local str = string.format( "%d%s" , MathUtil.round(value), g_i18n:getText( "unit_cmShort" ))\n        if returnValues and returnRange then\n            return value, value, str\n        elseif returnValues then\n                return value, str\n            else\n                    return str\n                end\n            end\n\n            return nil\n        end\n\n'})}),"\n",(0,s.jsx)(n.h3,{id:"getsupportsautotreealignment",children:"getSupportsAutoTreeAlignment"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Definition"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"getSupportsAutoTreeAlignment()"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,s.jsx)(n.table,{children:(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"any"}),(0,s.jsx)(n.th,{children:"superFunc"})]})})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Code"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:"function WoodHarvester:getSupportsAutoTreeAlignment(superFunc)\n    return true\nend\n\n"})}),"\n",(0,s.jsx)(n.h3,{id:"initspecialization",children:"initSpecialization"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Definition"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"initSpecialization()"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Code"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:'function WoodHarvester.initSpecialization()\n    g_storeManager:addSpecType( "woodHarvesterMaxTreeSize" , "shopListAttributeIconMaxTreeSize" , WoodHarvester.loadSpecValueMaxTreeSize, WoodHarvester.getSpecValueMaxTreeSize, StoreSpecies.VEHICLE)\n\n    local schema = Vehicle.xmlSchema\n    schema:setXMLSpecializationType( "WoodHarvester" )\n\n    schema:register(XMLValueType.NODE_INDEX, "vehicle.woodHarvester.cutNode#node" , "Cut node" )\n    schema:register(XMLValueType.FLOAT, "vehicle.woodHarvester.cutNode#maxRadius" , "Max.radius" , 1 )\n    schema:register(XMLValueType.FLOAT, "vehicle.woodHarvester.cutNode#sizeY" , "Size Y" , 1 )\n    schema:register(XMLValueType.FLOAT, "vehicle.woodHarvester.cutNode#sizeZ" , "Size Z" , 1 )\n    schema:register(XMLValueType.NODE_INDEX, "vehicle.woodHarvester.cutNode#attachNode" , "Attach node" )\n    schema:register(XMLValueType.NODE_INDEX, "vehicle.woodHarvester.cutNode#attachReferenceNode" , "Attach reference node" )\n    schema:register(XMLValueType.FLOAT, "vehicle.woodHarvester.cutNode#attachMoveSpeed" , "Attach move speed" , 3 )\n    schema:register(XMLValueType.INT, "vehicle.woodHarvester.cutNode#releasedComponentJointIndex" , "Released component joint" )\n    schema:register(XMLValueType.ANGLE, "vehicle.woodHarvester.cutNode#releasedComponentJointRotLimitXSpeed" , "Released component joint rot limit X speed" , 100 )\n    schema:register(XMLValueType.INT, "vehicle.woodHarvester.cutNode#releasedComponentJoint2Index" , "Released component joint 2" )\n\n    schema:register(XMLValueType.STRING, WoodHarvester.HEADER_JOINT_TILT_XML_KEY .. "#animationName" , "Header tilt animation" )\n    schema:register(XMLValueType.FLOAT, WoodHarvester.HEADER_JOINT_TILT_XML_KEY .. "#speedFactor" , "Speed of header tilt animation" , 1 )\n\n    schema:register(XMLValueType.NODE_INDEX, "vehicle.woodHarvester.delimbNode#node" , "Delimb node" )\n    schema:register(XMLValueType.FLOAT, "vehicle.woodHarvester.delimbNode#sizeX" , "Delimb size X" , 0.1 )\n    schema:register(XMLValueType.FLOAT, "vehicle.woodHarvester.delimbNode#sizeY" , "Delimb size Y" , 1 )\n    schema:register(XMLValueType.FLOAT, "vehicle.woodHarvester.delimbNode#sizeZ" , "Delimb size Z" , 1 )\n    schema:register(XMLValueType.BOOL, "vehicle.woodHarvester.delimbNode#delimbOnCut" , "Delimb on cut" , false )\n\n    schema:register(XMLValueType.FLOAT, "vehicle.woodHarvester.cutLengths#min" , "Min.cut length" , 1 )\n    schema:register(XMLValueType.FLOAT, "vehicle.woodHarvester.cutLengths#max" , "Max.cut length" , 5 )\n    schema:register(XMLValueType.FLOAT, "vehicle.woodHarvester.cutLengths#step" , "Cut length steps" , 0.5 )\n    schema:register(XMLValueType.VECTOR_N, "vehicle.woodHarvester.cutLengths#values" , "Multiple lengths that are available separated by blank space" )\n    schema:register(XMLValueType.INT, "vehicle.woodHarvester.cutLengths#startIndex" , "Default selected cut length index" , 1 )\n\n    EffectManager.registerEffectXMLPaths(schema, "vehicle.woodHarvester.cutEffects" )\n    EffectManager.registerEffectXMLPaths(schema, "vehicle.woodHarvester.delimbEffects" )\n    AnimationManager.registerAnimationNodesXMLPaths(schema, "vehicle.woodHarvester.forwardingNodes" )\n\n    SoundManager.registerSampleXMLPaths(schema, "vehicle.woodHarvester.sounds" , "cut" )\n    SoundManager.registerSampleXMLPaths(schema, "vehicle.woodHarvester.sounds" , "delimb" )\n\n    schema:register(XMLValueType.STRING, "vehicle.woodHarvester.cutAnimation#name" , "Cut animation name" )\n    schema:register(XMLValueType.FLOAT, "vehicle.woodHarvester.cutAnimation#speedScale" , "Cut animation speed scale" )\n    schema:register(XMLValueType.FLOAT, "vehicle.woodHarvester.cutAnimation#cutTime" , "Cut animation cut time" )\n\n    schema:register(XMLValueType.STRING, "vehicle.woodHarvester.grabAnimation#name" , "Grab animation name" )\n    schema:register(XMLValueType.FLOAT, "vehicle.woodHarvester.grabAnimation#speedScale" , "Grab animation speed scale" )\n\n    schema:register(XMLValueType.NODE_INDEX, "vehicle.woodHarvester.treeSizeMeasure#node" , "Tree size measure node" )\n    schema:register(XMLValueType.FLOAT, "vehicle.woodHarvester.treeSizeMeasure#rotMaxRadius" , "Max.tree size as reference for grab animation" , 1 )\n        schema:register(XMLValueType.FLOAT, "vehicle.woodHarvester.treeSizeMeasure#rotMaxAnimTime" , "Grab animation time which reflects the rotMaxRadius(0-1)" , 1 )\n\n        Dashboard.registerDashboardXMLPaths(schema, "vehicle.woodHarvester.dashboards" , { "cutLength" , "curCutLength" , "diameter" } )\n\n        schema:setXMLSpecializationType()\n\n        local schemaSavegame = Vehicle.xmlSchemaSavegame\n        schemaSavegame:register(XMLValueType.INT, "vehicles.vehicle(?).woodHarvester#currentCutLengthIndex" , "Current cut length selection index" , 1 )\n        schemaSavegame:register(XMLValueType.BOOL, "vehicles.vehicle(?).woodHarvester#isTurnedOn" , "Harvester is turned on" , false )\n        schemaSavegame:register(XMLValueType.VECTOR_ 4 , "vehicles.vehicle(?).woodHarvester#lastTreeSize" , "Last dimensions of tree to cutNode" )\n        schemaSavegame:register(XMLValueType.INT, "vehicles.vehicle(?).woodHarvester#lastCutAttachDirection" , "Last tree attach direction" )\n        schemaSavegame:register(XMLValueType.VECTOR_ 3 , "vehicles.vehicle(?).woodHarvester#lastTreeJointPos" , "Last tree joint position in local space of splitShape" )\n        schemaSavegame:register(XMLValueType.BOOL, "vehicles.vehicle(?).woodHarvester#hasAttachedSplitShape" , "Has split shape attached" , false )\n    end\n\n'})}),"\n",(0,s.jsx)(n.h3,{id:"loadspecvaluemaxtreesize",children:"loadSpecValueMaxTreeSize"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Definition"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"loadSpecValueMaxTreeSize()"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"any"}),(0,s.jsx)(n.th,{children:"xmlFile"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"any"}),(0,s.jsx)(n.td,{children:"customEnvironment"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"any"}),(0,s.jsx)(n.td,{children:"baseDir"})]})]})]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Code"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:'function WoodHarvester.loadSpecValueMaxTreeSize(xmlFile, customEnvironment, baseDir)\n    return xmlFile:getValue( "vehicle.woodHarvester.cutNode#maxRadius" )\nend\n\n'})}),"\n",(0,s.jsx)(n.h3,{id:"loadwoodharvesterheadertiltfromxml",children:"loadWoodHarvesterHeaderTiltFromXML"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Definition"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"loadWoodHarvesterHeaderTiltFromXML()"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"any"}),(0,s.jsx)(n.th,{children:"headerTilt"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"any"}),(0,s.jsx)(n.td,{children:"xmlFile"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"any"}),(0,s.jsx)(n.td,{children:"key"})]})]})]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Code"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:'function WoodHarvester:loadWoodHarvesterHeaderTiltFromXML(headerTilt, xmlFile, key)\n    headerTilt.animationName = xmlFile:getValue(key .. "#animationName" )\n    if headerTilt.animationName = = nil then\n        return false\n    end\n\n    headerTilt.speedFactor = xmlFile:getValue(key .. "#speedFactor" , 1 )\n    headerTilt.state = false\n    headerTilt.lastState = nil\n\n    return true\nend\n\n'})}),"\n",(0,s.jsx)(n.h3,{id:"oncuttree",children:"onCutTree"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Definition"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"onCutTree()"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"any"}),(0,s.jsx)(n.th,{children:"radius"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"any"}),(0,s.jsx)(n.td,{children:"isNewTree"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"any"}),(0,s.jsx)(n.td,{children:"loadedFromSavegame"})]})]})]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Code"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:"function WoodHarvester:onCutTree(radius, isNewTree, loadedFromSavegame)\n    local spec = self.spec_woodHarvester\n    if radius > 0 then\n        if self.isClient then\n            if spec.grabAnimation.name ~ = nil then\n                local targetAnimTime = math.min(radius / spec.treeSizeMeasure.rotMaxRadius, 1 ) * spec.treeSizeMeasure.rotMaxAnimTime\n\n                if spec.grabAnimation.speedScale < 0 then\n                    targetAnimTime = 1.0 - targetAnimTime\n                end\n                self:setAnimationStopTime(spec.grabAnimation.name, targetAnimTime)\n\n                if targetAnimTime > self:getAnimationTime(spec.grabAnimation.name) then\n                    self:playAnimation(spec.grabAnimation.name, spec.grabAnimation.speedScale, self:getAnimationTime(spec.grabAnimation.name), true )\n                else\n                        self:playAnimation(spec.grabAnimation.name, - spec.grabAnimation.speedScale, self:getAnimationTime(spec.grabAnimation.name), true )\n                    end\n                end\n\n                self:setLastTreeDiameter( 2 * radius)\n            end\n\n            spec.hasAttachedSplitShape = true\n        else\n                if spec.grabAnimation.name ~ = nil then\n                    if spec.grabAnimation.speedScale > 0 then\n                        self:setAnimationStopTime(spec.grabAnimation.name, 1 )\n                    else\n                            self:setAnimationStopTime(spec.grabAnimation.name, 0 )\n                        end\n                        self:playAnimation(spec.grabAnimation.name, spec.grabAnimation.speedScale, self:getAnimationTime(spec.grabAnimation.name), true )\n                    end\n                    spec.hasAttachedSplitShape = false\n                    spec.cutTimer = - 1\n\n                    if self.isServer then\n                        if spec.headerJointTilt ~ = nil and spec.headerJointTilt.lastState ~ = nil then\n                            self:setWoodHarvesterTiltState(spec.headerJointTilt.lastState)\n                            spec.headerJointTilt.lastState = nil\n                        end\n                    end\n                end\n\n                if loadedFromSavegame then\n                    if spec.grabAnimation.name ~ = nil then\n                        AnimatedVehicle.updateAnimationByName( self , spec.grabAnimation.name, 99999999 , true )\n                    end\n                end\n            end\n\n"})}),"\n",(0,s.jsx)(n.h3,{id:"ondeactivate",children:"onDeactivate"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Definition"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"onDeactivate()"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Code"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:"function WoodHarvester:onDeactivate()\n    local spec = self.spec_woodHarvester\n    spec.curSplitShape = nil\n    self:setLastTreeDiameter( 0 )\nend\n\n"})}),"\n",(0,s.jsx)(n.h3,{id:"ondelete",children:"onDelete"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Definition"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"onDelete()"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Code"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:"function WoodHarvester:onDelete()\n    local spec = self.spec_woodHarvester\n    if spec.attachedSplitShapeJointIndex ~ = nil then\n        removeJoint(spec.attachedSplitShapeJointIndex)\n        spec.attachedSplitShapeJointIndex = nil\n    end\n    if spec.cutAttachHelperNode ~ = nil then\n        delete(spec.cutAttachHelperNode)\n    end\n\n    g_effectManager:deleteEffects(spec.cutEffects)\n    g_effectManager:deleteEffects(spec.delimbEffects)\n    g_soundManager:deleteSamples(spec.samples)\n    g_animationManager:deleteAnimations(spec.forwardingNodes)\nend\n\n"})}),"\n",(0,s.jsx)(n.h3,{id:"ondelimbtree",children:"onDelimbTree"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Definition"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"onDelimbTree()"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,s.jsx)(n.table,{children:(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"any"}),(0,s.jsx)(n.th,{children:"state"})]})})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Code"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:"function WoodHarvester:onDelimbTree(state)\n    local spec = self.spec_woodHarvester\n    if state then\n        spec.isAttachedSplitShapeMoving = true\n    else\n            spec.isAttachedSplitShapeMoving = false\n\n            if self.isServer then\n                if spec.automaticCuttingEnabled then\n                    self:cutTree( 0 )\n                else\n                        spec.automaticCuttingIsDirty = true\n                    end\n                else\n                        spec.automaticCuttingIsDirty = not spec.automaticCuttingEnabled\n                    end\n                end\n            end\n\n"})}),"\n",(0,s.jsx)(n.h3,{id:"ondraw",children:"onDraw"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Definition"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"onDraw()"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"any"}),(0,s.jsx)(n.th,{children:"isActiveForInput"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"any"}),(0,s.jsx)(n.td,{children:"isActiveForInputIgnoreSelection"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"any"}),(0,s.jsx)(n.td,{children:"isSelected"})]})]})]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Code"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:"function WoodHarvester:onDraw(isActiveForInput, isActiveForInputIgnoreSelection, isSelected)\n    local spec = self.spec_woodHarvester\n    if isActiveForInputIgnoreSelection and isSelected and self:getIsTurnedOn() then\n        if spec.cutNode ~ = nil then\n            if spec.warnInvalidTreeRadius then\n                g_currentMission:showBlinkingWarning(spec.texts.warningTreeTooThick, 100 )\n            elseif spec.warnInvalidTreePosition then\n                    g_currentMission:showBlinkingWarning(spec.texts.warningTreeTooThickAtPosition, 100 )\n                elseif spec.warnInvalidTree then\n                        g_currentMission:showBlinkingWarning(spec.texts.warningTreeTypeNotSupported, 100 )\n                    elseif spec.warnTreeNotOwned then\n                            g_currentMission:showBlinkingWarning(spec.texts.warningYouDontHaveAccessToThisLand, 100 )\n                        end\n                    end\n                end\n            end\n\n"})}),"\n",(0,s.jsx)(n.h3,{id:"onload",children:"onLoad"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Definition"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"onLoad()"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,s.jsx)(n.table,{children:(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"any"}),(0,s.jsx)(n.th,{children:"savegame"})]})})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Code"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:'function WoodHarvester:onLoad(savegame)\n    local spec = self.spec_woodHarvester\n\n    XMLUtil.checkDeprecatedXMLElements( self.xmlFile, "vehicle.woodHarvester.delimbSound" , "vehicle.woodHarvester.sounds.delimb" ) --FS17 to FS19\n    XMLUtil.checkDeprecatedXMLElements( self.xmlFile, "vehicle.woodHarvester.cutSound" , "vehicle.woodHarvester.sounds.cut" ) --FS17 to FS19\n    XMLUtil.checkDeprecatedXMLElements( self.xmlFile, "vehicle.woodHarvester.treeSizeMeasure#index" , "vehicle.woodHarvester.treeSizeMeasure#node" ) --FS17 to FS19\n    XMLUtil.checkDeprecatedXMLElements( self.xmlFile, "vehicle.woodHarvester.forwardingWheels.wheel(0)" , "vehicle.woodHarvester.forwardingNodes.animationNode" ) --FS17 to FS19\n    XMLUtil.checkDeprecatedXMLElements( self.xmlFile, "vehicle.woodHarvester.cutParticleSystems" , "vehicle.woodHarvester.cutEffects" ) --FS17 to FS19\n    XMLUtil.checkDeprecatedXMLElements( self.xmlFile, "vehicle.woodHarvester.delimbParticleSystems" , "vehicle.woodHarvester.delimbEffects" ) --FS17 to FS19\n\n    spec.curSplitShape = nil\n    spec.attachedSplitShape = nil\n    spec.hasAttachedSplitShape = false\n    spec.isAttachedSplitShapeMoving = false\n    spec.attachedSplitShapeLastDelimbTime = 0\n    spec.attachedSplitShapeX = 0\n    spec.attachedSplitShapeY = 0\n    spec.attachedSplitShapeZ = 0\n    spec.attachedSplitShapeTargetY = 0\n    spec.attachedSplitShapeLastCutY = 0\n    spec.attachedSplitShapeStartY = 0\n    spec.attachedSplitShapeOnlyMove = false\n    spec.attachedSplitShapeOnlyMoveDelay = 0\n    spec.attachedSplitShapeMoveEffectActive = false\n    spec.attachedSplitShapeDelimbEffectActive = false\n    spec.cutTimer = - 1\n\n    spec.lastCutEventTime = 0\n    spec.cutEventCoolDownTime = 1000 -- alllow cut event only every second so on the client side there is enough time to reseive the correct state from the server\n\n    spec.automaticCuttingEnabled = true\n    spec.automaticCuttingIsDirty = false\n\n    spec.lastTreeSize = nil\n    spec.lastTreeJointPos = nil\n    spec.loadedSplitShapeFromSavegame = false\n\n    spec.cutNode = self.xmlFile:getValue( "vehicle.woodHarvester.cutNode#node" , nil , self.components, self.i3dMappings)\n    spec.cutMaxRadius = self.xmlFile:getValue( "vehicle.woodHarvester.cutNode#maxRadius" , 1 )\n    spec.cutSizeY = self.xmlFile:getValue( "vehicle.woodHarvester.cutNode#sizeY" , 1 )\n    spec.cutSizeZ = self.xmlFile:getValue( "vehicle.woodHarvester.cutNode#sizeZ" , 1 )\n    spec.cutAttachNode = self.xmlFile:getValue( "vehicle.woodHarvester.cutNode#attachNode" , nil , self.components, self.i3dMappings)\n    spec.cutAttachReferenceNode = self.xmlFile:getValue( "vehicle.woodHarvester.cutNode#attachReferenceNode" , nil , self.components, self.i3dMappings)\n    spec.cutAttachMoveSpeed = self.xmlFile:getValue( "vehicle.woodHarvester.cutNode#attachMoveSpeed" , 3 ) * 0.001\n    local cutReleasedComponentJointIndex = self.xmlFile:getValue( "vehicle.woodHarvester.cutNode#releasedComponentJointIndex" )\n    if cutReleasedComponentJointIndex ~ = nil then\n        spec.cutReleasedComponentJoint = self.componentJoints[cutReleasedComponentJointIndex]\n        spec.cutReleasedComponentJointRotLimitX = 0\n        spec.cutReleasedComponentJointRotLimitXSpeed = self.xmlFile:getValue( "vehicle.woodHarvester.cutNode#releasedComponentJointRotLimitXSpeed" , 100 ) * 0.001\n    end\n    local cutReleasedComponentJoint2Index = self.xmlFile:getValue( "vehicle.woodHarvester.cutNode#releasedComponentJoint2Index" )\n    if cutReleasedComponentJoint2Index ~ = nil then\n        spec.cutReleasedComponentJoint2 = self.componentJoints[cutReleasedComponentJoint2Index]\n        spec.cutReleasedComponentJoint2RotLimitX = 0\n        spec.cutReleasedComponentJoint2RotLimitXSpeed = self.xmlFile:getValue( "vehicle.woodHarvester.cutNode#releasedComponentJointRotLimitXSpeed" , 100 ) * 0.001\n    end\n\n    spec.headerJointTilt = { }\n    if not self:loadWoodHarvesterHeaderTiltFromXML(spec.headerJointTilt, self.xmlFile, "vehicle.woodHarvester.headerJointTilt" ) then\n        spec.headerJointTilt = nil\n    end\n\n    if spec.cutAttachReferenceNode ~ = nil and spec.cutAttachNode ~ = nil then\n        spec.cutAttachHelperNode = createTransformGroup( "helper" )\n        link(spec.cutAttachReferenceNode, spec.cutAttachHelperNode)\n        setTranslation(spec.cutAttachHelperNode, 0 , 0 , 0 )\n        setRotation(spec.cutAttachHelperNode, 0 , 0 , 0 )\n    end\n\n    spec.cutAttachDirection = 1\n    spec.lastCutAttachDirection = 1\n\n    spec.delimbNode = self.xmlFile:getValue( "vehicle.woodHarvester.delimbNode#node" , nil , self.components, self.i3dMappings)\n    spec.delimbSizeX = self.xmlFile:getValue( "vehicle.woodHarvester.delimbNode#sizeX" , 0.1 )\n    spec.delimbSizeY = self.xmlFile:getValue( "vehicle.woodHarvester.delimbNode#sizeY" , 1 )\n    spec.delimbSizeZ = self.xmlFile:getValue( "vehicle.woodHarvester.delimbNode#sizeZ" , 1 )\n    spec.delimbOnCut = self.xmlFile:getValue( "vehicle.woodHarvester.delimbNode#delimbOnCut" , false )\n\n    spec.cutLengthMin = self.xmlFile:getValue( "vehicle.woodHarvester.cutLengths#min" , 1 )\n    spec.cutLengthMax = self.xmlFile:getValue( "vehicle.woodHarvester.cutLengths#max" , 5 )\n    spec.cutLengthStep = self.xmlFile:getValue( "vehicle.woodHarvester.cutLengths#step" , 0.5 )\n\n    spec.cutLengths = self.xmlFile:getValue( "vehicle.woodHarvester.cutLengths#values" , nil , true )\n    if spec.cutLengths = = nil or #spec.cutLengths = = 0 then\n        spec.cutLengths = { }\n        for i = spec.cutLengthMin, spec.cutLengthMax, spec.cutLengthStep do\n            table.insert(spec.cutLengths, i)\n        end\n    else\n            for i = 1 , #spec.cutLengths do\n                if spec.cutLengths[i] = = 0 then\n                    spec.cutLengths[i] = math.huge\n                end\n            end\n        end\n\n        spec.currentCutLengthIndex = math.clamp( self.xmlFile:getValue( "vehicle.woodHarvester.cutLengths#startIndex" , 1 ), 1 , #spec.cutLengths)\n        spec.currentCutLength = spec.cutLengths[spec.currentCutLengthIndex] or 1\n\n        if self.isClient then\n            spec.cutEffects = g_effectManager:loadEffect( self.xmlFile, "vehicle.woodHarvester.cutEffects" , self.components, self , self.i3dMappings)\n            spec.delimbEffects = g_effectManager:loadEffect( self.xmlFile, "vehicle.woodHarvester.delimbEffects" , self.components, self , self.i3dMappings)\n            spec.forwardingNodes = g_animationManager:loadAnimations( self.xmlFile, "vehicle.woodHarvester.forwardingNodes" , self.components, self , self.i3dMappings)\n\n            spec.samples = { }\n            spec.samples.cut = g_soundManager:loadSampleFromXML( self.xmlFile, "vehicle.woodHarvester.sounds" , "cut" , self.baseDirectory, self.components, 0 , AudioGroup.VEHICLE, self.i3dMappings, self )\n            spec.samples.delimb = g_soundManager:loadSampleFromXML( self.xmlFile, "vehicle.woodHarvester.sounds" , "delimb" , self.baseDirectory, self.components, 0 , AudioGroup.VEHICLE, self.i3dMappings, self )\n            spec.isCutSamplePlaying = false\n            spec.isDelimbSamplePlaying = false\n        end\n\n        spec.cutAnimation = { }\n        spec.cutAnimation.name = self.xmlFile:getValue( "vehicle.woodHarvester.cutAnimation#name" )\n        spec.cutAnimation.speedScale = self.xmlFile:getValue( "vehicle.woodHarvester.cutAnimation#speedScale" , 1 )\n        spec.cutAnimation.cutTime = self.xmlFile:getValue( "vehicle.woodHarvester.cutAnimation#cutTime" , 1 )\n\n        spec.grabAnimation = { }\n        spec.grabAnimation.name = self.xmlFile:getValue( "vehicle.woodHarvester.grabAnimation#name" )\n        spec.grabAnimation.speedScale = self.xmlFile:getValue( "vehicle.woodHarvester.grabAnimation#speedScale" , 1 )\n\n        spec.treeSizeMeasure = { }\n        spec.treeSizeMeasure.node = self.xmlFile:getValue( "vehicle.woodHarvester.treeSizeMeasure#node" , nil , self.components, self.i3dMappings)\n        spec.treeSizeMeasure.rotMaxRadius = self.xmlFile:getValue( "vehicle.woodHarvester.treeSizeMeasure#rotMaxRadius" , 1 )\n        spec.treeSizeMeasure.rotMaxAnimTime = self.xmlFile:getValue( "vehicle.woodHarvester.treeSizeMeasure#rotMaxAnimTime" , 1 )\n\n        spec.warnInvalidTree = false\n        spec.warnInvalidTreeRadius = false\n        spec.warnInvalidTreePosition = false\n        spec.warnTreeNotOwned = false\n\n        spec.lastDiameter = 0\n\n        spec.texts = { }\n        spec.texts.actionChangeCutLength = g_i18n:getText( "action_woodHarvesterChangeCutLength" )\n        spec.texts.woodHarvesterTiltHeader = g_i18n:getText( "action_woodHarvesterTiltHeader" )\n        spec.texts.uiMax = g_i18n:getText( "ui_max" )\n        spec.texts.unitMeterShort = g_i18n:getText( "unit_mShort" )\n        spec.texts.actionCut = g_i18n:getText( "action_woodHarvesterCut" )\n        spec.texts.warningFoldingTreeMounted = g_i18n:getText( "warning_foldingTreeMounted" )\n        spec.texts.warningTreeTooThick = g_i18n:getText( "warning_treeTooThick" )\n        spec.texts.warningTreeTooThickAtPosition = g_i18n:getText( "warning_treeTooThickAtPosition" )\n        spec.texts.warningTreeTypeNotSupported = g_i18n:getText( "warning_treeTypeNotSupported" )\n        spec.texts.warningYouDontHaveAccessToThisLand = g_i18n:getText( "warning_youAreNotAllowedToCutThisTree" )\n        spec.texts.warningFirstTurnOnTheTool = string.format(g_i18n:getText( "warning_firstTurnOnTheTool" ), self.typeDesc)\n\n        self:registerVehicleSetting(GameSettings.SETTING.WOOD_HARVESTER_AUTO_CUT, true )\n    end\n\n'})}),"\n",(0,s.jsx)(n.h3,{id:"onloadfinished",children:"onLoadFinished"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Definition"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"onLoadFinished()"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,s.jsx)(n.table,{children:(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"any"}),(0,s.jsx)(n.th,{children:"savegame"})]})})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Code"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:'function WoodHarvester:onLoadFinished(savegame)\n    local spec = self.spec_woodHarvester\n    if savegame ~ = nil and not savegame.resetVehicles then\n        local cutLengthIndex = savegame.xmlFile:getValue(savegame.key .. ".woodHarvester#currentCutLengthIndex" , spec.currentCutLengthIndex)\n        self:setWoodHarvesterCutLengthIndex(cutLengthIndex, true )\n\n        if savegame.xmlFile:getValue(savegame.key .. ".woodHarvester#isTurnedOn" , false ) then\n            self:setIsTurnedOn( true )\n        end\n\n        if spec.grabAnimation.name ~ = nil then\n            AnimatedVehicle.updateAnimationByName( self , spec.grabAnimation.name, 99999999 , true )\n        end\n\n        local lastTreeSize = savegame.xmlFile:getValue(savegame.key .. ".woodHarvester#lastTreeSize" , nil , true )\n        if lastTreeSize ~ = nil then\n            spec.lastTreeSize = lastTreeSize\n        end\n\n        local lastTreeJointPos = savegame.xmlFile:getValue(savegame.key .. ".woodHarvester#lastTreeJointPos" , nil , true )\n        if lastTreeJointPos ~ = nil then\n            spec.lastTreeJointPos = lastTreeJointPos\n        end\n\n        spec.lastCutAttachDirection = savegame.xmlFile:getValue(savegame.key .. ".woodHarvester#lastCutAttachDirection" , spec.lastCutAttachDirection)\n\n        if savegame.xmlFile:getValue(savegame.key .. ".woodHarvester#hasAttachedSplitShape" , false ) then\n            if self:getIsTurnedOn() then\n                self:findSplitShapesInRange( 0.5 , true )\n\n                if spec.curSplitShape ~ = nil and spec.curSplitShape ~ = 0 then\n                    spec.loadedSplitShapeFromSavegame = true\n                end\n            end\n        end\n    end\nend\n\n'})}),"\n",(0,s.jsx)(n.h3,{id:"onpostload",children:"onPostLoad"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Definition"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"onPostLoad()"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,s.jsx)(n.table,{children:(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"any"}),(0,s.jsx)(n.th,{children:"savegame"})]})})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Code"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:"function WoodHarvester:onPostLoad(savegame)\n    local spec = self.spec_woodHarvester\n    if spec.grabAnimation.name ~ = nil then\n        local speedScale = - spec.grabAnimation.speedScale\n        local stopTime = 0\n        if spec.grabAnimation.speedScale < 0 then\n            stopTime = 1\n        end\n        self:playAnimation(spec.grabAnimation.name, speedScale, nil , true )\n        self:setAnimationStopTime(spec.grabAnimation.name, stopTime)\n        AnimatedVehicle.updateAnimationByName( self , spec.grabAnimation.name, 99999999 , true )\n    end\nend\n\n"})}),"\n",(0,s.jsx)(n.h3,{id:"onreadstream",children:"onReadStream"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Definition"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"onReadStream()"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"any"}),(0,s.jsx)(n.th,{children:"streamId"})]})}),(0,s.jsx)(n.tbody,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"any"}),(0,s.jsx)(n.td,{children:"connection"})]})})]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Code"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:"function WoodHarvester:onReadStream(streamId, connection)\n    local spec = self.spec_woodHarvester\n    spec.hasAttachedSplitShape = streamReadBool(streamId)\n    if spec.hasAttachedSplitShape then\n        local animTime = streamReadUIntN(streamId, 7 ) / 127\n        self:setAnimationTime(spec.grabAnimation.name, animTime, true )\n\n        self:setAnimationTime(spec.cutAnimation.name, 1 , true )\n    end\n\n    spec.isAttachedSplitShapeMoving = streamReadBool(streamId)\n\n    local cutLengthIndex = streamReadUIntN(streamId, WoodHarvester.NUM_BITS_CUT_LENGTH)\n    self:setWoodHarvesterCutLengthIndex(cutLengthIndex, true )\nend\n\n"})}),"\n",(0,s.jsx)(n.h3,{id:"onreadupdatestream",children:"onReadUpdateStream"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Definition"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"onReadUpdateStream()"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"any"}),(0,s.jsx)(n.th,{children:"streamId"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"any"}),(0,s.jsx)(n.td,{children:"timestamp"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"any"}),(0,s.jsx)(n.td,{children:"connection"})]})]})]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Code"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:"function WoodHarvester:onReadUpdateStream(streamId, timestamp, connection)\n    if connection:getIsServer() then\n        local spec = self.spec_woodHarvester\n        spec.attachedSplitShapeMoveEffectActive = streamReadBool(streamId)\n        if spec.attachedSplitShapeMoveEffectActive then\n            spec.attachedSplitShapeDelimbEffectActive = streamReadBool(streamId)\n        else\n                spec.attachedSplitShapeDelimbEffectActive = false\n            end\n        end\n    end\n\n"})}),"\n",(0,s.jsx)(n.h3,{id:"onregisteractionevents",children:"onRegisterActionEvents"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Definition"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"onRegisterActionEvents()"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"any"}),(0,s.jsx)(n.th,{children:"isActiveForInput"})]})}),(0,s.jsx)(n.tbody,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"any"}),(0,s.jsx)(n.td,{children:"isActiveForInputIgnoreSelection"})]})})]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Code"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:"function WoodHarvester:onRegisterActionEvents(isActiveForInput, isActiveForInputIgnoreSelection)\n    if self.isClient then\n        local spec = self.spec_woodHarvester\n        self:clearActionEventsTable(spec.actionEvents)\n\n        if isActiveForInputIgnoreSelection then\n            local _, actionEventId = self:addPoweredActionEvent(spec.actionEvents, InputAction.IMPLEMENT_EXTRA2, self , WoodHarvester.actionEventCutTree, false , true , true , true , nil )\n            g_inputBinding:setActionEventTextPriority(actionEventId, GS_PRIO_HIGH)\n            g_inputBinding:setActionEventText(actionEventId, spec.texts.actionCut)\n\n            _, actionEventId = self:addActionEvent(spec.actionEvents, InputAction.IMPLEMENT_EXTRA3, self , WoodHarvester.actionEventSetCutlength, false , true , false , true , 1 )\n            g_inputBinding:setActionEventTextPriority(actionEventId, GS_PRIO_HIGH)\n\n            _, actionEventId = self:addActionEvent(spec.actionEvents, InputAction.TOGGLE_CUT_LENGTH_BACK, self , WoodHarvester.actionEventSetCutlength, false , true , false , true , - 1 )\n            g_inputBinding:setActionEventTextVisibility(actionEventId, false )\n\n            _, actionEventId = self:addActionEvent(spec.actionEvents, InputAction.WOOD_HARVESTER_DROP, self , WoodHarvester.actionEventDropTree, false , true , false , true , nil )\n            g_inputBinding:setActionEventTextVisibility(actionEventId, true )\n            g_inputBinding:setActionEventTextPriority(actionEventId, GS_PRIO_NORMAL)\n\n            if spec.headerJointTilt ~ = nil then\n                _, actionEventId = self:addActionEvent(spec.actionEvents, InputAction.TOGGLE_WOOD_HARVESTER_TILT, self , WoodHarvester.actionEventTiltHeader, false , true , false , true , nil )\n                g_inputBinding:setActionEventTextPriority(actionEventId, GS_PRIO_HIGH)\n                g_inputBinding:setActionEventText(actionEventId, spec.texts.woodHarvesterTiltHeader)\n            end\n        end\n    end\nend\n\n"})}),"\n",(0,s.jsx)(n.h3,{id:"onregisterdashboardvaluetypes",children:"onRegisterDashboardValueTypes"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"Called on post load to register dashboard value types"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Definition"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"onRegisterDashboardValueTypes()"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Code"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:'function WoodHarvester:onRegisterDashboardValueTypes()\n    local spec = self.spec_woodHarvester\n\n    local cutLength = DashboardValueType.new( "woodHarvester" , "cutLength" )\n    cutLength:setValue(spec, function ()\n        if spec.currentCutLength = = math.huge then\n            return 9999999\n        else\n                return spec.currentCutLength * 100\n            end\n        end )\n        self:registerDashboardValueType(cutLength)\n\n        local curCutLength = DashboardValueType.new( "woodHarvester" , "curCutLength" )\n        curCutLength:setValue(spec, function ()\n            return math.abs(spec.attachedSplitShapeStartY - spec.attachedSplitShapeY) * 100\n        end )\n        self:registerDashboardValueType(curCutLength)\n\n        local diameter = DashboardValueType.new( "woodHarvester" , "diameter" )\n        diameter:setValue(spec, function ()\n            return spec.lastDiameter * 1000\n        end )\n        self:registerDashboardValueType(diameter)\n    end\n\n'})}),"\n",(0,s.jsx)(n.h3,{id:"onstatechange",children:"onStateChange"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Definition"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"onStateChange()"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"any"}),(0,s.jsx)(n.th,{children:"state"})]})}),(0,s.jsx)(n.tbody,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"any"}),(0,s.jsx)(n.td,{children:"data"})]})})]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Code"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:"function WoodHarvester:onStateChange(state, data)\n    if self.isServer then\n        if state = = VehicleStateChange.MOTOR_TURN_ON then\n            if self.spec_woodHarvester.attachedSplitShape ~ = nil then\n                if self:getCanBeTurnedOn() then\n                    self:setIsTurnedOn( true )\n                end\n            end\n        end\n    end\nend\n\n"})}),"\n",(0,s.jsx)(n.h3,{id:"onturnedoff",children:"onTurnedOff"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Definition"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"onTurnedOff()"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Code"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:"function WoodHarvester:onTurnedOff()\n    local spec = self.spec_woodHarvester\n\n    -- first open the cutter completely\n    if spec.grabAnimation.name ~ = nil and spec.attachedSplitShape = = nil then\n        self.playDelayedGrabAnimationTime = g_currentMission.time + 500\n        if spec.grabAnimation.speedScale > 0 then\n            self:setAnimationStopTime(spec.grabAnimation.name, 1 )\n        else\n                self:setAnimationStopTime(spec.grabAnimation.name, 0 )\n            end\n            self:playAnimation(spec.grabAnimation.name, spec.grabAnimation.speedScale, self:getAnimationTime(spec.grabAnimation.name), true )\n        end\n\n        if self.isClient then\n            g_effectManager:stopEffects(spec.delimbEffects)\n            g_effectManager:stopEffects(spec.cutEffects)\n            g_soundManager:stopSamples(spec.samples)\n            spec.isCutSamplePlaying = false\n            spec.isDelimbSamplePlaying = false\n        end\n    end\n\n"})}),"\n",(0,s.jsx)(n.h3,{id:"onturnedon",children:"onTurnedOn"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Definition"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"onTurnedOn()"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Code"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:"function WoodHarvester:onTurnedOn()\n    local spec = self.spec_woodHarvester\n    self.playDelayedGrabAnimationTime = nil\n    if spec.grabAnimation.name ~ = nil and spec.attachedSplitShape = = nil then\n        if spec.grabAnimation.speedScale > 0 then\n            self:setAnimationStopTime(spec.grabAnimation.name, 1 )\n        else\n                self:setAnimationStopTime(spec.grabAnimation.name, 0 )\n            end\n            self:playAnimation(spec.grabAnimation.name, spec.grabAnimation.speedScale, self:getAnimationTime(spec.grabAnimation.name), true )\n        end\n\n        self:setLastTreeDiameter( 0 )\n    end\n\n"})}),"\n",(0,s.jsx)(n.h3,{id:"onupdate",children:"onUpdate"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Definition"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"onUpdate()"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"any"}),(0,s.jsx)(n.th,{children:"dt"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"any"}),(0,s.jsx)(n.td,{children:"isActiveForInput"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"any"}),(0,s.jsx)(n.td,{children:"isActiveForInputIgnoreSelection"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"any"}),(0,s.jsx)(n.td,{children:"isSelected"})]})]})]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Code"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:'function WoodHarvester:onUpdate(dt, isActiveForInput, isActiveForInputIgnoreSelection, isSelected)\n    local spec = self.spec_woodHarvester\n\n    -- Verify that the split shapes still exist(possible that someone has cut them)\n    if self.isServer then\n        local lostShape = false\n        if spec.attachedSplitShape ~ = nil then\n            if not entityExists(spec.attachedSplitShape) then\n                spec.attachedSplitShape = nil\n                spec.attachedSplitShapeJointIndex = nil\n                spec.isAttachedSplitShapeMoving = false\n                spec.attachedSplitShapeMoveEffectActive = false\n                spec.attachedSplitShapeDelimbEffectActive = false\n                spec.cutTimer = - 1\n                lostShape = true\n            end\n        elseif spec.curSplitShape ~ = nil then\n                if not entityExists(spec.curSplitShape) then\n                    spec.curSplitShape = nil\n                    lostShape = true\n                end\n            end\n            if lostShape then\n                SpecializationUtil.raiseEvent( self , "onCutTree" , 0 , false , false )\n                if g_server ~ = nil then\n                    g_server:broadcastEvent( WoodHarvesterOnCutTreeEvent.new( self , 0 ), nil , nil , self )\n                end\n            end\n        end\n\n        if self.isServer and(spec.attachedSplitShape ~ = nil or spec.curSplitShape ~ = nil ) then\n            if spec.cutTimer > 0 then\n                if spec.cutAnimation.name ~ = nil then\n                    if self:getAnimationTime(spec.cutAnimation.name) > spec.cutAnimation.cutTime then\n                        spec.cutTimer = 0\n                    end\n                else\n                        spec.cutTimer = math.max(spec.cutTimer - dt, 0 )\n                    end\n                end\n                local readyToCut = spec.cutTimer = = 0\n\n                -- cut\n                if readyToCut then\n                    spec.cutTimer = - 1\n\n                    local x,y,z = getWorldTranslation(spec.cutNode)\n                    local nx,ny,nz = localDirectionToWorld(spec.cutNode, 1 , 0 , 0 )\n                    local yx,yy,yz = localDirectionToWorld(spec.cutNode, 0 , 1 , 0 )\n                    local newTreeCut = false\n\n                    local currentSplitShape\n                    if spec.attachedSplitShapeJointIndex ~ = nil then\n                        removeJoint(spec.attachedSplitShapeJointIndex)\n                        spec.attachedSplitShapeJointIndex = nil\n                        currentSplitShape = spec.attachedSplitShape\n                        spec.attachedSplitShape = nil\n                    else\n                            currentSplitShape = spec.curSplitShape\n                            spec.curSplitShape = nil\n                            newTreeCut = true\n                        end\n\n                        -- remember split type name for later(achievement)\n                            local splitTypeName = ""\n                            local splitType = g_splitShapeManager:getSplitTypeByIndex(getSplitType(currentSplitShape))\n                            if splitType ~ = nil then\n                                splitTypeName = splitType.name\n                            end\n\n                            if spec.delimbOnCut then\n                                local xD,yD,zD = getWorldTranslation(spec.delimbNode)\n                                local nxD,nyD,nzD = localDirectionToWorld(spec.delimbNode, 1 , 0 , 0 )\n                                local yxD,yyD,yzD = localDirectionToWorld(spec.delimbNode, 0 , 1 , 0 )\n                                local vx,vy,vz = x - xD,y - yD,z - zD\n                                local sizeX = MathUtil.vector3Length(vx,vy,vz)\n                                removeSplitShapeAttachments(currentSplitShape, xD + vx * 0.5 ,yD + vy * 0.5 ,zD + vz * 0.5 , nxD,nyD,nzD, yxD,yyD,yzD, sizeX * 0.7 + spec.delimbSizeX, spec.delimbSizeY, spec.delimbSizeZ)\n                            end\n\n                            spec.attachedSplitShape = nil\n                            spec.curSplitShape = nil\n                            spec.prevSplitShape = currentSplitShape\n\n                            -- if the tree is loaded from the savegame or we pick up a tree that is already cut, we just attach it\n                                local doTreeCut = not spec.loadedSplitShapeFromSavegame\n                                if getRigidBodyType(currentSplitShape) ~ = RigidBodyType.STATIC and newTreeCut then\n                                    doTreeCut = false\n                                end\n\n                                if doTreeCut then\n                                    g_currentMission:removeKnownSplitShape(currentSplitShape)\n                                    self.shapeBeingCut = currentSplitShape\n                                    self.shapeBeingCutIsTree = getRigidBodyType(currentSplitShape) = = RigidBodyType.STATIC\n                                    self.shapeBeingCutIsNew = newTreeCut\n                                    splitShape(currentSplitShape, x,y,z, nx,ny,nz, yx,yy,yz, spec.cutSizeY, spec.cutSizeZ, "woodHarvesterSplitShapeCallback" , self )\n                                    g_treePlantManager:removingSplitShape(currentSplitShape)\n                                else\n                                        local minY, maxY, minZ, maxZ\n                                        local delimbOffset = 0\n                                        if spec.lastTreeSize = = nil or not spec.loadedSplitShapeFromSavegame then\n                                            minY, maxY, minZ, maxZ = testSplitShape(currentSplitShape, x,y,z, nx,ny,nz, yx,yy,yz, spec.cutSizeY, spec.cutSizeZ)\n                                            if minY ~ = nil then\n                                                local lengthBelow, _ = getSplitShapePlaneExtents(currentSplitShape, x,y,z, nx,ny,nz)\n                                                if lengthBelow ~ = nil and lengthBelow > 0.01 then\n                                                    -- we move the bottom of the tree to the cutting blade, so it will have the exact set length while cutting\n                                                        delimbOffset = - lengthBelow\n                                                    end\n                                                end\n                                            else\n                                                    minY, maxY, minZ, maxZ = spec.lastTreeSize[ 1 ], spec.lastTreeSize[ 2 ], spec.lastTreeSize[ 3 ], spec.lastTreeSize[ 4 ]\n                                                end\n\n                                                if minY ~ = nil then\n                                                    self:woodHarvesterSplitShapeCallback(currentSplitShape, false , true , minY, maxY, minZ, maxZ)\n                                                    g_messageCenter:publish(MessageType.TREE_SHAPE_MOUNTED, currentSplitShape, self )\n\n                                                    if delimbOffset ~ = 0 then\n                                                        spec.attachedSplitShapeTargetY = spec.attachedSplitShapeLastCutY + delimbOffset * spec.cutAttachDirection\n                                                        spec.attachedSplitShapeOnlyMove = true\n                                                        spec.attachedSplitShapeOnlyMoveDelay = 750 -- short delay to the tree has time to get into the grab\n                                                        self:onDelimbTree( true )\n                                                    end\n                                                end\n                                            end\n\n                                            if spec.attachedSplitShape = = nil then\n                                                SpecializationUtil.raiseEvent( self , "onCutTree" , 0 , false , false )\n                                                if g_server ~ = nil then\n                                                    g_server:broadcastEvent( WoodHarvesterOnCutTreeEvent.new( self , 0 ), nil , nil , self )\n                                                end\n                                            else\n                                                    if spec.delimbOnCut then\n                                                        local xD,yD,zD = getWorldTranslation(spec.delimbNode)\n                                                        local nxD,nyD,nzD = localDirectionToWorld(spec.delimbNode, 1 , 0 , 0 )\n                                                        local yxD,yyD,yzD = localDirectionToWorld(spec.delimbNode, 0 , 1 , 0 )\n                                                        local vx,vy,vz = x - xD,y - yD,z - zD\n                                                        local sizeX = MathUtil.vector3Length(vx,vy,vz)\n                                                        removeSplitShapeAttachments(spec.attachedSplitShape, xD + vx * 3 ,yD + vy * 3 ,zD + vz * 3 , nxD,nyD,nzD, yxD,yyD,yzD, sizeX * 3 + spec.delimbSizeX, spec.delimbSizeY, spec.delimbSizeZ)\n                                                    end\n                                                end\n\n                                                if doTreeCut and newTreeCut then\n                                                    -- increase tree cut counter for achievements\n                                                        local total, _ = g_farmManager:updateFarmStats( self:getActiveFarm(), "cutTreeCount" , 1 )\n\n                                                        if total ~ = nil then\n                                                            g_achievementManager:tryUnlock( "CutTreeFirst" , total)\n                                                            g_achievementManager:tryUnlock( "CutTree" , total)\n                                                        end\n\n                                                        -- update the types of trees cut so far(achievement)\n                                                        if splitTypeName ~ = "" then\n                                                            local farm = g_farmManager:getFarmById( self:getActiveFarm())\n                                                            if farm ~ = nil then\n                                                                farm.stats:updateTreeTypesCut(splitTypeName)\n                                                            end\n                                                        end\n                                                    end\n                                                end\n\n                                                spec.attachedSplitShapeMoveEffectActive = false\n                                                spec.attachedSplitShapeDelimbEffectActive = false\n\n                                                -- delimb\n                                                if spec.attachedSplitShape ~ = nil and spec.isAttachedSplitShapeMoving then\n                                                    if spec.delimbNode ~ = nil then\n                                                        local x,y,z = getWorldTranslation(spec.delimbNode)\n                                                        local nx,ny,nz = localDirectionToWorld(spec.delimbNode, 1 , 0 , 0 )\n                                                        local yx,yy,yz = localDirectionToWorld(spec.delimbNode, 0 , 1 , 0 )\n\n                                                        local didDelimb = removeSplitShapeAttachments(spec.attachedSplitShape, x,y,z, nx,ny,nz, yx,yy,yz, spec.delimbSizeX, spec.delimbSizeY, spec.delimbSizeZ)\n                                                        if didDelimb then\n                                                            spec.attachedSplitShapeLastDelimbTime = g_ time\n                                                        end\n\n                                                        if g_ time - spec.attachedSplitShapeLastDelimbTime < 500 then\n                                                            spec.attachedSplitShapeDelimbEffectActive = true\n                                                        end\n                                                    end\n\n                                                    local updateSplitShapeJoint, updateJointSavePosition = false , false\n                                                    if not spec.attachedSplitShapeOnlyMove then\n                                                        if spec.cutNode ~ = nil and spec.attachedSplitShapeJointIndex ~ = nil then\n                                                            local x,y,z = getWorldTranslation(spec.cutAttachReferenceNode)\n                                                            local nx,ny,nz = localDirectionToWorld(spec.cutAttachReferenceNode, 0 , 1 , 0 )\n                                                            local _, lengthRem = getSplitShapePlaneExtents(spec.attachedSplitShape, x,y,z, nx,ny,nz)\n\n                                                            if lengthRem = = nil or lengthRem < = 0.1 then\n\n                                                                -- end of tree\n                                                                removeJoint(spec.attachedSplitShapeJointIndex)\n                                                                spec.attachedSplitShapeJointIndex = nil\n                                                                spec.attachedSplitShape = nil\n\n                                                                self:onDelimbTree( false )\n                                                                if g_server ~ = nil then\n                                                                    g_server:broadcastEvent( WoodHarvesterOnDelimbTreeEvent.new( self , false ), nil , nil , self )\n                                                                end\n\n                                                                SpecializationUtil.raiseEvent( self , "onCutTree" , 0 , false , false )\n                                                                if g_server ~ = nil then\n                                                                    g_server:broadcastEvent( WoodHarvesterOnCutTreeEvent.new( self , 0 ), nil , nil , self )\n                                                                end\n                                                            else\n                                                                    local dir = spec.attachedSplitShapeTargetY > spec.attachedSplitShapeY and 1 or - 1\n                                                                    local limit = spec.attachedSplitShapeTargetY > spec.attachedSplitShapeY and math.min or math.max\n                                                                    spec.attachedSplitShapeY = limit(spec.attachedSplitShapeY + spec.cutAttachMoveSpeed * dt * dir, spec.attachedSplitShapeTargetY)\n                                                                    if spec.attachedSplitShapeY = = spec.attachedSplitShapeTargetY then\n                                                                        self:onDelimbTree( false )\n                                                                        if g_server ~ = nil then\n                                                                            g_server:broadcastEvent( WoodHarvesterOnDelimbTreeEvent.new( self , false ), nil , nil , self )\n                                                                        end\n                                                                    end\n\n                                                                    updateSplitShapeJoint = true\n                                                                end\n                                                            end\n                                                        else\n                                                                if spec.attachedSplitShapeOnlyMoveDelay < = 0 then\n                                                                    local dir = spec.attachedSplitShapeTargetY > spec.attachedSplitShapeY and 1 or - 1\n                                                                    local limit = spec.attachedSplitShapeTargetY > spec.attachedSplitShapeY and math.min or math.max\n                                                                    spec.attachedSplitShapeY = limit(spec.attachedSplitShapeY + spec.cutAttachMoveSpeed * dt * dir, spec.attachedSplitShapeTargetY)\n                                                                    if spec.attachedSplitShapeY = = spec.attachedSplitShapeTargetY then\n                                                                        spec.isAttachedSplitShapeMoving = false\n                                                                        spec.attachedSplitShapeOnlyMove = false\n                                                                        spec.attachedSplitShapeLastCutY = spec.attachedSplitShapeY\n                                                                    end\n                                                                    updateSplitShapeJoint = true\n                                                                    updateJointSavePosition = true\n                                                                else\n                                                                        spec.attachedSplitShapeOnlyMoveDelay = spec.attachedSplitShapeOnlyMoveDelay - dt\n                                                                    end\n                                                                end\n\n                                                                if updateSplitShapeJoint then\n                                                                    if spec.attachedSplitShapeJointIndex ~ = nil then\n                                                                        local x,y,z = localToWorld(spec.cutNode, 0.3 , 0 , 0 )\n                                                                        local nx,ny,nz = localDirectionToWorld(spec.cutNode, 1 , 0 , 0 )\n                                                                        local yx,yy,yz = localDirectionToWorld(spec.cutNode, 0 , 1 , 0 )\n                                                                        local shape, minY, maxY, minZ, maxZ = findSplitShape(x,y,z, nx,ny,nz, yx,yy,yz, spec.cutSizeY, spec.cutSizeZ)\n                                                                        if shape = = spec.attachedSplitShape then\n                                                                            local treeCenterX,treeCenterY,treeCenterZ = localToWorld(spec.cutNode, 0 , (minY + maxY) * 0.5 , (minZ + maxZ) * 0.5 )\n                                                                            local _\n                                                                            spec.attachedSplitShapeX, _, spec.attachedSplitShapeZ = worldToLocal(spec.attachedSplitShape, treeCenterX,treeCenterY,treeCenterZ)\n                                                                            self:setLastTreeDiameter((maxY - minY + maxZ - minZ) * 0.5 )\n                                                                        end\n                                                                        x,y,z = localToWorld(spec.attachedSplitShape, spec.attachedSplitShapeX, spec.attachedSplitShapeY, spec.attachedSplitShapeZ)\n                                                                        setJointPosition(spec.attachedSplitShapeJointIndex, 1 , x,y,z)\n\n                                                                        if updateJointSavePosition then\n                                                                            spec.lastTreeJointPos[ 1 ] = spec.attachedSplitShapeX\n                                                                            spec.lastTreeJointPos[ 2 ] = spec.attachedSplitShapeY\n                                                                            spec.lastTreeJointPos[ 3 ] = spec.attachedSplitShapeZ\n                                                                        end\n                                                                    end\n                                                                end\n\n                                                                spec.attachedSplitShapeMoveEffectActive = updateSplitShapeJoint\n                                                            end\n                                                        end\n\n                                                        -- effect and sound for cut and delimb\n                                                            if self.isClient then\n                                                                -- cut\n                                                                if spec.cutAnimation.name ~ = nil then\n                                                                    if self:getIsAnimationPlaying(spec.cutAnimation.name) and self:getAnimationTime(spec.cutAnimation.name) < spec.cutAnimation.cutTime then\n                                                                        if not spec.isCutSamplePlaying then\n                                                                            g_soundManager:playSample(spec.samples.cut)\n                                                                            spec.isCutSamplePlaying = true\n                                                                        end\n                                                                        g_effectManager:setEffectTypeInfo(spec.cutEffects, FillType.WOODCHIPS)\n                                                                        g_effectManager:startEffects(spec.cutEffects)\n                                                                    else\n                                                                            if spec.isCutSamplePlaying then\n                                                                                g_soundManager:stopSample(spec.samples.cut)\n                                                                                spec.isCutSamplePlaying = false\n                                                                            end\n                                                                            g_effectManager:stopEffects(spec.cutEffects)\n                                                                        end\n                                                                    end\n\n                                                                    -- delimb\n                                                                    if spec.attachedSplitShapeMoveEffectActive then\n                                                                        if not spec.isDelimbSamplePlaying then\n                                                                            g_soundManager:playSample(spec.samples.delimb)\n                                                                            spec.isDelimbSamplePlaying = true\n                                                                        end\n                                                                        g_effectManager:setEffectTypeInfo(spec.delimbEffects, FillType.WOODCHIPS)\n                                                                        g_effectManager:startEffects(spec.delimbEffects)\n                                                                        g_effectManager:setDensity(spec.delimbEffects, spec.attachedSplitShapeDelimbEffectActive and 1 or 0.1 )\n                                                                        g_animationManager:startAnimations(spec.forwardingNodes)\n                                                                    else\n                                                                            if spec.isDelimbSamplePlaying then\n                                                                                g_soundManager:stopSample(spec.samples.delimb)\n                                                                                spec.isDelimbSamplePlaying = false\n                                                                            end\n                                                                            g_effectManager:stopEffects(spec.delimbEffects)\n                                                                            g_animationManager:stopAnimations(spec.forwardingNodes)\n                                                                        end\n                                                                    end\n\n                                                                    --#debug DebugUtil.drawCutNodeArea(spec.cutNode, spec.cutSizeY, spec.cutSizeZ, 1, 0, 0)\n                                                                    --#debug DebugUtil.drawCutNodeArea(spec.delimbNode, spec.delimbSizeY, spec.delimbSizeZ, 0, 0, 1)\n                                                                    --#debug local x1, y1, z1 = getWorldTranslation(spec.cutAttachReferenceNode)\n                                                                    --#debug local x2, y2, z2 = localToWorld(spec.cutAttachReferenceNode, 0, 2.5, 0)\n                                                                    --#debug drawDebugLine(x1, y1, z1, 1, 0, 0, x2, y2, z2, 0, 0, 1, true)\n                                                                end\n\n'})}),"\n",(0,s.jsx)(n.h3,{id:"onupdatetick",children:"onUpdateTick"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Definition"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"onUpdateTick()"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"any"}),(0,s.jsx)(n.th,{children:"dt"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"any"}),(0,s.jsx)(n.td,{children:"isActiveForInput"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"any"}),(0,s.jsx)(n.td,{children:"isActiveForInputIgnoreSelection"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"any"}),(0,s.jsx)(n.td,{children:"isSelected"})]})]})]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Code"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:'function WoodHarvester:onUpdateTick(dt, isActiveForInput, isActiveForInputIgnoreSelection, isSelected)\n    local spec = self.spec_woodHarvester\n\n    spec.warnInvalidTree = false\n    spec.warnInvalidTreeRadius = false\n    spec.warnInvalidTreePosition = false\n    spec.warnTreeNotOwned = false\n\n    if self:getIsTurnedOn() then\n        if spec.attachedSplitShape = = nil and spec.cutNode ~ = nil then\n            local x,y,z = getWorldTranslation(spec.cutNode)\n            local nx,ny,nz = localDirectionToWorld(spec.cutNode, 1 , 0 , 0 )\n            local yx,yy,yz = localDirectionToWorld(spec.cutNode, 0 , 1 , 0 )\n\n            self:findSplitShapesInRange()\n\n            if spec.curSplitShape ~ = nil then\n                if entityExists(spec.curSplitShape) then\n                    local minY,maxY, minZ,maxZ = testSplitShape(spec.curSplitShape, x,y,z, nx,ny,nz, yx,yy,yz, spec.cutSizeY, spec.cutSizeZ)\n                    if minY = = nil then\n                        spec.curSplitShape = nil\n                    else\n                            -- check if cut would be below y = 0(tree CoSy)\n                                local cutTooLow = false\n                                local _\n                                _,y,_ = localToLocal(spec.cutNode, spec.curSplitShape, 0 ,minY,minZ)\n                                cutTooLow = cutTooLow or y < 0.01\n                                _,y,_ = localToLocal(spec.cutNode, spec.curSplitShape, 0 ,minY,maxZ)\n                                cutTooLow = cutTooLow or y < 0.01\n                                _,y,_ = localToLocal(spec.cutNode, spec.curSplitShape, 0 ,maxY,minZ)\n                                cutTooLow = cutTooLow or y < 0.01\n                                _,y,_ = localToLocal(spec.cutNode, spec.curSplitShape, 0 ,maxY,maxZ)\n                                cutTooLow = cutTooLow or y < 0.01\n                                if cutTooLow then\n                                    spec.curSplitShape = nil\n                                end\n                            end\n                        else\n                                spec.curSplitShape = nil\n                            end\n                        end\n\n                        if spec.curSplitShape = = nil and spec.cutTimer > - 1 then\n                            SpecializationUtil.raiseEvent( self , "onCutTree" , 0 , false , false )\n                            if g_server ~ = nil then\n                                g_server:broadcastEvent( WoodHarvesterOnCutTreeEvent.new( self , 0 ), nil , nil , self )\n                            end\n                        end\n\n                    end\n                end\n\n                if self.isServer then\n                    if spec.attachedSplitShape = = nil then\n                        if spec.cutReleasedComponentJoint ~ = nil and spec.cutReleasedComponentJointRotLimitX ~ = 0 then\n                            spec.cutReleasedComponentJointRotLimitX = math.max( 0 , spec.cutReleasedComponentJointRotLimitX - spec.cutReleasedComponentJointRotLimitXSpeed * dt)\n                            setJointRotationLimit(spec.cutReleasedComponentJoint.jointIndex, 0 , true , 0 , spec.cutReleasedComponentJointRotLimitX)\n                        end\n                        if spec.cutReleasedComponentJoint2 ~ = nil and spec.cutReleasedComponentJoint2RotLimitX ~ = 0 then\n                            spec.cutReleasedComponentJoint2RotLimitX = math.max(spec.cutReleasedComponentJoint2RotLimitX - spec.cutReleasedComponentJoint2RotLimitXSpeed * dt, 0 )\n                            setJointRotationLimit(spec.cutReleasedComponentJoint2.jointIndex, 0 , true , - spec.cutReleasedComponentJoint2RotLimitX, spec.cutReleasedComponentJoint2RotLimitX)\n                        end\n                    end\n                end\n\n                if self.isServer then\n                    if self.playDelayedGrabAnimationTime ~ = nil then\n                        if self.playDelayedGrabAnimationTime < g_currentMission.time then\n                            self.playDelayedGrabAnimationTime = nil\n                            if self:getAnimationTime(spec.grabAnimation.name) > 0 then\n                                if spec.grabAnimation.name ~ = nil and spec.attachedSplitShape = = nil then\n                                    if spec.grabAnimation.speedScale > 0 then\n                                        self:setAnimationStopTime(spec.grabAnimation.name, 0 )\n                                    else\n                                            self:setAnimationStopTime(spec.grabAnimation.name, 1 )\n                                        end\n                                        self:playAnimation(spec.grabAnimation.name, - spec.grabAnimation.speedScale, self:getAnimationTime(spec.grabAnimation.name), false )\n                                    end\n                                end\n                            end\n                        end\n                    end\n\n                    if self.isClient then\n                        local actionEvent = spec.actionEvents[InputAction.IMPLEMENT_EXTRA2]\n                        if actionEvent ~ = nil then\n                            local showAction = false\n                            if spec.hasAttachedSplitShape then\n                                if not spec.isAttachedSplitShapeMoving and self:getAnimationTime(spec.cutAnimation.name) = = 1 then\n                                    showAction = true\n                                end\n                            elseif spec.curSplitShape ~ = nil then\n                                    showAction = true\n                                end\n\n                                g_inputBinding:setActionEventActive(actionEvent.actionEventId, showAction)\n\n                                local dropActionEvent = spec.actionEvents[InputAction.WOOD_HARVESTER_DROP]\n                                if dropActionEvent ~ = nil then\n                                    g_inputBinding:setActionEventActive(dropActionEvent.actionEventId, showAction)\n                                end\n                            end\n\n                            actionEvent = spec.actionEvents[InputAction.IMPLEMENT_EXTRA3]\n                            if actionEvent ~ = nil then\n                                g_inputBinding:setActionEventActive(actionEvent.actionEventId, not spec.isAttachedSplitShapeMoving)\n                                if not spec.isAttachedSplitShapeMoving then\n                                    local lengthStr = string.format( "%.1f%s" , spec.currentCutLength, spec.texts.unitMeterShort)\n                                    if spec.currentCutLength = = math.huge then\n                                        lengthStr = spec.texts.uiMax\n                                    end\n\n                                    g_inputBinding:setActionEventText(actionEvent.actionEventId, string.format(spec.texts.actionChangeCutLength, lengthStr))\n                                end\n                            end\n                        end\n                    end\n\n'})}),"\n",(0,s.jsx)(n.h3,{id:"onvehiclesettingchanged",children:"onVehicleSettingChanged"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"Called when vehicle settings change"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Definition"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"onVehicleSettingChanged()"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"any"}),(0,s.jsx)(n.th,{children:"gameSettingId"})]})}),(0,s.jsx)(n.tbody,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"any"}),(0,s.jsx)(n.td,{children:"state"})]})})]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Code"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:"function WoodHarvester:onVehicleSettingChanged(gameSettingId, state)\n    if gameSettingId = = GameSettings.SETTING.WOOD_HARVESTER_AUTO_CUT then\n        self.spec_woodHarvester.automaticCuttingEnabled = state\n    end\nend\n\n"})}),"\n",(0,s.jsx)(n.h3,{id:"onwritestream",children:"onWriteStream"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Definition"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"onWriteStream()"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"any"}),(0,s.jsx)(n.th,{children:"streamId"})]})}),(0,s.jsx)(n.tbody,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"any"}),(0,s.jsx)(n.td,{children:"connection"})]})})]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Code"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:"function WoodHarvester:onWriteStream(streamId, connection)\n    local spec = self.spec_woodHarvester\n    if streamWriteBool(streamId, spec.hasAttachedSplitShape) then\n        local animTime = self:getAnimationTime(spec.grabAnimation.name)\n        streamWriteUIntN(streamId, animTime * 127 , 7 )\n    end\n\n    streamWriteBool(streamId, spec.isAttachedSplitShapeMoving)\n\n    streamWriteUIntN(streamId, spec.currentCutLengthIndex, WoodHarvester.NUM_BITS_CUT_LENGTH)\nend\n\n"})}),"\n",(0,s.jsx)(n.h3,{id:"onwriteupdatestream",children:"onWriteUpdateStream"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Definition"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"onWriteUpdateStream()"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"any"}),(0,s.jsx)(n.th,{children:"streamId"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"any"}),(0,s.jsx)(n.td,{children:"connection"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"any"}),(0,s.jsx)(n.td,{children:"dirtyMask"})]})]})]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Code"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:"function WoodHarvester:onWriteUpdateStream(streamId, connection, dirtyMask)\n    if not connection:getIsServer() then\n        local spec = self.spec_woodHarvester\n        if streamWriteBool(streamId, spec.attachedSplitShapeMoveEffectActive) then\n            streamWriteBool(streamId, spec.attachedSplitShapeDelimbEffectActive)\n        end\n    end\nend\n\n"})}),"\n",(0,s.jsx)(n.h3,{id:"prerequisitespresent",children:"prerequisitesPresent"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Definition"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"prerequisitesPresent()"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,s.jsx)(n.table,{children:(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"any"}),(0,s.jsx)(n.th,{children:"specializations"})]})})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Code"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:"function WoodHarvester.prerequisitesPresent(specializations)\n    return SpecializationUtil.hasSpecialization( TurnOnVehicle , specializations)\nend\n\n"})}),"\n",(0,s.jsx)(n.h3,{id:"registereventlisteners",children:"registerEventListeners"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Definition"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"registerEventListeners()"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,s.jsx)(n.table,{children:(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"any"}),(0,s.jsx)(n.th,{children:"vehicleType"})]})})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Code"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:'function WoodHarvester.registerEventListeners(vehicleType)\n    SpecializationUtil.registerEventListener(vehicleType, "onLoad" , WoodHarvester )\n    SpecializationUtil.registerEventListener(vehicleType, "onPostLoad" , WoodHarvester )\n    SpecializationUtil.registerEventListener(vehicleType, "onLoadFinished" , WoodHarvester )\n    SpecializationUtil.registerEventListener(vehicleType, "onRegisterDashboardValueTypes" , WoodHarvester )\n    SpecializationUtil.registerEventListener(vehicleType, "onDelete" , WoodHarvester )\n    SpecializationUtil.registerEventListener(vehicleType, "onReadStream" , WoodHarvester )\n    SpecializationUtil.registerEventListener(vehicleType, "onWriteStream" , WoodHarvester )\n    SpecializationUtil.registerEventListener(vehicleType, "onReadUpdateStream" , WoodHarvester )\n    SpecializationUtil.registerEventListener(vehicleType, "onWriteUpdateStream" , WoodHarvester )\n    SpecializationUtil.registerEventListener(vehicleType, "onUpdate" , WoodHarvester )\n    SpecializationUtil.registerEventListener(vehicleType, "onUpdateTick" , WoodHarvester )\n    SpecializationUtil.registerEventListener(vehicleType, "onDraw" , WoodHarvester )\n    SpecializationUtil.registerEventListener(vehicleType, "onRegisterActionEvents" , WoodHarvester )\n    SpecializationUtil.registerEventListener(vehicleType, "onDeactivate" , WoodHarvester )\n    SpecializationUtil.registerEventListener(vehicleType, "onTurnedOn" , WoodHarvester )\n    SpecializationUtil.registerEventListener(vehicleType, "onTurnedOff" , WoodHarvester )\n    SpecializationUtil.registerEventListener(vehicleType, "onStateChange" , WoodHarvester )\n    SpecializationUtil.registerEventListener(vehicleType, "onCutTree" , WoodHarvester )\n    SpecializationUtil.registerEventListener(vehicleType, "onVehicleSettingChanged" , WoodHarvester )\nend\n\n'})}),"\n",(0,s.jsx)(n.h3,{id:"registerevents",children:"registerEvents"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Definition"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"registerEvents()"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,s.jsx)(n.table,{children:(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"any"}),(0,s.jsx)(n.th,{children:"vehicleType"})]})})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Code"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:'function WoodHarvester.registerEvents(vehicleType)\n    SpecializationUtil.registerEvent(vehicleType, "onCutTree" )\nend\n\n'})}),"\n",(0,s.jsx)(n.h3,{id:"registerfunctions",children:"registerFunctions"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Definition"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"registerFunctions()"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,s.jsx)(n.table,{children:(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"any"}),(0,s.jsx)(n.th,{children:"vehicleType"})]})})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Code"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:'function WoodHarvester.registerFunctions(vehicleType)\n    SpecializationUtil.registerFunction(vehicleType, "woodHarvesterSplitShapeCallback" , WoodHarvester.woodHarvesterSplitShapeCallback)\n    SpecializationUtil.registerFunction(vehicleType, "setLastTreeDiameter" , WoodHarvester.setLastTreeDiameter)\n    SpecializationUtil.registerFunction(vehicleType, "findSplitShapesInRange" , WoodHarvester.findSplitShapesInRange)\n    SpecializationUtil.registerFunction(vehicleType, "cutTree" , WoodHarvester.cutTree)\n    SpecializationUtil.registerFunction(vehicleType, "onDelimbTree" , WoodHarvester.onDelimbTree)\n    SpecializationUtil.registerFunction(vehicleType, "getCanSplitShapeBeAccessed" , WoodHarvester.getCanSplitShapeBeAccessed)\n    SpecializationUtil.registerFunction(vehicleType, "loadWoodHarvesterHeaderTiltFromXML" , WoodHarvester.loadWoodHarvesterHeaderTiltFromXML)\n    SpecializationUtil.registerFunction(vehicleType, "getIsWoodHarvesterTiltStateAllowed" , WoodHarvester.getIsWoodHarvesterTiltStateAllowed)\n    SpecializationUtil.registerFunction(vehicleType, "setWoodHarvesterTiltState" , WoodHarvester.setWoodHarvesterTiltState)\n    SpecializationUtil.registerFunction(vehicleType, "setWoodHarvesterCutLengthIndex" , WoodHarvester.setWoodHarvesterCutLengthIndex)\n    SpecializationUtil.registerFunction(vehicleType, "dropWoodHarvesterTree" , WoodHarvester.dropWoodHarvesterTree)\nend\n\n'})}),"\n",(0,s.jsx)(n.h3,{id:"registeroverwrittenfunctions",children:"registerOverwrittenFunctions"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Definition"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"registerOverwrittenFunctions()"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,s.jsx)(n.table,{children:(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"any"}),(0,s.jsx)(n.th,{children:"vehicleType"})]})})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Code"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:'function WoodHarvester.registerOverwrittenFunctions(vehicleType)\n    SpecializationUtil.registerOverwrittenFunction(vehicleType, "getCanBeSelected" , WoodHarvester.getCanBeSelected)\n    SpecializationUtil.registerOverwrittenFunction(vehicleType, "getDoConsumePtoPower" , WoodHarvester.getDoConsumePtoPower)\n    SpecializationUtil.registerOverwrittenFunction(vehicleType, "getConsumingLoad" , WoodHarvester.getConsumingLoad)\n    SpecializationUtil.registerOverwrittenFunction(vehicleType, "getIsFoldAllowed" , WoodHarvester.getIsFoldAllowed)\n    SpecializationUtil.registerOverwrittenFunction(vehicleType, "getSupportsAutoTreeAlignment" , WoodHarvester.getSupportsAutoTreeAlignment)\n    SpecializationUtil.registerOverwrittenFunction(vehicleType, "getIsAutoTreeAlignmentAllowed" , WoodHarvester.getIsAutoTreeAlignmentAllowed)\n    SpecializationUtil.registerOverwrittenFunction(vehicleType, "getAutoAlignHasValidTree" , WoodHarvester.getAutoAlignHasValidTree)\nend\n\n'})}),"\n",(0,s.jsx)(n.h3,{id:"savetoxmlfile",children:"saveToXMLFile"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Definition"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"saveToXMLFile()"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"any"}),(0,s.jsx)(n.th,{children:"xmlFile"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"any"}),(0,s.jsx)(n.td,{children:"key"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"any"}),(0,s.jsx)(n.td,{children:"usedModNames"})]})]})]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Code"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:'function WoodHarvester:saveToXMLFile(xmlFile, key, usedModNames)\n    local spec = self.spec_woodHarvester\n\n    xmlFile:setValue(key .. "#currentCutLengthIndex" , spec.currentCutLengthIndex)\n\n    xmlFile:setValue(key .. "#isTurnedOn" , self:getIsTurnedOn() or spec.hasAttachedSplitShape)\n    xmlFile:setValue(key .. "#hasAttachedSplitShape" , spec.hasAttachedSplitShape)\n    xmlFile:setValue(key .. "#lastCutAttachDirection" , spec.lastCutAttachDirection)\n\n    if spec.hasAttachedSplitShape then\n        if spec.lastTreeSize ~ = nil then\n            xmlFile:setValue(key .. "#lastTreeSize" , unpack(spec.lastTreeSize))\n        end\n        if spec.lastTreeJointPos ~ = nil then\n            xmlFile:setValue(key .. "#lastTreeJointPos" , unpack(spec.lastTreeJointPos))\n        end\n    end\nend\n\n'})}),"\n",(0,s.jsx)(n.h3,{id:"setlasttreediameter",children:"setLastTreeDiameter"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Definition"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"setLastTreeDiameter()"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,s.jsx)(n.table,{children:(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"any"}),(0,s.jsx)(n.th,{children:"diameter"})]})})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Code"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:"function WoodHarvester:setLastTreeDiameter(diameter)\n    local spec = self.spec_woodHarvester\n    spec.lastDiameter = diameter\nend\n\n"})}),"\n",(0,s.jsx)(n.h3,{id:"setwoodharvestercutlengthindex",children:"setWoodHarvesterCutLengthIndex"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Definition"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"setWoodHarvesterCutLengthIndex()"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"any"}),(0,s.jsx)(n.th,{children:"index"})]})}),(0,s.jsx)(n.tbody,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"any"}),(0,s.jsx)(n.td,{children:"noEventSend"})]})})]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Code"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:"function WoodHarvester:setWoodHarvesterCutLengthIndex(index, noEventSend)\n    local spec = self.spec_woodHarvester\n    if index ~ = spec.currentCutLengthIndex then\n        spec.currentCutLengthIndex = index\n        spec.currentCutLength = spec.cutLengths[spec.currentCutLengthIndex] or 1\n    end\n\n    WoodHarvesterCutLengthEvent.sendEvent( self , index, noEventSend)\nend\n\n"})}),"\n",(0,s.jsx)(n.h3,{id:"setwoodharvestertiltstate",children:"setWoodHarvesterTiltState"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Definition"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"setWoodHarvesterTiltState()"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"any"}),(0,s.jsx)(n.th,{children:"state"})]})}),(0,s.jsx)(n.tbody,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"any"}),(0,s.jsx)(n.td,{children:"noEventSend"})]})})]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Code"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:"function WoodHarvester:setWoodHarvesterTiltState(state, noEventSend)\n    local spec = self.spec_woodHarvester\n    if state = = nil then\n        state = not spec.headerJointTilt.state\n    end\n\n    if state ~ = spec.headerJointTilt.state then\n        spec.headerJointTilt.state = state\n\n        self:playAnimation(spec.headerJointTilt.animationName, state and 1 or - 1 , self:getAnimationTime(spec.headerJointTilt.animationName), true )\n    end\n\n    WoodHarvesterHeaderTiltEvent.sendEvent( self , state, noEventSend)\nend\n\n"})}),"\n",(0,s.jsx)(n.h3,{id:"woodharvestersplitshapecallback",children:"woodHarvesterSplitShapeCallback"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Definition"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"woodHarvesterSplitShapeCallback()"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"any"}),(0,s.jsx)(n.th,{children:"shape"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"any"}),(0,s.jsx)(n.td,{children:"isBelow"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"any"}),(0,s.jsx)(n.td,{children:"isAbove"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"any"}),(0,s.jsx)(n.td,{children:"minY"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"any"}),(0,s.jsx)(n.td,{children:"maxY"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"any"}),(0,s.jsx)(n.td,{children:"minZ"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"any"}),(0,s.jsx)(n.td,{children:"maxZ"})]})]})]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Code"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:'function WoodHarvester:woodHarvesterSplitShapeCallback(shape, isBelow, isAbove, minY, maxY, minZ, maxZ)\n    local spec = self.spec_woodHarvester\n\n    g_currentMission:addKnownSplitShape(shape)\n    g_treePlantManager:addingSplitShape(shape, self.shapeBeingCut, self.shapeBeingCutIsTree)\n\n    if spec.attachedSplitShape = = nil and isAbove and not isBelow and spec.cutAttachNode ~ = nil and spec.cutAttachReferenceNode ~ = nil then\n        spec.attachedSplitShape = shape\n        spec.lastTreeSize = { minY, maxY, minZ, maxZ }\n\n        -- Current tree center(mid of cut area)\n        local treeCenterX, treeCenterY, treeCenterZ = localToWorld(spec.cutNode, 0 , (minY + maxY) * 0.5 , (minZ + maxZ) * 0.5 )\n\n        local cutAttachDirection\n        local loadedSplitShapeFromSavegame = spec.loadedSplitShapeFromSavegame\n        if loadedSplitShapeFromSavegame then\n            if spec.lastTreeJointPos ~ = nil then\n                treeCenterX, treeCenterY, treeCenterZ = localToWorld(shape, unpack(spec.lastTreeJointPos))\n                cutAttachDirection = spec.lastCutAttachDirection\n            end\n\n            spec.loadedSplitShapeFromSavegame = false\n        end\n        spec.lastTreeJointPos = { worldToLocal(shape, treeCenterX, treeCenterY, treeCenterZ) }\n\n        -- Target tree center(half tree size in front of the reference node)\n        local x,y,z = localToWorld(spec.cutAttachReferenceNode, 0 , 0 , (maxZ - minZ) * 0.5 )\n\n        local dx,dy,dz = localDirectionToWorld(shape, 0 , 0 , 1 )\n\n        local _, treeYDirection, _ = localDirectionToLocal(shape, spec.cutAttachReferenceNode, 0 , 1 , 0 )\n        spec.cutAttachDirection = cutAttachDirection or(treeYDirection > 0 and 1 or - 1 )\n        spec.lastCutAttachDirection = spec.cutAttachDirection\n\n        local upx,upy,upz = localDirectionToWorld(spec.cutAttachReferenceNode, 0 , spec.cutAttachDirection, 0 )\n        local sideX,sideY,sizeZ = MathUtil.crossProduct(upx,upy,upz, dx,dy,dz)\n        dx,dy,dz = MathUtil.crossProduct(sideX,sideY,sizeZ, upx,upy,upz) -- Note:we want the up axis to be exact, thus orthogonalize the direction here\n        I3DUtil.setWorldDirection(spec.cutAttachHelperNode, dx,dy,dz, upx,upy,upz, 2 )\n\n        local constr = JointConstructor.new()\n        constr:setActors(spec.cutAttachNode, shape)\n        -- Note:we assume that the direction of the tree is equal to the y axis\n        constr:setJointTransforms(spec.cutAttachHelperNode, shape)\n        constr:setJointWorldPositions(x,y,z, treeCenterX,treeCenterY,treeCenterZ)\n\n        constr:setRotationLimit( 0 , 0 , 0 )\n        constr:setRotationLimit( 1 , 0 , 0 )\n        constr:setRotationLimit( 2 , 0 , 0 )\n\n        constr:setEnableCollision( false )\n\n        spec.attachedSplitShapeJointIndex = constr:finalize()\n\n        if spec.cutReleasedComponentJoint ~ = nil then\n            spec.cutReleasedComponentJointRotLimitX = math.pi * 0.9\n            if spec.cutReleasedComponentJoint.jointIndex ~ = 0 then\n                setJointRotationLimit(spec.cutReleasedComponentJoint.jointIndex, 0 , true , 0 , spec.cutReleasedComponentJointRotLimitX)\n            end\n        end\n        if spec.cutReleasedComponentJoint2 ~ = nil then\n            spec.cutReleasedComponentJoint2RotLimitX = math.pi * 0.9\n            if spec.cutReleasedComponentJoint2.jointIndex ~ = 0 then\n                setJointRotationLimit(spec.cutReleasedComponentJoint2.jointIndex, 0 , true , - spec.cutReleasedComponentJoint2RotLimitX, spec.cutReleasedComponentJoint2RotLimitX)\n            end\n        end\n\n        if spec.headerJointTilt ~ = nil and spec.headerJointTilt.state and spec.headerJointTilt.lastState = = nil then\n            spec.headerJointTilt.lastState = spec.headerJointTilt.state\n            self:setWoodHarvesterTiltState( false )\n        end\n\n        spec.attachedSplitShapeX, spec.attachedSplitShapeY, spec.attachedSplitShapeZ = worldToLocal(shape, treeCenterX,treeCenterY,treeCenterZ)\n        spec.attachedSplitShapeLastCutY = spec.attachedSplitShapeY\n        spec.attachedSplitShapeStartY = spec.attachedSplitShapeY\n        spec.attachedSplitShapeTargetY = spec.attachedSplitShapeY\n\n        local radius = ((maxY - minY) + (maxZ - minZ)) / 4\n        SpecializationUtil.raiseEvent( self , "onCutTree" , radius, self.shapeBeingCutIsNew, loadedSplitShapeFromSavegame)\n        if g_server ~ = nil then\n            g_server:broadcastEvent( WoodHarvesterOnCutTreeEvent.new( self , radius), nil , nil , self )\n        end\n    end\nend\n\n'})})]})}function h(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}}}]);