"use strict";(globalThis.webpackChunkfs25_community_luadoc=globalThis.webpackChunkfs25_community_luadoc||[]).push([[17405],{4364(n,e,t){t.r(e),t.d(e,{assets:()=>r,contentTitle:()=>s,default:()=>h,frontMatter:()=>l,metadata:()=>i,toc:()=>a});const i=JSON.parse('{"id":"script/Specializations/DynamicMountAttacher","title":"DynamicMountAttacher","description":"DynamicMountAttacher","source":"@site/../docs/script/Specializations/DynamicMountAttacher.md","sourceDirName":"script/Specializations","slug":"/script/Specializations/DynamicMountAttacher","permalink":"/FS25-Community-LUADOC/script/Specializations/DynamicMountAttacher","draft":false,"unlisted":false,"tags":[],"version":"current","lastUpdatedAt":1767161192000,"frontMatter":{},"sidebar":"docsSidebar","previous":{"title":"Drivable","permalink":"/FS25-Community-LUADOC/script/Specializations/Drivable"},"next":{"title":"DynamicallyLoadedParts","permalink":"/FS25-Community-LUADOC/script/Specializations/DynamicallyLoadedParts"}}');var o=t(74848),c=t(28453);const l={},s=void 0,r={},a=[{value:"DynamicMountAttacher",id:"dynamicmountattacher",level:2},{value:"addDynamicMountedObject",id:"adddynamicmountedobject",level:3},{value:"dynamicMountLockPositionOverlapCallback",id:"dynamicmountlockpositionoverlapcallback",level:3},{value:"dynamicMountTriggerCallback",id:"dynamicmounttriggercallback",level:3},{value:"forceDynamicMountPendingObjects",id:"forcedynamicmountpendingobjects",level:3},{value:"forceUnmountDynamicMountedObjects",id:"forceunmountdynamicmountedobjects",level:3},{value:"getAdditionalComponentMass",id:"getadditionalcomponentmass",level:3},{value:"getAllowDynamicMountFillLevelInfo",id:"getallowdynamicmountfilllevelinfo",level:3},{value:"getAllowDynamicMountObjects",id:"getallowdynamicmountobjects",level:3},{value:"getDynamicMountAttacherSettingsByNode",id:"getdynamicmountattachersettingsbynode",level:3},{value:"getDynamicMountTimeToMount",id:"getdynamicmounttimetomount",level:3},{value:"getFillLevelInformation",id:"getfilllevelinformation",level:3},{value:"getHasDynamicMountedObjects",id:"gethasdynamicmountedobjects",level:3},{value:"getHasObjectMounted",id:"gethasobjectmounted",level:3},{value:"getIsAttachedTo",id:"getisattachedto",level:3},{value:"getIsDynamicLockPositionActive",id:"getisdynamiclockpositionactive",level:3},{value:"getIsDynamicMountGrabOpened",id:"getisdynamicmountgrabopened",level:3},{value:"getIsFoldAllowed",id:"getisfoldallowed",level:3},{value:"getIsMovingToolActive",id:"getismovingtoolactive",level:3},{value:"initSpecialization",id:"initspecialization",level:3},{value:"loadDynamicLockPositionFromXML",id:"loaddynamiclockpositionfromxml",level:3},{value:"loadDynamicMountGrabFromXML",id:"loaddynamicmountgrabfromxml",level:3},{value:"loadExtraDependentParts",id:"loadextradependentparts",level:3},{value:"loadMovingToolFromXML",id:"loadmovingtoolfromxml",level:3},{value:"lockDynamicMountedObject",id:"lockdynamicmountedobject",level:3},{value:"onDelete",id:"ondelete",level:3},{value:"onLoad",id:"onload",level:3},{value:"onPreAttachImplement",id:"onpreattachimplement",level:3},{value:"onReadUpdateStream",id:"onreadupdatestream",level:3},{value:"onUnmountObject",id:"onunmountobject",level:3},{value:"onUpdateTick",id:"onupdatetick",level:3},{value:"onWriteUpdateStream",id:"onwriteupdatestream",level:3},{value:"prerequisitesPresent",id:"prerequisitespresent",level:3},{value:"readDynamicMountObjectsFromStream",id:"readdynamicmountobjectsfromstream",level:3},{value:"registerEventListeners",id:"registereventlisteners",level:3},{value:"registerFunctions",id:"registerfunctions",level:3},{value:"registerOverwrittenFunctions",id:"registeroverwrittenfunctions",level:3},{value:"removeDynamicMountedObject",id:"removedynamicmountedobject",level:3},{value:"setDynamicMountAnimationState",id:"setdynamicmountanimationstate",level:3},{value:"updateDebugValues",id:"updatedebugvalues",level:3},{value:"updateExtraDependentParts",id:"updateextradependentparts",level:3},{value:"writeDynamicMountObjectsToStream",id:"writedynamicmountobjectstostream",level:3}];function d(n){const e={a:"a",blockquote:"blockquote",code:"code",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,c.R)(),...n.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(e.h2,{id:"dynamicmountattacher",children:"DynamicMountAttacher"}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Description"})}),"\n",(0,o.jsxs)(e.blockquote,{children:["\n",(0,o.jsx)(e.p,{children:"Specialization for automatically attaching objects to vehicles (e.g. cutters to cutter trailers, bales to\nbaleforks, ...)"}),"\n"]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Functions"})}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsx)(e.li,{children:(0,o.jsx)(e.a,{href:"#adddynamicmountedobject",children:"addDynamicMountedObject"})}),"\n",(0,o.jsx)(e.li,{children:(0,o.jsx)(e.a,{href:"#dynamicmountlockpositionoverlapcallback",children:"dynamicMountLockPositionOverlapCallback"})}),"\n",(0,o.jsx)(e.li,{children:(0,o.jsx)(e.a,{href:"#dynamicmounttriggercallback",children:"dynamicMountTriggerCallback"})}),"\n",(0,o.jsx)(e.li,{children:(0,o.jsx)(e.a,{href:"#forcedynamicmountpendingobjects",children:"forceDynamicMountPendingObjects"})}),"\n",(0,o.jsx)(e.li,{children:(0,o.jsx)(e.a,{href:"#forceunmountdynamicmountedobjects",children:"forceUnmountDynamicMountedObjects"})}),"\n",(0,o.jsx)(e.li,{children:(0,o.jsx)(e.a,{href:"#getadditionalcomponentmass",children:"getAdditionalComponentMass"})}),"\n",(0,o.jsx)(e.li,{children:(0,o.jsx)(e.a,{href:"#getallowdynamicmountfilllevelinfo",children:"getAllowDynamicMountFillLevelInfo"})}),"\n",(0,o.jsx)(e.li,{children:(0,o.jsx)(e.a,{href:"#getallowdynamicmountobjects",children:"getAllowDynamicMountObjects"})}),"\n",(0,o.jsx)(e.li,{children:(0,o.jsx)(e.a,{href:"#getdynamicmountattachersettingsbynode",children:"getDynamicMountAttacherSettingsByNode"})}),"\n",(0,o.jsx)(e.li,{children:(0,o.jsx)(e.a,{href:"#getdynamicmounttimetomount",children:"getDynamicMountTimeToMount"})}),"\n",(0,o.jsx)(e.li,{children:(0,o.jsx)(e.a,{href:"#getfilllevelinformation",children:"getFillLevelInformation"})}),"\n",(0,o.jsx)(e.li,{children:(0,o.jsx)(e.a,{href:"#gethasdynamicmountedobjects",children:"getHasDynamicMountedObjects"})}),"\n",(0,o.jsx)(e.li,{children:(0,o.jsx)(e.a,{href:"#gethasobjectmounted",children:"getHasObjectMounted"})}),"\n",(0,o.jsx)(e.li,{children:(0,o.jsx)(e.a,{href:"#getisattachedto",children:"getIsAttachedTo"})}),"\n",(0,o.jsx)(e.li,{children:(0,o.jsx)(e.a,{href:"#getisdynamiclockpositionactive",children:"getIsDynamicLockPositionActive"})}),"\n",(0,o.jsx)(e.li,{children:(0,o.jsx)(e.a,{href:"#getisdynamicmountgrabopened",children:"getIsDynamicMountGrabOpened"})}),"\n",(0,o.jsx)(e.li,{children:(0,o.jsx)(e.a,{href:"#getisfoldallowed",children:"getIsFoldAllowed"})}),"\n",(0,o.jsx)(e.li,{children:(0,o.jsx)(e.a,{href:"#getismovingtoolactive",children:"getIsMovingToolActive"})}),"\n",(0,o.jsx)(e.li,{children:(0,o.jsx)(e.a,{href:"#initspecialization",children:"initSpecialization"})}),"\n",(0,o.jsx)(e.li,{children:(0,o.jsx)(e.a,{href:"#loaddynamiclockpositionfromxml",children:"loadDynamicLockPositionFromXML"})}),"\n",(0,o.jsx)(e.li,{children:(0,o.jsx)(e.a,{href:"#loaddynamicmountgrabfromxml",children:"loadDynamicMountGrabFromXML"})}),"\n",(0,o.jsx)(e.li,{children:(0,o.jsx)(e.a,{href:"#loadextradependentparts",children:"loadExtraDependentParts"})}),"\n",(0,o.jsx)(e.li,{children:(0,o.jsx)(e.a,{href:"#loadmovingtoolfromxml",children:"loadMovingToolFromXML"})}),"\n",(0,o.jsx)(e.li,{children:(0,o.jsx)(e.a,{href:"#lockdynamicmountedobject",children:"lockDynamicMountedObject"})}),"\n",(0,o.jsx)(e.li,{children:(0,o.jsx)(e.a,{href:"#ondelete",children:"onDelete"})}),"\n",(0,o.jsx)(e.li,{children:(0,o.jsx)(e.a,{href:"#onload",children:"onLoad"})}),"\n",(0,o.jsx)(e.li,{children:(0,o.jsx)(e.a,{href:"#onpreattachimplement",children:"onPreAttachImplement"})}),"\n",(0,o.jsx)(e.li,{children:(0,o.jsx)(e.a,{href:"#onreadupdatestream",children:"onReadUpdateStream"})}),"\n",(0,o.jsx)(e.li,{children:(0,o.jsx)(e.a,{href:"#onunmountobject",children:"onUnmountObject"})}),"\n",(0,o.jsx)(e.li,{children:(0,o.jsx)(e.a,{href:"#onupdatetick",children:"onUpdateTick"})}),"\n",(0,o.jsx)(e.li,{children:(0,o.jsx)(e.a,{href:"#onwriteupdatestream",children:"onWriteUpdateStream"})}),"\n",(0,o.jsx)(e.li,{children:(0,o.jsx)(e.a,{href:"#prerequisitespresent",children:"prerequisitesPresent"})}),"\n",(0,o.jsx)(e.li,{children:(0,o.jsx)(e.a,{href:"#readdynamicmountobjectsfromstream",children:"readDynamicMountObjectsFromStream"})}),"\n",(0,o.jsx)(e.li,{children:(0,o.jsx)(e.a,{href:"#registereventlisteners",children:"registerEventListeners"})}),"\n",(0,o.jsx)(e.li,{children:(0,o.jsx)(e.a,{href:"#registerfunctions",children:"registerFunctions"})}),"\n",(0,o.jsx)(e.li,{children:(0,o.jsx)(e.a,{href:"#registeroverwrittenfunctions",children:"registerOverwrittenFunctions"})}),"\n",(0,o.jsx)(e.li,{children:(0,o.jsx)(e.a,{href:"#removedynamicmountedobject",children:"removeDynamicMountedObject"})}),"\n",(0,o.jsx)(e.li,{children:(0,o.jsx)(e.a,{href:"#setdynamicmountanimationstate",children:"setDynamicMountAnimationState"})}),"\n",(0,o.jsx)(e.li,{children:(0,o.jsx)(e.a,{href:"#updatedebugvalues",children:"updateDebugValues"})}),"\n",(0,o.jsx)(e.li,{children:(0,o.jsx)(e.a,{href:"#updateextradependentparts",children:"updateExtraDependentParts"})}),"\n",(0,o.jsx)(e.li,{children:(0,o.jsx)(e.a,{href:"#writedynamicmountobjectstostream",children:"writeDynamicMountObjectsToStream"})}),"\n"]}),"\n",(0,o.jsx)(e.h3,{id:"adddynamicmountedobject",children:"addDynamicMountedObject"}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Description"})}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Definition"})}),"\n",(0,o.jsxs)(e.blockquote,{children:["\n",(0,o.jsx)(e.p,{children:"addDynamicMountedObject()"}),"\n"]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,o.jsx)(e.table,{children:(0,o.jsx)(e.thead,{children:(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.th,{children:"any"}),(0,o.jsx)(e.th,{children:"object"})]})})}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Code"})}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-lua",children:'function DynamicMountAttacher:addDynamicMountedObject(object)\n    local spec = self.spec_dynamicMountAttacher\n\n    if spec.dynamicMountedObjects[object] = = nil then\n        spec.dynamicMountedObjects[object] = object\n\n        local lockedToPosition = false\n        if object.getMountableLockPositions ~ = nil then\n            local lockPositions = object:getMountableLockPositions()\n            for i = 1 , #lockPositions do\n                local position = lockPositions[i]\n                if string.endsWith( self.configFileName, position.xmlFilename) then\n                    local jointNode = I3DUtil.indexToObject( self.components, position.jointNode, self.i3dMappings)\n                    if jointNode ~ = nil then\n                        local x, y, z = localToWorld(jointNode, position.transOffset[ 1 ], position.transOffset[ 2 ], position.transOffset[ 3 ])\n                        local rx, ry, rz = localRotationToWorld(jointNode, position.rotOffset[ 1 ], position.rotOffset[ 2 ], position.rotOffset[ 3 ])\n                        if self:lockDynamicMountedObject(object, x, y, z, rx, ry, rz) then\n                            lockedToPosition = true\n                            break\n                        end\n                    end\n                end\n            end\n        end\n\n        if not lockedToPosition and object:isa( Vehicle ) then\n            local minDistancePosition\n            local minDistance = math.huge\n            for _, lockPosition in ipairs(spec.lockPositions) do\n                if self:getIsDynamicLockPositionActive(lockPosition) then\n                    if object.configFileName ~ = nil and string.endsWith(object.configFileName, lockPosition.xmlFilename) then\n                        local foundVehicle = true\n                        if next(lockPosition.configurations) ~ = nil then\n                            for configName, configIndex in pairs(lockPosition.configurations) do\n                                foundVehicle = foundVehicle and(object.configurations = = nil or object.configurations[configName] = = configIndex)\n                            end\n                        end\n\n                        if foundVehicle then\n                            local distance = calcDistanceFrom(lockPosition.jointNode, object.rootNode)\n                            if distance < minDistance then\n                                minDistance = distance\n                                minDistancePosition = lockPosition\n                            end\n                        end\n                    end\n                end\n            end\n\n            if minDistancePosition ~ = nil then\n                if minDistancePosition.width ~ = nil and minDistancePosition.length ~ = nil and minDistancePosition.height ~ = nil then\n                    local x, y, z = localToWorld(minDistancePosition.jointNode, 0 , minDistancePosition.height * 0.5 , 0 )\n                    local rx, ry, rz = getWorldRotation(minDistancePosition.jointNode)\n\n                    spec.overlapBoxHasCollision = false\n                    spec.overlapBoxIgnoreVehicle = object\n                    overlapBox(x, y, z, rx, ry, rz, minDistancePosition.width * 0.5 , minDistancePosition.height * 0.5 , minDistancePosition.length * 0.5 , "dynamicMountLockPositionOverlapCallback" , self , CollisionFlag.VEHICLE, true , false , false , true )\n                    if spec.overlapBoxHasCollision then\n                        minDistancePosition = nil\n                    end\n                    spec.overlapBoxIgnoreVehicle = nil\n                end\n            end\n\n            if minDistancePosition ~ = nil then\n                local x, y, z = getWorldTranslation(minDistancePosition.jointNode)\n                local rx, ry, rz = getWorldRotation(minDistancePosition.jointNode)\n                if self:lockDynamicMountedObject(object, x, y, z, rx, ry, rz) then\n                    ObjectChangeUtil.setObjectChanges(minDistancePosition.objectChanges, true , self , self.setMovingToolDirty)\n\n                    minDistancePosition.state = true\n                    minDistancePosition.object = object\n                end\n            end\n        end\n\n        if spec.transferMass then\n            if object.setReducedComponentMass ~ = nil then\n                if object:getAllowComponentMassReduction() then\n                    object:setReducedComponentMass( true )\n                    self:setMassDirty()\n                end\n            end\n        end\n\n        if not spec.collisionBetweenObjects then\n            for otherObject,_ in pairs(spec.dynamicMountedObjects) do\n                if otherObject ~ = object then\n                    local node1 = object.nodeId or object.rootNode\n                    local node2 = otherObject.nodeId or otherObject.rootNode\n                    if node1 ~ = nil and node2 ~ = nil then\n                        setPairCollision(node1, node2, false )\n                    end\n                end\n            end\n        end\n\n        self:setDynamicMountAnimationState( true )\n\n        self:raiseDirtyFlags(spec.dynamicMountedObjectsDirtyFlag)\n    end\nend\n\n'})}),"\n",(0,o.jsx)(e.h3,{id:"dynamicmountlockpositionoverlapcallback",children:"dynamicMountLockPositionOverlapCallback"}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Description"})}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Definition"})}),"\n",(0,o.jsxs)(e.blockquote,{children:["\n",(0,o.jsx)(e.p,{children:"dynamicMountLockPositionOverlapCallback()"}),"\n"]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,o.jsx)(e.table,{children:(0,o.jsx)(e.thead,{children:(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.th,{children:"any"}),(0,o.jsx)(e.th,{children:"transformId"})]})})}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Code"})}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-lua",children:"function DynamicMountAttacher:dynamicMountLockPositionOverlapCallback(transformId)\n    if g_currentMission.nodeToObject[transformId] ~ = nil or g_currentMission.players[transformId] ~ = nil then\n        local spec = self.spec_dynamicMountAttacher\n        if g_currentMission.nodeToObject[transformId] ~ = self and g_currentMission.nodeToObject[transformId] ~ = spec.overlapBoxIgnoreVehicle then\n            spec.overlapBoxHasCollision = true\n        end\n    end\nend\n\n"})}),"\n",(0,o.jsx)(e.h3,{id:"dynamicmounttriggercallback",children:"dynamicMountTriggerCallback"}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Description"})}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Definition"})}),"\n",(0,o.jsxs)(e.blockquote,{children:["\n",(0,o.jsx)(e.p,{children:"dynamicMountTriggerCallback()"}),"\n"]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,o.jsxs)(e.table,{children:[(0,o.jsx)(e.thead,{children:(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.th,{children:"any"}),(0,o.jsx)(e.th,{children:"triggerId"})]})}),(0,o.jsxs)(e.tbody,{children:[(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.td,{children:"any"}),(0,o.jsx)(e.td,{children:"otherActorId"})]}),(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.td,{children:"any"}),(0,o.jsx)(e.td,{children:"onEnter"})]}),(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.td,{children:"any"}),(0,o.jsx)(e.td,{children:"onLeave"})]}),(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.td,{children:"any"}),(0,o.jsx)(e.td,{children:"onStay"})]}),(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.td,{children:"any"}),(0,o.jsx)(e.td,{children:"otherShapeId"})]})]})]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Code"})}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-lua",children:"function DynamicMountAttacher:dynamicMountTriggerCallback(triggerId, otherActorId, onEnter, onLeave, onStay, otherShapeId)\n    local spec = self.spec_dynamicMountAttacher\n\n    if spec.limitToKnownObjects then\n        local object = g_currentMission:getNodeObject(otherActorId)\n        if object ~ = nil then\n            local foundVehicle = false\n            for i = 1 , #spec.lockPositions do\n                local position = spec.lockPositions[i]\n                if not position.state then\n                    if object.configFileName ~ = nil and string.endsWith(object.configFileName, position.xmlFilename) then\n                        foundVehicle = true\n                        if next(position.configurations) ~ = nil then\n                            for configName, configIndex in pairs(position.configurations) do\n                                foundVehicle = foundVehicle and(object.configurations = = nil or object.configurations[configName] = = configIndex)\n                            end\n                        end\n\n                        if foundVehicle then\n                            break\n                        end\n                    end\n                end\n            end\n\n            if not foundVehicle then\n                return\n            end\n        end\n    end\n\n    if getRigidBodyType(otherActorId) = = RigidBodyType.DYNAMIC\n        and not getHasTrigger(otherActorId) then\n        if onEnter then\n            local object = g_currentMission:getNodeObject(otherActorId)\n            if object = = nil then\n                object = g_currentMission.nodeToObject[otherActorId]\n            end\n            if object = = self.rootVehicle or( self.spec_attachable ~ = nil and self.spec_attachable.attacherVehicle = = object) then\n                object = nil\n            end\n            if object ~ = nil and object ~ = self then\n                -- is a mountable object(e.g.bales)\n                local isObject = object.getSupportsMountDynamic ~ = nil and object:getSupportsMountDynamic() and object.lastMoveTime ~ = nil\n\n                -- is a mountable vehicle(e.g.pallets)\n                local isVehicle = object.getSupportsTensionBelts ~ = nil and object:getSupportsTensionBelts() and object.lastMoveTime ~ = nil\n\n                if isObject or isVehicle then\n                    spec.pendingDynamicMountObjects[object] = Utils.getNoNil(spec.pendingDynamicMountObjects[object], 0 ) + 1\n\n                    if spec.pendingDynamicMountObjects[object] = = 1 then\n                        self:raiseDirtyFlags(spec.dynamicMountedObjectsDirtyFlag)\n                    end\n                end\n            end\n        elseif onLeave then\n                local object = g_currentMission:getNodeObject(otherActorId)\n                if object = = nil then\n                    object = g_currentMission.nodeToObject[otherActorId]\n                end\n                if object ~ = nil then\n                    if spec.pendingDynamicMountObjects[object] ~ = nil then\n                        local count = spec.pendingDynamicMountObjects[object] - 1\n                        if count = = 0 then\n                            spec.pendingDynamicMountObjects[object] = nil\n\n                            if spec.dynamicMountedObjects[object] ~ = nil then\n                                self:removeDynamicMountedObject(object, false )\n                                object:unmountDynamic()\n\n                                if object.additionalDynamicMountJointNode ~ = nil then\n                                    delete(object.additionalDynamicMountJointNode)\n                                    object.additionalDynamicMountJointNode = nil\n                                end\n                            end\n\n                            self:raiseDirtyFlags(spec.dynamicMountedObjectsDirtyFlag)\n                        else\n                                spec.pendingDynamicMountObjects[object] = count\n                            end\n                        end\n                    end\n                end\n            end\n        end\n\n"})}),"\n",(0,o.jsx)(e.h3,{id:"forcedynamicmountpendingobjects",children:"forceDynamicMountPendingObjects"}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Description"})}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Definition"})}),"\n",(0,o.jsxs)(e.blockquote,{children:["\n",(0,o.jsx)(e.p,{children:"forceDynamicMountPendingObjects()"}),"\n"]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,o.jsx)(e.table,{children:(0,o.jsx)(e.thead,{children:(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.th,{children:"any"}),(0,o.jsx)(e.th,{children:"onlyBales"})]})})}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Code"})}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-lua",children:"function DynamicMountAttacher:forceDynamicMountPendingObjects(onlyBales)\n    if self:getAllowDynamicMountObjects() then\n        local spec = self.spec_dynamicMountAttacher\n        for object,_ in pairs(spec.pendingDynamicMountObjects) do\n            if spec.dynamicMountedObjects[object] = = nil then\n                if not onlyBales or object:isa( Bale ) then\n                    local trigger = spec.dynamicMountAttacherTrigger\n                    local couldMount = object:mountDynamic( self , trigger.rootNode, trigger.jointNode, trigger.mountType, trigger.forceAcceleration)\n                    if couldMount then\n                        self:addDynamicMountedObject(object)\n                    end\n                end\n            end\n        end\n    end\nend\n\n"})}),"\n",(0,o.jsx)(e.h3,{id:"forceunmountdynamicmountedobjects",children:"forceUnmountDynamicMountedObjects"}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Description"})}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Definition"})}),"\n",(0,o.jsxs)(e.blockquote,{children:["\n",(0,o.jsx)(e.p,{children:"forceUnmountDynamicMountedObjects()"}),"\n"]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Code"})}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-lua",children:"function DynamicMountAttacher:forceUnmountDynamicMountedObjects()\n    local spec = self.spec_dynamicMountAttacher\n    for object, _ in pairs(spec.dynamicMountedObjects) do\n        self:removeDynamicMountedObject(object, false )\n        object:unmountDynamic()\n\n        if object.additionalDynamicMountJointNode ~ = nil then\n            delete(object.additionalDynamicMountJointNode)\n            object.additionalDynamicMountJointNode = nil\n        end\n    end\nend\n\n"})}),"\n",(0,o.jsx)(e.h3,{id:"getadditionalcomponentmass",children:"getAdditionalComponentMass"}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Description"})}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Definition"})}),"\n",(0,o.jsxs)(e.blockquote,{children:["\n",(0,o.jsx)(e.p,{children:"getAdditionalComponentMass()"}),"\n"]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,o.jsxs)(e.table,{children:[(0,o.jsx)(e.thead,{children:(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.th,{children:"any"}),(0,o.jsx)(e.th,{children:"superFunc"})]})}),(0,o.jsx)(e.tbody,{children:(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.td,{children:"any"}),(0,o.jsx)(e.td,{children:"component"})]})})]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Code"})}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-lua",children:"function DynamicMountAttacher:getAdditionalComponentMass(superFunc, component)\n    local additionalMass = superFunc( self , component)\n    local spec = self.spec_dynamicMountAttacher\n\n    if spec.dynamicMountAttacherTrigger ~ = nil and spec.transferMass then\n        if spec.dynamicMountAttacherTrigger.component = = component.node then\n            for object, _ in pairs(spec.dynamicMountedObjects) do\n                if object.getAllowComponentMassReduction ~ = nil and object:getAllowComponentMassReduction() then\n                    additionalMass = additionalMass + (object:getDefaultMass() - 0.1 )\n                end\n            end\n        end\n    end\n\n    return additionalMass\nend\n\n"})}),"\n",(0,o.jsx)(e.h3,{id:"getallowdynamicmountfilllevelinfo",children:"getAllowDynamicMountFillLevelInfo"}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Description"})}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Definition"})}),"\n",(0,o.jsxs)(e.blockquote,{children:["\n",(0,o.jsx)(e.p,{children:"getAllowDynamicMountFillLevelInfo()"}),"\n"]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Code"})}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-lua",children:"function DynamicMountAttacher:getAllowDynamicMountFillLevelInfo()\n    return true\nend\n\n"})}),"\n",(0,o.jsx)(e.h3,{id:"getallowdynamicmountobjects",children:"getAllowDynamicMountObjects"}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Description"})}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Definition"})}),"\n",(0,o.jsxs)(e.blockquote,{children:["\n",(0,o.jsx)(e.p,{children:"getAllowDynamicMountObjects()"}),"\n"]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Code"})}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-lua",children:"function DynamicMountAttacher:getAllowDynamicMountObjects()\n    return true\nend\n\n"})}),"\n",(0,o.jsx)(e.h3,{id:"getdynamicmountattachersettingsbynode",children:"getDynamicMountAttacherSettingsByNode"}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Description"})}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Definition"})}),"\n",(0,o.jsxs)(e.blockquote,{children:["\n",(0,o.jsx)(e.p,{children:"getDynamicMountAttacherSettingsByNode()"}),"\n"]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,o.jsx)(e.table,{children:(0,o.jsx)(e.thead,{children:(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.th,{children:"any"}),(0,o.jsx)(e.th,{children:"node"})]})})}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Code"})}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-lua",children:"function DynamicMountAttacher:getDynamicMountAttacherSettingsByNode(node)\n    local spec = self.spec_dynamicMountAttacher\n    for _, fork in pairs(spec.forks) do\n        if fork.node = = node then\n            return fork.mountType, fork.forceLimitScale\n        end\n    end\n\n    return DynamicMountUtil.TYPE_FORK, 1\nend\n\n"})}),"\n",(0,o.jsx)(e.h3,{id:"getdynamicmounttimetomount",children:"getDynamicMountTimeToMount"}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Description"})}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Definition"})}),"\n",(0,o.jsxs)(e.blockquote,{children:["\n",(0,o.jsx)(e.p,{children:"getDynamicMountTimeToMount()"}),"\n"]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Code"})}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-lua",children:"function DynamicMountAttacher:getDynamicMountTimeToMount()\n    return self.spec_dynamicMountAttacher.dynamicMountAttacherTimeToMount\nend\n\n"})}),"\n",(0,o.jsx)(e.h3,{id:"getfilllevelinformation",children:"getFillLevelInformation"}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Description"})}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Definition"})}),"\n",(0,o.jsxs)(e.blockquote,{children:["\n",(0,o.jsx)(e.p,{children:"getFillLevelInformation()"}),"\n"]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,o.jsxs)(e.table,{children:[(0,o.jsx)(e.thead,{children:(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.th,{children:"any"}),(0,o.jsx)(e.th,{children:"superFunc"})]})}),(0,o.jsx)(e.tbody,{children:(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.td,{children:"any"}),(0,o.jsx)(e.td,{children:"display"})]})})]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Code"})}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-lua",children:"function DynamicMountAttacher:getFillLevelInformation(superFunc, display)\n    superFunc( self , display)\n\n    if self:getAllowDynamicMountFillLevelInfo() then\n        local spec = self.spec_dynamicMountAttacher\n        for object,_ in pairs(spec.dynamicMountedObjects) do\n            if object.getFillLevelInformation ~ = nil then\n                object:getFillLevelInformation(display)\n            else\n                    if object.getFillLevel ~ = nil and object.getFillType ~ = nil then\n                        local fillType = object:getFillType()\n                        local fillLevel = object:getFillLevel()\n                        local capacity = fillLevel\n                        if object.getCapacity ~ = nil then\n                            capacity = object:getCapacity()\n                        end\n\n                        display:addFillLevel(fillType, fillLevel, capacity)\n                    end\n                end\n            end\n        end\n    end\n\n"})}),"\n",(0,o.jsx)(e.h3,{id:"gethasdynamicmountedobjects",children:"getHasDynamicMountedObjects"}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Description"})}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Definition"})}),"\n",(0,o.jsxs)(e.blockquote,{children:["\n",(0,o.jsx)(e.p,{children:"getHasDynamicMountedObjects()"}),"\n"]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Code"})}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-lua",children:"function DynamicMountAttacher:getHasDynamicMountedObjects()\n    return next( self.spec_dynamicMountAttacher.dynamicMountedObjects) ~ = nil\nend\n\n"})}),"\n",(0,o.jsx)(e.h3,{id:"gethasobjectmounted",children:"getHasObjectMounted"}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Description"})}),"\n",(0,o.jsxs)(e.blockquote,{children:["\n",(0,o.jsx)(e.p,{children:"Returns if the vehicle (or any child) has the given object mounted"}),"\n"]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Definition"})}),"\n",(0,o.jsxs)(e.blockquote,{children:["\n",(0,o.jsx)(e.p,{children:"getHasObjectMounted(table object, )"}),"\n"]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,o.jsxs)(e.table,{children:[(0,o.jsx)(e.thead,{children:(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.th,{children:"table"}),(0,o.jsx)(e.th,{children:"object"}),(0,o.jsx)(e.th,{children:"object"})]})}),(0,o.jsx)(e.tbody,{children:(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.td,{children:"any"}),(0,o.jsx)(e.td,{children:"object"}),(0,o.jsx)(e.td,{})]})})]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Return Values"})}),"\n\n\n\n\n\n\n\n\n",(0,o.jsx)(e.table,{children:(0,o.jsx)(e.thead,{children:(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.th,{children:"any"}),(0,o.jsx)(e.th,{children:"hasObjectMounted"}),(0,o.jsx)(e.th,{children:"has object mounted"})]})})}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Code"})}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-lua",children:"function DynamicMountAttacher:getHasObjectMounted(superFunc, object)\n    if superFunc( self , object) then\n        return true\n    end\n\n    local spec = self.spec_dynamicMountAttacher\n    for dynamicMountedObject, _ in pairs(spec.dynamicMountedObjects) do\n        if dynamicMountedObject = = object then\n            return true\n        end\n\n        if dynamicMountedObject.getHasObjectMounted ~ = nil then\n            if dynamicMountedObject:getHasObjectMounted(object) then\n                return true\n            end\n        end\n    end\n\n    return false\nend\n\n"})}),"\n",(0,o.jsx)(e.h3,{id:"getisattachedto",children:"getIsAttachedTo"}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Description"})}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Definition"})}),"\n",(0,o.jsxs)(e.blockquote,{children:["\n",(0,o.jsx)(e.p,{children:"getIsAttachedTo()"}),"\n"]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,o.jsxs)(e.table,{children:[(0,o.jsx)(e.thead,{children:(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.th,{children:"any"}),(0,o.jsx)(e.th,{children:"superFunc"})]})}),(0,o.jsx)(e.tbody,{children:(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.td,{children:"any"}),(0,o.jsx)(e.td,{children:"vehicle"})]})})]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Code"})}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-lua",children:"function DynamicMountAttacher:getIsAttachedTo(superFunc, vehicle)\n    if superFunc( self , vehicle) then\n        return true\n    end\n\n    local spec = self.spec_dynamicMountAttacher\n\n    for object, _ in pairs(spec.dynamicMountedObjects) do\n        if object = = vehicle then\n            return true\n        end\n    end\n\n    for object, _ in pairs(spec.pendingDynamicMountObjects) do\n        if object = = vehicle then\n            return true\n        end\n    end\n\n    return false\nend\n\n"})}),"\n",(0,o.jsx)(e.h3,{id:"getisdynamiclockpositionactive",children:"getIsDynamicLockPositionActive"}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Description"})}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Definition"})}),"\n",(0,o.jsxs)(e.blockquote,{children:["\n",(0,o.jsx)(e.p,{children:"getIsDynamicLockPositionActive()"}),"\n"]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,o.jsx)(e.table,{children:(0,o.jsx)(e.thead,{children:(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.th,{children:"any"}),(0,o.jsx)(e.th,{children:"lockPosition"})]})})}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Code"})}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-lua",children:"function DynamicMountAttacher:getIsDynamicLockPositionActive(lockPosition)\n    return not lockPosition.state\nend\n\n"})}),"\n",(0,o.jsx)(e.h3,{id:"getisdynamicmountgrabopened",children:"getIsDynamicMountGrabOpened"}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Description"})}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Definition"})}),"\n",(0,o.jsxs)(e.blockquote,{children:["\n",(0,o.jsx)(e.p,{children:"getIsDynamicMountGrabOpened()"}),"\n"]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,o.jsx)(e.table,{children:(0,o.jsx)(e.thead,{children:(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.th,{children:"any"}),(0,o.jsx)(e.th,{children:"grab"})]})})}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Code"})}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-lua",children:"function DynamicMountAttacher:getIsDynamicMountGrabOpened(grab)\n    return true\nend\n\n"})}),"\n",(0,o.jsx)(e.h3,{id:"getisfoldallowed",children:"getIsFoldAllowed"}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Description"})}),"\n",(0,o.jsxs)(e.blockquote,{children:["\n",(0,o.jsx)(e.p,{children:"Returns if fold is allowed"}),"\n"]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Definition"})}),"\n",(0,o.jsxs)(e.blockquote,{children:["\n",(0,o.jsx)(e.p,{children:"getIsFoldAllowed()"}),"\n"]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,o.jsxs)(e.table,{children:[(0,o.jsx)(e.thead,{children:(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.th,{children:"any"}),(0,o.jsx)(e.th,{children:"superFunc"})]})}),(0,o.jsxs)(e.tbody,{children:[(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.td,{children:"any"}),(0,o.jsx)(e.td,{children:"direction"})]}),(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.td,{children:"any"}),(0,o.jsx)(e.td,{children:"onAiTurnOn"})]})]})]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Return Values"})}),"\n\n\n\n\n\n\n\n\n",(0,o.jsx)(e.table,{children:(0,o.jsx)(e.thead,{children:(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.th,{children:"any"}),(0,o.jsx)(e.th,{children:"allowsFold"}),(0,o.jsx)(e.th,{children:"allows folding"})]})})}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Code"})}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-lua",children:'function DynamicMountAttacher:getIsFoldAllowed(superFunc, direction, onAiTurnOn)\n    local spec = self.spec_dynamicMountAttacher\n\n    if not spec.allowFoldingWhileMounted and self:getHasDynamicMountedObjects() then\n        return false , g_i18n:getText( "warning_toolIsFull" )\n    end\n\n    return superFunc( self , direction, onAiTurnOn)\nend\n\n'})}),"\n",(0,o.jsx)(e.h3,{id:"getismovingtoolactive",children:"getIsMovingToolActive"}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Description"})}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Definition"})}),"\n",(0,o.jsxs)(e.blockquote,{children:["\n",(0,o.jsx)(e.p,{children:"getIsMovingToolActive()"}),"\n"]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,o.jsxs)(e.table,{children:[(0,o.jsx)(e.thead,{children:(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.th,{children:"any"}),(0,o.jsx)(e.th,{children:"superFunc"})]})}),(0,o.jsx)(e.tbody,{children:(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.td,{children:"any"}),(0,o.jsx)(e.td,{children:"movingTool"})]})})]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Code"})}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-lua",children:"function DynamicMountAttacher:getIsMovingToolActive(superFunc, movingTool)\n    if not movingTool.dynamicMountAttacherAllowedMounted then\n        if next( self.spec_dynamicMountAttacher.dynamicMountedObjects) ~ = nil then\n            return false\n        end\n    end\n\n    return superFunc( self , movingTool)\nend\n\n"})}),"\n",(0,o.jsx)(e.h3,{id:"initspecialization",children:"initSpecialization"}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Description"})}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Definition"})}),"\n",(0,o.jsxs)(e.blockquote,{children:["\n",(0,o.jsx)(e.p,{children:"initSpecialization()"}),"\n"]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Code"})}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-lua",children:'function DynamicMountAttacher.initSpecialization()\n    local schema = Vehicle.xmlSchema\n    schema:setXMLSpecializationType( "DynamicMountAttacher" )\n\n    schema:register(XMLValueType.NODE_INDEX, "vehicle.dynamicMountAttacher#node" , "Attacher node" )\n    schema:register(XMLValueType.FLOAT, "vehicle.dynamicMountAttacher#forceLimitScale" , "Force limit" , 1 )\n    schema:register(XMLValueType.FLOAT, "vehicle.dynamicMountAttacher#timeToMount" , "No movement time until mounting" , 1000 )\n    schema:register(XMLValueType.BOOL, "vehicle.dynamicMountAttacher#stateChangeMount" , "Mount / unmount the object while the allowed state changes(e.g.due to foldable limits)" , false )\n        schema:register(XMLValueType.INT, "vehicle.dynamicMountAttacher#numObjectBits" , "Number of object bits to sync" , 5 )\n\n        schema:register(XMLValueType.BOOL, "vehicle.dynamicMountAttacher#limitToKnownObjects" , "Only mount objects that are defined with a lockPosition" , false )\n        schema:register(XMLValueType.BOOL, "vehicle.dynamicMountAttacher#collisionBetweenObjects" , "Collision between mounted objects is enabled" , true )\n\n        schema:register(XMLValueType.STRING, "vehicle.dynamicMountAttacher.grab#openMountType" , "Open mount type" , "TYPE_FORK" )\n        schema:register(XMLValueType.STRING, "vehicle.dynamicMountAttacher.grab#closedMountType" , "Closed mount type" , "TYPE_AUTO_ATTACH_XYZ" )\n\n        schema:register(XMLValueType.NODE_INDEX, "vehicle.dynamicMountAttacher.fork(?)#node" , "Fork collision node(starting from FS25 one combined node for front and back part)" )\n            schema:register(XMLValueType.STRING, "vehicle.dynamicMountAttacher.fork(?)#mountType" , "Mount type that is used if object is mounted via this fork node" , "FORK" )\n                schema:register(XMLValueType.FLOAT, "vehicle.dynamicMountAttacher.fork(?)#forceLimitScale" , "Force limit that is used if object is mounted via this fork node" , 1 )\n\n                    schema:register(XMLValueType.NODE_INDEX, "vehicle.dynamicMountAttacher#triggerNode" , "Trigger node" )\n                    schema:register(XMLValueType.NODE_INDEX, "vehicle.dynamicMountAttacher#rootNode" , "Root node" )\n                    schema:register(XMLValueType.NODE_INDEX, "vehicle.dynamicMountAttacher#jointNode" , "Joint node" )\n                    schema:register(XMLValueType.FLOAT, "vehicle.dynamicMountAttacher#forceAcceleration" , "Force acceleration" , 30 )\n                    schema:register(XMLValueType.STRING, "vehicle.dynamicMountAttacher#mountType" , "Mount type" , "TYPE_AUTO_ATTACH_XZ" )\n\n                    schema:register(XMLValueType.BOOL, "vehicle.dynamicMountAttacher#transferMass" , "If this is set to \'true\' the mass of the object to mount is transferred to our own component.This improves physics stability" , false )\n\n                    schema:addDelayedRegistrationPath( "vehicle.dynamicMountAttacher.lockPosition(?)" , "DynamicMountAttacher:lockPosition" )\n                    schema:register(XMLValueType.STRING, "vehicle.dynamicMountAttacher.lockPosition(?)#xmlFilename" , "XML filename of vehicle to lock(needs to match only the end of the filename)" )\n                    schema:register(XMLValueType.NODE_INDEX, "vehicle.dynamicMountAttacher.lockPosition(?)#jointNode" , "Joint node(Represents the position of the other vehicles root node)" )\n                    schema:register(XMLValueType.STRING, "vehicle.dynamicMountAttacher.lockPosition(?).configuration(?)#name" , "Name of configuration" )\n                    schema:register(XMLValueType.INT, "vehicle.dynamicMountAttacher.lockPosition(?).configuration(?)#index" , "Configuration index that needs to match to use the lock position" )\n                    schema:register(XMLValueType.FLOAT, "vehicle.dynamicMountAttacher.lockPosition(?)#width" , "Width of lock position(if defined, collision to other vehicles is checked during locking)" )\n                        schema:register(XMLValueType.FLOAT, "vehicle.dynamicMountAttacher.lockPosition(?)#length" , "Length of lock position(if defined, collision to other vehicles is checked during locking)" )\n                            schema:register(XMLValueType.FLOAT, "vehicle.dynamicMountAttacher.lockPosition(?)#height" , "Height of lock position(if defined, collision to other vehicles is checked during locking)" )\n\n                                ObjectChangeUtil.registerObjectChangeXMLPaths(schema, "vehicle.dynamicMountAttacher.lockPosition(?)" )\n\n                                schema:register(XMLValueType.STRING, "vehicle.dynamicMountAttacher.animation#name" , "Animation name" )\n                                schema:register(XMLValueType.FLOAT, "vehicle.dynamicMountAttacher.animation#speed" , "Animation speed" , 1 )\n\n                                schema:addDelayedRegistrationFunc( "Cylindered:movingTool" , function (cSchema, cKey)\n                                    cSchema:register(XMLValueType.BOOL, cKey .. ".dynamicMountAttacher#value" , "Update dynamic mount attacher joints" )\n                                    cSchema:register(XMLValueType.BOOL, cKey .. ".dynamicMountAttacher#allowedMounted" , "Allow moving tool movement while something is mounted" , true )\n                                    end )\n\n                                    schema:addDelayedRegistrationFunc( "Cylindered:movingPart" , function (cSchema, cKey)\n                                        cSchema:register(XMLValueType.BOOL, cKey .. ".dynamicMountAttacher#value" , "Update dynamic mount attacher joints" )\n                                    end )\n\n                                    schema:register(XMLValueType.BOOL, "vehicle.dynamicMountAttacher#allowFoldingWhileMounted" , "Folding is allowed while a object is mounted" , true )\n\n                                        schema:setXMLSpecializationType()\n                                    end\n\n'})}),"\n",(0,o.jsx)(e.h3,{id:"loaddynamiclockpositionfromxml",children:"loadDynamicLockPositionFromXML"}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Description"})}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Definition"})}),"\n",(0,o.jsxs)(e.blockquote,{children:["\n",(0,o.jsx)(e.p,{children:"loadDynamicLockPositionFromXML()"}),"\n"]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,o.jsxs)(e.table,{children:[(0,o.jsx)(e.thead,{children:(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.th,{children:"any"}),(0,o.jsx)(e.th,{children:"xmlFile"})]})}),(0,o.jsxs)(e.tbody,{children:[(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.td,{children:"any"}),(0,o.jsx)(e.td,{children:"key"})]}),(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.td,{children:"any"}),(0,o.jsx)(e.td,{children:"lockPosition"})]})]})]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Code"})}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-lua",children:'function DynamicMountAttacher:loadDynamicLockPositionFromXML(xmlFile, key, lockPosition)\n    lockPosition.xmlFilename = xmlFile:getValue(key .. "#xmlFilename" )\n    if lockPosition.xmlFilename = = nil then\n        Logging.xmlWarning(xmlFile, "Missing xmlFilename for lock position \'%s\'" , key)\n            return false\n        else\n                lockPosition.xmlFilename = lockPosition.xmlFilename:gsub( "$data" , "data" )\n            end\n\n            lockPosition.jointNode = xmlFile:getValue(key .. "#jointNode" , nil , self.components, self.i3dMappings)\n            if lockPosition.jointNode = = nil then\n                Logging.xmlWarning(xmlFile, "Missing jointNode for lock position \'%s\'" , key)\n                    return false\n                end\n\n                lockPosition.configurations = { }\n                xmlFile:iterate(key .. ".configuration" , function (_, configKey)\n                    local name = self.xmlFile:getValue(configKey .. "#name" )\n                    local index = self.xmlFile:getValue(configKey .. "#index" )\n                    if name ~ = nil and index ~ = nil then\n                        lockPosition.configurations[name] = index\n                    end\n                end )\n\n                lockPosition.width = xmlFile:getValue(key .. "#width" )\n                lockPosition.length = xmlFile:getValue(key .. "#length" )\n                lockPosition.height = xmlFile:getValue(key .. "#height" )\n\n                lockPosition.objectChanges = { }\n                ObjectChangeUtil.loadObjectChangeFromXML(xmlFile, key, lockPosition.objectChanges, self.components, self )\n\n                lockPosition.state = false\n\n                return true\n            end\n\n'})}),"\n",(0,o.jsx)(e.h3,{id:"loaddynamicmountgrabfromxml",children:"loadDynamicMountGrabFromXML"}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Description"})}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Definition"})}),"\n",(0,o.jsxs)(e.blockquote,{children:["\n",(0,o.jsx)(e.p,{children:"loadDynamicMountGrabFromXML()"}),"\n"]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,o.jsxs)(e.table,{children:[(0,o.jsx)(e.thead,{children:(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.th,{children:"any"}),(0,o.jsx)(e.th,{children:"xmlFile"})]})}),(0,o.jsxs)(e.tbody,{children:[(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.td,{children:"any"}),(0,o.jsx)(e.td,{children:"key"})]}),(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.td,{children:"any"}),(0,o.jsx)(e.td,{children:"entry"})]})]})]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Code"})}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-lua",children:'function DynamicMountAttacher:loadDynamicMountGrabFromXML(xmlFile, key, entry)\n    local openMountType = self.xmlFile:getValue(key .. "#openMountType" )\n    entry.openMountType = Utils.getNoNil(DynamicMountUtil[openMountType], DynamicMountUtil.TYPE_FORK)\n\n    local closedMountType = self.xmlFile:getValue(key .. "#closedMountType" )\n    entry.closedMountType = Utils.getNoNil(DynamicMountUtil[closedMountType], DynamicMountUtil.TYPE_AUTO_ATTACH_XYZ)\n\n    entry.currentMountType = entry.openMountType\n\n    return true\nend\n\n'})}),"\n",(0,o.jsx)(e.h3,{id:"loadextradependentparts",children:"loadExtraDependentParts"}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Description"})}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Definition"})}),"\n",(0,o.jsxs)(e.blockquote,{children:["\n",(0,o.jsx)(e.p,{children:"loadExtraDependentParts()"}),"\n"]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,o.jsxs)(e.table,{children:[(0,o.jsx)(e.thead,{children:(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.th,{children:"any"}),(0,o.jsx)(e.th,{children:"superFunc"})]})}),(0,o.jsxs)(e.tbody,{children:[(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.td,{children:"any"}),(0,o.jsx)(e.td,{children:"xmlFile"})]}),(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.td,{children:"any"}),(0,o.jsx)(e.td,{children:"baseName"})]}),(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.td,{children:"any"}),(0,o.jsx)(e.td,{children:"entry"})]})]})]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Code"})}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-lua",children:'function DynamicMountAttacher:loadExtraDependentParts(superFunc, xmlFile, baseName, entry)\n    if not superFunc( self , xmlFile, baseName, entry) then\n        return false\n    end\n\n    entry.updateDynamicMountAttacher = xmlFile:getValue(baseName .. ".dynamicMountAttacher#value" )\n\n    return true\nend\n\n'})}),"\n",(0,o.jsx)(e.h3,{id:"loadmovingtoolfromxml",children:"loadMovingToolFromXML"}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Description"})}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Definition"})}),"\n",(0,o.jsxs)(e.blockquote,{children:["\n",(0,o.jsx)(e.p,{children:"loadMovingToolFromXML()"}),"\n"]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,o.jsxs)(e.table,{children:[(0,o.jsx)(e.thead,{children:(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.th,{children:"any"}),(0,o.jsx)(e.th,{children:"superFunc"})]})}),(0,o.jsxs)(e.tbody,{children:[(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.td,{children:"any"}),(0,o.jsx)(e.td,{children:"xmlFile"})]}),(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.td,{children:"any"}),(0,o.jsx)(e.td,{children:"key"})]}),(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.td,{children:"any"}),(0,o.jsx)(e.td,{children:"entry"})]})]})]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Code"})}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-lua",children:'function DynamicMountAttacher:loadMovingToolFromXML(superFunc, xmlFile, key, entry)\n    if not superFunc( self , xmlFile, key, entry) then\n        return false\n    end\n\n    entry.dynamicMountAttacherAllowedMounted = xmlFile:getValue(key .. ".dynamicMountAttacher#allowedMounted" , true )\n\n    return true\nend\n\n'})}),"\n",(0,o.jsx)(e.h3,{id:"lockdynamicmountedobject",children:"lockDynamicMountedObject"}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Description"})}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Definition"})}),"\n",(0,o.jsxs)(e.blockquote,{children:["\n",(0,o.jsx)(e.p,{children:"lockDynamicMountedObject()"}),"\n"]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,o.jsxs)(e.table,{children:[(0,o.jsx)(e.thead,{children:(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.th,{children:"any"}),(0,o.jsx)(e.th,{children:"object"})]})}),(0,o.jsxs)(e.tbody,{children:[(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.td,{children:"any"}),(0,o.jsx)(e.td,{children:"x"})]}),(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.td,{children:"any"}),(0,o.jsx)(e.td,{children:"y"})]}),(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.td,{children:"any"}),(0,o.jsx)(e.td,{children:"z"})]}),(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.td,{children:"any"}),(0,o.jsx)(e.td,{children:"rx"})]}),(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.td,{children:"any"}),(0,o.jsx)(e.td,{children:"ry"})]}),(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.td,{children:"any"}),(0,o.jsx)(e.td,{children:"rz"})]})]})]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Code"})}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-lua",children:"function DynamicMountAttacher:lockDynamicMountedObject(object, x, y, z, rx, ry, rz)\n    local spec = self.spec_dynamicMountAttacher\n\n    DynamicMountUtil.unmountDynamic(object, false )\n\n    object:removeFromPhysics()\n    spec.pendingDynamicMountObjects[object] = nil -- will be readded on addToPhysics\n\n    object:setAbsolutePosition(x, y, z, rx, ry, rz, nil )\n    object:addToPhysics()\n\n    local trigger = spec.dynamicMountAttacherTrigger\n\n    local couldMount = object:mountDynamic( self , trigger.rootNode, trigger.jointNode, trigger.mountType, trigger.forceAcceleration)\n    if not couldMount then\n        self:removeDynamicMountedObject(object, false )\n        return false\n    end\n\n    return true\nend\n\n"})}),"\n",(0,o.jsx)(e.h3,{id:"ondelete",children:"onDelete"}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Description"})}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Definition"})}),"\n",(0,o.jsxs)(e.blockquote,{children:["\n",(0,o.jsx)(e.p,{children:"onDelete()"}),"\n"]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Code"})}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-lua",children:"function DynamicMountAttacher:onDelete()\n    local spec = self.spec_dynamicMountAttacher\n\n    if self.isServer and spec.dynamicMountedObjects ~ = nil then\n        for object,_ in pairs(spec.dynamicMountedObjects) do\n            object:unmountDynamic()\n        end\n    end\n    if spec.dynamicMountAttacherTrigger ~ = nil then\n        removeTrigger(spec.dynamicMountAttacherTrigger.triggerNode)\n\n        g_currentMission:removeNodeObject(spec.dynamicMountAttacherTrigger.triggerNode)\n    end\nend\n\n"})}),"\n",(0,o.jsx)(e.h3,{id:"onload",children:"onLoad"}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Description"})}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Definition"})}),"\n",(0,o.jsxs)(e.blockquote,{children:["\n",(0,o.jsx)(e.p,{children:"onLoad()"}),"\n"]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,o.jsx)(e.table,{children:(0,o.jsx)(e.thead,{children:(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.th,{children:"any"}),(0,o.jsx)(e.th,{children:"savegame"})]})})}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Code"})}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-lua",children:'function DynamicMountAttacher:onLoad(savegame)\n    local spec = self.spec_dynamicMountAttacher\n\n    XMLUtil.checkDeprecatedXMLElements( self.xmlFile, "vehicle.dynamicMountAttacher#index" , "vehicle.dynamicMountAttacher#node" ) --FS17 to FS19\n    XMLUtil.checkDeprecatedXMLElements( self.xmlFile, "vehicle.dynamicMountAttacher.mountCollisionMask" , "vehicle.dynamicMountAttacher.fork" ) --FS22 to FS25\n\n    -- Allow mountable object to attach them selfs to us\n    spec.dynamicMountAttacherNode = self.xmlFile:getValue( "vehicle.dynamicMountAttacher#node" , nil , self.components, self.i3dMappings)\n    spec.dynamicMountAttacherForceLimitScale = self.xmlFile:getValue( "vehicle.dynamicMountAttacher#forceLimitScale" , 1 )\n    spec.dynamicMountAttacherTimeToMount = self.xmlFile:getValue( "vehicle.dynamicMountAttacher#timeToMount" , 1000 )\n    spec.dynamicMountAttacherStateChangeMount = self.xmlFile:getValue( "vehicle.dynamicMountAttacher#stateChangeMount" , false )\n    spec.numObjectBits = self.xmlFile:getValue( "vehicle.dynamicMountAttacher#numObjectBits" , 5 )\n    spec.maxNumObjectsToSend = 2 ^ spec.numObjectBits - 1\n    spec.limitToKnownObjects = self.xmlFile:getValue( "vehicle.dynamicMountAttacher#limitToKnownObjects" , false )\n    spec.collisionBetweenObjects = self.xmlFile:getValue( "vehicle.dynamicMountAttacher#collisionBetweenObjects" , true )\n\n    local grabKey = "vehicle.dynamicMountAttacher.grab"\n    if self.xmlFile:hasProperty(grabKey) then\n        spec.dynamicMountAttacherGrab = { }\n        self:loadDynamicMountGrabFromXML( self.xmlFile, grabKey, spec.dynamicMountAttacherGrab)\n    end\n\n    spec.pendingDynamicMountObjects = { }\n    spec.lockPositions = { }\n\n    if self.isServer then\n        spec.forks = { }\n\n        for _, key in self.xmlFile:iterator( "vehicle.dynamicMountAttacher.fork" ) do\n            local fork = { }\n            fork.node = self.xmlFile:getValue(key .. "#node" , nil , self.components, self.i3dMappings)\n            if fork.node ~ = nil then\n                if getCollisionFilterGroup(fork.node) ~ = CollisionFlag.VEHICLE_FORK then\n                    Logging.xmlWarning( self.xmlFile, "Fork node \'%s\' has invalid collision filter group, should have %s!" , getName(fork.node), CollisionFlag.getBitAndName(CollisionFlag.VEHICLE_FORK))\n                    continue\n                end\n\n                local mountTypeStr = self.xmlFile:getValue(key .. "#mountType" , "FORK" )\n                fork.mountType = DynamicMountUtil[ "TYPE_" .. mountTypeStr] or DynamicMountUtil.TYPE_FORK\n                fork.forceLimitScale = self.xmlFile:getValue(key .. "#forceLimitScale" , spec.dynamicMountAttacherForceLimitScale)\n\n                table.insert(spec.forks, fork)\n            else\n                    Logging.xmlWarning( self.xmlFile, "Missing node or fork in \'%s\'" , key)\n                end\n            end\n\n            local dynamicMountTrigger = { }\n            dynamicMountTrigger.triggerNode = self.xmlFile:getValue( "vehicle.dynamicMountAttacher#triggerNode" , nil , self.components, self.i3dMappings)\n            dynamicMountTrigger.rootNode = self.xmlFile:getValue( "vehicle.dynamicMountAttacher#rootNode" , nil , self.components, self.i3dMappings)\n            dynamicMountTrigger.jointNode = self.xmlFile:getValue( "vehicle.dynamicMountAttacher#jointNode" , nil , self.components, self.i3dMappings)\n            if dynamicMountTrigger.triggerNode ~ = nil and dynamicMountTrigger.rootNode ~ = nil and dynamicMountTrigger.jointNode ~ = nil then\n                local collisionMask = getCollisionFilterMask(dynamicMountTrigger.triggerNode)\n                if bit32.band(collisionMask, CollisionFlag.DYNAMIC_OBJECT + CollisionFlag.VEHICLE) > 0 then\n                    addTrigger(dynamicMountTrigger.triggerNode, "dynamicMountTriggerCallback" , self )\n\n                    dynamicMountTrigger.forceAcceleration = self.xmlFile:getValue( "vehicle.dynamicMountAttacher#forceAcceleration" , 30 )\n                    local mountTypeString = self.xmlFile:getValue( "vehicle.dynamicMountAttacher#mountType" , "TYPE_AUTO_ATTACH_XZ" )\n                    dynamicMountTrigger.mountType = Utils.getNoNil(DynamicMountUtil[mountTypeString], DynamicMountUtil.TYPE_AUTO_ATTACH_XZ)\n                    dynamicMountTrigger.currentMountType = dynamicMountTrigger.mountType\n                    dynamicMountTrigger.component = self:getParentComponent(dynamicMountTrigger.triggerNode)\n\n                    spec.dynamicMountAttacherTrigger = dynamicMountTrigger\n                else\n                        Logging.xmlWarning( self.xmlFile, "Dynamic Mount trigger has invalid collision filter mask, should have %s or %s!" , CollisionFlag.getBitAndName(CollisionFlag.DYNAMIC_OBJECT), CollisionFlag.getBitAndName(CollisionFlag.VEHICLE))\n                    end\n\n                    if string.contains( string.lower(getName(dynamicMountTrigger.jointNode)), "cutter" ) then\n                        if bit32.band(collisionMask,CollisionFlag.VEHICLE) = = 0 then\n                            Logging.xmlWarning( self.xmlFile, "Dynamic Mount trigger has invalid collision filter mask, should have %s for cutter trailers!" , CollisionFlag.getBitAndName(CollisionFlag.VEHICLE))\n                            end\n                        end\n\n                        g_currentMission:addNodeObject(dynamicMountTrigger.triggerNode, self )\n                    end\n\n                    spec.transferMass = self.xmlFile:getValue( "vehicle.dynamicMountAttacher#transferMass" , false )\n\n                    self.xmlFile:iterate( "vehicle.dynamicMountAttacher.lockPosition" , function (_, key)\n                        local lockPosition = { }\n                        if self:loadDynamicLockPositionFromXML( self.xmlFile, key, lockPosition) then\n                            table.insert(spec.lockPositions, lockPosition)\n                        end\n                    end )\n                end\n\n                spec.animationName = self.xmlFile:getValue( "vehicle.dynamicMountAttacher.animation#name" )\n                spec.animationSpeed = self.xmlFile:getValue( "vehicle.dynamicMountAttacher.animation#speed" , 1 )\n                if spec.animationName ~ = nil then\n                    self:playAnimation(spec.animationName, spec.animationSpeed, self:getAnimationTime(spec.animationName), true )\n                end\n\n                spec.allowFoldingWhileMounted = self.xmlFile:getValue( "vehicle.dynamicMountAttacher#allowFoldingWhileMounted" , true )\n\n                spec.lastMountingIsAllowed = false\n\n                spec.overlapBoxHasCollision = false\n                spec.overlapBoxIgnoreVehicle = nil\n\n                spec.dynamicMountedObjects = { }\n                spec.dynamicMountedObjectsDirtyFlag = self:getNextDirtyFlag()\n            end\n\n'})}),"\n",(0,o.jsx)(e.h3,{id:"onpreattachimplement",children:"onPreAttachImplement"}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Description"})}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Definition"})}),"\n",(0,o.jsxs)(e.blockquote,{children:["\n",(0,o.jsx)(e.p,{children:"onPreAttachImplement()"}),"\n"]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,o.jsxs)(e.table,{children:[(0,o.jsx)(e.thead,{children:(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.th,{children:"any"}),(0,o.jsx)(e.th,{children:"object"})]})}),(0,o.jsxs)(e.tbody,{children:[(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.td,{children:"any"}),(0,o.jsx)(e.td,{children:"inputJointDescIndex"})]}),(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.td,{children:"any"}),(0,o.jsx)(e.td,{children:"jointDescIndex"})]}),(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.td,{children:"any"}),(0,o.jsx)(e.td,{children:"loadFromSavegame"})]})]})]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Code"})}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-lua",children:"function DynamicMountAttacher:onPreAttachImplement(object, inputJointDescIndex, jointDescIndex, loadFromSavegame)\n    local objSpec = object.spec_dynamicMountAttacher\n    if objSpec ~ = nil and self.isServer then\n        objSpec.pendingDynamicMountObjects[ self ] = nil\n        if objSpec.dynamicMountedObjects[ self ] ~ = nil then\n            object:removeDynamicMountedObject( self , false )\n            self:unmountDynamic()\n\n            if object.additionalDynamicMountJointNode ~ = nil then\n                delete(object.additionalDynamicMountJointNode)\n                object.additionalDynamicMountJointNode = nil\n            end\n        end\n    end\nend\n\n"})}),"\n",(0,o.jsx)(e.h3,{id:"onreadupdatestream",children:"onReadUpdateStream"}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Description"})}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Definition"})}),"\n",(0,o.jsxs)(e.blockquote,{children:["\n",(0,o.jsx)(e.p,{children:"onReadUpdateStream()"}),"\n"]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,o.jsxs)(e.table,{children:[(0,o.jsx)(e.thead,{children:(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.th,{children:"any"}),(0,o.jsx)(e.th,{children:"streamId"})]})}),(0,o.jsxs)(e.tbody,{children:[(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.td,{children:"any"}),(0,o.jsx)(e.td,{children:"timestamp"})]}),(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.td,{children:"any"}),(0,o.jsx)(e.td,{children:"connection"})]})]})]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Code"})}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-lua",children:"function DynamicMountAttacher:onReadUpdateStream(streamId, timestamp, connection)\n    if connection:getIsServer() then\n        local spec = self.spec_dynamicMountAttacher\n\n        if streamReadBool(streamId) then\n            local sum = self:readDynamicMountObjectsFromStream(streamId, spec.dynamicMountedObjects)\n            self:setDynamicMountAnimationState(sum > 0 )\n\n            self:readDynamicMountObjectsFromStream(streamId, spec.pendingDynamicMountObjects)\n        end\n    end\nend\n\n"})}),"\n",(0,o.jsx)(e.h3,{id:"onunmountobject",children:"onUnmountObject"}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Description"})}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Definition"})}),"\n",(0,o.jsxs)(e.blockquote,{children:["\n",(0,o.jsx)(e.p,{children:"onUnmountObject()"}),"\n"]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,o.jsx)(e.table,{children:(0,o.jsx)(e.thead,{children:(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.th,{children:"any"}),(0,o.jsx)(e.th,{children:"object"})]})})}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Code"})}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-lua",children:"function DynamicMountAttacher:onUnmountObject(object)\n    local spec = self.spec_dynamicMountAttacher\n    if spec.dynamicMountedObjects[object] ~ = nil then\n        self:removeDynamicMountedObject(object, false )\n    end\nend\n\n"})}),"\n",(0,o.jsx)(e.h3,{id:"onupdatetick",children:"onUpdateTick"}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Description"})}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Definition"})}),"\n",(0,o.jsxs)(e.blockquote,{children:["\n",(0,o.jsx)(e.p,{children:"onUpdateTick()"}),"\n"]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,o.jsxs)(e.table,{children:[(0,o.jsx)(e.thead,{children:(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.th,{children:"any"}),(0,o.jsx)(e.th,{children:"dt"})]})}),(0,o.jsxs)(e.tbody,{children:[(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.td,{children:"any"}),(0,o.jsx)(e.td,{children:"isActiveForInput"})]}),(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.td,{children:"any"}),(0,o.jsx)(e.td,{children:"isActiveForInputIgnoreSelection"})]}),(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.td,{children:"any"}),(0,o.jsx)(e.td,{children:"isSelected"})]})]})]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Code"})}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-lua",children:'function DynamicMountAttacher:onUpdateTick(dt, isActiveForInput, isActiveForInputIgnoreSelection, isSelected)\n    if self.isServer then\n        local spec = self.spec_dynamicMountAttacher\n        local mountingIsAllowed = self:getAllowDynamicMountObjects()\n        if mountingIsAllowed ~ = spec.lastMountingIsAllowed or not spec.dynamicMountAttacherStateChangeMount then\n            spec.lastMountingIsAllowed = mountingIsAllowed\n\n            if mountingIsAllowed then\n                for object,_ in pairs(spec.pendingDynamicMountObjects) do\n                    -- raise active as long as we got pending objects to give the objects a chance to be mounted if they are not moving\n                        self:raiseActive()\n\n                        if spec.dynamicMountedObjects[object] = = nil then\n                            if object.lastMoveTime + self:getDynamicMountTimeToMount() < g_currentMission.time then\n                                local doAttach = false\n                                local objectRoot\n                                if object.components ~ = nil then\n                                    if object.getCanBeMounted ~ = nil then\n                                        doAttach = object:getCanBeMounted()\n                                    elseif entityExists(object.components[ 1 ].node) then\n                                            doAttach = true\n                                        end\n\n                                        objectRoot = object.components[ 1 ].node\n                                    end\n                                    if object.nodeId ~ = nil then\n                                        if object.getCanBeMounted ~ = nil then\n                                            doAttach = object:getCanBeMounted()\n                                        elseif entityExists(object.nodeId) then\n                                                doAttach = true\n                                            end\n                                            objectRoot = object.nodeId\n                                        end\n                                        if doAttach then\n                                            local trigger = spec.dynamicMountAttacherTrigger\n                                            local objectJoint = createTransformGroup( "dynamicMountObjectJoint" )\n                                            link(trigger.jointNode, objectJoint)\n                                            setWorldTranslation(objectJoint, getWorldTranslation(objectRoot))\n\n                                            local couldMount = object:mountDynamic( self , trigger.rootNode, objectJoint, trigger.mountType, trigger.forceAcceleration)\n                                            if couldMount then\n                                                object.additionalDynamicMountJointNode = objectJoint\n                                                self:addDynamicMountedObject(object)\n                                            else\n                                                    delete(objectJoint)\n                                                end\n                                            else\n                                                    spec.pendingDynamicMountObjects[object] = nil\n\n                                                    self:raiseDirtyFlags(spec.dynamicMountedObjectsDirtyFlag)\n                                                end\n                                            end\n                                        else\n                                                spec.pendingDynamicMountObjects[object] = nil\n                                            end\n                                        end\n                                    else\n                                            for object,_ in pairs(spec.dynamicMountedObjects) do\n                                                self:removeDynamicMountedObject(object, false )\n                                                object:unmountDynamic()\n\n                                                if object.additionalDynamicMountJointNode ~ = nil then\n                                                    delete(object.additionalDynamicMountJointNode)\n                                                    object.additionalDynamicMountJointNode = nil\n                                                end\n                                            end\n                                        end\n                                    end\n\n                                    if spec.dynamicMountAttacherGrab ~ = nil then\n                                        for object,_ in pairs(spec.dynamicMountedObjects) do\n                                            local usedMountType = spec.dynamicMountAttacherGrab.closedMountType\n\n                                            if self:getIsDynamicMountGrabOpened(spec.dynamicMountAttacherGrab) then\n                                                usedMountType = spec.dynamicMountAttacherGrab.openMountType\n                                            end\n\n                                            if spec.dynamicMountAttacherGrab.currentMountType ~ = usedMountType then\n                                                spec.dynamicMountAttacherGrab.currentMountType = usedMountType\n\n                                                local x, y, z = getWorldTranslation(spec.dynamicMountAttacherNode)\n                                                setJointPosition(object.dynamicMountJointIndex, 1 , x,y,z)\n                                                if usedMountType = = DynamicMountUtil.TYPE_FORK then\n\n                                                    setJointRotationLimit(object.dynamicMountJointIndex, 0 , true , 0 , 0 )\n                                                    setJointRotationLimit(object.dynamicMountJointIndex, 1 , true , 0 , 0 )\n                                                    setJointRotationLimit(object.dynamicMountJointIndex, 2 , true , 0 , 0 )\n\n                                                    if object.dynamicMountSingleAxisFreeX then\n                                                        setJointTranslationLimit(object.dynamicMountJointIndex, 0 , false , 0 , 0 )\n                                                    else\n                                                            setJointTranslationLimit(object.dynamicMountJointIndex, 0 , true , - 0.01 , 0.01 )\n                                                        end\n                                                        if object.dynamicMountSingleAxisFreeY then\n                                                            setJointTranslationLimit(object.dynamicMountJointIndex, 1 , false , 0 , 0 )\n                                                        else\n                                                                setJointTranslationLimit(object.dynamicMountJointIndex, 1 , true , - 0.01 , 0.01 )\n                                                            end\n                                                            setJointTranslationLimit(object.dynamicMountJointIndex, 2 , false , 0 , 0 )\n                                                        else\n                                                                setJointRotationLimit(object.dynamicMountJointIndex, 0 , true , 0 , 0 )\n                                                                setJointRotationLimit(object.dynamicMountJointIndex, 1 , true , 0 , 0 )\n                                                                setJointRotationLimit(object.dynamicMountJointIndex, 2 , true , 0 , 0 )\n\n                                                                if usedMountType = = DynamicMountUtil.TYPE_AUTO_ATTACH_XYZ or usedMountType = = DynamicMountUtil.TYPE_FIX_ATTACH then\n                                                                    setJointTranslationLimit(object.dynamicMountJointIndex, 0 , true , - 0.01 , 0.01 )\n                                                                    setJointTranslationLimit(object.dynamicMountJointIndex, 1 , true , - 0.01 , 0.01 )\n                                                                    setJointTranslationLimit(object.dynamicMountJointIndex, 2 , true , - 0.01 , 0.01 )\n                                                                elseif usedMountType = = DynamicMountUtil.TYPE_AUTO_ATTACH_XZ then\n                                                                        setJointTranslationLimit(object.dynamicMountJointIndex, 0 , true , - 0.01 , 0.01 )\n                                                                        setJointTranslationLimit(object.dynamicMountJointIndex, 1 , false , 0 , 0 )\n                                                                        setJointTranslationLimit(object.dynamicMountJointIndex, 2 , true , - 0.01 , 0.01 )\n                                                                    elseif usedMountType = = DynamicMountUtil.TYPE_AUTO_ATTACH_Y then\n                                                                            setJointTranslationLimit(object.dynamicMountJointIndex, 0 , false , 0 , 0 )\n                                                                            setJointTranslationLimit(object.dynamicMountJointIndex, 1 , true , - 0.01 , 0.01 )\n                                                                            setJointTranslationLimit(object.dynamicMountJointIndex, 2 , false , 0 , 0 )\n                                                                        end\n                                                                    end\n                                                                end\n                                                            end\n                                                        end\n                                                    end\n                                                end\n\n'})}),"\n",(0,o.jsx)(e.h3,{id:"onwriteupdatestream",children:"onWriteUpdateStream"}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Description"})}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Definition"})}),"\n",(0,o.jsxs)(e.blockquote,{children:["\n",(0,o.jsx)(e.p,{children:"onWriteUpdateStream()"}),"\n"]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,o.jsxs)(e.table,{children:[(0,o.jsx)(e.thead,{children:(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.th,{children:"any"}),(0,o.jsx)(e.th,{children:"streamId"})]})}),(0,o.jsxs)(e.tbody,{children:[(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.td,{children:"any"}),(0,o.jsx)(e.td,{children:"connection"})]}),(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.td,{children:"any"}),(0,o.jsx)(e.td,{children:"dirtyMask"})]})]})]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Code"})}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-lua",children:"function DynamicMountAttacher:onWriteUpdateStream(streamId, connection, dirtyMask)\n    if not connection:getIsServer() then\n        local spec = self.spec_dynamicMountAttacher\n\n        if streamWriteBool(streamId, bit32.band(dirtyMask, spec.dynamicMountedObjectsDirtyFlag) ~ = 0 ) then\n            self:writeDynamicMountObjectsToStream(streamId, spec.dynamicMountedObjects)\n            self:writeDynamicMountObjectsToStream(streamId, spec.pendingDynamicMountObjects)\n        end\n    end\nend\n\n"})}),"\n",(0,o.jsx)(e.h3,{id:"prerequisitespresent",children:"prerequisitesPresent"}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Description"})}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Definition"})}),"\n",(0,o.jsxs)(e.blockquote,{children:["\n",(0,o.jsx)(e.p,{children:"prerequisitesPresent()"}),"\n"]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,o.jsx)(e.table,{children:(0,o.jsx)(e.thead,{children:(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.th,{children:"any"}),(0,o.jsx)(e.th,{children:"specializations"})]})})}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Code"})}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-lua",children:"function DynamicMountAttacher.prerequisitesPresent(specializations)\n    return true\nend\n\n"})}),"\n",(0,o.jsx)(e.h3,{id:"readdynamicmountobjectsfromstream",children:"readDynamicMountObjectsFromStream"}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Description"})}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Definition"})}),"\n",(0,o.jsxs)(e.blockquote,{children:["\n",(0,o.jsx)(e.p,{children:"readDynamicMountObjectsFromStream()"}),"\n"]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,o.jsxs)(e.table,{children:[(0,o.jsx)(e.thead,{children:(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.th,{children:"any"}),(0,o.jsx)(e.th,{children:"streamId"})]})}),(0,o.jsx)(e.tbody,{children:(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.td,{children:"any"}),(0,o.jsx)(e.td,{children:"objects"})]})})]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Code"})}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-lua",children:"function DynamicMountAttacher:readDynamicMountObjectsFromStream(streamId, objects)\n    local spec = self.spec_dynamicMountAttacher\n    local sum = streamReadUIntN(streamId, spec.numObjectBits)\n\n    for k, _ in pairs(objects) do\n        objects[k] = nil\n    end\n\n    for _ = 1 , sum do\n        local object = NetworkUtil.readNodeObject(streamId)\n        if object ~ = nil then\n            objects[object] = object\n        end\n    end\n\n    return sum\nend\n\n"})}),"\n",(0,o.jsx)(e.h3,{id:"registereventlisteners",children:"registerEventListeners"}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Description"})}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Definition"})}),"\n",(0,o.jsxs)(e.blockquote,{children:["\n",(0,o.jsx)(e.p,{children:"registerEventListeners()"}),"\n"]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,o.jsx)(e.table,{children:(0,o.jsx)(e.thead,{children:(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.th,{children:"any"}),(0,o.jsx)(e.th,{children:"vehicleType"})]})})}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Code"})}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-lua",children:'function DynamicMountAttacher.registerEventListeners(vehicleType)\n    SpecializationUtil.registerEventListener(vehicleType, "onLoad" , DynamicMountAttacher )\n    SpecializationUtil.registerEventListener(vehicleType, "onDelete" , DynamicMountAttacher )\n    SpecializationUtil.registerEventListener(vehicleType, "onReadUpdateStream" , DynamicMountAttacher )\n    SpecializationUtil.registerEventListener(vehicleType, "onWriteUpdateStream" , DynamicMountAttacher )\n    SpecializationUtil.registerEventListener(vehicleType, "onUpdateTick" , DynamicMountAttacher )\n    SpecializationUtil.registerEventListener(vehicleType, "onPreAttachImplement" , DynamicMountAttacher )\nend\n\n'})}),"\n",(0,o.jsx)(e.h3,{id:"registerfunctions",children:"registerFunctions"}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Description"})}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Definition"})}),"\n",(0,o.jsxs)(e.blockquote,{children:["\n",(0,o.jsx)(e.p,{children:"registerFunctions()"}),"\n"]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,o.jsx)(e.table,{children:(0,o.jsx)(e.thead,{children:(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.th,{children:"any"}),(0,o.jsx)(e.th,{children:"vehicleType"})]})})}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Code"})}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-lua",children:'function DynamicMountAttacher.registerFunctions(vehicleType)\n    SpecializationUtil.registerFunction(vehicleType, "loadDynamicLockPositionFromXML" , DynamicMountAttacher.loadDynamicLockPositionFromXML)\n    SpecializationUtil.registerFunction(vehicleType, "getIsDynamicLockPositionActive" , DynamicMountAttacher.getIsDynamicLockPositionActive)\n    SpecializationUtil.registerFunction(vehicleType, "writeDynamicMountObjectsToStream" , DynamicMountAttacher.writeDynamicMountObjectsToStream)\n    SpecializationUtil.registerFunction(vehicleType, "readDynamicMountObjectsFromStream" , DynamicMountAttacher.readDynamicMountObjectsFromStream)\n    SpecializationUtil.registerFunction(vehicleType, "getAllowDynamicMountObjects" , DynamicMountAttacher.getAllowDynamicMountObjects)\n    SpecializationUtil.registerFunction(vehicleType, "dynamicMountTriggerCallback" , DynamicMountAttacher.dynamicMountTriggerCallback)\n    SpecializationUtil.registerFunction(vehicleType, "lockDynamicMountedObject" , DynamicMountAttacher.lockDynamicMountedObject)\n    SpecializationUtil.registerFunction(vehicleType, "addDynamicMountedObject" , DynamicMountAttacher.addDynamicMountedObject)\n    SpecializationUtil.registerFunction(vehicleType, "removeDynamicMountedObject" , DynamicMountAttacher.removeDynamicMountedObject)\n    SpecializationUtil.registerFunction(vehicleType, "onUnmountObject" , DynamicMountAttacher.onUnmountObject)\n    SpecializationUtil.registerFunction(vehicleType, "setDynamicMountAnimationState" , DynamicMountAttacher.setDynamicMountAnimationState)\n    SpecializationUtil.registerFunction(vehicleType, "getAllowDynamicMountFillLevelInfo" , DynamicMountAttacher.getAllowDynamicMountFillLevelInfo)\n    SpecializationUtil.registerFunction(vehicleType, "loadDynamicMountGrabFromXML" , DynamicMountAttacher.loadDynamicMountGrabFromXML)\n    SpecializationUtil.registerFunction(vehicleType, "getIsDynamicMountGrabOpened" , DynamicMountAttacher.getIsDynamicMountGrabOpened)\n    SpecializationUtil.registerFunction(vehicleType, "getDynamicMountTimeToMount" , DynamicMountAttacher.getDynamicMountTimeToMount)\n    SpecializationUtil.registerFunction(vehicleType, "getHasDynamicMountedObjects" , DynamicMountAttacher.getHasDynamicMountedObjects)\n    SpecializationUtil.registerFunction(vehicleType, "forceDynamicMountPendingObjects" , DynamicMountAttacher.forceDynamicMountPendingObjects)\n    SpecializationUtil.registerFunction(vehicleType, "forceUnmountDynamicMountedObjects" , DynamicMountAttacher.forceUnmountDynamicMountedObjects)\n    SpecializationUtil.registerFunction(vehicleType, "getDynamicMountAttacherSettingsByNode" , DynamicMountAttacher.getDynamicMountAttacherSettingsByNode)\n    SpecializationUtil.registerFunction(vehicleType, "dynamicMountLockPositionOverlapCallback" , DynamicMountAttacher.dynamicMountLockPositionOverlapCallback)\nend\n\n'})}),"\n",(0,o.jsx)(e.h3,{id:"registeroverwrittenfunctions",children:"registerOverwrittenFunctions"}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Description"})}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Definition"})}),"\n",(0,o.jsxs)(e.blockquote,{children:["\n",(0,o.jsx)(e.p,{children:"registerOverwrittenFunctions()"}),"\n"]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,o.jsx)(e.table,{children:(0,o.jsx)(e.thead,{children:(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.th,{children:"any"}),(0,o.jsx)(e.th,{children:"vehicleType"})]})})}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Code"})}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-lua",children:'function DynamicMountAttacher.registerOverwrittenFunctions(vehicleType)\n    SpecializationUtil.registerOverwrittenFunction(vehicleType, "getFillLevelInformation" , DynamicMountAttacher.getFillLevelInformation)\n    SpecializationUtil.registerOverwrittenFunction(vehicleType, "loadExtraDependentParts" , DynamicMountAttacher.loadExtraDependentParts)\n    SpecializationUtil.registerOverwrittenFunction(vehicleType, "updateExtraDependentParts" , DynamicMountAttacher.updateExtraDependentParts)\n    SpecializationUtil.registerOverwrittenFunction(vehicleType, "getIsAttachedTo" , DynamicMountAttacher.getIsAttachedTo)\n    SpecializationUtil.registerOverwrittenFunction(vehicleType, "getAdditionalComponentMass" , DynamicMountAttacher.getAdditionalComponentMass)\n    SpecializationUtil.registerOverwrittenFunction(vehicleType, "getIsFoldAllowed" , DynamicMountAttacher.getIsFoldAllowed)\n    SpecializationUtil.registerOverwrittenFunction(vehicleType, "loadMovingToolFromXML" , DynamicMountAttacher.loadMovingToolFromXML)\n    SpecializationUtil.registerOverwrittenFunction(vehicleType, "getIsMovingToolActive" , DynamicMountAttacher.getIsMovingToolActive)\nend\n\n'})}),"\n",(0,o.jsx)(e.h3,{id:"removedynamicmountedobject",children:"removeDynamicMountedObject"}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Description"})}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Definition"})}),"\n",(0,o.jsxs)(e.blockquote,{children:["\n",(0,o.jsx)(e.p,{children:"removeDynamicMountedObject()"}),"\n"]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,o.jsxs)(e.table,{children:[(0,o.jsx)(e.thead,{children:(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.th,{children:"any"}),(0,o.jsx)(e.th,{children:"object"})]})}),(0,o.jsx)(e.tbody,{children:(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.td,{children:"any"}),(0,o.jsx)(e.td,{children:"isDeleting"})]})})]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Code"})}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-lua",children:"function DynamicMountAttacher:removeDynamicMountedObject(object, isDeleting)\n    local spec = self.spec_dynamicMountAttacher\n\n    spec.dynamicMountedObjects[object] = nil\n    if isDeleting then\n        spec.pendingDynamicMountObjects[object] = nil\n    end\n\n    for i = 1 , #spec.lockPositions do\n        local position = spec.lockPositions[i]\n        if position.state and position.object = = object then\n            ObjectChangeUtil.setObjectChanges(spec.lockPositions[i].objectChanges, false , self , self.setMovingToolDirty)\n\n            position.state = false\n            position.object = nil\n        end\n    end\n\n    if spec.transferMass then\n        self:setMassDirty()\n    end\n\n    if not spec.collisionBetweenObjects then\n        for otherObject,_ in pairs(spec.dynamicMountedObjects) do\n            if otherObject ~ = object then\n                local node1 = object.nodeId or object.rootNode\n                local node2 = otherObject.nodeId or otherObject.rootNode\n                if node1 ~ = nil and node2 ~ = nil then\n                    setPairCollision(node1, node2, true )\n                end\n            end\n        end\n    end\n\n    self:setDynamicMountAnimationState( false )\n\n    self:raiseDirtyFlags(spec.dynamicMountedObjectsDirtyFlag)\nend\n\n"})}),"\n",(0,o.jsx)(e.h3,{id:"setdynamicmountanimationstate",children:"setDynamicMountAnimationState"}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Description"})}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Definition"})}),"\n",(0,o.jsxs)(e.blockquote,{children:["\n",(0,o.jsx)(e.p,{children:"setDynamicMountAnimationState()"}),"\n"]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,o.jsx)(e.table,{children:(0,o.jsx)(e.thead,{children:(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.th,{children:"any"}),(0,o.jsx)(e.th,{children:"state"})]})})}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Code"})}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-lua",children:"function DynamicMountAttacher:setDynamicMountAnimationState(state)\n    local spec = self.spec_dynamicMountAttacher\n\n    if state then\n        self:playAnimation(spec.animationName, spec.animationSpeed, self:getAnimationTime(spec.animationName), true )\n    else\n            self:playAnimation(spec.animationName, - spec.animationSpeed, self:getAnimationTime(spec.animationName), true )\n        end\n    end\n\n"})}),"\n",(0,o.jsx)(e.h3,{id:"updatedebugvalues",children:"updateDebugValues"}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Description"})}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Definition"})}),"\n",(0,o.jsxs)(e.blockquote,{children:["\n",(0,o.jsx)(e.p,{children:"updateDebugValues()"}),"\n"]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,o.jsx)(e.table,{children:(0,o.jsx)(e.thead,{children:(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.th,{children:"any"}),(0,o.jsx)(e.th,{children:"values"})]})})}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Code"})}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-lua",children:'function DynamicMountAttacher:updateDebugValues(values)\n    local spec = self.spec_dynamicMountAttacher\n\n    if self.isServer then\n        local timeToMount = self.lastMoveTime + spec.dynamicMountAttacherTimeToMount - g_currentMission.time\n        table.insert(values, { name = "timeToMount:" , value = string.format( "%d" , timeToMount) } )\n\n        for object, _ in pairs(spec.pendingDynamicMountObjects) do\n            table.insert(values, { name = "pendingDynamicMountObject:" , value = string.format( "%s timeToMount: %d" , object.configFileNameClean or object, math.max(object.lastMoveTime + spec.dynamicMountAttacherTimeToMount - g_currentMission.time , 0 )) } )\n        end\n\n        for object, _ in pairs(spec.dynamicMountedObjects) do\n            local objectName = object.configFileNameClean or(object.xmlFilename and Utils.getFilenameFromPath(object.xmlFilename)) or object\n            local objectColor = DebugUtil.tableToColor(object)\n            table.insert(values, {\n            name = "dynamicMountedObjects:" ,\n            value = string.format( "%s jointIndex:%s mountOffset:%.3f triggerCount:%s" , objectName, object.dynamicMountJointIndex, object.dynamicMountJointNodeDynamicMountOffset or - 1 , object.dynamicMountObjectTriggerCount),\n            color = objectColor\n            } )\n            local objectNode = object.nodeId or object.rootNode\n            if objectNode ~ = nil then\n                local x,y,z = getWorldTranslation(objectNode)\n                drawDebugPoint(x,y,z, objectColor[ 1 ], objectColor[ 2 ], objectColor[ 3 ], objectColor[ 4 ], false )\n            end\n        end\n    end\n\n    table.insert(values, { name = "allowMountObjects:" , value = string.format( "%s" , self:getAllowDynamicMountObjects()) } )\n\n    if spec.dynamicMountAttacherGrab ~ = nil then\n        table.insert(values, { name = "grabOpened:" , value = string.format( "%s" , self:getIsDynamicMountGrabOpened(spec.dynamicMountAttacherGrab)) } )\n    end\nend\n\n'})}),"\n",(0,o.jsx)(e.h3,{id:"updateextradependentparts",children:"updateExtraDependentParts"}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Description"})}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Definition"})}),"\n",(0,o.jsxs)(e.blockquote,{children:["\n",(0,o.jsx)(e.p,{children:"updateExtraDependentParts()"}),"\n"]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,o.jsxs)(e.table,{children:[(0,o.jsx)(e.thead,{children:(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.th,{children:"any"}),(0,o.jsx)(e.th,{children:"superFunc"})]})}),(0,o.jsxs)(e.tbody,{children:[(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.td,{children:"any"}),(0,o.jsx)(e.td,{children:"part"})]}),(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.td,{children:"any"}),(0,o.jsx)(e.td,{children:"dt"})]})]})]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Code"})}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-lua",children:"function DynamicMountAttacher:updateExtraDependentParts(superFunc, part, dt)\n    superFunc( self , part, dt)\n\n    if self.isServer then\n        if part.updateDynamicMountAttacher ~ = nil and part.updateDynamicMountAttacher then\n            local spec = self.spec_dynamicMountAttacher\n            for object,_ in pairs(spec.dynamicMountedObjects) do\n                setJointFrame(object.dynamicMountJointIndex, 0 , object.dynamicMountJointNode)\n            end\n        end\n    end\nend\n\n"})}),"\n",(0,o.jsx)(e.h3,{id:"writedynamicmountobjectstostream",children:"writeDynamicMountObjectsToStream"}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Description"})}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Definition"})}),"\n",(0,o.jsxs)(e.blockquote,{children:["\n",(0,o.jsx)(e.p,{children:"writeDynamicMountObjectsToStream()"}),"\n"]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,o.jsxs)(e.table,{children:[(0,o.jsx)(e.thead,{children:(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.th,{children:"any"}),(0,o.jsx)(e.th,{children:"streamId"})]})}),(0,o.jsx)(e.tbody,{children:(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.td,{children:"any"}),(0,o.jsx)(e.td,{children:"objects"})]})})]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Code"})}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-lua",children:'function DynamicMountAttacher:writeDynamicMountObjectsToStream(streamId, objects)\n    local spec = self.spec_dynamicMountAttacher\n    local num = math.min( table.size(objects), spec.maxNumObjectsToSend)\n    streamWriteUIntN(streamId, num, spec.numObjectBits)\n\n    local objectIndex = 0\n    for object,_ in pairs(objects) do\n        objectIndex = objectIndex + 1\n        if objectIndex < = num then\n            NetworkUtil.writeNodeObject(streamId, object)\n        else\n                Logging.xmlWarning( self.xmlFile, "Not enough bits to send all mounted objects.Please increase \'%s\'" , "vehicle.dynamicMountAttacher#numObjectBits" )\n            end\n        end\n    end\n\n'})})]})}function h(n={}){const{wrapper:e}={...(0,c.R)(),...n.components};return e?(0,o.jsx)(e,{...n,children:(0,o.jsx)(d,{...n})}):d(n)}},28453(n,e,t){t.d(e,{R:()=>l,x:()=>s});var i=t(96540);const o={},c=i.createContext(o);function l(n){const e=i.useContext(c);return i.useMemo(function(){return"function"==typeof n?n(e):{...e,...n}},[e,n])}function s(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(o):n.components||o:l(n.components),i.createElement(c.Provider,{value:e},n.children)}}}]);