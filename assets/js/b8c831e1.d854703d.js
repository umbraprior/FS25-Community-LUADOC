"use strict";(globalThis.webpackChunkfs25_community_luadoc=globalThis.webpackChunkfs25_community_luadoc||[]).push([[43266],{28453(e,n,t){t.d(n,{R:()=>r,x:()=>c});var s=t(96540);const i={},l=s.createContext(i);function r(e){const n=s.useContext(l);return s.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:r(e.components),s.createElement(l.Provider,{value:n},e.children)}},41923(e,n,t){t.r(n),t.d(n,{assets:()=>o,contentTitle:()=>c,default:()=>h,frontMatter:()=>r,metadata:()=>s,toc:()=>d});const s=JSON.parse('{"id":"script/GUI/FocusManager","title":"FocusManager","description":"FocusManager","source":"@site/../docs/script/GUI/FocusManager.md","sourceDirName":"script/GUI","slug":"/script/GUI/FocusManager","permalink":"/FS25-Community-LUADOC/script/GUI/FocusManager","draft":false,"unlisted":false,"tags":[],"version":"current","lastUpdatedAt":1767161192000,"frontMatter":{},"sidebar":"docsSidebar","previous":{"title":"DynamicFadedBitmapElement","permalink":"/FS25-Community-LUADOC/script/GUI/DynamicFadedBitmapElement"},"next":{"title":"FrameElement","permalink":"/FS25-Community-LUADOC/script/GUI/FrameElement"}}');var i=t(74848),l=t(28453);const r={},c=void 0,o={},d=[{value:"FocusManager",id:"focusmanager",level:2},{value:"checkElementDistance",id:"checkelementdistance",level:3},{value:"deleteGuiFocusData",id:"deleteguifocusdata",level:3},{value:"getClosestPointOnBoundingBox",id:"getclosestpointonboundingbox",level:3},{value:"getDirectionForAxisValue",id:"getdirectionforaxisvalue",level:3},{value:"getElementById",id:"getelementbyid",level:3},{value:"getFocusedElement",id:"getfocusedelement",level:3},{value:"getFocusOverrideFunction",id:"getfocusoverridefunction",level:3},{value:"getNestedFocusTarget",id:"getnestedfocustarget",level:3},{value:"getNextFocusElement",id:"getnextfocuselement",level:3},{value:"getShortestBoundingBoxVector",id:"getshortestboundingboxvector",level:3},{value:"hasFocus",id:"hasfocus",level:3},{value:"inputEvent",id:"inputevent",level:3},{value:"isDirectionLocked",id:"isdirectionlocked",level:3},{value:"isFocusInputLocked",id:"isfocusinputlocked",level:3},{value:"isLocked",id:"islocked",level:3},{value:"linkElements",id:"linkelements",level:3},{value:"loadElementFromCustomValues",id:"loadelementfromcustomvalues",level:3},{value:"loadElementFromXML",id:"loadelementfromxml",level:3},{value:"lockFocusInput",id:"lockfocusinput",level:3},{value:"releaseLock",id:"releaselock",level:3},{value:"releaseMovementFocusInput",id:"releasemovementfocusinput",level:3},{value:"removeElement",id:"removeelement",level:3},{value:"requireLock",id:"requirelock",level:3},{value:"resetFocusInputLocks",id:"resetfocusinputlocks",level:3},{value:"serveAutoFocusId",id:"serveautofocusid",level:3},{value:"setFocus",id:"setfocus",level:3},{value:"setGui",id:"setgui",level:3},{value:"setHighlight",id:"sethighlight",level:3},{value:"setSoundPlayer",id:"setsoundplayer",level:3},{value:"unsetFocus",id:"unsetfocus",level:3},{value:"unsetHighlight",id:"unsethighlight",level:3},{value:"updateFocus",id:"updatefocus",level:3}];function a(e){const n={a:"a",blockquote:"blockquote",code:"code",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,l.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.h2,{id:"focusmanager",children:"FocusManager"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Description"})}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsx)(n.p,{children:"The FocusManager controls which element in the menu system is currently focused\nand allows menu control with only keyboard or gamepad.\nFor each participating gui element the focus state and the next focused gui element\nin each direction is stored. This data is set up directly in the xml file of the gui screen\nand loaded through the loadElementFromXML() function or manually loaded within code by using\nthe loadElementFromCustomValues() method.\nFocus handling is independent for every screen in the GUI. To swap screens the setGui() method\nhas to be used.\nThe focus system is then controlled with 5 actions: MENU_UP, MENU_DOWN, MENU_RIGHT and MENU_LEFT to\nchange the currently focused element in the specified direction and MENU_ACCEPT to activate\nthe currently focused element.\nWhen using dynamically changing objects which cannot be set directly in the XML file of the screen\nthe method createLinkageSystemForElements() can be used to set up direction links between the\npassed elements automatically."}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Functions"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"#checkelementdistance",children:"checkElementDistance"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"#deleteguifocusdata",children:"deleteGuiFocusData"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"#getclosestpointonboundingbox",children:"getClosestPointOnBoundingBox"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"#getdirectionforaxisvalue",children:"getDirectionForAxisValue"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"#getelementbyid",children:"getElementById"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"#getfocusedelement",children:"getFocusedElement"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"#getfocusoverridefunction",children:"getFocusOverrideFunction"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"#getnestedfocustarget",children:"getNestedFocusTarget"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"#getnextfocuselement",children:"getNextFocusElement"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"#getshortestboundingboxvector",children:"getShortestBoundingBoxVector"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"#hasfocus",children:"hasFocus"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"#inputevent",children:"inputEvent"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"#isdirectionlocked",children:"isDirectionLocked"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"#isfocusinputlocked",children:"isFocusInputLocked"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"#islocked",children:"isLocked"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"#linkelements",children:"linkElements"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"#loadelementfromcustomvalues",children:"loadElementFromCustomValues"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"#loadelementfromxml",children:"loadElementFromXML"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"#lockfocusinput",children:"lockFocusInput"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"#releaselock",children:"releaseLock"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"#releasemovementfocusinput",children:"releaseMovementFocusInput"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"#removeelement",children:"removeElement"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"#requirelock",children:"requireLock"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"#resetfocusinputlocks",children:"resetFocusInputLocks"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"#serveautofocusid",children:"serveAutoFocusId"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"#setfocus",children:"setFocus"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"#setgui",children:"setGui"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"#sethighlight",children:"setHighlight"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"#setsoundplayer",children:"setSoundPlayer"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"#unsetfocus",children:"unsetFocus"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"#unsethighlight",children:"unsetHighlight"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"#updatefocus",children:"updateFocus"})}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"checkelementdistance",children:"checkElementDistance"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Description"})}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsx)(n.p,{children:"Checks the distance between two GuiElements with the aim of incrementally finding the closest other element in a\ndirection within a screen view."}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Definition"})}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsx)(n.p,{children:"checkElementDistance(curElement Current, other Other, dirX Scan, dirY Scan, curElementOffsetY Position, closestOther\nPreviously, closestDistanceSq Squared)"}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"curElement"}),(0,i.jsx)(n.th,{children:"Current"}),(0,i.jsx)(n.th,{children:"checking GuiElement"})]})}),(0,i.jsxs)(n.tbody,{children:[(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"other"}),(0,i.jsx)(n.td,{children:"Other"}),(0,i.jsx)(n.td,{children:"GuiElement to compare"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"dirX"}),(0,i.jsx)(n.td,{children:"Scan"}),(0,i.jsx)(n.td,{children:"direction vector x component, normalized to unit length"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"dirY"}),(0,i.jsx)(n.td,{children:"Scan"}),(0,i.jsx)(n.td,{children:"direction vector y component, normalized to unit length"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"curElementOffsetY"}),(0,i.jsx)(n.td,{children:"Position"}),(0,i.jsx)(n.td,{children:"y offset of current element's bounding volume, used when checking for wrap-around"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"closestOther"}),(0,i.jsx)(n.td,{children:"Previously"}),(0,i.jsx)(n.td,{children:"closest other GuiElement"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"closestDistanceSq"}),(0,i.jsx)(n.td,{children:"Squared"}),(0,i.jsx)(n.td,{children:"distance from the current checking element to the previously closest other GuiElement"})]})]})]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Code"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lua",children:"function FocusManager.checkElementDistance(curElement, other, dirX, dirY, curElementOffsetY, closestOther, closestDistanceSq)\n    local retOther = closestOther\n    local retDistSq = closestDistanceSq\n\n    local minX, minY, maxX, maxY = curElement:getBorders()\n    minY = minY + curElementOffsetY\n    maxY = maxY + curElementOffsetY\n\n    local centerX, centerY = curElement:getCenter()\n    centerY = centerY + curElementOffsetY\n\n    if other ~ = curElement and not other.disabled and other:getIsVisible() and other:canReceiveFocus() and not(other:isChildOf(curElement) or curElement:isChildOf(other)) then\n        local otherBoxMinX, otherBoxMinY, otherBoxMaxX, otherBoxMaxY = other:getBorders()\n        local otherCenterX, otherCenterY = other:getCenter()\n\n        -- get vector between bounding box points\n        local elementDirX, elementDirY = FocusManager.getShortestBoundingBoxVector(minX, minY, maxX, maxY, otherBoxMinX, otherBoxMinY, otherBoxMaxX, otherBoxMaxY, otherCenterX, otherCenterY)\n\n        -- test direction and distance of bounding box points\n        local boxDistanceSq = MathUtil.vector2LengthSq(elementDirX, elementDirY)\n        local dot = MathUtil.dotProduct(elementDirX, elementDirY, 0 , dirX, dirY, 0 )\n        if boxDistanceSq < FocusManager.EPSILON then -- boundaries touch, use center points for direction check\n            dot = MathUtil.dotProduct(otherCenterX - centerX, otherCenterY - centerY, 0 , dirX, dirY, 0 )\n        end\n\n        if dot > 0 then -- other element lies in scanning direction\n            local useOther = false\n\n            -- when two elements are equally close, choose the one further up(-y) and/or further left(-x)\n            if closestOther and math.abs(closestDistanceSq - boxDistanceSq) < FocusManager.EPSILON then\n                -- also compare dot products\n                local closestBoxMinX, closestBoxMinY, closestBoxMaxX, closestBoxMaxY = closestOther:getBorders()\n                local closestCenterX, closestCenterY = closestOther:getCenter()\n                local toClosestX, toClosestY = FocusManager.getShortestBoundingBoxVector(minX, minY, maxX, maxY, closestBoxMinX, closestBoxMinY, closestBoxMaxX, closestBoxMaxY, closestCenterX, closestCenterY)\n                local closestDot = MathUtil.dotProduct(toClosestX, toClosestY, 0 , dirX, dirY, 0 )\n\n                if math.abs(closestDot - dot) < FocusManager.EPSILON then -- same distance and angle as previous best\n                    -- when going up, go right first, etc. --\x3e ensure symmetric paths in all directions\n                    if dirY > 0 then\n                        useOther = other.absPosition[ 1 ] > closestOther.absPosition[ 1 ]\n                    elseif dirY < 0 then\n                            useOther = other.absPosition[ 1 ] < closestOther.absPosition[ 1 ]\n                        elseif dirX > 0 then\n                                useOther = other.absPosition[ 2 ] > closestOther.absPosition[ 2 ]\n                            elseif dirX < 0 then\n                                    useOther = other.absPosition[ 2 ] < closestOther.absPosition[ 2 ]\n                                end\n                            elseif dot > closestDot then -- when distance is equal and angles differ, prefer the one closer to the movement direction\n                                    useOther = true\n                                end\n                            elseif boxDistanceSq < closestDistanceSq then\n                                    useOther = true\n                                end\n\n                                if useOther then\n                                    retOther = other\n                                    retDistSq = boxDistanceSq\n                                end\n                            end\n                        end\n\n                        return retOther, retDistSq\n                    end\n\n"})}),"\n",(0,i.jsx)(n.h3,{id:"deleteguifocusdata",children:"deleteGuiFocusData"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Description"})}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsx)(n.p,{children:"Deletes the saved focus data for a specific gui"}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Definition"})}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsx)(n.p,{children:"deleteGuiFocusData(guiName name)"}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n",(0,i.jsx)(n.table,{children:(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"guiName"}),(0,i.jsx)(n.th,{children:"name"}),(0,i.jsx)(n.th,{children:"of the gui"})]})})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Code"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lua",children:"function FocusManager:deleteGuiFocusData(guiName)\n    self.guiFocusData[guiName] = nil\nend\n\n"})}),"\n",(0,i.jsx)(n.h3,{id:"getclosestpointonboundingbox",children:"getClosestPointOnBoundingBox"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Description"})}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsx)(n.p,{children:"Given a point and bounding box, get the closest other point on the bounding box circumference. If the point lies\nwithin the bounding box, it is returned unchanged."}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Definition"})}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsx)(n.p,{children:"getClosestPointOnBoundingBox(x Point, y Point, boxMinX Bounding, boxMinY Bounding, boxMaxX Bounding, boxMaxY Bounding)"}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"x"}),(0,i.jsx)(n.th,{children:"Point"}),(0,i.jsx)(n.th,{children:"X"})]})}),(0,i.jsxs)(n.tbody,{children:[(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"y"}),(0,i.jsx)(n.td,{children:"Point"}),(0,i.jsx)(n.td,{children:"Y"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"boxMinX"}),(0,i.jsx)(n.td,{children:"Bounding"}),(0,i.jsx)(n.td,{children:"box minimum point X"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"boxMinY"}),(0,i.jsx)(n.td,{children:"Bounding"}),(0,i.jsx)(n.td,{children:"box minimum point Y"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"boxMaxX"}),(0,i.jsx)(n.td,{children:"Bounding"}),(0,i.jsx)(n.td,{children:"box maximum point X"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"boxMaxY"}),(0,i.jsx)(n.td,{children:"Bounding"}),(0,i.jsx)(n.td,{children:"box maximum point Y"})]})]})]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Return Values"})}),"\n\n\n\n\n\n\n\n\n",(0,i.jsx)(n.table,{children:(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"boxMaxY"}),(0,i.jsx)(n.th,{children:"point"}),(0,i.jsx)(n.th,{children:"x, y"})]})})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Code"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lua",children:"function FocusManager.getClosestPointOnBoundingBox(x, y, boxMinX, boxMinY, boxMaxX, boxMaxY)\n    local px, py = x, y\n    if x < boxMinX then\n        px = boxMinX\n    elseif x > boxMaxX then\n            px = boxMaxX\n        end\n\n        if y < boxMinY then\n            py = boxMinY\n        elseif y > boxMaxY then\n                py = boxMaxY\n            end\n\n            return px, py\n        end\n\n"})}),"\n",(0,i.jsx)(n.h3,{id:"getdirectionforaxisvalue",children:"getDirectionForAxisValue"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Description"})}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsx)(n.p,{children:"Get a direction value for a given menu input action and value"}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Definition"})}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsx)(n.p,{children:"getDirectionForAxisValue()"}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"any"}),(0,i.jsx)(n.th,{children:"inputAction"})]})}),(0,i.jsx)(n.tbody,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"any"}),(0,i.jsx)(n.td,{children:"value"})]})})]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Code"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lua",children:"function FocusManager.getDirectionForAxisValue(inputAction, value)\n    if value = = nil then\n        return nil\n    end\n\n    local direction = nil\n    if inputAction = = InputAction.MENU_AXIS_UP_DOWN then\n        if value < 0 then\n            direction = FocusManager.BOTTOM\n        elseif value > 0 then\n                direction = FocusManager.TOP\n            end\n        elseif inputAction = = InputAction.MENU_AXIS_LEFT_RIGHT then\n                if value < 0 then\n                    direction = FocusManager.LEFT\n                elseif value > 0 then\n                        direction = FocusManager.RIGHT\n                    end\n                end\n\n                return direction\n            end\n\n"})}),"\n",(0,i.jsx)(n.h3,{id:"getelementbyid",children:"getElementById"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Description"})}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsx)(n.p,{children:"Get a focusable GuiElement in the current view by its ID."}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Definition"})}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsx)(n.p,{children:"getElementById()"}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,i.jsx)(n.table,{children:(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"any"}),(0,i.jsx)(n.th,{children:"id"})]})})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Code"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lua",children:"function FocusManager:getElementById(id)\n    return self.currentFocusData.idToElementMapping[id]\nend\n\n"})}),"\n",(0,i.jsx)(n.h3,{id:"getfocusedelement",children:"getFocusedElement"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Description"})}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsx)(n.p,{children:"Get the currently focused GuiElement"}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Definition"})}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsx)(n.p,{children:"getFocusedElement()"}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Code"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lua",children:"function FocusManager:getFocusedElement()\n    return self.currentFocusData.focusElement\nend\n\n"})}),"\n",(0,i.jsx)(n.h3,{id:"getfocusoverridefunction",children:"getFocusOverrideFunction"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Description"})}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsx)(n.p,{children:"Get a closure override function for elements' getFocusOverride() methods."}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Definition"})}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsx)(n.p,{children:"getFocusOverrideFunction(forDirections List, substitute Element, useSubstituteForFocus (Optional))"}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"forDirections"}),(0,i.jsx)(n.th,{children:"List"}),(0,i.jsx)(n.th,{children:"of directions to override"})]})}),(0,i.jsxs)(n.tbody,{children:[(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"substitute"}),(0,i.jsx)(n.td,{children:"Element"}),(0,i.jsx)(n.td,{children:"to substitute as focus target in overridden direction"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"useSubstituteForFocus"}),(0,i.jsx)(n.td,{children:"(Optional)"}),(0,i.jsx)(n.td,{children:"If true, the substitute parameter will be used as the origin for finding the"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"next focus target in the overridden direction."}),(0,i.jsx)(n.td,{}),(0,i.jsx)(n.td,{})]})]})]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Code"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lua",children:"function FocusManager:getFocusOverrideFunction(forDirections, substitute, useSubstituteForFocus)\n    if forDirections = = nil or #forDirections < 1 then\n        return function (elementSelf, dir) return false , nil end\n    end\n\n    local f = function (elementSelf, dir)\n        for _, overrideDirection in pairs(forDirections) do\n            if dir = = overrideDirection then\n                if useSubstituteForFocus then\n                    local next = self:getNextFocusElement(substitute, dir)\n                    if next then\n                        return true , next\n                    end\n                else\n                        return true , substitute\n                    end\n                end\n            end\n\n            return false , nil\n        end\n\n        return f\n    end\n\n"})}),"\n",(0,i.jsx)(n.h3,{id:"getnestedfocustarget",children:"getNestedFocusTarget"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Description"})}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsx)(n.p,{children:"Get an element's focus target at the deepest nesting depth, e.g. when multiple nested layouts point down to their\nchild elements until only a single element is left which points to itself."}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Definition"})}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsx)(n.p,{children:"getNestedFocusTarget(element GuiElement, direction Focus)"}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"element"}),(0,i.jsx)(n.th,{children:"GuiElement"}),(0,i.jsx)(n.th,{children:"whose focus target needs to be retrieved"})]})}),(0,i.jsx)(n.tbody,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"direction"}),(0,i.jsx)(n.td,{children:"Focus"}),(0,i.jsx)(n.td,{children:"navigation direction"})]})})]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Return Values"})}),"\n\n\n\n\n\n\n\n",(0,i.jsx)(n.table,{children:(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"direction"}),(0,i.jsx)(n.th,{children:"target"})]})})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Code"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lua",children:"function FocusManager.getNestedFocusTarget(element, direction)\n    local target = element\n    local prevTarget = nil\n    while target and prevTarget ~ = target do\n        prevTarget = target\n        target = target:getFocusTarget( FocusManager.OPPOSING_DIRECTIONS[direction], direction)\n    end\n\n    return target\nend\n\n"})}),"\n",(0,i.jsx)(n.h3,{id:"getnextfocuselement",children:"getNextFocusElement"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Description"})}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsx)(n.p,{children:"Find the next other element to the one provided in a given navigation direction"}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Definition"})}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsx)(n.p,{children:"getNextFocusElement(element GUI, direction Direction)"}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"element"}),(0,i.jsx)(n.th,{children:"GUI"}),(0,i.jsx)(n.th,{children:"element which needs a focus link"}),(0,i.jsx)(n.th,{}),(0,i.jsx)(n.th,{}),(0,i.jsx)(n.th,{})]})}),(0,i.jsx)(n.tbody,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"direction"}),(0,i.jsx)(n.td,{children:"Direction"}),(0,i.jsx)(n.td,{children:"constant [TOP"}),(0,i.jsx)(n.td,{children:"BOTTOM"}),(0,i.jsx)(n.td,{children:"LEFT"}),(0,i.jsx)(n.td,{children:"RIGHT]"})]})})]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Return Values"})}),"\n\n\n\n\n\n\n\n\n",(0,i.jsx)(n.table,{children:(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"direction"}),(0,i.jsx)(n.th,{children:"GUI"}),(0,i.jsx)(n.th,{children:"element in given direction which can be linked, actual scanning direction used (may change in wrap around scenarios)"})]})})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Code"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lua",children:"function FocusManager:getNextFocusElement(element, direction)\n    -- if there is a configured next element, return that\n        local nextFocusId = element.focusChangeData[direction]\n        if nextFocusId then\n            return self.currentFocusData.idToElementMapping[nextFocusId], direction\n        end\n        -- otherwise, find the next one based on proximity:\n        local dirX, dirY = unpack( FocusManager.DIRECTION_VECTORS[direction])\n\n        local closestOther = nil\n        local closestDistance = math.huge\n\n        for _, other in pairs( self.currentFocusData.idToElementMapping) do\n            closestOther, closestDistance = FocusManager.checkElementDistance(element, other, dirX, dirY, 0 , closestOther, closestDistance)\n        end\n\n        if closestOther = = nil then\n            -- wrap around\n            if direction = = FocusManager.LEFT then\n                -- look up instead\n                closestOther, direction = self:getNextFocusElement(element, FocusManager.TOP)\n            elseif direction = = FocusManager.RIGHT then\n                    -- look down instead\n                    closestOther, direction = self:getNextFocusElement(element, FocusManager.BOTTOM)\n                else\n                        -- get the right test elements\n                        local validWrapElements = self.currentFocusData.idToElementMapping -- screen wrap around\n                        if element.parent and element.parent.wrapAround then -- local box/area wrap around if required\n                            validWrapElements = element.parent.elements\n                        end\n\n                        local wrapOffsetY = 0\n                        if direction = = FocusManager.TOP then\n                            wrapOffsetY = - 1.2 - element.size[ 2 ] -- below screen must be <-1 to work in all cases, even though screen space is defined within [0, 1]\n                        elseif direction = = FocusManager.BOTTOM then\n                                wrapOffsetY = 1.2 + element.size[ 2 ] -- above screen\n                            end\n\n                            -- try wrapping around\n                            for _, other in pairs(validWrapElements) do\n                                closestOther, closestDistance = FocusManager.checkElementDistance(element, other, dirX, dirY, wrapOffsetY, closestOther, closestDistance)\n                            end\n                        end\n                    end\n\n                    return closestOther, direction\n                end\n\n"})}),"\n",(0,i.jsx)(n.h3,{id:"getshortestboundingboxvector",children:"getShortestBoundingBoxVector"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Description"})}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsx)(n.p,{children:"Calculate the shortest connecting line segment between two bounding boxes. Overlapping boxes will result in flipped\ndirections, so take care."}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Definition"})}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsx)(n.p,{children:"getShortestBoundingBoxVector()"}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"any"}),(0,i.jsx)(n.th,{children:"minX"})]})}),(0,i.jsxs)(n.tbody,{children:[(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"any"}),(0,i.jsx)(n.td,{children:"minY"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"any"}),(0,i.jsx)(n.td,{children:"maxX"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"any"}),(0,i.jsx)(n.td,{children:"maxY"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"any"}),(0,i.jsx)(n.td,{children:"otherBoxMinX"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"any"}),(0,i.jsx)(n.td,{children:"otherBoxMinY"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"any"}),(0,i.jsx)(n.td,{children:"otherBoxMaxX"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"any"}),(0,i.jsx)(n.td,{children:"otherBoxMaxY"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"any"}),(0,i.jsx)(n.td,{children:"otherCenterX"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"any"}),(0,i.jsx)(n.td,{children:"otherCenterY"})]})]})]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Code"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lua",children:"function FocusManager.getShortestBoundingBoxVector(minX, minY, maxX, maxY, otherBoxMinX, otherBoxMinY, otherBoxMaxX, otherBoxMaxY, otherCenterX, otherCenterY)\n    local ePointX, ePointY = FocusManager.getClosestPointOnBoundingBox(otherCenterX, otherCenterY, minX, minY, maxX, maxY)\n\n    -- use the previously calculated bounding box point here to get the closest boundary distance\n    local oPointX, oPointY = FocusManager.getClosestPointOnBoundingBox(ePointX, ePointY, otherBoxMinX, otherBoxMinY, otherBoxMaxX, otherBoxMaxY)\n\n    -- get vector between bounding box points\n    local elementDirX = oPointX - ePointX\n    local elementDirY = oPointY - ePointY\n\n    return elementDirX, elementDirY\nend\n\n"})}),"\n",(0,i.jsx)(n.h3,{id:"hasfocus",children:"hasFocus"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Description"})}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsx)(n.p,{children:"Determine if a GuiElement is currently focused."}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Definition"})}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsx)(n.p,{children:"hasFocus()"}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,i.jsx)(n.table,{children:(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"any"}),(0,i.jsx)(n.th,{children:"element"})]})})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Code"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lua",children:"function FocusManager:hasFocus(element)\n    return(( self.currentFocusData.focusElement = = element) and(element:getIsFocused()))\nend\n\n"})}),"\n",(0,i.jsx)(n.h3,{id:"inputevent",children:"inputEvent"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Description"})}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsx)(n.p,{children:"Handles input and changes focus if required and possible."}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Definition"})}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsx)(n.p,{children:"inputEvent(action Name, value Input, eventUsed Usage)"}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"action"}),(0,i.jsx)(n.th,{children:"Name"}),(0,i.jsx)(n.th,{children:"of navigation action which triggered the event, see InputAction"})]})}),(0,i.jsxs)(n.tbody,{children:[(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"value"}),(0,i.jsx)(n.td,{children:"Input"}),(0,i.jsx)(n.td,{children:"value [-1, 1]"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"eventUsed"}),(0,i.jsx)(n.td,{children:"Usage"}),(0,i.jsx)(n.td,{children:"flag, no action is taken if this is true"})]})]})]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Return Values"})}),"\n\n\n\n\n\n\n\n\n",(0,i.jsx)(n.table,{children:(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"eventUsed"}),(0,i.jsx)(n.th,{children:"if"}),(0,i.jsx)(n.th,{children:"the input event has been consumed, false otherwise"})]})})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Code"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lua",children:"function FocusManager:inputEvent(action, value, eventUsed)\n    local element = self.currentFocusData.focusElement\n\n    local pressedAccept = false\n\n    local direction\n    if action = = InputAction.MENU_AXIS_UP_DOWN and value > g_analogStickVTolerance then\n        direction = FocusManager.TOP\n    elseif action = = InputAction.MENU_AXIS_UP_DOWN and value < - g_analogStickVTolerance then\n            direction = FocusManager.BOTTOM\n        elseif action = = InputAction.MENU_AXIS_LEFT_RIGHT and value < - g_analogStickHTolerance then\n                direction = FocusManager.LEFT\n            elseif action = = InputAction.MENU_AXIS_LEFT_RIGHT and value > g_analogStickHTolerance then\n                    direction = FocusManager.RIGHT\n                end\n\n                if direction ~ = nil then\n                    self:updateFocus(element, direction, eventUsed)\n                end\n\n                if not eventUsed and element ~ = nil and not element.needExternalClick then\n                    pressedAccept = action = = InputAction.MENU_ACCEPT\n                    if pressedAccept and not self:isFocusInputLocked(action) then\n                        -- elements can get unfocused, accept is only allowed for currently focused and visible elements\n                            if element:getIsFocused() and element:getIsVisible() then\n                                self.focusSystemMadeChanges = true\n                                element:onFocusActivate()\n                                self.focusSystemMadeChanges = false\n                            end\n                        end\n                    end\n\n                    return eventUsed or direction ~ = nil or pressedAccept\n                end\n\n"})}),"\n",(0,i.jsx)(n.h3,{id:"isdirectionlocked",children:"isDirectionLocked"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Description"})}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsx)(n.p,{children:"Determine if focus navigation in a given direction is currently locked."}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Definition"})}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsx)(n.p,{children:"isDirectionLocked(direction Navigation)"}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n",(0,i.jsx)(n.table,{children:(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"direction"}),(0,i.jsx)(n.th,{children:"Navigation"}),(0,i.jsx)(n.th,{children:"direction as defined in constants"})]})})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Return Values"})}),"\n\n\n\n\n\n\n\n\n",(0,i.jsx)(n.table,{children:(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"direction"}),(0,i.jsx)(n.th,{children:"if"}),(0,i.jsx)(n.th,{children:"navigation in given direction is locked"})]})})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Code"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lua",children:"function FocusManager:isDirectionLocked(direction)\n    return self.lastInput[direction] ~ = nil\nend\n\n"})}),"\n",(0,i.jsx)(n.h3,{id:"isfocusinputlocked",children:"isFocusInputLocked"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Description"})}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsx)(n.p,{children:"Checks if the focus manager has an input lock on input."}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Definition"})}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsx)(n.p,{children:"isFocusInputLocked(inputAxis InputAction, value Axis)"}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"inputAxis"}),(0,i.jsx)(n.th,{children:"InputAction"}),(0,i.jsx)(n.th,{children:"axis or action code"})]})}),(0,i.jsx)(n.tbody,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"value"}),(0,i.jsx)(n.td,{children:"Axis"}),(0,i.jsx)(n.td,{children:"value [-1, 1] or nil if not a directional axis"})]})})]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Return Values"})}),"\n\n\n\n\n\n\n\n\n",(0,i.jsx)(n.table,{children:(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"value"}),(0,i.jsx)(n.th,{children:"True"}),(0,i.jsx)(n.th,{children:"if locked, false otherwise"})]})})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Code"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lua",children:"function FocusManager:isFocusInputLocked(inputAxis, value)\n    local key = FocusManager.getDirectionForAxisValue(inputAxis, value)\n    if key = = nil and inputAxis ~ = InputAction.MENU_AXIS_UP_DOWN and inputAxis ~ = InputAction.MENU_AXIS_LEFT_RIGHT then\n        key = inputAxis\n    end\n\n    if self.lastInput[key] and self.lockUntil[key] > g_ time then\n        return true\n    else\n            return false\n        end\n    end\n\n"})}),"\n",(0,i.jsx)(n.h3,{id:"islocked",children:"isLocked"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Description"})}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsx)(n.p,{children:"Check if focus input is locked."}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Definition"})}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsx)(n.p,{children:"isLocked()"}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Code"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lua",children:"function FocusManager:isLocked()\n    return FocusManager.isFocusLocked\nend\n\n"})}),"\n",(0,i.jsx)(n.h3,{id:"linkelements",children:"linkElements"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Description"})}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsx)(n.p,{children:"Links an element's focus navigation to another element for a given direction.\nThe link is unidirectional from source to target. If bi-directional links are desired, call this method again with\nswapped arguments."}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Definition"})}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsx)(n.p,{children:"linkElements(sourceElement Source, direction Navigation, targetElement Target)"}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"sourceElement"}),(0,i.jsx)(n.th,{children:"Source"}),(0,i.jsx)(n.th,{children:"element which receives the focus link."})]})}),(0,i.jsxs)(n.tbody,{children:[(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"direction"}),(0,i.jsx)(n.td,{children:"Navigation"}),(0,i.jsx)(n.td,{children:"direction for the link, is not required to be the actual visual direction."})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"targetElement"}),(0,i.jsx)(n.td,{children:"Target"}),(0,i.jsx)(n.td,{children:"element"})]})]})]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Code"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lua",children:'function FocusManager:linkElements(sourceElement, direction, targetElement)\n    if targetElement = = nil then\n        sourceElement.focusChangeData[direction] = "nil"\n    else\n            sourceElement.focusChangeData[direction] = targetElement.focusId\n        end\n    end\n\n'})}),"\n",(0,i.jsx)(n.h3,{id:"loadelementfromcustomvalues",children:"loadElementFromCustomValues"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Description"})}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsx)(n.p,{children:"Add an element to the focus system with custom values.\nThe caller should ensure that explicitly set focus IDs are unique. If a duplicate ID is encountered, only the first\nelement with that focus ID is considered for focusing. The method returns a boolean value to indicate any problems\nwith data assignment. Callers can evaluate the value to check if the given parameters were valid. If in doubt or\nwhen no elaborate focus navigation is needed, rely on automatic focus ID generation by omitting the ID parameter\n(or set it to nil)."}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Definition"})}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsx)(n.p,{children:"loadElementFromCustomValues(element Element, focusId Focus, focusChangeData Custom, focusActive If,\nisAlwaysFocusedOnOpen If)"}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"element"}),(0,i.jsx)(n.th,{children:"Element"}),(0,i.jsx)(n.th,{children:"to add to focus system"})]})}),(0,i.jsxs)(n.tbody,{children:[(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"focusId"}),(0,i.jsx)(n.td,{children:"Focus"}),(0,i.jsx)(n.td,{children:"ID for element"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"focusChangeData"}),(0,i.jsx)(n.td,{children:"Custom"}),(0,i.jsx)(n.td,{children:"focus navigation data for the element (map of direction to focus ID)"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"focusActive"}),(0,i.jsx)(n.td,{children:"If"}),(0,i.jsx)(n.td,{children:"true, the element should be focused right now"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"isAlwaysFocusedOnOpen"}),(0,i.jsx)(n.td,{children:"If"}),(0,i.jsx)(n.td,{children:"true, the element is supposed to be focused when its parent view is opened."})]})]})]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Return Values"})}),"\n\n\n\n\n\n\n\n\n",(0,i.jsx)(n.table,{children:(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"isAlwaysFocusedOnOpen"}),(0,i.jsx)(n.th,{children:"if"}),(0,i.jsx)(n.th,{children:"the element and all of its children could be set up with the given values, false otherwise."})]})})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Code"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lua",children:"function FocusManager:loadElementFromCustomValues(element, focusId, focusChangeData, focusActive, isAlwaysFocusedOnOpen)\n    if focusId and self.currentFocusData.idToElementMapping[focusId] then\n        return false -- ignore element, caller is responsible for sensible ID assignment when specified\n        end\n\n        if not element.focusId then\n            if not focusId then\n                focusId = FocusManager.serveAutoFocusId()\n            end\n\n            element.focusId = focusId\n        end\n\n        element.focusChangeData = element.focusChangeData or focusChangeData or { }\n        element.isAlwaysFocusedOnOpen = isAlwaysFocusedOnOpen\n\n        if FocusManager.allElements[element] = = nil then\n            FocusManager.allElements[element] = { }\n        end\n        table.insert( FocusManager.allElements[element], self.currentGui)\n        self.currentFocusData.idToElementMapping[element.focusId] = element\n\n        if isAlwaysFocusedOnOpen then\n            self.currentFocusData.initialFocusElement = element\n        end\n\n        if focusActive then\n            self:setFocus(element)\n        end\n\n        local success = true\n        for _, child in pairs(element.elements) do\n            success = success and self:loadElementFromCustomValues(child, child.focusId, child.focusChangeData, child.focusActive, child.isAlwaysFocusedOnOpen)\n        end\n\n        return success\n    end\n\n"})}),"\n",(0,i.jsx)(n.h3,{id:"loadelementfromxml",children:"loadElementFromXML"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Description"})}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsx)(n.p,{children:"Load GuiElement focus data from its XML definition.\nThis is called at the end of GuiElement:loadFromXML()."}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Definition"})}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsx)(n.p,{children:"loadElementFromXML()"}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"any"}),(0,i.jsx)(n.th,{children:"xmlFile"})]})}),(0,i.jsxs)(n.tbody,{children:[(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"any"}),(0,i.jsx)(n.td,{children:"xmlBaseNode"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"any"}),(0,i.jsx)(n.td,{children:"element"})]})]})]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Code"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lua",children:'function FocusManager:loadElementFromXML(xmlFile, xmlBaseNode, element)\n    local focusId = getXMLString(xmlFile, xmlBaseNode .. "#focusId" )\n    if not focusId then\n        focusId = FocusManager.serveAutoFocusId()\n    end\n\n    element.focusId = focusId\n    element.focusChangeData = { }\n    -- assign focus change data from configuration if it has not been set by code:\n        if not element.focusChangeData[ FocusManager.TOP] then\n            element.focusChangeData[ FocusManager.TOP] = getXMLString(xmlFile, xmlBaseNode .. "#focusChangeTop" )\n        end\n\n        if not element.focusChangeData[ FocusManager.BOTTOM] then\n            element.focusChangeData[ FocusManager.BOTTOM] = getXMLString(xmlFile, xmlBaseNode .. "#focusChangeBottom" )\n        end\n\n        if not element.focusChangeData[ FocusManager.LEFT] then\n            element.focusChangeData[ FocusManager.LEFT] = getXMLString(xmlFile, xmlBaseNode .. "#focusChangeLeft" )\n        end\n\n        if not element.focusChangeData[ FocusManager.RIGHT] then\n            element.focusChangeData[ FocusManager.RIGHT] = getXMLString(xmlFile, xmlBaseNode .. "#focusChangeRight" )\n        end\n\n        -- Disabled:it is unused at time of writing but breaks special focus setups for the construction screen\n            --[[\n            if GS_IS_CONSOLE_VERSION then\n                element.focusChangeData[FocusManager.TOP] = Utils.getNoNil(getXMLString(xmlFile, xmlBaseNode .. "#consoleFocusChangeTop"), element.focusChangeData[FocusManager.TOP])\n                element.focusChangeData[FocusManager.BOTTOM] = Utils.getNoNil(getXMLString(xmlFile, xmlBaseNode .. "#consoleFocusChangeBottom"), element.focusChangeData[FocusManager.BOTTOM])\n                element.focusChangeData[FocusManager.LEFT] = Utils.getNoNil(getXMLString(xmlFile, xmlBaseNode .. "#consoleFocusChangeLeft"), element.focusChangeData[FocusManager.LEFT])\n                element.focusChangeData[FocusManager.RIGHT] = Utils.getNoNil(getXMLString(xmlFile, xmlBaseNode .. "#consoleFocusChangeRight"), element.focusChangeData[FocusManager.RIGHT])\n\n                if element.focusChangeData[FocusManager.TOP] = = "nil" then\n                    element.focusChangeData[FocusManager.TOP] = nil\n                end\n\n                if element.focusChangeData[FocusManager.BOTTOM] = = "nil" then\n                    element.focusChangeData[FocusManager.BOTTOM] = nil\n                end\n\n                if element.focusChangeData[FocusManager.LEFT] = = "nil" then\n                    element.focusChangeData[FocusManager.LEFT] = nil\n                end\n\n                if element.focusChangeData[FocusManager.RIGHT] = = "nil" then\n                    element.focusChangeData[FocusManager.RIGHT] = nil\n                end\n            end\n            ]]\n\n            element.focused = (getXMLString(xmlFile, xmlBaseNode .. "#focusInit" ) ~ = nil )\n            local isAlwaysFocusedOnOpen = (getXMLString(xmlFile, xmlBaseNode .. "#focusInit" ) = = "onOpen" )\n            element.isAlwaysFocusedOnOpen = isAlwaysFocusedOnOpen\n\n            local focusChangeOverride = getXMLString(xmlFile, xmlBaseNode .. "#focusChangeOverride" )\n            if focusChangeOverride then\n                if element.target and element.target.focusChangeOverride then\n                    element.focusChangeOverride = element.target[focusChangeOverride]\n                else\n                        self.focusChangeOverride = ClassUtil.getFunction(focusChangeOverride)\n                    end\n                end\n\n                if FocusManager.allElements[element] = = nil then\n                    FocusManager.allElements[element] = { }\n                end\n                table.insert( FocusManager.allElements[element], self.currentGui)\n                self.currentFocusData.idToElementMapping[focusId] = element\n\n                if isAlwaysFocusedOnOpen then\n                    self.currentFocusData.initialFocusElement = element\n\n                    -- Force disable any sounds when loading\n                    local old = element.soundDisabled\n                    element.soundDisabled = true\n                    self:setFocus(element)\n                    element.soundDisabled = old\n                else\n                        if not self.currentFocusData.focusElement then\n                            self.currentFocusData.focusElement = element\n                        end\n                    end\n                end\n\n'})}),"\n",(0,i.jsx)(n.h3,{id:"lockfocusinput",children:"lockFocusInput"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Description"})}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsx)(n.p,{children:"Locks a given input axis action's input for a time. Until the delay has passed, the focus manager will not react to\nthat input."}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Definition"})}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsx)(n.p,{children:"lockFocusInput(inputAxis InputAction, delay Delay, value Axis)"}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"inputAxis"}),(0,i.jsx)(n.th,{children:"InputAction"}),(0,i.jsx)(n.th,{children:"axis or action code"})]})}),(0,i.jsxs)(n.tbody,{children:[(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"delay"}),(0,i.jsx)(n.td,{children:"Delay"}),(0,i.jsx)(n.td,{children:"in ms"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"value"}),(0,i.jsx)(n.td,{children:"Axis"}),(0,i.jsx)(n.td,{children:"value [-1, 1], only relevant to identify directional axes"})]})]})]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Code"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lua",children:"function FocusManager:lockFocusInput(axisAction, delay, value)\n    local key = FocusManager.getDirectionForAxisValue(axisAction, value)\n    if not key and axisAction ~ = InputAction.MENU_AXIS_UP_DOWN and axisAction ~ = InputAction.MENU_AXIS_LEFT_RIGHT then\n        key = axisAction\n    end\n\n    self.lastInput[key] = g_ time\n    self.lockUntil[key] = g_ time + delay\nend\n\n"})}),"\n",(0,i.jsx)(n.h3,{id:"releaselock",children:"releaseLock"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Description"})}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsx)(n.p,{children:"Release the global focus input lock."}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Definition"})}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsx)(n.p,{children:"releaseLock()"}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Code"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lua",children:"function FocusManager:releaseLock()\n    FocusManager.isFocusLocked = false\nend\n\n"})}),"\n",(0,i.jsx)(n.h3,{id:"releasemovementfocusinput",children:"releaseMovementFocusInput"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Description"})}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsx)(n.p,{children:"Release a focus movement input lock on an action.\nCalled by the UI input handling code. Avoid calling this for anything else."}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Definition"})}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsx)(n.p,{children:"releaseMovementFocusInput(action Focus)"}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n",(0,i.jsx)(n.table,{children:(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"action"}),(0,i.jsx)(n.th,{children:"Focus"}),(0,i.jsx)(n.th,{children:"movement input action name"})]})})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Code"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lua",children:"function FocusManager:releaseMovementFocusInput(action)\n    -- on input release we do not have a direction input value, need to clear lock for both directions on axes:\n        if action = = InputAction.MENU_AXIS_LEFT_RIGHT then\n            self.lastInput[ FocusManager.LEFT] = nil\n            self.lockUntil[ FocusManager.LEFT] = nil\n            self.lastInput[ FocusManager.RIGHT] = nil\n            self.lockUntil[ FocusManager.RIGHT] = nil\n        elseif action = = InputAction.MENU_AXIS_UP_DOWN then\n                self.lastInput[ FocusManager.TOP] = nil\n                self.lockUntil[ FocusManager.TOP] = nil\n                self.lastInput[ FocusManager.BOTTOM] = nil\n                self.lockUntil[ FocusManager.BOTTOM] = nil\n            end\n        end\n\n"})}),"\n",(0,i.jsx)(n.h3,{id:"removeelement",children:"removeElement"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Description"})}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsx)(n.p,{children:"Remove a GuiElement from the current focus context."}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Definition"})}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsx)(n.p,{children:"removeElement()"}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,i.jsx)(n.table,{children:(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"any"}),(0,i.jsx)(n.th,{children:"element"})]})})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Code"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lua",children:"function FocusManager:removeElement(element)\n    if not element.focusId then\n        return\n    end\n\n    for _, child in pairs(element.elements) do\n        self:removeElement(child)\n    end\n\n    if element:getIsFocused() then\n        element:onFocusLeave()\n        FocusManager:unsetFocus(element)\n    end\n\n    if FocusManager.allElements[element] ~ = nil then\n        for _, guiItWasAddedTo in ipairs( FocusManager.allElements[element]) do\n            local data = self.guiFocusData[guiItWasAddedTo]\n            data.idToElementMapping[element.focusId] = nil\n            if data.focusElement = = element then\n                data.focusElement = nil\n            end\n        end\n\n        FocusManager.allElements[element] = nil -- remove\n    end\n\n    self.currentFocusData.idToElementMapping[element.focusId] = nil\n    element.focusId = nil\n    element.focusChangeData = { }\n\n    if self.currentFocusData.focusElement = = element then\n        self.currentFocusData.focusElement = nil\n    end\nend\n\n"})}),"\n",(0,i.jsx)(n.h3,{id:"requirelock",children:"requireLock"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Description"})}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsx)(n.p,{children:"Globally lock focus input."}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Definition"})}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsx)(n.p,{children:"requireLock()"}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Code"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lua",children:"function FocusManager:requireLock()\n    FocusManager.isFocusLocked = true\nend\n\n"})}),"\n",(0,i.jsx)(n.h3,{id:"resetfocusinputlocks",children:"resetFocusInputLocks"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Description"})}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsx)(n.p,{children:"Reset all locks of focus input."}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Definition"})}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsx)(n.p,{children:"resetFocusInputLocks()"}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Code"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lua",children:"function FocusManager:resetFocusInputLocks()\n    for k, _ in pairs( self.lastInput) do\n        self.lastInput[k] = nil\n    end\n    for k, _ in pairs( self.lockUntil) do\n        self.lockUntil[k] = 0\n    end\nend\n\n"})}),"\n",(0,i.jsx)(n.h3,{id:"serveautofocusid",children:"serveAutoFocusId"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Description"})}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsx)(n.p,{children:"Get a new automatic focus ID.\nIt's based on a simple integer increment and will be unique unless billions of elements require an ID."}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Definition"})}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsx)(n.p,{children:"serveAutoFocusId()"}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Code"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lua",children:'function FocusManager.serveAutoFocusId()\n    local focusId = string.format( "focusAuto_%d" , FocusManager.autoIDcount)\n    FocusManager.autoIDcount = FocusManager.autoIDcount + 1\n    return focusId\nend\n\n'})}),"\n",(0,i.jsx)(n.h3,{id:"setfocus",children:"setFocus"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Description"})}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsx)(n.p,{children:"Set focus on a GuiElement or its focus target.\nApplies overlay state and triggers onFocusEnter() on the target."}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Definition"})}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsx)(n.p,{children:"setFocus(element Element, direction Focus, ... Variable)"}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"element"}),(0,i.jsx)(n.th,{children:"Element"}),(0,i.jsx)(n.th,{children:"whose focus target (usually itself) receives focus."})]})}),(0,i.jsxs)(n.tbody,{children:[(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"direction"}),(0,i.jsx)(n.td,{children:"Focus"}),(0,i.jsx)(n.td,{children:"navigation direction"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"..."}),(0,i.jsx)(n.td,{children:"Variable"}),(0,i.jsx)(n.td,{children:"arguments to pass on to the onFocusEnter callback of the target element"})]})]})]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Return Values"})}),"\n\n\n\n\n\n\n\n\n",(0,i.jsx)(n.table,{children:(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"..."}),(0,i.jsx)(n.th,{children:"if"}),(0,i.jsx)(n.th,{children:"focus has changed, false otherwise"})]})})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Code"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lua",children:'function FocusManager:setFocus(element, direction, .. .)\n    if FocusManager.isFocusLocked or element = = nil or not element:canReceiveFocus() then\n        return false\n    end\n\n    -- get the element\'s focus target(or a descendant\'s) to return\n    local targetElement = FocusManager.getNestedFocusTarget(element, direction)\n    if targetElement.target = = nil or targetElement.target.name ~ = self.currentGui then\n        return false\n    end\n\n    if self.currentFocusData.focusElement and\n        self.currentFocusData.focusElement = = targetElement and\n        self.currentFocusData.focusElement:getIsFocused() then\n        -- the passed element already has focus\n        return false\n    end\n\n    -- clear focus and highlight on previous elements\n    if self.currentFocusData.focusElement ~ = nil then\n        self:unsetFocus( self.currentFocusData.focusElement)\n        self:unsetHighlight( self.currentFocusData.highlightElement)\n    end\n\n    -- set focus of newly focused element\n    targetElement:setFocused( true )\n    self.currentFocusData.focusElement = targetElement\n    targetElement:onFocusEnter( .. .)\n\n    if FocusManager.DEBUG then\n        log( "focus changed to element" , targetElement, "; ID:" , targetElement.id, "; profile:" , targetElement.profile, "; type:" , targetElement.typeName)\n    end\n\n    if not element:getSoundSuppressed() and element:getIsVisible() and(element.playHoverSoundOnFocus ~ = false or targetElement.customFocusSample ~ = nil ) and not element.soundDisabled then\n        self.soundPlayer:playSample(targetElement.customFocusSample or GuiSoundPlayer.SOUND_SAMPLES.HOVER)\n    end\n\n    return true\nend\n\n'})}),"\n",(0,i.jsx)(n.h3,{id:"setgui",children:"setGui"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Description"})}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsx)(n.p,{children:"Set the active GUI for focus input."}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Definition"})}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsx)(n.p,{children:"setGui(gui Screen)"}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n",(0,i.jsx)(n.table,{children:(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"gui"}),(0,i.jsx)(n.th,{children:"Screen"}),(0,i.jsx)(n.th,{children:"root GuiElement"})]})})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Code"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lua",children:"function FocusManager:setGui(gui)\n    -- reset old gui focus\n    if self.currentFocusData then\n        local focusElement = self.currentFocusData.focusElement\n        if focusElement then\n            self:unsetFocus(focusElement)\n        end\n\n        local highlightElement = self.currentFocusData.highlightElement\n        if highlightElement then\n            self:unsetHighlight(highlightElement)\n        end\n    end\n\n    -- set(up) new gui focus\n    self.currentGui = gui\n    self.currentFocusData = self.guiFocusData[gui]\n    if not self.currentFocusData then\n        self.guiFocusData[gui] = { }\n        self.guiFocusData[gui].idToElementMapping = { } -- all elements\n        self.currentFocusData = self.guiFocusData[gui]\n    else\n            local focusElement = self.currentFocusData.initialFocusElement or self.currentFocusData.focusElement\n            if focusElement ~ = nil then\n                local oldSound = focusElement.soundDisabled\n                focusElement.soundDisabled = true\n                self:setFocus(focusElement)\n                focusElement.soundDisabled = oldSound\n            end\n        end\n\n        -- reset delay locks\n        self:resetFocusInputLocks()\n    end\n\n"})}),"\n",(0,i.jsx)(n.h3,{id:"sethighlight",children:"setHighlight"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Description"})}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsx)(n.p,{children:"Activate a highlight on an element. Highlighted elements are only visually marked and do not receive focus activation.\nOnly one element will be highlighted at any time, usually corresponding to the current mouse over target."}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Definition"})}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsx)(n.p,{children:"setHighlight(element Element)"}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n",(0,i.jsx)(n.table,{children:(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"element"}),(0,i.jsx)(n.th,{children:"Element"}),(0,i.jsx)(n.th,{children:"to be highlighted."})]})})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Code"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lua",children:"function FocusManager:setHighlight(element)\n    -- check if element has highlight already\n        if self.currentFocusData.highlightElement and self.currentFocusData.highlightElement = = element or not element.handleFocus then\n            return\n        end\n\n        -- unset highlight of currently highlighted element\n        self:unsetHighlight( self.currentFocusData.highlightElement)\n\n        if not element.disallowFocusedHighlight or not( self.currentFocusData.focusElement and self.currentFocusData.focusElement = = element) then\n            -- set highlight of new element\n            self.currentFocusData.highlightElement = element\n            element:onHighlight()\n\n            if not element:getSoundSuppressed() and element:getIsVisible() and element.playHoverSoundOnFocus ~ = false and not element.soundDisabled then\n                self.soundPlayer:playSample( GuiSoundPlayer.SOUND_SAMPLES.HOVER)\n            end\n        end\n    end\n\n"})}),"\n",(0,i.jsx)(n.h3,{id:"setsoundplayer",children:"setSoundPlayer"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Description"})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Definition"})}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsx)(n.p,{children:"setSoundPlayer()"}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,i.jsx)(n.table,{children:(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"any"}),(0,i.jsx)(n.th,{children:"guiSoundPlayer"})]})})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Code"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lua",children:"function FocusManager:setSoundPlayer(guiSoundPlayer)\n    self.soundPlayer = guiSoundPlayer\nend\n\n"})}),"\n",(0,i.jsx)(n.h3,{id:"unsetfocus",children:"unsetFocus"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Description"})}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsx)(n.p,{children:"Removes focus from an element.\nApplies overlay state and triggers onFocusLeave() on the target."}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Definition"})}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsx)(n.p,{children:"unsetFocus(element Element, ... Variable)"}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"element"}),(0,i.jsx)(n.th,{children:"Element"}),(0,i.jsx)(n.th,{children:"which should lose focus"})]})}),(0,i.jsx)(n.tbody,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"..."}),(0,i.jsx)(n.td,{children:"Variable"}),(0,i.jsx)(n.td,{children:"arguments to pass on to the onFocusLeave callback of the target element"})]})})]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Code"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lua",children:"function FocusManager:unsetFocus(element, .. .)\n    local prevFocusElement = self.currentFocusData.focusElement\n    if prevFocusElement ~ = element or prevFocusElement = = nil then\n        -- the element is not focused\n        return\n    end\n\n    if not element:getIsFocused() then\n        -- the element has already lost focus\n        return\n    end\n\n    prevFocusElement:onFocusLeave( .. .) -- call focus leave last, can override overlay state if desired\n    end\n\n"})}),"\n",(0,i.jsx)(n.h3,{id:"unsethighlight",children:"unsetHighlight"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Description"})}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsx)(n.p,{children:"Remove highlight status from an element."}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Definition"})}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsx)(n.p,{children:"unsetHighlight(element Highlighted)"}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n",(0,i.jsx)(n.table,{children:(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"element"}),(0,i.jsx)(n.th,{children:"Highlighted"}),(0,i.jsx)(n.th,{children:"element to revert"})]})})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Code"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lua",children:"function FocusManager:unsetHighlight(element)\n    if self.currentFocusData.highlightElement and self.currentFocusData.highlightElement = = element then\n        self.currentFocusData.highlightElement = nil\n        element:onHighlightRemove()\n    end\nend\n\n"})}),"\n",(0,i.jsx)(n.h3,{id:"updatefocus",children:"updateFocus"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Description"})}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsx)(n.p,{children:"Update the current focus target."}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Definition"})}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsx)(n.p,{children:"updateFocus(element GuiElement, isFocusMoving Only, direction Focus, updateOnly If)"}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"element"}),(0,i.jsx)(n.th,{children:"GuiElement"}),(0,i.jsx)(n.th,{children:"which should be the new focus target"}),(0,i.jsx)(n.th,{}),(0,i.jsx)(n.th,{}),(0,i.jsx)(n.th,{})]})}),(0,i.jsxs)(n.tbody,{children:[(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"isFocusMoving"}),(0,i.jsx)(n.td,{children:"Only"}),(0,i.jsx)(n.td,{children:"move focus if this is true"}),(0,i.jsx)(n.td,{}),(0,i.jsx)(n.td,{}),(0,i.jsx)(n.td,{})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"direction"}),(0,i.jsx)(n.td,{children:"Focus"}),(0,i.jsx)(n.td,{children:"navigation movement direction, one of FocusManager.[TOP"}),(0,i.jsx)(n.td,{children:"BOTTOM"}),(0,i.jsx)(n.td,{children:"LEFT"}),(0,i.jsx)(n.td,{children:"RIGHT]"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"updateOnly"}),(0,i.jsx)(n.td,{children:"If"}),(0,i.jsx)(n.td,{children:"true, only updates the lock state of focus movement for the given parameters"}),(0,i.jsx)(n.td,{}),(0,i.jsx)(n.td,{}),(0,i.jsx)(n.td,{})]})]})]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Code"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lua",children:"function FocusManager:updateFocus(element, direction, updateOnly)\n    if element = = nil then\n        return\n    end\n\n    if self.lastInput[direction] then\n        -- input is still blocked\n        if self.lockUntil[direction] > g_ time then\n            return\n        end\n\n        -- delay has passed but we are still holding the button.set a new delay\n        self.lockUntil[direction] = g_ time + self.SCROLL_DELAY_TIME\n    else\n            self.lockUntil[direction] = g_ time + self.INITIAL_DELAY_TIME\n        end\n\n        if updateOnly then\n            return\n        end\n\n        -- delay has passed, focus change is allowed, delay is set up\n        self.lastInput[direction] = g_ time\n\n        -- used if more than one button was pressed, only the first one is handled -- TODO:is needed?, also:button priority\n            if self.currentFocusData.focusElement ~ = element then\n                return\n            end\n\n            -- give the element the chance to override the focus change\n            if element:shouldFocusChange(direction) then\n                -- change focus\n                local nextElement, nextElementIsSet\n                if element.focusChangeOverride then\n                    if element.target then\n                        nextElementIsSet, nextElement = element.focusChangeOverride(element.target, direction)\n                    else\n                            nextElementIsSet, nextElement = element:focusChangeOverride(direction)\n                        end\n                    end\n\n                    local actualDirection = direction\n                    if not nextElementIsSet then\n                        nextElement, actualDirection = self:getNextFocusElement(element, direction)\n                    end\n\n                    if nextElement and nextElement:canReceiveFocus() then\n                        self:setFocus(nextElement, actualDirection)\n                        return\n                    else\n                            local focusElement = element\n                            nextElement = element\n                            if not element.focusChangeOverride or not element:focusChangeOverride(direction) then\n                                local maxSteps = 30\n                                while maxSteps > 0 do\n                                    if nextElement = = nil then\n                                        break\n                                    end\n\n                                    nextElement, actualDirection = self:getNextFocusElement(nextElement, direction)\n                                    if nextElement ~ = nil and nextElement:canReceiveFocus() then\n                                        focusElement = nextElement\n                                        break\n                                    end\n\n                                    maxSteps = maxSteps - 1\n                                end\n                            end\n\n                            self:setFocus(focusElement, actualDirection)\n                        end\n                    end\n                end\n\n"})})]})}function h(e={}){const{wrapper:n}={...(0,l.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(a,{...e})}):a(e)}}}]);