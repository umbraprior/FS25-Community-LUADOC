"use strict";(globalThis.webpackChunkfs25_community_luadoc=globalThis.webpackChunkfs25_community_luadoc||[]).push([[53474],{28453(e,n,i){i.d(n,{R:()=>s,x:()=>a});var t=i(96540);const l={},r=t.createContext(l);function s(e){const n=t.useContext(r);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(l):e.components||l:s(e.components),t.createElement(r.Provider,{value:n},e.children)}},63628(e,n,i){i.r(n),i.d(n,{assets:()=>o,contentTitle:()=>a,default:()=>h,frontMatter:()=>s,metadata:()=>t,toc:()=>c});const t=JSON.parse('{"id":"script/Specializations/BaleGrab","title":"BaleGrab","description":"BaleGrab","source":"@site/../docs/script/Specializations/BaleGrab.md","sourceDirName":"script/Specializations","slug":"/script/Specializations/BaleGrab","permalink":"/FS25-Community-LUADOC/script/Specializations/BaleGrab","draft":false,"unlisted":false,"tags":[],"version":"current","lastUpdatedAt":1767161192000,"frontMatter":{},"sidebar":"docsSidebar","previous":{"title":"AutoLoaderBales","permalink":"/FS25-Community-LUADOC/script/Specializations/AutoLoaderBales"},"next":{"title":"BaleLoader","permalink":"/FS25-Community-LUADOC/script/Specializations/BaleLoader"}}');var l=i(74848),r=i(28453);const s={},a=void 0,o={},c=[{value:"BaleGrab",id:"balegrab",level:2},{value:"addDynamicMountedObject",id:"adddynamicmountedobject",level:3},{value:"baleGrabTriggerCallback",id:"balegrabtriggercallback",level:3},{value:"getIsBaleGrabClosed",id:"getisbalegrabclosed",level:3},{value:"getMovingToolMoveValue",id:"getmovingtoolmovevalue",level:3},{value:"getSpecValueMaxSize",id:"getspecvaluemaxsize",level:3},{value:"getSpecValueMaxSizeRound",id:"getspecvaluemaxsizeround",level:3},{value:"getSpecValueMaxSizeSquare",id:"getspecvaluemaxsizesquare",level:3},{value:"initSpecialization",id:"initspecialization",level:3},{value:"loadSpecValueMaxSize",id:"loadspecvaluemaxsize",level:3},{value:"loadSpecValueMaxSizeRound",id:"loadspecvaluemaxsizeround",level:3},{value:"loadSpecValueMaxSizeSquare",id:"loadspecvaluemaxsizesquare",level:3},{value:"mountBaleGrabObject",id:"mountbalegrabobject",level:3},{value:"onDelete",id:"ondelete",level:3},{value:"onLoad",id:"onload",level:3},{value:"onPendingObjectDelete",id:"onpendingobjectdelete",level:3},{value:"onPendingObjectMountStateChanged",id:"onpendingobjectmountstatechanged",level:3},{value:"onPostLoad",id:"onpostload",level:3},{value:"onUpdateTick",id:"onupdatetick",level:3},{value:"prerequisitesPresent",id:"prerequisitespresent",level:3},{value:"registerEventListeners",id:"registereventlisteners",level:3},{value:"registerFunctions",id:"registerfunctions",level:3},{value:"registerOverwrittenFunctions",id:"registeroverwrittenfunctions",level:3},{value:"removeDynamicMountedObject",id:"removedynamicmountedobject",level:3},{value:"unmountBaleGrabObject",id:"unmountbalegrabobject",level:3},{value:"updateDebugValues",id:"updatedebugvalues",level:3}];function d(e){const n={a:"a",blockquote:"blockquote",code:"code",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,r.R)(),...e.components};return(0,l.jsxs)(l.Fragment,{children:[(0,l.jsx)(n.h2,{id:"balegrab",children:"BaleGrab"}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Description"})}),"\n",(0,l.jsxs)(n.blockquote,{children:["\n",(0,l.jsx)(n.p,{children:"Specialization for a balegrab tool adding soft attaching of bales"}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Functions"})}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsx)(n.li,{children:(0,l.jsx)(n.a,{href:"#adddynamicmountedobject",children:"addDynamicMountedObject"})}),"\n",(0,l.jsx)(n.li,{children:(0,l.jsx)(n.a,{href:"#balegrabtriggercallback",children:"baleGrabTriggerCallback"})}),"\n",(0,l.jsx)(n.li,{children:(0,l.jsx)(n.a,{href:"#getisbalegrabclosed",children:"getIsBaleGrabClosed"})}),"\n",(0,l.jsx)(n.li,{children:(0,l.jsx)(n.a,{href:"#getmovingtoolmovevalue",children:"getMovingToolMoveValue"})}),"\n",(0,l.jsx)(n.li,{children:(0,l.jsx)(n.a,{href:"#getspecvaluemaxsize",children:"getSpecValueMaxSize"})}),"\n",(0,l.jsx)(n.li,{children:(0,l.jsx)(n.a,{href:"#getspecvaluemaxsizeround",children:"getSpecValueMaxSizeRound"})}),"\n",(0,l.jsx)(n.li,{children:(0,l.jsx)(n.a,{href:"#getspecvaluemaxsizesquare",children:"getSpecValueMaxSizeSquare"})}),"\n",(0,l.jsx)(n.li,{children:(0,l.jsx)(n.a,{href:"#initspecialization",children:"initSpecialization"})}),"\n",(0,l.jsx)(n.li,{children:(0,l.jsx)(n.a,{href:"#loadspecvaluemaxsize",children:"loadSpecValueMaxSize"})}),"\n",(0,l.jsx)(n.li,{children:(0,l.jsx)(n.a,{href:"#loadspecvaluemaxsizeround",children:"loadSpecValueMaxSizeRound"})}),"\n",(0,l.jsx)(n.li,{children:(0,l.jsx)(n.a,{href:"#loadspecvaluemaxsizesquare",children:"loadSpecValueMaxSizeSquare"})}),"\n",(0,l.jsx)(n.li,{children:(0,l.jsx)(n.a,{href:"#mountbalegrabobject",children:"mountBaleGrabObject"})}),"\n",(0,l.jsx)(n.li,{children:(0,l.jsx)(n.a,{href:"#ondelete",children:"onDelete"})}),"\n",(0,l.jsx)(n.li,{children:(0,l.jsx)(n.a,{href:"#onload",children:"onLoad"})}),"\n",(0,l.jsx)(n.li,{children:(0,l.jsx)(n.a,{href:"#onpendingobjectdelete",children:"onPendingObjectDelete"})}),"\n",(0,l.jsx)(n.li,{children:(0,l.jsx)(n.a,{href:"#onpendingobjectmountstatechanged",children:"onPendingObjectMountStateChanged"})}),"\n",(0,l.jsx)(n.li,{children:(0,l.jsx)(n.a,{href:"#onpostload",children:"onPostLoad"})}),"\n",(0,l.jsx)(n.li,{children:(0,l.jsx)(n.a,{href:"#onupdatetick",children:"onUpdateTick"})}),"\n",(0,l.jsx)(n.li,{children:(0,l.jsx)(n.a,{href:"#prerequisitespresent",children:"prerequisitesPresent"})}),"\n",(0,l.jsx)(n.li,{children:(0,l.jsx)(n.a,{href:"#registereventlisteners",children:"registerEventListeners"})}),"\n",(0,l.jsx)(n.li,{children:(0,l.jsx)(n.a,{href:"#registerfunctions",children:"registerFunctions"})}),"\n",(0,l.jsx)(n.li,{children:(0,l.jsx)(n.a,{href:"#registeroverwrittenfunctions",children:"registerOverwrittenFunctions"})}),"\n",(0,l.jsx)(n.li,{children:(0,l.jsx)(n.a,{href:"#removedynamicmountedobject",children:"removeDynamicMountedObject"})}),"\n",(0,l.jsx)(n.li,{children:(0,l.jsx)(n.a,{href:"#unmountbalegrabobject",children:"unmountBaleGrabObject"})}),"\n",(0,l.jsx)(n.li,{children:(0,l.jsx)(n.a,{href:"#updatedebugvalues",children:"updateDebugValues"})}),"\n"]}),"\n",(0,l.jsx)(n.h3,{id:"adddynamicmountedobject",children:"addDynamicMountedObject"}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Description"})}),"\n",(0,l.jsxs)(n.blockquote,{children:["\n",(0,l.jsx)(n.p,{children:"Add dynamic mount object"}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Definition"})}),"\n",(0,l.jsxs)(n.blockquote,{children:["\n",(0,l.jsx)(n.p,{children:"addDynamicMountedObject(table object)"}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n",(0,l.jsx)(n.table,{children:(0,l.jsx)(n.thead,{children:(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.th,{children:"table"}),(0,l.jsx)(n.th,{children:"object"}),(0,l.jsx)(n.th,{children:"object"})]})})}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Code"})}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-lua",children:"function BaleGrab:addDynamicMountedObject(object)\n    local spec = self.spec_baleGrab\n    spec.dynamicMountedObjects[object] = object\nend\n\n"})}),"\n",(0,l.jsx)(n.h3,{id:"balegrabtriggercallback",children:"baleGrabTriggerCallback"}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Description"})}),"\n",(0,l.jsxs)(n.blockquote,{children:["\n",(0,l.jsx)(n.p,{children:"Trigger callback"}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Definition"})}),"\n",(0,l.jsxs)(n.blockquote,{children:["\n",(0,l.jsx)(n.p,{children:"baleGrabTriggerCallback(integer triggerId, integer otherActorId, boolean onEnter, boolean onLeave, boolean onStay,\ninteger otherShapeId)"}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,l.jsxs)(n.table,{children:[(0,l.jsx)(n.thead,{children:(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.th,{children:"integer"}),(0,l.jsx)(n.th,{children:"triggerId"}),(0,l.jsx)(n.th,{children:"id of trigger"})]})}),(0,l.jsxs)(n.tbody,{children:[(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{children:"integer"}),(0,l.jsx)(n.td,{children:"otherActorId"}),(0,l.jsx)(n.td,{children:"id of other actor"})]}),(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{children:"boolean"}),(0,l.jsx)(n.td,{children:"onEnter"}),(0,l.jsx)(n.td,{children:"on enter"})]}),(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{children:"boolean"}),(0,l.jsx)(n.td,{children:"onLeave"}),(0,l.jsx)(n.td,{children:"on leave"})]}),(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{children:"boolean"}),(0,l.jsx)(n.td,{children:"onStay"}),(0,l.jsx)(n.td,{children:"on stay"})]}),(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{children:"integer"}),(0,l.jsx)(n.td,{children:"otherShapeId"}),(0,l.jsx)(n.td,{children:"id of other shape"})]})]})]}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Code"})}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-lua",children:"function BaleGrab:baleGrabTriggerCallback(triggerId, otherActorId, onEnter, onLeave, onStay, otherShapeId)\n    local spec = self.spec_baleGrab\n    if onEnter then\n        local object = g_currentMission:getNodeObject(otherActorId)\n        if object ~ = nil and object ~ = self and object.getSupportsMountDynamic ~ = nil and object:getSupportsMountDynamic() and object.addMountStateChangeListener ~ = nil and(object.nodeId ~ = nil or object.rootNode ~ = 0 ) then\n            spec.pendingDynamicMountObjects[object] = (spec.pendingDynamicMountObjects[object] or 0 ) + 1\n            if spec.pendingDynamicMountObjects[object] = = 1 then\n                object:addDeleteListener( self , BaleGrab.onPendingObjectDelete)\n                object:addMountStateChangeListener( self , BaleGrab.onPendingObjectMountStateChanged)\n            end\n        end\n    elseif onLeave then\n            local object = g_currentMission:getNodeObject(otherActorId)\n            if object ~ = nil then\n                if spec.pendingDynamicMountObjects[object] ~ = nil then\n                    spec.pendingDynamicMountObjects[object] = spec.pendingDynamicMountObjects[object] - 1\n                    if spec.pendingDynamicMountObjects[object] < = 0 then\n                        self:removeDynamicMountedObject(object, true )\n                        object:removeDeleteListener( self , BaleGrab.onPendingObjectDelete)\n                        object:removeMountStateChangeListener( self , BaleGrab.onPendingObjectMountStateChanged)\n                    end\n                end\n            end\n        end\n    end\n\n"})}),"\n",(0,l.jsx)(n.h3,{id:"getisbalegrabclosed",children:"getIsBaleGrabClosed"}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Description"})}),"\n",(0,l.jsxs)(n.blockquote,{children:["\n",(0,l.jsx)(n.p,{children:"Returns if the bale grab is closed or not"}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Definition"})}),"\n",(0,l.jsxs)(n.blockquote,{children:["\n",(0,l.jsx)(n.p,{children:"getIsBaleGrabClosed()"}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,l.jsx)(n.table,{children:(0,l.jsx)(n.thead,{children:(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.th,{children:"any"}),(0,l.jsx)(n.th,{children:"grab"})]})})}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Code"})}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-lua",children:"function BaleGrab:getIsBaleGrabClosed(grab)\n    -- while the moving tools are fully opened the grab can never be closed, even if the joint is over the limit\n        for toolIndex = 1 , #grab.movingTools do\n            local movingToolData = grab.movingTools[toolIndex]\n\n            local state = Cylindered.getMovingToolState( self , movingToolData.movingTool)\n            if movingToolData.closingDirection > 0 then\n                if state < 0.01 then\n                    return false\n                end\n            else\n                    if state > 0.99 then\n                        return false\n                    end\n                end\n            end\n\n            if grab.rotationAxis ~ = nil then\n                grab.lastValues[ 1 ], grab.lastValues[ 2 ], grab.lastValues[ 3 ] = localRotationToLocal(grab.componentJointActor1, grab.componentJointActor0, 0 , 0 , 0 )\n                if grab.rotationThreshold > 0 then\n                    if grab.lastValues[grab.rotationAxis] > grab.rotationThreshold then\n                        return true\n                    end\n                else\n                        if grab.lastValues[grab.rotationAxis] < grab.rotationThreshold then\n                            return true\n                        end\n                    end\n                elseif grab.translationAxis ~ = nil then\n                        grab.lastValues[ 1 ], grab.lastValues[ 2 ], grab.lastValues[ 3 ] = localToLocal(grab.componentJointActor1, grab.componentJointActor0, 0 , 0 , 0 )\n\n                        if grab.translationThreshold > 0 then\n                            if grab.lastValues[grab.translationAxis] > grab.translationThreshold then\n                                return true\n                            end\n                        else\n                                if grab.lastValues[grab.translationAxis] < grab.translationThreshold then\n                                    return true\n                                end\n                            end\n                        end\n\n                        return false\n                    end\n\n"})}),"\n",(0,l.jsx)(n.h3,{id:"getmovingtoolmovevalue",children:"getMovingToolMoveValue"}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Description"})}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Definition"})}),"\n",(0,l.jsxs)(n.blockquote,{children:["\n",(0,l.jsx)(n.p,{children:"getMovingToolMoveValue()"}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,l.jsxs)(n.table,{children:[(0,l.jsx)(n.thead,{children:(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.th,{children:"any"}),(0,l.jsx)(n.th,{children:"superFunc"})]})}),(0,l.jsx)(n.tbody,{children:(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{children:"any"}),(0,l.jsx)(n.td,{children:"movingTool"})]})})]}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Code"})}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-lua",children:"function BaleGrab:getMovingToolMoveValue(superFunc, movingTool)\n    local move = superFunc( self , movingTool)\n\n    local spec = self.spec_baleGrab\n    for i = 1 , #spec.grabs do\n        local grab = spec.grabs[i]\n        for toolIndex = 1 , #grab.movingTools do\n            local movingToolData = grab.movingTools[toolIndex]\n            if movingToolData.movingTool = = movingTool then\n                movingToolData.lastMoveValue = move\n                if grab.closeTimer < BaleGrab.CLOSE_TIMER and next(spec.pendingDynamicMountObjects) ~ = nil then\n                    if math.sign(move) = = movingToolData.closingDirection then\n                        move = 0\n                    end\n                end\n            end\n        end\n    end\n\n    return move\nend\n\n"})}),"\n",(0,l.jsx)(n.h3,{id:"getspecvaluemaxsize",children:"getSpecValueMaxSize"}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Description"})}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Definition"})}),"\n",(0,l.jsxs)(n.blockquote,{children:["\n",(0,l.jsx)(n.p,{children:"getSpecValueMaxSize()"}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,l.jsxs)(n.table,{children:[(0,l.jsx)(n.thead,{children:(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.th,{children:"any"}),(0,l.jsx)(n.th,{children:"specName"})]})}),(0,l.jsxs)(n.tbody,{children:[(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{children:"any"}),(0,l.jsx)(n.td,{children:"storeItem"})]}),(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{children:"any"}),(0,l.jsx)(n.td,{children:"realItem"})]}),(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{children:"any"}),(0,l.jsx)(n.td,{children:"configurations"})]}),(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{children:"any"}),(0,l.jsx)(n.td,{children:"saleItem"})]}),(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{children:"any"}),(0,l.jsx)(n.td,{children:"returnValues"})]}),(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{children:"any"}),(0,l.jsx)(n.td,{children:"returnRange"})]})]})]}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Code"})}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-lua",children:'function BaleGrab.getSpecValueMaxSize(specName, storeItem, realItem, configurations, saleItem, returnValues, returnRange)\n    local spec = storeItem.specs[specName]\n    if spec ~ = nil then\n        local minValue = spec.minSize or spec.maxSize\n        local maxValue = spec.maxSize or spec.minSize\n\n        if returnValues = = nil or not returnValues then\n            local unit = g_i18n:getText( "unit_cmShort" )\n            local size\n            if maxValue ~ = minValue and minValue ~ = 0 and maxValue ~ = 0 then\n                size = string.format( "%d%s-%d%s" , minValue * 100 , unit, maxValue * 100 , unit)\n            else\n                    size = string.format( "%d%s" , math.max(minValue, maxValue) * 100 , unit)\n                end\n\n                return size\n            else\n                    if returnRange = = true and maxValue ~ = minValue and minValue ~ = 0 and maxValue ~ = 0 then\n                        return minValue * 100 , maxValue * 100 , g_i18n:getText( "unit_cmShort" )\n                    else\n                            return math.max(minValue, maxValue) * 100 , g_i18n:getText( "unit_cmShort" )\n                        end\n                    end\n                end\n            end\n\n'})}),"\n",(0,l.jsx)(n.h3,{id:"getspecvaluemaxsizeround",children:"getSpecValueMaxSizeRound"}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Description"})}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Definition"})}),"\n",(0,l.jsxs)(n.blockquote,{children:["\n",(0,l.jsx)(n.p,{children:"getSpecValueMaxSizeRound()"}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,l.jsxs)(n.table,{children:[(0,l.jsx)(n.thead,{children:(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.th,{children:"any"}),(0,l.jsx)(n.th,{children:"storeItem"})]})}),(0,l.jsxs)(n.tbody,{children:[(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{children:"any"}),(0,l.jsx)(n.td,{children:"realItem"})]}),(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{children:"any"}),(0,l.jsx)(n.td,{children:"configurations"})]}),(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{children:"any"}),(0,l.jsx)(n.td,{children:"saleItem"})]}),(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{children:"any"}),(0,l.jsx)(n.td,{children:"returnValues"})]}),(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{children:"any"}),(0,l.jsx)(n.td,{children:"returnRange"})]})]})]}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Code"})}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-lua",children:'function BaleGrab.getSpecValueMaxSizeRound(storeItem, realItem, configurations, saleItem, returnValues, returnRange)\n    return BaleGrab.getSpecValueMaxSize( "baleGrabMaxSizeRound" , storeItem, realItem, configurations, saleItem, returnValues, returnRange)\nend\n\n'})}),"\n",(0,l.jsx)(n.h3,{id:"getspecvaluemaxsizesquare",children:"getSpecValueMaxSizeSquare"}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Description"})}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Definition"})}),"\n",(0,l.jsxs)(n.blockquote,{children:["\n",(0,l.jsx)(n.p,{children:"getSpecValueMaxSizeSquare()"}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,l.jsxs)(n.table,{children:[(0,l.jsx)(n.thead,{children:(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.th,{children:"any"}),(0,l.jsx)(n.th,{children:"storeItem"})]})}),(0,l.jsxs)(n.tbody,{children:[(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{children:"any"}),(0,l.jsx)(n.td,{children:"realItem"})]}),(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{children:"any"}),(0,l.jsx)(n.td,{children:"configurations"})]}),(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{children:"any"}),(0,l.jsx)(n.td,{children:"saleItem"})]}),(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{children:"any"}),(0,l.jsx)(n.td,{children:"returnValues"})]}),(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{children:"any"}),(0,l.jsx)(n.td,{children:"returnRange"})]})]})]}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Code"})}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-lua",children:'function BaleGrab.getSpecValueMaxSizeSquare(storeItem, realItem, configurations, saleItem, returnValues, returnRange)\n    return BaleGrab.getSpecValueMaxSize( "baleGrabMaxSizeSquare" , storeItem, realItem, configurations, saleItem, returnValues, returnRange)\nend\n\n'})}),"\n",(0,l.jsx)(n.h3,{id:"initspecialization",children:"initSpecialization"}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Description"})}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Definition"})}),"\n",(0,l.jsxs)(n.blockquote,{children:["\n",(0,l.jsx)(n.p,{children:"initSpecialization()"}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Code"})}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-lua",children:'function BaleGrab.initSpecialization()\n    local schema = Vehicle.xmlSchema\n    schema:setXMLSpecializationType( "BaleGrab" )\n\n    schema:register(XMLValueType.FLOAT, "vehicle.baleGrab#minSizeRound" , "Min.size of round bales(for shop display only)" )\n        schema:register(XMLValueType.FLOAT, "vehicle.baleGrab#maxSizeRound" , "Max.size of round bales(for shop display only)" )\n\n            schema:register(XMLValueType.FLOAT, "vehicle.baleGrab#minSizeSquare" , "Min.size of square bales(for shop display only)" )\n                schema:register(XMLValueType.FLOAT, "vehicle.baleGrab#maxSizeSquare" , "Max.size of square bales(for shop display only)" )\n\n                    schema:register(XMLValueType.NODE_INDEX, "vehicle.baleGrab#triggerNode" , "Trigger node" )\n                    schema:register(XMLValueType.NODE_INDEX, "vehicle.baleGrab#rootNode" , "Root node" , "Main component" )\n                    schema:register(XMLValueType.STRING, "vehicle.baleGrab#dynamicMountType" , "Dynamic mount type" , "TYPE_FIX_ATTACH" )\n                    schema:register(XMLValueType.FLOAT, "vehicle.baleGrab#forceAcceleration" , "Force acceleration" , 20 )\n\n                    schema:register(XMLValueType.INT, "vehicle.baleGrab.grab(?)#componentJointIndex" , "Component joint index of grab" )\n                    schema:register(XMLValueType.FLOAT, "vehicle.baleGrab.grab(?)#dampingFactor" , "Factor that is applied to the component joint rot/trans damping as soon as a bale is mounted" , 20 )\n\n                    schema:register(XMLValueType.INT, "vehicle.baleGrab.grab(?)#rotationAxis" , "Rotation axis of component joint to detect if the grab is rotating out of the limits(only rotation or translation axis can be used)" )\n                        schema:register(XMLValueType.ANGLE, "vehicle.baleGrab.grab(?)#rotationThreshold" , "Threshold to mount the bale if the component is this angle off the component joint rotation" , 5 )\n\n                            schema:register(XMLValueType.INT, "vehicle.baleGrab.grab(?)#translationAxis" , "Translation axis of component joint to detect if the grab is translating out of the limits(only rotation or translation axis can be used)" )\n                                schema:register(XMLValueType.FLOAT, "vehicle.baleGrab.grab(?)#translationThreshold" , "Threshold to mount the bale if the component is this translation off the component joint translation" , 0.05 )\n\n                                    schema:register(XMLValueType.NODE_INDEX, "vehicle.baleGrab.grab(?).movingTool(?)#node" , "Node of moving tool to block while limit is exceeded" )\n                                        schema:register(XMLValueType.INT, "vehicle.baleGrab.grab(?).movingTool(?)#closingDirection" , "Direction to block the moving tool" , 1 )\n\n                                        schema:setXMLSpecializationType()\n\n                                        g_storeManager:addSpecType( "baleGrabMaxSizeRound" , "shopListAttributeIconBaleSizeRound" , BaleGrab.loadSpecValueMaxSizeRound, BaleGrab.getSpecValueMaxSizeRound, StoreSpecies.VEHICLE)\n                                        g_storeManager:addSpecType( "baleGrabMaxSizeSquare" , "shopListAttributeIconBaleSizeSquare" , BaleGrab.loadSpecValueMaxSizeSquare, BaleGrab.getSpecValueMaxSizeSquare, StoreSpecies.VEHICLE)\n                                    end\n\n'})}),"\n",(0,l.jsx)(n.h3,{id:"loadspecvaluemaxsize",children:"loadSpecValueMaxSize"}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Description"})}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Definition"})}),"\n",(0,l.jsxs)(n.blockquote,{children:["\n",(0,l.jsx)(n.p,{children:"loadSpecValueMaxSize()"}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,l.jsxs)(n.table,{children:[(0,l.jsx)(n.thead,{children:(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.th,{children:"any"}),(0,l.jsx)(n.th,{children:"xmlFile"})]})}),(0,l.jsxs)(n.tbody,{children:[(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{children:"any"}),(0,l.jsx)(n.td,{children:"minKey"})]}),(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{children:"any"}),(0,l.jsx)(n.td,{children:"maxKey"})]})]})]}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Code"})}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-lua",children:"function BaleGrab.loadSpecValueMaxSize(xmlFile, minKey, maxKey)\n    local sizeData = { }\n\n    sizeData.minSize = MathUtil.round(xmlFile:getValue(minKey) or 0 , 2 )\n    sizeData.maxSize = MathUtil.round(xmlFile:getValue(maxKey) or 0 , 2 )\n\n    if sizeData.minSize ~ = 0 or sizeData.maxSize ~ = 0 then\n        return sizeData\n    end\nend\n\n"})}),"\n",(0,l.jsx)(n.h3,{id:"loadspecvaluemaxsizeround",children:"loadSpecValueMaxSizeRound"}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Description"})}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Definition"})}),"\n",(0,l.jsxs)(n.blockquote,{children:["\n",(0,l.jsx)(n.p,{children:"loadSpecValueMaxSizeRound()"}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,l.jsxs)(n.table,{children:[(0,l.jsx)(n.thead,{children:(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.th,{children:"any"}),(0,l.jsx)(n.th,{children:"xmlFile"})]})}),(0,l.jsxs)(n.tbody,{children:[(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{children:"any"}),(0,l.jsx)(n.td,{children:"customEnvironment"})]}),(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{children:"any"}),(0,l.jsx)(n.td,{children:"baseDir"})]})]})]}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Code"})}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-lua",children:'function BaleGrab.loadSpecValueMaxSizeRound(xmlFile, customEnvironment, baseDir)\n    return BaleGrab.loadSpecValueMaxSize(xmlFile, "vehicle.baleGrab#minSizeRound" , "vehicle.baleGrab#maxSizeRound" )\nend\n\n'})}),"\n",(0,l.jsx)(n.h3,{id:"loadspecvaluemaxsizesquare",children:"loadSpecValueMaxSizeSquare"}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Description"})}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Definition"})}),"\n",(0,l.jsxs)(n.blockquote,{children:["\n",(0,l.jsx)(n.p,{children:"loadSpecValueMaxSizeSquare()"}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,l.jsxs)(n.table,{children:[(0,l.jsx)(n.thead,{children:(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.th,{children:"any"}),(0,l.jsx)(n.th,{children:"xmlFile"})]})}),(0,l.jsxs)(n.tbody,{children:[(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{children:"any"}),(0,l.jsx)(n.td,{children:"customEnvironment"})]}),(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{children:"any"}),(0,l.jsx)(n.td,{children:"baseDir"})]})]})]}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Code"})}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-lua",children:'function BaleGrab.loadSpecValueMaxSizeSquare(xmlFile, customEnvironment, baseDir)\n    return BaleGrab.loadSpecValueMaxSize(xmlFile, "vehicle.baleGrab#minSizeSquare" , "vehicle.baleGrab#maxSizeSquare" )\nend\n\n'})}),"\n",(0,l.jsx)(n.h3,{id:"mountbalegrabobject",children:"mountBaleGrabObject"}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Description"})}),"\n",(0,l.jsxs)(n.blockquote,{children:["\n",(0,l.jsx)(n.p,{children:"Mounts a dynamic object to the bale grab"}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Definition"})}),"\n",(0,l.jsxs)(n.blockquote,{children:["\n",(0,l.jsx)(n.p,{children:"mountBaleGrabObject(table object)"}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n",(0,l.jsx)(n.table,{children:(0,l.jsx)(n.thead,{children:(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.th,{children:"table"}),(0,l.jsx)(n.th,{children:"object"}),(0,l.jsx)(n.th,{children:"object"})]})})}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Return Values"})}),"\n\n\n\n\n\n\n\n\n",(0,l.jsx)(n.table,{children:(0,l.jsx)(n.thead,{children:(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.th,{children:"table"}),(0,l.jsx)(n.th,{children:"success"}),(0,l.jsx)(n.th,{children:"success"})]})})}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Code"})}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-lua",children:"function BaleGrab:mountBaleGrabObject(object)\n    local spec = self.spec_baleGrab\n\n    local rootNode = object.nodeId or object.rootNode\n\n    local x, y, z = localToWorld(rootNode, getCenterOfMass(rootNode))\n    setWorldTranslation(spec.jointNode, x, y, z)\n\n    if object:mountDynamic( self , spec.rootNode, spec.jointNode, spec.dynamicMountType, spec.forceAcceleration) then\n        for i = 1 , 3 do\n            setJointRotationLimitSpring(object.dynamicMountJointIndex, i - 1 , 10000 , 10 )\n            setJointTranslationLimitSpring(object.dynamicMountJointIndex, i - 1 , 10000 , 10 )\n        end\n\n        self:addDynamicMountedObject(object)\n        return true\n    end\n\n    return false\nend\n\n"})}),"\n",(0,l.jsx)(n.h3,{id:"ondelete",children:"onDelete"}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Description"})}),"\n",(0,l.jsxs)(n.blockquote,{children:["\n",(0,l.jsx)(n.p,{children:"Called on deleting"}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Definition"})}),"\n",(0,l.jsxs)(n.blockquote,{children:["\n",(0,l.jsx)(n.p,{children:"onDelete()"}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Code"})}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-lua",children:"function BaleGrab:onDelete()\n    local spec = self.spec_baleGrab\n\n    if spec.pendingDynamicMountObjects ~ = nil then\n        for object, _ in pairs(spec.pendingDynamicMountObjects) do\n            if object.removeDeleteListener ~ = nil then\n                object:removeDeleteListener( self , BaleGrab.onPendingObjectDelete)\n            end\n            if object.removeMountStateChangeListener ~ = nil then\n                object:removeMountStateChangeListener( self , BaleGrab.onPendingObjectMountStateChanged)\n            end\n        end\n        table.clear(spec.pendingDynamicMountObjects)\n    end\n\n    if spec.dynamicMountedObjects ~ = nil then\n        for object,_ in pairs(spec.dynamicMountedObjects) do\n            self:unmountBaleGrabObject(object)\n        end\n        table.clear(spec.dynamicMountedObjects)\n    end\n\n    if spec.triggerNode ~ = nil then\n        removeTrigger(spec.triggerNode)\n        spec.triggerNode = nil\n    end\nend\n\n"})}),"\n",(0,l.jsx)(n.h3,{id:"onload",children:"onLoad"}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Description"})}),"\n",(0,l.jsxs)(n.blockquote,{children:["\n",(0,l.jsx)(n.p,{children:"Called on loading"}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Definition"})}),"\n",(0,l.jsxs)(n.blockquote,{children:["\n",(0,l.jsx)(n.p,{children:"onLoad(table savegame)"}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n",(0,l.jsx)(n.table,{children:(0,l.jsx)(n.thead,{children:(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.th,{children:"table"}),(0,l.jsx)(n.th,{children:"savegame"}),(0,l.jsx)(n.th,{children:"savegame"})]})})}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Code"})}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-lua",children:'function BaleGrab:onLoad(savegame)\n    local spec = self.spec_baleGrab\n\n    XMLUtil.checkDeprecatedXMLElements( self.xmlFile, "vehicle.baleGrab#jointType" , "vehicle.baleGrab#dynamicMountType" )\n    XMLUtil.checkDeprecatedXMLElements( self.xmlFile, "vehicle.baleGrab#grabRefComponentJointIndex1" , "vehicle.baleGrab.grab#componentJointIndex" )\n    XMLUtil.checkDeprecatedXMLElements( self.xmlFile, "vehicle.baleGrab#grabRefComponentJointIndex2" , "vehicle.baleGrab.grab#componentJointIndex" )\n    XMLUtil.checkDeprecatedXMLElements( self.xmlFile, "vehicle.baleGrab#rotDiffThreshold1" , "vehicle.baleGrab.grab#rotationThreshold" )\n    XMLUtil.checkDeprecatedXMLElements( self.xmlFile, "vehicle.baleGrab#rotDiffThreshold2" , "vehicle.baleGrab.grab#rotationThreshold" )\n\n    if self.isServer then\n        spec.rootNode = self.xmlFile:getValue( "vehicle.baleGrab#rootNode" , self.rootNode, self.components, self.i3dMappings)\n\n        spec.triggerNode = self.xmlFile:getValue( "vehicle.baleGrab#triggerNode" , nil , self.components, self.i3dMappings)\n        if spec.triggerNode ~ = nil then\n            if CollisionFlag.getHasMaskFlagSet(spec.triggerNode, CollisionFlag.DYNAMIC_OBJECT) then\n                addTrigger(spec.triggerNode, "baleGrabTriggerCallback" , self )\n            else\n                    Logging.xmlWarning( self.xmlFile, "BaleGrab trigger has no \'TRIGGER_DYNAMIC_OBJECT\' collision bit set!" )\n                end\n\n                spec.jointNode = createTransformGroup( "balegrabJointNode" )\n                link(spec.rootNode, spec.jointNode)\n\n                spec.forceAcceleration = self.xmlFile:getValue( "vehicle.baleGrab#forceAcceleration" , 20 )\n\n                local dynamicMountTypeString = self.xmlFile:getValue( "vehicle.baleGrab#dynamicMountType" , "TYPE_FIX_ATTACH" )\n                spec.dynamicMountType = DynamicMountUtil[dynamicMountTypeString] or DynamicMountUtil.TYPE_FIX_ATTACH\n\n                spec.grabs = { }\n\n                self.xmlFile:iterate( "vehicle.baleGrab.grab" , function (_, key)\n                    local grab = { }\n                    grab.componentJointIndex = self.xmlFile:getValue(key .. "#componentJointIndex" )\n                    if grab.componentJointIndex ~ = nil then\n                        grab.dampingFactor = self.xmlFile:getValue(key .. "#dampingFactor" , 20 )\n\n                        grab.rotationAxis = self.xmlFile:getValue(key .. "#rotationAxis" )\n                        if grab.rotationAxis ~ = nil then\n                            grab.rotationThreshold = self.xmlFile:getValue(key .. "#rotationThreshold" , 5 )\n                        else\n                                grab.translationAxis = self.xmlFile:getValue(key .. "#translationAxis" )\n                                if grab.translationAxis ~ = nil then\n                                    grab.translationThreshold = self.xmlFile:getValue(key .. "#translationThreshold" , 0.05 )\n                                else\n                                        Logging.xmlWarning( self.xmlFile, "Missing rotation or translation axis in \'%s" , key)\n                                    end\n                                end\n\n                                if grab.rotationAxis ~ = nil or grab.translationAxis then\n                                    grab.componentJoint = self.componentJoints[grab.componentJointIndex]\n                                    if grab.componentJoint ~ = nil then\n                                        grab.componentJointActor0 = grab.componentJoint.jointNode\n                                        grab.componentJointActor1 = grab.componentJoint.jointNodeActor1\n                                        if grab.componentJointActor0 = = grab.componentJointActor1 then\n                                            grab.componentJointActor1 = createTransformGroup( "componentJointActor1" )\n\n                                            if self:getParentComponent(grab.componentJointActor0) = = self.components[grab.componentJoint.componentIndices[ 1 ]].node then\n                                                link( self.components[grab.componentJoint.componentIndices[ 2 ]].node, grab.componentJointActor1)\n                                            else\n                                                    link( self.components[grab.componentJoint.componentIndices[ 1 ]].node, grab.componentJointActor1)\n                                                end\n                                                setWorldTranslation(grab.componentJointActor1, getWorldTranslation(grab.componentJointActor0))\n                                                setWorldRotation(grab.componentJointActor1, getWorldRotation(grab.componentJointActor0))\n                                            end\n\n                                            grab.movingTools = { }\n                                            self.xmlFile:iterate(key .. ".movingTool" , function (_, movingToolKey)\n                                                local movingToolData = { }\n                                                movingToolData.node = self.xmlFile:getValue(movingToolKey .. "#node" , nil , self.components, self.i3dMappings)\n                                                if movingToolData.node ~ = nil then\n                                                    movingToolData.closingDirection = self.xmlFile:getValue(movingToolKey .. "#closingDirection" )\n                                                    table.insert(grab.movingTools, movingToolData)\n                                                end\n                                            end )\n\n                                            grab.lastValues = { 0 , 0 , 0 }\n                                            grab.isClosed = false\n                                            grab.closeTimer = 0\n                                            grab.jointChecksum = 0\n\n                                            table.insert(spec.grabs, grab)\n                                        else\n                                                Logging.xmlWarning( self.xmlFile, "Invalid component joint index %s in \'%s" , grab.componentJointIndex, key)\n                                            end\n                                        end\n                                    else\n                                            Logging.xmlWarning( self.xmlFile, "Missing component joint in \'%s" , key)\n                                        end\n                                    end )\n                                end\n\n                                spec.lastAllGrabsClosed = false\n                                spec.dynamicMountedObjects = { }\n                                spec.pendingDynamicMountObjects = { }\n                            end\n\n                            if spec.triggerNode = = nil then\n                                SpecializationUtil.removeEventListener( self , "onPostLoad" , BaleGrab )\n                                SpecializationUtil.removeEventListener( self , "onDelete" , BaleGrab )\n                                SpecializationUtil.removeEventListener( self , "onUpdateTick" , BaleGrab )\n                            end\n                        end\n\n'})}),"\n",(0,l.jsx)(n.h3,{id:"onpendingobjectdelete",children:"onPendingObjectDelete"}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Description"})}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Definition"})}),"\n",(0,l.jsxs)(n.blockquote,{children:["\n",(0,l.jsx)(n.p,{children:"onPendingObjectDelete()"}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,l.jsxs)(n.table,{children:[(0,l.jsx)(n.thead,{children:(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.th,{children:"any"}),(0,l.jsx)(n.th,{children:"self"})]})}),(0,l.jsx)(n.tbody,{children:(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{children:"any"}),(0,l.jsx)(n.td,{children:"object"})]})})]}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Code"})}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-lua",children:"function BaleGrab.onPendingObjectDelete( self , object)\n    local spec = self.spec_baleGrab\n    if spec.pendingDynamicMountObjects[object] ~ = nil or spec.dynamicMountedObjects[object] ~ = nil then\n        self:removeDynamicMountedObject(object, true )\n    end\nend\n\n"})}),"\n",(0,l.jsx)(n.h3,{id:"onpendingobjectmountstatechanged",children:"onPendingObjectMountStateChanged"}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Description"})}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Definition"})}),"\n",(0,l.jsxs)(n.blockquote,{children:["\n",(0,l.jsx)(n.p,{children:"onPendingObjectMountStateChanged()"}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,l.jsxs)(n.table,{children:[(0,l.jsx)(n.thead,{children:(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.th,{children:"any"}),(0,l.jsx)(n.th,{children:"self"})]})}),(0,l.jsxs)(n.tbody,{children:[(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{children:"any"}),(0,l.jsx)(n.td,{children:"object"})]}),(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{children:"any"}),(0,l.jsx)(n.td,{children:"mountState"})]}),(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{children:"any"}),(0,l.jsx)(n.td,{children:"mountObject"})]})]})]}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Code"})}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-lua",children:"function BaleGrab.onPendingObjectMountStateChanged( self , object, mountState, mountObject)\n    if mountState ~ = MountableObject.MOUNT_TYPE_NONE and mountObject ~ = self then\n        local spec = self.spec_baleGrab\n        if spec.pendingDynamicMountObjects[object] ~ = nil or spec.dynamicMountedObjects[object] ~ = nil then\n            self:removeDynamicMountedObject(object, true )\n        end\n    end\nend\n\n"})}),"\n",(0,l.jsx)(n.h3,{id:"onpostload",children:"onPostLoad"}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Description"})}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Definition"})}),"\n",(0,l.jsxs)(n.blockquote,{children:["\n",(0,l.jsx)(n.p,{children:"onPostLoad()"}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,l.jsx)(n.table,{children:(0,l.jsx)(n.thead,{children:(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.th,{children:"any"}),(0,l.jsx)(n.th,{children:"savegame"})]})})}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Code"})}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-lua",children:"function BaleGrab:onPostLoad(savegame)\n    local spec = self.spec_baleGrab\n    for i = 1 , #spec.grabs do\n        local grab = spec.grabs[i]\n        for toolIndex = #grab.movingTools, 1 , - 1 do\n            local movingToolData = grab.movingTools[toolIndex]\n            movingToolData.movingTool = self:getMovingToolByNode(movingToolData.node)\n            if movingToolData.movingTool = = nil then\n                table.remove(grab.movingTools, toolIndex)\n            end\n        end\n    end\nend\n\n"})}),"\n",(0,l.jsx)(n.h3,{id:"onupdatetick",children:"onUpdateTick"}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Description"})}),"\n",(0,l.jsxs)(n.blockquote,{children:["\n",(0,l.jsx)(n.p,{children:"Called on update tick"}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Definition"})}),"\n",(0,l.jsxs)(n.blockquote,{children:["\n",(0,l.jsx)(n.p,{children:"onUpdateTick(float dt, boolean isActiveForInput, boolean isSelected, )"}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,l.jsxs)(n.table,{children:[(0,l.jsx)(n.thead,{children:(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.th,{children:"float"}),(0,l.jsx)(n.th,{children:"dt"}),(0,l.jsx)(n.th,{children:"time since last call in ms"})]})}),(0,l.jsxs)(n.tbody,{children:[(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{children:"boolean"}),(0,l.jsx)(n.td,{children:"isActiveForInput"}),(0,l.jsx)(n.td,{children:"true if vehicle is active for input"})]}),(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{children:"boolean"}),(0,l.jsx)(n.td,{children:"isSelected"}),(0,l.jsx)(n.td,{children:"true if vehicle is selected"})]}),(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{children:"any"}),(0,l.jsx)(n.td,{children:"isSelected"}),(0,l.jsx)(n.td,{})]})]})]}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Code"})}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-lua",children:"function BaleGrab:onUpdateTick(dt, isActiveForInput, isActiveForInputIgnoreSelection, isSelected)\n    if self.isServer then\n        local spec = self.spec_baleGrab\n\n        local allGrabsClosed = next(spec.pendingDynamicMountObjects) ~ = nil\n        for i = 1 , #spec.grabs do\n            local grab = spec.grabs[i]\n\n            local isClosed = self:getIsBaleGrabClosed(grab)\n            if isClosed then\n                grab.closeTimer = math.max(grab.closeTimer - dt, 0 )\n            else\n                    grab.closeTimer = BaleGrab.CLOSE_TIMER\n                end\n\n                -- update checksum while grab is open and after the close timer is down to 0\n                    -- like this we check if the grab joint has been changed while the grab is closing(while the timer is running)\n                        -- if the joint was not moved or rotated by the player we don't allow any update of the grab state\n                            -- otherwise small impacts on the component could cause a unmounting of the bale, especially with a high joint damping\n                            if (grab.closeTimer = = 0 ) ~ = grab.isClosed then\n                                local x, y, z = getTranslation(grab.componentJointActor0)\n                                local rx, ry, rz = getRotation(grab.componentJointActor0)\n                                local jointChecksum = x + y + z + rx + ry + rz\n                                if grab.jointChecksum ~ = jointChecksum then\n                                    grab.jointChecksum = jointChecksum\n                                    grab.isClosed = grab.closeTimer = = 0\n                                elseif next(spec.pendingDynamicMountObjects) ~ = nil and grab.closeTimer = = 0 then\n                                        grab.isClosed = grab.closeTimer = = 0\n                                    elseif next(spec.pendingDynamicMountObjects) = = nil and grab.closeTimer = = BaleGrab.CLOSE_TIMER then\n                                            -- update the grab state if nothing is in the trigger and the new state would be open\n                                                -- otherwise it can happen that a bale that enters the trigger newly will be mounted directly\n                                                grab.isClosed = grab.closeTimer = = 0\n                                            end\n                                        elseif grab.closeTimer = = BaleGrab.CLOSE_TIMER then\n                                                local x, y, z = getTranslation(grab.componentJointActor0)\n                                                local rx, ry, rz = getRotation(grab.componentJointActor0)\n                                                grab.jointChecksum = x + y + z + rx + ry + rz\n                                            end\n\n                                            if not grab.isClosed then\n                                                allGrabsClosed = false\n                                            end\n                                        end\n\n                                        if allGrabsClosed ~ = spec.lastAllGrabsClosed then\n                                            spec.lastAllGrabsClosed = allGrabsClosed\n\n                                            if allGrabsClosed then\n                                                for object, _ in pairs(spec.pendingDynamicMountObjects) do\n                                                    if spec.dynamicMountedObjects[object] = = nil and object.dynamicMountType = = MountableObject.MOUNT_TYPE_NONE then\n                                                        self:unmountBaleGrabObject(object)\n                                                        self:mountBaleGrabObject(object)\n                                                    end\n                                                end\n\n                                                for i = 1 , #spec.grabs do\n                                                    local grab = spec.grabs[i]\n                                                    for axis = 1 , 3 do\n                                                        if grab.rotationAxis ~ = nil then\n                                                            setJointRotationLimitSpring(grab.componentJoint.jointIndex, axis - 1 , grab.componentJoint.rotLimitSpring[axis], grab.componentJoint.rotLimitDamping[axis] * grab.dampingFactor)\n                                                        else\n                                                                setJointTranslationLimitSpring(grab.componentJoint.jointIndex, axis - 1 , grab.componentJoint.transLimitSpring[axis], grab.componentJoint.transLimitDamping[axis] * grab.dampingFactor)\n                                                            end\n                                                        end\n                                                    end\n                                                else\n                                                        for object,_ in pairs(spec.dynamicMountedObjects) do\n                                                            self:unmountBaleGrabObject(object)\n                                                        end\n\n                                                        for i = 1 , #spec.grabs do\n                                                            local grab = spec.grabs[i]\n                                                            for axis = 1 , 3 do\n                                                                if grab.rotationAxis ~ = nil then\n                                                                    setJointRotationLimitSpring(grab.componentJoint.jointIndex, axis - 1 , grab.componentJoint.rotLimitSpring[axis], grab.componentJoint.rotLimitDamping[axis])\n                                                                else\n                                                                        setJointTranslationLimitSpring(grab.componentJoint.jointIndex, axis - 1 , grab.componentJoint.transLimitSpring[axis], grab.componentJoint.transLimitDamping[axis])\n                                                                    end\n                                                                end\n                                                            end\n                                                        end\n                                                    end\n                                                end\n                                            end\n\n"})}),"\n",(0,l.jsx)(n.h3,{id:"prerequisitespresent",children:"prerequisitesPresent"}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Description"})}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Definition"})}),"\n",(0,l.jsxs)(n.blockquote,{children:["\n",(0,l.jsx)(n.p,{children:"prerequisitesPresent()"}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,l.jsx)(n.table,{children:(0,l.jsx)(n.thead,{children:(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.th,{children:"any"}),(0,l.jsx)(n.th,{children:"specializations"})]})})}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Code"})}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-lua",children:"function BaleGrab.prerequisitesPresent(specializations)\n    return true\nend\n\n"})}),"\n",(0,l.jsx)(n.h3,{id:"registereventlisteners",children:"registerEventListeners"}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Description"})}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Definition"})}),"\n",(0,l.jsxs)(n.blockquote,{children:["\n",(0,l.jsx)(n.p,{children:"registerEventListeners()"}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,l.jsx)(n.table,{children:(0,l.jsx)(n.thead,{children:(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.th,{children:"any"}),(0,l.jsx)(n.th,{children:"vehicleType"})]})})}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Code"})}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-lua",children:'function BaleGrab.registerEventListeners(vehicleType)\n    SpecializationUtil.registerEventListener(vehicleType, "onLoad" , BaleGrab )\n    SpecializationUtil.registerEventListener(vehicleType, "onPostLoad" , BaleGrab )\n    SpecializationUtil.registerEventListener(vehicleType, "onDelete" , BaleGrab )\n    SpecializationUtil.registerEventListener(vehicleType, "onUpdateTick" , BaleGrab )\nend\n\n'})}),"\n",(0,l.jsx)(n.h3,{id:"registerfunctions",children:"registerFunctions"}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Description"})}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Definition"})}),"\n",(0,l.jsxs)(n.blockquote,{children:["\n",(0,l.jsx)(n.p,{children:"registerFunctions()"}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,l.jsx)(n.table,{children:(0,l.jsx)(n.thead,{children:(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.th,{children:"any"}),(0,l.jsx)(n.th,{children:"vehicleType"})]})})}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Code"})}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-lua",children:'function BaleGrab.registerFunctions(vehicleType)\n    SpecializationUtil.registerFunction(vehicleType, "baleGrabTriggerCallback" , BaleGrab.baleGrabTriggerCallback)\n    SpecializationUtil.registerFunction(vehicleType, "addDynamicMountedObject" , BaleGrab.addDynamicMountedObject)\n    SpecializationUtil.registerFunction(vehicleType, "removeDynamicMountedObject" , BaleGrab.removeDynamicMountedObject)\n    SpecializationUtil.registerFunction(vehicleType, "getIsBaleGrabClosed" , BaleGrab.getIsBaleGrabClosed)\n    SpecializationUtil.registerFunction(vehicleType, "mountBaleGrabObject" , BaleGrab.mountBaleGrabObject)\n    SpecializationUtil.registerFunction(vehicleType, "unmountBaleGrabObject" , BaleGrab.unmountBaleGrabObject)\nend\n\n'})}),"\n",(0,l.jsx)(n.h3,{id:"registeroverwrittenfunctions",children:"registerOverwrittenFunctions"}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Description"})}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Definition"})}),"\n",(0,l.jsxs)(n.blockquote,{children:["\n",(0,l.jsx)(n.p,{children:"registerOverwrittenFunctions()"}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,l.jsx)(n.table,{children:(0,l.jsx)(n.thead,{children:(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.th,{children:"any"}),(0,l.jsx)(n.th,{children:"vehicleType"})]})})}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Code"})}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-lua",children:'function BaleGrab.registerOverwrittenFunctions(vehicleType)\n    SpecializationUtil.registerOverwrittenFunction(vehicleType, "getMovingToolMoveValue" , BaleGrab.getMovingToolMoveValue)\nend\n\n'})}),"\n",(0,l.jsx)(n.h3,{id:"removedynamicmountedobject",children:"removeDynamicMountedObject"}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Description"})}),"\n",(0,l.jsxs)(n.blockquote,{children:["\n",(0,l.jsx)(n.p,{children:"Remove dynamic mount object"}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Definition"})}),"\n",(0,l.jsxs)(n.blockquote,{children:["\n",(0,l.jsx)(n.p,{children:"removeDynamicMountedObject(table object, boolean isDeleting)"}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,l.jsxs)(n.table,{children:[(0,l.jsx)(n.thead,{children:(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.th,{children:"table"}),(0,l.jsx)(n.th,{children:"object"}),(0,l.jsx)(n.th,{children:"object"})]})}),(0,l.jsx)(n.tbody,{children:(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{children:"boolean"}),(0,l.jsx)(n.td,{children:"isDeleting"}),(0,l.jsx)(n.td,{children:"is deleting"})]})})]}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Code"})}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-lua",children:"function BaleGrab:removeDynamicMountedObject(object, isDeleting)\n    local spec = self.spec_baleGrab\n\n    if object.dynamicMountType = = MountableObject.MOUNT_TYPE_DYNAMIC then\n        object:unmountDynamic()\n    end\n\n    spec.dynamicMountedObjects[object] = nil\n    if isDeleting then\n        spec.pendingDynamicMountObjects[object] = nil\n    end\nend\n\n"})}),"\n",(0,l.jsx)(n.h3,{id:"unmountbalegrabobject",children:"unmountBaleGrabObject"}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Description"})}),"\n",(0,l.jsxs)(n.blockquote,{children:["\n",(0,l.jsx)(n.p,{children:"Unmounts a dynamic object from the bale grab"}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Definition"})}),"\n",(0,l.jsxs)(n.blockquote,{children:["\n",(0,l.jsx)(n.p,{children:"unmountBaleGrabObject(table object)"}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n",(0,l.jsx)(n.table,{children:(0,l.jsx)(n.thead,{children:(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.th,{children:"table"}),(0,l.jsx)(n.th,{children:"object"}),(0,l.jsx)(n.th,{children:"object"})]})})}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Return Values"})}),"\n\n\n\n\n\n\n\n\n",(0,l.jsx)(n.table,{children:(0,l.jsx)(n.thead,{children:(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.th,{children:"table"}),(0,l.jsx)(n.th,{children:"success"}),(0,l.jsx)(n.th,{children:"success"})]})})}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Code"})}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-lua",children:"function BaleGrab:unmountBaleGrabObject(object)\n    self:removeDynamicMountedObject(object, false )\n\n    return true\nend\n\n"})}),"\n",(0,l.jsx)(n.h3,{id:"updatedebugvalues",children:"updateDebugValues"}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Description"})}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Definition"})}),"\n",(0,l.jsxs)(n.blockquote,{children:["\n",(0,l.jsx)(n.p,{children:"updateDebugValues()"}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,l.jsx)(n.table,{children:(0,l.jsx)(n.thead,{children:(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.th,{children:"any"}),(0,l.jsx)(n.th,{children:"values"})]})})}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Code"})}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-lua",children:'function BaleGrab:updateDebugValues(values)\n    if self.isServer then\n        local spec = self.spec_baleGrab\n        for i = 1 , #spec.grabs do\n            local grab = spec.grabs[i]\n\n            if grab.rotationAxis ~ = nil then\n                local isClosed = false\n                grab.lastValues[ 1 ], grab.lastValues[ 2 ], grab.lastValues[ 3 ] = localRotationToLocal(grab.componentJointActor1, grab.componentJointActor0, 0 , 0 , 0 )\n\n                if grab.rotationThreshold > 0 then\n                    if grab.lastValues[grab.rotationAxis] > grab.rotationThreshold then\n                        isClosed = true\n                    end\n                else\n                        if grab.lastValues[grab.rotationAxis] < grab.rotationThreshold then\n                            isClosed = true\n                        end\n                    end\n\n                    table.insert(values, { name = string.format( "grab(rot - %s):" , getName(grab.componentJointActor0)), value = string.format( "offset: %.1fdeg / %.1fdeg | state: %s(t %d)" , math.deg(grab.lastValues[grab.rotationAxis]), math.deg(grab.rotationThreshold), isClosed and "closed" or "open" , grab.closeTimer) } )\n                elseif grab.translationAxis ~ = nil then\n                        local isClosed = false\n                        grab.lastValues[ 1 ], grab.lastValues[ 2 ], grab.lastValues[ 3 ] = localToLocal(grab.componentJointActor1, grab.componentJointActor0, 0 , 0 , 0 )\n\n                        if grab.translationThreshold > 0 then\n                            if grab.lastValues[grab.translationAxis] > grab.translationThreshold then\n                                isClosed = true\n                            end\n                        else\n                                if grab.lastValues[grab.translationAxis] < grab.translationThreshold then\n                                    isClosed = true\n                                end\n                            end\n\n                            table.insert(values, { name = string.format( "grab(trans - %s):" , getName(grab.componentJointActor0)), value = string.format( "offset: %.3f / %.3f | state: %s(t %d)" , grab.lastValues[grab.translationAxis], grab.translationThreshold, isClosed and "closed" or "open" , grab.closeTimer) } )\n                        end\n\n                        for toolIndex = 1 , #grab.movingTools do\n                            local movingToolData = grab.movingTools[toolIndex]\n\n                            local lastMovingDirection = math.sign(movingToolData.lastMoveValue)\n                            local directionStr = lastMovingDirection = = movingToolData.closingDirection and "closing" or(lastMovingDirection = = 0 and "none" or "opening" )\n                            local blockStr = (lastMovingDirection = = movingToolData.closingDirection and grab.closeTimer < BaleGrab.CLOSE_TIMER and next(spec.pendingDynamicMountObjects) ~ = nil ) and " BLOCKED" or ""\n\n                            table.insert(values, { name = "movingTool:" , value = string.format( "%s | direction: %s%s" , getName(movingToolData.movingTool.node), directionStr, blockStr) } )\n                        end\n                    end\n\n                    table.insert(values, { name = "--" , value = "--" } )\n\n                    for object, numShapes in pairs(spec.pendingDynamicMountObjects) do\n                        local rootNode = object.nodeId or object.rootNode\n                        local state = spec.dynamicMountedObjects[object] = = nil and "<> Pending " or ">< Mounted "\n                        table.insert(values, { name = state, value = string.format( "%s(id %d, numShapes %d)" , getName(rootNode), rootNode, numShapes) } )\n                    end\n                end\n            end\n\n'})})]})}function h(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,l.jsx)(n,{...e,children:(0,l.jsx)(d,{...e})}):d(e)}}}]);