"use strict";(globalThis.webpackChunkfs25_community_luadoc=globalThis.webpackChunkfs25_community_luadoc||[]).push([[81130],{28453(e,n,t){t.d(n,{R:()=>s,x:()=>i});var l=t(96540);const o={},r=l.createContext(o);function s(e){const n=l.useContext(r);return l.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function i(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:s(e.components),l.createElement(r.Provider,{value:n},e.children)}},33667(e,n,t){t.r(n),t.d(n,{assets:()=>d,contentTitle:()=>i,default:()=>u,frontMatter:()=>s,metadata:()=>l,toc:()=>a});const l=JSON.parse('{"id":"script/Debug/DebugDensityMap","title":"DebugDensityMap","description":"DebugDensityMap","source":"@site/../docs/script/Debug/DebugDensityMap.md","sourceDirName":"script/Debug","slug":"/script/Debug/DebugDensityMap","permalink":"/FS25-Community-LUADOC/script/Debug/DebugDensityMap","draft":false,"unlisted":false,"tags":[],"version":"current","lastUpdatedAt":1767161192000,"frontMatter":{},"sidebar":"docsSidebar","previous":{"title":"DebugCylinder","permalink":"/FS25-Community-LUADOC/script/Debug/DebugCylinder"},"next":{"title":"DebugElement","permalink":"/FS25-Community-LUADOC/script/Debug/DebugElement"}}');var o=t(74848),r=t(28453);const s={},i=void 0,d={},a=[{value:"DebugDensityMap",id:"debugdensitymap",level:2},{value:"draw",id:"draw",level:3}];function c(e){const n={a:"a",blockquote:"blockquote",code:"code",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(n.h2,{id:"debugdensitymap",children:"DebugDensityMap"}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Parent"})}),"\n",(0,o.jsxs)(n.blockquote,{children:["\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.a,{href:"?version=script&category=21&class=199",children:"DebugElement"})}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Functions"})}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.a,{href:"#draw",children:"draw"})}),"\n"]}),"\n",(0,o.jsx)(n.h3,{id:"draw",children:"draw"}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Description"})}),"\n",(0,o.jsxs)(n.blockquote,{children:["\n",(0,o.jsx)(n.p,{children:"draw"}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Definition"})}),"\n",(0,o.jsxs)(n.blockquote,{children:["\n",(0,o.jsx)(n.p,{children:"draw()"}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Code"})}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-lua",children:'function DebugDensityMap:draw()\n    local resolution = self.resolution\n    local colors = self.pixelValueToColor\n    local radius = self.radius\n\n    local steps = math.ceil(radius / resolution - resolution * 0.5 )\n\n    local visualOffsetX = resolution * 0.5\n    local visualOffsetZ = resolution * 0.5\n\n    local x = self.centerX\n    local z = self.centerZ\n\n    if x = = nil then\n        local _\n        x, _, z = getWorldTranslation(g_cameraManager:getActiveCamera())\n    end\n\n    x = math.floor(x / self.resolution) * self.resolution\n    z = math.floor(z / self.resolution) * self.resolution\n\n    local densityOffsetX = resolution * 0.1\n    local densityOffsetZ = resolution * 0.1\n\n    for xStep = 1 , steps do\n        for zStep = 1 , steps do\n            local startWorldX = x + (xStep - steps * 0.5 ) * resolution\n            local startWorldZ = z + (zStep - steps * 0.5 ) * resolution\n            local widthWorldX = x + (xStep + 1 - steps * 0.5 ) * resolution\n            local widthWorldZ = z + (zStep - steps * 0.5 ) * resolution\n            local heightWorldX = x + (xStep - steps * 0.5 ) * resolution\n            local heightWorldZ = z + (zStep + 1 - steps * 0.5 ) * resolution\n\n            local dStartWorldX = startWorldX + densityOffsetX\n            local dStartWorldZ = startWorldZ + densityOffsetZ\n            local dWidthWorldX = widthWorldX - densityOffsetX\n            local dWidthWorldZ = widthWorldZ + densityOffsetZ\n            local dHeightWorldX = heightWorldX + densityOffsetX\n            local dHeightWorldZ = heightWorldZ - densityOffsetZ\n\n            self.modifier:setParallelogramWorldCoords(dStartWorldX, dStartWorldZ, dWidthWorldX, dWidthWorldZ, dHeightWorldX, dHeightWorldZ, DensityCoordType.POINT_POINT_POINT)\n\n            for i = 0 , ( 2 ^ self.numChannels) - 1 do\n                self.filter:setValueCompareParams(DensityValueCompareType.EQUAL, i)\n                local _, numPixels, _ = self.modifier:executeGet( self.filter)\n\n                if numPixels > 0 then\n                    local vStartWorldX = startWorldX + resolution * 0.1 - visualOffsetX\n                    local vStartWorldZ = startWorldZ + resolution * 0.1 - visualOffsetZ\n                    local vWidthWorldX = widthWorldX - resolution * 0.1 - visualOffsetX\n                    local vWidthWorldZ = widthWorldZ + resolution * 0.1 - visualOffsetZ\n                    local vHeightWorldX = heightWorldX + resolution * 0.1 - visualOffsetX\n                    local vHeightWorldZ = heightWorldZ - resolution * 0.1 - visualOffsetZ\n\n                    local color = colors[i]\n                    if color ~ = nil then\n                        self:drawDebugAreaRectangleFilled(vStartWorldX, vStartWorldZ, vWidthWorldX, vWidthWorldZ, vHeightWorldX, vHeightWorldZ, color)\n                    end\n\n                    local centerX = (vStartWorldX + vWidthWorldX) * 0.5\n                    local centerZ = (vStartWorldZ + vHeightWorldZ) * 0.5\n                    local centerY = getTerrainHeightAtWorldPos(g_terrainNode, centerX, 0 , centerZ) + self.yOffset\n\n                    Utils.renderTextAtWorldPosition(centerX, centerY, centerZ, tostring(i), 0.012 , 0 , self.textColor)\n\n                    break\n                end\n            end\n        end\n    end\n\n    if self.displayLegend then\n        local legendEntryOffset = 0\n        local fontSize = 0.015\n        local colorBoxHeight = getTextHeight(fontSize, "1" ) * 0.9\n        setTextAlignment(RenderText.ALIGN_LEFT)\n        renderText( 0.01 , 0.7 , fontSize, "DebugDensityMap colors" )\n        legendEntryOffset = legendEntryOffset + 1.1 * fontSize\n        -- TODO:add proper sorting\n        for pixelValue, color in pairs(colors) do\n            -- TODO:add support for value to text/desc display\n                drawFilledRect( 0.013 , 0.7 - legendEntryOffset , colorBoxHeight, colorBoxHeight, color[ 1 ], color[ 2 ], color[ 3 ], math.max(color[ 4 ], 0.5 ))\n                renderText( 0.013 + colorBoxHeight * 1.2 , 0.7 - legendEntryOffset, fontSize, string.format( "%d" , pixelValue))\n                legendEntryOffset = legendEntryOffset + fontSize\n            end\n        end\n    end\n\n'})})]})}function u(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(c,{...e})}):c(e)}}}]);