"use strict";(globalThis.webpackChunkfs25_community_luadoc=globalThis.webpackChunkfs25_community_luadoc||[]).push([[27913],{28453(e,n,t){t.d(n,{R:()=>l,x:()=>c});var r=t(96540);const s={},i=r.createContext(s);function l(e){const n=r.useContext(i);return r.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:l(e.components),r.createElement(i.Provider,{value:n},e.children)}},85550(e,n,t){t.r(n),t.d(n,{assets:()=>a,contentTitle:()=>c,default:()=>o,frontMatter:()=>l,metadata:()=>r,toc:()=>h});const r=JSON.parse('{"id":"script/StateMachine/PlayerStateCrouch","title":"PlayerStateCrouch","description":"PlayerStateCrouch","source":"@site/../docs/script/StateMachine/PlayerStateCrouch.md","sourceDirName":"script/StateMachine","slug":"/script/StateMachine/PlayerStateCrouch","permalink":"/FS25-Community-LUADOC/script/StateMachine/PlayerStateCrouch","draft":false,"unlisted":false,"tags":[],"version":"current","lastUpdatedAt":1767161192000,"frontMatter":{},"sidebar":"docsSidebar","previous":{"title":"PlayerOnFootStateMachine","permalink":"/FS25-Community-LUADOC/script/StateMachine/PlayerOnFootStateMachine"},"next":{"title":"PlayerStateFall","permalink":"/FS25-Community-LUADOC/script/StateMachine/PlayerStateFall"}}');var s=t(74848),i=t(28453);const l={},c=void 0,a={},h=[{value:"PlayerStateCrouch",id:"playerstatecrouch",level:2},{value:"calculateDesiredHorizontalVelocity",id:"calculatedesiredhorizontalvelocity",level:3},{value:"calculateIfCrouching",id:"calculateifcrouching",level:3},{value:"calculateIfValidEntryState",id:"calculateifvalidentrystate",level:3},{value:"createTransitions",id:"createtransitions",level:3},{value:"new",id:"new",level:3},{value:"onStateEntered",id:"onstateentered",level:3},{value:"onStateExited",id:"onstateexited",level:3},{value:"resetTimers",id:"resettimers",level:3},{value:"updateAsCurrent",id:"updateascurrent",level:3}];function d(e){const n={a:"a",blockquote:"blockquote",code:"code",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,i.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.h2,{id:"playerstatecrouch",children:"PlayerStateCrouch"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"The state used for the player moving on foot while holding the crouch button."}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Parent"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.a,{href:"?version=script&category=80&class=842",children:"BaseStateMachineState"})}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Functions"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#calculatedesiredhorizontalvelocity",children:"calculateDesiredHorizontalVelocity"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#calculateifcrouching",children:"calculateIfCrouching"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#calculateifvalidentrystate",children:"calculateIfValidEntryState"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#createtransitions",children:"createTransitions"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#new",children:"new"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#onstateentered",children:"onStateEntered"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#onstateexited",children:"onStateExited"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#resettimers",children:"resetTimers"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#updateascurrent",children:"updateAsCurrent"})}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"calculatedesiredhorizontalvelocity",children:"calculateDesiredHorizontalVelocity"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"Calculates the desired horizontal velocity in metres per second."}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Definition"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"calculateDesiredHorizontalVelocity(float directionX, float directionZ)"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"float"}),(0,s.jsx)(n.th,{children:"directionX"}),(0,s.jsx)(n.th,{children:"The direction on the x axis to use."})]})}),(0,s.jsx)(n.tbody,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"float"}),(0,s.jsx)(n.td,{children:"directionZ"}),(0,s.jsx)(n.td,{children:"The direction on the z axis to use."})]})})]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Return Values"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"float"}),(0,s.jsx)(n.th,{children:"x"}),(0,s.jsx)(n.th,{children:"The desired x."})]})}),(0,s.jsx)(n.tbody,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"float"}),(0,s.jsx)(n.td,{children:"z"}),(0,s.jsx)(n.td,{children:"The desired z."})]})})]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Code"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:"function PlayerStateCrouch:calculateDesiredHorizontalVelocity(directionX, directionZ)\n\n    -- Calculate the speed to use then return it as a velocity vector.\n    local speed = self.player.mover:calculateSmoothSpeed( self.player.inputComponent.walkAxis, true , 0 , PlayerStateCrouch.MAXIMUM_MOVE_SPEED)\n    return directionX * speed, directionZ * speed\nend\n\n"})}),"\n",(0,s.jsx)(n.h3,{id:"calculateifcrouching",children:"calculateIfCrouching"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"Determines if this state is valid to transition to from another state. Does not excessively check things like grounded\nstate and water level, as the transition can only happen from valid states."}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Definition"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"calculateIfCrouching()"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Return Values"})}),"\n\n\n\n\n\n\n\n\n",(0,s.jsx)(n.table,{children:(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"float"}),(0,s.jsx)(n.th,{children:"true"}),(0,s.jsx)(n.th,{children:"if the player is holding the crouch button."})]})})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Code"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:"function PlayerStateCrouch:calculateIfCrouching()\n    if self.player.isOwner then\n        return self.player.inputComponent.crouchValue > 0.0\n        and( not self.player:getIsHoldingHandTool() or self.player:getHeldHandTool().canCrouch)\n        and self.player.mover.currentWaterSubmergeDistance < 1\n    else\n            -- TODO:Implement crouching over the network.\n            return false\n        end\n    end\n\n"})}),"\n",(0,s.jsx)(n.h3,{id:"calculateifvalidentrystate",children:"calculateIfValidEntryState"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"Determines if this state should be used after the player comes out of a forced state or vehicle."}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Definition"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"calculateIfValidEntryState()"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Return Values"})}),"\n\n\n\n\n\n\n\n\n",(0,s.jsx)(n.table,{children:(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"float"}),(0,s.jsx)(n.th,{children:"true"}),(0,s.jsx)(n.th,{children:"if the player is holding the crouch button, is grounded, and is not so deep in water that they are swimming."})]})})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Code"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:"function PlayerStateCrouch:calculateIfValidEntryState()\n    return self:calculateIfCrouching() and self.player.mover.isGrounded and not self.stateMachine.states.swimming:calculateIfSubmerged()\nend\n\n"})}),"\n",(0,s.jsx)(n.h3,{id:"createtransitions",children:"createTransitions"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"Called just after the creation of all states, so that other states can be used to create transitions."}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Definition"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"createTransitions()"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Code"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:"function PlayerStateCrouch:createTransitions()\n\n    self:addTransition( self.stateMachine.states.idle.calculateIfIdle, self.stateMachine.states.idle)\n    self:addTransition( self.stateMachine.states.walking.calculateIfMoving, self.stateMachine.states.walking)\n    self:addTransition( self.stateMachine.states.jumping.calculateIfJumping, self.stateMachine.states.jumping)\nend\n\n"})}),"\n",(0,s.jsx)(n.h3,{id:"new",children:"new"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"Creates a state with the given player and managing state machine."}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Definition"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"new(Player player, StateMachine stateMachine)"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Player"}),(0,s.jsx)(n.th,{children:"player"}),(0,s.jsx)(n.th,{children:"The player who owns this state."})]})}),(0,s.jsx)(n.tbody,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"StateMachine"}),(0,s.jsx)(n.td,{children:"stateMachine"}),(0,s.jsx)(n.td,{children:"The state machine managing this state."})]})})]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Return Values"})}),"\n\n\n\n\n\n\n\n\n",(0,s.jsx)(n.table,{children:(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"StateMachine"}),(0,s.jsx)(n.th,{children:"instance"}),(0,s.jsx)(n.th,{children:"The created instance."})]})})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Code"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:"function PlayerStateCrouch.new(player, stateMachine)\n\n    -- Create the instance and set the player.\n    local self = BaseStateMachineState.new(stateMachine, PlayerStateCrouch _mt)\n    self.player = player\n\n    -- The camera y offset.\n    self.cameraOffsetY = 0.0\n\n    -- The timer for how long the player has been crouched.\n        self.crouchTime = 0.0\n\n        -- The timer for the transition between standing and crouching(and vice versa).\n            self.transitionTime = 0.0\n\n            -- Return the created instance.\n            return self\n        end\n\n"})}),"\n",(0,s.jsx)(n.h3,{id:"onstateentered",children:"onStateEntered"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"Fired when this state is entered."}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Definition"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"onStateEntered(PlayerStateBase previousState)"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n",(0,s.jsx)(n.table,{children:(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"PlayerStateBase"}),(0,s.jsx)(n.th,{children:"previousState"}),(0,s.jsx)(n.th,{children:"The previous state the machine was in before entering this one."})]})})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Code"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:"function PlayerStateCrouch:onStateEntered(previousState)\n    self.player.mover:setIsCrouching( true )\n\n    -- Reset the timers.\n    self:resetTimers()\nend\n\n"})}),"\n",(0,s.jsx)(n.h3,{id:"onstateexited",children:"onStateExited"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"Fired when this state is exited."}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Definition"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"onStateExited(BaseStateMachineState nextState)"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n",(0,s.jsx)(n.table,{children:(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"BaseStateMachineState"}),(0,s.jsx)(n.th,{children:"nextState"}),(0,s.jsx)(n.th,{children:"The state the machine will be in after exiting this one."})]})})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Code"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:"function PlayerStateCrouch:onStateExited(nextState)\n    self.player.mover:setIsCrouching( false )\n\n    -- Reset the timers.\n    self:resetTimers()\nend\n\n"})}),"\n",(0,s.jsx)(n.h3,{id:"resettimers",children:"resetTimers"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"Resets all timers associated with crouching."}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Definition"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"resetTimers()"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Code"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:"function PlayerStateCrouch:resetTimers()\n\n    -- Reset the timers.\n    self.transitionTime = 0.0\n    self.crouchTime = 0.0\n\n    -- Reset the camera offset.\n    self.cameraOffsetY = 0.0\nend\n\n"})}),"\n",(0,s.jsx)(n.h3,{id:"updateascurrent",children:"updateAsCurrent"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"Updates this state when it is currently the state machine's current state."}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Definition"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"updateAsCurrent(float dt)"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n",(0,s.jsx)(n.table,{children:(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"float"}),(0,s.jsx)(n.th,{children:"dt"}),(0,s.jsx)(n.th,{children:"Delta time in ms."})]})})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Code"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:"function PlayerStateCrouch:updateAsCurrent(dt)\n\n    -- If the player is holding the crouch button, increment the crouch timer,\n    if self:calculateIfCrouching() then\n\n        -- Set the height to the crouching height.\n        self.player.capsuleController:setHeight( PlayerCCT.DEFAULT_HEIGHT * 0.5 )\n\n        -- Increment the crouch timer and transition timer.\n        self.crouchTime = self.crouchTime + (dt * 0.001 )\n        self.transitionTime = math.min( self.transitionTime + (dt * 0.001 ), PlayerStateCrouch.SMOOTHING_TIME)\n        -- Otherwise; increment the uncrouch timer.\n    else\n\n            -- Set the height to the standing height.\n            self.player.capsuleController:setHeight( PlayerCCT.DEFAULT_HEIGHT)\n\n            if self.player.capsuleController:getHeight() = = PlayerCCT.DEFAULT_HEIGHT then\n                -- Reset the crouch timer and decrement the transition timer.\n                self.crouchTime = 0.0\n                self.transitionTime = math.max( 0 , self.transitionTime - (dt * 0.001 ))\n            end\n        end\n\n        -- Calculate the crouch progress based on the transition time.\n        local crouchProgress = math.clamp( self.transitionTime / PlayerStateCrouch.SMOOTHING_TIME, 0 , 1 )\n\n        -- Set the y offset based on the crouch progress.\n        self.cameraOffsetY = PlayerStateCrouch.CROUCHED_CAMERA_OFFSET * crouchProgress\n\n        -- If the transition timer is 0 and the player is standing, go through the transitions and see if any are valid.\n            if not self.stateMachine:getIsPassive() and self.transitionTime < = 0 and self.player.capsuleController:getHeight() = = PlayerCCT.DEFAULT_HEIGHT then\n                self:trySwitchToValidTransition()\n            end\n        end\n\n"})})]})}function o(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}}}]);