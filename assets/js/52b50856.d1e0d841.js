"use strict";(globalThis.webpackChunkfs25_community_luadoc=globalThis.webpackChunkfs25_community_luadoc||[]).push([[39900],{28453(e,n,l){l.d(n,{R:()=>r,x:()=>a});var i=l(96540);const t={},s=i.createContext(t);function r(e){const n=i.useContext(s);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:r(e.components),i.createElement(s.Provider,{value:n},e.children)}},85846(e,n,l){l.r(n),l.d(n,{assets:()=>d,contentTitle:()=>a,default:()=>h,frontMatter:()=>r,metadata:()=>i,toc:()=>c});const i=JSON.parse('{"id":"script/Specializations/FillUnit","title":"FillUnit","description":"FillUnit","source":"@site/../docs/script/Specializations/FillUnit.md","sourceDirName":"script/Specializations","slug":"/script/Specializations/FillUnit","permalink":"/FS25-Community-LUADOC/script/Specializations/FillUnit","draft":false,"unlisted":false,"tags":[],"version":"current","lastUpdatedAt":1767161192000,"frontMatter":{},"sidebar":"docsSidebar","previous":{"title":"FillTriggerVehicle","permalink":"/FS25-Community-LUADOC/script/Specializations/FillTriggerVehicle"},"next":{"title":"FillVolume","permalink":"/FS25-Community-LUADOC/script/Specializations/FillVolume"}}');var t=l(74848),s=l(28453);const r={},a=void 0,d={},c=[{value:"FillUnit",id:"fillunit",level:2},{value:"actionEventConsoleFillUnitDec",id:"actioneventconsolefillunitdec",level:3},{value:"actionEventConsoleFillUnitInc",id:"actioneventconsolefillunitinc",level:3},{value:"actionEventConsoleFillUnitNext",id:"actioneventconsolefillunitnext",level:3},{value:"actionEventUnload",id:"actioneventunload",level:3},{value:"addExactFillRootAimToUpdate",id:"addexactfillrootaimtoupdate",level:3},{value:"addFillTypeSources",id:"addfilltypesources",level:3},{value:"addFillUnitFillLevel",id:"addfillunitfilllevel",level:3},{value:"addFillUnitTrigger",id:"addfillunittrigger",level:3},{value:"debugGetSupportedFillTypesPerFillUnit",id:"debuggetsupportedfilltypesperfillunit",level:3},{value:"emptyAllFillUnits",id:"emptyallfillunits",level:3},{value:"getAdditionalComponentMass",id:"getadditionalcomponentmass",level:3},{value:"getAlarmTriggerIsActive",id:"getalarmtriggerisactive",level:3},{value:"getAllowLoadTriggerActivation",id:"getallowloadtriggeractivation",level:3},{value:"getCanBeTurnedOn",id:"getcanbeturnedon",level:3},{value:"getCapacityFromXml",id:"getcapacityfromxml",level:3},{value:"getDoConsumePtoPower",id:"getdoconsumeptopower",level:3},{value:"getDrawFirstFillText",id:"getdrawfirstfilltext",level:3},{value:"getFillLevelInformation",id:"getfilllevelinformation",level:3},{value:"getFillTypeChangeThreshold",id:"getfilltypechangethreshold",level:3},{value:"getFillTypeNamesFromXML",id:"getfilltypenamesfromxml",level:3},{value:"getFillUnitAllowsFillType",id:"getfillunitallowsfilltype",level:3},{value:"getFillUnitAutoAimTargetNode",id:"getfillunitautoaimtargetnode",level:3},{value:"getFillUnitByIndex",id:"getfillunitbyindex",level:3},{value:"getFillUnitCanBeFilled",id:"getfillunitcanbefilled",level:3},{value:"getFillUnitCapacity",id:"getfillunitcapacity",level:3},{value:"getFillUnitEmptyOnReset",id:"getfillunitemptyonreset",level:3},{value:"getFillUnitExactFillRootNode",id:"getfillunitexactfillrootnode",level:3},{value:"getFillUnitExists",id:"getfillunitexists",level:3},{value:"getFillUnitExtraDistanceFromNode",id:"getfillunitextradistancefromnode",level:3},{value:"getFillUnitFillLevel",id:"getfillunitfilllevel",level:3},{value:"getFillUnitFillLevelPercentage",id:"getfillunitfilllevelpercentage",level:3},{value:"getFillUnitFillType",id:"getfillunitfilltype",level:3},{value:"getFillUnitFirstSupportedFillType",id:"getfillunitfirstsupportedfilltype",level:3},{value:"getFillUnitForcedMaterialFillType",id:"getfillunitforcedmaterialfilltype",level:3},{value:"getFillUnitFreeCapacity",id:"getfillunitfreecapacity",level:3},{value:"getFillUnitFromNode",id:"getfillunitfromnode",level:3},{value:"getFillUnitHasMountedPalletsToUnload",id:"getfillunithasmountedpalletstounload",level:3},{value:"getFillUnitIndexFromNode",id:"getfillunitindexfromnode",level:3},{value:"getFillUnitLastValidFillType",id:"getfillunitlastvalidfilltype",level:3},{value:"getFillUnitMountedPalletsToUnload",id:"getfillunitmountedpalletstounload",level:3},{value:"getFillUnitRootNode",id:"getfillunitrootnode",level:3},{value:"getFillUnits",id:"getfillunits",level:3},{value:"getFillUnitSupportedFillTypes",id:"getfillunitsupportedfilltypes",level:3},{value:"getFillUnitSupportedToolTypes",id:"getfillunitsupportedtooltypes",level:3},{value:"getFillUnitSupportsFillType",id:"getfillunitsupportsfilltype",level:3},{value:"getFillUnitSupportsToolType",id:"getfillunitsupportstooltype",level:3},{value:"getFillUnitSupportsToolTypeAndFillType",id:"getfillunitsupportstooltypeandfilltype",level:3},{value:"getFillUnitUnloadingTasks",id:"getfillunitunloadingtasks",level:3},{value:"getFillUnitUnloadPalletFilename",id:"getfillunitunloadpalletfilename",level:3},{value:"getFirstValidFillUnitToFill",id:"getfirstvalidfillunittofill",level:3},{value:"getIsAttacherJointCompatible",id:"getisattacherjointcompatible",level:3},{value:"getIsFillAllowedFromFarm",id:"getisfillallowedfromfarm",level:3},{value:"getIsFillUnitActive",id:"getisfillunitactive",level:3},{value:"getIsFoldAllowed",id:"getisfoldallowed",level:3},{value:"getIsLevelerPickupNodeActive",id:"getislevelerpickupnodeactive",level:3},{value:"getIsMovingToolActive",id:"getismovingtoolactive",level:3},{value:"getIsPowerTakeOffActive",id:"getispowertakeoffactive",level:3},{value:"getIsReadyForAutomatedTrainTravel",id:"getisreadyforautomatedtraintravel",level:3},{value:"getSpecValueCapacity",id:"getspecvaluecapacity",level:3},{value:"getSpecValueFillTypes",id:"getspecvaluefilltypes",level:3},{value:"getSpecValueStartFillUnitMassByMassData",id:"getspecvaluestartfillunitmassbymassdata",level:3},{value:"initSpecialization",id:"initspecialization",level:3},{value:"loadAlarmTrigger",id:"loadalarmtrigger",level:3},{value:"loadAttacherJointFromXML",id:"loadattacherjointfromxml",level:3},{value:"loadFillPlane",id:"loadfillplane",level:3},{value:"loadFillTypeMaterials",id:"loadfilltypematerials",level:3},{value:"loadFillUnitFromXML",id:"loadfillunitfromxml",level:3},{value:"loadFillUnitUnloadingFromXML",id:"loadfillunitunloadingfromxml",level:3},{value:"loadLevelerNodeFromXML",id:"loadlevelernodefromxml",level:3},{value:"loadMeasurementNode",id:"loadmeasurementnode",level:3},{value:"loadMovingToolFromXML",id:"loadmovingtoolfromxml",level:3},{value:"loadSpecValueCapacity",id:"loadspecvaluecapacity",level:3},{value:"loadSpecValueFillTypes",id:"loadspecvaluefilltypes",level:3},{value:"loadSpecValueFillUnitMassData",id:"loadspecvaluefillunitmassdata",level:3},{value:"onDeactivate",id:"ondeactivate",level:3},{value:"onDelete",id:"ondelete",level:3},{value:"onDischargeTargetObjectChanged",id:"ondischargetargetobjectchanged",level:3},{value:"onDraw",id:"ondraw",level:3},{value:"onLoad",id:"onload",level:3},{value:"onPostLoad",id:"onpostload",level:3},{value:"onPostUpdate",id:"onpostupdate",level:3},{value:"onReadStream",id:"onreadstream",level:3},{value:"onReadUpdateStream",id:"onreadupdatestream",level:3},{value:"onRegisterActionEvents",id:"onregisteractionevents",level:3},{value:"onUpdateTick",id:"onupdatetick",level:3},{value:"onWriteStream",id:"onwritestream",level:3},{value:"onWriteUpdateStream",id:"onwriteupdatestream",level:3},{value:"prerequisitesPresent",id:"prerequisitespresent",level:3},{value:"registerEventListeners",id:"registereventlisteners",level:3},{value:"registerEvents",id:"registerevents",level:3},{value:"registerFunctions",id:"registerfunctions",level:3},{value:"registerOverwrittenFunctions",id:"registeroverwrittenfunctions",level:3},{value:"registerUnitDisplaySchema",id:"registerunitdisplayschema",level:3},{value:"removeFillUnitTrigger",id:"removefillunittrigger",level:3},{value:"saveStatsToXMLFile",id:"savestatstoxmlfile",level:3},{value:"saveToXMLFile",id:"savetoxmlfile",level:3},{value:"setAlarmTriggerState",id:"setalarmtriggerstate",level:3},{value:"setFillPlaneForcedFillType",id:"setfillplaneforcedfilltype",level:3},{value:"setFillSoundIsPlaying",id:"setfillsoundisplaying",level:3},{value:"setFillUnitCapacity",id:"setfillunitcapacity",level:3},{value:"setFillUnitCapacityToDisplay",id:"setfillunitcapacitytodisplay",level:3},{value:"setFillUnitFillLevelToDisplay",id:"setfillunitfillleveltodisplay",level:3},{value:"setFillUnitFillType",id:"setfillunitfilltype",level:3},{value:"setFillUnitFillTypeToDisplay",id:"setfillunitfilltypetodisplay",level:3},{value:"setFillUnitForcedMaterialFillType",id:"setfillunitforcedmaterialfilltype",level:3},{value:"setFillUnitInTriggerRange",id:"setfillunitintriggerrange",level:3},{value:"setFillUnitIsFilling",id:"setfillunitisfilling",level:3},{value:"setFillUnitLastValidFillType",id:"setfillunitlastvalidfilltype",level:3},{value:"showInfo",id:"showinfo",level:3},{value:"unloadFillUnits",id:"unloadfillunits",level:3},{value:"updateAlarmTriggers",id:"updatealarmtriggers",level:3},{value:"updateFillTypeMaterials",id:"updatefilltypematerials",level:3},{value:"updateFillUnitAutoAimTarget",id:"updatefillunitautoaimtarget",level:3},{value:"updateFillUnitFillPlane",id:"updatefillunitfillplane",level:3},{value:"updateFillUnitTriggers",id:"updatefillunittriggers",level:3},{value:"updateMeasurementNodes",id:"updatemeasurementnodes",level:3},{value:"updateUnloadActionDisplay",id:"updateunloadactiondisplay",level:3}];function o(e){const n={a:"a",blockquote:"blockquote",code:"code",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,s.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.h2,{id:"fillunit",children:"FillUnit"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Description"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"Specialization for vehicles with any sort of capacity or tank. Manages filltypes, capacities, fillLevel changes"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Functions"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#actioneventconsolefillunitdec",children:"actionEventConsoleFillUnitDec"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#actioneventconsolefillunitinc",children:"actionEventConsoleFillUnitInc"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#actioneventconsolefillunitnext",children:"actionEventConsoleFillUnitNext"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#actioneventunload",children:"actionEventUnload"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#addexactfillrootaimtoupdate",children:"addExactFillRootAimToUpdate"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#addfilltypesources",children:"addFillTypeSources"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#addfillunitfilllevel",children:"addFillUnitFillLevel"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#addfillunittrigger",children:"addFillUnitTrigger"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#debuggetsupportedfilltypesperfillunit",children:"debugGetSupportedFillTypesPerFillUnit"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#emptyallfillunits",children:"emptyAllFillUnits"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#getadditionalcomponentmass",children:"getAdditionalComponentMass"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#getalarmtriggerisactive",children:"getAlarmTriggerIsActive"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#getallowloadtriggeractivation",children:"getAllowLoadTriggerActivation"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#getcanbeturnedon",children:"getCanBeTurnedOn"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#getcapacityfromxml",children:"getCapacityFromXml"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#getdoconsumeptopower",children:"getDoConsumePtoPower"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#getdrawfirstfilltext",children:"getDrawFirstFillText"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#getfilllevelinformation",children:"getFillLevelInformation"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#getfilltypechangethreshold",children:"getFillTypeChangeThreshold"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#getfilltypenamesfromxml",children:"getFillTypeNamesFromXML"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#getfillunitallowsfilltype",children:"getFillUnitAllowsFillType"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#getfillunitautoaimtargetnode",children:"getFillUnitAutoAimTargetNode"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#getfillunitbyindex",children:"getFillUnitByIndex"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#getfillunitcanbefilled",children:"getFillUnitCanBeFilled"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#getfillunitcapacity",children:"getFillUnitCapacity"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#getfillunitemptyonreset",children:"getFillUnitEmptyOnReset"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#getfillunitexactfillrootnode",children:"getFillUnitExactFillRootNode"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#getfillunitexists",children:"getFillUnitExists"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#getfillunitextradistancefromnode",children:"getFillUnitExtraDistanceFromNode"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#getfillunitfilllevel",children:"getFillUnitFillLevel"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#getfillunitfilllevelpercentage",children:"getFillUnitFillLevelPercentage"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#getfillunitfilltype",children:"getFillUnitFillType"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#getfillunitfirstsupportedfilltype",children:"getFillUnitFirstSupportedFillType"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#getfillunitforcedmaterialfilltype",children:"getFillUnitForcedMaterialFillType"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#getfillunitfreecapacity",children:"getFillUnitFreeCapacity"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#getfillunitfromnode",children:"getFillUnitFromNode"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#getfillunithasmountedpalletstounload",children:"getFillUnitHasMountedPalletsToUnload"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#getfillunitindexfromnode",children:"getFillUnitIndexFromNode"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#getfillunitlastvalidfilltype",children:"getFillUnitLastValidFillType"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#getfillunitmountedpalletstounload",children:"getFillUnitMountedPalletsToUnload"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#getfillunitrootnode",children:"getFillUnitRootNode"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#getfillunits",children:"getFillUnits"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#getfillunitsupportedfilltypes",children:"getFillUnitSupportedFillTypes"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#getfillunitsupportedtooltypes",children:"getFillUnitSupportedToolTypes"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#getfillunitsupportsfilltype",children:"getFillUnitSupportsFillType"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#getfillunitsupportstooltype",children:"getFillUnitSupportsToolType"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#getfillunitsupportstooltypeandfilltype",children:"getFillUnitSupportsToolTypeAndFillType"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#getfillunitunloadingtasks",children:"getFillUnitUnloadingTasks"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#getfillunitunloadpalletfilename",children:"getFillUnitUnloadPalletFilename"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#getfirstvalidfillunittofill",children:"getFirstValidFillUnitToFill"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#getisattacherjointcompatible",children:"getIsAttacherJointCompatible"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#getisfillallowedfromfarm",children:"getIsFillAllowedFromFarm"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#getisfillunitactive",children:"getIsFillUnitActive"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#getisfoldallowed",children:"getIsFoldAllowed"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#getislevelerpickupnodeactive",children:"getIsLevelerPickupNodeActive"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#getismovingtoolactive",children:"getIsMovingToolActive"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#getispowertakeoffactive",children:"getIsPowerTakeOffActive"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#getisreadyforautomatedtraintravel",children:"getIsReadyForAutomatedTrainTravel"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#getspecvaluecapacity",children:"getSpecValueCapacity"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#getspecvaluefilltypes",children:"getSpecValueFillTypes"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#getspecvaluestartfillunitmassbymassdata",children:"getSpecValueStartFillUnitMassByMassData"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#initspecialization",children:"initSpecialization"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#loadalarmtrigger",children:"loadAlarmTrigger"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#loadattacherjointfromxml",children:"loadAttacherJointFromXML"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#loadfillplane",children:"loadFillPlane"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#loadfilltypematerials",children:"loadFillTypeMaterials"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#loadfillunitfromxml",children:"loadFillUnitFromXML"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#loadfillunitunloadingfromxml",children:"loadFillUnitUnloadingFromXML"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#loadlevelernodefromxml",children:"loadLevelerNodeFromXML"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#loadmeasurementnode",children:"loadMeasurementNode"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#loadmovingtoolfromxml",children:"loadMovingToolFromXML"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#loadspecvaluecapacity",children:"loadSpecValueCapacity"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#loadspecvaluefilltypes",children:"loadSpecValueFillTypes"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#loadspecvaluefillunitmassdata",children:"loadSpecValueFillUnitMassData"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#ondeactivate",children:"onDeactivate"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#ondelete",children:"onDelete"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#ondischargetargetobjectchanged",children:"onDischargeTargetObjectChanged"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#ondraw",children:"onDraw"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#onload",children:"onLoad"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#onpostload",children:"onPostLoad"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#onpostupdate",children:"onPostUpdate"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#onreadstream",children:"onReadStream"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#onreadupdatestream",children:"onReadUpdateStream"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#onregisteractionevents",children:"onRegisterActionEvents"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#onupdatetick",children:"onUpdateTick"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#onwritestream",children:"onWriteStream"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#onwriteupdatestream",children:"onWriteUpdateStream"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#prerequisitespresent",children:"prerequisitesPresent"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#registereventlisteners",children:"registerEventListeners"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#registerevents",children:"registerEvents"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#registerfunctions",children:"registerFunctions"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#registeroverwrittenfunctions",children:"registerOverwrittenFunctions"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#registerunitdisplayschema",children:"registerUnitDisplaySchema"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#removefillunittrigger",children:"removeFillUnitTrigger"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#savestatstoxmlfile",children:"saveStatsToXMLFile"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#savetoxmlfile",children:"saveToXMLFile"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#setalarmtriggerstate",children:"setAlarmTriggerState"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#setfillplaneforcedfilltype",children:"setFillPlaneForcedFillType"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#setfillsoundisplaying",children:"setFillSoundIsPlaying"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#setfillunitcapacity",children:"setFillUnitCapacity"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#setfillunitcapacitytodisplay",children:"setFillUnitCapacityToDisplay"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#setfillunitfillleveltodisplay",children:"setFillUnitFillLevelToDisplay"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#setfillunitfilltype",children:"setFillUnitFillType"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#setfillunitfilltypetodisplay",children:"setFillUnitFillTypeToDisplay"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#setfillunitforcedmaterialfilltype",children:"setFillUnitForcedMaterialFillType"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#setfillunitintriggerrange",children:"setFillUnitInTriggerRange"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#setfillunitisfilling",children:"setFillUnitIsFilling"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#setfillunitlastvalidfilltype",children:"setFillUnitLastValidFillType"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#showinfo",children:"showInfo"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#unloadfillunits",children:"unloadFillUnits"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#updatealarmtriggers",children:"updateAlarmTriggers"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#updatefilltypematerials",children:"updateFillTypeMaterials"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#updatefillunitautoaimtarget",children:"updateFillUnitAutoAimTarget"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#updatefillunitfillplane",children:"updateFillUnitFillPlane"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#updatefillunittriggers",children:"updateFillUnitTriggers"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#updatemeasurementnodes",children:"updateMeasurementNodes"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#updateunloadactiondisplay",children:"updateUnloadActionDisplay"})}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"actioneventconsolefillunitdec",children:"actionEventConsoleFillUnitDec"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Description"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Definition"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"actionEventConsoleFillUnitDec()"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"any"}),(0,t.jsx)(n.th,{children:"self"})]})}),(0,t.jsxs)(n.tbody,{children:[(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"any"}),(0,t.jsx)(n.td,{children:"actionName"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"any"}),(0,t.jsx)(n.td,{children:"inputValue"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"any"}),(0,t.jsx)(n.td,{children:"callbackState"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"any"}),(0,t.jsx)(n.td,{children:"isAnalog"})]})]})]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Code"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:"function FillUnit.actionEventConsoleFillUnitDec( self , actionName, inputValue, callbackState, isAnalog)\n    if self:getIsSelected() then\n        local fillType = self:getFillUnitFillType( 1 )\n        self:addFillUnitFillLevel( self:getOwnerFarmId(), 1 , - 1000 , fillType, ToolType.UNDEFINED, nil )\n    end\nend\n\n"})}),"\n",(0,t.jsx)(n.h3,{id:"actioneventconsolefillunitinc",children:"actionEventConsoleFillUnitInc"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Description"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Definition"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"actionEventConsoleFillUnitInc()"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"any"}),(0,t.jsx)(n.th,{children:"self"})]})}),(0,t.jsxs)(n.tbody,{children:[(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"any"}),(0,t.jsx)(n.td,{children:"actionName"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"any"}),(0,t.jsx)(n.td,{children:"inputValue"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"any"}),(0,t.jsx)(n.td,{children:"callbackState"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"any"}),(0,t.jsx)(n.td,{children:"isAnalog"})]})]})]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Code"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:"function FillUnit.actionEventConsoleFillUnitInc( self , actionName, inputValue, callbackState, isAnalog)\n    if self:getIsSelected() then\n        local fillType = self:getFillUnitFillType( 1 )\n        if fillType = = FillType.UNKNOWN then\n            local fillUnit = self:getFillUnitByIndex( 1 )\n            fillType = next(fillUnit.supportedFillTypes)\n        end\n        self:addFillUnitFillLevel( self:getOwnerFarmId(), 1 , 1000 , fillType, ToolType.UNDEFINED, nil )\n    end\nend\n\n"})}),"\n",(0,t.jsx)(n.h3,{id:"actioneventconsolefillunitnext",children:"actionEventConsoleFillUnitNext"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Description"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Definition"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"actionEventConsoleFillUnitNext()"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"any"}),(0,t.jsx)(n.th,{children:"self"})]})}),(0,t.jsxs)(n.tbody,{children:[(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"any"}),(0,t.jsx)(n.td,{children:"actionName"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"any"}),(0,t.jsx)(n.td,{children:"inputValue"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"any"}),(0,t.jsx)(n.td,{children:"callbackState"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"any"}),(0,t.jsx)(n.td,{children:"isAnalog"})]})]})]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Code"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:"function FillUnit.actionEventConsoleFillUnitNext( self , actionName, inputValue, callbackState, isAnalog)\n    if self:getIsSelected() then\n        local fillType = self:getFillUnitFillType( 1 )\n        local fillUnit = self:getFillUnitByIndex( 1 )\n        local found = false\n        local nextFillType = nil\n        for supportedFillType,_ in pairs(fillUnit.supportedFillTypes) do\n            if not found then\n                if supportedFillType = = fillType then\n                    found = true\n                end\n            else\n                    nextFillType = supportedFillType\n                    break\n                end\n            end\n\n            if nextFillType = = nil then\n                nextFillType = next(fillUnit.supportedFillTypes)\n            end\n\n            self:addFillUnitFillLevel( self:getOwnerFarmId(), 1 , - math.huge, fillType, ToolType.UNDEFINED, nil )\n            self:addFillUnitFillLevel( self:getOwnerFarmId(), 1 , 100 , nextFillType, ToolType.UNDEFINED, nil )\n        end\n    end\n\n"})}),"\n",(0,t.jsx)(n.h3,{id:"actioneventunload",children:"actionEventUnload"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Description"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Definition"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"actionEventUnload()"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"any"}),(0,t.jsx)(n.th,{children:"self"})]})}),(0,t.jsxs)(n.tbody,{children:[(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"any"}),(0,t.jsx)(n.td,{children:"actionName"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"any"}),(0,t.jsx)(n.td,{children:"inputValue"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"any"}),(0,t.jsx)(n.td,{children:"callbackState"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"any"}),(0,t.jsx)(n.td,{children:"isAnalog"})]})]})]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Code"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:"function FillUnit.actionEventUnload( self , actionName, inputValue, callbackState, isAnalog)\n    self:unloadFillUnits()\nend\n\n"})}),"\n",(0,t.jsx)(n.h3,{id:"addexactfillrootaimtoupdate",children:"addExactFillRootAimToUpdate"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Description"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Definition"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"addExactFillRootAimToUpdate()"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"any"}),(0,t.jsx)(n.th,{children:"vehicle"})]})}),(0,t.jsx)(n.tbody,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"any"}),(0,t.jsx)(n.td,{children:"func"})]})})]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Code"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:"function FillUnit:addExactFillRootAimToUpdate(vehicle, func)\n    local spec = self.spec_fillUnit\n    spec.exactFillRootNodeAimToUpdate[vehicle] = func\nend\n\n"})}),"\n",(0,t.jsx)(n.h3,{id:"addfilltypesources",children:"addFillTypeSources"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Description"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Definition"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"addFillTypeSources()"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"any"}),(0,t.jsx)(n.th,{children:"sources"})]})}),(0,t.jsxs)(n.tbody,{children:[(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"any"}),(0,t.jsx)(n.td,{children:"currentVehicle"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"any"}),(0,t.jsx)(n.td,{children:"excludeVehicle"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"any"}),(0,t.jsx)(n.td,{children:"fillTypes"})]})]})]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Code"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:"function FillUnit.addFillTypeSources(sources, currentVehicle, excludeVehicle, fillTypes)\n    if currentVehicle ~ = excludeVehicle then\n        local curVehicle = currentVehicle.spec_fillUnit\n        if curVehicle ~ = nil then\n            for fillUnitIndex2, fillUnit2 in pairs(curVehicle.fillUnits) do\n                for _,fillType in pairs(fillTypes) do\n                    if fillUnit2.supportedFillTypes[fillType] then\n                        if sources[fillType] = = nil then\n                            sources[fillType] = { }\n                        end\n                        table.insert(sources[fillType], { vehicle = currentVehicle, fillUnitIndex = fillUnitIndex2 } )\n                    end\n                end\n            end\n        end\n    end\n\n    if currentVehicle.getAttachedImplements ~ = nil then\n        local attachedImplements = currentVehicle:getAttachedImplements()\n        for _,implement in pairs(attachedImplements) do\n            if implement.object ~ = nil then\n                FillUnit.addFillTypeSources(sources, implement.object, excludeVehicle, fillTypes)\n            end\n        end\n    end\nend\n\n"})}),"\n",(0,t.jsx)(n.h3,{id:"addfillunitfilllevel",children:"addFillUnitFillLevel"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Description"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Definition"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"addFillUnitFillLevel()"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"any"}),(0,t.jsx)(n.th,{children:"farmId"})]})}),(0,t.jsxs)(n.tbody,{children:[(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"any"}),(0,t.jsx)(n.td,{children:"fillUnitIndex"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"any"}),(0,t.jsx)(n.td,{children:"fillLevelDelta"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"any"}),(0,t.jsx)(n.td,{children:"fillTypeIndex"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"any"}),(0,t.jsx)(n.td,{children:"toolType"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"any"}),(0,t.jsx)(n.td,{children:"fillPositionData"})]})]})]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Code"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:'function FillUnit:addFillUnitFillLevel(farmId, fillUnitIndex, fillLevelDelta, fillTypeIndex, toolType, fillPositionData)\n    local spec = self.spec_fillUnit\n    spec.isInfoDirty = true\n\n    -- Check for permission.Do allow vehicles with farmId 0(all-access vehicles).\n        -- Only check for access if value is being removed\n            if fillLevelDelta < 0 and not g_currentMission.accessHandler:canFarmAccess(farmId, self , true ) and not g_guidedTourManager:getIsTourRunning() then\n                return 0\n            end\n\n            -- If this fillunit belongs to a mounted object(pallet), check that the controller of the object\n            -- is allowed to empty the fill unit.\n            if self.getDynamicMountObject ~ = nil then\n                local mounter = self:getDynamicMountObject()\n                if mounter ~ = nil then\n                    -- if the active farm of the mounter has NO access to farmId fill unit:disallow\n                        if not g_currentMission.accessHandler:canFarmAccess(mounter:getActiveFarm(), self , true ) then\n                            return 0\n                        end\n                    end\n                end\n\n                local fillUnit = spec.fillUnits[fillUnitIndex]\n                if fillUnit ~ = nil then\n                    if fillLevelDelta > 0 then\n                        if not fillUnit.ignoreFillLimit then\n                            if g_currentMission.missionInfo.trailerFillLimit and self:getMaxComponentMassReached() then\n                                return 0\n                            end\n                        end\n                    end\n\n                    if not self:getFillUnitSupportsToolTypeAndFillType(fillUnitIndex, toolType, fillTypeIndex) then\n                        return 0\n                    end\n\n                    -- apply limit only on server side, client will receive the correct data\n                    if self.isServer then\n                        if fillLevelDelta > 0 then\n                            if not fillUnit.ignoreFillLimit then\n                                if g_currentMission.missionInfo.trailerFillLimit then\n                                    local maxMassToApply = self:getAvailableComponentMass()\n                                    local fillTypeDesc = g_fillTypeManager:getFillTypeByIndex(fillTypeIndex)\n                                    if fillTypeDesc ~ = nil and fillTypeDesc.massPerLiter ~ = 0 then\n                                        fillLevelDelta = math.min(fillLevelDelta, maxMassToApply / fillTypeDesc.massPerLiter)\n                                    end\n                                end\n                            end\n                        end\n                    end\n\n                    local oldFillLevel = fillUnit.fillLevel\n                    local capacity = fillUnit.capacity\n                    if capacity = = 0 then\n                        capacity = math.huge\n                    end\n\n                    local fillTypeChanged = false\n                    if fillUnit.fillType = = fillTypeIndex then\n                        fillUnit.fillLevel = math.max( 0 , math.min(capacity, oldFillLevel + fillLevelDelta))\n                    else\n                            if fillLevelDelta > 0 then\n                                local allowFillType = self:getFillUnitAllowsFillType(fillUnitIndex, fillTypeIndex)\n                                if allowFillType then\n                                    local oldFillTypeIndex = fillUnit.fillType\n                                    if oldFillLevel > 0 then\n                                        local oldRemoveOnEmpty = spec.removeVehicleIfEmpty\n                                        spec.removeVehicleIfEmpty = false -- do not remove vehicle if we directly fill it again\n\n                                            self:addFillUnitFillLevel(farmId, fillUnitIndex, - math.huge, fillUnit.fillType, toolType, fillPositionData)\n\n                                            spec.removeVehicleIfEmpty = oldRemoveOnEmpty\n                                        end\n                                        oldFillLevel = 0\n                                        fillUnit.fillLevel = math.max( 0 , math.min(capacity, fillLevelDelta))\n                                        fillUnit.fillType = fillTypeIndex\n\n                                        fillTypeChanged = true\n                                        self.rootVehicle:raiseStateChange(VehicleStateChange.FILLTYPE_CHANGE)\n                                        SpecializationUtil.raiseEvent( self , "onChangedFillType" , fillUnitIndex, fillTypeIndex, oldFillTypeIndex)\n                                    else\n                                            return 0\n                                        end\n                                    end\n                                end\n\n                                -- reset fill level if below threshold due to float 32 inaccuracy\n                                    if fillUnit.fillLevel < 0.00001 then\n                                        fillUnit.fillLevel = 0\n                                    end\n\n                                    if fillUnit.fillLevel > 0 then\n                                        fillUnit.lastValidFillType = fillUnit.fillType\n                                    else\n                                            SpecializationUtil.raiseEvent( self , "onChangedFillType" , fillUnitIndex, FillType.UNKNOWN, fillUnit.fillType)\n                                            fillUnit.fillType = FillType.UNKNOWN\n\n                                            if not fillUnit.fillTypeToDisplayIsPersistent then\n                                                fillUnit.fillTypeToDisplay = FillType.UNKNOWN\n                                            end\n\n                                            if not fillUnit.fillLevelToDisplayIsPersistent then\n                                                fillUnit.fillLevelToDisplay = nil\n                                            end\n                                        end\n\n                                        local appliedDelta = fillUnit.fillLevel - oldFillLevel\n\n                                        if self.isServer then\n                                            -- prepare for network\n                                                if fillUnit.synchronizeFillLevel then\n                                                    local hasChanged = false\n                                                    if fillUnit.fillLevel ~ = fillUnit.fillLevelSent then\n                                                        local maxValue = 2 ^ fillUnit.synchronizationNumBits - 1\n                                                        local levelPerBit = fillUnit.capacity / maxValue\n                                                        local changedLevel = math.abs(fillUnit.fillLevel - fillUnit.fillLevelSent)\n\n                                                        if changedLevel > levelPerBit then\n                                                            fillUnit.fillLevelSent = fillUnit.fillLevel\n                                                            hasChanged = true\n                                                        end\n                                                    end\n                                                    if fillUnit.fillType ~ = fillUnit.fillTypeSent then\n                                                        fillUnit.fillTypeSent = fillUnit.fillType\n                                                        hasChanged = true\n                                                    end\n                                                    if fillUnit.lastValidFillType ~ = fillUnit.lastValidFillTypeSent then\n                                                        fillUnit.lastValidFillTypeSent = fillUnit.lastValidFillType\n                                                        hasChanged = true\n                                                    end\n                                                    if hasChanged then\n                                                        self:raiseDirtyFlags(spec.dirtyFlag)\n                                                    end\n                                                end\n                                            end\n\n                                            if fillUnit.updateMass then\n                                                self:setMassDirty()\n                                            end\n\n                                            self:updateFillUnitAutoAimTarget(fillUnit)\n\n                                            if self.isClient then\n                                                self:updateAlarmTriggers(fillUnit.alarmTriggers)\n                                                self:updateFillUnitFillPlane(fillUnit)\n                                                self:updateMeasurementNodes(fillUnit, 0 , true )\n\n                                                if fillTypeChanged then\n                                                    self:updateFillTypeMaterials(fillUnit.fillTypeMaterials, fillUnit.fillType)\n                                                end\n                                            end\n\n                                            SpecializationUtil.raiseEvent( self , "onFillUnitFillLevelChanged" , fillUnitIndex, fillLevelDelta, fillTypeIndex, toolType, fillPositionData, appliedDelta)\n\n                                            if self.isServer then\n                                                if spec.removeVehicleIfEmpty and fillUnit.fillLevel < = spec.removeVehicleThreshold and fillLevelDelta ~ = 0 then\n                                                    if spec.removeVehicleDelay = = 0 then\n                                                        self:delete()\n\n                                                        if spec.removeVehicleReward > 0 then\n                                                            g_currentMission:addMoney(spec.removeVehicleReward, self:getOwnerFarmId(), MoneyType.SOLD_PRODUCTS, true , true )\n                                                        end\n                                                    else\n                                                            Timer.createOneshot(spec.removeVehicleDelay, function ()\n                                                                if not self.isDeleted then\n                                                                    self:delete()\n                                                                end\n\n                                                                if spec.removeVehicleReward > 0 then\n                                                                    g_currentMission:addMoney(spec.removeVehicleReward, self:getOwnerFarmId(), MoneyType.SOLD_PRODUCTS, true , true )\n                                                                end\n                                                            end )\n                                                        end\n                                                    end\n                                                end\n\n                                                if appliedDelta > 0 then\n                                                    -- display default effects\n                                                    if #spec.fillEffects > 0 then\n                                                        g_effectManager:setEffectTypeInfo(spec.fillEffects, fillUnit.fillType)\n                                                        g_effectManager:startEffects(spec.fillEffects)\n\n                                                        spec.activeFillEffects[spec.fillEffects] = 500\n                                                    end\n\n                                                    -- display fill unit effects\n                                                    if #fillUnit.fillEffects > 0 then\n                                                        g_effectManager:setEffectTypeInfo(fillUnit.fillEffects, fillUnit.fillType)\n                                                        g_effectManager:startEffects(fillUnit.fillEffects)\n\n                                                        spec.activeFillEffects[fillUnit.fillEffects] = 500\n                                                    end\n\n                                                    -- start default animation nodes\n                                                    if #spec.animationNodes > 0 then\n                                                        g_animationManager:startAnimations(spec.animationNodes)\n                                                        spec.activeFillAnimations[spec.animationNodes] = 500\n                                                    end\n\n                                                    -- start fill unit animation nodes\n                                                    if #fillUnit.animationNodes > 0 then\n                                                        g_animationManager:startAnimations(fillUnit.animationNodes)\n                                                        spec.activeFillAnimations[fillUnit.animationNodes] = 500\n                                                    end\n\n                                                    if fillUnit.fillAnimation ~ = nil then\n                                                        if fillUnit.fillAnimationLoadTime ~ = nil then\n                                                            local animTime = self:getAnimationTime(fillUnit.fillAnimation)\n                                                            local direction = math.sign(fillUnit.fillAnimationLoadTime - animTime)\n                                                            if direction ~ = 0 then\n                                                                self:playAnimation(fillUnit.fillAnimation, direction, animTime)\n                                                                self:setAnimationStopTime(fillUnit.fillAnimation, fillUnit.fillAnimationLoadTime)\n                                                            end\n                                                        end\n                                                    end\n                                                end\n\n                                                if appliedDelta ~ = 0 then\n                                                    for _, fillLevelAnimation in ipairs(fillUnit.fillLevelAnimations) do\n                                                        if fillUnit.fillLevel > 0 or fillLevelAnimation.resetOnEmpty then\n                                                            local currentTime = self:getAnimationTime(fillLevelAnimation.name)\n                                                            local targetTime = fillUnit.fillLevel / fillUnit.capacity\n                                                            if fillLevelAnimation.useMaxStateIfEmpty and fillUnit.fillLevel = = 0 then\n                                                                targetTime = 1\n                                                            end\n                                                            if not fillLevelAnimation.updateWhileFilled and fillLevelDelta > 0 then\n                                                                targetTime = 1\n                                                            end\n\n                                                            self:setAnimationStopTime(fillLevelAnimation.name, targetTime)\n\n                                                            local speedScale = math.sign(targetTime - currentTime)\n                                                            self:playAnimation(fillLevelAnimation.name, speedScale, currentTime, true )\n                                                        end\n                                                    end\n\n                                                    if fillUnit.hasDashboards and self.updateDashboardValueType ~ = nil then\n                                                        self:updateDashboardValueType( "fillUnit.fillLevel" )\n                                                        self:updateDashboardValueType( "fillUnit.fillLevelPct" )\n                                                        self:updateDashboardValueType( "fillUnit.fillLevelWarning" )\n                                                    end\n\n                                                    FillUnit.updateUnloadActionDisplay( self )\n                                                end\n\n                                                if fillUnit.fillLevel < 0.0001 then\n                                                    if fillUnit.fillAnimation ~ = nil then\n                                                        if fillUnit.fillAnimationEmptyTime ~ = nil then\n                                                            local animTime = self:getAnimationTime(fillUnit.fillAnimation)\n                                                            local direction = math.sign(fillUnit.fillAnimationEmptyTime - animTime)\n                                                            self:playAnimation(fillUnit.fillAnimation, direction, animTime)\n                                                            self:setAnimationStopTime(fillUnit.fillAnimation, fillUnit.fillAnimationEmptyTime)\n                                                        end\n                                                    end\n                                                end\n\n                                                if self.isServer then\n                                                    if not spec.allowFoldingWhileFilled and spec.resetFoldingWhileFilled then\n                                                        if fillUnit.fillLevel > (fillUnit.allowFoldingThreshold or spec.allowFoldingThreshold) and(fillUnit.allowFoldingFillType = = nil or fillUnit.allowFoldingFillType = = fillUnit.fillType) then\n                                                            if self:getIsUnfolded() then\n                                                                self:setFoldState( - self.spec_foldable.turnOnFoldDirection, false )\n                                                            end\n                                                        end\n                                                    end\n                                                end\n\n                                                return appliedDelta\n                                            end\n\n                                            return 0\n                                        end\n\n'})}),"\n",(0,t.jsx)(n.h3,{id:"addfillunittrigger",children:"addFillUnitTrigger"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Description"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"Adds fill trigger"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Definition"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"addFillUnitTrigger(table trigger, integer fillTypeIndex, )"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"table"}),(0,t.jsx)(n.th,{children:"trigger"}),(0,t.jsx)(n.th,{children:"trigger"})]})}),(0,t.jsxs)(n.tbody,{children:[(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"integer"}),(0,t.jsx)(n.td,{children:"fillTypeIndex"}),(0,t.jsx)(n.td,{children:"fillTypeIndex"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"any"}),(0,t.jsx)(n.td,{children:"fillUnitIndex"}),(0,t.jsx)(n.td,{})]})]})]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Code"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:'function FillUnit:addFillUnitTrigger(trigger, fillTypeIndex, fillUnitIndex)\n    local spec = self.spec_fillUnit\n    if #spec.fillTrigger.triggers = = 0 then\n        g_currentMission.activatableObjectsSystem:addActivatable(spec.fillTrigger.activatable)\n        spec.fillTrigger.activatable:setFillType(fillTypeIndex)\n\n        -- automatic filling for mobile version\n            if self.isServer and Platform.gameplay.automaticFilling then\n                self:setFillUnitIsFilling( true )\n            end\n        end\n        table.addElement(spec.fillTrigger.triggers, trigger)\n        SpecializationUtil.raiseEvent( self , "onAddedFillUnitTrigger" , fillTypeIndex, fillUnitIndex, #spec.fillTrigger.triggers)\n\n        self:updateFillUnitTriggers()\n    end\n\n'})}),"\n",(0,t.jsx)(n.h3,{id:"debuggetsupportedfilltypesperfillunit",children:"debugGetSupportedFillTypesPerFillUnit"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Description"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"Returns table with key=fillUnitIndex and value=array of fillTypeIds"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Definition"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"debugGetSupportedFillTypesPerFillUnit()"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Code"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:"function FillUnit:debugGetSupportedFillTypesPerFillUnit()\n    local fillUnitToFillTypes = { }\n    for _, fillUnit in ipairs( self:getFillUnits()) do\n        fillUnitToFillTypes[fillUnit.fillUnitIndex] = fillUnit.supportedFillTypes\n    end\n    return fillUnitToFillTypes\nend\n\n"})}),"\n",(0,t.jsx)(n.h3,{id:"emptyallfillunits",children:"emptyAllFillUnits"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Description"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Definition"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"emptyAllFillUnits()"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,t.jsx)(n.table,{children:(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"any"}),(0,t.jsx)(n.th,{children:"ignoreDeleteOnEmptyFlag"})]})})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Code"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:"function FillUnit:emptyAllFillUnits(ignoreDeleteOnEmptyFlag)\n    local spec = self.spec_fillUnit\n    local oldRemoveOnEmpty = spec.removeVehicleIfEmpty\n    if ignoreDeleteOnEmptyFlag then\n        spec.removeVehicleIfEmpty = false\n    end\n\n    for k, _ in ipairs( self:getFillUnits()) do\n        local fillTypeIndex = self:getFillUnitFillType(k)\n        self:addFillUnitFillLevel( self:getOwnerFarmId(), k, - math.huge, fillTypeIndex, ToolType.UNDEFINED, nil )\n    end\n\n    spec.removeVehicleIfEmpty = oldRemoveOnEmpty\nend\n\n"})}),"\n",(0,t.jsx)(n.h3,{id:"getadditionalcomponentmass",children:"getAdditionalComponentMass"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Description"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Definition"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"getAdditionalComponentMass()"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"any"}),(0,t.jsx)(n.th,{children:"superFunc"})]})}),(0,t.jsx)(n.tbody,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"any"}),(0,t.jsx)(n.td,{children:"component"})]})})]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Code"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:"function FillUnit:getAdditionalComponentMass(superFunc, component)\n    local additionalMass = superFunc( self , component)\n    local spec = self.spec_fillUnit\n\n    for _, fillUnit in ipairs(spec.fillUnits) do\n        if fillUnit.updateMass and fillUnit.fillMassNode = = component.node and fillUnit.fillType ~ = nil and fillUnit.fillType ~ = FillType.UNKNOWN then\n            local desc = g_fillTypeManager:getFillTypeByIndex(fillUnit.fillType)\n            local mass = fillUnit.fillLevel * desc.massPerLiter\n            additionalMass = additionalMass + mass\n        end\n    end\n\n    return additionalMass\nend\n\n"})}),"\n",(0,t.jsx)(n.h3,{id:"getalarmtriggerisactive",children:"getAlarmTriggerIsActive"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Description"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Definition"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"getAlarmTriggerIsActive()"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,t.jsx)(n.table,{children:(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"any"}),(0,t.jsx)(n.th,{children:"alarmTrigger"})]})})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Code"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:"function FillUnit:getAlarmTriggerIsActive(alarmTrigger)\n    local ret = false\n\n    local fillLevelPct = alarmTrigger.fillUnit.fillLevel / alarmTrigger.fillUnit.capacity\n    if fillLevelPct > = alarmTrigger.minFillLevel and fillLevelPct < = alarmTrigger.maxFillLevel then\n        ret = true\n    end\n\n    return ret\nend\n\n"})}),"\n",(0,t.jsx)(n.h3,{id:"getallowloadtriggeractivation",children:"getAllowLoadTriggerActivation"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Description"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Definition"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"getAllowLoadTriggerActivation()"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,t.jsx)(n.table,{children:(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"any"}),(0,t.jsx)(n.th,{children:"rootVehicle"})]})})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Code"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:"function FillUnit:getAllowLoadTriggerActivation(rootVehicle)\n    -- if not g_currentMission.guidedTour:getCanBeFilledByTrigger(self) then\n        -- return false\n        -- end\n\n        if self.rootVehicle = = g_localPlayer:getCurrentVehicle() then\n            return true\n        end\n\n        return false\n    end\n\n"})}),"\n",(0,t.jsx)(n.h3,{id:"getcanbeturnedon",children:"getCanBeTurnedOn"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Description"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Definition"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"getCanBeTurnedOn()"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,t.jsx)(n.table,{children:(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"any"}),(0,t.jsx)(n.th,{children:"superFunc"})]})})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Code"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:"function FillUnit:getCanBeTurnedOn(superFunc)\n    local spec = self.spec_fillUnit\n\n    for _, alarmTrigger in pairs(spec.activeAlarmTriggers) do\n        if alarmTrigger.turnOffInTrigger then\n            return false\n        end\n    end\n\n    return superFunc( self )\nend\n\n"})}),"\n",(0,t.jsx)(n.h3,{id:"getcapacityfromxml",children:"getCapacityFromXml"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Description"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Definition"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"getCapacityFromXml()"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,t.jsx)(n.table,{children:(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"any"}),(0,t.jsx)(n.th,{children:"xmlFile"})]})})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Code"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:'function FillUnit.getCapacityFromXml(xmlFile)\n    local rootName = xmlFile:getRootName()\n    local maxCapacity = 0\n\n    xmlFile:iterate(rootName .. ".fillUnit.fillUnitConfigurations.fillUnitConfiguration" , function (_, key)\n        xmlFile:iterate(key .. ".fillUnits.fillUnit" , function (_, fillUnitKey)\n            maxCapacity = math.max(maxCapacity, xmlFile:getValue(fillUnitKey .. "#capacity" ) or 0 )\n        end )\n    end )\n\n    return maxCapacity\nend\n\n'})}),"\n",(0,t.jsx)(n.h3,{id:"getdoconsumeptopower",children:"getDoConsumePtoPower"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Description"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Definition"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"getDoConsumePtoPower()"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,t.jsx)(n.table,{children:(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"any"}),(0,t.jsx)(n.th,{children:"superFunc"})]})})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Code"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:"function FillUnit:getDoConsumePtoPower(superFunc)\n    local fillTrigger = self.spec_fillUnit.fillTrigger\n    return superFunc( self ) or(fillTrigger.isFilling and fillTrigger.consumePtoPower)\nend\n\n"})}),"\n",(0,t.jsx)(n.h3,{id:"getdrawfirstfilltext",children:"getDrawFirstFillText"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Description"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Definition"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"getDrawFirstFillText()"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Code"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:"function FillUnit:getDrawFirstFillText()\n    return false\nend\n\n"})}),"\n",(0,t.jsx)(n.h3,{id:"getfilllevelinformation",children:"getFillLevelInformation"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Description"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"Get fill level information"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Definition"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"getFillLevelInformation(function superFunc, table display)"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"function"}),(0,t.jsx)(n.th,{children:"superFunc"}),(0,t.jsx)(n.th,{})]})}),(0,t.jsx)(n.tbody,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"table"}),(0,t.jsx)(n.td,{children:"display"}),(0,t.jsx)(n.td,{children:"fill level information"})]})})]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Code"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:"function FillUnit:getFillLevelInformation(superFunc, display)\n    superFunc( self , display)\n\n    local spec = self.spec_fillUnit\n    for i = 1 , #spec.fillUnits do\n        local fillUnit = spec.fillUnits[i]\n        if fillUnit.capacity > 0 and fillUnit.showOnHud then\n            local fillType = fillUnit.fillType\n\n            -- if we only support one fill type and are empty we show the fill type\n                if fillType = = FillType.UNKNOWN then\n                    if table.size(fillUnit.supportedFillTypes) = = 1 then\n                        fillType = next(fillUnit.supportedFillTypes)\n                    end\n                end\n\n                if fillUnit.fillTypeToDisplay ~ = FillType.UNKNOWN then\n                    fillType = fillUnit.fillTypeToDisplay\n                end\n\n                local fillLevel = fillUnit.fillLevel\n                if fillUnit.fillLevelToDisplay ~ = nil then\n                    fillLevel = fillUnit.fillLevelToDisplay\n                end\n\n                local capacity = fillUnit.capacity\n                if fillUnit.capacityToDisplay ~ = nil then\n                    capacity = fillUnit.capacityToDisplay\n                end\n\n                -- child and parent units will be merged together as display if one of them has a valid fill type and another an unknown fill type\n                    -- capacity is used from the parent one\n                    if fillUnit.parentUnitOnHud ~ = nil then\n                        if fillType = = FillType.UNKNOWN then\n                            fillType = spec.fillUnits[fillUnit.parentUnitOnHud].fillType\n                        end\n                        capacity = 0\n                    elseif fillUnit.childUnitOnHud ~ = nil then\n                            if fillType = = FillType.UNKNOWN then\n                                fillType = spec.fillUnits[fillUnit.childUnitOnHud].fillType\n                            end\n                        end\n\n                        local maxReached = not fillUnit.ignoreFillLimit and g_currentMission.missionInfo.trailerFillLimit and self:getMaxComponentMassReached()\n                        display:addFillLevel(fillType, fillLevel, capacity, fillLevel > 0 and fillUnit.uiPrecision or 0 , maxReached, fillUnit.uiDisplayTypeId, fillUnit.uiCustomFillTypeName, fillUnit.uiExtraInfoText)\n                    end\n                end\n            end\n\n"})}),"\n",(0,t.jsx)(n.h3,{id:"getfilltypechangethreshold",children:"getFillTypeChangeThreshold"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Description"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Definition"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"getFillTypeChangeThreshold()"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,t.jsx)(n.table,{children:(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"any"}),(0,t.jsx)(n.th,{children:"fillUnitIndex"})]})})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Code"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:"function FillUnit:getFillTypeChangeThreshold(fillUnitIndex)\n    if fillUnitIndex = = nil then\n        return self.spec_fillUnit.fillTypeChangeThreshold\n    else\n            local capacity = self:getFillUnitCapacity(fillUnitIndex) or 1\n            return capacity * self.spec_fillUnit.fillTypeChangeThreshold\n        end\n    end\n\n"})}),"\n",(0,t.jsx)(n.h3,{id:"getfilltypenamesfromxml",children:"getFillTypeNamesFromXML"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Description"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Definition"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"getFillTypeNamesFromXML()"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,t.jsx)(n.table,{children:(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"any"}),(0,t.jsx)(n.th,{children:"xmlFile"})]})})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Code"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:'function FillUnit.getFillTypeNamesFromXML(xmlFile)\n    local fillTypeNames = nil\n    local fillTypeCategoryNames = nil\n    local rootName = xmlFile:getRootName()\n\n    xmlFile:iterate(rootName .. ".fillUnit.fillUnitConfigurations.fillUnitConfiguration" , function (_, key)\n        xmlFile:iterate(key .. ".fillUnits.fillUnit" , function (_, fillUnitKey)\n            local capacity = xmlFile:getValue(fillUnitKey .. "#capacity" )\n            if capacity = = nil or capacity > 0 then\n                local currentFillTypes = xmlFile:getValue(fillUnitKey .. "#fillTypes" )\n                if currentFillTypes ~ = nil then\n                    if fillTypeNames = = nil then\n                        fillTypeNames = currentFillTypes\n                    else\n                            fillTypeNames = fillTypeNames .. " " .. currentFillTypes\n                        end\n                    end\n\n                    local currentFillTypeCategories = xmlFile:getValue(fillUnitKey .. "#fillTypeCategories" )\n                    if currentFillTypeCategories ~ = nil then\n                        if fillTypeCategoryNames = = nil then\n                            fillTypeCategoryNames = currentFillTypeCategories\n                        else\n                                fillTypeCategoryNames = fillTypeCategoryNames .. " " .. currentFillTypeCategories\n                            end\n                        end\n                    end\n                end )\n            end )\n\n            return { fillTypeNames = fillTypeNames, fillTypeCategoryNames = fillTypeCategoryNames }\n        end\n\n'})}),"\n",(0,t.jsx)(n.h3,{id:"getfillunitallowsfilltype",children:"getFillUnitAllowsFillType"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Description"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Definition"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"getFillUnitAllowsFillType()"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"any"}),(0,t.jsx)(n.th,{children:"fillUnitIndex"})]})}),(0,t.jsx)(n.tbody,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"any"}),(0,t.jsx)(n.td,{children:"fillType"})]})})]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Code"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:"function FillUnit:getFillUnitAllowsFillType(fillUnitIndex, fillType)\n    local spec = self.spec_fillUnit\n    if spec.fillUnits[fillUnitIndex] ~ = nil then\n        if self:getFillUnitSupportsFillType(fillUnitIndex, fillType) then\n            if fillType = = spec.fillUnits[fillUnitIndex].fillType then\n                return true\n            else\n                    return(spec.fillUnits[fillUnitIndex].fillLevel / math.max(spec.fillUnits[fillUnitIndex].capacity, 0.0001 )) < = self:getFillTypeChangeThreshold()\n                end\n            end\n        end\n        return false\n    end\n\n"})}),"\n",(0,t.jsx)(n.h3,{id:"getfillunitautoaimtargetnode",children:"getFillUnitAutoAimTargetNode"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Description"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Definition"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"getFillUnitAutoAimTargetNode()"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,t.jsx)(n.table,{children:(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"any"}),(0,t.jsx)(n.th,{children:"fillUnitIndex"})]})})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Code"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:"function FillUnit:getFillUnitAutoAimTargetNode(fillUnitIndex)\n    local spec = self.spec_fillUnit\n    if spec.fillUnits[fillUnitIndex] ~ = nil then\n        return spec.fillUnits[fillUnitIndex].autoAimTarget.node\n    end\n    return nil\nend\n\n"})}),"\n",(0,t.jsx)(n.h3,{id:"getfillunitbyindex",children:"getFillUnitByIndex"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Description"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Definition"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"getFillUnitByIndex()"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,t.jsx)(n.table,{children:(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"any"}),(0,t.jsx)(n.th,{children:"fillUnitIndex"})]})})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Code"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:"function FillUnit:getFillUnitByIndex(fillUnitIndex)\n    local spec = self.spec_fillUnit\n    if self:getFillUnitExists(fillUnitIndex) then\n        return spec.fillUnits[fillUnitIndex]\n    end\n    return nil\nend\n\n"})}),"\n",(0,t.jsx)(n.h3,{id:"getfillunitcanbefilled",children:"getFillUnitCanBeFilled"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Description"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Definition"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"getFillUnitCanBeFilled()"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"any"}),(0,t.jsx)(n.th,{children:"fillUnitIndex"})]})}),(0,t.jsxs)(n.tbody,{children:[(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"any"}),(0,t.jsx)(n.td,{children:"fillType"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"any"}),(0,t.jsx)(n.td,{children:"ignoreCapacity"})]})]})]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Code"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:"function FillUnit:getFillUnitCanBeFilled(fillUnitIndex, fillType, ignoreCapacity)\n    if self:getFillUnitAllowsFillType(fillUnitIndex, fillType) then\n        if self:getFillUnitFreeCapacity(fillUnitIndex) > 0 or(ignoreCapacity ~ = nil and ignoreCapacity) then\n            return true\n        end\n    end\n\n    return false\nend\n\n"})}),"\n",(0,t.jsx)(n.h3,{id:"getfillunitcapacity",children:"getFillUnitCapacity"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Description"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Definition"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"getFillUnitCapacity()"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,t.jsx)(n.table,{children:(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"any"}),(0,t.jsx)(n.th,{children:"fillUnitIndex"})]})})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Code"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:"function FillUnit:getFillUnitCapacity(fillUnitIndex)\n    local spec = self.spec_fillUnit\n    if spec.fillUnits[fillUnitIndex] ~ = nil then\n        return spec.fillUnits[fillUnitIndex].capacity\n    end\n    return nil\nend\n\n"})}),"\n",(0,t.jsx)(n.h3,{id:"getfillunitemptyonreset",children:"getFillUnitEmptyOnReset"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Description"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Definition"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"getFillUnitEmptyOnReset()"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Code"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:"function FillUnit:getFillUnitEmptyOnReset()\n    return true\nend\n\n"})}),"\n",(0,t.jsx)(n.h3,{id:"getfillunitexactfillrootnode",children:"getFillUnitExactFillRootNode"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Description"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Definition"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"getFillUnitExactFillRootNode()"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,t.jsx)(n.table,{children:(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"any"}),(0,t.jsx)(n.th,{children:"fillUnitIndex"})]})})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Code"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:"function FillUnit:getFillUnitExactFillRootNode(fillUnitIndex)\n    local spec = self.spec_fillUnit\n    if spec.fillUnits[fillUnitIndex] ~ = nil then\n        return spec.fillUnits[fillUnitIndex].exactFillRootNode\n    end\n    return nil\nend\n\n"})}),"\n",(0,t.jsx)(n.h3,{id:"getfillunitexists",children:"getFillUnitExists"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Description"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Definition"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"getFillUnitExists()"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,t.jsx)(n.table,{children:(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"any"}),(0,t.jsx)(n.th,{children:"fillUnitIndex"})]})})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Code"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:"function FillUnit:getFillUnitExists(fillUnitIndex)\n    local spec = self.spec_fillUnit\n    return fillUnitIndex ~ = nil and spec.fillUnits[fillUnitIndex] ~ = nil\nend\n\n"})}),"\n",(0,t.jsx)(n.h3,{id:"getfillunitextradistancefromnode",children:"getFillUnitExtraDistanceFromNode"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Description"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Definition"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"getFillUnitExtraDistanceFromNode()"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,t.jsx)(n.table,{children:(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"any"}),(0,t.jsx)(n.th,{children:"node"})]})})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Code"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:"function FillUnit:getFillUnitExtraDistanceFromNode(node)\n    local spec = self.spec_fillUnit\n    return spec.exactFillRootNodeToExtraDistance[node] or 0\nend\n\n"})}),"\n",(0,t.jsx)(n.h3,{id:"getfillunitfilllevel",children:"getFillUnitFillLevel"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Description"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Definition"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"getFillUnitFillLevel()"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,t.jsx)(n.table,{children:(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"any"}),(0,t.jsx)(n.th,{children:"fillUnitIndex"})]})})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Code"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:"function FillUnit:getFillUnitFillLevel(fillUnitIndex)\n    local spec = self.spec_fillUnit\n    if spec.fillUnits[fillUnitIndex] ~ = nil then\n        return spec.fillUnits[fillUnitIndex].fillLevel\n    end\n    return nil\nend\n\n"})}),"\n",(0,t.jsx)(n.h3,{id:"getfillunitfilllevelpercentage",children:"getFillUnitFillLevelPercentage"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Description"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Definition"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"getFillUnitFillLevelPercentage()"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,t.jsx)(n.table,{children:(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"any"}),(0,t.jsx)(n.th,{children:"fillUnitIndex"})]})})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Code"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:"function FillUnit:getFillUnitFillLevelPercentage(fillUnitIndex)\n    local spec = self.spec_fillUnit\n    local fillUnit = spec.fillUnits[fillUnitIndex]\n    if fillUnit ~ = nil then\n        if fillUnit.capacity > 0 then\n            return fillUnit.fillLevel / fillUnit.capacity\n        end\n\n        return 0\n    end\n\n    return nil\nend\n\n"})}),"\n",(0,t.jsx)(n.h3,{id:"getfillunitfilltype",children:"getFillUnitFillType"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Description"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Definition"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"getFillUnitFillType()"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,t.jsx)(n.table,{children:(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"any"}),(0,t.jsx)(n.th,{children:"fillUnitIndex"})]})})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Code"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:"function FillUnit:getFillUnitFillType(fillUnitIndex)\n    local spec = self.spec_fillUnit\n    if spec.fillUnits[fillUnitIndex] ~ = nil then\n        return spec.fillUnits[fillUnitIndex].fillType\n    end\n    return nil\nend\n\n"})}),"\n",(0,t.jsx)(n.h3,{id:"getfillunitfirstsupportedfilltype",children:"getFillUnitFirstSupportedFillType"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Description"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Definition"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"getFillUnitFirstSupportedFillType()"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,t.jsx)(n.table,{children:(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"any"}),(0,t.jsx)(n.th,{children:"fillUnitIndex"})]})})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Code"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:"function FillUnit:getFillUnitFirstSupportedFillType(fillUnitIndex)\n    local spec = self.spec_fillUnit\n    if spec.fillUnits[fillUnitIndex] ~ = nil then\n        return next(spec.fillUnits[fillUnitIndex].supportedFillTypes)\n    end\n    return nil\nend\n\n"})}),"\n",(0,t.jsx)(n.h3,{id:"getfillunitforcedmaterialfilltype",children:"getFillUnitForcedMaterialFillType"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Description"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Definition"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"getFillUnitForcedMaterialFillType()"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,t.jsx)(n.table,{children:(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"any"}),(0,t.jsx)(n.th,{children:"fillUnitIndex"})]})})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Code"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:"function FillUnit:getFillUnitForcedMaterialFillType(fillUnitIndex)\n    local spec = self.spec_fillUnit\n    if spec.fillUnits[fillUnitIndex] ~ = nil then\n        return spec.fillUnits[fillUnitIndex].forcedMaterialFillType\n    end\n\n    return FillType.UNKNOWN\nend\n\n"})}),"\n",(0,t.jsx)(n.h3,{id:"getfillunitfreecapacity",children:"getFillUnitFreeCapacity"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Description"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"getFillUnitFreeCapacity"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Definition"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"getFillUnitFreeCapacity(integer fillUnitIndex, integer fillTypeIndex, integer farmId)"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"integer"}),(0,t.jsx)(n.th,{children:"fillUnitIndex"}),(0,t.jsx)(n.th,{})]})}),(0,t.jsxs)(n.tbody,{children:[(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"integer"}),(0,t.jsx)(n.td,{children:"fillTypeIndex"}),(0,t.jsx)(n.td,{children:"currently ignored/unused"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"integer"}),(0,t.jsx)(n.td,{children:"farmId"}),(0,t.jsx)(n.td,{children:"currently ignored/unused"})]})]})]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Code"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:"function FillUnit:getFillUnitFreeCapacity(fillUnitIndex, fillTypeIndex, farmId)\n    local spec = self.spec_fillUnit\n    local fillUnit = spec.fillUnits[fillUnitIndex]\n    if fillUnit ~ = nil then\n        local freeCapacity = fillUnit.capacity - fillUnit.fillLevel\n\n        if not fillUnit.ignoreFillLimit then\n            if g_currentMission.missionInfo.trailerFillLimit and self:getMaxComponentMassReached() then\n                return 0\n            end\n        end\n\n        return freeCapacity\n    end\n    return nil\nend\n\n"})}),"\n",(0,t.jsx)(n.h3,{id:"getfillunitfromnode",children:"getFillUnitFromNode"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Description"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Definition"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"getFillUnitFromNode()"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,t.jsx)(n.table,{children:(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"any"}),(0,t.jsx)(n.th,{children:"node"})]})})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Code"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:"function FillUnit:getFillUnitFromNode(node)\n    local spec = self.spec_fillUnit\n    return spec.exactFillRootNodeToFillUnit[node]\nend\n\n"})}),"\n",(0,t.jsx)(n.h3,{id:"getfillunithasmountedpalletstounload",children:"getFillUnitHasMountedPalletsToUnload"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Description"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Definition"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"getFillUnitHasMountedPalletsToUnload()"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Code"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:"function FillUnit:getFillUnitHasMountedPalletsToUnload()\n    return false\nend\n\n"})}),"\n",(0,t.jsx)(n.h3,{id:"getfillunitindexfromnode",children:"getFillUnitIndexFromNode"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Description"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Definition"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"getFillUnitIndexFromNode()"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,t.jsx)(n.table,{children:(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"any"}),(0,t.jsx)(n.th,{children:"node"})]})})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Code"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:"function FillUnit:getFillUnitIndexFromNode(node)\n    local spec = self.spec_fillUnit\n    local fillUnit = spec.exactFillRootNodeToFillUnit[node]\n    if fillUnit ~ = nil then\n        return fillUnit.fillUnitIndex\n    end\n\n    return nil\nend\n\n"})}),"\n",(0,t.jsx)(n.h3,{id:"getfillunitlastvalidfilltype",children:"getFillUnitLastValidFillType"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Description"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Definition"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"getFillUnitLastValidFillType()"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,t.jsx)(n.table,{children:(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"any"}),(0,t.jsx)(n.th,{children:"fillUnitIndex"})]})})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Code"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:"function FillUnit:getFillUnitLastValidFillType(fillUnitIndex)\n    local spec = self.spec_fillUnit\n    if spec.fillUnits[fillUnitIndex] ~ = nil then\n        return spec.fillUnits[fillUnitIndex].lastValidFillType\n    end\n    return nil\nend\n\n"})}),"\n",(0,t.jsx)(n.h3,{id:"getfillunitmountedpalletstounload",children:"getFillUnitMountedPalletsToUnload"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Description"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Definition"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"getFillUnitMountedPalletsToUnload()"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Code"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:"function FillUnit:getFillUnitMountedPalletsToUnload()\n    return nil\nend\n\n"})}),"\n",(0,t.jsx)(n.h3,{id:"getfillunitrootnode",children:"getFillUnitRootNode"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Description"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Definition"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"getFillUnitRootNode()"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,t.jsx)(n.table,{children:(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"any"}),(0,t.jsx)(n.th,{children:"fillUnitIndex"})]})})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Code"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:"function FillUnit:getFillUnitRootNode(fillUnitIndex)\n    local spec = self.spec_fillUnit\n    if spec.fillUnits[fillUnitIndex] ~ = nil then\n        return spec.fillUnits[fillUnitIndex].fillRootNode\n    end\n    return nil\nend\n\n"})}),"\n",(0,t.jsx)(n.h3,{id:"getfillunits",children:"getFillUnits"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Description"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Definition"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"getFillUnits()"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Code"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:"function FillUnit:getFillUnits()\n    local spec = self.spec_fillUnit\n    return spec.fillUnits\nend\n\n"})}),"\n",(0,t.jsx)(n.h3,{id:"getfillunitsupportedfilltypes",children:"getFillUnitSupportedFillTypes"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Description"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Definition"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"getFillUnitSupportedFillTypes()"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,t.jsx)(n.table,{children:(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"any"}),(0,t.jsx)(n.th,{children:"fillUnitIndex"})]})})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Code"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:"function FillUnit:getFillUnitSupportedFillTypes(fillUnitIndex)\n    local spec = self.spec_fillUnit\n    if spec.fillUnits[fillUnitIndex] ~ = nil then\n        return spec.fillUnits[fillUnitIndex].supportedFillTypes\n    end\n    return nil\nend\n\n"})}),"\n",(0,t.jsx)(n.h3,{id:"getfillunitsupportedtooltypes",children:"getFillUnitSupportedToolTypes"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Description"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Definition"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"getFillUnitSupportedToolTypes()"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,t.jsx)(n.table,{children:(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"any"}),(0,t.jsx)(n.th,{children:"fillUnitIndex"})]})})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Code"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:"function FillUnit:getFillUnitSupportedToolTypes(fillUnitIndex)\n    local spec = self.spec_fillUnit\n    if spec.fillUnits[fillUnitIndex] ~ = nil then\n        return spec.fillUnits[fillUnitIndex].supportedToolTypes\n    end\n    return nil\nend\n\n"})}),"\n",(0,t.jsx)(n.h3,{id:"getfillunitsupportsfilltype",children:"getFillUnitSupportsFillType"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Description"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Definition"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"getFillUnitSupportsFillType()"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"any"}),(0,t.jsx)(n.th,{children:"fillUnitIndex"})]})}),(0,t.jsx)(n.tbody,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"any"}),(0,t.jsx)(n.td,{children:"fillType"})]})})]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Code"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:"function FillUnit:getFillUnitSupportsFillType(fillUnitIndex, fillType)\n    local spec = self.spec_fillUnit\n    if spec.fillUnits[fillUnitIndex] ~ = nil then\n        return spec.fillUnits[fillUnitIndex].supportedFillTypes[fillType]\n    end\n    return false\nend\n\n"})}),"\n",(0,t.jsx)(n.h3,{id:"getfillunitsupportstooltype",children:"getFillUnitSupportsToolType"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Description"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Definition"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"getFillUnitSupportsToolType()"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"any"}),(0,t.jsx)(n.th,{children:"fillUnitIndex"})]})}),(0,t.jsx)(n.tbody,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"any"}),(0,t.jsx)(n.td,{children:"toolType"})]})})]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Code"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:"function FillUnit:getFillUnitSupportsToolType(fillUnitIndex, toolType)\n    local spec = self.spec_fillUnit\n    if spec.fillUnits[fillUnitIndex] ~ = nil then\n        return spec.fillUnits[fillUnitIndex].supportedToolTypes[toolType]\n    end\n    return false\nend\n\n"})}),"\n",(0,t.jsx)(n.h3,{id:"getfillunitsupportstooltypeandfilltype",children:"getFillUnitSupportsToolTypeAndFillType"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Description"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Definition"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"getFillUnitSupportsToolTypeAndFillType()"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"any"}),(0,t.jsx)(n.th,{children:"fillUnitIndex"})]})}),(0,t.jsxs)(n.tbody,{children:[(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"any"}),(0,t.jsx)(n.td,{children:"toolType"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"any"}),(0,t.jsx)(n.td,{children:"fillType"})]})]})]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Code"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:"function FillUnit:getFillUnitSupportsToolTypeAndFillType(fillUnitIndex, toolType, fillType)\n    return self:getFillUnitSupportsToolType(fillUnitIndex, toolType)\n    and self:getFillUnitSupportsFillType(fillUnitIndex, fillType)\nend\n\n"})}),"\n",(0,t.jsx)(n.h3,{id:"getfillunitunloadingtasks",children:"getFillUnitUnloadingTasks"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Description"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Definition"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"getFillUnitUnloadingTasks()"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Code"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:"function FillUnit:getFillUnitUnloadingTasks()\n    local unloadingTasks = { }\n    for fillUnitIndex, fillUnit in ipairs( self:getFillUnits()) do\n        local fillLevel = self:getFillUnitFillLevel(fillUnitIndex)\n        if fillUnit.canBeUnloaded and self:getFillUnitFillLevel(fillUnitIndex) > 0 then\n            local palletFilename = self:getFillUnitUnloadPalletFilename(fillUnitIndex)\n            if palletFilename ~ = nil then\n                local fillTypeIndex = self:getFillUnitFillType(fillUnitIndex)\n                table.insert(unloadingTasks, { fillUnitIndex = fillUnitIndex, fillTypeIndex = fillTypeIndex, fillLevel = fillLevel, filename = palletFilename } )\n            end\n        end\n    end\n\n    return unloadingTasks\nend\n\n"})}),"\n",(0,t.jsx)(n.h3,{id:"getfillunitunloadpalletfilename",children:"getFillUnitUnloadPalletFilename"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Description"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Definition"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"getFillUnitUnloadPalletFilename()"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,t.jsx)(n.table,{children:(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"any"}),(0,t.jsx)(n.th,{children:"fillUnitIndex"})]})})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Code"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:"function FillUnit:getFillUnitUnloadPalletFilename(fillUnitIndex)\n    local fillTypeIndex = self:getFillUnitFillType(fillUnitIndex)\n    if fillTypeIndex ~ = FillType.UNKNOWN then\n        local fillType = g_fillTypeManager:getFillTypeByIndex(fillTypeIndex)\n        return fillType.palletFilename\n    end\n\n    return nil\nend\n\n"})}),"\n",(0,t.jsx)(n.h3,{id:"getfirstvalidfillunittofill",children:"getFirstValidFillUnitToFill"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Description"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Definition"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"getFirstValidFillUnitToFill()"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"any"}),(0,t.jsx)(n.th,{children:"fillType"})]})}),(0,t.jsx)(n.tbody,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"any"}),(0,t.jsx)(n.td,{children:"ignoreCapacity"})]})})]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Code"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:"function FillUnit:getFirstValidFillUnitToFill(fillType, ignoreCapacity)\n    local spec = self.spec_fillUnit\n    for fillUnitIndex, _ in ipairs(spec.fillUnits) do\n        if self:getFillUnitAllowsFillType(fillUnitIndex, fillType) then\n            if self:getFillUnitFreeCapacity(fillUnitIndex) > 0 or(ignoreCapacity ~ = nil and ignoreCapacity) then\n                return fillUnitIndex\n            end\n        end\n    end\n\n    return nil\nend\n\n"})}),"\n",(0,t.jsx)(n.h3,{id:"getisattacherjointcompatible",children:"getIsAttacherJointCompatible"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Description"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Definition"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"getIsAttacherJointCompatible()"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"any"}),(0,t.jsx)(n.th,{children:"superFunc"})]})}),(0,t.jsxs)(n.tbody,{children:[(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"any"}),(0,t.jsx)(n.td,{children:"vehicle"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"any"}),(0,t.jsx)(n.td,{children:"attacherJoint"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"any"}),(0,t.jsx)(n.td,{children:"inputAttacherVehicle"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"any"}),(0,t.jsx)(n.td,{children:"inputAttacherJoint"})]})]})]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Code"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:'function FillUnit:getIsAttacherJointCompatible(superFunc, vehicle, attacherJoint, inputAttacherVehicle, inputAttacherJoint)\n    if attacherJoint.limitFillUnitIndex ~ = nil then\n        local fillLevelPct = self:getFillUnitFillLevelPercentage(attacherJoint.limitFillUnitIndex)\n        if fillLevelPct ~ = nil and(fillLevelPct < attacherJoint.minFillLevel or fillLevelPct > attacherJoint.maxFillLevel) then\n            if not attacherJoint.fillUnitTopArmOnly or inputAttacherJoint.topReferenceNode ~ = nil then\n                return false , g_i18n:getText( "warning_fillUnitAttachNotAllowed" )\n            end\n        end\n    end\n\n    return superFunc( self , vehicle, attacherJoint, inputAttacherVehicle, inputAttacherJoint)\nend\n\n'})}),"\n",(0,t.jsx)(n.h3,{id:"getisfillallowedfromfarm",children:"getIsFillAllowedFromFarm"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Description"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Definition"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"getIsFillAllowedFromFarm()"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,t.jsx)(n.table,{children:(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"any"}),(0,t.jsx)(n.th,{children:"farmId"})]})})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Code"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:"function FillUnit:getIsFillAllowedFromFarm(farmId)\n    return true\nend\n\n"})}),"\n",(0,t.jsx)(n.h3,{id:"getisfillunitactive",children:"getIsFillUnitActive"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Description"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Definition"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"getIsFillUnitActive()"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,t.jsx)(n.table,{children:(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"any"}),(0,t.jsx)(n.th,{children:"fillUnitIndex"})]})})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Code"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:"function FillUnit:getIsFillUnitActive(fillUnitIndex)\n    return true\nend\n\n"})}),"\n",(0,t.jsx)(n.h3,{id:"getisfoldallowed",children:"getIsFoldAllowed"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Description"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Definition"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"getIsFoldAllowed()"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"any"}),(0,t.jsx)(n.th,{children:"superFunc"})]})}),(0,t.jsxs)(n.tbody,{children:[(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"any"}),(0,t.jsx)(n.td,{children:"direction"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"any"}),(0,t.jsx)(n.td,{children:"onAiTurnOn"})]})]})]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Code"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:"function FillUnit:getIsFoldAllowed(superFunc, direction, onAiTurnOn)\n    local spec = self.spec_fillUnit\n    if not spec.allowFoldingWhileFilled then\n        for fillUnitIndex, fillUnit in ipairs(spec.fillUnits) do\n            if self:getFillUnitFillLevel(fillUnitIndex) > (fillUnit.allowFoldingThreshold or spec.allowFoldingThreshold) and(fillUnit.allowFoldingFillType = = nil or fillUnit.allowFoldingFillType = = fillUnit.fillType) then\n                return false , spec.texts.warningFoldingFilled\n            end\n        end\n    end\n\n    return superFunc( self , direction, onAiTurnOn)\nend\n\n"})}),"\n",(0,t.jsx)(n.h3,{id:"getislevelerpickupnodeactive",children:"getIsLevelerPickupNodeActive"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Description"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Definition"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"getIsLevelerPickupNodeActive()"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"any"}),(0,t.jsx)(n.th,{children:"superFunc"})]})}),(0,t.jsx)(n.tbody,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"any"}),(0,t.jsx)(n.td,{children:"levelerNode"})]})})]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Code"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:"function FillUnit:getIsLevelerPickupNodeActive(superFunc, levelerNode)\n    local fillLevelPct = self:getFillUnitFillLevelPercentage(levelerNode.limitFillUnitIndex)\n    if fillLevelPct ~ = nil and(fillLevelPct < levelerNode.minFillLevel or fillLevelPct > levelerNode.maxFillLevel) then\n        return false\n    end\n\n    return superFunc( self , levelerNode)\nend\n\n"})}),"\n",(0,t.jsx)(n.h3,{id:"getismovingtoolactive",children:"getIsMovingToolActive"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Description"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Definition"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"getIsMovingToolActive()"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"any"}),(0,t.jsx)(n.th,{children:"superFunc"})]})}),(0,t.jsx)(n.tbody,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"any"}),(0,t.jsx)(n.td,{children:"movingTool"})]})})]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Code"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:"function FillUnit:getIsMovingToolActive(superFunc, movingTool)\n    if movingTool.fillUnitIndex ~ = nil then\n        local fillLevelPct = self:getFillUnitFillLevelPercentage(movingTool.fillUnitIndex)\n        if fillLevelPct > movingTool.minFillLevel or fillLevelPct < movingTool.maxFillLevel then\n            return false\n        end\n    end\n\n    return superFunc( self , movingTool)\nend\n\n"})}),"\n",(0,t.jsx)(n.h3,{id:"getispowertakeoffactive",children:"getIsPowerTakeOffActive"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Description"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Definition"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"getIsPowerTakeOffActive()"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,t.jsx)(n.table,{children:(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"any"}),(0,t.jsx)(n.th,{children:"superFunc"})]})})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Code"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:"function FillUnit:getIsPowerTakeOffActive(superFunc)\n    local fillTrigger = self.spec_fillUnit.fillTrigger\n    return superFunc( self ) or(fillTrigger.isFilling and fillTrigger.consumePtoPower)\nend\n\n"})}),"\n",(0,t.jsx)(n.h3,{id:"getisreadyforautomatedtraintravel",children:"getIsReadyForAutomatedTrainTravel"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Description"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Definition"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"getIsReadyForAutomatedTrainTravel()"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,t.jsx)(n.table,{children:(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"any"}),(0,t.jsx)(n.th,{children:"superFunc"})]})})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Code"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:"function FillUnit:getIsReadyForAutomatedTrainTravel(superFunc)\n    local spec = self.spec_fillUnit\n    for _, fillUnit in ipairs(spec.fillUnits) do\n        if fillUnit.blocksAutomatedTrainTravel and fillUnit.fillLevel > 0 then\n            return false\n        end\n    end\n\n    return superFunc( self )\nend\n\n"})}),"\n",(0,t.jsx)(n.h3,{id:"getspecvaluecapacity",children:"getSpecValueCapacity"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Description"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Definition"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"getSpecValueCapacity()"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"any"}),(0,t.jsx)(n.th,{children:"storeItem"})]})}),(0,t.jsxs)(n.tbody,{children:[(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"any"}),(0,t.jsx)(n.td,{children:"realItem"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"any"}),(0,t.jsx)(n.td,{children:"configurations"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"any"}),(0,t.jsx)(n.td,{children:"saleItem"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"any"}),(0,t.jsx)(n.td,{children:"returnValues"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"any"}),(0,t.jsx)(n.td,{children:"returnRange"})]})]})]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Code"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:'function FillUnit.getSpecValueCapacity(storeItem, realItem, configurations, saleItem, returnValues, returnRange)\n    local configurationIndex = 1\n    if realItem ~ = nil and storeItem.configurations ~ = nil and realItem.configurations[ "fillUnit" ] ~ = nil and storeItem.configurations[ "fillUnit" ] ~ = nil then\n        configurationIndex = realItem.configurations[ "fillUnit" ]\n    elseif configurations ~ = nil and storeItem.configurations ~ = nil and configurations[ "fillUnit" ] ~ = nil and storeItem.configurations[ "fillUnit" ] ~ = nil then\n            configurationIndex = configurations[ "fillUnit" ]\n        end\n\n        local minCapacity = 0\n        local capacity = 0\n        local unit = ""\n\n        local fillUnitConfigurations = storeItem.specs.capacity\n        if fillUnitConfigurations ~ = nil then\n            if realItem ~ = nil or(configurations ~ = nil and saleItem ~ = nil ) then\n                if fillUnitConfigurations[configurationIndex] ~ = nil then\n                    for _, fillUnit in ipairs(fillUnitConfigurations[configurationIndex].fillUnits) do\n                        if realItem ~ = nil and realItem.getFillUnitCapacity ~ = nil and fillUnit.fillUnitIndex ~ = nil then\n                            local unitCapacity = realItem:getFillUnitCapacity(fillUnit.fillUnitIndex)\n                            if unitCapacity ~ = 0 and unitCapacity ~ = math.huge then\n                                if fillUnit.conversionFunc ~ = nil then\n                                    unitCapacity = fillUnit.conversionFunc(unitCapacity)\n                                end\n                                capacity = capacity + unitCapacity\n                            end\n                        else\n                                capacity = capacity + fillUnit.capacity\n                            end\n\n                            unit = fillUnit.unit\n                        end\n                        minCapacity = capacity\n                    end\n                else\n                        -- if no configuration index is given we use the max capacity the vehicle can have\n                            minCapacity = math.huge\n                            capacity = 0\n                            for _, configuration in ipairs(fillUnitConfigurations) do\n                                if configuration.isSelectable then\n                                    local configCapacity = 0\n                                    for _, fillUnit in ipairs(configuration.fillUnits) do\n                                        configCapacity = configCapacity + fillUnit.capacity\n                                        unit = fillUnit.unit\n                                    end\n\n                                    if configCapacity ~ = 0 then\n                                        minCapacity = math.min(minCapacity, configCapacity)\n                                        capacity = math.max(capacity, configCapacity)\n                                    end\n                                end\n                            end\n\n                            if minCapacity = = capacity then\n                                capacity = minCapacity\n                            else\n                                    if minCapacity ~ = math.huge and capacity ~ = 0 then\n                                        if returnValues = = nil or not returnValues then\n                                            -- while allowed to return a string we return capacity range\n                                                capacity = string.format( "%s-%s" , minCapacity, capacity)\n                                            end\n                                        end\n                                    end\n                                end\n                            end\n\n                            if type(capacity) = = "number" and capacity = = 0 then\n                                if returnValues = = nil or not returnValues then\n                                    return nil\n                                end\n                            end\n\n                            if unit ~ = "" then\n                                if unit:sub( 1 , 6 ) = = "$l10n_" then\n                                    unit = unit:sub( 7 )\n                                end\n                            end\n\n                            if returnValues = = nil or not returnValues then\n                                return string.format(g_i18n:getText( "shop_capacityValue" ), capacity, g_i18n:getText(unit or "unit_literShort" ))\n                            else\n                                    if returnRange = = true and capacity ~ = minCapacity then\n                                        return minCapacity, capacity, unit\n                                    else\n                                            return minCapacity, unit\n                                        end\n                                    end\n                                end\n\n'})}),"\n",(0,t.jsx)(n.h3,{id:"getspecvaluefilltypes",children:"getSpecValueFillTypes"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Description"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Definition"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"getSpecValueFillTypes()"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"any"}),(0,t.jsx)(n.th,{children:"storeItem"})]})}),(0,t.jsxs)(n.tbody,{children:[(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"any"}),(0,t.jsx)(n.td,{children:"realItem"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"any"}),(0,t.jsx)(n.td,{children:"configurations"})]})]})]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Code"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:'function FillUnit.getSpecValueFillTypes(storeItem, realItem, configurations)\n    local specs = storeItem.specs.fillTypes\n    if specs ~ = nil then\n        local configuration\n        if configurations ~ = nil then\n            local configId = configurations[ "fillUnit" ]\n            configuration = specs.fillTypesByConfiguration[configId]\n        end\n\n        local categoryNames = specs.categoryNames\n        if configuration ~ = nil then\n            categoryNames = configuration.categoryNames or categoryNames\n        end\n\n        local fillTypeNames = specs.fillTypeNames\n        if configuration ~ = nil then\n            fillTypeNames = configuration.fillTypeNames or fillTypeNames\n        end\n\n        if categoryNames ~ = nil or fillTypeNames ~ = nil then\n            local fillTypes = { }\n            if categoryNames ~ = nil then\n                g_fillTypeManager:getFillTypesByCategoryNames(categoryNames, nil , fillTypes)\n            end\n            if fillTypeNames ~ = nil then\n                g_fillTypeManager:getFillTypesByNames(fillTypeNames, nil , fillTypes)\n            end\n\n            return fillTypes\n        elseif specs.fruitTypeNames ~ = nil then\n                return g_fruitTypeManager:getFillTypeIndicesByFruitTypeNames(specs.fruitTypeNames, nil )\n            elseif specs.fruitTypeCategoryNames ~ = nil then\n                    return g_fruitTypeManager:getFillTypeIndicesByFruitTypeCategoryName(specs.fruitTypeCategoryNames, nil )\n                elseif specs.windrowFillTypes ~ = nil then\n                        return specs.windrowFillTypes\n                    end\n                end\n                return nil\n            end\n\n'})}),"\n",(0,t.jsx)(n.h3,{id:"getspecvaluestartfillunitmassbymassdata",children:"getSpecValueStartFillUnitMassByMassData"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Description"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Definition"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"getSpecValueStartFillUnitMassByMassData()"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,t.jsx)(n.table,{children:(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"any"}),(0,t.jsx)(n.th,{children:"fillUnitMassData"})]})})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Code"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:"function FillUnit.getSpecValueStartFillUnitMassByMassData(fillUnitMassData)\n    local mass = 0\n    for _, massData in pairs(fillUnitMassData) do\n        local fillType\n        if massData.fillTypeCategories ~ = nil then\n            local fillTypes = g_fillTypeManager:getFillTypesByCategoryNames(massData.fillTypeCategories)\n            fillType = fillTypes[ 1 ]\n        elseif massData.fillTypes ~ = nil then\n                local fillTypes = g_fillTypeManager:getFillTypesByNames(massData.fillTypes)\n                fillType = fillTypes[ 1 ]\n            elseif massData.fillType ~ = nil then\n                    fillType = g_fillTypeManager:getFillTypeIndexByName(massData.fillType)\n                end\n\n                if fillType ~ = nil then\n                    local fillTypeDesc = g_fillTypeManager:getFillTypeByIndex(fillType)\n                    mass = mass + massData.capacity * fillTypeDesc.massPerLiter\n                end\n            end\n\n            return mass\n        end\n\n"})}),"\n",(0,t.jsx)(n.h3,{id:"initspecialization",children:"initSpecialization"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Description"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Definition"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"initSpecialization()"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Code"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:'function FillUnit.initSpecialization()\n    g_vehicleConfigurationManager:addConfigurationType( "fillUnit" , g_i18n:getText( "configuration_fillUnit" ), "fillUnit" , VehicleConfigurationItem )\n\n    g_storeManager:addSpecType( "capacity" , "shopListAttributeIconCapacity" , FillUnit.loadSpecValueCapacity, FillUnit.getSpecValueCapacity, StoreSpecies.VEHICLE, { "fillUnit" } )\n    g_storeManager:addSpecType( "fillTypes" , "shopListAttributeIconFillTypes" , FillUnit.loadSpecValueFillTypes, FillUnit.getSpecValueFillTypes, StoreSpecies.VEHICLE, { "fillUnit" } )\n\n    local schema = Vehicle.xmlSchema\n    schema:setXMLSpecializationType( "FillUnit" )\n\n    schema:register(XMLValueType.STRING, "vehicle.storeData.specs.fillTypes" , "Fill types" )\n    schema:register(XMLValueType.STRING, "vehicle.storeData.specs.fillTypeCategories" , "Fill type categories" )\n    schema:register(XMLValueType.STRING, "vehicle.storeData.specs.fruitTypes" , "Fruit types" )\n    schema:register(XMLValueType.STRING, "vehicle.storeData.specs.fruitTypeCategories" , "Fruit type categories" )\n    schema:register(XMLValueType.FLOAT, "vehicle.storeData.specs.capacity" , "Capacity" )\n    FillUnit.registerUnitDisplaySchema(schema, "vehicle.storeData.specs.capacity" )\n\n    schema:register(XMLValueType.BOOL, FillUnit.FILL_UNIT_CONFIG_XML_KEY .. ".fillUnits#removeVehicleIfEmpty" , "Remove vehicle if unit empty" , false )\n        schema:register(XMLValueType.FLOAT, FillUnit.FILL_UNIT_CONFIG_XML_KEY .. ".fillUnits#removeVehicleThreshold" , "Remove vehicle if empty threshold in liters" , 0 )\n            schema:register(XMLValueType.TIME, FillUnit.FILL_UNIT_CONFIG_XML_KEY .. ".fillUnits#removeVehicleDelay" , "Delay for vehicle removal(e.g.can be used while sounds are still playing)" , 0 )\n                schema:register(XMLValueType.FLOAT, FillUnit.FILL_UNIT_CONFIG_XML_KEY .. ".fillUnits#removeVehicleReward" , "Amount of money as reward of removing the pallet" , 0 )\n                schema:register(XMLValueType.BOOL, FillUnit.FILL_UNIT_CONFIG_XML_KEY .. ".fillUnits#allowFoldingWhileFilled" , "Allow folding while filled" , true )\n                    schema:register(XMLValueType.BOOL, FillUnit.FILL_UNIT_CONFIG_XML_KEY .. ".fillUnits#resetFoldingWhileFilled" , "Reset folding while filled" , false )\n                        schema:register(XMLValueType.FLOAT, FillUnit.FILL_UNIT_CONFIG_XML_KEY .. ".fillUnits#allowFoldingThreshold" , "Allow folding threshold" , 0.0001 )\n                        schema:register(XMLValueType.FLOAT, FillUnit.FILL_UNIT_CONFIG_XML_KEY .. ".fillUnits#fillTypeChangeThreshold" , "Fill type overwrite threshold" , 0.05 )\n\n                        schema:register(XMLValueType.FLOAT, FillUnit.FILL_UNIT_CONFIG_XML_KEY .. ".fillUnits.fillTrigger#litersPerSecond" , "Fill liters per second" , 200 )\n                        schema:register(XMLValueType.BOOL, FillUnit.FILL_UNIT_CONFIG_XML_KEY .. ".fillUnits.fillTrigger#consumePtoPower" , "Consume pto power while filling" , false )\n\n                            local fillUnitPath = FillUnit.FILL_UNIT_XML_KEY\n\n                            schema:register(XMLValueType.FLOAT, fillUnitPath .. "#capacity" , "Capacity" , "unlimited" )\n                            schema:register(XMLValueType.BOOL, fillUnitPath .. "#updateMass" , "Update vehicle mass while fill level changes" , true )\n                                schema:register(XMLValueType.BOOL, fillUnitPath .. "#canBeUnloaded" , "Can be unloaded" , true )\n                                schema:register(XMLValueType.FLOAT, fillUnitPath .. "#allowFoldingThreshold" , "Allow folding threshold" , "Value of fillUnits#allowFoldingThreshold" )\n                                schema:register(XMLValueType.STRING, fillUnitPath .. "#allowFoldingFillType" , "Defines the fill type for which the folding threshold applies - all others are always allowed" )\n\n                                    FillUnit.registerUnitDisplaySchema(schema, fillUnitPath)\n                                    schema:register(XMLValueType.BOOL, fillUnitPath .. "#showCapacityInShop" , "Show capacity in shop" , true )\n                                    schema:register(XMLValueType.BOOL, fillUnitPath .. "#showInShop" , "Show in shop" , true )\n\n                                    schema:register(XMLValueType.NODE_INDEX, fillUnitPath .. ".exactFillRootNode#node" , "Exact fill root node" )\n                                    schema:register(XMLValueType.FLOAT, fillUnitPath .. ".exactFillRootNode#extraEffectDistance" , "Exact fill root node extra distance" , 0 )\n\n                                    schema:register(XMLValueType.NODE_INDEX, fillUnitPath .. ".autoAimTargetNode#node" , "Auto aim target node" )\n                                    schema:register(XMLValueType.FLOAT, fillUnitPath .. ".autoAimTargetNode#startZ" , "Start Z translation" )\n                                    schema:register(XMLValueType.FLOAT, fillUnitPath .. ".autoAimTargetNode#endZ" , "End Z translation" )\n                                    schema:register(XMLValueType.FLOAT, fillUnitPath .. ".autoAimTargetNode#startPercentage" , "Start move percentage" )\n                                    schema:register(XMLValueType.BOOL, fillUnitPath .. ".autoAimTargetNode#invert" , "Invert Z movement" )\n\n                                    schema:register(XMLValueType.STRING, fillUnitPath .. "#fillTypeCategories" , "Supported fill type categories" )\n                                    schema:register(XMLValueType.STRING, fillUnitPath .. "#fillTypes" , "Supported fill types" )\n\n                                    schema:register(XMLValueType.FLOAT, fillUnitPath .. "#startFillLevel" , "Start fill level" )\n                                    schema:register(XMLValueType.STRING, fillUnitPath .. "#startFillType" , "Start fill type" )\n\n                                    schema:register(XMLValueType.NODE_INDEX, fillUnitPath .. ".fillRootNode#node" , "Fill root node" , "first component" )\n                                    schema:register(XMLValueType.NODE_INDEX, fillUnitPath .. ".fillMassNode#node" , "Fill root node" , "first component" )\n                                    schema:register(XMLValueType.BOOL, fillUnitPath .. "#updateFillLevelMass" , "Update fill level mass" , true )\n                                    schema:register(XMLValueType.BOOL, fillUnitPath .. "#ignoreFillLimit" , "Ignores limiting of filling if the max mass is reached(if the settings is turned on)" , false )\n\n                                        schema:register(XMLValueType.BOOL, fillUnitPath .. "#synchronizeFillLevel" , "Synchronize fill level" , true )\n                                        schema:register(XMLValueType.BOOL, fillUnitPath .. "#synchronizeFullFillLevel" , "Synchronize fill level as 32bit float instead of percentage with max.16 bits" , false )\n                                        schema:register(XMLValueType.INT, fillUnitPath .. "#synchronizationNumBits" , "Synchronization bits" )\n\n                                        schema:register(XMLValueType.BOOL, fillUnitPath .. "#showOnHud" , "Show on HUD" , true )\n                                        schema:register(XMLValueType.BOOL, fillUnitPath .. "#showOnInfoHud" , "Show on Info HUD" , true )\n                                        schema:register(XMLValueType.INT, fillUnitPath .. "#uiPrecision" , "Precision in UI display" , 0 )\n                                        schema:register(XMLValueType.L10N_STRING, fillUnitPath .. "#uiCustomFillTypeName" , "Custom fill type name for UI display" )\n                                            schema:register(XMLValueType.L10N_STRING, fillUnitPath .. "#uiExtraInfoText" , "Extra text to display behind the fill type name" )\n                                            schema:register(XMLValueType.STRING, fillUnitPath .. "#uiDisplayType" , "The style that is used for the display of the fill level in the HUD(\'BAR\' or \'STEP\')" , "BAR" )\n                                                schema:register(XMLValueType.BOOL, fillUnitPath .. "#blocksAutomatedTrainTravel" , "Block automated train travel if not empty" , false )\n\n                                                    schema:register(XMLValueType.STRING, fillUnitPath .. "#fillAnimation" , "Fill animation name" )\n                                                    schema:register(XMLValueType.FLOAT, fillUnitPath .. "#fillAnimationLoadTime" , "Fill animation load time" )\n                                                    schema:register(XMLValueType.FLOAT, fillUnitPath .. "#fillAnimationEmptyTime" , "Fill animation empty time" )\n\n                                                    schema:register(XMLValueType.STRING, fillUnitPath .. ".fillLevelAnimation(?)#name" , "Fill level animation name(Animation time is set depending on fill level percentage)" )\n                                                    schema:register(XMLValueType.BOOL, fillUnitPath .. ".fillLevelAnimation(?)#resetOnEmpty" , "Update animation when fill level reaches zero" , true )\n                                                    schema:register(XMLValueType.BOOL, fillUnitPath .. ".fillLevelAnimation(?)#updateWhileFilled" , "Animation will be updated while filled(If not \'true\', the animation will be set the the max.state)" , true )\n                                                        schema:register(XMLValueType.BOOL, fillUnitPath .. ".fillLevelAnimation(?)#useMaxStateIfEmpty" , "If the fill unit is empty, the animation will use the max.state" , true )\n\n                                                        schema:register(XMLValueType.FLOAT, fillUnitPath .. ".alarmTriggers.alarmTrigger(?)#minFillLevel" , "Fill animation empty time" )\n                                                        schema:register(XMLValueType.FLOAT, fillUnitPath .. ".alarmTriggers.alarmTrigger(?)#maxFillLevel" , "Fill animation empty time" )\n                                                        schema:register(XMLValueType.BOOL, fillUnitPath .. ".alarmTriggers.alarmTrigger(?)#needsTurnOn" , "Needs turn on" , false )\n                                                        schema:register(XMLValueType.BOOL, fillUnitPath .. ".alarmTriggers.alarmTrigger(?)#turnOffInTrigger" , "Turn off in trigger" , false )\n                                                        SoundManager.registerSampleXMLPaths(schema, fillUnitPath .. ".alarmTriggers.alarmTrigger(?)" , "alarmSound" )\n\n                                                        BeaconLight.registerVehicleXMLPaths(schema, fillUnitPath .. ".alarmTriggers.alarmTrigger(?).beaconLight(?)" )\n                                                        schema:register(XMLValueType.TIME, fillUnitPath .. ".alarmTriggers.alarmTrigger(?).beaconLight(?)#activeDuration" , "Duration the beacon light is active(0:as long as the alarm trigger is active)" , 0 )\n\n                                                        schema:register(XMLValueType.NODE_INDEX, fillUnitPath .. ".measurementNodes.measurementNode(?)#node" , "Measurement node" )\n\n                                                        schema:register(XMLValueType.NODE_INDEX, fillUnitPath .. ".fillPlane.node(?)#node" , "Fill plane node" )\n                                                        schema:register(XMLValueType.FLOAT, fillUnitPath .. ".fillPlane.node(?).key(?)#time" , "Key time" )\n                                                        schema:register(XMLValueType.VECTOR_TRANS, fillUnitPath .. ".fillPlane.node(?).key(?)#translation" , "Translation" )\n                                                        schema:register(XMLValueType.FLOAT, fillUnitPath .. ".fillPlane.node(?).key(?)#y" , "Y Translation" )\n                                                        schema:register(XMLValueType.VECTOR_ROT, fillUnitPath .. ".fillPlane.node(?).key(?)#rotation" , "Rotation" )\n                                                        schema:register(XMLValueType.VECTOR_SCALE, fillUnitPath .. ".fillPlane.node(?).key(?)#scale" , "Scale" )\n                                                        schema:register(XMLValueType.VECTOR_ 2 , fillUnitPath .. ".fillPlane.node(?)#minMaxY" , "Min.and max.Y translation" )\n                                                        schema:register(XMLValueType.BOOL, fillUnitPath .. ".fillPlane.node(?)#alwaysVisible" , "Is always visible" , false )\n                                                        schema:register(XMLValueType.STRING, fillUnitPath .. ".fillPlane#defaultFillType" , "Default fill type name" )\n\n                                                        schema:register(XMLValueType.STRING, fillUnitPath .. ".fillTypeMaterials.material(?)#fillType" , "Fill type name" )\n                                                        schema:register(XMLValueType.NODE_INDEX, fillUnitPath .. ".fillTypeMaterials.material(?)#node" , "Node which receives material" )\n                                                        schema:register(XMLValueType.NODE_INDEX, fillUnitPath .. ".fillTypeMaterials.material(?)#refNode" , "Node which provides material" )\n                                                        schema:register(XMLValueType.STRING, fillUnitPath .. ".fillTypeMaterials.material(?)#materialSlotName" , "Material slot name to apply the defined texture as diffuse map" )\n                                                        schema:register(XMLValueType.FILENAME, fillUnitPath .. ".fillTypeMaterials.material(?)#diffuse" , "Path to a custom diffuse texture to apply" )\n\n                                                        EffectManager.registerEffectXMLPaths(schema, fillUnitPath .. ".fillEffect" )\n                                                        AnimationManager.registerAnimationNodesXMLPaths(schema, fillUnitPath .. ".animationNodes" )\n\n                                                        Dashboard.registerDashboardXMLPaths(schema, fillUnitPath, { "fillLevel" , "fillLevelPct" , "fillLevelWarning" } )\n\n                                                        Dashboard.addDelayedRegistrationFunc(schema, function (cSchema, cKey)\n                                                            cSchema:register(XMLValueType.STRING, cKey .. "#fillType" , "Fill type of fillUnit to be used" )\n                                                            cSchema:register(XMLValueType.INT, cKey .. "#fillUnitIndex" , "Fill unit index to represent" )\n                                                        end )\n\n                                                        schema:register(XMLValueType.NODE_INDEX, FillUnit.FILL_UNIT_CONFIG_XML_KEY .. ".fillUnits.unloading(?)#node" , "Unloading node" )\n                                                        schema:register(XMLValueType.FLOAT, FillUnit.FILL_UNIT_CONFIG_XML_KEY .. ".fillUnits.unloading(?)#width" , "Unloading width" , 15 )\n                                                        schema:register(XMLValueType.VECTOR_TRANS, FillUnit.FILL_UNIT_CONFIG_XML_KEY .. ".fillUnits.unloading(?)#offset" , "Unloading offset" , "0 0 0" )\n\n                                                        EffectManager.registerEffectXMLPaths(schema, FillUnit.FILL_UNIT_CONFIG_XML_KEY .. ".fillUnits.fillEffect" )\n                                                        AnimationManager.registerAnimationNodesXMLPaths(schema, FillUnit.FILL_UNIT_CONFIG_XML_KEY .. ".fillUnits.animationNodes" )\n                                                        SoundManager.registerSampleXMLPaths(schema, "vehicle.fillUnit.sounds" , "fill" )\n\n                                                        schema:register(XMLValueType.INT, Leveler.LEVELER_NODE_XML_KEY .. "#fillUnitIndex" , "Reference fill unit index" , 1 )\n                                                        schema:register(XMLValueType.FLOAT, Leveler.LEVELER_NODE_XML_KEY .. "#minFillLevel" , "Min.fill level to activate leveler node(pct between 0 and 1)" , 0 )\n                                                        schema:register(XMLValueType.FLOAT, Leveler.LEVELER_NODE_XML_KEY .. "#maxFillLevel" , "Max.fill level to activate leveler node(pct between 0 and 1)" , 1 )\n\n                                                        schema:addDelayedRegistrationFunc( "AttacherJoint" , function (cSchema, cKey)\n                                                            cSchema:register(XMLValueType.INT, cKey .. "#fillUnitIndex" , "Reference fill unit index" , 1 )\n                                                            cSchema:register(XMLValueType.BOOL, cKey .. "#fillUnitTopArmOnly" , "Block attaching of implements with top arm only" , false )\n                                                            cSchema:register(XMLValueType.FLOAT, cKey .. "#minFillLevel" , "Min.fill level to activate attacher joint(pct between 0 and 1)" , 0 )\n                                                            cSchema:register(XMLValueType.FLOAT, cKey .. "#maxFillLevel" , "Max.fill level to activate attacher joint(pct between 0 and 1)" , 1 )\n                                                        end )\n\n                                                        schema:setXMLSpecializationType()\n\n                                                        local schemaSavegame = Vehicle.xmlSchemaSavegame\n                                                        schemaSavegame:register(XMLValueType.INT, "vehicles.vehicle(?).fillUnit.unit(?)#index" , "Fill Unit index" )\n                                                        schemaSavegame:register(XMLValueType.STRING, "vehicles.vehicle(?).fillUnit.unit(?)#fillType" , "Fill type" )\n                                                        schemaSavegame:register(XMLValueType.FLOAT, "vehicles.vehicle(?).fillUnit.unit(?)#fillLevel" , "Fill level" )\n                                                    end\n\n'})}),"\n",(0,t.jsx)(n.h3,{id:"loadalarmtrigger",children:"loadAlarmTrigger"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Description"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Definition"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"loadAlarmTrigger()"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"any"}),(0,t.jsx)(n.th,{children:"xmlFile"})]})}),(0,t.jsxs)(n.tbody,{children:[(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"any"}),(0,t.jsx)(n.td,{children:"key"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"any"}),(0,t.jsx)(n.td,{children:"alarmTrigger"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"any"}),(0,t.jsx)(n.td,{children:"fillUnit"})]})]})]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Code"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:'function FillUnit:loadAlarmTrigger(xmlFile, key, alarmTrigger, fillUnit)\n    alarmTrigger.fillUnit = fillUnit\n    alarmTrigger.isActive = false\n\n    local success = true\n    alarmTrigger.minFillLevel = xmlFile:getValue(key .. "#minFillLevel" )\n    if alarmTrigger.minFillLevel = = nil then\n        Logging.xmlWarning( self.xmlFile, "Missing \'minFillLevel\' for alarmTrigger \'%s\'" , key)\n            success = false\n        end\n\n        alarmTrigger.maxFillLevel = xmlFile:getValue(key .. "#maxFillLevel" )\n        if alarmTrigger.maxFillLevel = = nil then\n            Logging.xmlWarning( self.xmlFile, "Missing \'maxFillLevel\' for alarmTrigger \'%s\'" , key)\n                success = false\n            end\n\n            alarmTrigger.sample = g_soundManager:loadSampleFromXML(xmlFile, key, "alarmSound" , self.baseDirectory, self.components, 0 , AudioGroup.VEHICLE, self.i3dMappings, self )\n\n            alarmTrigger.beaconLights = { }\n            xmlFile:iterate(key .. ".beaconLight" , function (_, beaconKey)\n                local beaconLight = BeaconLight.loadFromVehicleXML(alarmTrigger.beaconLights, xmlFile, beaconKey, self )\n                if beaconLight ~ = nil then\n                    beaconLight.activeDuration = xmlFile:getValue(beaconKey .. "#activeDuration" , 0 )\n                end\n            end )\n\n            return success\n        end\n\n'})}),"\n",(0,t.jsx)(n.h3,{id:"loadattacherjointfromxml",children:"loadAttacherJointFromXML"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Description"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"Load attacher joint from xml"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Definition"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"loadAttacherJointFromXML(table attacherJoint, integer fileId, string baseName, integer index, )"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"table"}),(0,t.jsx)(n.th,{children:"attacherJoint"}),(0,t.jsx)(n.th,{children:"attacherJoint"})]})}),(0,t.jsxs)(n.tbody,{children:[(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"integer"}),(0,t.jsx)(n.td,{children:"fileId"}),(0,t.jsx)(n.td,{children:"xml file id"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"string"}),(0,t.jsx)(n.td,{children:"baseName"}),(0,t.jsx)(n.td,{children:"baseName"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"integer"}),(0,t.jsx)(n.td,{children:"index"}),(0,t.jsx)(n.td,{children:"index of attacher joint"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"any"}),(0,t.jsx)(n.td,{children:"index"}),(0,t.jsx)(n.td,{})]})]})]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Code"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:'function FillUnit:loadAttacherJointFromXML(superFunc, attacherJoint, xmlFile, baseName, index)\n    attacherJoint.limitFillUnitIndex = xmlFile:getValue(baseName .. "#fillUnitIndex" )\n    if attacherJoint.limitFillUnitIndex ~ = nil then\n        attacherJoint.fillUnitTopArmOnly = xmlFile:getValue(baseName .. "#fillUnitTopArmOnly" , false )\n        attacherJoint.minFillLevel = xmlFile:getValue(baseName .. "#minFillLevel" , 0 )\n        attacherJoint.maxFillLevel = xmlFile:getValue(baseName .. "#maxFillLevel" , 1 )\n    end\n\n    return superFunc( self , attacherJoint, xmlFile, baseName, index)\nend\n\n'})}),"\n",(0,t.jsx)(n.h3,{id:"loadfillplane",children:"loadFillPlane"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Description"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Definition"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"loadFillPlane()"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"any"}),(0,t.jsx)(n.th,{children:"xmlFile"})]})}),(0,t.jsxs)(n.tbody,{children:[(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"any"}),(0,t.jsx)(n.td,{children:"key"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"any"}),(0,t.jsx)(n.td,{children:"fillPlane"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"any"}),(0,t.jsx)(n.td,{children:"fillUnit"})]})]})]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Code"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:'function FillUnit:loadFillPlane(xmlFile, key, fillPlane, fillUnit)\n    XMLUtil.checkDeprecatedXMLElements(xmlFile, key .. "#fillType" , "Material is dynamically assigned to the nodes" )\n\n    if not xmlFile:hasProperty(key) then\n        return false\n    end\n\n    fillPlane.nodes = { }\n    local i = 0\n    while true do\n        local nodeKey = string.format( "%s.node(%d)" , key, i)\n        if not xmlFile:hasProperty(nodeKey) then\n            break\n        end\n\n        XMLUtil.checkDeprecatedXMLElements(xmlFile, nodeKey .. "#index" , nodeKey .. "#node" ) -- FS17 to FS19\n\n        local node = xmlFile:getValue(nodeKey .. "#node" , nil , self.components, self.i3dMappings)\n        if node ~ = nil then\n            local defaultX, defaultY, defaultZ = getTranslation(node)\n            local defaultRX, defaultRY, defaultRZ = getRotation(node)\n\n            local animCurve = AnimCurve.new(linearInterpolatorTransRotScale)\n            local j = 0\n            while true do\n                local animKey = string.format( "%s.key(%d)" , nodeKey, j)\n                if not xmlFile:hasProperty(animKey) then\n                    break\n                end\n\n                local keyTime = xmlFile:getValue(animKey .. "#time" )\n                if keyTime = = nil then\n                    break\n                end\n\n                local x, y, z = xmlFile:getValue(animKey .. "#translation" )\n                if y = = nil then\n                    y = xmlFile:getValue(animKey .. "#y" )\n                end\n                x = x or defaultX\n                y = y or defaultY\n                z = z or defaultZ\n\n                local rx, ry, rz = xmlFile:getValue(animKey .. "#rotation" )\n                rx = rx or defaultRX\n                ry = ry or defaultRY\n                rz = rz or defaultRZ\n\n                local sx, sy, sz = xmlFile:getValue(animKey .. "#scale" )\n                sx = sx or 1\n                sy = sy or 1\n                sz = sz or 1\n\n                animCurve:addKeyframe( { x = x, y = y, z = z, rx = rx, ry = ry, rz = rz, sx = sx, sy = sy, sz = sz, time = keyTime } )\n                j = j + 1\n            end\n\n            if j = = 0 then\n                local minY, maxY = xmlFile:getValue(nodeKey .. "#minMaxY" )\n                minY = minY or defaultY\n                maxY = maxY or defaultY\n                animCurve:addKeyframe( { defaultX, minY, defaultZ, defaultRX, defaultRY, defaultRZ, 1 , 1 , 1 , time = 0 } )\n                animCurve:addKeyframe( { defaultX, maxY, defaultZ, defaultRX, defaultRY, defaultRZ, 1 , 1 , 1 , time = 1 } )\n            end\n\n            local alwaysVisible = xmlFile:getValue(nodeKey .. "#alwaysVisible" , false )\n            setVisibility(node, alwaysVisible)\n\n            table.insert(fillPlane.nodes, { node = node, animCurve = animCurve, alwaysVisible = alwaysVisible } )\n\n            local fillPlaneMaterial = g_materialManager:getBaseMaterialByName( "fillPlane" )\n            if fillPlaneMaterial ~ = nil then\n                setMaterial(node, fillPlaneMaterial, 0 )\n                g_fillTypeManager:assignFillTypeTextureArraysFromTerrain(node, g_terrainNode, true , true , true )\n\n                setShaderParameter(node, "isCustomShape" , 1 , 0 , 0 , 0 , false )\n            else\n                    Logging.error( "Failed to assign material to fill plane.Base Material \'fillPlane\' not found!" )\n                end\n            end\n            i = i + 1\n        end\n\n        fillPlane.forcedFillType = nil\n\n        local defaultFillTypeStr = xmlFile:getValue(key .. "#defaultFillType" )\n        if defaultFillTypeStr ~ = nil then\n            local defaultFillTypeIndex = g_fillTypeManager:getFillTypeIndexByName(defaultFillTypeStr)\n            if defaultFillTypeIndex = = nil then\n                Logging.xmlWarning( self.xmlFile, "Invalid defaultFillType \'%s\' for \'%s\'!" , tostring(defaultFillTypeStr), key)\n                    return false\n                else\n                        fillPlane.defaultFillType = defaultFillTypeIndex\n                    end\n                else\n                        fillPlane.defaultFillType = next(fillUnit.supportedFillTypes)\n                    end\n\n                    return true\n                end\n\n'})}),"\n",(0,t.jsx)(n.h3,{id:"loadfilltypematerials",children:"loadFillTypeMaterials"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Description"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Definition"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"loadFillTypeMaterials()"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"any"}),(0,t.jsx)(n.th,{children:"xmlFile"})]})}),(0,t.jsx)(n.tbody,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"any"}),(0,t.jsx)(n.td,{children:"key"})]})})]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Code"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:'function FillUnit:loadFillTypeMaterials(xmlFile, key)\n    local fillTypeMaterials = { }\n    xmlFile:iterate(key .. ".fillTypeMaterials.material" , function (_, materialKey)\n        local fillTypeName = xmlFile:getValue(materialKey .. "#fillType" )\n        if fillTypeName ~ = nil then\n            local fillTypeIndex = g_fillTypeManager:getFillTypeIndexByName(fillTypeName)\n            if fillTypeIndex ~ = nil then\n                local node = xmlFile:getValue(materialKey .. "#node" , nil , self.components, self.i3dMappings)\n                local refNode = xmlFile:getValue(materialKey .. "#refNode" , nil , self.components, self.i3dMappings)\n                local materialSlotName = xmlFile:getValue(materialKey .. "#materialSlotName" )\n                if node ~ = nil and refNode ~ = nil then\n                    local fillTypeMaterial = { }\n                    fillTypeMaterial.fillTypeIndex = fillTypeIndex\n                    fillTypeMaterial.node = node\n                    fillTypeMaterial.refNode = refNode\n                    table.insert(fillTypeMaterials, fillTypeMaterial)\n                elseif materialSlotName ~ = nil then\n                        local materialId = MaterialUtil.getMaterialBySlotName( self.rootNode, materialSlotName)\n                        if materialId = = nil then\n                            Logging.xmlWarning(xmlFile, "Material for slot name \'%s\' not found in \'%s\'" , materialSlotName, materialKey)\n                                return\n                            end\n\n                            local diffuse = xmlFile:getValue(materialKey .. "#diffuse" , nil , self.baseDirectory)\n                            if diffuse ~ = nil then\n                                if textureFileExists(diffuse) then\n                                    local fillTypeMaterial = { }\n                                    fillTypeMaterial.fillTypeIndex = fillTypeIndex\n                                    fillTypeMaterial.materialId = materialId\n                                    fillTypeMaterial.diffuse = diffuse\n                                    table.insert(fillTypeMaterials, fillTypeMaterial)\n                                else\n                                        Logging.xmlWarning(xmlFile, "Diffuse texture \'%s\' not found in \'%s\'" , diffuse, materialKey)\n                                    end\n                                else\n                                        Logging.xmlWarning(xmlFile, "Missing diffuse texture for fill type \'%s\' in \'%s\'" , fillTypeName, materialKey)\n                                        end\n                                    else\n                                            Logging.xmlWarning(xmlFile, "Missing node or ref node or materialSlotName in \'%s\'" , materialKey)\n                                        end\n                                    else\n                                            Logging.xmlWarning(xmlFile, "Unknown fill type \'%s\' in \'%s\'" , fillTypeName, materialKey)\n                                        end\n                                    else\n                                            Logging.xmlWarning(xmlFile, "Missing fill type in \'%s\'" , materialKey)\n                                        end\n                                    end )\n\n                                    return fillTypeMaterials\n                                end\n\n'})}),"\n",(0,t.jsx)(n.h3,{id:"loadfillunitfromxml",children:"loadFillUnitFromXML"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Description"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Definition"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"loadFillUnitFromXML()"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"any"}),(0,t.jsx)(n.th,{children:"xmlFile"})]})}),(0,t.jsxs)(n.tbody,{children:[(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"any"}),(0,t.jsx)(n.td,{children:"key"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"any"}),(0,t.jsx)(n.td,{children:"entry"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"any"}),(0,t.jsx)(n.td,{children:"index"})]})]})]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Code"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:'function FillUnit:loadFillUnitFromXML(xmlFile, key, entry, index)\n    local spec = self.spec_fillUnit\n\n    entry.fillUnitIndex = index\n    entry.capacity = xmlFile:getValue(key .. "#capacity" , math.huge)\n    entry.defaultCapacity = entry.capacity\n    entry.updateMass = xmlFile:getValue(key .. "#updateMass" , true )\n    entry.canBeUnloaded = xmlFile:getValue(key .. "#canBeUnloaded" , true )\n    entry.allowFoldingThreshold = xmlFile:getValue(key .. "#allowFoldingThreshold" )\n    local allowFoldingFillTypeName = xmlFile:getValue(key .. "#allowFoldingFillType" )\n    if allowFoldingFillTypeName ~ = nil then\n        local allowFoldingFillTypeIndex = g_fillTypeManager:getFillTypeIndexByName(allowFoldingFillTypeName)\n        if allowFoldingFillTypeIndex ~ = nil then\n            entry.allowFoldingFillType = allowFoldingFillTypeIndex\n        else\n                Logging.xmlWarning( self.xmlFile, "Invalid fill type for fill unit in \'%s\'" , allowFoldingFillTypeName, key .. "#allowFoldingFillType" )\n                end\n            end\n            entry.needsSaving = true\n\n            entry.fillLevel = 0\n            entry.fillLevelSent = 0\n\n            entry.fillType = FillType.UNKNOWN\n            entry.fillTypeSent = FillType.UNKNOWN\n            entry.fillTypeToDisplay = FillType.UNKNOWN\n            entry.fillLevelToDisplay = nil\n            entry.capacityToDisplay = nil\n\n            entry.lastValidFillType = FillType.UNKNOWN\n            entry.lastValidFillTypeSent = FillType.UNKNOWN\n\n            if xmlFile:hasProperty(key .. ".exactFillRootNode" ) then\n                XMLUtil.checkDeprecatedXMLElements(xmlFile, key .. ".exactFillRootNode#index" , key .. ".exactFillRootNode#node" ) --FS17 to FS19\n\n                entry.exactFillRootNode = xmlFile:getValue(key .. ".exactFillRootNode#node" , nil , self.components, self.i3dMappings)\n                if entry.exactFillRootNode ~ = nil then\n                    if not CollisionFlag.getHasGroupFlagSet(entry.exactFillRootNode, CollisionFlag.FILLABLE) then\n                        Logging.xmlWarning( self.xmlFile, "Missing collision group %s.Please add this bit to exact fill root node \'%s\' collision filter group in \'%s\'" , CollisionFlag.getBitAndName(CollisionFlag.FILLABLE), getName(entry.exactFillRootNode), key)\n                    else\n                            spec.exactFillRootNodeToFillUnit[entry.exactFillRootNode] = entry\n                            spec.exactFillRootNodeToExtraDistance[entry.exactFillRootNode] = xmlFile:getValue(key .. ".exactFillRootNode#extraEffectDistance" , 0 )\n                            spec.hasExactFillRootNodes = true\n\n                            g_currentMission:addNodeObject(entry.exactFillRootNode, self )\n                        end\n                    else\n                            Logging.xmlWarning( self.xmlFile, "ExactFillRootNode not found for fillUnit \'%s\'!" , key)\n                            end\n                        end\n\n                        XMLUtil.checkDeprecatedXMLElements(xmlFile, key .. ".autoAimTargetNode#index" , key .. ".autoAimTargetNode#node" ) --FS17 to FS19\n\n                        entry.autoAimTarget = { }\n                        entry.autoAimTarget.node = xmlFile:getValue(key .. ".autoAimTargetNode#node" , nil , self.components, self.i3dMappings)\n                        if entry.autoAimTarget.node ~ = nil then\n                            entry.autoAimTarget.baseTrans = { getTranslation(entry.autoAimTarget.node) }\n                            entry.autoAimTarget.startZ = xmlFile:getValue( key .. ".autoAimTargetNode#startZ" )\n                            entry.autoAimTarget.endZ = xmlFile:getValue( key .. ".autoAimTargetNode#endZ" )\n                            entry.autoAimTarget.startPercentage = xmlFile:getValue( key .. ".autoAimTargetNode#startPercentage" , 25 ) / 100\n                            entry.autoAimTarget.invert = xmlFile:getValue( key .. ".autoAimTargetNode#invert" , false )\n                            if entry.autoAimTarget.startZ ~ = nil and entry.autoAimTarget.endZ ~ = nil then\n                                local startZ = entry.autoAimTarget.startZ\n                                if entry.autoAimTarget.invert then\n                                    startZ = entry.autoAimTarget.endZ\n                                end\n\n                                setTranslation(entry.autoAimTarget.node, entry.autoAimTarget.baseTrans[ 1 ], entry.autoAimTarget.baseTrans[ 2 ], startZ)\n                            end\n                        end\n\n                        entry.supportedFillTypes = { }\n                        local fillTypes\n                        local fillTypeCategories = xmlFile:getValue(key .. "#fillTypeCategories" )\n                        local fillTypeNames = xmlFile:getValue(key .. "#fillTypes" )\n                        if fillTypeCategories ~ = nil and fillTypeNames = = nil then\n                            fillTypes = g_fillTypeManager:getFillTypesByCategoryNames(fillTypeCategories, "Warning: \'" .. self.configFileName .. "\' has invalid fillTypeCategory \'%s\'." )\n                        elseif fillTypeCategories = = nil and fillTypeNames ~ = nil then\n                                fillTypes = g_fillTypeManager:getFillTypesByNames(fillTypeNames, "Warning: \'" .. self.configFileName .. "\' has invalid fillType \'%s\'." )\n                            else\n                                    Logging.xmlWarning( self.xmlFile, "Missing \'fillTypeCategories\' or \'fillTypes\' for fillUnit \'%s\'" , key)\n                                        return false\n                                    end\n\n                                    if fillTypes ~ = nil then\n                                        for _,fillType in pairs(fillTypes) do\n                                            entry.supportedFillTypes[fillType] = true\n                                        end\n                                    end\n\n                                    entry.supportedToolTypes = { }\n                                    for i = 1 , g_toolTypeManager:getNumberOfToolTypes() do\n                                        entry.supportedToolTypes[i] = true\n                                    end\n\n                                    local startFillLevel = xmlFile:getValue(key .. "#startFillLevel" )\n                                    local startFillTypeStr = xmlFile:getValue(key .. "#startFillType" )\n                                    if startFillTypeStr ~ = nil then\n                                        local startFillTypeIndex = g_fillTypeManager:getFillTypeIndexByName(startFillTypeStr)\n                                        if startFillTypeIndex ~ = nil then\n                                            entry.startFillLevel = startFillLevel\n                                            entry.startFillTypeIndex = startFillTypeIndex\n                                        end\n                                    end\n\n                                    entry.fillRootNode = xmlFile:getValue(key .. ".fillRootNode#node" , nil , self.components, self.i3dMappings)\n                                    if entry.fillRootNode = = nil then\n                                        entry.fillRootNode = self.components[ 1 ].node\n                                    end\n\n                                    entry.fillMassNode = xmlFile:getValue(key .. ".fillMassNode#node" , nil , self.components, self.i3dMappings)\n                                    local updateFillLevelMass = xmlFile:getValue(key .. "#updateFillLevelMass" , true )\n                                    if entry.fillMassNode = = nil and updateFillLevelMass then\n                                        entry.fillMassNode = self.components[ 1 ].node\n                                    end\n\n                                    entry.ignoreFillLimit = xmlFile:getValue(key .. "#ignoreFillLimit" , false )\n\n                                    -- mp sync info\n                                    entry.synchronizeFillLevel = xmlFile:getValue(key .. "#synchronizeFillLevel" , true )\n                                    entry.synchronizeFullFillLevel = xmlFile:getValue(key .. "#synchronizeFullFillLevel" , false )\n\n                                    local defaultBits = 16\n                                    for startCapacity, bits in pairs( FillUnit.CAPACITY_TO_NETWORK_BITS) do\n                                        if entry.capacity > = startCapacity then\n                                            defaultBits = bits\n                                        end\n                                    end\n\n                                    entry.synchronizationNumBits = xmlFile:getValue(key .. "#synchronizationNumBits" , defaultBits)\n\n                                    entry.showOnHud = xmlFile:getValue(key .. "#showOnHud" , true )\n                                    entry.showOnInfoHud = xmlFile:getValue(key .. "#showOnInfoHud" , true )\n                                    entry.uiPrecision = xmlFile:getValue(key .. "#uiPrecision" , 0 )\n                                    entry.uiCustomFillTypeName = xmlFile:getValue(key .. "#uiCustomFillTypeName" , nil , self.customEnvironment, false )\n                                    entry.uiExtraInfoText = xmlFile:getValue(key .. "#uiExtraInfoText" , nil , self.customEnvironment, false )\n                                    entry.uiDisplayTypeId = FillLevelsDisplay [ "TYPE_" .. xmlFile:getValue(key .. "#uiDisplayType" , "BAR" )] or FillLevelsDisplay.TYPE_BAR\n                                    local unitText = xmlFile:getValue(key .. "#unitTextOverride" )\n                                    if unitText ~ = nil then\n                                        entry.unitText = g_i18n:convertText(unitText)\n                                    end\n                                    entry.parentUnitOnHud = nil\n                                    entry.childUnitOnHud = nil\n                                    entry.blocksAutomatedTrainTravel = xmlFile:getValue(key .. "#blocksAutomatedTrainTravel" , false )\n\n                                    entry.fillAnimation = xmlFile:getValue(key .. "#fillAnimation" )\n                                    entry.fillAnimationLoadTime = xmlFile:getValue(key .. "#fillAnimationLoadTime" )\n                                    entry.fillAnimationEmptyTime = xmlFile:getValue(key .. "#fillAnimationEmptyTime" )\n\n                                    entry.fillLevelAnimations = { }\n                                    for _, key in xmlFile:iterator(key .. ".fillLevelAnimation" ) do\n                                        local fillLevelAnimation = { }\n                                        fillLevelAnimation.name = xmlFile:getValue(key .. "#name" )\n                                        if fillLevelAnimation.name ~ = nil then\n                                            fillLevelAnimation.resetOnEmpty = xmlFile:getValue(key .. "#resetOnEmpty" , true )\n                                            fillLevelAnimation.updateWhileFilled = xmlFile:getValue(key .. "#updateWhileFilled" , true )\n                                            fillLevelAnimation.useMaxStateIfEmpty = xmlFile:getValue(key .. "#useMaxStateIfEmpty" , false )\n\n                                            table.insert(entry.fillLevelAnimations, fillLevelAnimation)\n                                        else\n                                                Logging.xmlWarning(xmlFile, "Missing \'name\' for fillLevelAnimation \'%s\'" , key)\n                                                end\n                                            end\n\n                                            --\n                                            if self.isClient then\n                                                entry.alarmTriggers = { }\n                                                local i = 0\n                                                while true do\n                                                    local nodeKey = key .. string.format( ".alarmTriggers.alarmTrigger(%d)" , i)\n                                                    if not xmlFile:hasProperty(nodeKey) then\n                                                        break\n                                                    end\n                                                    local alarmTrigger = { }\n                                                    if self:loadAlarmTrigger(xmlFile, nodeKey, alarmTrigger, entry) then\n                                                        table.insert(entry.alarmTriggers, alarmTrigger)\n                                                    end\n                                                    i = i + 1\n                                                end\n\n                                                entry.measurementNodes = { }\n                                                i = 0\n                                                while true do\n                                                    local nodeKey = key .. string.format( ".measurementNodes.measurementNode(%d)" , i)\n                                                    if not xmlFile:hasProperty(nodeKey) then\n                                                        break\n                                                    end\n\n                                                    local measurementNode = { }\n                                                    if self:loadMeasurementNode(xmlFile, nodeKey, measurementNode) then\n                                                        table.insert(entry.measurementNodes, measurementNode)\n                                                    end\n\n                                                    i = i + 1\n                                                end\n\n                                                entry.fillPlane = { }\n                                                entry.lastFillPlaneType = nil\n                                                if not self:loadFillPlane(xmlFile, key .. ".fillPlane" , entry.fillPlane, entry) then\n                                                    entry.fillPlane = nil\n                                                end\n\n                                                entry.fillTypeMaterials = self:loadFillTypeMaterials(xmlFile, key)\n\n                                                entry.fillEffects = g_effectManager:loadEffect(xmlFile, key .. ".fillEffect" , self.components, self , self.i3dMappings)\n                                                entry.animationNodes = g_animationManager:loadAnimations(xmlFile, key .. ".animationNodes" , self.components, self , self.i3dMappings)\n\n                                                XMLUtil.checkDeprecatedXMLElements(xmlFile, key .. ".fillLevelHud" , key .. ".dashboard" ) --FS17 to FS19\n\n                                                entry.hasDashboards = false\n\n                                                if self.registerDashboardValueType ~ = nil then\n                                                    local fillUnitLoadFunc = function ( self , xmlFile, key, dashboard, isActive)\n                                                        local fillTypeName = xmlFile:getValue(key .. "#fillType" )\n                                                        if fillTypeName ~ = nil then\n                                                            local fillTypeIndex = g_fillTypeManager:getFillTypeIndexByName(fillTypeName)\n                                                            if fillTypeIndex ~ = nil then\n                                                                for _, fillUnit in ipairs(spec.fillUnits) do\n                                                                    if fillUnit.supportedFillTypes[fillTypeIndex] then\n                                                                        dashboard.fillUnit = fillUnit\n                                                                    end\n                                                                end\n                                                            end\n                                                        end\n\n                                                        local fillUnitIndex = xmlFile:getValue(key .. "#fillUnitIndex" )\n                                                        if fillUnitIndex ~ = nil then\n                                                            dashboard.fillUnit = spec.fillUnits[fillUnitIndex]\n                                                        end\n\n                                                        if dashboard.fillUnit ~ = nil then\n                                                            dashboard.fillUnit.hasDashboards = true\n                                                        else\n                                                                entry.hasDashboards = true\n                                                            end\n\n                                                            return true\n                                                        end\n\n                                                        local fillUnitLoadFuncWarning = function ( self , xmlFile, key, dashboard, isActive)\n                                                            fillUnitLoadFunc( self , xmlFile, key, dashboard, isActive)\n\n                                                            return Dashboard.warningAttributes( self , xmlFile, key, dashboard, isActive)\n                                                        end\n\n                                                        local fillLevel = DashboardValueType.new( "fillUnit" , "fillLevel" )\n                                                        fillLevel:setXMLKey(key)\n                                                        fillLevel:setValue(entry, function (_fillUnit, dashboard)\n                                                            return(dashboard.fillUnit or _fillUnit).fillLevel\n                                                        end )\n                                                        fillLevel:setRange( 0 , function (_fillUnit, dashboard)\n                                                            return(dashboard.fillUnit or _fillUnit).capacity\n                                                        end )\n                                                        fillLevel:setInterpolationSpeed( function (_fillUnit, dashboard)\n                                                            return(dashboard.fillUnit or _fillUnit).capacity * 0.001\n                                                        end )\n                                                        fillLevel:setAdditionalFunctions(fillUnitLoadFunc, nil )\n                                                        fillLevel:setPollUpdate( false )\n                                                        self:registerDashboardValueType(fillLevel)\n\n                                                        local fillLevelPct = DashboardValueType.new( "fillUnit" , "fillLevelPct" )\n                                                        fillLevelPct:setXMLKey(key)\n                                                        fillLevelPct:setValue(entry, function (_fillUnit, dashboard)\n                                                            _fillUnit = dashboard.fillUnit or _fillUnit\n                                                            return math.clamp(_fillUnit.fillLevel / _fillUnit.capacity, 0 , 1 ) * 100\n                                                        end )\n                                                        fillLevelPct:setRange( 0 , 100 )\n                                                        fillLevelPct:setInterpolationSpeed( 100 * 0.001 )\n                                                        fillLevelPct:setAdditionalFunctions(fillUnitLoadFunc, nil )\n                                                        fillLevelPct:setPollUpdate( false )\n                                                        self:registerDashboardValueType(fillLevelPct)\n\n                                                        local fillLevelWarning = DashboardValueType.new( "fillUnit" , "fillLevelWarning" )\n                                                        fillLevelWarning:setXMLKey(key)\n                                                        fillLevelWarning:setValue(entry, function (_fillUnit, dashboard)\n                                                            local fillLevel = (dashboard.fillUnit or _fillUnit).fillLevel\n                                                            return fillLevel > dashboard.warningThresholdMin and fillLevel < dashboard.warningThresholdMax\n                                                        end )\n                                                        fillLevelWarning:setAdditionalFunctions(fillUnitLoadFuncWarning)\n                                                        fillLevelWarning:setPollUpdate( false )\n                                                        self:registerDashboardValueType(fillLevelWarning)\n                                                    end\n                                                end\n\n                                                return true\n                                            end\n\n'})}),"\n",(0,t.jsx)(n.h3,{id:"loadfillunitunloadingfromxml",children:"loadFillUnitUnloadingFromXML"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Description"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Definition"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"loadFillUnitUnloadingFromXML()"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"any"}),(0,t.jsx)(n.th,{children:"xmlFile"})]})}),(0,t.jsxs)(n.tbody,{children:[(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"any"}),(0,t.jsx)(n.td,{children:"key"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"any"}),(0,t.jsx)(n.td,{children:"entry"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"any"}),(0,t.jsx)(n.td,{children:"index"})]})]})]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Code"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:'function FillUnit:loadFillUnitUnloadingFromXML(xmlFile, key, entry, index)\n    entry.node = xmlFile:getValue(key .. "#node" , self.rootNode, self.components, self.i3dMappings)\n    entry.width = xmlFile:getValue(key .. "#width" , 15 )\n    entry.offset = xmlFile:getValue(key .. "#offset" , "0 0 0" , true )\n\n    return true\nend\n\n'})}),"\n",(0,t.jsx)(n.h3,{id:"loadlevelernodefromxml",children:"loadLevelerNodeFromXML"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Description"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Definition"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"loadLevelerNodeFromXML()"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"any"}),(0,t.jsx)(n.th,{children:"superFunc"})]})}),(0,t.jsxs)(n.tbody,{children:[(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"any"}),(0,t.jsx)(n.td,{children:"levelerNode"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"any"}),(0,t.jsx)(n.td,{children:"xmlFile"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"any"}),(0,t.jsx)(n.td,{children:"key"})]})]})]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Code"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:'function FillUnit:loadLevelerNodeFromXML(superFunc, levelerNode, xmlFile, key)\n    levelerNode.limitFillUnitIndex = xmlFile:getValue(key .. "#fillUnitIndex" , 1 )\n    levelerNode.minFillLevel = xmlFile:getValue(key .. "#minFillLevel" , 0 )\n    levelerNode.maxFillLevel = xmlFile:getValue(key .. "#maxFillLevel" , 1 )\n\n    return superFunc( self , levelerNode, xmlFile, key)\nend\n\n'})}),"\n",(0,t.jsx)(n.h3,{id:"loadmeasurementnode",children:"loadMeasurementNode"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Description"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Definition"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"loadMeasurementNode()"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"any"}),(0,t.jsx)(n.th,{children:"xmlFile"})]})}),(0,t.jsxs)(n.tbody,{children:[(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"any"}),(0,t.jsx)(n.td,{children:"key"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"any"}),(0,t.jsx)(n.td,{children:"entry"})]})]})]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Code"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:'function FillUnit:loadMeasurementNode(xmlFile, key, entry)\n    XMLUtil.checkDeprecatedXMLElements(xmlFile, key .. "#index" , key .. "#node" )\n\n    local node = xmlFile:getValue(key .. "#node" , nil , self.components, self.i3dMappings)\n    if node = = nil then\n        Logging.xmlWarning( self.xmlFile, "Missing \'node\' for measurementNode \'%s\'" , key)\n            return false\n        end\n        entry.node = node\n        entry.measurementTime = 0\n        entry.intensity = 0\n\n        return true\n    end\n\n'})}),"\n",(0,t.jsx)(n.h3,{id:"loadmovingtoolfromxml",children:"loadMovingToolFromXML"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Description"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Definition"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"loadMovingToolFromXML()"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"any"}),(0,t.jsx)(n.th,{children:"superFunc"})]})}),(0,t.jsxs)(n.tbody,{children:[(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"any"}),(0,t.jsx)(n.td,{children:"xmlFile"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"any"}),(0,t.jsx)(n.td,{children:"key"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"any"}),(0,t.jsx)(n.td,{children:"entry"})]})]})]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Code"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:'function FillUnit:loadMovingToolFromXML(superFunc, xmlFile, key, entry)\n    if not superFunc( self , xmlFile, key, entry) then\n        return false\n    end\n\n    entry.fillUnitIndex = xmlFile:getValue(key .. "#fillUnitIndex" )\n    entry.minFillLevel = xmlFile:getValue(key .. "#minFillLevel" )\n    entry.maxFillLevel = xmlFile:getValue(key .. "#maxFillLevel" )\n\n    return true\nend\n\n'})}),"\n",(0,t.jsx)(n.h3,{id:"loadspecvaluecapacity",children:"loadSpecValueCapacity"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Description"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Definition"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"loadSpecValueCapacity()"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"any"}),(0,t.jsx)(n.th,{children:"xmlFile"})]})}),(0,t.jsxs)(n.tbody,{children:[(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"any"}),(0,t.jsx)(n.td,{children:"customEnvironment"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"any"}),(0,t.jsx)(n.td,{children:"baseDir"})]})]})]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Code"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:'function FillUnit.loadSpecValueCapacity(xmlFile, customEnvironment, baseDir)\n    -- check if #unitText or #unit was set and convert capacity, liters otherwise\n        local function getUnitCapacityAndText(fillUnitKey, capacity)\n            local unitText = xmlFile:getValue(fillUnitKey .. "#unitTextOverride" )\n            if unitText = = nil then\n                local unitId = xmlFile:getValue(fillUnitKey .. "#shopDisplayUnit" )\n                local convFuncAndL10n = FillUnit.UNIT[unitId]\n                if unitId ~ = nil and convFuncAndL10n = = nil then\n                    Logging.xmlWarning(xmlFile, "Unit \'%s\' is not defined in fillUnit \'%s\'.Available units: %s.Using LITER as default" , unitId, fillUnitKey, table.concatKeys( FillUnit.UNIT, " " ))\n                end\n                convFuncAndL10n = convFuncAndL10n or FillUnit.UNIT[ "LITER" ]\n                return convFuncAndL10n.conversionFunc(capacity), convFuncAndL10n.l10n, convFuncAndL10n.conversionFunc\n            end\n            return capacity, unitText\n        end\n\n        local rootName = xmlFile:getRootName()\n        local fillUnitConfigurations = { }\n\n        XMLUtil.checkDeprecatedXMLElements(xmlFile, rootName .. ".storeData.specs.capacity#unit" , rootName .. ".storeData.specs.capacity#unitTextOverride" ) --FS19 to FS22\n\n        local overwrittenCapacity = xmlFile:getValue(rootName .. ".storeData.specs.capacity" )\n        local overwrittenUnitText\n        local conversionFunc\n\n        if overwrittenCapacity ~ = nil then\n            overwrittenCapacity, overwrittenUnitText, conversionFunc = getUnitCapacityAndText(rootName .. ".storeData.specs.capacity" , overwrittenCapacity)\n        end\n\n        if overwrittenCapacity ~ = nil and overwrittenUnitText ~ = nil then\n            table.insert(fillUnitConfigurations, { isSelectable = true , fillUnits = { { capacity = overwrittenCapacity, unit = overwrittenUnitText, conversionFunc = conversionFunc } } } )\n            return fillUnitConfigurations\n        end\n\n        xmlFile:iterate(rootName .. ".fillUnit.fillUnitConfigurations.fillUnitConfiguration" , function (_, key)\n            local fillUnitConfiguration = { }\n            fillUnitConfiguration.isSelectable = xmlFile:getValue(key .. "#isSelectable" , true )\n            fillUnitConfiguration.fillUnits = { }\n\n            xmlFile:iterate(key .. ".fillUnits.fillUnit" , function (fillUnitIndex, fillUnitKey)\n\n                XMLUtil.checkDeprecatedXMLElements(xmlFile, fillUnitKey .. "#unit" , fillUnitKey .. "#unitTextOverride" ) --FS19 to FS22\n\n                if xmlFile:getValue(fillUnitKey .. "#showCapacityInShop" ) ~ = false and xmlFile:getValue(fillUnitKey .. "#showInShop" ) ~ = false then\n                    local capacity = xmlFile:getValue(fillUnitKey .. "#capacity" ) or 0\n                    local unitText\n\n                    capacity, unitText, conversionFunc = getUnitCapacityAndText(fillUnitKey, capacity)\n\n                    table.insert(fillUnitConfiguration.fillUnits, { capacity = capacity, unit = unitText, conversionFunc = conversionFunc, fillUnitIndex = fillUnitIndex } )\n                end\n            end )\n\n            table.insert(fillUnitConfigurations, fillUnitConfiguration)\n        end )\n\n        if #fillUnitConfigurations > 0 then\n            return fillUnitConfigurations\n        end\n\n        return nil\n    end\n\n'})}),"\n",(0,t.jsx)(n.h3,{id:"loadspecvaluefilltypes",children:"loadSpecValueFillTypes"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Description"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Definition"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"loadSpecValueFillTypes()"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"any"}),(0,t.jsx)(n.th,{children:"xmlFile"})]})}),(0,t.jsxs)(n.tbody,{children:[(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"any"}),(0,t.jsx)(n.td,{children:"customEnvironment"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"any"}),(0,t.jsx)(n.td,{children:"baseDir"})]})]})]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Code"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:'function FillUnit.loadSpecValueFillTypes(xmlFile, customEnvironment, baseDir)\n    local fillTypeNames = nil\n    local fillTypeCategoryNames = nil\n    local fillTypes = nil\n    local fruitTypeNames = nil\n    local fillTypesByConfiguration = { }\n\n    local rootName = xmlFile:getRootName()\n\n    XMLUtil.checkDeprecatedXMLElements(xmlFile, rootName .. ".fillTypes" , rootName .. ".cutter#fruitTypes" ) --FS19 to FS21\n    XMLUtil.checkDeprecatedXMLElements(xmlFile, rootName .. ".fruitTypes" , rootName .. ".storeData.specs.fillTypes" ) --FS19 to FS21\n    XMLUtil.checkDeprecatedXMLElements(xmlFile, rootName .. ".fillTypeCategories" , rootName .. ".storeData.specs.fillTypeCategories" ) --FS19 to FS21\n\n    -- get fill types of all configurations and all fill units to display all possible fill types\n    local i = 0\n    while true do\n        local key = string.format(rootName .. ".fillUnit.fillUnitConfigurations.fillUnitConfiguration(%d)" , i)\n        if not xmlFile:hasProperty(key) then\n            break\n        end\n\n        local j = 0\n        while true do\n            local unitKey = string.format(key .. ".fillUnits.fillUnit(%d)" , j)\n            if not xmlFile:hasProperty(unitKey) then\n                break\n            end\n\n            local showInShop = xmlFile:getValue(unitKey .. "#showInShop" )\n            local capacity = xmlFile:getValue(unitKey .. "#capacity" )\n            if (showInShop = = nil or showInShop) and(capacity = = nil or capacity > 0 ) then\n                local currentFillTypes = xmlFile:getValue(unitKey .. "#fillTypes" )\n                if currentFillTypes ~ = nil then\n                    if fillTypeNames = = nil then\n                        fillTypeNames = currentFillTypes\n                    else\n                            fillTypeNames = fillTypeNames .. " " .. currentFillTypes\n                        end\n                    end\n\n                    local currentFillTypeCategories = xmlFile:getValue(unitKey .. "#fillTypeCategories" )\n                    if currentFillTypeCategories ~ = nil then\n                        if fillTypeCategoryNames = = nil then\n                            fillTypeCategoryNames = currentFillTypeCategories\n                        else\n                                fillTypeCategoryNames = fillTypeCategoryNames .. " " .. currentFillTypeCategories\n                            end\n                        end\n\n                        fillTypesByConfiguration[i + 1 ] = { fillTypeNames = currentFillTypes, categoryNames = currentFillTypeCategories }\n                    end\n\n                    j = j + 1\n                end\n\n                i = i + 1\n            end\n\n            local overwrittenFillTypeNames = xmlFile:getValue(rootName .. ".storeData.specs.fillTypes" )\n            if overwrittenFillTypeNames ~ = nil then\n                fillTypeNames = overwrittenFillTypeNames\n                fillTypeCategoryNames = nil\n            end\n\n            if fillTypes = = nil then\n                fruitTypeNames = xmlFile:getValue(rootName .. ".storeData.specs.fruitTypes" )\n\n                if fruitTypeNames = = nil then\n                    fruitTypeNames = xmlFile:getValue(rootName .. ".cutter#fruitTypes" )\n                end\n            end\n\n            local fruitTypeCategoryNames = xmlFile:getValue(rootName .. ".storeData.specs.fruitTypeCategories" )\n            if fruitTypeCategoryNames = = nil then\n                fruitTypeCategoryNames = xmlFile:getValue(rootName .. ".cutter#fruitTypeCategories" )\n            end\n\n            local windrowFillTypes = nil\n            local fillTypeConverterName = xmlFile:getValue(rootName .. ".cutter#fillTypeConverter" )\n            if fillTypeConverterName ~ = nil then\n                local fillTypeConverter = g_fillTypeManager:getConverterDataByName(fillTypeConverterName)\n                if fillTypeConverter ~ = nil then\n                    windrowFillTypes = { }\n                    for sourceFillTypeIndex, _ in pairs(fillTypeConverter) do\n                        table.insert(windrowFillTypes, sourceFillTypeIndex)\n                    end\n\n                    table.sort(windrowFillTypes)\n                end\n            end\n\n            fillTypeCategoryNames = xmlFile:getValue(rootName .. ".storeData.specs.fillTypeCategories" , fillTypeCategoryNames)\n\n            return { categoryNames = fillTypeCategoryNames, fillTypeNames = fillTypeNames, fruitTypeNames = fruitTypeNames, fruitTypeCategoryNames = fruitTypeCategoryNames, windrowFillTypes = windrowFillTypes, fillTypesByConfiguration = fillTypesByConfiguration }\n        end\n\n'})}),"\n",(0,t.jsx)(n.h3,{id:"loadspecvaluefillunitmassdata",children:"loadSpecValueFillUnitMassData"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Description"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Definition"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"loadSpecValueFillUnitMassData()"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"any"}),(0,t.jsx)(n.th,{children:"xmlFile"})]})}),(0,t.jsxs)(n.tbody,{children:[(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"any"}),(0,t.jsx)(n.td,{children:"customEnvironment"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"any"}),(0,t.jsx)(n.td,{children:"baseDir"})]})]})]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Code"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:'function FillUnit.loadSpecValueFillUnitMassData(xmlFile, customEnvironment, baseDir)\n    local fillUnitMassData = { }\n    xmlFile:iterate( "vehicle.motorized.consumerConfigurations.consumerConfiguration(0).consumer" , function (index, key)\n        local fillUnitIndex = xmlFile:getValue(key .. "#fillUnitIndex" , 0 )\n        if fillUnitIndex ~ = 0 then\n            local capacity = xmlFile:getValue(key .. "#capacity" )\n\n            local unitKey = string.format( "vehicle.fillUnit.fillUnitConfigurations.fillUnitConfiguration(0).fillUnits.fillUnit(%d)" , fillUnitIndex - 1 )\n\n            local fillTypeCategories = xmlFile:getValue(unitKey .. "#fillTypeCategories" )\n            local fillTypes = xmlFile:getValue(unitKey .. "#fillTypes" )\n            if capacity = = nil then\n                capacity = xmlFile:getValue(unitKey .. "#capacity" , 0 )\n            end\n\n            if capacity > 0 then\n                table.insert(fillUnitMassData, { fillTypeCategories = fillTypeCategories, fillTypes = fillTypes, capacity = capacity } )\n            end\n        end\n    end )\n\n    xmlFile:iterate( "vehicle.fillUnit.fillUnitConfigurations.fillUnitConfiguration(0).fillUnits.fillUnit" , function (index, key)\n        local startFillLevel = xmlFile:getValue(key .. "#startFillLevel" , 0 )\n        if startFillLevel > 0 then\n            local startFillType = xmlFile:getValue(key .. "#startFillType" )\n            table.insert(fillUnitMassData, { fillType = startFillType, capacity = startFillLevel } )\n        end\n    end )\n\n    return fillUnitMassData\nend\n\n'})}),"\n",(0,t.jsx)(n.h3,{id:"ondeactivate",children:"onDeactivate"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Description"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Definition"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"onDeactivate()"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Code"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:"function FillUnit:onDeactivate()\n    local spec = self.spec_fillUnit\n    if spec.fillTrigger.isFilling then\n        self:setFillUnitIsFilling( false , true )\n    end\n\n    for _, fillUnit in pairs(spec.fillUnits) do\n        self:updateMeasurementNodes(fillUnit, 0 , false , 0 )\n    end\nend\n\n"})}),"\n",(0,t.jsx)(n.h3,{id:"ondelete",children:"onDelete"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Description"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Definition"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"onDelete()"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Code"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:"function FillUnit:onDelete()\n    local spec = self.spec_fillUnit\n\n    if spec.fillTrigger ~ = nil then\n        g_currentMission.activatableObjectsSystem:removeActivatable(spec.fillTrigger.activatable)\n        for _, trigger in pairs(spec.fillTrigger.triggers) do\n            trigger:onVehicleDeleted( self )\n        end\n        spec.fillTrigger.currentTrigger = nil\n        spec.fillTrigger.selectedTrigger = nil\n    end\n\n    if spec.fillUnits ~ = nil then\n        for _, fillUnit in ipairs(spec.fillUnits) do\n            for _, alarmTrigger in ipairs(fillUnit.alarmTriggers) do\n                g_soundManager:deleteSample(alarmTrigger.sample)\n\n                for _, beaconLight in ipairs(alarmTrigger.beaconLights) do\n                    beaconLight:delete()\n                end\n            end\n\n            g_effectManager:deleteEffects(fillUnit.fillEffects)\n            g_animationManager:deleteAnimations(fillUnit.animationNodes)\n\n            if fillUnit.exactFillRootNode ~ = nil then\n                g_currentMission:removeNodeObject(fillUnit.exactFillRootNode)\n            end\n        end\n    end\n\n    g_effectManager:deleteEffects(spec.fillEffects)\n    g_animationManager:deleteAnimations(spec.animationNodes)\n\n    if spec.samples ~ = nil then\n        g_soundManager:deleteSamples(spec.samples)\n        table.clear(spec.samples)\n    end\nend\n\n"})}),"\n",(0,t.jsx)(n.h3,{id:"ondischargetargetobjectchanged",children:"onDischargeTargetObjectChanged"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Description"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Definition"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"onDischargeTargetObjectChanged()"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,t.jsx)(n.table,{children:(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"any"}),(0,t.jsx)(n.th,{children:"dischargeObject"})]})})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Code"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:"function FillUnit:onDischargeTargetObjectChanged(dischargeObject)\n    -- update unloading action event in case we overlap with the overloading action\n    FillUnit.updateUnloadActionDisplay( self )\nend\n\n"})}),"\n",(0,t.jsx)(n.h3,{id:"ondraw",children:"onDraw"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Description"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Definition"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"onDraw()"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"any"}),(0,t.jsx)(n.th,{children:"isActiveForInput"})]})}),(0,t.jsxs)(n.tbody,{children:[(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"any"}),(0,t.jsx)(n.td,{children:"isActiveForInputIgnoreSelection"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"any"}),(0,t.jsx)(n.td,{children:"isSelected"})]})]})]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Code"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:"function FillUnit:onDraw(isActiveForInput, isActiveForInputIgnoreSelection, isSelected)\n    if self:getDrawFirstFillText() then\n        local spec = self.spec_fillUnit\n        g_currentMission:addExtraPrintText(spec.texts.firstFillTheTool)\n    end\nend\n\n"})}),"\n",(0,t.jsx)(n.h3,{id:"onload",children:"onLoad"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Description"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Definition"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"onLoad()"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,t.jsx)(n.table,{children:(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"any"}),(0,t.jsx)(n.th,{children:"savegame"})]})})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Code"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:'function FillUnit:onLoad(savegame)\n    local spec = self.spec_fillUnit\n\n    XMLUtil.checkDeprecatedXMLElements( self.xmlFile, "vehicle.measurementNodes.measurementNode" , "vehicle.fillUnit.fillUnitConfigurations.fillUnitConfiguration.fillUnits.fillUnit.measurementNodes.measurementNode" )\n    XMLUtil.checkDeprecatedXMLElements( self.xmlFile, "vehicle.fillPlanes.fillPlane" , "vehicle.fillUnit.fillUnitConfigurations.fillUnitConfiguration.fillUnits.fillUnit.fillPlane" )\n    XMLUtil.checkDeprecatedXMLElements( self.xmlFile, "vehicle.foldable.foldingParts#onlyFoldOnEmpty" , "vehicle.fillUnit#allowFoldingWhileFilled" )\n    XMLUtil.checkDeprecatedXMLElements( self.xmlFile, "vehicle.fillAutoAimTargetNode" , "vehicle.fillUnit.fillUnitConfigurations.fillUnitConfiguration.fillUnits.fillUnit.autoAimTargetNode" ) --FS17 to FS19\n\n    local fillUnitConfigurationId = Utils.getNoNil( self.configurations[ "fillUnit" ], 1 )\n    local baseKey = string.format( "vehicle.fillUnit.fillUnitConfigurations.fillUnitConfiguration(%d).fillUnits" , fillUnitConfigurationId - 1 )\n\n    spec.removeVehicleIfEmpty = self.xmlFile:getValue(baseKey .. "#removeVehicleIfEmpty" , false )\n    spec.removeVehicleThreshold = self.xmlFile:getValue(baseKey .. "#removeVehicleThreshold" , 0 )\n    spec.removeVehicleDelay = self.xmlFile:getValue(baseKey .. "#removeVehicleDelay" , 0 )\n    spec.removeVehicleReward = self.xmlFile:getValue(baseKey .. "#removeVehicleReward" , 0 )\n    spec.allowFoldingWhileFilled = self.xmlFile:getValue(baseKey .. "#allowFoldingWhileFilled" , true )\n    spec.resetFoldingWhileFilled = self.xmlFile:getValue(baseKey .. "#resetFoldingWhileFilled" , false )\n    spec.allowFoldingThreshold = self.xmlFile:getValue(baseKey .. "#allowFoldingThreshold" , 0.0001 )\n    spec.fillTypeChangeThreshold = self.xmlFile:getValue(baseKey .. "#fillTypeChangeThreshold" , 0.05 ) -- fill level percentage that still allows overriding with another fill type\n    spec.fillUnits = { }\n    spec.exactFillRootNodeToFillUnit = { }\n    spec.exactFillRootNodeToExtraDistance = { }\n    spec.exactFillRootNodeAimToUpdate = { }\n    spec.hasExactFillRootNodes = false\n    spec.activeAlarmTriggers = { }\n\n    spec.fillTrigger = { }\n    spec.fillTrigger.triggers = { }\n    spec.fillTrigger.activatable = FillActivatable.new( self )\n    spec.fillTrigger.isFilling = false\n    spec.fillTrigger.currentTrigger = nil -- trigger that is currently used for filling\n        spec.fillTrigger.selectedTrigger = nil -- currently used trigger no matter if filling or not\n            spec.fillTrigger.litersPerSecond = self.xmlFile:getValue(baseKey .. ".fillTrigger#litersPerSecond" , 200 )\n            spec.fillTrigger.consumePtoPower = self.xmlFile:getValue(baseKey .. ".fillTrigger#consumePtoPower" , false )\n\n            local i = 0\n            while true do\n                local key = string.format( "%s.fillUnit(%d)" , baseKey, i)\n                if not self.xmlFile:hasProperty(key) then\n                    break\n                end\n                local entry = { }\n\n                if self:loadFillUnitFromXML( self.xmlFile, key, entry, i + 1 ) then\n                    table.insert(spec.fillUnits, entry)\n                else\n                        Logging.xmlWarning( self.xmlFile, "Could not load fillUnit for \'%s\'" , key)\n                            self:setLoadingState(VehicleLoadingState.ERROR)\n                            break\n                        end\n\n                        i = i + 1\n                    end\n\n                    if self.xmlFile:hasProperty(baseKey .. ".unloading" ) then\n                        spec.unloading = { }\n                        self.xmlFile:iterate(baseKey .. ".unloading" , function (_, unloadingKey)\n                            local entry = { }\n\n                            if self:loadFillUnitUnloadingFromXML( self.xmlFile, unloadingKey, entry, i + 1 ) then\n                                table.insert(spec.unloading, entry)\n                                return\n                            else\n                                    Logging.xmlWarning( self.xmlFile, "Could not load unloading node for \'%s\'" , unloadingKey)\n                                        return false -- stop iteration\n                                    end\n                                end )\n                            end\n\n                            if self.isClient then\n                                spec.samples = { }\n                                spec.samples.fill = g_soundManager:loadSampleFromXML( self.xmlFile, "vehicle.fillUnit.sounds" , "fill" , self.baseDirectory, self.components, 0 , AudioGroup.VEHICLE, self.i3dMappings, self )\n\n                                spec.fillEffects = g_effectManager:loadEffect( self.xmlFile, baseKey .. ".fillEffect" , self.components, self , self.i3dMappings)\n                                spec.animationNodes = g_animationManager:loadAnimations( self.xmlFile, baseKey .. ".animationNodes" , self.components, self , self.i3dMappings)\n\n                                spec.activeFillEffects = { }\n                                spec.activeFillAnimations = { }\n                            end\n\n                            spec.texts = { }\n                            spec.texts.warningFoldingFilled = g_i18n:getText( "warning_foldingNotWhileFilled" )\n                            spec.texts.firstFillTheTool = g_i18n:getText( "info_firstFillTheTool" )\n                            spec.texts.unloadNoSpace = g_i18n:getText( "fillUnit_unload_nospace" )\n                            spec.texts.stopRefill = g_i18n:getText( "action_stopRefillingOBJECT" )\n                            spec.texts.startRefill = g_i18n:getText( "action_refillOBJECT" )\n\n                            spec.isInfoDirty = false\n                            spec.fillUnitInfos = { }\n\n                            spec.dirtyFlag = self:getNextDirtyFlag()\n                        end\n\n'})}),"\n",(0,t.jsx)(n.h3,{id:"onpostload",children:"onPostLoad"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Description"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Definition"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"onPostLoad()"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,t.jsx)(n.table,{children:(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"any"}),(0,t.jsx)(n.th,{children:"savegame"})]})})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Code"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:'function FillUnit:onPostLoad(savegame)\n    local spec = self.spec_fillUnit\n\n    if self.isServer then\n        -- fill units that do not have a start fill level will be only loaded from savegame if not reset and savegame available\n            local fillUnitsToLoad = { }\n            for i, fillUnit in ipairs(spec.fillUnits) do\n                if fillUnit.startFillLevel = = nil and fillUnit.startFillTypeIndex = = nil then\n                    fillUnitsToLoad[i] = fillUnit\n                end\n            end\n\n            -- if the fill units are not in the savegame we fill them also with the start fill level(e.g.on a new savegame)\n                if savegame ~ = nil and savegame.xmlFile:hasProperty(savegame.key .. ".fillUnit" ) then\n                    local i = 0\n                    local xmlFile = savegame.xmlFile\n                    while true do\n                        local key = string.format( "%s.fillUnit.unit(%d)" , savegame.key, i)\n                        if not xmlFile:hasProperty(key) then\n                            break\n                        end\n\n                        local fillUnitIndex = xmlFile:getValue(key .. "#index" )\n\n                        local allowLoading = fillUnitsToLoad[fillUnitIndex] = = nil or -- always load(fill unit with start fill level)\n                        (fillUnitsToLoad[fillUnitIndex] ~ = nil and( not savegame.resetVehicles or not self:getFillUnitEmptyOnReset())) -- only load if not reset(fill unit without start fill level)\n                            if allowLoading then\n                                local fillTypeName = xmlFile:getValue(key .. "#fillType" )\n                                local fillLevel = xmlFile:getValue(key .. "#fillLevel" )\n                                local fillTypeIndex = g_fillTypeManager:getFillTypeIndexByName(fillTypeName)\n                                self:addFillUnitFillLevel( self:getOwnerFarmId(), fillUnitIndex, fillLevel, fillTypeIndex, ToolType.UNDEFINED, nil )\n\n                                local fillUnit = spec.fillUnits[fillUnitIndex]\n                                if fillUnit ~ = nil then\n                                    for _, fillLevelAnimation in ipairs(fillUnit.fillLevelAnimations) do\n                                        AnimatedVehicle.updateAnimationByName( self , fillLevelAnimation.name, 9999999 , true )\n                                    end\n                                end\n                            end\n\n                            i = i + 1\n                        end\n                    else\n                            if not self.vehicleLoadingData:getCustomParameter( "spawnEmpty" ) then\n                                -- fill units that are filled by a start fill level are always loaded from the savegame(otherwise you could cheat if you reset the vehicle)\n                                    for fillUnitIndex, fillUnit in pairs(spec.fillUnits) do\n                                        if fillUnit.startFillLevel ~ = nil and fillUnit.startFillTypeIndex ~ = nil then\n                                            self:addFillUnitFillLevel( self:getOwnerFarmId(), fillUnitIndex, fillUnit.startFillLevel, fillUnit.startFillTypeIndex, ToolType.UNDEFINED, nil )\n\n                                            for _, fillLevelAnimation in ipairs(fillUnit.fillLevelAnimations) do\n                                                AnimatedVehicle.updateAnimationByName( self , fillLevelAnimation.name, 9999999 , true )\n                                            end\n                                        end\n                                    end\n                                end\n                            end\n\n                            for i, fillUnit in ipairs(spec.fillUnits) do\n                                self:updateAlarmTriggers(fillUnit.alarmTriggers)\n                            end\n                        end\n\n                        if #spec.fillUnits = = 0 then\n                            SpecializationUtil.removeEventListener( self , "onReadStream" , FillUnit )\n                            SpecializationUtil.removeEventListener( self , "onWriteStream" , FillUnit )\n                            SpecializationUtil.removeEventListener( self , "onReadUpdateStream" , FillUnit )\n                            SpecializationUtil.removeEventListener( self , "onWriteUpdateStream" , FillUnit )\n                            SpecializationUtil.removeEventListener( self , "onUpdateTick" , FillUnit )\n                            SpecializationUtil.removeEventListener( self , "onPostUpdate" , FillUnit )\n                            SpecializationUtil.removeEventListener( self , "onDraw" , FillUnit )\n                            SpecializationUtil.removeEventListener( self , "onDeactivate" , FillUnit )\n                            SpecializationUtil.removeEventListener( self , "onRegisterActionEvents" , FillUnit )\n                        end\n                    end\n\n'})}),"\n",(0,t.jsx)(n.h3,{id:"onpostupdate",children:"onPostUpdate"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Description"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"Called on post update"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Definition"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"onPostUpdate(float dt, boolean isActiveForInput, boolean isSelected, )"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"float"}),(0,t.jsx)(n.th,{children:"dt"}),(0,t.jsx)(n.th,{children:"time since last call in ms"})]})}),(0,t.jsxs)(n.tbody,{children:[(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"boolean"}),(0,t.jsx)(n.td,{children:"isActiveForInput"}),(0,t.jsx)(n.td,{children:"true if vehicle is active for input"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"boolean"}),(0,t.jsx)(n.td,{children:"isSelected"}),(0,t.jsx)(n.td,{children:"true if vehicle is selected"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"any"}),(0,t.jsx)(n.td,{children:"isSelected"}),(0,t.jsx)(n.td,{})]})]})]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Code"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:"function FillUnit:onPostUpdate(dt, isActiveForInput, isActiveForInputIgnoreSelection, isSelected)\n    local spec = self.spec_fillUnit\n    for vehicle, func in pairs(spec.exactFillRootNodeAimToUpdate) do\n        if not vehicle.isDeleted then\n            func(vehicle, dt)\n        end\n\n        spec.exactFillRootNodeAimToUpdate[vehicle] = nil\n    end\nend\n\n"})}),"\n",(0,t.jsx)(n.h3,{id:"onreadstream",children:"onReadStream"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Description"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Definition"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"onReadStream()"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"any"}),(0,t.jsx)(n.th,{children:"streamId"})]})}),(0,t.jsx)(n.tbody,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"any"}),(0,t.jsx)(n.td,{children:"connection"})]})})]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Code"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:"function FillUnit:onReadStream(streamId, connection)\n    if connection:getIsServer() then\n        local spec = self.spec_fillUnit\n\n        self:setFillUnitIsFilling(streamReadBool(streamId), true )\n\n        for i = 1 ,#spec.fillUnits do\n            if spec.fillUnits[i].synchronizeFillLevel then\n                local fillLevel = streamReadFloat32(streamId)\n                local fillType = streamReadUIntN(streamId, FillTypeManager.SEND_NUM_BITS)\n\n                self:addFillUnitFillLevel( self:getOwnerFarmId(), i, fillLevel, fillType, ToolType.UNDEFINED, nil )\n\n                local lastValidFillType = streamReadUIntN(streamId, FillTypeManager.SEND_NUM_BITS)\n                self:setFillUnitLastValidFillType(i, lastValidFillType, true )\n            end\n        end\n    end\nend\n\n"})}),"\n",(0,t.jsx)(n.h3,{id:"onreadupdatestream",children:"onReadUpdateStream"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Description"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Definition"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"onReadUpdateStream()"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"any"}),(0,t.jsx)(n.th,{children:"streamId"})]})}),(0,t.jsxs)(n.tbody,{children:[(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"any"}),(0,t.jsx)(n.td,{children:"timestamp"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"any"}),(0,t.jsx)(n.td,{children:"connection"})]})]})]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Code"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:"function FillUnit:onReadUpdateStream(streamId, timestamp, connection)\n    if connection:getIsServer() then\n        local spec = self.spec_fillUnit\n\n        if streamReadBool(streamId) then\n            for i = 1 ,#spec.fillUnits do\n                local fillUnit = spec.fillUnits[i]\n                if fillUnit.synchronizeFillLevel then\n                    local fillLevel\n                    if streamReadBool(streamId) then\n                        fillLevel = streamReadFloat32(streamId)\n                    else\n                            local maxValue = 2 ^ fillUnit.synchronizationNumBits - 1\n                            fillLevel = fillUnit.capacity * streamReadUIntN(streamId, fillUnit.synchronizationNumBits) / maxValue\n                        end\n\n                        local fillType = streamReadUIntN(streamId, FillTypeManager.SEND_NUM_BITS)\n                        if fillLevel ~ = fillUnit.fillLevel or fillType ~ = fillUnit.fillType then\n                            local oldFillType = self:getFillUnitFillType(i)\n\n                            -- if fill type is unknown we empty the fillUnit\n                                if fillType = = FillType.UNKNOWN then\n                                    self:addFillUnitFillLevel( self:getOwnerFarmId(), i, - math.huge, oldFillType, ToolType.UNDEFINED, nil )\n                                else\n                                        -- in case the fill type was switched dynamically\n                                        if oldFillType ~ = FillType.UNKNOWN and fillType ~ = oldFillType then\n                                            self:setFillUnitFillType(i, fillType)\n                                        end\n\n                                        self:addFillUnitFillLevel( self:getOwnerFarmId(), i, fillLevel - fillUnit.fillLevel, fillType, ToolType.UNDEFINED, nil )\n                                    end\n                                end\n\n                                local lastValidFillType = streamReadUIntN(streamId, FillTypeManager.SEND_NUM_BITS)\n                                self:setFillUnitLastValidFillType(i, lastValidFillType, lastValidFillType ~ = fillUnit.lastValidFillType)\n                            end\n                        end\n                    end\n                end\n            end\n\n"})}),"\n",(0,t.jsx)(n.h3,{id:"onregisteractionevents",children:"onRegisterActionEvents"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Description"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Definition"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"onRegisterActionEvents()"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"any"}),(0,t.jsx)(n.th,{children:"isActiveForInput"})]})}),(0,t.jsx)(n.tbody,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"any"}),(0,t.jsx)(n.td,{children:"isActiveForInputIgnoreSelection"})]})})]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Code"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:"function FillUnit:onRegisterActionEvents(isActiveForInput, isActiveForInputIgnoreSelection)\n    if self.isClient then\n        local spec = self.spec_fillUnit\n        self:clearActionEventsTable(spec.actionEvents)\n        if isActiveForInputIgnoreSelection then\n            if self.isServer and GS_IS_CONSOLE_VERSION and g_isDevelopmentVersion then\n                local _, actionEventId = self:addActionEvent(spec.actionEvents, InputAction.CONSOLE_DEBUG_FILLUNIT_NEXT, self , FillUnit.actionEventConsoleFillUnitNext, false , true , false , true , nil )\n                g_inputBinding:setActionEventTextVisibility(actionEventId, false )\n                g_inputBinding:setActionEventTextPriority(actionEventId, GS_PRIO_VERY_LOW)\n                _, actionEventId = self:addActionEvent(spec.actionEvents, InputAction.CONSOLE_DEBUG_FILLUNIT_INC, self , FillUnit.actionEventConsoleFillUnitInc, false , true , false , true , nil )\n                g_inputBinding:setActionEventTextVisibility(actionEventId, false )\n                g_inputBinding:setActionEventTextPriority(actionEventId, GS_PRIO_VERY_LOW)\n                _, actionEventId = self:addActionEvent(spec.actionEvents, InputAction.CONSOLE_DEBUG_FILLUNIT_DEC, self , FillUnit.actionEventConsoleFillUnitDec, false , true , false , true , nil )\n                g_inputBinding:setActionEventTextVisibility(actionEventId, false )\n                g_inputBinding:setActionEventTextPriority(actionEventId, GS_PRIO_VERY_LOW)\n            end\n\n            if spec.unloading ~ = nil then\n                local _, actionEventId = self:addActionEvent(spec.actionEvents, InputAction.UNLOAD, self , FillUnit.actionEventUnload, false , true , false , true , nil )\n                g_inputBinding:setActionEventTextPriority(actionEventId, GS_PRIO_NORMAL)\n                spec.unloadActionEventId = actionEventId\n                FillUnit.updateUnloadActionDisplay( self )\n            end\n        end\n    end\nend\n\n"})}),"\n",(0,t.jsx)(n.h3,{id:"onupdatetick",children:"onUpdateTick"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Description"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Definition"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"onUpdateTick()"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"any"}),(0,t.jsx)(n.th,{children:"dt"})]})}),(0,t.jsxs)(n.tbody,{children:[(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"any"}),(0,t.jsx)(n.td,{children:"isActiveForInput"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"any"}),(0,t.jsx)(n.td,{children:"isActiveForInputIgnoreSelection"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"any"}),(0,t.jsx)(n.td,{children:"isSelected"})]})]})]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Code"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:"function FillUnit:onUpdateTick(dt, isActiveForInput, isActiveForInputIgnoreSelection, isSelected)\n    local spec = self.spec_fillUnit\n\n    if self.isServer and spec.fillTrigger.isFilling then\n        local delta = 0\n        local trigger = spec.fillTrigger.currentTrigger\n        if trigger ~ = nil then\n            delta = spec.fillTrigger.litersPerSecond * dt * 0.001\n            delta = trigger:fillVehicle( self , delta, dt)\n        end\n\n        if delta < = 0 then\n            self:setFillUnitIsFilling( false )\n        end\n    end\n\n    if self.isClient then\n        for _, fillUnit in pairs(spec.fillUnits) do\n            self:updateMeasurementNodes(fillUnit, dt, false )\n        end\n\n        self:updateAlarmTriggers(spec.activeAlarmTriggers)\n\n        local needsUpdate = false\n\n        -- stop effects\n        for effect, time in pairs(spec.activeFillEffects) do\n            time = time - dt\n            if time < 0 then\n                g_effectManager:stopEffects(effect)\n                spec.activeFillEffects[effect] = nil\n            else\n                    needsUpdate = true\n                    spec.activeFillEffects[effect] = time\n                end\n            end\n\n            -- stop animations\n            for animationNodes, time in pairs(spec.activeFillAnimations) do\n                time = time - dt\n                if time < 0 then\n                    g_animationManager:stopAnimations(animationNodes)\n                    spec.activeFillAnimations[animationNodes] = nil\n                else\n                        needsUpdate = true\n                        spec.activeFillAnimations[animationNodes] = time\n                    end\n                end\n\n                if needsUpdate then\n                    self:raiseActive()\n                end\n            end\n        end\n\n"})}),"\n",(0,t.jsx)(n.h3,{id:"onwritestream",children:"onWriteStream"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Description"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Definition"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"onWriteStream()"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"any"}),(0,t.jsx)(n.th,{children:"streamId"})]})}),(0,t.jsx)(n.tbody,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"any"}),(0,t.jsx)(n.td,{children:"connection"})]})})]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Code"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:"function FillUnit:onWriteStream(streamId, connection)\n    if not connection:getIsServer() then\n        local spec = self.spec_fillUnit\n\n        streamWriteBool(streamId, spec.fillTrigger.isFilling)\n\n        for i = 1 ,#spec.fillUnits do\n            if spec.fillUnits[i].synchronizeFillLevel then\n                local fillUnit = spec.fillUnits[i]\n                streamWriteFloat32(streamId, fillUnit.fillLevel)\n                streamWriteUIntN(streamId, fillUnit.fillType, FillTypeManager.SEND_NUM_BITS)\n                streamWriteUIntN(streamId, fillUnit.lastValidFillType, FillTypeManager.SEND_NUM_BITS)\n            end\n        end\n    end\nend\n\n"})}),"\n",(0,t.jsx)(n.h3,{id:"onwriteupdatestream",children:"onWriteUpdateStream"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Description"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Definition"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"onWriteUpdateStream()"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"any"}),(0,t.jsx)(n.th,{children:"streamId"})]})}),(0,t.jsxs)(n.tbody,{children:[(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"any"}),(0,t.jsx)(n.td,{children:"connection"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"any"}),(0,t.jsx)(n.td,{children:"dirtyMask"})]})]})]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Code"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:"function FillUnit:onWriteUpdateStream(streamId, connection, dirtyMask)\n    if not connection:getIsServer() then\n        local spec = self.spec_fillUnit\n\n        if streamWriteBool(streamId, bit32.band(dirtyMask, spec.dirtyFlag) ~ = 0 ) then\n            for i = 1 ,#spec.fillUnits do\n                local fillUnit = spec.fillUnits[i]\n                if fillUnit.synchronizeFillLevel then\n                    if streamWriteBool(streamId, fillUnit.synchronizeFullFillLevel or fillUnit.capacity = = math.huge) then\n                        streamWriteFloat32(streamId, fillUnit.fillLevelSent)\n                    else\n                            local percent = 0\n                            if fillUnit.capacity > 0 then\n                                percent = math.clamp(fillUnit.fillLevelSent / fillUnit.capacity, 0 , 1 )\n                            end\n\n                            local value = math.floor(percent * ( 2 ^ fillUnit.synchronizationNumBits - 1 ) + 0.5 )\n                            streamWriteUIntN(streamId, value, fillUnit.synchronizationNumBits)\n                        end\n                        streamWriteUIntN(streamId, fillUnit.fillTypeSent, FillTypeManager.SEND_NUM_BITS)\n                        streamWriteUIntN(streamId, fillUnit.lastValidFillTypeSent, FillTypeManager.SEND_NUM_BITS)\n                    end\n                end\n            end\n        end\n    end\n\n"})}),"\n",(0,t.jsx)(n.h3,{id:"prerequisitespresent",children:"prerequisitesPresent"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Description"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Definition"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"prerequisitesPresent()"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,t.jsx)(n.table,{children:(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"any"}),(0,t.jsx)(n.th,{children:"specializations"})]})})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Code"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:"function FillUnit.prerequisitesPresent(specializations)\n    return true\nend\n\n"})}),"\n",(0,t.jsx)(n.h3,{id:"registereventlisteners",children:"registerEventListeners"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Description"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Definition"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"registerEventListeners()"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,t.jsx)(n.table,{children:(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"any"}),(0,t.jsx)(n.th,{children:"vehicleType"})]})})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Code"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:'function FillUnit.registerEventListeners(vehicleType)\n    SpecializationUtil.registerEventListener(vehicleType, "onLoad" , FillUnit )\n    SpecializationUtil.registerEventListener(vehicleType, "onPostLoad" , FillUnit )\n    SpecializationUtil.registerEventListener(vehicleType, "onDelete" , FillUnit )\n    SpecializationUtil.registerEventListener(vehicleType, "onReadStream" , FillUnit )\n    SpecializationUtil.registerEventListener(vehicleType, "onWriteStream" , FillUnit )\n    SpecializationUtil.registerEventListener(vehicleType, "onReadUpdateStream" , FillUnit )\n    SpecializationUtil.registerEventListener(vehicleType, "onWriteUpdateStream" , FillUnit )\n    SpecializationUtil.registerEventListener(vehicleType, "onUpdateTick" , FillUnit )\n    SpecializationUtil.registerEventListener(vehicleType, "onPostUpdate" , FillUnit )\n    SpecializationUtil.registerEventListener(vehicleType, "onDraw" , FillUnit )\n    SpecializationUtil.registerEventListener(vehicleType, "onDeactivate" , FillUnit )\n    SpecializationUtil.registerEventListener(vehicleType, "onRegisterActionEvents" , FillUnit )\n    SpecializationUtil.registerEventListener(vehicleType, "onDischargeTargetObjectChanged" , FillUnit )\nend\n\n'})}),"\n",(0,t.jsx)(n.h3,{id:"registerevents",children:"registerEvents"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Description"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Definition"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"registerEvents()"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,t.jsx)(n.table,{children:(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"any"}),(0,t.jsx)(n.th,{children:"vehicleType"})]})})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Code"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:'function FillUnit.registerEvents(vehicleType)\n    SpecializationUtil.registerEvent(vehicleType, "onFillUnitFillLevelChanged" )\n    SpecializationUtil.registerEvent(vehicleType, "onChangedFillType" )\n    SpecializationUtil.registerEvent(vehicleType, "onAlarmTriggerChanged" )\n    SpecializationUtil.registerEvent(vehicleType, "onAddedFillUnitTrigger" )\n    SpecializationUtil.registerEvent(vehicleType, "onFillUnitTriggerChanged" )\n    SpecializationUtil.registerEvent(vehicleType, "onRemovedFillUnitTrigger" )\n    SpecializationUtil.registerEvent(vehicleType, "onFillUnitIsFillingStateChanged" )\n    SpecializationUtil.registerEvent(vehicleType, "onFillUnitUnloadPallet" )\n    SpecializationUtil.registerEvent(vehicleType, "onFillUnitUnloaded" )\nend\n\n'})}),"\n",(0,t.jsx)(n.h3,{id:"registerfunctions",children:"registerFunctions"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Description"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Definition"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"registerFunctions()"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,t.jsx)(n.table,{children:(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"any"}),(0,t.jsx)(n.th,{children:"vehicleType"})]})})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Code"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:'function FillUnit.registerFunctions(vehicleType)\n    SpecializationUtil.registerFunction(vehicleType, "getDrawFirstFillText" , FillUnit.getDrawFirstFillText)\n    SpecializationUtil.registerFunction(vehicleType, "getFillUnits" , FillUnit.getFillUnits)\n    SpecializationUtil.registerFunction(vehicleType, "getFillUnitByIndex" , FillUnit.getFillUnitByIndex)\n    SpecializationUtil.registerFunction(vehicleType, "getFillUnitExists" , FillUnit.getFillUnitExists)\n    SpecializationUtil.registerFunction(vehicleType, "getFillUnitCapacity" , FillUnit.getFillUnitCapacity)\n    SpecializationUtil.registerFunction(vehicleType, "getFillUnitFreeCapacity" , FillUnit.getFillUnitFreeCapacity)\n    SpecializationUtil.registerFunction(vehicleType, "getIsFillAllowedFromFarm" , FillUnit.getIsFillAllowedFromFarm)\n    SpecializationUtil.registerFunction(vehicleType, "getFillUnitFillLevel" , FillUnit.getFillUnitFillLevel)\n    SpecializationUtil.registerFunction(vehicleType, "getFillUnitFillLevelPercentage" , FillUnit.getFillUnitFillLevelPercentage)\n    SpecializationUtil.registerFunction(vehicleType, "getFillUnitFillType" , FillUnit.getFillUnitFillType)\n    SpecializationUtil.registerFunction(vehicleType, "getFillUnitLastValidFillType" , FillUnit.getFillUnitLastValidFillType)\n    SpecializationUtil.registerFunction(vehicleType, "getFillUnitFirstSupportedFillType" , FillUnit.getFillUnitFirstSupportedFillType)\n    SpecializationUtil.registerFunction(vehicleType, "getFillUnitExactFillRootNode" , FillUnit.getFillUnitExactFillRootNode)\n    SpecializationUtil.registerFunction(vehicleType, "getFillUnitRootNode" , FillUnit.getFillUnitRootNode)\n    SpecializationUtil.registerFunction(vehicleType, "getFillUnitAutoAimTargetNode" , FillUnit.getFillUnitAutoAimTargetNode)\n    SpecializationUtil.registerFunction(vehicleType, "getFillUnitSupportsFillType" , FillUnit.getFillUnitSupportsFillType)\n    SpecializationUtil.registerFunction(vehicleType, "getFillUnitSupportsToolType" , FillUnit.getFillUnitSupportsToolType)\n    SpecializationUtil.registerFunction(vehicleType, "getFillUnitSupportsToolTypeAndFillType" , FillUnit.getFillUnitSupportsToolTypeAndFillType)\n    SpecializationUtil.registerFunction(vehicleType, "getFillUnitSupportedFillTypes" , FillUnit.getFillUnitSupportedFillTypes)\n    SpecializationUtil.registerFunction(vehicleType, "getFillUnitSupportedToolTypes" , FillUnit.getFillUnitSupportedToolTypes)\n    SpecializationUtil.registerFunction(vehicleType, "getFillUnitAllowsFillType" , FillUnit.getFillUnitAllowsFillType)\n    SpecializationUtil.registerFunction(vehicleType, "getFillTypeChangeThreshold" , FillUnit.getFillTypeChangeThreshold)\n    SpecializationUtil.registerFunction(vehicleType, "getFirstValidFillUnitToFill" , FillUnit.getFirstValidFillUnitToFill)\n    SpecializationUtil.registerFunction(vehicleType, "getFillUnitCanBeFilled" , FillUnit.getFillUnitCanBeFilled)\n    SpecializationUtil.registerFunction(vehicleType, "setFillUnitFillType" , FillUnit.setFillUnitFillType)\n    SpecializationUtil.registerFunction(vehicleType, "setFillUnitFillTypeToDisplay" , FillUnit.setFillUnitFillTypeToDisplay)\n    SpecializationUtil.registerFunction(vehicleType, "setFillUnitFillLevelToDisplay" , FillUnit.setFillUnitFillLevelToDisplay)\n    SpecializationUtil.registerFunction(vehicleType, "setFillUnitCapacityToDisplay" , FillUnit.setFillUnitCapacityToDisplay)\n    SpecializationUtil.registerFunction(vehicleType, "setFillUnitCapacity" , FillUnit.setFillUnitCapacity)\n    SpecializationUtil.registerFunction(vehicleType, "setFillUnitForcedMaterialFillType" , FillUnit.setFillUnitForcedMaterialFillType)\n    SpecializationUtil.registerFunction(vehicleType, "getFillUnitForcedMaterialFillType" , FillUnit.getFillUnitForcedMaterialFillType)\n    SpecializationUtil.registerFunction(vehicleType, "setFillUnitInTriggerRange" , FillUnit.setFillUnitInTriggerRange)\n    SpecializationUtil.registerFunction(vehicleType, "updateAlarmTriggers" , FillUnit.updateAlarmTriggers)\n    SpecializationUtil.registerFunction(vehicleType, "getAlarmTriggerIsActive" , FillUnit.getAlarmTriggerIsActive)\n    SpecializationUtil.registerFunction(vehicleType, "setAlarmTriggerState" , FillUnit.setAlarmTriggerState)\n    SpecializationUtil.registerFunction(vehicleType, "getFillUnitIndexFromNode" , FillUnit.getFillUnitIndexFromNode)\n    SpecializationUtil.registerFunction(vehicleType, "getFillUnitExtraDistanceFromNode" , FillUnit.getFillUnitExtraDistanceFromNode)\n    SpecializationUtil.registerFunction(vehicleType, "getFillUnitFromNode" , FillUnit.getFillUnitFromNode)\n    SpecializationUtil.registerFunction(vehicleType, "addFillUnitFillLevel" , FillUnit.addFillUnitFillLevel)\n    SpecializationUtil.registerFunction(vehicleType, "setFillUnitLastValidFillType" , FillUnit.setFillUnitLastValidFillType)\n    SpecializationUtil.registerFunction(vehicleType, "loadFillUnitFromXML" , FillUnit.loadFillUnitFromXML)\n    SpecializationUtil.registerFunction(vehicleType, "loadAlarmTrigger" , FillUnit.loadAlarmTrigger)\n    SpecializationUtil.registerFunction(vehicleType, "loadMeasurementNode" , FillUnit.loadMeasurementNode)\n    SpecializationUtil.registerFunction(vehicleType, "updateMeasurementNodes" , FillUnit.updateMeasurementNodes)\n    SpecializationUtil.registerFunction(vehicleType, "loadFillPlane" , FillUnit.loadFillPlane)\n    SpecializationUtil.registerFunction(vehicleType, "setFillPlaneForcedFillType" , FillUnit.setFillPlaneForcedFillType)\n    SpecializationUtil.registerFunction(vehicleType, "updateFillUnitFillPlane" , FillUnit.updateFillUnitFillPlane)\n    SpecializationUtil.registerFunction(vehicleType, "loadFillTypeMaterials" , FillUnit.loadFillTypeMaterials)\n    SpecializationUtil.registerFunction(vehicleType, "updateFillTypeMaterials" , FillUnit.updateFillTypeMaterials)\n    SpecializationUtil.registerFunction(vehicleType, "updateFillUnitAutoAimTarget" , FillUnit.updateFillUnitAutoAimTarget)\n    SpecializationUtil.registerFunction(vehicleType, "addFillUnitTrigger" , FillUnit.addFillUnitTrigger)\n    SpecializationUtil.registerFunction(vehicleType, "removeFillUnitTrigger" , FillUnit.removeFillUnitTrigger)\n    SpecializationUtil.registerFunction(vehicleType, "setFillUnitIsFilling" , FillUnit.setFillUnitIsFilling)\n    SpecializationUtil.registerFunction(vehicleType, "setFillSoundIsPlaying" , FillUnit.setFillSoundIsPlaying)\n    SpecializationUtil.registerFunction(vehicleType, "getIsFillUnitActive" , FillUnit.getIsFillUnitActive)\n    SpecializationUtil.registerFunction(vehicleType, "updateFillUnitTriggers" , FillUnit.updateFillUnitTriggers)\n    SpecializationUtil.registerFunction(vehicleType, "emptyAllFillUnits" , FillUnit.emptyAllFillUnits)\n    SpecializationUtil.registerFunction(vehicleType, "unloadFillUnits" , FillUnit.unloadFillUnits)\n    SpecializationUtil.registerFunction(vehicleType, "loadFillUnitUnloadingFromXML" , FillUnit.loadFillUnitUnloadingFromXML)\n    SpecializationUtil.registerFunction(vehicleType, "getFillUnitUnloadPalletFilename" , FillUnit.getFillUnitUnloadPalletFilename)\n    SpecializationUtil.registerFunction(vehicleType, "getFillUnitHasMountedPalletsToUnload" , FillUnit.getFillUnitHasMountedPalletsToUnload)\n    SpecializationUtil.registerFunction(vehicleType, "getFillUnitMountedPalletsToUnload" , FillUnit.getFillUnitMountedPalletsToUnload)\n    SpecializationUtil.registerFunction(vehicleType, "getFillUnitUnloadingTasks" , FillUnit.getFillUnitUnloadingTasks)\n    SpecializationUtil.registerFunction(vehicleType, "getFillUnitEmptyOnReset" , FillUnit.getFillUnitEmptyOnReset)\n    SpecializationUtil.registerFunction(vehicleType, "getAllowLoadTriggerActivation" , FillUnit.getAllowLoadTriggerActivation)\n    SpecializationUtil.registerFunction(vehicleType, "addExactFillRootAimToUpdate" , FillUnit.addExactFillRootAimToUpdate)\n    SpecializationUtil.registerFunction(vehicleType, "debugGetSupportedFillTypesPerFillUnit" , FillUnit.debugGetSupportedFillTypesPerFillUnit)\nend\n\n'})}),"\n",(0,t.jsx)(n.h3,{id:"registeroverwrittenfunctions",children:"registerOverwrittenFunctions"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Description"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Definition"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"registerOverwrittenFunctions()"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,t.jsx)(n.table,{children:(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"any"}),(0,t.jsx)(n.th,{children:"vehicleType"})]})})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Code"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:'function FillUnit.registerOverwrittenFunctions(vehicleType)\n    SpecializationUtil.registerOverwrittenFunction(vehicleType, "getAdditionalComponentMass" , FillUnit.getAdditionalComponentMass)\n    SpecializationUtil.registerOverwrittenFunction(vehicleType, "getFillLevelInformation" , FillUnit.getFillLevelInformation)\n    SpecializationUtil.registerOverwrittenFunction(vehicleType, "getIsFoldAllowed" , FillUnit.getIsFoldAllowed)\n    SpecializationUtil.registerOverwrittenFunction(vehicleType, "getIsReadyForAutomatedTrainTravel" , FillUnit.getIsReadyForAutomatedTrainTravel)\n    SpecializationUtil.registerOverwrittenFunction(vehicleType, "loadMovingToolFromXML" , FillUnit.loadMovingToolFromXML)\n    SpecializationUtil.registerOverwrittenFunction(vehicleType, "getIsMovingToolActive" , FillUnit.getIsMovingToolActive)\n    SpecializationUtil.registerOverwrittenFunction(vehicleType, "getDoConsumePtoPower" , FillUnit.getDoConsumePtoPower)\n    SpecializationUtil.registerOverwrittenFunction(vehicleType, "getIsPowerTakeOffActive" , FillUnit.getIsPowerTakeOffActive)\n    SpecializationUtil.registerOverwrittenFunction(vehicleType, "getCanBeTurnedOn" , FillUnit.getCanBeTurnedOn)\n    SpecializationUtil.registerOverwrittenFunction(vehicleType, "showInfo" , FillUnit.showInfo)\n    SpecializationUtil.registerOverwrittenFunction(vehicleType, "loadLevelerNodeFromXML" , FillUnit.loadLevelerNodeFromXML)\n    SpecializationUtil.registerOverwrittenFunction(vehicleType, "getIsLevelerPickupNodeActive" , FillUnit.getIsLevelerPickupNodeActive)\n    SpecializationUtil.registerOverwrittenFunction(vehicleType, "loadAttacherJointFromXML" , FillUnit.loadAttacherJointFromXML)\n    SpecializationUtil.registerOverwrittenFunction(vehicleType, "getIsAttacherJointCompatible" , FillUnit.getIsAttacherJointCompatible)\nend\n\n'})}),"\n",(0,t.jsx)(n.h3,{id:"registerunitdisplayschema",children:"registerUnitDisplaySchema"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Description"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Definition"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"registerUnitDisplaySchema()"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"any"}),(0,t.jsx)(n.th,{children:"schema"})]})}),(0,t.jsx)(n.tbody,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"any"}),(0,t.jsx)(n.td,{children:"key"})]})})]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Code"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:'function FillUnit.registerUnitDisplaySchema(schema, key)\n    schema:register(XMLValueType.STRING, key .. "#shopDisplayUnit" , "Unit used for displaying the capacity in shop(converts to given unit from capacity in liters)" , "LITER" , false , table.toList( FillUnit.UNIT))\n        schema:register(XMLValueType.STRING, key .. "#unitTextOverride" , "Unit text override, no conversion performed on given capacity" )\n    end\n\n'})}),"\n",(0,t.jsx)(n.h3,{id:"removefillunittrigger",children:"removeFillUnitTrigger"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Description"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"Removes fill trigger"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Definition"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"removeFillUnitTrigger(table trigger)"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n",(0,t.jsx)(n.table,{children:(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"table"}),(0,t.jsx)(n.th,{children:"trigger"}),(0,t.jsx)(n.th,{children:"trigger"})]})})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Code"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:'function FillUnit:removeFillUnitTrigger(trigger)\n    local spec = self.spec_fillUnit\n    table.removeElement(spec.fillTrigger.triggers, trigger)\n\n    if self.isServer and trigger = = spec.fillTrigger.currentTrigger then\n        self:setFillUnitIsFilling( false )\n    end\n\n    if #spec.fillTrigger.triggers = = 0 then\n        g_currentMission.activatableObjectsSystem:removeActivatable(spec.fillTrigger.activatable)\n\n        -- automatic filling for mobile version\n            if self.isServer and Platform.gameplay.automaticFilling then\n                self:setFillUnitIsFilling( false )\n            end\n        end\n\n        SpecializationUtil.raiseEvent( self , "onRemovedFillUnitTrigger" , #spec.fillTrigger.triggers)\n\n        self:updateFillUnitTriggers()\n    end\n\n'})}),"\n",(0,t.jsx)(n.h3,{id:"savestatstoxmlfile",children:"saveStatsToXMLFile"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Description"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Definition"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"saveStatsToXMLFile()"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"any"}),(0,t.jsx)(n.th,{children:"xmlFile"})]})}),(0,t.jsx)(n.tbody,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"any"}),(0,t.jsx)(n.td,{children:"key"})]})})]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Code"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:"function FillUnit:saveStatsToXMLFile(xmlFile, key)\n    local spec = self.spec_fillUnit\n\n    local fillTypes = ''\n    local fillLevels = ''\n    local numFillUnits = #spec.fillUnits\n    for i,fillUnit in ipairs(spec.fillUnits) do\n        local fillTypeName = Utils.getNoNil(g_fillTypeManager:getFillTypeNameByIndex(fillUnit.fillType), \"unknown\" )\n        fillTypes = fillTypes .. HTMLUtil.encodeToHTML( tostring(fillTypeName))\n        fillLevels = fillLevels .. string.format( \"%.3f\" , fillUnit.fillLevel)\n        if numFillUnits > 1 and i ~ = numFillUnits then\n            fillTypes = fillTypes .. ' '\n            fillLevels = fillLevels .. ' '\n        end\n    end\n\n    setXMLString(xmlFile, key .. \"#fillTypes\" , fillTypes)\n    setXMLString(xmlFile, key .. \"#fillLevels\" , fillLevels)\nend\n\n"})}),"\n",(0,t.jsx)(n.h3,{id:"savetoxmlfile",children:"saveToXMLFile"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Description"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Definition"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"saveToXMLFile()"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"any"}),(0,t.jsx)(n.th,{children:"xmlFile"})]})}),(0,t.jsxs)(n.tbody,{children:[(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"any"}),(0,t.jsx)(n.td,{children:"key"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"any"}),(0,t.jsx)(n.td,{children:"usedModNames"})]})]})]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Code"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:'function FillUnit:saveToXMLFile(xmlFile, key, usedModNames)\n    local spec = self.spec_fillUnit\n    local i = 0\n    for k, fillUnit in ipairs(spec.fillUnits) do\n        if fillUnit.needsSaving then\n            local fillUnitKey = string.format( "%s.unit(%d)" , key, i)\n            local fillTypeName = Utils.getNoNil(g_fillTypeManager:getFillTypeNameByIndex(fillUnit.fillType), "unknown" )\n            xmlFile:setValue(fillUnitKey .. "#index" , k)\n            xmlFile:setValue(fillUnitKey .. "#fillType" , fillTypeName)\n            xmlFile:setValue(fillUnitKey .. "#fillLevel" , fillUnit.fillLevel)\n            i = i + 1\n        end\n    end\nend\n\n'})}),"\n",(0,t.jsx)(n.h3,{id:"setalarmtriggerstate",children:"setAlarmTriggerState"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Description"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Definition"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"setAlarmTriggerState()"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"any"}),(0,t.jsx)(n.th,{children:"alarmTrigger"})]})}),(0,t.jsx)(n.tbody,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"any"}),(0,t.jsx)(n.td,{children:"state"})]})})]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Code"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:'function FillUnit:setAlarmTriggerState(alarmTrigger, state)\n    local spec = self.spec_fillUnit\n\n    if state ~ = alarmTrigger.isActive then\n        if state then\n            if alarmTrigger.sample ~ = nil then\n                g_soundManager:playSample(alarmTrigger.sample)\n            end\n\n            for _, beaconLight in ipairs(alarmTrigger.beaconLights) do\n                beaconLight:setIsActive( true )\n\n                if beaconLight.activeDuration ~ = 0 then\n                    Timer.createOneshot(beaconLight.activeDuration, function ()\n                        beaconLight:setIsActive( false )\n                    end )\n                end\n            end\n\n            spec.activeAlarmTriggers[alarmTrigger] = alarmTrigger\n        else\n                if alarmTrigger.sample ~ = nil then\n                    g_soundManager:stopSample(alarmTrigger.sample)\n                end\n\n                for _, beaconLight in ipairs(alarmTrigger.beaconLights) do\n                    beaconLight:setIsActive( false )\n                end\n\n                spec.activeAlarmTriggers[alarmTrigger] = nil\n            end\n\n            alarmTrigger.isActive = state\n            SpecializationUtil.raiseEvent( self , "onAlarmTriggerChanged" , alarmTrigger, state)\n        end\n    end\n\n'})}),"\n",(0,t.jsx)(n.h3,{id:"setfillplaneforcedfilltype",children:"setFillPlaneForcedFillType"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Description"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Definition"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"setFillPlaneForcedFillType()"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"any"}),(0,t.jsx)(n.th,{children:"fillUnitIndex"})]})}),(0,t.jsx)(n.tbody,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"any"}),(0,t.jsx)(n.td,{children:"forcedFillType"})]})})]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Code"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:"function FillUnit:setFillPlaneForcedFillType(fillUnitIndex, forcedFillType)\n    local spec = self.spec_fillUnit\n    if spec.fillUnits[fillUnitIndex] ~ = nil then\n        if spec.fillUnits[fillUnitIndex].fillPlane ~ = nil then\n            spec.fillUnits[fillUnitIndex].fillPlane.forcedFillType = forcedFillType\n        end\n    end\nend\n\n"})}),"\n",(0,t.jsx)(n.h3,{id:"setfillsoundisplaying",children:"setFillSoundIsPlaying"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Description"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Definition"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"setFillSoundIsPlaying()"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,t.jsx)(n.table,{children:(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"any"}),(0,t.jsx)(n.th,{children:"isPlaying"})]})})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Code"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:"function FillUnit:setFillSoundIsPlaying(isPlaying)\n    local spec = self.spec_fillUnit\n    if isPlaying then\n        if not g_soundManager:getIsSamplePlaying(spec.samples.fill) then\n            g_soundManager:playSample(spec.samples.fill)\n        end\n    else\n            if g_soundManager:getIsSamplePlaying(spec.samples.fill) then\n                g_soundManager:stopSample(spec.samples.fill)\n            end\n        end\n    end\n\n"})}),"\n",(0,t.jsx)(n.h3,{id:"setfillunitcapacity",children:"setFillUnitCapacity"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Description"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Definition"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"setFillUnitCapacity()"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"any"}),(0,t.jsx)(n.th,{children:"fillUnitIndex"})]})}),(0,t.jsxs)(n.tbody,{children:[(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"any"}),(0,t.jsx)(n.td,{children:"capacity"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"any"}),(0,t.jsx)(n.td,{children:"noEventSend"})]})]})]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Code"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:"function FillUnit:setFillUnitCapacity(fillUnitIndex, capacity, noEventSend)\n    local spec = self.spec_fillUnit\n    if spec.fillUnits[fillUnitIndex] ~ = nil then\n        if capacity ~ = spec.fillUnits[fillUnitIndex].capacity then\n            spec.fillUnits[fillUnitIndex].capacity = capacity\n\n            SetFillUnitCapacityEvent.sendEvent( self , fillUnitIndex, capacity, noEventSend)\n        end\n    end\nend\n\n"})}),"\n",(0,t.jsx)(n.h3,{id:"setfillunitcapacitytodisplay",children:"setFillUnitCapacityToDisplay"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Description"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Definition"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"setFillUnitCapacityToDisplay()"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"any"}),(0,t.jsx)(n.th,{children:"fillUnitIndex"})]})}),(0,t.jsx)(n.tbody,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"any"}),(0,t.jsx)(n.td,{children:"capacity"})]})})]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Code"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:"function FillUnit:setFillUnitCapacityToDisplay(fillUnitIndex, capacity)\n    local spec = self.spec_fillUnit\n    if spec.fillUnits[fillUnitIndex] ~ = nil then\n        spec.fillUnits[fillUnitIndex].capacityToDisplay = capacity\n    end\nend\n\n"})}),"\n",(0,t.jsx)(n.h3,{id:"setfillunitfillleveltodisplay",children:"setFillUnitFillLevelToDisplay"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Description"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Definition"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"setFillUnitFillLevelToDisplay()"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"any"}),(0,t.jsx)(n.th,{children:"fillUnitIndex"})]})}),(0,t.jsxs)(n.tbody,{children:[(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"any"}),(0,t.jsx)(n.td,{children:"fillLevel"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"any"}),(0,t.jsx)(n.td,{children:"isPersistent"})]})]})]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Code"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:"function FillUnit:setFillUnitFillLevelToDisplay(fillUnitIndex, fillLevel, isPersistent)\n    local spec = self.spec_fillUnit\n    if spec.fillUnits[fillUnitIndex] ~ = nil then\n        spec.fillUnits[fillUnitIndex].fillLevelToDisplay = fillLevel\n        spec.fillUnits[fillUnitIndex].fillLevelToDisplayIsPersistent = isPersistent ~ = nil and isPersistent\n    end\nend\n\n"})}),"\n",(0,t.jsx)(n.h3,{id:"setfillunitfilltype",children:"setFillUnitFillType"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Description"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Definition"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"setFillUnitFillType()"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"any"}),(0,t.jsx)(n.th,{children:"fillUnitIndex"})]})}),(0,t.jsx)(n.tbody,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"any"}),(0,t.jsx)(n.td,{children:"fillTypeIndex"})]})})]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Code"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:'function FillUnit:setFillUnitFillType(fillUnitIndex, fillTypeIndex)\n    local spec = self.spec_fillUnit\n    local oldFillTypeIndex = spec.fillUnits[fillUnitIndex].fillType\n    if oldFillTypeIndex ~ = fillTypeIndex then\n        spec.fillUnits[fillUnitIndex].fillType = fillTypeIndex\n        SpecializationUtil.raiseEvent( self , "onChangedFillType" , fillUnitIndex, fillTypeIndex, oldFillTypeIndex)\n    end\nend\n\n'})}),"\n",(0,t.jsx)(n.h3,{id:"setfillunitfilltypetodisplay",children:"setFillUnitFillTypeToDisplay"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Description"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Definition"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"setFillUnitFillTypeToDisplay()"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"any"}),(0,t.jsx)(n.th,{children:"fillUnitIndex"})]})}),(0,t.jsxs)(n.tbody,{children:[(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"any"}),(0,t.jsx)(n.td,{children:"fillTypeIndex"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"any"}),(0,t.jsx)(n.td,{children:"isPersistent"})]})]})]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Code"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:"function FillUnit:setFillUnitFillTypeToDisplay(fillUnitIndex, fillTypeIndex, isPersistent)\n    local spec = self.spec_fillUnit\n    if spec.fillUnits[fillUnitIndex] ~ = nil then\n        spec.fillUnits[fillUnitIndex].fillTypeToDisplay = fillTypeIndex\n        spec.fillUnits[fillUnitIndex].fillTypeToDisplayIsPersistent = isPersistent ~ = nil and isPersistent\n    end\nend\n\n"})}),"\n",(0,t.jsx)(n.h3,{id:"setfillunitforcedmaterialfilltype",children:"setFillUnitForcedMaterialFillType"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Description"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Definition"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"setFillUnitForcedMaterialFillType()"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"any"}),(0,t.jsx)(n.th,{children:"fillUnitIndex"})]})}),(0,t.jsx)(n.tbody,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"any"}),(0,t.jsx)(n.td,{children:"forcedMaterialFillType"})]})})]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Code"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:"function FillUnit:setFillUnitForcedMaterialFillType(fillUnitIndex, forcedMaterialFillType)\n    local spec = self.spec_fillUnit\n    if spec.fillUnits[fillUnitIndex] ~ = nil then\n        spec.fillUnits[fillUnitIndex].forcedMaterialFillType = forcedMaterialFillType\n    end\n\n    self:setFillPlaneForcedFillType(fillUnitIndex, forcedMaterialFillType)\n\n    if self.setFillVolumeForcedFillTypeByFillUnitIndex ~ = nil then\n        self:setFillVolumeForcedFillTypeByFillUnitIndex(fillUnitIndex, forcedMaterialFillType)\n    end\nend\n\n"})}),"\n",(0,t.jsx)(n.h3,{id:"setfillunitintriggerrange",children:"setFillUnitInTriggerRange"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Description"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Definition"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"setFillUnitInTriggerRange()"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"any"}),(0,t.jsx)(n.th,{children:"fillUnitIndex"})]})}),(0,t.jsx)(n.tbody,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"any"}),(0,t.jsx)(n.td,{children:"isInRange"})]})})]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Code"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:"function FillUnit:setFillUnitInTriggerRange(fillUnitIndex, isInRange)\nend\n\n"})}),"\n",(0,t.jsx)(n.h3,{id:"setfillunitisfilling",children:"setFillUnitIsFilling"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Description"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Definition"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"setFillUnitIsFilling()"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"any"}),(0,t.jsx)(n.th,{children:"isFilling"})]})}),(0,t.jsx)(n.tbody,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"any"}),(0,t.jsx)(n.td,{children:"noEventSend"})]})})]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Code"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:'function FillUnit:setFillUnitIsFilling(isFilling, noEventSend)\n    local spec = self.spec_fillUnit\n    if isFilling ~ = spec.fillTrigger.isFilling then\n        if noEventSend = = nil or noEventSend = = false then\n            if g_server ~ = nil then\n                g_server:broadcastEvent( SetFillUnitIsFillingEvent.new( self , isFilling), nil , nil , self )\n            else\n                    g_client:getServerConnection():sendEvent( SetFillUnitIsFillingEvent.new( self , isFilling))\n                end\n            end\n\n            spec.fillTrigger.isFilling = isFilling\n\n            if isFilling then\n                spec.fillTrigger.currentTrigger = nil\n\n                -- find the first trigger which is activable\n                for _, trigger in ipairs(spec.fillTrigger.triggers) do\n                    if trigger:getIsActivatable( self ) then\n                        spec.fillTrigger.currentTrigger = trigger\n                        trigger:setFillSoundIsPlaying(isFilling)\n                        break\n                    end\n                end\n            else\n                    if spec.fillTrigger.currentTrigger ~ = nil then\n                        spec.fillTrigger.currentTrigger:setFillSoundIsPlaying(isFilling)\n                        spec.fillTrigger.currentTrigger = nil\n                    end\n                end\n\n                if self.isClient then\n                    self:setFillSoundIsPlaying(isFilling)\n                end\n\n                SpecializationUtil.raiseEvent( self , "onFillUnitIsFillingStateChanged" , isFilling)\n\n                if not isFilling then\n                    self:updateFillUnitTriggers()\n                end\n            end\n        end\n\n'})}),"\n",(0,t.jsx)(n.h3,{id:"setfillunitlastvalidfilltype",children:"setFillUnitLastValidFillType"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Description"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Definition"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"setFillUnitLastValidFillType()"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"any"}),(0,t.jsx)(n.th,{children:"fillUnitIndex"})]})}),(0,t.jsxs)(n.tbody,{children:[(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"any"}),(0,t.jsx)(n.td,{children:"fillType"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"any"}),(0,t.jsx)(n.td,{children:"force"})]})]})]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Code"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:"function FillUnit:setFillUnitLastValidFillType(fillUnitIndex, fillType, force)\n    local spec = self.spec_fillUnit\n    local fillUnit = spec.fillUnits[fillUnitIndex]\n    if fillUnit ~ = nil and fillUnit.lastValidFillType ~ = fillType then\n        fillUnit.lastValidFillType = fillType\n        fillUnit.lastValidFillTypeSent = fillType\n        self:raiseDirtyFlags(spec.dirtyFlag)\n    end\nend\n\n"})}),"\n",(0,t.jsx)(n.h3,{id:"showinfo",children:"showInfo"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Description"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Definition"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"showInfo()"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"any"}),(0,t.jsx)(n.th,{children:"superFunc"})]})}),(0,t.jsx)(n.tbody,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"any"}),(0,t.jsx)(n.td,{children:"box"})]})})]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Code"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:'function FillUnit:showInfo(superFunc, box)\n    local spec = self.spec_fillUnit\n\n    if spec.isInfoDirty then\n        spec.fillUnitInfos = { }\n        local fillTypeToInfo = { }\n\n        for _, fillUnit in ipairs(spec.fillUnits) do\n            if fillUnit.showOnInfoHud and fillUnit.fillLevel > 0 then\n                local info = fillTypeToInfo[fillUnit.fillType]\n                if info = = nil then\n                    local fillType = g_fillTypeManager:getFillTypeByIndex(fillUnit.fillType)\n                    info = { title = fillType.title, fillLevel = 0 , unit = fillUnit.unitText, precision = 0 }\n                    table.insert(spec.fillUnitInfos, info)\n                    fillTypeToInfo[fillUnit.fillType] = info\n                end\n\n                info.fillLevel = info.fillLevel + fillUnit.fillLevel\n                if info.precision = = 0 and fillUnit.fillLevel > 0 then\n                    info.precision = fillUnit.uiPrecision or 0\n                end\n            end\n        end\n\n        spec.isInfoDirty = false\n    end\n\n    for _, info in ipairs(spec.fillUnitInfos) do\n        local formattedNumber\n        if info.precision > 0 then\n            local rounded = MathUtil.round(info.fillLevel, info.precision)\n            formattedNumber = string.format( "%d%s%0" .. info.precision .. "d" , math.floor(rounded), g_i18n.decimalSeparator, (rounded - math.floor(rounded)) * 10 ^ info.precision)\n        else\n                formattedNumber = string.format( "%d" , MathUtil.round(info.fillLevel))\n            end\n\n            formattedNumber = formattedNumber .. " " .. (info.unit or g_i18n:getVolumeUnit())\n\n            box:addLine(info.title, formattedNumber)\n        end\n\n        superFunc( self , box)\n    end\n\n'})}),"\n",(0,t.jsx)(n.h3,{id:"unloadfillunits",children:"unloadFillUnits"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Description"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Definition"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"unloadFillUnits()"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,t.jsx)(n.table,{children:(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"any"}),(0,t.jsx)(n.th,{children:"ignoreWarning"})]})})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Code"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:'function FillUnit:unloadFillUnits(ignoreWarning)\n    if not self.isServer then\n        g_client:getServerConnection():sendEvent( FillUnitUnloadEvent.new( self ))\n    else\n            local spec = self.spec_fillUnit\n            if spec.unloadingFillUnitsRunning then\n                return\n            else\n                    spec.unloadingFillUnitsRunning = true\n                end\n\n                local unloadingPlaces = spec.unloading\n\n                local places = { }\n\n                for _, unloading in ipairs(unloadingPlaces) do\n                    local node = unloading.node\n                    local ox, oy, oz = unpack(unloading.offset)\n                    local x, y, z = localToWorld(node, ox - unloading.width * 0.5 , oy, oz)\n\n                    local place = { }\n                    place.startX, place.startY, place.startZ = x, y, z\n                    place.rotX, place.rotY, place.rotZ = getWorldRotation(node)\n                    place.dirX, place.dirY, place.dirZ = localDirectionToWorld(node, 1 , 0 , 0 )\n                    place.dirPerpX, place.dirPerpY, place.dirPerpZ = localDirectionToWorld(node, 0 , 0 , 1 )\n                    place.yOffset = 1\n                    place.maxWidth = math.huge\n                    place.maxLength = math.huge\n                    place.maxHeight = math.huge\n                    place.width = unloading.width\n\n                    table.insert(places, place)\n                end\n\n                local usedPlaces = { }\n\n                local availablePallets = { }\n\n                local unloadingTasks = self:getFillUnitUnloadingTasks()\n\n                if self:getFillUnitHasMountedPalletsToUnload() then\n                    local pallets = self:getFillUnitMountedPalletsToUnload()\n                    if pallets ~ = nil and #pallets > 0 then\n                        for i, pallet in ipairs(pallets) do\n                            local x, y, z, place, width, _ = PlacementUtil.getPlace(places, pallet.size, usedPlaces, true , true , false , true )\n                            if x ~ = nil then\n                                if pallet.unmount ~ = nil then\n                                    pallet:unmount( true )\n                                end\n\n                                PlacementUtil.markPlaceUsed(usedPlaces, place, width)\n\n                                local rotY = MathUtil.getYRotationFromDirection(place.dirPerpX, place.dirPerpZ)\n                                pallet:setAbsolutePosition(x, y, z, 0 , rotY, 0 )\n\n                                SpecializationUtil.raiseEvent( self , "onFillUnitUnloadPallet" , pallet)\n\n                                g_server:broadcastEvent( FillUnitUnloadedEvent.new( self , pallet), false , nil , self )\n                            else\n                                    if ignoreWarning = = nil or not ignoreWarning then\n                                        g_currentMission:addIngameNotification(FSBaseMission.INGAME_NOTIFICATION_INFO, spec.texts.unloadNoSpace)\n                                    end\n\n                                    g_server:broadcastEvent( FillUnitUnloadedEvent.new( self , nil , true ), false , nil , self )\n                                end\n                            end\n                        end\n                    end\n\n                    local function unloadNext()\n                        local task = unloadingTasks[ 1 ]\n                        if task ~ = nil then\n                            -- try to fill existing pallets\n                            for pallet, _ in pairs(availablePallets) do\n                                local fillUnitIndex = pallet:getFirstValidFillUnitToFill(task.fillTypeIndex)\n                                if fillUnitIndex ~ = nil then\n                                    local appliedDelta = pallet:addFillUnitFillLevel( self:getOwnerFarmId(), fillUnitIndex, task.fillLevel, task.fillTypeIndex, ToolType.UNDEFINED, nil )\n                                    self:addFillUnitFillLevel( self:getOwnerFarmId(), task.fillUnitIndex, - appliedDelta, task.fillTypeIndex, ToolType.UNDEFINED, nil )\n                                    task.fillLevel = task.fillLevel - appliedDelta\n\n                                    -- remove filled pallets\n                                    if pallet:getFillUnitFreeCapacity(fillUnitIndex) < = 0 then\n                                        availablePallets[pallet] = nil\n                                    end\n                                end\n                            end\n\n                            if task.fillLevel > 0.01 then\n                                local asyncCallback = function (_, vehicles, vehicleLoadState, arguments)\n                                    if vehicleLoadState = = VehicleLoadingState.OK then\n                                        for _, vehicle in ipairs(vehicles) do\n                                            vehicle:emptyAllFillUnits( true )\n                                            availablePallets[vehicle] = true\n\n                                            SpecializationUtil.raiseEvent( self , "onFillUnitUnloadPallet" , vehicle)\n                                        end\n\n                                        unloadNext()\n                                    elseif vehicleLoadState = = VehicleLoadingState.NO_SPACE then\n                                            if ignoreWarning = = nil or not ignoreWarning then\n                                                g_currentMission:addIngameNotification(FSBaseMission.INGAME_NOTIFICATION_INFO, spec.texts.unloadNoSpace)\n                                            end\n\n                                            SpecializationUtil.raiseEvent( self , "onFillUnitUnloaded" , false )\n                                            g_server:broadcastEvent( FillUnitUnloadedEvent.new( self , nil , true , false ), false , nil , self )\n                                            spec.unloadingFillUnitsRunning = false\n                                        end\n                                    end\n\n                                    local data = VehicleLoadingData.new()\n                                    data:setFilename(task.filename)\n                                    data:setLoadingPlace(places, usedPlaces, 0.5 , true )\n                                    data:setPropertyState(VehiclePropertyState.OWNED)\n                                    data:setOwnerFarmId( self:getOwnerFarmId())\n\n                                    data:load(asyncCallback)\n                                else\n                                        table.remove(unloadingTasks, 1 )\n                                        unloadNext()\n                                    end\n                                else\n                                        SpecializationUtil.raiseEvent( self , "onFillUnitUnloaded" , true )\n                                        g_server:broadcastEvent( FillUnitUnloadedEvent.new( self , nil , false , true ), false , nil , self )\n                                        spec.unloadingFillUnitsRunning = false\n                                    end\n                                end\n\n                                unloadNext()\n                            end\n                        end\n\n'})}),"\n",(0,t.jsx)(n.h3,{id:"updatealarmtriggers",children:"updateAlarmTriggers"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Description"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Definition"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"updateAlarmTriggers()"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,t.jsx)(n.table,{children:(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"any"}),(0,t.jsx)(n.th,{children:"alarmTriggers"})]})})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Code"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:"function FillUnit:updateAlarmTriggers(alarmTriggers)\n    for _, alarmTrigger in pairs(alarmTriggers) do\n        self:setAlarmTriggerState(alarmTrigger, self:getAlarmTriggerIsActive(alarmTrigger))\n    end\nend\n\n"})}),"\n",(0,t.jsx)(n.h3,{id:"updatefilltypematerials",children:"updateFillTypeMaterials"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Description"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Definition"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"updateFillTypeMaterials()"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"any"}),(0,t.jsx)(n.th,{children:"fillTypeMaterials"})]})}),(0,t.jsx)(n.tbody,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"any"}),(0,t.jsx)(n.td,{children:"fillTypeIndex"})]})})]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Code"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:"function FillUnit:updateFillTypeMaterials(fillTypeMaterials, fillTypeIndex)\n    for i = 1 , #fillTypeMaterials do\n        local fillTypeMaterial = fillTypeMaterials[i]\n        if fillTypeMaterial.fillTypeIndex = = fillTypeIndex then\n            if fillTypeMaterial.refNode ~ = nil then\n                local materialId = getMaterial(fillTypeMaterial.refNode, 0 )\n                setMaterial(fillTypeMaterial.node, materialId, 0 )\n            elseif fillTypeMaterial.materialId ~ = nil then\n                    local newMaterialId = setMaterialDiffuseMapFromFile(fillTypeMaterial.materialId, fillTypeMaterial.diffuse, true , true , false )\n\n                    MaterialUtil.replaceMaterialRec( self.rootNode, fillTypeMaterial.materialId, newMaterialId)\n\n                    fillTypeMaterial.materialId = newMaterialId\n                end\n            end\n        end\n    end\n\n"})}),"\n",(0,t.jsx)(n.h3,{id:"updatefillunitautoaimtarget",children:"updateFillUnitAutoAimTarget"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Description"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Definition"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"updateFillUnitAutoAimTarget()"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,t.jsx)(n.table,{children:(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"any"}),(0,t.jsx)(n.th,{children:"fillUnit"})]})})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Code"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:"function FillUnit:updateFillUnitAutoAimTarget(fillUnit)\n    local autoAimTarget = fillUnit.autoAimTarget\n    if autoAimTarget.node ~ = nil then\n        if autoAimTarget.startZ ~ = nil and autoAimTarget.endZ ~ = nil then\n            local startFillLevel = fillUnit.capacity * autoAimTarget.startPercentage\n            local percent = math.clamp((fillUnit.fillLevel - startFillLevel) / (fillUnit.capacity - startFillLevel), 0 , 1 )\n            if autoAimTarget.invert then\n                percent = 1 - percent\n            end\n            local newZ = (autoAimTarget.endZ - autoAimTarget.startZ) * percent + autoAimTarget.startZ\n            setTranslation(autoAimTarget.node, autoAimTarget.baseTrans[ 1 ], autoAimTarget.baseTrans[ 2 ], newZ)\n        end\n    end\nend\n\n"})}),"\n",(0,t.jsx)(n.h3,{id:"updatefillunitfillplane",children:"updateFillUnitFillPlane"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Description"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Definition"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"updateFillUnitFillPlane()"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,t.jsx)(n.table,{children:(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"any"}),(0,t.jsx)(n.th,{children:"fillUnit"})]})})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Code"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:'function FillUnit:updateFillUnitFillPlane(fillUnit)\n    local fillPlane = fillUnit.fillPlane\n    if fillPlane ~ = nil then\n        local t = self:getFillUnitFillLevelPercentage(fillUnit.fillUnitIndex)\n\n        for _, node in ipairs(fillPlane.nodes) do\n            local x,y,z, rx,ry,rz, sx,sy,sz = node.animCurve:get(t)\n\n            setTranslation(node.node, x, y, z)\n            setRotation(node.node, rx, ry, rz)\n            setScale(node.node, sx, sy, sz)\n            setVisibility(node.node, fillUnit.fillLevel > 0 or node.alwaysVisible)\n        end\n\n        if fillUnit.fillType ~ = fillUnit.lastFillPlaneType then\n            local textureArrayIndex = g_fillTypeManager:getTextureArrayIndexByFillTypeIndex(fillUnit.fillType)\n            if textureArrayIndex ~ = nil then\n                for _, node in ipairs(fillPlane.nodes) do\n                    setShaderParameter(node.node, "fillTypeId" , textureArrayIndex - 1 , 0 , 0 , 0 , false )\n                end\n            end\n        end\n    end\nend\n\n'})}),"\n",(0,t.jsx)(n.h3,{id:"updatefillunittriggers",children:"updateFillUnitTriggers"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Description"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Definition"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"updateFillUnitTriggers()"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Code"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:'function FillUnit:updateFillUnitTriggers()\n    local spec = self.spec_fillUnit\n\n    table.sort(spec.fillTrigger.triggers, function (t1, t2)\n        local fillTypeIndex1 = t1:getCurrentFillType()\n        local fillTypeIndex2 = t2:getCurrentFillType()\n\n        local t1FillUnitIndex = self:getFirstValidFillUnitToFill(fillTypeIndex1)\n        local t2FillUnitIndex = self:getFirstValidFillUnitToFill(fillTypeIndex2)\n\n        if t1FillUnitIndex ~ = nil and t2FillUnitIndex ~ = nil then\n            return self:getFillUnitFillLevel(t1FillUnitIndex) > self:getFillUnitFillLevel(t2FillUnitIndex)\n        elseif t1FillUnitIndex ~ = nil then\n                return true\n            end\n\n            return false\n        end )\n\n        if #spec.fillTrigger.triggers > 0 then\n            local fillTypeIndex = spec.fillTrigger.triggers[ 1 ]:getCurrentFillType()\n            spec.fillTrigger.activatable:setFillType(fillTypeIndex)\n\n            if spec.fillTrigger.selectedTrigger ~ = spec.fillTrigger.triggers[ 1 ] then\n                SpecializationUtil.raiseEvent( self , "onFillUnitTriggerChanged" , spec.fillTrigger.triggers[ 1 ], fillTypeIndex, self:getFirstValidFillUnitToFill(fillTypeIndex), #spec.fillTrigger.triggers)\n\n                spec.fillTrigger.selectedTrigger = spec.fillTrigger.triggers[ 1 ]\n            end\n        else\n                spec.fillTrigger.selectedTrigger = nil\n            end\n        end\n\n'})}),"\n",(0,t.jsx)(n.h3,{id:"updatemeasurementnodes",children:"updateMeasurementNodes"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Description"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Definition"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"updateMeasurementNodes()"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"any"}),(0,t.jsx)(n.th,{children:"fillUnit"})]})}),(0,t.jsxs)(n.tbody,{children:[(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"any"}),(0,t.jsx)(n.td,{children:"dt"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"any"}),(0,t.jsx)(n.td,{children:"setActive"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"any"}),(0,t.jsx)(n.td,{children:"forcedIntensity"})]})]})]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Code"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:'function FillUnit:updateMeasurementNodes(fillUnit, dt, setActive, forcedIntensity)\n    if fillUnit.measurementNodes ~ = nil then\n        for _, measurementNode in pairs(fillUnit.measurementNodes) do\n            if setActive ~ = nil and setActive then\n                measurementNode.measurementTime = 5000\n            end\n\n            if measurementNode.measurementTime > 0 then\n                measurementNode.measurementTime = math.max(measurementNode.measurementTime - dt, 0 )\n            end\n\n            local intensity = math.min(measurementNode.measurementTime / 5000 , 1 )\n            intensity = math.max(intensity, math.min( self.lastSpeed * 3600 / 10 , 1 ))\n            intensity = forcedIntensity or intensity\n            if intensity ~ = measurementNode.intensity then\n                setShaderParameter(measurementNode.node, "fillLevel" , fillUnit.fillLevel / fillUnit.capacity, intensity, 0 , 0 , false )\n                setShaderParameter(measurementNode.node, "prevFillLevel" , fillUnit.fillLevel / fillUnit.capacity, measurementNode.intensity, 0 , 0 , false )\n                measurementNode.intensity = intensity\n            end\n        end\n    end\nend\n\n'})}),"\n",(0,t.jsx)(n.h3,{id:"updateunloadactiondisplay",children:"updateUnloadActionDisplay"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Description"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Definition"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"updateUnloadActionDisplay()"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,t.jsx)(n.table,{children:(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"any"}),(0,t.jsx)(n.th,{children:"self"})]})})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Code"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:"function FillUnit.updateUnloadActionDisplay( self )\n    local spec = self.spec_fillUnit\n    if spec ~ = nil and spec.unloading ~ = nil then\n        local isActive = false\n        for fillUnitIndex, fillUnit in ipairs( self:getFillUnits()) do\n            if fillUnit.canBeUnloaded and self:getFillUnitFillLevel(fillUnitIndex) > 0 then\n                if self:getFillUnitUnloadPalletFilename(fillUnitIndex) ~ = nil then\n                    isActive = true\n                    break\n                end\n            end\n        end\n\n        if self:getFillUnitHasMountedPalletsToUnload() then\n            isActive = true\n        end\n\n        if self.getCurrentDischargeNode ~ = nil then\n            local dischargeNode = self:getCurrentDischargeNode()\n            if dischargeNode ~ = nil then\n                local dischargeObject, _ = self:getDischargeTargetObject(dischargeNode)\n                if dischargeObject ~ = nil then\n                    isActive = false\n                end\n            end\n        end\n\n        g_inputBinding:setActionEventActive(spec.unloadActionEventId, isActive)\n    end\nend\n\n"})})]})}function h(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(o,{...e})}):o(e)}}}]);