"use strict";(globalThis.webpackChunkfs25_community_luadoc=globalThis.webpackChunkfs25_community_luadoc||[]).push([[20383],{28453(e,n,t){t.d(n,{R:()=>r,x:()=>i});var l=t(96540);const s={},a=l.createContext(s);function r(e){const n=l.useContext(a);return l.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function i(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:r(e.components),l.createElement(a.Provider,{value:n},e.children)}},73230(e,n,t){t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>i,default:()=>h,frontMatter:()=>r,metadata:()=>l,toc:()=>d});const l=JSON.parse('{"id":"script/Wheels/WheelEffects","title":"WheelEffects","description":"WheelEffects","source":"@site/../docs/script/Wheels/WheelEffects.md","sourceDirName":"script/Wheels","slug":"/script/Wheels/WheelEffects","permalink":"/FS25-Community-LUADOC/script/Wheels/WheelEffects","draft":false,"unlisted":false,"tags":[],"version":"current","lastUpdatedAt":1767161192000,"frontMatter":{},"sidebar":"docsSidebar","previous":{"title":"WheelDestruction","permalink":"/FS25-Community-LUADOC/script/Wheels/WheelDestruction"},"next":{"title":"WheelManager","permalink":"/FS25-Community-LUADOC/script/Wheels/WheelManager"}}');var s=t(74848),a=t(28453);const r={},i=void 0,c={},d=[{value:"WheelEffects",id:"wheeleffects",level:2},{value:"addWaterEffectsToPhysicsData",id:"addwatereffectstophysicsdata",level:3},{value:"delete",id:"delete",level:3},{value:"finalize",id:"finalize",level:3},{value:"getDriveGroundParticleSystemsScale",id:"getdrivegroundparticlesystemsscale",level:3},{value:"loadFromXML",id:"loadfromxml",level:3},{value:"new",id:"new",level:3},{value:"onUpdateEnd",id:"onupdateend",level:3},{value:"onWheelParticleSystemI3DLoaded",id:"onwheelparticlesystemi3dloaded",level:3},{value:"onWheelWaterEffectI3DLoaded",id:"onwheelwatereffecti3dloaded",level:3},{value:"registerXMLPaths",id:"registerxmlpaths",level:3},{value:"removeWaterEffects",id:"removewatereffects",level:3},{value:"update",id:"update",level:3},{value:"updateTick",id:"updatetick",level:3}];function o(e){const n={a:"a",blockquote:"blockquote",code:"code",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,a.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.h2,{id:"wheeleffects",children:"WheelEffects"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"Handles wheel visual effects (tire tracks, particles, shallow water)"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Functions"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#addwatereffectstophysicsdata",children:"addWaterEffectsToPhysicsData"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#delete",children:"delete"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#finalize",children:"finalize"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#getdrivegroundparticlesystemsscale",children:"getDriveGroundParticleSystemsScale"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#loadfromxml",children:"loadFromXML"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#new",children:"new"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#onupdateend",children:"onUpdateEnd"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#onwheelparticlesystemi3dloaded",children:"onWheelParticleSystemI3DLoaded"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#onwheelwatereffecti3dloaded",children:"onWheelWaterEffectI3DLoaded"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#registerxmlpaths",children:"registerXMLPaths"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#removewatereffects",children:"removeWaterEffects"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#update",children:"update"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#updatetick",children:"updateTick"})}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"addwatereffectstophysicsdata",children:"addWaterEffectsToPhysicsData"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Definition"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"addWaterEffectsToPhysicsData()"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Code"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:"function WheelEffects:addWaterEffectsToPhysicsData()\n    self.hasWaterParticles = true\n\n    local args = { }\n    args.wheelNode = self.wheel.driveNode\n    args.width = self.wheel.physics.width\n    args.radius = self.wheel.physics.radius\n    local sharedLoadRequestId = self.vehicle:loadSubSharedI3DFile( WheelEffects.WATER_EFFECTS, false , false , self.onWheelWaterEffectI3DLoaded, self , args)\n    table.insert( self.sharedLoadRequestIds, sharedLoadRequestId)\nend\n\n"})}),"\n",(0,s.jsx)(n.h3,{id:"delete",children:"delete"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Definition"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"delete()"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Code"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:"function WheelEffects:delete()\n    for _, particleSystem in pairs( self.driveGroundParticleSystems) do\n        ParticleUtil.deleteParticleSystem(particleSystem)\n    end\n\n    for _, sharedLoadRequestId in ipairs( self.sharedLoadRequestIds) do\n        g_i3DManager:releaseSharedI3DFile(sharedLoadRequestId)\n    end\n    self.sharedLoadRequestIds = { }\n\n    self:removeWaterEffects()\nend\n\n"})}),"\n",(0,s.jsx)(n.h3,{id:"finalize",children:"finalize"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Definition"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"finalize()"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Code"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:"function WheelEffects:finalize()\n    for _, visualWheel in ipairs( self.wheel.visualWheels) do\n        if self.hasParticles then\n            for name, state in pairs( WheelEffects.PARTICLE_SYSTEM_STATES) do\n                local sourceParticleSystem = g_particleSystemManager:getParticleSystem(name)\n                if sourceParticleSystem ~ = nil then\n                    local args = { }\n                    args.name = name\n                    args.state = state\n                    args.wheelNode = visualWheel.node\n                    args.width = visualWheel.width\n                    args.radius = visualWheel.radius\n                    args.sourceParticleSystem = sourceParticleSystem\n                    args.sizeScale = 2 * visualWheel.width * visualWheel.radius\n\n                    local sharedLoadRequestId = self.vehicle:loadSubSharedI3DFile( WheelEffects.PARTICLE_SYSTEM_PATH, false , false , self.onWheelParticleSystemI3DLoaded, self , args)\n                    table.insert( self.sharedLoadRequestIds, sharedLoadRequestId)\n                end\n            end\n        end\n\n        if self.hasWaterParticles ~ = false then\n            local args = { }\n            args.wheelNode = visualWheel.node\n            args.width = visualWheel.width\n            args.radius = visualWheel.radius\n\n            local sharedLoadRequestId = self.vehicle:loadSubSharedI3DFile( WheelEffects.WATER_EFFECTS, false , false , self.onWheelWaterEffectI3DLoaded, self , args)\n            table.insert( self.sharedLoadRequestIds, sharedLoadRequestId)\n        end\n\n        if self.hasTireTracks and Platform.gameplay.wheelTireTracks then\n            self.tireTrackNodeIndex = self.vehicle:addTireTrackNode( self.wheel, self.wheel.driveNodeDirectionNode, visualWheel.node, self.tireTrackAtlasIndex, visualWheel.width, visualWheel.radius, visualWheel:getIsTireInverted())\n            self.wheel.syncContactState = true\n        end\n\n        if self.isShallowWaterObstacle then\n            visualWheel:addShallowWaterObstacle()\n        end\n    end\n\n    -- if we don't have any visual wheel, we attach the effects to the physical wheel(crawlers etc.)\n        if # self.wheel.visualWheels = = 0 then\n            if self.hasParticles then\n                for name, state in pairs( WheelEffects.PARTICLE_SYSTEM_STATES) do\n                    local sourceParticleSystem = g_particleSystemManager:getParticleSystem(name)\n                    if sourceParticleSystem ~ = nil then\n                        local args = { }\n                        args.name = name\n                        args.state = state\n                        args.wheelNode = self.wheel.driveNode\n                        args.width = self.wheel.physics.width\n                        args.radius = self.wheel.physics.radius\n                        args.sourceParticleSystem = sourceParticleSystem\n                        args.sizeScale = 2 * self.wheel.physics.width * self.wheel.physics.radius\n\n                        local sharedLoadRequestId = self.vehicle:loadSubSharedI3DFile( WheelEffects.PARTICLE_SYSTEM_PATH, false , false , self.onWheelParticleSystemI3DLoaded, self , args)\n                        table.insert( self.sharedLoadRequestIds, sharedLoadRequestId)\n                    end\n                end\n            end\n\n            if self.hasWaterParticles = = true then\n                self:addWaterEffectsToPhysicsData()\n            end\n\n            if self.hasTireTracks and Platform.gameplay.wheelTireTracks then\n                self.tireTrackNodeIndex = self.vehicle:addTireTrackNode( self.wheel, self.wheel.driveNodeDirectionNode, self.wheel.driveNode, self.tireTrackAtlasIndex, self.wheel.physics.width, self.wheel.physics.radius, false )\n                self.wheel.syncContactState = true\n            end\n        end\n    end\n\n"})}),"\n",(0,s.jsx)(n.h3,{id:"getdrivegroundparticlesystemsscale",children:"getDriveGroundParticleSystemsScale"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Definition"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"getDriveGroundParticleSystemsScale()"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"any"}),(0,s.jsx)(n.th,{children:"particleSystem"})]})}),(0,s.jsx)(n.tbody,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"any"}),(0,s.jsx)(n.td,{children:"speed"})]})})]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Code"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:"function WheelEffects:getDriveGroundParticleSystemsScale(particleSystem, speed)\n    local wheel = self.wheel\n\n    if not wheel.physics.hasSnowContact then\n        if self.onlyActiveOnGroundContact and wheel.physics.contact ~ = WheelContactType.GROUND then\n            return 0\n        end\n\n        if not WheelEffects.GROUND_PARTICLES[wheel.physics.lastTerrainAttribute] then\n            return 0\n        end\n\n        if wheel.physics.densityType = = FieldGroundType.GRASS then\n            return 0\n        end\n    end\n\n    local minSpeed = self.minSpeed\n    local direction = self.direction\n    if speed > minSpeed and(direction = = 0 or(direction > 0 ) = = ( self.vehicle.movingDirection > 0 )) then\n        local maxSpeed = self.maxSpeed\n        local alpha = math.min((speed - minSpeed) / (maxSpeed - minSpeed), 1 )\n        local scale = MathUtil.lerp( self.minScale, self.maxScale, alpha)\n        return scale\n    end\n\n    return 0\nend\n\n"})}),"\n",(0,s.jsx)(n.h3,{id:"loadfromxml",children:"loadFromXML"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Definition"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"loadFromXML()"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,s.jsx)(n.table,{children:(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"any"}),(0,s.jsx)(n.th,{children:"xmlObject"})]})})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Code"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:'function WheelEffects:loadFromXML(xmlObject)\n    self.hasTireTracks = xmlObject:getValue( "#hasTireTracks" , false )\n    self.hasParticles = xmlObject:getValue( "#hasParticles" , false )\n    self.hasWaterParticles = xmlObject:getValue( "#hasWaterParticles" )\n    self.waterParticleDirection = xmlObject:getValue( "#waterParticleDirection" , 0 )\n    self.isShallowWaterObstacle = xmlObject:getValue( "#isShallowWaterObstacle" , true )\n\n    self.tireTrackAtlasIndex = xmlObject:getValue( ".tire#tireTrackAtlasIndex" , 0 )\n\n    self.offset = xmlObject:getValue( ".wheelParticleSystem#psOffset" , "0 0 0" , true )\n    self.minSpeed = xmlObject:getValue( ".wheelParticleSystem#minSpeed" , 3 ) / 3600\n    self.maxSpeed = xmlObject:getValue( ".wheelParticleSystem#maxSpeed" , 20 ) / 3600\n    self.minScale = xmlObject:getValue( ".wheelParticleSystem#minScale" , 0.1 )\n    self.maxScale = xmlObject:getValue( ".wheelParticleSystem#maxScale" , 1 )\n    self.direction = xmlObject:getValue( ".wheelParticleSystem#direction" , 0 )\n    self.onlyActiveOnGroundContact = xmlObject:getValue( ".wheelParticleSystem#onlyActiveOnGroundContact" , true )\n\n    return true\nend\n\n'})}),"\n",(0,s.jsx)(n.h3,{id:"new",children:"new"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Definition"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"new()"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,s.jsx)(n.table,{children:(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"any"}),(0,s.jsx)(n.th,{children:"wheel"})]})})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Code"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:"function WheelEffects.new(wheel)\n    local self = setmetatable( { } , { __index = WheelEffects } )\n\n    self.wheel = wheel\n    self.vehicle = wheel.vehicle\n\n    self.sharedLoadRequestIds = { }\n    self.driveGroundParticleSystems = { }\n\n    self.waterEffects = { }\n    self.waterEffectsLoaded = false\n    self.waterEffectsActive = false\n    self.waterEffectScale = 0\n    self.waterEffectReferenceRadius = nil\n    self.speedSmooth = 0\n    self.wheelSpeedSmooth = 0\n\n    return self\nend\n\n"})}),"\n",(0,s.jsx)(n.h3,{id:"onupdateend",children:"onUpdateEnd"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Definition"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"onUpdateEnd()"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,s.jsx)(n.table,{children:(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"any"}),(0,s.jsx)(n.th,{children:"dt"})]})})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Code"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:"function WheelEffects:onUpdateEnd(dt)\n    for _, particleSystem in ipairs( self.driveGroundParticleSystems) do\n        ParticleUtil.setEmittingState(particleSystem, false )\n    end\nend\n\n"})}),"\n",(0,s.jsx)(n.h3,{id:"onwheelparticlesystemi3dloaded",children:"onWheelParticleSystemI3DLoaded"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"Called when wheel particle i3d was loaded"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Definition"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"onWheelParticleSystemI3DLoaded(integer i3dNode, table args, )"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"integer"}),(0,s.jsx)(n.th,{children:"i3dNode"}),(0,s.jsx)(n.th,{children:"i3dNode of wheel chock"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"table"}),(0,s.jsx)(n.td,{children:"args"}),(0,s.jsx)(n.td,{children:"arguments"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"any"}),(0,s.jsx)(n.td,{children:"args"}),(0,s.jsx)(n.td,{})]})]})]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Code"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:'function WheelEffects:onWheelParticleSystemI3DLoaded(i3dNode, failedReason, args)\n    if i3dNode ~ = 0 then\n        local emitterShape = getChildAt(i3dNode, 0 )\n        link( self.wheel.repr, emitterShape)\n        delete(i3dNode)\n\n        local particleSystem = ParticleUtil.copyParticleSystem( nil , nil , args.sourceParticleSystem, emitterShape)\n        particleSystem.state = args.state\n        particleSystem.i3dFilename = args.i3dFilename\n        particleSystem.particleSpeed = ParticleUtil.getParticleSystemSpeed(particleSystem)\n        particleSystem.particleRandomSpeed = ParticleUtil.getParticleSystemSpeedRandom(particleSystem)\n        particleSystem.sizeScale = args.sizeScale\n        particleSystem.alpha = 0\n\n        particleSystem.isTintable = Utils.getNoNil(getUserAttribute(particleSystem.shape, "tintable" ), true )\n\n        local wx, wy, wz = worldToLocal( self.wheel.repr, getWorldTranslation(args.wheelNode))\n        setTranslation(particleSystem.emitterShape, wx + self.offset[ 1 ], wy + self.offset[ 2 ], wz + self.offset[ 3 ])\n        setRotation(particleSystem.emitterShape, localRotationToLocal(args.wheelNode, getParent(particleSystem.emitterShape), 0 , 0 , 0 ))\n        setScale(particleSystem.emitterShape, args.width, args.radius * 2 , args.radius * 2 )\n\n        table.insert( self.driveGroundParticleSystems, particleSystem)\n    end\nend\n\n'})}),"\n",(0,s.jsx)(n.h3,{id:"onwheelwatereffecti3dloaded",children:"onWheelWaterEffectI3DLoaded"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Definition"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"onWheelWaterEffectI3DLoaded()"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"any"}),(0,s.jsx)(n.th,{children:"i3dNode"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"any"}),(0,s.jsx)(n.td,{children:"failedReason"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"any"}),(0,s.jsx)(n.td,{children:"wheelData"})]})]})]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Code"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:'function WheelEffects:onWheelWaterEffectI3DLoaded(i3dNode, failedReason, wheelData)\n    if i3dNode ~ = 0 and self.hasWaterParticles ~ = false then\n        local waterFront = getChildAt(i3dNode, 0 )\n        local waterFrontFoam = getChildAt(i3dNode, 1 )\n        local waterBack = getChildAt(i3dNode, 2 )\n        local waterBackFoam = getChildAt(i3dNode, 3 )\n\n        local waterEffectNode = createTransformGroup( "waterEffectNode" )\n        link( self.wheel.node, waterEffectNode)\n        setWorldTranslation(waterEffectNode, getWorldTranslation(wheelData.wheelNode))\n        setWorldRotation(waterEffectNode, getWorldRotation(wheelData.wheelNode))\n\n        local waterEffect = { }\n        waterEffect.wheelData = wheelData\n        waterEffect.waterEffectNode = waterEffectNode\n\n        waterEffect.waterFront = waterFront\n        waterEffect.waterFrontFoam = waterFrontFoam\n        waterEffect.waterBack = waterBack\n        waterEffect.waterBackFoam = waterBackFoam\n\n        link(waterEffectNode, waterFront)\n        link(waterEffectNode, waterFrontFoam)\n        link(waterEffectNode, waterBack)\n        link(waterEffectNode, waterBackFoam)\n\n        setTranslation(waterFront, 0 , 0 , wheelData.radius * 0.65 )\n        setTranslation(waterFrontFoam, 0 , 0 , wheelData.radius * 0.65 )\n        setTranslation(waterBack, 0 , 0 , - wheelData.radius * 0.35 )\n        setTranslation(waterBackFoam, 0 , 0 , - wheelData.radius * 0.35 )\n\n        local baseDensity = math.min(wheelData.radius * wheelData.width, 1 )\n        setShaderParameter(waterFront, "fadeProgress" , nil , nil , baseDensity, 0 , false )\n        setShaderParameter(waterFrontFoam, "fadeProgress" , nil , nil , baseDensity, 0 , false )\n        setShaderParameter(waterBack, "fadeProgress" , nil , nil , baseDensity, 0 , false )\n        setShaderParameter(waterBackFoam, "fadeProgress" , nil , nil , baseDensity, 0 , false )\n\n        setVisibility(waterEffectNode, false )\n        self.waterEffectsActive = false\n\n        table.insert( self.waterEffects, waterEffect)\n        self.waterEffectsLoaded = true\n\n        delete(i3dNode)\n    end\nend\n\n'})}),"\n",(0,s.jsx)(n.h3,{id:"registerxmlpaths",children:"registerXMLPaths"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Definition"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"registerXMLPaths()"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"any"}),(0,s.jsx)(n.th,{children:"schema"})]})}),(0,s.jsx)(n.tbody,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"any"}),(0,s.jsx)(n.td,{children:"key"})]})})]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Code"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:'function WheelEffects.registerXMLPaths(schema, key)\n    schema:register(XMLValueType.BOOL, key .. "#hasTireTracks" , "Has tire tracks" , false )\n    schema:register(XMLValueType.BOOL, key .. "#hasParticles" , "Has particles" , false )\n    schema:register(XMLValueType.BOOL, key .. "#hasWaterParticles" , "Has water particles" , "true if visual wheel is defined" )\n        schema:register(XMLValueType.INT, key .. "#waterParticleDirection" , "The direction in which the water particles should only be active(0:both, 1:only the front, -1:only the back)" , 0 )\n        schema:register(XMLValueType.BOOL, key .. "#isShallowWaterObstacle" , "The visual wheels will interact with the shallow water simulation" , true )\n\n        schema:register(XMLValueType.FLOAT, key .. ".tire#tireTrackAtlasIndex" , "Tire track atlas index" , 0 )\n\n        schema:register(XMLValueType.VECTOR_TRANS, key .. ".wheelParticleSystem#psOffset" , "Translation offset" , "0 0 0" )\n        schema:register(XMLValueType.FLOAT, key .. ".wheelParticleSystem#minSpeed" , "Min.speed for activation" , 3 )\n            schema:register(XMLValueType.FLOAT, key .. ".wheelParticleSystem#maxSpeed" , "Max.speed for activation" , 20 )\n                schema:register(XMLValueType.FLOAT, key .. ".wheelParticleSystem#minScale" , "Min.scale" , 0.1 )\n                schema:register(XMLValueType.FLOAT, key .. ".wheelParticleSystem#maxScale" , "Max.scale" , 1 )\n                schema:register(XMLValueType.INT, key .. ".wheelParticleSystem#direction" , "Moving direction for activation" , 0 )\n                    schema:register(XMLValueType.BOOL, key .. ".wheelParticleSystem#onlyActiveOnGroundContact" , "Only active while wheel has ground contact" , true )\n                    end\n\n'})}),"\n",(0,s.jsx)(n.h3,{id:"removewatereffects",children:"removeWaterEffects"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Definition"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"removeWaterEffects()"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Code"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:"function WheelEffects:removeWaterEffects()\n    for _, waterEffect in ipairs( self.waterEffects) do\n        delete(waterEffect.waterEffectNode)\n    end\n\n    self.waterEffects = { }\n    self.waterEffectsLoaded = false\n    self.hasWaterParticles = false\nend\n\n"})}),"\n",(0,s.jsx)(n.h3,{id:"update",children:"update"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Definition"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"update()"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"any"}),(0,s.jsx)(n.th,{children:"dt"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"any"}),(0,s.jsx)(n.td,{children:"groundWetness"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"any"}),(0,s.jsx)(n.td,{children:"currentUpdateIndex"})]})]})]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Code"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:'function WheelEffects:update(dt, groundWetness, currentUpdateIndex)\n    if not self.waterEffectsLoaded then\n        return\n    end\n\n    local physics = self.wheel.physics\n\n    if VehicleDebug.wheelEffectDebugState then\n        physics.hasWaterContact = true\n        physics.netInfo.lastSpeedSmoothed = 20 / 3600\n        self.waterEffectScale = 1\n        self.vehicle.lastSpeedSmoothed = 20 / 3600\n    end\n\n    if physics.hasWaterContact then\n        self.waterEffectScale = math.min( self.waterEffectScale + dt * WheelEffects.WATER_EFFECT_FADE_IN_TIME, 1 )\n    else\n            self.waterEffectScale = math.max( self.waterEffectScale - dt * WheelEffects.WATER_EFFECT_FADE_OUT_TIME, 0 )\n        end\n\n        local isActive = self.waterEffectScale > 0 and physics.lastContactX ~ = nil\n        if isActive then\n            local contactX, contactY, contactZ = physics.lastContactX, physics.lastContactY, physics.lastContactZ\n\n            -- exclude the shop\n            if contactY > 0 then\n                local terrainHeight = getTerrainHeightAtWorldPos(g_terrainNode, contactX, 0 , contactZ)\n                contactY = math.max(contactY, terrainHeight)\n            end\n\n            local direction = 1\n            if physics.netInfo.lastSpeedSmoothed < - 0.000277 then\n                direction = - 1\n            end\n\n            local speed = self.vehicle.lastSpeedSmoothed * 3600\n            local wheelSpeed = math.abs(physics.netInfo.lastSpeedSmoothed) * 3600\n\n            local slipScale = 1 + physics.netInfo.slip\n\n            local densityFront = math.max( math.min((speed - 1 ) / 11 , 1 ), 0 ) * self.waterEffectScale\n            local densityFrontFoam = math.max( math.min((speed - 11 ) / 21 * math.min(slipScale, 2 ), 1 ), 0 ) * self.waterEffectScale\n            local densityBack = math.max( math.min((wheelSpeed - 1 ) / 11 , 1 ), 0 ) * self.waterEffectScale\n            local densityBackFoam = math.max( math.min((wheelSpeed - 11 ) / 21 * math.min(slipScale, 2 ), 1 ), 0 ) * self.waterEffectScale\n\n            if self.waterParticleDirection ~ = 0 then\n                if ( self.waterParticleDirection > 0 ) = = (direction > 0 ) then\n                    densityBack = 0\n                    densityBackFoam = 0\n                else\n                        densityFront = 0\n                        densityFrontFoam = 0\n                    end\n                end\n\n                for _, waterEffect in ipairs( self.waterEffects) do\n                    if not self.waterEffectsActive then\n                        setVisibility(waterEffect.waterEffectNode, true )\n                    end\n\n                    local offsetX, _, offsetZ = localToLocal(waterEffect.wheelData.wheelNode, self.wheel.node, 0 , 0 , 0 )\n                    local _, offsetY, _ = worldToLocal( self.wheel.node, contactX, contactY, contactZ)\n                    setTranslation(waterEffect.waterEffectNode, offsetX, offsetY, offsetZ)\n\n                    local nx, _, nz = getWorldTranslation(waterEffect.waterEffectNode)\n\n                    local tx, tz\n                    if physics.useReprDirection or physics.useDriveNodeDirection or physics.rotSpeed ~ = 0 then\n                        local offsetX, offsetY, offsetZ = localToLocal(waterEffect.waterEffectNode, self.wheel.driveNodeDirectionNode, 0 , 0 , 0 )\n                        tx, _, tz = localToWorld( self.wheel.driveNodeDirectionNode, offsetX, offsetY, offsetZ - direction * 0.25 )\n                    else\n                            local offsetX, offsetY, offsetZ = localToLocal(waterEffect.waterEffectNode, self.wheel.node, 0 , 0 , 0 )\n                            tx, _, tz = localToWorld( self.wheel.node, offsetX, offsetY, offsetZ - direction * 0.25 )\n                        end\n\n                        if waterEffect.worldTargetPosition = = nil then\n                            waterEffect.worldTargetPosition = { tx, tz }\n                        end\n\n                        waterEffect.worldTargetPosition[ 1 ] = waterEffect.worldTargetPosition[ 1 ] * 0.8 + tx * 0.2\n                        waterEffect.worldTargetPosition[ 2 ] = waterEffect.worldTargetPosition[ 2 ] * 0.8 + tz * 0.2\n\n                        local dx, dz = nx - waterEffect.worldTargetPosition[ 1 ], nz - waterEffect.worldTargetPosition[ 2 ]\n\n                        local length = MathUtil.vector3Length(dx, 0 , dz)\n                        if length > 0 then\n                            dx, dz = dx / length, dz / length\n\n                            local dy\n                            dx, dy, dz = worldDirectionToLocal(getParent(waterEffect.waterEffectNode), dx, 0 , dz)\n                            local upX, upY, upZ = worldDirectionToLocal(getParent(waterEffect.waterEffectNode), 0 , 1 , 0 )\n                            setDirection(waterEffect.waterEffectNode, dx, dy, dz, upX, upY, upZ)\n                        end\n\n                        if VehicleDebug.wheelEffectDebugState then\n                            local _, ny, _ = getWorldTranslation(waterEffect.waterEffectNode)\n                            drawDebugLine(nx, ny + 2 , nz, 1 , 0 , 0 , waterEffect.worldTargetPosition[ 1 ], ny + 2 , waterEffect.worldTargetPosition[ 2 ], 1 , 0 , 0 , true )\n                        end\n\n                        local radius = self.waterEffectReferenceRadius or waterEffect.wheelData.radius\n                        local scaleFront = radius * math.max( math.min(speed / 25 , 1 ), 0.25 )\n                        local scaleBack = radius * math.max( math.min((wheelSpeed * math.min(slipScale, 3 )) / 25 , 1 ), 0.25 )\n\n                        local scaleX = waterEffect.wheelData.width * 1.2\n\n                        setScale(waterEffect.waterFront, scaleX, scaleFront, scaleFront)\n                        setScale(waterEffect.waterFrontFoam, scaleX, scaleFront, scaleFront)\n                        setScale(waterEffect.waterBack, scaleX, scaleBack, scaleBack)\n                        setScale(waterEffect.waterBackFoam, scaleX, scaleBack, scaleBack)\n\n                        setShaderParameter(waterEffect.waterFront, "density" , densityFront, nil , nil , nil , false )\n                        setShaderParameter(waterEffect.waterFrontFoam, "density" , densityFrontFoam, nil , nil , nil , false )\n                        setShaderParameter(waterEffect.waterBack, "density" , densityBack, nil , nil , nil , false )\n                        setShaderParameter(waterEffect.waterBackFoam, "density" , densityBackFoam, nil , nil , nil , false )\n                    end\n                else\n                        if self.waterEffectsActive then\n                            for _, waterEffect in ipairs( self.waterEffects) do\n                                setVisibility(waterEffect.waterEffectNode, false )\n                            end\n                        end\n                    end\n\n                    self.waterEffectsActive = isActive\n                end\n\n'})}),"\n",(0,s.jsx)(n.h3,{id:"updatetick",children:"updateTick"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Definition"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"updateTick()"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"any"}),(0,s.jsx)(n.th,{children:"dt"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"any"}),(0,s.jsx)(n.td,{children:"groundWetness"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"any"}),(0,s.jsx)(n.td,{children:"currentUpdateDistance"})]})]})]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Code"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:'function WheelEffects:updateTick(dt, groundWetness, currentUpdateDistance)\n    if currentUpdateDistance > WheelEffects.MAX_UPDATE_DISTANCE then\n        return\n    end\n\n    local physics = self.wheel.physics\n    local groundColor = physics.groundColor\n\n    -- update particle systems\n    local enableSoilPS, hasSnowContact = physics.hasSoilContact, physics.hasSnowContact\n\n    local state = 0\n    if hasSnowContact then\n        state = WheelEffects.PARTICLE_SYSTEM_STATES.WHEEL_SNOW\n    elseif enableSoilPS then\n            if groundWetness > 0.2 then\n                state = WheelEffects.PARTICLE_SYSTEM_STATES.WHEEL_WET\n            else\n                    state = WheelEffects.PARTICLE_SYSTEM_STATES.WHEEL_DRY\n                end\n            elseif groundWetness < = 0.2 then\n                    state = WheelEffects.PARTICLE_SYSTEM_STATES.WHEEL_DUST\n                end\n\n                local wheelSpeed = physics.netInfo.lastSpeedSmoothed\n                local wheelSlip = 1 + physics.netInfo.slip\n\n                for _, particleSystem in ipairs( self.driveGroundParticleSystems) do\n                    if particleSystem.state = = state then\n                        local scale = 0\n                        if particleSystem.state ~ = WheelEffects.PARTICLE_SYSTEM_STATES.WHEEL_DUST then\n                            scale = self:getDriveGroundParticleSystemsScale(particleSystem, wheelSpeed) * wheelSlip\n                        else\n                                scale = self:getDriveGroundParticleSystemsScale(particleSystem, self.vehicle.lastSpeedSmoothed)\n                            end\n\n                            if particleSystem.isTintable then\n                                -- interpolate between different ground colors to avoid unrealisitic particle color changes\n                                if particleSystem.lastColor = = nil then\n                                    particleSystem.lastColor = { groundColor[ 1 ], groundColor[ 2 ], groundColor[ 3 ] }\n                                    particleSystem.targetColor = { groundColor[ 1 ], groundColor[ 2 ], groundColor[ 3 ] }\n                                    particleSystem.currentColor = { groundColor[ 1 ], groundColor[ 2 ], groundColor[ 3 ] }\n                                    particleSystem.alpha = 1\n                                end\n\n                                if particleSystem.alpha ~ = 1 then\n                                    particleSystem.alpha = math.min(particleSystem.alpha + dt * 0.001 , 1 )\n                                    local r,g,b = MathUtil.vector3ArrayLerp(particleSystem.lastColor, particleSystem.targetColor, particleSystem.alpha)\n                                    particleSystem.currentColor[ 1 ] = r\n                                    particleSystem.currentColor[ 2 ] = g\n                                    particleSystem.currentColor[ 3 ] = b\n                                    if particleSystem.alpha = = 1 then\n                                        particleSystem.lastColor[ 1 ] = particleSystem.currentColor[ 1 ]\n                                        particleSystem.lastColor[ 2 ] = particleSystem.currentColor[ 2 ]\n                                        particleSystem.lastColor[ 3 ] = particleSystem.currentColor[ 3 ]\n                                    end\n                                end\n\n                                if particleSystem.alpha = = 1 and groundColor[ 1 ] ~ = particleSystem.targetColor[ 1 ] and groundColor[ 2 ] ~ = particleSystem.targetColor[ 2 ] and groundColor[ 3 ] ~ = particleSystem.targetColor[ 3 ] then\n                                    particleSystem.alpha = 0\n                                    particleSystem.targetColor[ 1 ] = groundColor[ 1 ]\n                                    particleSystem.targetColor[ 2 ] = groundColor[ 2 ]\n                                    particleSystem.targetColor[ 3 ] = groundColor[ 3 ]\n                                end\n                            end\n\n                            if scale > 0 then\n                                ParticleUtil.setEmittingState(particleSystem, true )\n                                if particleSystem.isTintable then\n                                    I3DUtil.setShaderParameterRec(particleSystem.shape, "colorAlpha" , particleSystem.currentColor[ 1 ], particleSystem.currentColor[ 2 ], particleSystem.currentColor[ 3 ], 1 )\n                                end\n                            else\n                                    ParticleUtil.setEmittingState(particleSystem, false )\n                                end\n\n                                -- emit count\n                                local maxSpeed = ( 50 / 3.6 )\n                                local circum = physics.radiusOriginal\n                                local maxWheelRpm = maxSpeed / circum\n                                local wheelRotFactor = (physics.netInfo.xDriveSpeed or 0 ) / maxWheelRpm\n                                local emitScale = scale * wheelRotFactor * particleSystem.sizeScale\n                                ParticleUtil.setEmitCountScale(particleSystem, math.clamp(emitScale, self.minScale, self.maxScale))\n\n                                -- speed\n                                ParticleUtil.setParticleSystemSpeed(particleSystem, particleSystem.particleSpeed)\n                                ParticleUtil.setParticleSystemSpeedRandom(particleSystem, particleSystem.particleRandomSpeed)\n                            else\n                                    ParticleUtil.setEmittingState(particleSystem, false )\n                                end\n                            end\n                        end\n\n'})})]})}function h(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(o,{...e})}):o(e)}}}]);