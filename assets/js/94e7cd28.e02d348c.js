"use strict";(globalThis.webpackChunkfs25_community_luadoc=globalThis.webpackChunkfs25_community_luadoc||[]).push([[82487],{28453(e,n,t){t.d(n,{R:()=>a,x:()=>d});var i=t(96540);const s={},l=i.createContext(s);function a(e){const n=i.useContext(l);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function d(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:a(e.components),i.createElement(l.Provider,{value:n},e.children)}},69043(e,n,t){t.r(n),t.d(n,{assets:()=>r,contentTitle:()=>d,default:()=>c,frontMatter:()=>a,metadata:()=>i,toc:()=>o});const i=JSON.parse('{"id":"script/Components/StaticLightCompound","title":"StaticLightCompound","description":"StaticLightCompound","source":"@site/../docs/script/Components/StaticLightCompound.md","sourceDirName":"script/Components","slug":"/script/Components/StaticLightCompound","permalink":"/FS25-Community-LUADOC/script/Components/StaticLightCompound","draft":false,"unlisted":false,"tags":[],"version":"current","lastUpdatedAt":1767161192000,"frontMatter":{},"sidebar":"docsSidebar","previous":{"title":"StaticLight","permalink":"/FS25-Community-LUADOC/script/Components/StaticLight"},"next":{"title":"ToolConnectionHoseMount","permalink":"/FS25-Community-LUADOC/script/Components/ToolConnectionHoseMount"}}');var s=t(74848),l=t(28453);const a={},d=void 0,r={},o=[{value:"StaticLightCompound",id:"staticlightcompound",level:2},{value:"loadFromXML",id:"loadfromxml",level:3},{value:"loadFunctionMappingData",id:"loadfunctionmappingdata",level:3},{value:"new",id:"new",level:3},{value:"registerXMLPaths",id:"registerxmlpaths",level:3},{value:"setLightTypes",id:"setlighttypes",level:3},{value:"setLightTypesMask",id:"setlighttypesmask",level:3},{value:"setOverwriteSettings",id:"setoverwritesettings",level:3}];function h(e){const n={a:"a",blockquote:"blockquote",code:"code",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,l.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.h2,{id:"staticlightcompound",children:"StaticLightCompound"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"Class for static light compounds which combine multiple lights into one object and select the function via UV slots"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Functions"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#loadfromxml",children:"loadFromXML"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#loadfunctionmappingdata",children:"loadFunctionMappingData"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#new",children:"new"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#registerxmlpaths",children:"registerXMLPaths"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#setlighttypes",children:"setLightTypes"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#setlighttypesmask",children:"setLightTypesMask"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#setoverwritesettings",children:"setOverwriteSettings"})}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"loadfromxml",children:"loadFromXML"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Definition"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"loadFromXML()"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"any"}),(0,s.jsx)(n.th,{children:"xmlFile"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"any"}),(0,s.jsx)(n.td,{children:"baseKey"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"any"}),(0,s.jsx)(n.td,{children:"components"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"any"}),(0,s.jsx)(n.td,{children:"i3dMappings"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"any"}),(0,s.jsx)(n.td,{children:"vehicle"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"any"}),(0,s.jsx)(n.td,{children:"sharedLight"})]})]})]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Code"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:'function StaticLightCompound:loadFromXML(xmlFile, baseKey, components, i3dMappings, vehicle, sharedLight)\n    self.bottomLightAsHighBeam = xmlFile:getValue(baseKey .. "#bottomLightAsHighBeam" , true )\n    self.topLightAsHighBeam = xmlFile:getValue(baseKey .. "#topLightAsHighBeam" , true )\n\n    self.useSliderTurnLights = xmlFile:getValue(baseKey .. "#useSliderTurnLights" , false )\n\n    self.intensity = { }\n\n    -- default intensity scales by type\n    self.intensity[StaticLightCompoundUVSlot.HIGH_BEAM] = 1.4 -- 25 * 1.4 = 35\n    self.intensity[StaticLightCompoundUVSlot.DAY_TIME_RUNNING_LIGHT] = 0.4 -- 25 * 0.4 = 10\n\n    self.funcToUVSlotMapping = { }\n    for index = 1 , 16 do\n        self.funcToUVSlotMapping[index] = { }\n    end\n\n    local data = StaticLightCompound.loadFunctionMappingData(xmlFile, baseKey)\n    for i, mappingData in ipairs(data) do\n        table.insert( self.funcToUVSlotMapping[mappingData.defaultSlotIndex], mappingData)\n    end\n\n    if sharedLight ~ = nil and sharedLight.functionMappingData ~ = nil then\n        -- clear the mapping data if there is a mapping for this slot already defined in the shared light\n            -- otherwise we just assign multiple functions and are not able to overwrite\n            for _, mappingData in ipairs(sharedLight.functionMappingData) do\n                for mappedFuncIndex, mappedSlots in pairs( self.funcToUVSlotMapping) do\n                    for i = #mappedSlots, 1 , - 1 do\n                        local mappedSlot = mappedSlots[i]\n                        if mappedSlot.uvSlotIndex = = mappingData.uvSlotIndex then\n                            table.remove(mappedSlots, i)\n                        end\n                    end\n                end\n            end\n\n            for i, mappingData in ipairs(sharedLight.functionMappingData) do\n                table.insert( self.funcToUVSlotMapping[mappingData.defaultSlotIndex], mappingData)\n            end\n        end\n\n        -- assign the default function if we don\'t have custom data defined for this slot\n            for index = 1 , 16 do\n                local uvSlotIsUsed = false\n                for mappedFuncIndex, mappedSlots in pairs( self.funcToUVSlotMapping) do\n                    for _, mappedSlot in pairs(mappedSlots) do\n                        if mappedSlot.uvSlotIndex = = index then\n                            uvSlotIsUsed = true\n                            break\n                        end\n                    end\n\n                    if uvSlotIsUsed then\n                        break\n                    end\n                end\n\n                if not uvSlotIsUsed then\n                    table.insert( self.funcToUVSlotMapping[index], { uvSlotIndex = index, uvOffset = 0 , intensityScale = 1 } )\n                end\n            end\n\n            self.nodes = { }\n            for _, nodeKey in xmlFile:iterator(baseKey .. ".node" ) do\n                local node = xmlFile:getValue(nodeKey .. "#node" , nil , components, i3dMappings)\n                if node ~ = nil then\n                    if sharedLight ~ = nil then\n                        local isValid = false\n                        local parent = node\n                        while parent ~ = nil and parent ~ = 0 and parent ~ = getRootNode() do\n                            if parent = = sharedLight.node then\n                                isValid = true\n                                break\n                            end\n\n                            parent = getParent(parent)\n                        end\n\n                        if not isValid then\n                            Logging.xmlWarning(xmlFile, "Static compound light mesh \'%s\' is outside of the root shared light node(%s) in \'%s\'" , getName(node), getName(sharedLight.node), baseKey)\n                            continue\n                        end\n                    end\n\n                    if getHasClassId(node, ClassIds.LIGHT_SOURCE) then\n                        Logging.xmlWarning(xmlFile, "Light source used in static light compound in \'%s\'" , nodeKey)\n                        continue\n                    end\n\n                    if not getHasClassId(node, ClassIds.SHAPE) then\n                        Logging.xmlWarning(xmlFile, "Node used in static light compound in \'%s\' is not a shape" , nodeKey)\n                        continue\n                    end\n\n                    if not getHasShaderParameter(node, "lightIds0" ) then\n                        Logging.xmlWarning(xmlFile, "Wrong shader applied to static light compound in \'%s\'.Missing \'lightIds\' shader parameter." , nodeKey)\n                        continue\n                    else\n                            setShaderParameter(node, "lightIds0" , 0 , 0 , 0 , 0 , false )\n                            setShaderParameter(node, "lightIds1" , 0 , 0 , 0 , 0 , false )\n                            setShaderParameter(node, "lightIds2" , 0 , 0 , 0 , 0 , false )\n                            setShaderParameter(node, "lightIds3" , 0 , 0 , 0 , 0 , false )\n                        end\n\n                        local nodeData = { }\n                        nodeData.node = node\n                        nodeData.intensity = xmlFile:getValue(nodeKey .. "#intensity" , 5 )\n\n                        nodeData.useSliderTurnLights = xmlFile:getValue(nodeKey .. "#useSliderTurnLights" , self.useSliderTurnLights)\n\n                        -- additional attributes are not supported inside shared lights\n                        if vehicle ~ = nil then\n                            if xmlFile:getRootName() = = "vehicle" then\n                                vehicle:loadAdditionalLightAttributesFromXML(xmlFile, nodeKey, nodeData)\n                            end\n                        end\n\n                        if sharedLight ~ = nil then\n                            if sharedLight.additionalAttributes ~ = nil then\n                                for k, v in pairs(sharedLight.additionalAttributes) do\n                                    nodeData[k] = v\n                                end\n                            end\n                        end\n\n                        table.insert( self.nodes, nodeData)\n                    else\n                            Logging.xmlWarning(xmlFile, "Invalid node in \'%s\'" , nodeKey)\n                        end\n                    end\n\n                    if # self.nodes = = 0 then\n                        Logging.xmlWarning(xmlFile, "Missing nodes for static light compound in \'%s\'" , baseKey)\n                            return false\n                        end\n\n                        self.states = { }\n                        self.stateFuncTypes = { }\n                        self.stateLightTypes = { }\n                        self.stateUVOffsets = { }\n                        for i = 1 , 16 do\n                            table.insert( self.states, 0 )\n                            table.insert( self.stateFuncTypes, 0 )\n                            table.insert( self.stateLightTypes, - 1 )\n                            table.insert( self.stateUVOffsets, 0 )\n                        end\n\n                        return true\n                    end\n\n'})}),"\n",(0,s.jsx)(n.h3,{id:"loadfunctionmappingdata",children:"loadFunctionMappingData"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Definition"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"loadFunctionMappingData()"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"any"}),(0,s.jsx)(n.th,{children:"xmlFile"})]})}),(0,s.jsx)(n.tbody,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"any"}),(0,s.jsx)(n.td,{children:"baseKey"})]})})]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Code"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:'function StaticLightCompound.loadFunctionMappingData(xmlFile, baseKey)\n    local data = { }\n    for _, functionKey in xmlFile:iterator(baseKey .. ".function" ) do\n        local functionName = xmlFile:getValue(functionKey .. "#name" )\n        if functionName ~ = nil then\n            local defaultSlotIndex = StaticLightCompoundUVSlot.getByName(functionName)\n            if defaultSlotIndex ~ = nil then\n                local uvSlotIndex = xmlFile:getValue(functionKey .. "#uvSlotIndex" , defaultSlotIndex)\n                if uvSlotIndex > = 1 and uvSlotIndex < = 16 then\n                    local uvOffset = xmlFile:getValue(functionKey .. "#uvOffset" , 0 )\n                    local intensityScale = xmlFile:getValue(functionKey .. "#intensityScale" , 1 )\n\n                    local lightTypeStr = xmlFile:getValue(functionKey .. "#lightType" )\n                    local lightTypeIndex = StaticLightCompoundLightType.getByName(lightTypeStr)\n\n                    table.insert(data, { defaultSlotIndex = defaultSlotIndex, uvSlotIndex = uvSlotIndex, uvOffset = uvOffset, intensityScale = intensityScale, lightTypeIndex = lightTypeIndex } )\n                else\n                        Logging.xmlWarning(xmlFile, "UV slot index out of range \'%d\' in \'%s\'.Range 1-16 is allowed." , uvSlotIndex, functionKey)\n                    end\n                else\n                        Logging.xmlWarning(xmlFile, "Invalid function name \'%s\' in \'%s\'" , functionName, functionKey)\n                        end\n                    else\n                            Logging.xmlWarning(xmlFile, "Missing function name in \'%s\'" , functionKey)\n                            end\n                        end\n\n                        return data\n                    end\n\n'})}),"\n",(0,s.jsx)(n.h3,{id:"new",children:"new"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Definition"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"new()"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"any"}),(0,s.jsx)(n.th,{children:"vehicle"})]})}),(0,s.jsx)(n.tbody,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"any"}),(0,s.jsx)(n.td,{children:"customMt"})]})})]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Code"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:"function StaticLightCompound.new(vehicle, customMt)\n    local self = setmetatable( { } , customMt or StaticLightCompound _mt)\n\n    self.vehicle = vehicle\n\n    return self\nend\n\n"})}),"\n",(0,s.jsx)(n.h3,{id:"registerxmlpaths",children:"registerXMLPaths"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Definition"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"registerXMLPaths()"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"any"}),(0,s.jsx)(n.th,{children:"schema"})]})}),(0,s.jsx)(n.tbody,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"any"}),(0,s.jsx)(n.td,{children:"basePath"})]})})]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Code"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:'function StaticLightCompound.registerXMLPaths(schema, basePath)\n    schema:register(XMLValueType.BOOL, basePath .. "#bottomLightAsHighBeam" , "Use bottom light as high beam as well" , true )\n    schema:register(XMLValueType.BOOL, basePath .. "#topLightAsHighBeam" , "Use top light as high beam as well" , true )\n    schema:register(XMLValueType.BOOL, basePath .. "#useSliderTurnLights" , "Turn lights will work as sliders if set to \'true\'" , false )\n\n        schema:register(XMLValueType.NODE_INDEX, basePath .. ".node(?)#node" , "Static light node" )\n        schema:register(XMLValueType.FLOAT, basePath .. ".node(?)#intensity" , "Intensity for all lights in this node" , 5 )\n            schema:register(XMLValueType.BOOL, basePath .. ".node(?)#useSliderTurnLights" , "Turn lights will work as sliders if set to \'true\'" , false )\n                schema:register(XMLValueType.INT, basePath .. ".node(?)#lightTypeBitMask" , "Custom light type bit mask" )\n\n                schema:register(XMLValueType.STRING, basePath .. ".function (?)#name" , "Function name" , nil , nil , StaticLightCompoundUVSlot.getAllOrderedByName())\n                    schema:register(XMLValueType.INT, basePath .. ".function (?)#uvSlotIndex" , "Custom UV slot index to assign the defined function name" )\n                        schema:register(XMLValueType.INT, basePath .. ".function (?)#uvOffset" , "Vertical UV offset that is used while this light function is active(value range:0-64 -> this represents the height of the texture with a resolution of 1/64).This is used for double usage of certain lights with different colors." , 0 )\n                            schema:register(XMLValueType.FLOAT, basePath .. ".function (?)#intensityScale" , "Custom intensity scale for this light type(is multiplied by the intensity defined in the node)" )\n                                schema:register(XMLValueType.STRING, basePath .. ".function (?)#lightType" , "Name of the light type to use" , nil , nil , StaticLightCompoundLightType.getAllOrderedByName())\n\n                                    schema:register(XMLValueType.INT, basePath .. "#lightTypeBitMask" , "Custom light type bit mask" , "Default mask is \'20480\' with blinking type set for turn light slots 7 & 8" )\n                                    end\n\n'})}),"\n",(0,s.jsx)(n.h3,{id:"setlighttypes",children:"setLightTypes"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Definition"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"setLightTypes()"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"any"}),(0,s.jsx)(n.th,{children:"lightTypes"})]})}),(0,s.jsx)(n.tbody,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"any"}),(0,s.jsx)(n.td,{children:"excludedLightTypes"})]})})]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Code"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:"function StaticLightCompound:setLightTypes(lightTypes, excludedLightTypes)\n    if lightTypes ~ = nil and next(lightTypes) ~ = nil then\n        self.lightTypes = lightTypes\n    end\n\n    if excludedLightTypes ~ = nil and next(excludedLightTypes) ~ = nil then\n        self.excludedLightTypes = excludedLightTypes\n    end\nend\n\n"})}),"\n",(0,s.jsx)(n.h3,{id:"setlighttypesmask",children:"setLightTypesMask"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Definition"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"setLightTypesMask()"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"any"}),(0,s.jsx)(n.th,{children:"lightsTypesMask"})]})}),(0,s.jsx)(n.tbody,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"any"}),(0,s.jsx)(n.td,{children:"vehicle"})]})})]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Code"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:'function StaticLightCompound:setLightTypesMask(lightsTypesMask, vehicle)\n    local startIndex = 1\n    if self.lightTypes ~ = nil then\n        local isActive = false\n        for _, lightType in pairs( self.lightTypes) do\n            if bit32.band(lightsTypesMask, 2 ^ lightType) ~ = 0 then\n                isActive = true\n                break\n            end\n        end\n\n        if isActive and self.excludedLightTypes ~ = nil then\n            for _, excludedLightType in pairs( self.excludedLightTypes) do\n                if bit32.band(lightsTypesMask, 2 ^ excludedLightType) ~ = 0 then\n                    isActive = false\n                    break\n                end\n            end\n        end\n\n        self.states[ 1 ] = isActive and 1 or 0\n\n        if self.turnLightLeft then\n            self.stateFuncTypes[ 1 ] = StaticLightCompoundUVSlot.TURN_LIGHT_LEFT\n        elseif self.turnLightRight then\n                self.stateFuncTypes[ 1 ] = StaticLightCompoundUVSlot.TURN_LIGHT_RIGHT\n            end\n\n            startIndex = 2\n        end\n\n        for index = startIndex, 16 do\n            self.states[index] = 0\n            self.stateFuncTypes[index] = 0\n            self.stateLightTypes[index] = - 1\n            self.stateUVOffsets[index] = 0\n\n            for mappedFuncIndex, mappedSlots in pairs( self.funcToUVSlotMapping) do\n                for _, mappedSlot in pairs(mappedSlots) do\n                    if mappedSlot.uvSlotIndex = = index then\n                        local value = self:getStateValueByFunction(index, mappedFuncIndex, lightsTypesMask, vehicle)\n\n                        if value > 0 then\n                            self.states[index] = value * ( self.intensity[mappedFuncIndex] or 1 ) * mappedSlot.intensityScale\n\n                            -- static light type can never overwrite blinking type(e.g.US back lights that are used as turn light as well)\n                            if self.stateFuncTypes[index] ~ = StaticLightCompoundUVSlot.TURN_LIGHT_LEFT and self.stateFuncTypes[index] ~ = StaticLightCompoundUVSlot.TURN_LIGHT_RIGHT then\n                                self.stateFuncTypes[index] = mappedFuncIndex\n                            end\n\n                            self.stateUVOffsets[index] = mappedSlot.uvOffset\n\n                            if mappedSlot.lightTypeIndex ~ = nil then\n                                self.stateLightTypes[index] = mappedSlot.lightTypeIndex\n                            end\n\n                            break\n                        end\n                    end\n                end\n            end\n        end\n\n        local lightTypesMask = self:getLightTypeMaskFromStates( self.useSliderTurnLights)\n        local lightUvOffsetBitMask = self:getUVOffsetMaskFromStates()\n\n        for i, nodeData in ipairs( self.nodes) do\n            if vehicle:getIsLightActive(nodeData) then\n                local intensity = nodeData.intensity\n                setShaderParameter(nodeData.node, "lightIds0" , self.states[ 1 ] * intensity, self.states[ 2 ] * intensity, self.states[ 3 ] * intensity, self.states[ 4 ] * intensity, false )\n                setShaderParameter(nodeData.node, "lightIds1" , self.states[ 5 ] * intensity, self.states[ 6 ] * intensity, self.states[ 7 ] * intensity, self.states[ 8 ] * intensity, false )\n                setShaderParameter(nodeData.node, "lightIds2" , self.states[ 9 ] * intensity, self.states[ 10 ] * intensity, self.states[ 11 ] * intensity, self.states[ 12 ] * intensity, false )\n                setShaderParameter(nodeData.node, "lightIds3" , self.states[ 13 ] * intensity, self.states[ 14 ] * intensity, self.states[ 15 ] * intensity, self.states[ 16 ] * intensity, false )\n\n                if self.useSliderTurnLights ~ = nodeData.useSliderTurnLights then\n                    local nodeLightTypesMask = self:getLightTypeMaskFromStates(nodeData.useSliderTurnLights)\n                    setShaderParameter(nodeData.node, "lightTypeBitMask" , nodeLightTypesMask, nil , nil , nil , false )\n                else\n                        setShaderParameter(nodeData.node, "lightTypeBitMask" , lightTypesMask, nil , nil , nil , false )\n                    end\n\n                    setShaderParameter(nodeData.node, "lightUvOffsetBitMask" , lightUvOffsetBitMask, nil , nil , nil , false )\n                else\n                        setShaderParameter(nodeData.node, "lightIds0" , 0 , 0 , 0 , 0 , false )\n                        setShaderParameter(nodeData.node, "lightIds1" , 0 , 0 , 0 , 0 , false )\n                        setShaderParameter(nodeData.node, "lightIds2" , 0 , 0 , 0 , 0 , false )\n                        setShaderParameter(nodeData.node, "lightIds3" , 0 , 0 , 0 , 0 , false )\n                    end\n                end\n            end\n\n'})}),"\n",(0,s.jsx)(n.h3,{id:"setoverwritesettings",children:"setOverwriteSettings"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Definition"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"setOverwriteSettings()"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"any"}),(0,s.jsx)(n.th,{children:"turnLightLeft"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"any"}),(0,s.jsx)(n.td,{children:"turnLightRight"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"any"}),(0,s.jsx)(n.td,{children:"reverseLight"})]})]})]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Code"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:"function StaticLightCompound:setOverwriteSettings(turnLightLeft, turnLightRight, reverseLight)\n    self.turnLightLeft = turnLightLeft\n    self.turnLightRight = turnLightRight\n    self.reverseLight = reverseLight\n\n    if turnLightLeft then\n        if self.lightTypes = = nil then\n            self.lightTypes = { }\n        end\n\n        table.insert( self.lightTypes, self.vehicle.spec_lights.additionalLightTypes.turnLightLeft)\n        table.insert( self.lightTypes, self.vehicle.spec_lights.additionalLightTypes.turnLightAny)\n    end\n\n    if turnLightRight then\n        if self.lightTypes = = nil then\n            self.lightTypes = { }\n        end\n\n        table.insert( self.lightTypes, self.vehicle.spec_lights.additionalLightTypes.turnLightRight)\n        table.insert( self.lightTypes, self.vehicle.spec_lights.additionalLightTypes.turnLightAny)\n    end\n\n    if reverseLight then\n        if self.lightTypes = = nil then\n            self.lightTypes = { }\n        end\n\n        table.insert( self.lightTypes, self.vehicle.spec_lights.additionalLightTypes.reverseLight)\n    end\nend\n\n"})})]})}function c(e={}){const{wrapper:n}={...(0,l.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(h,{...e})}):h(e)}}}]);