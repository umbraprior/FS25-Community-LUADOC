"use strict";(globalThis.webpackChunkfs25_community_luadoc=globalThis.webpackChunkfs25_community_luadoc||[]).push([[18980],{28453(e,n,i){i.d(n,{R:()=>a,x:()=>r});var t=i(96540);const s={},l=t.createContext(s);function a(e){const n=t.useContext(l);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:a(e.components),t.createElement(l.Provider,{value:n},e.children)}},84550(e,n,i){i.r(n),i.d(n,{assets:()=>c,contentTitle:()=>r,default:()=>d,frontMatter:()=>a,metadata:()=>t,toc:()=>h});const t=JSON.parse('{"id":"script/Components/BeaconLight","title":"BeaconLight","description":"BeaconLight","source":"@site/../docs/script/Components/BeaconLight.md","sourceDirName":"script/Components","slug":"/script/Components/BeaconLight","permalink":"/FS25-Community-LUADOC/script/Components/BeaconLight","draft":false,"unlisted":false,"tags":[],"version":"current","lastUpdatedAt":1767161192000,"frontMatter":{},"sidebar":"docsSidebar","previous":{"title":"AttacherJointTopArm","permalink":"/FS25-Community-LUADOC/script/Components/AttacherJointTopArm"},"next":{"title":"RealLight","permalink":"/FS25-Community-LUADOC/script/Components/RealLight"}}');var s=i(74848),l=i(28453);const a={},r=void 0,c={},h=[{value:"BeaconLight",id:"beaconlight",level:2},{value:"delete",id:"delete",level:3},{value:"loadFromVehicleXML",id:"loadfromvehiclexml",level:3},{value:"loadFromXML",id:"loadfromxml",level:3},{value:"loadVariationFromXML",id:"loadvariationfromxml",level:3},{value:"new",id:"new",level:3},{value:"onFinished",id:"onfinished",level:3},{value:"onI3DLoaded",id:"oni3dloaded",level:3},{value:"onLightsRealBeaconLightChanged",id:"onlightsrealbeaconlightchanged",level:3},{value:"registerVariationPaths",id:"registervariationpaths",level:3},{value:"registerVehicleXMLPaths",id:"registervehiclexmlpaths",level:3},{value:"registerXMLPaths",id:"registerxmlpaths",level:3},{value:"setCallback",id:"setcallback",level:3},{value:"setIsActive",id:"setisactive",level:3},{value:"setRealLight",id:"setreallight",level:3},{value:"setXMLSettings",id:"setxmlsettings",level:3},{value:"spawnDebugBeacons",id:"spawndebugbeacons",level:3},{value:"update",id:"update",level:3}];function o(e){const n={a:"a",blockquote:"blockquote",code:"code",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,l.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.h2,{id:"beaconlight",children:"BeaconLight"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"Class for beacon lights"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Functions"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#delete",children:"delete"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#loadfromvehiclexml",children:"loadFromVehicleXML"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#loadfromxml",children:"loadFromXML"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#loadvariationfromxml",children:"loadVariationFromXML"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#new",children:"new"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#onfinished",children:"onFinished"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#oni3dloaded",children:"onI3DLoaded"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#onlightsrealbeaconlightchanged",children:"onLightsRealBeaconLightChanged"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#registervariationpaths",children:"registerVariationPaths"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#registervehiclexmlpaths",children:"registerVehicleXMLPaths"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#registerxmlpaths",children:"registerXMLPaths"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#setcallback",children:"setCallback"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#setisactive",children:"setIsActive"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#setreallight",children:"setRealLight"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#setxmlsettings",children:"setXMLSettings"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#spawndebugbeacons",children:"spawnDebugBeacons"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#update",children:"update"})}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"delete",children:"delete"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Definition"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"delete()"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Code"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:"function BeaconLight:delete()\n    if self.node ~ = nil then\n        delete( self.node)\n        self.node = nil\n    end\n\n    if self.sharedLoadRequestId ~ = nil then\n        g_i3DManager:releaseSharedI3DFile( self.sharedLoadRequestId)\n        self.sharedLoadRequestId = nil\n    end\n\n    g_currentMission:removeUpdateable( self )\nend\n\n"})}),"\n",(0,s.jsx)(n.h3,{id:"loadfromvehiclexml",children:"loadFromVehicleXML"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Definition"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"loadFromVehicleXML()"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"any"}),(0,s.jsx)(n.th,{children:"targetTable"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"any"}),(0,s.jsx)(n.td,{children:"xmlFile"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"any"}),(0,s.jsx)(n.td,{children:"key"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"any"}),(0,s.jsx)(n.td,{children:"vehicle"})]})]})]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Code"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:'function BeaconLight.loadFromVehicleXML(targetTable, xmlFile, key, vehicle)\n    local xmlFilename = xmlFile:getValue(key .. "#filename" , nil , vehicle.baseDirectory)\n    if xmlFilename ~ = nil then\n        local linkNode = xmlFile:getValue(key .. "#node" , nil , vehicle.components, vehicle.i3dMappings)\n        if linkNode ~ = nil then\n            local isReference, _, runtimeLoaded = getReferenceInfo(linkNode)\n            if isReference and runtimeLoaded then\n                Logging.xmlWarning(xmlFile, "Beacon light link node \'%s\' is a runtime loaded reference, please load beacon lights only via XML!" , getName(linkNode))\n                return\n            end\n\n            local speed = xmlFile:getValue(key .. "#speed" )\n\n            local realLight = xmlFile:getValue(key .. "#realLight" , nil , vehicle.components, vehicle.i3dMappings)\n            local useRealLights = xmlFile:getValue(key .. "#useRealLights" , realLight = = nil )\n\n            local realLightRangeScale = xmlFile:getValue(key .. "#realLightRange" , 1 )\n            local intensity = xmlFile:getValue(key .. "#intensity" , 1 )\n\n            local mountType = xmlFile:getValue(key .. "#mountType" )\n            local variationName = xmlFile:getValue(key .. "#variationName" )\n\n            local beaconLight = BeaconLight.new(vehicle)\n            beaconLight:setXMLSettings(speed, intensity, mountType, variationName)\n            beaconLight:setRealLight(useRealLights, realLight, realLightRangeScale)\n            beaconLight:setCallback( function (success)\n                if success then\n                    table.insert(targetTable, beaconLight)\n                end\n            end )\n\n            beaconLight:loadFromXML(linkNode, xmlFilename, vehicle.baseDirectory)\n\n            return beaconLight\n        else\n                Logging.xmlWarning(xmlFile, "Missing link node for beacon light in \'%s\'" , key)\n                end\n            else\n                    local hasDynamicStaticLights = false\n\n                    local staticLights = { }\n                    for _, staticLightKey in xmlFile:iterator(key .. ".staticLight" ) do\n                        local staticLight = { }\n                        staticLight.node = xmlFile:getValue(staticLightKey .. "#node" , nil , vehicle.components, vehicle.i3dMappings)\n                        if staticLight.node ~ = nil then\n                            staticLight.intensity = xmlFile:getValue(staticLightKey .. "#intensity" , 1 )\n                            staticLight.multiBlink = xmlFile:getValue(staticLightKey .. "#multiBlink" , false )\n                            staticLight.multiBlinkParameters = xmlFile:getValue(staticLightKey .. "#multiBlinkParameters" , "2 5 50 0" , true )\n                            staticLight.uvOffsetParameter = xmlFile:getValue(staticLightKey .. "#uvOffsetParameter" , 0 )\n                            staticLight.minDistance = xmlFile:getValue(staticLightKey .. "#minDistance" , 0 )\n\n                            staticLight.intensityScaleMinDistance = xmlFile:getValue(staticLightKey .. ".intensityScale#minDistance" )\n                            staticLight.intensityScaleMinIntensity = xmlFile:getValue(staticLightKey .. ".intensityScale#minIntensity" )\n                            staticLight.intensityScaleMaxDistance = xmlFile:getValue(staticLightKey .. ".intensityScale#maxDistance" )\n                            staticLight.intensityScaleMaxIntensity = xmlFile:getValue(staticLightKey .. ".intensityScale#maxIntensity" )\n\n                            staticLight.hasDynamicIntensity = staticLight.intensityScaleMinDistance ~ = nil and staticLight.intensityScaleMinIntensity ~ = nil and staticLight.intensityScaleMaxDistance ~ = nil and staticLight.intensityScaleMaxIntensity ~ = nil\n\n                            hasDynamicStaticLights = hasDynamicStaticLights or staticLight.hasDynamicIntensity or staticLight.minDistance > 0\n\n                            table.insert(staticLights, staticLight)\n                        end\n                    end\n\n                    if staticLights ~ = nil and #staticLights > 0 then\n                        local speed = xmlFile:getValue(key .. "#speed" )\n                        local intensity = xmlFile:getValue(key .. "#intensity" , 1 )\n\n                        local realLight = xmlFile:getValue(key .. "#realLight" , nil , vehicle.components, vehicle.i3dMappings)\n                        local realLightRangeScale = xmlFile:getValue(key .. "#realLightRange" , 1 )\n\n                        local beaconLight = BeaconLight.new(vehicle)\n                        beaconLight:setXMLSettings(speed, intensity, nil , nil )\n                        beaconLight:setRealLight( true , realLight, realLightRangeScale)\n\n                        beaconLight.staticLights = staticLights\n                        beaconLight.hasStaticLights = true\n                        beaconLight.hasDynamicStaticLights = hasDynamicStaticLights\n\n                        beaconLight:onFinished( true )\n\n                        table.insert(targetTable, beaconLight)\n                        return beaconLight\n                    end\n                end\n\n                return nil\n            end\n\n'})}),"\n",(0,s.jsx)(n.h3,{id:"loadfromxml",children:"loadFromXML"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Definition"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"loadFromXML()"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"any"}),(0,s.jsx)(n.th,{children:"linkNode"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"any"}),(0,s.jsx)(n.td,{children:"xmlFilename"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"any"}),(0,s.jsx)(n.td,{children:"baseDirectory"})]})]})]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Code"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:'function BeaconLight:loadFromXML(linkNode, xmlFilename, baseDirectory)\n    self.xmlFile = XMLFile.loadIfExists( "BeaconLight" , xmlFilename, BeaconLight.xmlSchema)\n\n    if self.xmlFile = = nil then\n        if self.vehicle ~ = nil then\n            Logging.xmlWarning( self.vehicle.xmlFile, "Unable to load shared lights from xml \'%s\'" , xmlFilename)\n        else\n                Logging.warning( "Unable to load shared lights from xml \'%s\'" , xmlFilename)\n            end\n\n            self:onFinished( false )\n            return false\n        end\n\n        local filename = self.xmlFile:getValue( "beaconLight.filename" )\n        if filename = = nil then\n            Logging.xmlWarning( self.xmlFile, "Missing light i3d filename!" )\n            self.xmlFile:delete()\n            self.xmlFile = nil\n\n            self:onFinished( false )\n            return false\n        end\n\n        self.filename = Utils.getFilename(filename, baseDirectory)\n        self.linkNode = linkNode\n\n        if self.vehicle ~ = nil then\n            self.sharedLoadRequestId = self.vehicle:loadSubSharedI3DFile( self.filename, false , false , self.onI3DLoaded, self , nil )\n        else\n                self.sharedLoadRequestId = g_i3DManager:loadSharedI3DFileAsync( self.filename, false , false , self.onI3DLoaded, self , nil )\n            end\n\n            return true\n        end\n\n'})}),"\n",(0,s.jsx)(n.h3,{id:"loadvariationfromxml",children:"loadVariationFromXML"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Definition"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"loadVariationFromXML()"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"any"}),(0,s.jsx)(n.th,{children:"xmlFile"})]})}),(0,s.jsx)(n.tbody,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"any"}),(0,s.jsx)(n.td,{children:"key"})]})})]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Code"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:'function BeaconLight:loadVariationFromXML(xmlFile, key)\n    self.rotatorNode = xmlFile:getValue(key .. ".rotator#node" , self.rotatorNode, self.components, self.i3dMappings)\n    self.speed = xmlFile:getValue(key .. ".rotator#speed" , self.speed or 0.015 )\n\n    self.realLightNode = xmlFile:getValue(key .. ".realLight#node" , self.realLightNode, self.components, self.i3dMappings)\n    if self.realLightNode ~ = nil and not getHasClassId( self.realLightNode, ClassIds.LIGHT_SOURCE) then\n        Logging.xmlWarning(xmlFile, "Node \'%s\' defined as light source for beacon light, but is not a light source!" , getName( self.realLightNode))\n            self.realLightNode = nil\n        end\n\n        if not xmlFile:getValue(key .. ".realLight#useRealLight" , true ) then\n            if self.realLightNode ~ = nil then\n                delete( self.realLightNode)\n                self.realLightNode = nil\n            end\n        end\n\n        for _, staticLightKey in xmlFile:iterator(key .. ".staticLight" ) do\n            local staticLight = { }\n            staticLight.node = xmlFile:getValue(staticLightKey .. "#node" , nil , self.components, self.i3dMappings)\n            if staticLight.node ~ = nil then\n                if staticLight.node ~ = nil and not getHasClassId(staticLight.node, ClassIds.SHAPE) then\n                    Logging.xmlWarning(xmlFile, "Node \'%s\' defined as shader node for beacon light, but is not a shape!" , getName(staticLight.node))\n                        continue\n                    end\n\n                    staticLight.intensity = xmlFile:getValue(staticLightKey .. "#intensity" , 1 )\n                    staticLight.multiBlink = xmlFile:getValue(staticLightKey .. "#multiBlink" , false )\n                    staticLight.multiBlinkParameters = xmlFile:getValue(staticLightKey .. "#multiBlinkParameters" , "2 5 50 0" , true )\n                    staticLight.uvOffsetParameter = xmlFile:getValue(staticLightKey .. "#uvOffsetParameter" , 0 )\n                    staticLight.minDistance = xmlFile:getValue(staticLightKey .. "#minDistance" , 0 )\n\n                    staticLight.intensityScaleMinDistance = xmlFile:getValue(staticLightKey .. ".intensityScale#minDistance" )\n                    staticLight.intensityScaleMinIntensity = xmlFile:getValue(staticLightKey .. ".intensityScale#minIntensity" )\n                    staticLight.intensityScaleMaxDistance = xmlFile:getValue(staticLightKey .. ".intensityScale#maxDistance" )\n                    staticLight.intensityScaleMaxIntensity = xmlFile:getValue(staticLightKey .. ".intensityScale#maxIntensity" )\n\n                    staticLight.hasDynamicIntensity = staticLight.intensityScaleMinDistance ~ = nil and staticLight.intensityScaleMinIntensity ~ = nil and staticLight.intensityScaleMaxDistance ~ = nil and staticLight.intensityScaleMaxIntensity ~ = nil\n\n                    self.hasDynamicStaticLights = self.hasDynamicStaticLights or staticLight.hasDynamicIntensity or staticLight.minDistance > 0\n\n                    table.insert( self.staticLights, staticLight)\n                end\n            end\n\n            self.hasStaticLights = # self.staticLights > 0\n\n            self.device = BeaconLightManager.loadDeviceFromXML(xmlFile, key .. ".device" ) or self.device\n\n            if xmlFile:hasProperty(key .. ".material" ) then\n                local baseDirectory = ""\n                local customEnvironment = ""\n\n                if self.vehicle ~ = nil then\n                    baseDirectory = self.vehicle.baseDirectory\n                    customEnvironment = self.vehicle.customEnvironment\n                end\n\n                local material = VehicleMaterial.new(baseDirectory)\n                if material:loadFromXML(xmlFile, key .. ".material" , customEnvironment) then\n                    material:apply( self.node)\n                end\n            end\n        end\n\n'})}),"\n",(0,s.jsx)(n.h3,{id:"new",children:"new"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Definition"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"new()"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"any"}),(0,s.jsx)(n.th,{children:"vehicle"})]})}),(0,s.jsx)(n.tbody,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"any"}),(0,s.jsx)(n.td,{children:"customMt"})]})})]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Code"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:"function BeaconLight.new(vehicle, customMt)\n    local self = setmetatable( { } , customMt or BeaconLight _mt)\n\n    self.vehicle = vehicle\n    self.components = { }\n    self.i3dMappings = { }\n\n    self.staticLights = { }\n\n    self.speed = 1\n    self.realLightRangeScale = 1\n    self.intensity = 1\n\n    self.lastCameraDistance = 0\n    self.requiresDirtyUpdate = false\n    self.hasDynamicStaticLights = false\n\n    self.isActive = false\n    self.realLightActive = false\n\n    return self\nend\n\n"})}),"\n",(0,s.jsx)(n.h3,{id:"onfinished",children:"onFinished"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Definition"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"onFinished()"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,s.jsx)(n.table,{children:(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"any"}),(0,s.jsx)(n.th,{children:"success"})]})})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Code"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:'function BeaconLight:onFinished(success)\n    for _, staticLight in ipairs( self.staticLights) do\n        staticLight.useLightControlShaderParameter = getHasShaderParameter(staticLight.node, "lightControl" )\n        if staticLight.useLightControlShaderParameter then\n            setShaderParameter(staticLight.node, "lightControl" , 0 , nil , nil , nil , false )\n        else\n                setShaderParameter(staticLight.node, "lightIds0" , 0 , 0 , 0 , 0 , false )\n                setShaderParameter(staticLight.node, "lightIds1" , 0 , 0 , 0 , 0 , false )\n                setShaderParameter(staticLight.node, "lightTypeBitMask" , BeaconLight.LIGHT_TYPE_BITMASK, 0 , 0 , 0 , false )\n                setShaderParameter(staticLight.node, "lightUvOffsetBitMask" , staticLight.uvOffsetParameter, 0 , 0 , 0 , false )\n            end\n\n            setShaderParameter(staticLight.node, "blinkMulti" , staticLight.multiBlinkParameters[ 1 ], staticLight.multiBlinkParameters[ 2 ], staticLight.multiBlinkParameters[ 3 ], staticLight.multiBlinkParameters[ 4 ], false )\n\n            if staticLight.multiBlink or staticLight.minDistance > 0 or staticLight.hasDynamicIntensity then\n                self.requiresDirtyUpdate = true\n            end\n        end\n\n        if self.speed > 0 then\n            if self.rotatorNode ~ = nil then\n                setRotation( self.rotatorNode, 0 , math.random( 0 , math.pi * 2 ), 0 )\n                self.requiresDirtyUpdate = true\n            end\n        end\n\n        if not self.useRealLights or self.customRealLight ~ = nil then\n            if self.realLightNode ~ = nil then\n                delete( self.realLightNode)\n                self.realLightNode = nil\n            end\n        end\n\n        if self.customRealLight ~ = nil then\n            self.realLightNode = self.customRealLight\n        end\n\n        if self.realLightNode ~ = nil then\n            self.defaultColor = { getLightColor( self.realLightNode) }\n            setVisibility( self.realLightNode, false )\n\n            self.defaultLightRange = getLightRange( self.realLightNode)\n            setLightRange( self.realLightNode, self.defaultLightRange * self.realLightRangeScale)\n\n            setLightShadowPriority( self.realLightNode, 0.25 )\n        end\n\n        if self.callback ~ = nil then\n            if self.callbackTarget ~ = nil then\n                self.callback( self.callbackTarget, success)\n            else\n                    self.callback(success)\n                end\n            end\n        end\n\n'})}),"\n",(0,s.jsx)(n.h3,{id:"oni3dloaded",children:"onI3DLoaded"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Definition"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"onI3DLoaded()"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"any"}),(0,s.jsx)(n.th,{children:"i3dNode"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"any"}),(0,s.jsx)(n.td,{children:"failedReason"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"any"}),(0,s.jsx)(n.td,{children:"args"})]})]})]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Code"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:'function BeaconLight:onI3DLoaded(i3dNode, failedReason, args)\n    if self.vehicle ~ = nil and self.vehicle.isDeleted then\n        return\n    end\n\n    if i3dNode ~ = 0 then\n        I3DUtil.loadI3DComponents(i3dNode, self.components)\n        I3DUtil.loadI3DMapping( self.xmlFile, "beaconLight" , self.components, self.i3dMappings)\n\n        self.node = self.xmlFile:getValue( "beaconLight.rootNode#node" , "0" , self.components, self.i3dMappings)\n\n        if self.node ~ = nil then\n            self.nodesToRemove = { }\n            self.variationRootNode = nil\n\n            local variationKey\n            for _variationIndex, _variationKey in self.xmlFile:iterator( "beaconLight.variations.variation" ) do\n                local name = self.xmlFile:getValue(_variationKey .. "#name" )\n                if name ~ = nil then\n                    if ( self.variationName = = nil and _variationIndex = = 1 ) or( self.variationName ~ = nil and string.lower(name) = = string.lower( self.variationName)) then\n                        variationKey = _variationKey\n                        self.variationRootNode = self.xmlFile:getValue(_variationKey .. "#rootNode" , nil , self.components, self.i3dMappings)\n                    else\n                            local node = self.xmlFile:getValue(_variationKey .. "#rootNode" , nil , self.components, self.i3dMappings)\n                            if node ~ = nil then\n                                self.nodesToRemove[node] = true\n                            end\n                        end\n                    end\n                end\n\n                self:loadVariationFromXML( self.xmlFile, "beaconLight" )\n                if variationKey ~ = nil then\n                    self:loadVariationFromXML( self.xmlFile, variationKey)\n                end\n\n                local yOffset = 0\n                for mountTypeIndex, mountTypeKey in self.xmlFile:iterator( "beaconLight.mountTypes.mountType" ) do\n                    local name = self.xmlFile:getValue(mountTypeKey .. "#name" )\n                    if name ~ = nil then\n                        local node = self.xmlFile:getValue(mountTypeKey .. "#node" , nil , self.components, self.i3dMappings)\n                        if ( self.mountType = = nil and mountTypeIndex = = 1 ) or( self.mountType ~ = nil and string.lower(name) = = string.lower( self.mountType)) then\n                            yOffset = self.xmlFile:getValue(mountTypeKey .. "#yOffset" , 0 )\n\n                            if node ~ = nil then\n                                setVisibility(node, true )\n                            end\n                        else\n                                if node ~ = nil then\n                                    self.nodesToRemove[node] = true\n                                end\n                            end\n                        end\n                    end\n\n                    for node, _ in pairs( self.nodesToRemove) do\n                        if node ~ = self.variationRootNode then -- exclude the current variation root node in case of double usage\n                            delete(node)\n                        end\n                    end\n                    self.nodesToRemove = nil\n\n                    link( self.linkNode, self.node)\n                    setTranslation( self.node, 0 , yOffset, 0 )\n                end\n\n                delete(i3dNode)\n            end\n\n            self.xmlFile:delete()\n            self.xmlFile = nil\n            self:onFinished( self.node ~ = nil and self.hasStaticLights)\n        end\n\n'})}),"\n",(0,s.jsx)(n.h3,{id:"onlightsrealbeaconlightchanged",children:"onLightsRealBeaconLightChanged"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Definition"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"onLightsRealBeaconLightChanged()"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Code"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:"function BeaconLight:onLightsRealBeaconLightChanged()\n    if self.realLightNode ~ = nil then\n        if not self.isActive or g_gameSettings:getValue(GameSettings.SETTING.REAL_BEACON_LIGHTS) then\n            self.realLightActive = self.isActive\n        else\n                self.realLightActive = false\n            end\n\n            setVisibility( self.realLightNode, self.realLightActive)\n        end\n    end\n\n"})}),"\n",(0,s.jsx)(n.h3,{id:"registervariationpaths",children:"registerVariationPaths"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Definition"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"registerVariationPaths()"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"any"}),(0,s.jsx)(n.th,{children:"schema"})]})}),(0,s.jsx)(n.tbody,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"any"}),(0,s.jsx)(n.td,{children:"basePath"})]})})]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Code"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:'function BeaconLight.registerVariationPaths(schema, basePath)\n    schema:register(XMLValueType.NODE_INDEX, basePath .. ".rotator#node" , "Node that is rotating" )\n    schema:register(XMLValueType.FLOAT, basePath .. ".rotator#speed" , "Rotating speed" , 0.015 )\n\n    schema:register(XMLValueType.NODE_INDEX, basePath .. ".staticLight(?)#node" , "Light control shader node" )\n    schema:register(XMLValueType.FLOAT, basePath .. ".staticLight(?)#intensity" , "Light intensity of shader node" , 100 )\n    schema:register(XMLValueType.BOOL, basePath .. ".staticLight(?)#multiBlink" , "Uses multiblink functionality" , false )\n    schema:register(XMLValueType.VECTOR_ 4 , basePath .. ".staticLight(?)#multiBlinkParameters" , "Parameters for multi blink function (blink ticks, pause ticks, frequency)" , "2 5 50 0" )\n        schema:register(XMLValueType.INT, basePath .. ".staticLight(?)#uvOffsetParameter" , "Parameter for light UV offset bit mask" , 0 )\n            schema:register(XMLValueType.FLOAT, basePath .. ".staticLight(?)#minDistance" , "Starting from this camera distance to static light is visible" , 0 )\n\n            schema:register(XMLValueType.FLOAT, basePath .. ".staticLight(?).intensityScale#minDistance" , "Reference distance for default intensity" )\n                schema:register(XMLValueType.FLOAT, basePath .. ".staticLight(?).intensityScale#minIntensity" , "Intensity to be used at min.distance" )\n                schema:register(XMLValueType.FLOAT, basePath .. ".staticLight(?).intensityScale#maxDistance" , "Reference distance for max intensity" )\n                    schema:register(XMLValueType.FLOAT, basePath .. ".staticLight(?).intensityScale#maxIntensity" , "Intensity to be used at max.distance" )\n\n                    schema:register(XMLValueType.NODE_INDEX, basePath .. ".realLight#node" , "Real light source node" )\n                    schema:register(XMLValueType.BOOL, basePath .. ".realLight#useRealLight" , "Defines if the real light is used at all for this variation" , true )\n\n                        VehicleMaterial.registerXMLPaths(schema, basePath .. ".material" )\n\n                        BeaconLightManager.registerXMLPaths(schema, basePath .. ".device" )\n                    end\n\n'})}),"\n",(0,s.jsx)(n.h3,{id:"registervehiclexmlpaths",children:"registerVehicleXMLPaths"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Definition"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"registerVehicleXMLPaths()"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"any"}),(0,s.jsx)(n.th,{children:"schema"})]})}),(0,s.jsx)(n.tbody,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"any"}),(0,s.jsx)(n.td,{children:"basePath"})]})})]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Code"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:'function BeaconLight.registerVehicleXMLPaths(schema, basePath)\n    schema:register(XMLValueType.NODE_INDEX, basePath .. "#node" , "Link node" )\n    schema:register(XMLValueType.FILENAME, basePath .. "#filename" , "Beacon light xml file" )\n    schema:register(XMLValueType.FLOAT, basePath .. "#speed" , "Beacon light speed override" )\n    schema:register(XMLValueType.BOOL, basePath .. "#useRealLights" , "Use the real lights from the external beacon light file" , true )\n    schema:register(XMLValueType.NODE_INDEX, basePath .. "#realLight" , "Custom real light to be used from the vehicle file instead of the external beacon light file" )\n    schema:register(XMLValueType.FLOAT, basePath .. "#realLightRange" , "Factor that is applied on real light range of the beacon light" , 1 )\n    schema:register(XMLValueType.INT, basePath .. "#intensity" , "Beacon light intensity scale" , 1 )\n    schema:register(XMLValueType.STRING, basePath .. "#mountType" , "Name of the mount type to use(SURFACE or POLE for most of the beacon lights)" )\n        schema:register(XMLValueType.STRING, basePath .. "#variationName" , "Name of the variation to use(ROTATE or BLINK for most of the beacon lights)" )\n\n            schema:register(XMLValueType.NODE_INDEX, basePath .. ".staticLight(?)#node" , "Static light node inside the vehicle i3d file" )\n            schema:register(XMLValueType.FLOAT, basePath .. ".staticLight(?)#intensity" , "Intensity of this static light node" , 100 )\n            schema:register(XMLValueType.BOOL, basePath .. ".staticLight(?)#multiBlink" , "Uses multiblink functionality" , false )\n            schema:register(XMLValueType.VECTOR_ 4 , basePath .. ".staticLight(?)#multiBlinkParameters" , "Parameters for multi blink function (blink ticks, pause ticks, frequency)" , "2 5 50 0" )\n                schema:register(XMLValueType.INT, basePath .. ".staticLight(?)#uvOffsetParameter" , "Parameter for light UV offset bit mask" , 0 )\n                    schema:register(XMLValueType.FLOAT, basePath .. ".staticLight(?)#minDistance" , "Starting from this camera distance to static light is visible" , 0 )\n\n                    schema:register(XMLValueType.FLOAT, basePath .. ".staticLight(?).intensityScale#minDistance" , "Reference distance for default intensity" , 0 )\n                        schema:register(XMLValueType.FLOAT, basePath .. ".staticLight(?).intensityScale#minIntensity" , "Intensity to be used at min.distance" , 0 )\n                        schema:register(XMLValueType.FLOAT, basePath .. ".staticLight(?).intensityScale#maxDistance" , "Reference distance for max intensity" , 0 )\n                            schema:register(XMLValueType.FLOAT, basePath .. ".staticLight(?).intensityScale#maxIntensity" , "Intensity to be used at max.distance" , 0 )\n                        end\n\n'})}),"\n",(0,s.jsx)(n.h3,{id:"registerxmlpaths",children:"registerXMLPaths"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Definition"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"registerXMLPaths()"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,s.jsx)(n.table,{children:(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"any"}),(0,s.jsx)(n.th,{children:"schema"})]})})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Code"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:'function BeaconLight.registerXMLPaths(schema)\n    schema:register(XMLValueType.STRING, "beaconLight.filename" , "Path to i3d file" , nil , true )\n    schema:register(XMLValueType.NODE_INDEX, "beaconLight.rootNode#node" , "Root node" )\n\n    schema:register(XMLValueType.STRING, "beaconLight.mountTypes.mountType(?)#name" , "Name of the mount type" )\n    schema:register(XMLValueType.NODE_INDEX, "beaconLight.mountTypes.mountType(?)#node" , "Node to show while this mount type is used" )\n        schema:register(XMLValueType.FLOAT, "beaconLight.mountTypes.mountType(?)#yOffset" , "Y translation offset of the while beacon light while this mount type is used" , 0 )\n\n            BeaconLight.registerVariationPaths(schema, "beaconLight" )\n\n            schema:register(XMLValueType.STRING, "beaconLight.variations.variation(?)#name" , "Name of the variation" )\n            schema:register(XMLValueType.NODE_INDEX, "beaconLight.variations.variation(?)#rootNode" , "Node that contains the variation data.Will be deleted if not used." )\n                BeaconLight.registerVariationPaths(schema, "beaconLight.variations.variation(?)" )\n\n                I3DUtil.registerI3dMappingXMLPaths(schema, "beaconLight" )\n            end\n\n'})}),"\n",(0,s.jsx)(n.h3,{id:"setcallback",children:"setCallback"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Definition"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"setCallback()"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"any"}),(0,s.jsx)(n.th,{children:"callback"})]})}),(0,s.jsx)(n.tbody,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"any"}),(0,s.jsx)(n.td,{children:"callbackTarget"})]})})]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Code"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:"function BeaconLight:setCallback(callback, callbackTarget)\n    self.callback = callback\n    self.callbackTarget = callbackTarget\nend\n\n"})}),"\n",(0,s.jsx)(n.h3,{id:"setisactive",children:"setIsActive"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Definition"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"setIsActive()"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,s.jsx)(n.table,{children:(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"any"}),(0,s.jsx)(n.th,{children:"isActive"})]})})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Code"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:'function BeaconLight:setIsActive(isActive)\n    if self.requiresDirtyUpdate then\n        if isActive then\n            g_currentMission:addUpdateable( self )\n        else\n                g_currentMission:removeUpdateable( self )\n            end\n        end\n\n        if self.realLightNode ~ = nil then\n            if g_gameSettings:getValue(GameSettings.SETTING.REAL_BEACON_LIGHTS) then\n                self.realLightActive = isActive\n            else\n                    self.realLightActive = false\n                end\n\n                setVisibility( self.realLightNode, self.realLightActive)\n            end\n\n            if self.node ~ = nil and isActive then\n                self.lastCameraDistance = calcDistanceFrom( self.node, g_cameraManager:getActiveCamera())\n            end\n\n            for _, staticLight in ipairs( self.staticLights) do\n                local value = isActive and staticLight.intensity or 0\n\n                if isActive and staticLight.hasDynamicIntensity then\n                    local alpha = math.min( math.max(( self.lastCameraDistance - staticLight.intensityScaleMinDistance) / (staticLight.intensityScaleMaxDistance - staticLight.intensityScaleMinDistance), 0 ), 1 )\n                    value = staticLight.intensityScaleMinIntensity + (staticLight.intensityScaleMaxIntensity - staticLight.intensityScaleMinIntensity) * alpha\n                end\n\n                value = value * self.intensity\n\n                if staticLight.useLightControlShaderParameter then\n                    setShaderParameter(staticLight.node, "lightControl" , value, nil , nil , nil , false )\n                else\n                        setShaderParameter(staticLight.node, "lightIds0" , value, value, 0 , 0 , false )\n                    end\n\n                    if staticLight.minDistance > 0 then\n                        if isActive then\n                            setVisibility(staticLight.node, self.lastCameraDistance > = staticLight.minDistance)\n                        else\n                                setVisibility(staticLight.node, false )\n                            end\n                        end\n                    end\n\n                    self.isActive = isActive\n                end\n\n'})}),"\n",(0,s.jsx)(n.h3,{id:"setreallight",children:"setRealLight"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Definition"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"setRealLight()"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"any"}),(0,s.jsx)(n.th,{children:"useRealLights"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"any"}),(0,s.jsx)(n.td,{children:"customRealLight"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"any"}),(0,s.jsx)(n.td,{children:"realLightRangeScale"})]})]})]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Code"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:"function BeaconLight:setRealLight(useRealLights, customRealLight, realLightRangeScale)\n    self.useRealLights = Utils.getNoNil(useRealLights, self.useRealLights)\n    self.customRealLight = customRealLight\n    self.realLightRangeScale = realLightRangeScale or self.realLightRangeScale\nend\n\n"})}),"\n",(0,s.jsx)(n.h3,{id:"setxmlsettings",children:"setXMLSettings"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Definition"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"setXMLSettings()"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"any"}),(0,s.jsx)(n.th,{children:"speed"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"any"}),(0,s.jsx)(n.td,{children:"intensity"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"any"}),(0,s.jsx)(n.td,{children:"mountType"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"any"}),(0,s.jsx)(n.td,{children:"variationName"})]})]})]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Code"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:"function BeaconLight:setXMLSettings(speed, intensity, mountType, variationName)\n    self.speed = speed or self.speed\n    self.intensity = intensity or self.intensity\n\n    self.mountType = mountType\n    self.variationName = variationName\nend\n\n"})}),"\n",(0,s.jsx)(n.h3,{id:"spawndebugbeacons",children:"spawnDebugBeacons"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Definition"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"spawnDebugBeacons()"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,s.jsx)(n.table,{children:(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"any"}),(0,s.jsx)(n.th,{children:"rootNode"})]})})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Code"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:'function BeaconLight.spawnDebugBeacons(rootNode)\n    local files = Files.getFilesRecursive( "data/shared/assets/beaconLights" )\n    table.sort(files, function (a, b)\n        return a.path < b.path\n    end )\n\n    if BeaconLight.debugBeaconLights ~ = nil then\n        for _, beaconLight in ipairs( BeaconLight.debugBeaconLights) do\n            beaconLight:delete()\n        end\n    end\n\n    BeaconLight.debugBeaconLights = { }\n\n    local x, y, z = - 1 , 1 , 0\n    local numLightsToLoad, numLightsToLoadTotal = 0 , 0\n    local numLightsSuccess, numLightsFailed = 0 , 0\n    for _, file in ipairs(files) do\n        if not file.isDirectory then\n            if file.filename:contains( ".xml" ) then\n                x = x - 2\n                z = 0\n\n                local filename = string.gsub(file.path, getAppBasePath(), "" )\n\n                local tempXMLFile = XMLFile.loadIfExists( "BeaconLight" , filename, BeaconLight.xmlSchema)\n                if tempXMLFile ~ = nil then\n                    for _, mountTypeKey in tempXMLFile:iterator( "beaconLight.mountTypes.mountType" ) do\n                        local mountType = tempXMLFile:getValue(mountTypeKey .. "#name" )\n                        for _, variationKey in tempXMLFile:iterator( "beaconLight.variations.variation" ) do\n                            local variationName = tempXMLFile:getValue(variationKey .. "#name" )\n\n                            numLightsToLoad = numLightsToLoad + 1\n                            numLightsToLoadTotal = numLightsToLoadTotal + 1\n\n                            z = z + 1\n\n                            local linkNode = createTransformGroup( "linkNode" )\n                            link(rootNode, linkNode)\n\n                            setTranslation(linkNode, x, y, z)\n                            setRotation(linkNode, 0 , math.pi, 0 )\n\n                            local beaconLight = BeaconLight.new( nil )\n                            beaconLight:setXMLSettings( nil , nil , mountType, variationName)\n                            beaconLight:setRealLight( false )\n                            beaconLight:setCallback( function (success)\n                                numLightsToLoad = numLightsToLoad - 1\n                                if success then\n                                    numLightsSuccess = numLightsSuccess + 1\n                                    table.insert( BeaconLight.debugBeaconLights, beaconLight)\n                                else\n                                        beaconLight:delete()\n                                        numLightsFailed = numLightsFailed + 1\n                                    end\n\n                                    if numLightsToLoad = = 0 then\n                                        for _, light in ipairs( BeaconLight.debugBeaconLights) do\n\n                                            light:setIsActive( true )\n                                        end\n\n                                        Logging.info( "%d Beacon lights: %d loaded, %d failed to load" , numLightsToLoadTotal, numLightsSuccess, numLightsFailed)\n                                    end\n                                end )\n\n                                if beaconLight:loadFromXML(linkNode, filename, "" ) then\n                                    local wx, wy, wz = localToWorld(linkNode, 0 , 0 , - 0.2 )\n                                    local rx, ry, rz = localRotationToWorld(linkNode, - math.pi * 0.5 , 0 , 0 )\n                                    g_debugManager:addElement( DebugText3D.new():createWithWorldPos(wx, wy, wz, rx, ry, rz, string.format( "%s(%s, %s)" , file.filename, mountType, variationName), 0.07 ), nil , nil , math.huge)\n                                    g_debugManager:addElement( DebugGizmo.new():createWithNode(linkNode, "" , nil , nil , 0.1 ), nil , nil , math.huge)\n                                end\n                            end\n                        end\n\n                        tempXMLFile:delete()\n                    end\n                end\n            end\n        end\n    end\n\n'})}),"\n",(0,s.jsx)(n.h3,{id:"update",children:"update"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Definition"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"update()"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,s.jsx)(n.table,{children:(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"any"}),(0,s.jsx)(n.th,{children:"dt"})]})})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Code"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:'function BeaconLight:update(dt)\n    if self.rotatorNode ~ = nil then\n        rotate( self.rotatorNode, 0 , self.speed * dt, 0 )\n    end\n\n    if self.realLightActive and self.hasStaticLights and self.staticLights[ 1 ].multiBlink then\n        local staticLight = self.staticLights[ 1 ]\n        local blink, pause, freq, timeOffset = staticLight.multiBlinkParameters[ 1 ], staticLight.multiBlinkParameters[ 2 ], staticLight.multiBlinkParameters[ 3 ], staticLight.multiBlinkParameters[ 4 ]\n        local mTime = getShaderTimeSec() * freq + timeOffset\n        local alpha = math.clamp(( math.sin(mTime) - math.max(((mTime) % (((blink * 2 ) + pause * 2 ) * math.pi)) - (blink * 2 - 1 ) * math.pi, 0 )) + 0.2 , 0 , 1 )\n\n        local r, g, b = self.defaultColor[ 1 ], self.defaultColor[ 2 ], self.defaultColor[ 3 ]\n        setLightColor( self.realLightNode, r * alpha, g * alpha, b * alpha)\n        local numChildren = getNumOfChildren( self.realLightNode)\n        for i = 0 , numChildren - 1 do\n            setLightColor(getChildAt( self.realLightNode, i), r * alpha, g * alpha, b * alpha)\n        end\n    end\n\n    if self.hasDynamicStaticLights then\n        local cameraDistance = 0\n        if self.node ~ = nil then\n            cameraDistance = calcDistanceFrom( self.node, g_cameraManager:getActiveCamera())\n        end\n\n        if math.abs( self.lastCameraDistance - cameraDistance) > 1 then\n            for _, staticLight in ipairs( self.staticLights) do\n                if staticLight.hasDynamicIntensity then\n                    local alpha = math.min( math.max((cameraDistance - staticLight.intensityScaleMinDistance) / (staticLight.intensityScaleMaxDistance - staticLight.intensityScaleMinDistance), 0 ), 1 )\n                    local value = staticLight.intensityScaleMinIntensity + (staticLight.intensityScaleMaxIntensity - staticLight.intensityScaleMinIntensity) * alpha\n                    value = value * self.intensity\n\n                    if staticLight.useLightControlShaderParameter then\n                        setShaderParameter(staticLight.node, "lightControl" , value, nil , nil , nil , false )\n                    else\n                            setShaderParameter(staticLight.node, "lightIds0" , value, value, 0 , 0 , false )\n                        end\n                    end\n\n                    if staticLight.minDistance > 0 then\n                        setVisibility(staticLight.node, cameraDistance > = staticLight.minDistance)\n                    end\n                end\n\n                self.lastCameraDistance = cameraDistance\n            end\n        end\n    end\n\n'})})]})}function d(e={}){const{wrapper:n}={...(0,l.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(o,{...e})}):o(e)}}}]);