"use strict";(globalThis.webpackChunkfs25_community_luadoc=globalThis.webpackChunkfs25_community_luadoc||[]).push([[61120],{28453(e,n,r){r.d(n,{R:()=>o,x:()=>s});var t=r(96540);const i={},l=t.createContext(i);function o(e){const n=t.useContext(l);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function s(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:o(e.components),t.createElement(l.Provider,{value:n},e.children)}},35084(e,n,r){r.r(n),r.d(n,{assets:()=>a,contentTitle:()=>s,default:()=>h,frontMatter:()=>o,metadata:()=>t,toc:()=>d});const t=JSON.parse('{"id":"script/Vehicles/WheelsUtil","title":"WheelsUtil","description":"WheelsUtil","source":"@site/../docs/script/Vehicles/WheelsUtil.md","sourceDirName":"script/Vehicles","slug":"/script/Vehicles/WheelsUtil","permalink":"/FS25-Community-LUADOC/script/Vehicles/WheelsUtil","draft":false,"unlisted":false,"tags":[],"version":"current","lastUpdatedAt":1767161192000,"frontMatter":{},"sidebar":"docsSidebar","previous":{"title":"VehicleTeleportEvent","permalink":"/FS25-Community-LUADOC/script/Vehicles/VehicleTeleportEvent"},"next":{"title":"WorkAreaTypeManager","permalink":"/FS25-Community-LUADOC/script/Vehicles/WorkAreaTypeManager"}}');var i=r(74848),l=r(28453);const o={},s=void 0,a={},d=[{value:"WheelsUtil",id:"wheelsutil",level:2},{value:"computeDifferentialRotSpeedNonMotor",id:"computedifferentialrotspeednonmotor",level:3},{value:"getGroundType",id:"getgroundtype",level:3},{value:"getSmoothedAcceleratorAndBrakePedals",id:"getsmoothedacceleratorandbrakepedals",level:3},{value:"getTireFriction",id:"gettirefriction",level:3},{value:"getTireType",id:"gettiretype",level:3},{value:"getTireTypeName",id:"gettiretypename",level:3},{value:"registerTireType",id:"registertiretype",level:3},{value:"unregisterTireType",id:"unregistertiretype",level:3},{value:"updateWheelsPhysics",id:"updatewheelsphysics",level:3}];function c(e){const n={a:"a",blockquote:"blockquote",code:"code",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,l.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.h2,{id:"wheelsutil",children:"WheelsUtil"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Description"})}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsx)(n.p,{children:"Wheels util\nUtil class to manage wheels of a vehicle"}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Functions"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"#computedifferentialrotspeednonmotor",children:"computeDifferentialRotSpeedNonMotor"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"#getgroundtype",children:"getGroundType"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"#getsmoothedacceleratorandbrakepedals",children:"getSmoothedAcceleratorAndBrakePedals"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"#gettirefriction",children:"getTireFriction"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"#gettiretype",children:"getTireType"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"#gettiretypename",children:"getTireTypeName"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"#registertiretype",children:"registerTireType"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"#unregistertiretype",children:"unregisterTireType"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"#updatewheelsphysics",children:"updateWheelsPhysics"})}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"computedifferentialrotspeednonmotor",children:"computeDifferentialRotSpeedNonMotor"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Description"})}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsx)(n.p,{children:"Compute differential rot speed from properties of vehicle other than the motor, e.g. rot speed of wheels or linear\nspeed of vehicle"}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Definition"})}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsx)(n.p,{children:"computeDifferentialRotSpeedNonMotor()"}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,i.jsx)(n.table,{children:(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"any"}),(0,i.jsx)(n.th,{children:"self"})]})})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Return Values"})}),"\n\n\n\n\n\n\n\n\n",(0,i.jsx)(n.table,{children:(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"any"}),(0,i.jsx)(n.th,{children:"diffRotSpeed"}),(0,i.jsx)(n.th,{children:"rot speed [rad/sec]"})]})})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Code"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lua",children:"function WheelsUtil.computeDifferentialRotSpeedNonMotor( self )\n    if self.isServer and self.spec_wheels ~ = nil and # self.spec_wheels.wheels ~ = 0 then\n        local wheelSpeed = 0\n        local numWheels = 0\n        for _, wheel in pairs( self.spec_wheels.wheels) do\n            local axleSpeed = getWheelShapeAxleSpeed(wheel.node, wheel.physics.wheelShape) -- rad/sec\n            if wheel.physics.hasGroundContact then\n                wheelSpeed = wheelSpeed + axleSpeed * wheel.physics.radius\n                numWheels = numWheels + 1\n            end\n        end\n\n        if numWheels > 0 then\n            return wheelSpeed / numWheels\n        end\n        return 0\n    else\n            -- v = w*r = > w = v/r\n            -- differentials have embeded gear so that r can be considered 1\n            return self.lastSpeedReal * 1000\n        end\n    end\n\n"})}),"\n",(0,i.jsx)(n.h3,{id:"getgroundtype",children:"getGroundType"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Description"})}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsx)(n.p,{children:"Get ground type"}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Definition"})}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsx)(n.p,{children:"getGroundType(boolean isField, boolean isRoad, float depth)"}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"boolean"}),(0,i.jsx)(n.th,{children:"isField"}),(0,i.jsx)(n.th,{children:"is on field"})]})}),(0,i.jsxs)(n.tbody,{children:[(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"boolean"}),(0,i.jsx)(n.td,{children:"isRoad"}),(0,i.jsx)(n.td,{children:"is on road"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"float"}),(0,i.jsx)(n.td,{children:"depth"}),(0,i.jsx)(n.td,{children:"depth of terrain"})]})]})]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Return Values"})}),"\n\n\n\n\n\n\n\n\n",(0,i.jsx)(n.table,{children:(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"float"}),(0,i.jsx)(n.th,{children:"groundType"}),(0,i.jsx)(n.th,{children:"ground type"})]})})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Code"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lua",children:"function WheelsUtil.getGroundType(isField, isRoad, depth)\n    -- terrain softness:\n    -- [ 0, 0.1]:road\n    -- [0.1, 0.8]:hard terrain\n    -- [0.8, 1 ]:soft terrain\n    if isField then\n        return WheelsUtil.GROUND_FIELD\n    elseif isRoad or depth < 0.1 then\n            return WheelsUtil.GROUND_ROAD\n        else\n                if depth > 0.8 then\n                    return WheelsUtil.GROUND_SOFT_TERRAIN\n                else\n                        return WheelsUtil.GROUND_HARD_TERRAIN\n                    end\n                end\n            end\n\n"})}),"\n",(0,i.jsx)(n.h3,{id:"getsmoothedacceleratorandbrakepedals",children:"getSmoothedAcceleratorAndBrakePedals"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Description"})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Definition"})}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsx)(n.p,{children:"getSmoothedAcceleratorAndBrakePedals()"}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"any"}),(0,i.jsx)(n.th,{children:"self"})]})}),(0,i.jsxs)(n.tbody,{children:[(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"any"}),(0,i.jsx)(n.td,{children:"acceleratorPedal"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"any"}),(0,i.jsx)(n.td,{children:"brakePedal"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"any"}),(0,i.jsx)(n.td,{children:"dt"})]})]})]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Code"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lua",children:'function WheelsUtil.getSmoothedAcceleratorAndBrakePedals( self , acceleratorPedal, brakePedal, dt)\n\n    if self.wheelsUtilSmoothedAcceleratorPedal = = nil then\n        self.wheelsUtilSmoothedAcceleratorPedal = 0\n    end\n\n    local appliedAcc = 0\n    if acceleratorPedal > 0 then\n        if acceleratorPedal > self.wheelsUtilSmoothedAcceleratorPedal then\n            appliedAcc = math.min( math.max( self.wheelsUtilSmoothedAcceleratorPedal + SMOOTHING_SPEED_SCALE * dt, SMOOTHING_SPEED_SCALE), acceleratorPedal)\n        else\n                appliedAcc = acceleratorPedal\n            end\n            self.wheelsUtilSmoothedAcceleratorPedal = appliedAcc\n        elseif acceleratorPedal < 0 then\n                if acceleratorPedal < self.wheelsUtilSmoothedAcceleratorPedal then\n                    appliedAcc = math.max( math.min( self.wheelsUtilSmoothedAcceleratorPedal - SMOOTHING_SPEED_SCALE * dt, - SMOOTHING_SPEED_SCALE), acceleratorPedal)\n                else\n                        appliedAcc = acceleratorPedal\n                    end\n                    self.wheelsUtilSmoothedAcceleratorPedal = appliedAcc\n                else\n                        -- Decrease smoothed acceleration towards 0 with different speeds based on if we are braking\n                            local decSpeed = 0.0005 + 0.001 * brakePedal -- scale between 2sec and 0.66s(full brake)\n                            if self.wheelsUtilSmoothedAcceleratorPedal > 0 then\n                                self.wheelsUtilSmoothedAcceleratorPedal = math.max( self.wheelsUtilSmoothedAcceleratorPedal - decSpeed * dt, 0 )\n                            else\n                                    self.wheelsUtilSmoothedAcceleratorPedal = math.min( self.wheelsUtilSmoothedAcceleratorPedal + decSpeed * dt, 0 )\n                                end\n                            end\n\n                            if self.wheelsUtilSmoothedBrakePedal = = nil then\n                                self.wheelsUtilSmoothedBrakePedal = 0\n                            end\n\n                            local appliedBrake = 0\n                            if brakePedal > 0 then\n                                if brakePedal > self.wheelsUtilSmoothedBrakePedal then\n                                    appliedBrake = math.min( self.wheelsUtilSmoothedBrakePedal + 0.0025 * dt, brakePedal) -- full brake in 0.4sec\n                                else\n                                        appliedBrake = brakePedal\n                                    end\n                                    self.wheelsUtilSmoothedBrakePedal = appliedBrake\n                                else\n                                        -- Decrease smoothed brake towards 0 with different speeds based on if we are accelerating\n                                            local decSpeed = 0.0005 + 0.001 * acceleratorPedal -- scale between 2sec and 0.66s(full acceleration)\n                                            self.wheelsUtilSmoothedBrakePedal = math.max( self.wheelsUtilSmoothedBrakePedal - decSpeed * dt, 0 )\n                                        end\n\n                                        --print(string.format("input: %.2f %.2f applied: %.2f %.2f", acceleratorPedal, brakePedal, appliedAcc, appliedBrake))\n\n                                        return appliedAcc, appliedBrake\n                                    end\n\n'})}),"\n",(0,i.jsx)(n.h3,{id:"gettirefriction",children:"getTireFriction"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Description"})}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsx)(n.p,{children:"Returns tire friction"}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Definition"})}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsx)(n.p,{children:"getTireFriction(integer tireType, integer groundType, float wetScale, )"}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"integer"}),(0,i.jsx)(n.th,{children:"tireType"}),(0,i.jsx)(n.th,{children:"tire type index"})]})}),(0,i.jsxs)(n.tbody,{children:[(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"integer"}),(0,i.jsx)(n.td,{children:"groundType"}),(0,i.jsx)(n.td,{children:"ground type index"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"float"}),(0,i.jsx)(n.td,{children:"wetScale"}),(0,i.jsx)(n.td,{children:"wet scale"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"any"}),(0,i.jsx)(n.td,{children:"snowScale"}),(0,i.jsx)(n.td,{})]})]})]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Return Values"})}),"\n\n\n\n\n\n\n\n\n",(0,i.jsx)(n.table,{children:(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"any"}),(0,i.jsx)(n.th,{children:"tireFriction"}),(0,i.jsx)(n.th,{children:"tire friction"})]})})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Code"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lua",children:"function WheelsUtil.getTireFriction(tireType, groundType, wetScale, snowScale)\n    if wetScale = = nil then\n        wetScale = 0\n    end\n    local coeff = WheelsUtil.tireTypes[tireType].frictionCoeffs[groundType]\n    local coeffWet = WheelsUtil.tireTypes[tireType].frictionCoeffsWet[groundType]\n    local coeffSnow = WheelsUtil.tireTypes[tireType].frictionCoeffsSnow[groundType]\n    return coeff + (coeffWet - coeff) * wetScale + (coeffSnow - coeff) * snowScale\nend\n\n"})}),"\n",(0,i.jsx)(n.h3,{id:"gettiretype",children:"getTireType"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Description"})}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsx)(n.p,{children:"Returns tire type index"}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Definition"})}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsx)(n.p,{children:"getTireType(string name)"}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n",(0,i.jsx)(n.table,{children:(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"string"}),(0,i.jsx)(n.th,{children:"name"}),(0,i.jsx)(n.th,{children:"name of tire type"})]})})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Return Values"})}),"\n\n\n\n\n\n\n\n\n",(0,i.jsx)(n.table,{children:(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"string"}),(0,i.jsx)(n.th,{children:"i"}),(0,i.jsx)(n.th,{children:"index of tire type"})]})})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Code"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lua",children:"function WheelsUtil.getTireType(name)\n    name = string.upper(name)\n    for i, t in pairs( WheelsUtil.tireTypes) do\n        if t.name = = name then\n            return i\n        end\n    end\n    return nil\nend\n\n"})}),"\n",(0,i.jsx)(n.h3,{id:"gettiretypename",children:"getTireTypeName"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Description"})}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsx)(n.p,{children:"Returns tire type name by index"}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Definition"})}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsx)(n.p,{children:"getTireTypeName(integer i)"}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n",(0,i.jsx)(n.table,{children:(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"integer"}),(0,i.jsx)(n.th,{children:"i"}),(0,i.jsx)(n.th,{children:"index of tire type"})]})})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Return Values"})}),"\n\n\n\n\n\n\n\n\n",(0,i.jsx)(n.table,{children:(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"integer"}),(0,i.jsx)(n.th,{children:"name"}),(0,i.jsx)(n.th,{children:"name of tire type"})]})})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Code"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lua",children:'function WheelsUtil.getTireTypeName(index)\n    if WheelsUtil.tireTypes[index] ~ = nil then\n        return WheelsUtil.tireTypes[index].name\n    end\n\n    return "unknown"\nend\n\n'})}),"\n",(0,i.jsx)(n.h3,{id:"registertiretype",children:"registerTireType"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Description"})}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsx)(n.p,{children:"Register new tire type"}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Definition"})}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsx)(n.p,{children:"registerTireType(string name, table frictionCoeffs, table frictionCoeffsWer, )"}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"string"}),(0,i.jsx)(n.th,{children:"name"}),(0,i.jsx)(n.th,{children:"name of new tire type"})]})}),(0,i.jsxs)(n.tbody,{children:[(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"table"}),(0,i.jsx)(n.td,{children:"frictionCoeffs"}),(0,i.jsx)(n.td,{children:"friction coeffs"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"table"}),(0,i.jsx)(n.td,{children:"frictionCoeffsWer"}),(0,i.jsx)(n.td,{children:"friction coeffs wet"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"any"}),(0,i.jsx)(n.td,{children:"frictionCoeffsSnow"}),(0,i.jsx)(n.td,{})]})]})]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Code"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lua",children:'function WheelsUtil.registerTireType(name, frictionCoeffs, frictionCoeffsWet, frictionCoeffsSnow)\n    name = string.upper(name)\n    if WheelsUtil.getTireType(name) ~ = nil then\n        printWarning( "Warning:Tire type \'" .. name .. "\' already registered, ignoring this definition" )\n        return\n    end\n\n    local function getNoNilCoeffs(frictionCoeffs)\n        local localCoeffs = { }\n        if frictionCoeffs[ 1 ] = = nil then\n            localCoeffs[ 1 ] = 1.15\n            for i = 2 , WheelsUtil.NUM_GROUNDS do\n                if frictionCoeffs[i] ~ = nil then\n                    localCoeffs[ 1 ] = frictionCoeffs[i]\n                    break\n                end\n            end\n        else\n                localCoeffs[ 1 ] = frictionCoeffs[ 1 ]\n            end\n            for i = 2 , WheelsUtil.NUM_GROUNDS do\n                localCoeffs[i] = frictionCoeffs[i] or frictionCoeffs[i - 1 ]\n            end\n            return localCoeffs\n        end\n\n        local tireType = { }\n        tireType.name = name\n        tireType.frictionCoeffs = getNoNilCoeffs(frictionCoeffs)\n        tireType.frictionCoeffsWet = getNoNilCoeffs(frictionCoeffsWet or frictionCoeffs)\n        tireType.frictionCoeffsSnow = getNoNilCoeffs(frictionCoeffsSnow or tireType.frictionCoeffsWet)\n        table.insert( WheelsUtil.tireTypes, tireType)\n    end\n\n'})}),"\n",(0,i.jsx)(n.h3,{id:"unregistertiretype",children:"unregisterTireType"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Description"})}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsx)(n.p,{children:"Remove a tire type"}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Definition"})}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsx)(n.p,{children:"unregisterTireType()"}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,i.jsx)(n.table,{children:(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"any"}),(0,i.jsx)(n.th,{children:"name"})]})})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Code"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lua",children:"function WheelsUtil.unregisterTireType(name)\n    name = string.upper(name)\n    for i, tireType in ipairs( WheelsUtil.tireTypes) do\n        if tireType.name = = name then\n            table.remove( WheelsUtil.tireTypes, i)\n            break\n        end\n    end\nend\n\n"})}),"\n",(0,i.jsx)(n.h3,{id:"updatewheelsphysics",children:"updateWheelsPhysics"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Description"})}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsx)(n.p,{children:"Updates wheel physics"}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Definition"})}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsx)(n.p,{children:"updateWheelsPhysics(float dt, float currentSpeed, float acceleration, boolean doHandbrake, boolean stopAndGoBraking, )"}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"float"}),(0,i.jsx)(n.th,{children:"dt"}),(0,i.jsx)(n.th,{children:"time since last call in ms"})]})}),(0,i.jsxs)(n.tbody,{children:[(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"float"}),(0,i.jsx)(n.td,{children:"currentSpeed"}),(0,i.jsx)(n.td,{children:"signed current speed (m/ms)"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"float"}),(0,i.jsx)(n.td,{children:"acceleration"}),(0,i.jsx)(n.td,{children:"target acceleration [-1,1]"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"boolean"}),(0,i.jsx)(n.td,{children:"doHandbrake"}),(0,i.jsx)(n.td,{children:"do handbrake"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"boolean"}),(0,i.jsx)(n.td,{children:"stopAndGoBraking"}),(0,i.jsx)(n.td,{children:"if false, the acceleration needs to be 0 before a change of direction is allowed"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"any"}),(0,i.jsx)(n.td,{children:"stopAndGoBraking"}),(0,i.jsx)(n.td,{})]})]})]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Code"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lua",children:'function WheelsUtil.updateWheelsPhysics( self , dt, currentSpeed, acceleration, doHandbrake, stopAndGoBraking)\n    --print("function WheelsUtil.updateWheelsPhysics(" .. tostring(self) .. ", " .. tostring(dt) .. ", " .. tostring(currentSpeed) .. ", " .. tostring(acceleration) .. ", " .. tostring(doHandbrake) .. ", " .. tostring(stopAndGoBraking))\n\n        local acceleratorPedal = 0\n        local brakePedal = 0\n\n        local reverserDirection = 1\n        if self.spec_drivable ~ = nil then\n            reverserDirection = self.spec_drivable.reverserDirection\n        end\n\n        local motor = self.spec_motorized.motor\n        local isManualTransmission = motor.backwardGears ~ = nil or motor.forwardGears ~ = nil\n        local useManualDirectionChange = self:getIsManualDirectionChangeActive()\n        if useManualDirectionChange then\n            acceleration = acceleration * motor.currentDirection\n        else\n                acceleration = acceleration * reverserDirection\n            end\n\n            local absCurrentSpeed = math.abs(currentSpeed)\n            local accSign = math.sign(acceleration)\n\n            self.nextMovingDirection = self.nextMovingDirection or 0\n            self.nextMovingDirectionTimer = self.nextMovingDirectionTimer or 0\n\n            local automaticBrake = false\n            if math.abs(acceleration) < 0.001 then\n                automaticBrake = true\n\n                -- Non-stop&go only allows change of direction if the vehicle speed is smaller than 1km/h or the direction has already changed(e.g.because the brakes are not hard enough)\n                    if stopAndGoBraking or currentSpeed * self.nextMovingDirection < 0.0003 then\n                        self.nextMovingDirection = 0\n                    end\n                else\n                        -- Disable the known moving direction if the vehicle is driving more than 5km/h(0.0014 * 3600 = 5.04km/h) in the opposite direction\n                            if self.nextMovingDirection * currentSpeed < - 0.0014 then\n                                self.nextMovingDirection = 0\n                            end\n\n                            -- Continue accelerating if we want to go in the same direction\n                                -- or if the vehicle is only moving slowly in the wrong direction(0.0003 * 3600 = 1.08 km/h) and we are allowed to change direction\n                                    if accSign = = self.nextMovingDirection or(currentSpeed * accSign > - 0.0003 and(stopAndGoBraking or self.nextMovingDirection = = 0 )) then\n                                        self.nextMovingDirectionTimer = math.max( self.nextMovingDirectionTimer - dt, 0 )\n                                        if self.nextMovingDirectionTimer = = 0 then\n                                            acceleratorPedal = acceleration\n                                            brakePedal = 0\n                                            self.nextMovingDirection = accSign\n                                        else\n                                                acceleratorPedal = 0\n                                                brakePedal = math.abs(acceleration)\n                                            end\n                                        else\n                                                acceleratorPedal = 0\n                                                brakePedal = math.abs(acceleration)\n                                                if stopAndGoBraking then\n                                                    self.nextMovingDirectionTimer = 100\n                                                end\n                                            end\n                                        end\n\n                                        if useManualDirectionChange then\n                                            if acceleratorPedal ~ = 0 and math.sign(acceleratorPedal) ~ = motor.currentDirection then\n                                                brakePedal = math.abs(acceleratorPedal)\n                                                acceleratorPedal = 0\n                                            end\n                                        end\n\n                                        if automaticBrake then\n                                            acceleratorPedal = 0\n                                        end\n\n                                        acceleratorPedal, brakePedal = motor:updateGear(acceleratorPedal, brakePedal, dt)\n\n                                        if motor.gear = = 0 and motor.targetGear ~ = 0 then\n                                            -- brake automatically if the vehicle is rolling backwards while shifting\n                                                if currentSpeed * math.sign(motor.targetGear) < 0 and absCurrentSpeed < motor.lowBrakeForceSpeedLimit then\n                                                    automaticBrake = true\n                                                end\n                                            end\n\n                                            if motor.gearShiftMode = = VehicleMotor.SHIFT_MODE_MANUAL_CLUTCH then\n                                                if isManualTransmission then\n                                                    automaticBrake = false\n                                                end\n                                            end\n\n                                            if accSign ~ = 0 then\n                                                if motor.lowBrakeForceLocked then\n                                                    motor.lowBrakeForceLocked = false\n                                                end\n                                            end\n\n                                            if automaticBrake then\n                                                local isSlow = absCurrentSpeed < motor.lowBrakeForceSpeedLimit\n                                                local isArticulatedSteering = self.spec_articulatedAxis ~ = nil and self.spec_articulatedAxis.componentJoint ~ = nil and math.abs( self.rotatedTime) > 0.01\n\n                                                if (isSlow or doHandbrake) and not isArticulatedSteering or motor.lowBrakeForceLocked then\n                                                    brakePedal = 1\n\n                                                    -- if we once locked the low brake force, we keep it locked until the player provides input\n                                                        if not motor.lowBrakeForceLocked and accSign = = 0 then\n                                                            motor.lowBrakeForceLocked = true\n                                                        end\n                                                    else\n                                                            -- interpolate between lowBrakeForce and 1 if speed is below 3.6 km/h\n                                                                local factor = math.min(absCurrentSpeed / 0.001 , 1 )\n                                                                brakePedal = MathUtil.lerp( 1 , motor.lowBrakeForceScale, factor)\n                                                            end\n                                                        end\n\n                                                        SpecializationUtil.raiseEvent( self , "onVehiclePhysicsUpdate" , acceleratorPedal, brakePedal, automaticBrake, currentSpeed)\n\n                                                        acceleratorPedal, brakePedal = WheelsUtil.getSmoothedAcceleratorAndBrakePedals( self , acceleratorPedal, brakePedal, dt)\n\n                                                        local maxSpeed = motor:getMaximumForwardSpeed() * 3.6\n                                                        if self.movingDirection < 0 then\n                                                            maxSpeed = motor:getMaximumBackwardSpeed() * 3.6\n                                                        end\n\n                                                        --active braking if over the speed limit\n                                                            local overSpeedLimit = self:getLastSpeed() - math.min(motor:getSpeedLimit(), maxSpeed)\n                                                            if overSpeedLimit > 0 then\n                                                                if overSpeedLimit > 0.3 then\n                                                                    motor.overSpeedTimer = math.min(motor.overSpeedTimer + dt, 2000 )\n                                                                else\n                                                                        motor.overSpeedTimer = math.max(motor.overSpeedTimer - dt, 0 )\n                                                                    end\n\n                                                                    -- the longer we exceed the speed limit by min.0.3km/h, the harder we brake\n                                                                    -- so we have a smooth braking when the speed limit changes and a harder brake when driving downhill with a full trailer\n                                                                    local factor = 0.5 + (motor.overSpeedTimer / 2000 * 1 )\n\n                                                                    brakePedal = math.max( math.min( math.pow(overSpeedLimit * factor, 2 ), 1 ), brakePedal)\n                                                                    acceleratorPedal = 0.2 * math.max( 1 - overSpeedLimit / 0.2 , 0 ) * acceleratorPedal -- fadeout the accelerator pedal over 0.2km/h, but immediately reduce to 20% (don\'t set to 0 directly so that the physics engine can still compensate if the brakes are too hard)\n                                                                    else\n                                                                            acceleratorPedal = acceleratorPedal * math.min( math.abs(overSpeedLimit) / 0.3 + 0.2 , 1 )\n                                                                            motor.overSpeedTimer = 0\n                                                                        end\n\n                                                                        if next( self.spec_motorized.differentials) ~ = nil and self.spec_motorized.motorizedNode ~ = nil then\n\n                                                                            local absAcceleratorPedal = math.abs(acceleratorPedal)\n                                                                            local minGearRatio, maxGearRatio = motor:getMinMaxGearRatio()\n\n                                                                            if maxGearRatio > = 0 then\n                                                                                maxSpeed = motor:getMaximumForwardSpeed()\n                                                                            else\n                                                                                    maxSpeed = motor:getMaximumBackwardSpeed()\n                                                                                end\n\n                                                                                local acceleratorPedalControlsSpeed = false\n                                                                                if acceleratorPedalControlsSpeed then\n                                                                                    maxSpeed = maxSpeed * absAcceleratorPedal\n                                                                                    if absAcceleratorPedal > 0.001 then\n                                                                                        absAcceleratorPedal = 1\n                                                                                    end\n                                                                                end\n                                                                                maxSpeed = math.min(maxSpeed, motor:getSpeedLimit() / 3.6 )\n                                                                                local maxAcceleration = motor:getAccelerationLimit()\n                                                                                local maxMotorRotAcceleration = motor:getMotorRotationAccelerationLimit()\n                                                                                local minMotorRpm, maxMotorRpm = motor:getRequiredMotorRpmRange()\n\n                                                                                local neededPtoTorque, ptoTorqueVirtualMultiplicator = PowerConsumer.getTotalConsumedPtoTorque( self )\n                                                                                neededPtoTorque = neededPtoTorque / motor:getPtoMotorRpmRatio()\n                                                                                local neutralActive = (minGearRatio = = 0 and maxGearRatio = = 0 ) or motor:getManualClutchPedal() > 0.90\n\n                                                                                motor:setExternalTorqueVirtualMultiplicator(ptoTorqueVirtualMultiplicator)\n\n                                                                                --print(string.format("set vehicle props:accPed = %.1f speed = %.1f gearRatio = [%.1f %.1f] rpm = [%.1f %.1f], ptoTorque = [%.1f]", absAcceleratorPedal, maxSpeed, minGearRatio, maxGearRatio, minMotorRpm, maxMotorRpm, neededPtoTorque))\n                                                                                if not neutralActive then\n                                                                                    self:controlVehicle(absAcceleratorPedal, maxSpeed, maxAcceleration, minMotorRpm * math.pi / 30 , maxMotorRpm * math.pi / 30 , maxMotorRotAcceleration, minGearRatio, maxGearRatio, motor:getMaxClutchTorque(), neededPtoTorque)\n                                                                                else\n                                                                                        self:controlVehicle( 0.0 , 0.0 , 0.0 , 0.0 , math.huge, 0.0 , 0.0 , 0.0 , 0.0 , 0.0 )\n\n                                                                                        -- slightly break while using manual + clutch and in neutral position\n                                                                                            -- to simulate a bit of rolling resistance\n                                                                                            brakePedal = math.max(brakePedal, 0.03 )\n                                                                                        end\n                                                                                    end\n\n                                                                                    self:brake(brakePedal)\n                                                                                end\n\n'})})]})}function h(e={}){const{wrapper:n}={...(0,l.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(c,{...e})}):c(e)}}}]);