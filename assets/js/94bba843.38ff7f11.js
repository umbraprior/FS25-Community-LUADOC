"use strict";(globalThis.webpackChunkfs25_community_luadoc=globalThis.webpackChunkfs25_community_luadoc||[]).push([[63688],{28453(e,n,i){i.d(n,{R:()=>r,x:()=>a});var t=i(96540);const l={},s=t.createContext(l);function r(e){const n=t.useContext(s);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(l):e.components||l:r(e.components),t.createElement(s.Provider,{value:n},e.children)}},56093(e,n,i){i.r(n),i.d(n,{assets:()=>h,contentTitle:()=>a,default:()=>g,frontMatter:()=>r,metadata:()=>t,toc:()=>o});const t=JSON.parse('{"id":"script/Specializations/PlaceableLights","title":"PlaceableLights","description":"PlaceableLights","source":"@site/../docs/script/Specializations/PlaceableLights.md","sourceDirName":"script/Specializations","slug":"/script/Specializations/PlaceableLights","permalink":"/FS25-Community-LUADOC/script/Specializations/PlaceableLights","draft":false,"unlisted":false,"tags":[],"version":"current","lastUpdatedAt":1767161192000,"frontMatter":{},"sidebar":"docsSidebar","previous":{"title":"PlaceableLeveling","permalink":"/FS25-Community-LUADOC/script/Specializations/PlaceableLeveling"},"next":{"title":"PlaceableManureHeap","permalink":"/FS25-Community-LUADOC/script/Specializations/PlaceableManureHeap"}}');var l=i(74848),s=i(28453);const r={},a=void 0,h={},o=[{value:"PlaceableLights",id:"placeablelights",level:2},{value:"getUseHighProfile",id:"getusehighprofile",level:3},{value:"lightSetupChanged",id:"lightsetupchanged",level:3},{value:"lightsTriggerCallback",id:"lightstriggercallback",level:3},{value:"onDelete",id:"ondelete",level:3},{value:"onFinalizePlacement",id:"onfinalizeplacement",level:3},{value:"onLoad",id:"onload",level:3},{value:"onReadStream",id:"onreadstream",level:3},{value:"onWriteStream",id:"onwritestream",level:3},{value:"prerequisitesPresent",id:"prerequisitespresent",level:3},{value:"registerEventListeners",id:"registereventlisteners",level:3},{value:"registerFunctions",id:"registerfunctions",level:3},{value:"registerXMLPaths",id:"registerxmlpaths",level:3},{value:"setGroupIsActive",id:"setgroupisactive",level:3},{value:"sharedLightLoaded",id:"sharedlightloaded",level:3},{value:"updateLightState",id:"updatelightstate",level:3}];function d(e){const n={a:"a",blockquote:"blockquote",code:"code",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,s.R)(),...e.components};return(0,l.jsxs)(l.Fragment,{children:[(0,l.jsx)(n.h2,{id:"placeablelights",children:"PlaceableLights"}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Description"})}),"\n",(0,l.jsxs)(n.blockquote,{children:["\n",(0,l.jsx)(n.p,{children:"Specialization for placeables"}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Functions"})}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsx)(n.li,{children:(0,l.jsx)(n.a,{href:"#getusehighprofile",children:"getUseHighProfile"})}),"\n",(0,l.jsx)(n.li,{children:(0,l.jsx)(n.a,{href:"#lightsetupchanged",children:"lightSetupChanged"})}),"\n",(0,l.jsx)(n.li,{children:(0,l.jsx)(n.a,{href:"#lightstriggercallback",children:"lightsTriggerCallback"})}),"\n",(0,l.jsx)(n.li,{children:(0,l.jsx)(n.a,{href:"#ondelete",children:"onDelete"})}),"\n",(0,l.jsx)(n.li,{children:(0,l.jsx)(n.a,{href:"#onfinalizeplacement",children:"onFinalizePlacement"})}),"\n",(0,l.jsx)(n.li,{children:(0,l.jsx)(n.a,{href:"#onload",children:"onLoad"})}),"\n",(0,l.jsx)(n.li,{children:(0,l.jsx)(n.a,{href:"#onreadstream",children:"onReadStream"})}),"\n",(0,l.jsx)(n.li,{children:(0,l.jsx)(n.a,{href:"#onwritestream",children:"onWriteStream"})}),"\n",(0,l.jsx)(n.li,{children:(0,l.jsx)(n.a,{href:"#prerequisitespresent",children:"prerequisitesPresent"})}),"\n",(0,l.jsx)(n.li,{children:(0,l.jsx)(n.a,{href:"#registereventlisteners",children:"registerEventListeners"})}),"\n",(0,l.jsx)(n.li,{children:(0,l.jsx)(n.a,{href:"#registerfunctions",children:"registerFunctions"})}),"\n",(0,l.jsx)(n.li,{children:(0,l.jsx)(n.a,{href:"#registerxmlpaths",children:"registerXMLPaths"})}),"\n",(0,l.jsx)(n.li,{children:(0,l.jsx)(n.a,{href:"#setgroupisactive",children:"setGroupIsActive"})}),"\n",(0,l.jsx)(n.li,{children:(0,l.jsx)(n.a,{href:"#sharedlightloaded",children:"sharedLightLoaded"})}),"\n",(0,l.jsx)(n.li,{children:(0,l.jsx)(n.a,{href:"#updatelightstate",children:"updateLightState"})}),"\n"]}),"\n",(0,l.jsx)(n.h3,{id:"getusehighprofile",children:"getUseHighProfile"}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Description"})}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Definition"})}),"\n",(0,l.jsxs)(n.blockquote,{children:["\n",(0,l.jsx)(n.p,{children:"getUseHighProfile()"}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Code"})}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-lua",children:"function PlaceableLights:getUseHighProfile()\n    local lightsProfile = g_gameSettings:getValue(GameSettings.SETTING.LIGHTS_PROFILE)\n    lightsProfile = Utils.getNoNil(Platform.gameplay.lightsProfile, lightsProfile)\n\n    return lightsProfile > = GS_PROFILE_HIGH\nend\n\n"})}),"\n",(0,l.jsx)(n.h3,{id:"lightsetupchanged",children:"lightSetupChanged"}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Description"})}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Definition"})}),"\n",(0,l.jsxs)(n.blockquote,{children:["\n",(0,l.jsx)(n.p,{children:"lightSetupChanged()"}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Code"})}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-lua",children:"function PlaceableLights:lightSetupChanged()\n    local spec = self.spec_lights\n    for k, group in ipairs(spec.groups) do\n        self:updateLightState(k, group.isActive)\n    end\nend\n\n"})}),"\n",(0,l.jsx)(n.h3,{id:"lightstriggercallback",children:"lightsTriggerCallback"}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Description"})}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Definition"})}),"\n",(0,l.jsxs)(n.blockquote,{children:["\n",(0,l.jsx)(n.p,{children:"lightsTriggerCallback()"}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,l.jsxs)(n.table,{children:[(0,l.jsx)(n.thead,{children:(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.th,{children:"any"}),(0,l.jsx)(n.th,{children:"triggerId"})]})}),(0,l.jsxs)(n.tbody,{children:[(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{children:"any"}),(0,l.jsx)(n.td,{children:"otherId"})]}),(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{children:"any"}),(0,l.jsx)(n.td,{children:"onEnter"})]}),(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{children:"any"}),(0,l.jsx)(n.td,{children:"onLeave"})]}),(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{children:"any"}),(0,l.jsx)(n.td,{children:"onStay"})]})]})]}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Code"})}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-lua",children:"function PlaceableLights:lightsTriggerCallback(triggerId, otherId, onEnter, onLeave, onStay)\n    local spec = self.spec_lights\n    local group = spec.triggerToGroup[triggerId]\n    if group ~ = nil then\n        if onEnter or onLeave then\n            local player = g_localPlayer\n            if player ~ = nil and otherId = = player.rootNode then\n                if onEnter then\n                    group.playerInRange = true\n                    g_currentMission.activatableObjectsSystem:addActivatable(spec.activatable)\n                    spec.activatable:setGroupIndex(group.index)\n                else\n                        group.playerInRange = false\n\n                        local inRangeOfOtherGroups = false\n                        for _, otherGroup in ipairs(spec.groups) do\n                            inRangeOfOtherGroups = inRangeOfOtherGroups or otherGroup.playerInRange\n                        end\n                        if not inRangeOfOtherGroups then\n                            g_currentMission.activatableObjectsSystem:removeActivatable(spec.activatable)\n                        end\n                    end\n                end\n            end\n        end\n    end\n\n"})}),"\n",(0,l.jsx)(n.h3,{id:"ondelete",children:"onDelete"}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Description"})}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Definition"})}),"\n",(0,l.jsxs)(n.blockquote,{children:["\n",(0,l.jsx)(n.p,{children:"onDelete()"}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Code"})}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-lua",children:"function PlaceableLights:onDelete()\n    local spec = self.spec_lights\n\n    if spec.sharedLights ~ = nil then\n        for _, light in ipairs(spec.sharedLights) do\n            if light.lightXMLFile ~ = nil then\n                light.lightXMLFile:delete()\n                light.lightXMLFile = nil\n            end\n\n            if light.sharedLoadRequestId ~ = nil then\n                g_i3DManager:releaseSharedI3DFile(light.sharedLoadRequestId)\n                light.sharedLoadRequestId = nil\n            end\n        end\n        spec.sharedLights = { }\n    end\n\n    g_messageCenter:unsubscribeAll( self )\n    g_currentMission.activatableObjectsSystem:removeActivatable(spec.activatable)\n\n    if spec.groups ~ = nil then\n        for _, group in ipairs(spec.groups) do\n            if group.triggerNode ~ = nil then\n                removeTrigger(group.triggerNode)\n            end\n\n            g_soundManager:deleteSamples(group.samples)\n        end\n        spec.groups = { }\n    end\nend\n\n"})}),"\n",(0,l.jsx)(n.h3,{id:"onfinalizeplacement",children:"onFinalizePlacement"}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Description"})}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Definition"})}),"\n",(0,l.jsxs)(n.blockquote,{children:["\n",(0,l.jsx)(n.p,{children:"onFinalizePlacement()"}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Code"})}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-lua",children:"function PlaceableLights:onFinalizePlacement()\n    self:lightSetupChanged()\nend\n\n"})}),"\n",(0,l.jsx)(n.h3,{id:"onload",children:"onLoad"}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Description"})}),"\n",(0,l.jsxs)(n.blockquote,{children:["\n",(0,l.jsx)(n.p,{children:"Called on loading"}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Definition"})}),"\n",(0,l.jsxs)(n.blockquote,{children:["\n",(0,l.jsx)(n.p,{children:"onLoad(table savegame)"}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n",(0,l.jsx)(n.table,{children:(0,l.jsx)(n.thead,{children:(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.th,{children:"table"}),(0,l.jsx)(n.th,{children:"savegame"}),(0,l.jsx)(n.th,{children:"savegame"})]})})}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Code"})}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-lua",children:'function PlaceableLights:onLoad(savegame)\n    local spec = self.spec_lights\n    local xmlFile = self.xmlFile\n\n    local environmentMaskSystem = g_currentMission.environment.environmentMaskSystem\n\n    spec.sharedLights = { }\n    spec.groups = { }\n    spec.triggerToGroup = { }\n\n    spec.activatable = PlaceableLightsActivatable.new( self )\n\n    g_messageCenter:subscribe(MessageType.SETTING_CHANGED[ "lightsProfile" ], self.lightSetupChanged, self )\n\n    xmlFile:iterate( "placeable.lights.group" , function (lightIndex, lightGroupKey)\n        local group = { }\n        group.triggerNode = xmlFile:getValue(lightGroupKey .. "#triggerNode" , nil , self.components, self.i3dMappings)\n        if group.triggerNode ~ = nil then\n            addTrigger(group.triggerNode, "lightsTriggerCallback" , self )\n            spec.triggerToGroup[group.triggerNode] = group\n        end\n\n        local inputActionName = xmlFile:getValue(lightGroupKey .. "#inputAction" , "INTERACT" )\n        group.inputAction = InputAction[inputActionName] or InputAction.INTERACT\n\n        group.name = xmlFile:getValue(lightGroupKey .. "#name" , "action_placeableLightShed" , self.customEnvironment)\n        group.activateText = xmlFile:getValue(lightGroupKey .. "#activateText" , "action_placeableLightPos" , self.customEnvironment)\n        group.deactivateText = xmlFile:getValue(lightGroupKey .. "#deactivateText" , "action_placeableLightNeg" , self.customEnvironment)\n\n        local activateTimeStr = xmlFile:getValue(lightGroupKey .. "#activateTime" , nil )\n        if activateTimeStr ~ = nil then\n            group.activateMinute = Utils.getMinuteOfDayFromTime(activateTimeStr)\n            if group.activateMinute = = nil then\n                Logging.xmlWarning(xmlFile, "Invalid activateTime string \'%s\' given for group \'%s\'.Use \'hh:mm\' format" , activateTimeStr, lightGroupKey)\n                else\n                        group.activateMinute = math.max( 1 , group.activateMinute) -- if a time is set, it has to be at least 1 since 0 = = disabled\n                        end\n                    end\n\n                    local deactivateTimeStr = xmlFile:getValue(lightGroupKey .. "#deactivateTime" , nil )\n                    if deactivateTimeStr ~ = nil then\n                        group.deactivateMinute = Utils.getMinuteOfDayFromTime(deactivateTimeStr)\n                        if group.deactivateMinute = = nil then\n                            Logging.xmlWarning(xmlFile, "Invalid deactivateTime string \'%s\' given for group \'%s\'.Use \'hh:mm\' format" , deactivateTimeStr, lightGroupKey)\n                            else\n                                    group.deactivateMinute = math.max( 1 , group.deactivateMinute) -- if a time is set, it has to be at least 1 since 0 = = disabled\n                                    end\n                                end\n\n                                group.weatherRequiredMask = environmentMaskSystem:getWeatherMaskFromFlagNames(xmlFile:getValue(lightGroupKey .. "#weatherRequiredFlags" , nil ))\n                                group.weatherPreventMask = environmentMaskSystem:getWeatherMaskFromFlagNames(xmlFile:getValue(lightGroupKey .. "#weatherPreventFlags" , nil ))\n\n                                if self.isClient then\n                                    group.samples = { }\n                                    group.samples.toggle = g_soundManager:loadSampleFromXML(xmlFile, lightGroupKey .. ".sounds" , "toggle" , self.baseDirectory, self.components, 1 , AudioGroup.ENVIRONMENT, self.i3dMappings, nil )\n                                end\n\n                                if (group.activateMinute ~ = nil and group.deactivateMinute) = = nil or(group.deactivateMinute = = nil and group.activateMinute ~ = nil ) then\n                                    Logging.xmlWarning(xmlFile, "Incomplete automatic toggle time in \'%s\'" , lightGroupKey)\n                                else\n                                        group.hasManualLights = group.triggerNode ~ = nil\n\n                                        group.isActive = false\n                                        group.playerInRange = false\n\n                                        if #spec.groups < PlaceableLights.MAX_NUM_GROUPS then\n                                            table.insert(spec.groups, group)\n                                            group.index = #spec.groups\n                                        else\n                                                Logging.xmlWarning(xmlFile, "Too many light groups registered.Max. %d are allowed" , PlaceableLights.MAX_NUM_GROUPS)\n                                            end\n                                        end\n                                    end )\n\n                                    xmlFile:iterate( "placeable.lights.sharedLight" , function (lightIndex, lightKey)\n                                        local sharedLight = { }\n\n                                        local xmlFilename = xmlFile:getValue(lightKey .. "#filename" )\n                                        if xmlFilename ~ = nil then\n                                            sharedLight.xmlFilename = Utils.getFilename(xmlFilename, self.baseDirectory)\n                                            sharedLight.groupIndex = xmlFile:getValue(lightKey .. "#groupIndex" , 1 )\n                                            sharedLight.color = xmlFile:getValue(lightKey .. "#color" , nil , true )\n                                            sharedLight.linkNode = xmlFile:getValue(lightKey .. "#linkNode" , "0>" , self.components, self.i3dMappings)\n\n                                            local group = spec.groups[sharedLight.groupIndex]\n                                            if group = = nil then\n                                                Logging.xmlError(xmlFile, "Group index \'%d\' in \'%s\' does not exist" , sharedLight.groupIndex, lightKey)\n                                            else\n                                                    if sharedLight.linkNode ~ = nil then\n                                                        xmlFile:iterate(lightKey .. ".rotationNode" , function (rotIndex, rotKey)\n                                                            local name = xmlFile:getValue(rotKey .. "#name" )\n                                                            local rotation = xmlFile:getValue(rotKey .. "#rotation" , nil , true )\n                                                            if name ~ = nil and rotation ~ = nil then\n                                                                sharedLight.rotations = sharedLight.rotations or { }\n                                                                sharedLight.rotations[name] = rotation\n                                                            end\n                                                        end )\n\n                                                        local lightXMLFile = XMLFile.load( "placeableSharedLight" , sharedLight.xmlFilename, SharedLight.xmlSchema)\n                                                        if lightXMLFile ~ = nil then\n                                                            local filename = lightXMLFile:getValue( "light.filename" )\n                                                            if filename ~ = nil then\n                                                                local loadingTask = self:createLoadingTask(spec)\n                                                                filename = Utils.getFilename(filename, self.baseDirectory)\n\n                                                                local arguments = {\n                                                                sharedLight = sharedLight,\n                                                                lightXMLFile = lightXMLFile,\n                                                                loadingTask = loadingTask,\n                                                                group = group,\n                                                                filename = filename\n                                                                }\n                                                                sharedLight.lightXMLFile = lightXMLFile\n                                                                sharedLight.sharedLoadRequestId = g_i3DManager:loadSharedI3DFileAsync(filename, false , false , self.sharedLightLoaded, self , arguments)\n                                                                table.insert(spec.sharedLights, sharedLight)\n                                                            else\n                                                                    Logging.xmlWarning(lightXMLFile, "Missing light i3d filename!" )\n                                                                    lightXMLFile:delete()\n                                                                end\n                                                            end\n                                                        end\n                                                    end\n                                                end\n                                            end )\n\n                                            spec.lightShapes = { } -- self illum faces within the placeable, only shader will be applied, always stay visible\n\n                                            local getNodeShaderLightIntensity = function (node)\n                                                if getHasClassId(node, ClassIds.SHAPE) and getHasShaderParameter(node, "lightControl" ) then\n                                                    local x = getShaderParameter(node, "lightControl" )\n                                                    return x\n                                                end\n                                                return 1\n                                            end\n\n                                            xmlFile:iterate( "placeable.lights.lightShape" , function (lightIndex, lightKey)\n                                                local lightShape = { }\n\n                                                lightShape.groupIndex = xmlFile:getValue(lightKey .. "#groupIndex" , 1 )\n                                                lightShape.node = xmlFile:getValue(lightKey .. "#node" , "0>" , self.components, self.i3dMappings)\n                                                if lightShape.node ~ = nil then\n                                                    lightShape.intensity = xmlFile:getValue(lightKey .. "#intensity" , getNodeShaderLightIntensity(lightShape.node))\n\n                                                    local group = spec.groups[lightShape.groupIndex]\n                                                    if group = = nil then\n                                                        Logging.xmlError(xmlFile, "Group index \'%d\' in \'%s\' does not exist" , lightShape.groupIndex, lightKey)\n                                                    else\n                                                            if not group.hasManualLights then\n                                                                if group.activateMinute ~ = nil then\n                                                                    setVisibilityConditionMinuteOfDay(lightShape.node, group.activateMinute, group.deactivateMinute)\n                                                                end\n                                                                if group.weatherRequiredMask ~ = nil or group.weatherPreventMask ~ = nil then\n                                                                    setVisibilityConditionWeatherMask(lightShape.node, group.weatherRequiredMask or 0 , group.weatherPreventMask or 0 )\n                                                                end\n\n                                                                setVisibilityConditionRenderInvisible(lightShape.node, true ) -- still render self illum faces when group is not visible, only apply shader\n                                                                setVisibilityConditionVisibleShaderParameter(lightShape.node, lightShape.intensity)\n                                                            end\n                                                        end\n                                                        table.insert(spec.lightShapes, lightShape)\n                                                    end\n                                                end )\n\n                                                spec.realLights = {\n                                                low = { } ,\n                                                high = { } ,\n                                                }\n                                                local loadRealLight = function (realLightKey, insertTable)\n                                                    local realLight = { }\n                                                    realLight.node = xmlFile:getValue(realLightKey .. "#node" , nil , self.components, self.i3dMappings)\n                                                    if realLight.node ~ = nil then\n                                                        realLight.groupIndex = xmlFile:getValue(realLightKey .. "#groupIndex" , 1 )\n\n                                                        local group = spec.groups[realLight.groupIndex]\n                                                        if group = = nil then\n                                                            Logging.xmlError(xmlFile, "Group index \'%d\' in \'%s\' does not exist" , realLight.groupIndex, realLightKey)\n                                                        else\n                                                                if group.activateMinute ~ = nil then\n                                                                    setVisibilityConditionMinuteOfDay(realLight.node, group.activateMinute, group.deactivateMinute)\n                                                                end\n                                                                if group.weatherRequiredMask ~ = nil or group.weatherPreventMask ~ = nil then\n                                                                    setVisibilityConditionWeatherMask(realLight.node, group.weatherRequiredMask or 0 , group.weatherPreventMask or 0 )\n                                                                end\n\n                                                                table.insert(insertTable, realLight)\n                                                            end\n                                                        end\n                                                    end\n\n                                                    xmlFile:iterate( "placeable.lights.realLights.low.light" , function (lightIndex, lightKey)\n                                                        loadRealLight(lightKey, spec.realLights.low)\n                                                    end )\n\n                                                    xmlFile:iterate( "placeable.lights.realLights.high.light" , function (lightIndex, lightKey)\n                                                        loadRealLight(lightKey, spec.realLights.high)\n                                                    end )\n                                                end\n\n'})}),"\n",(0,l.jsx)(n.h3,{id:"onreadstream",children:"onReadStream"}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Description"})}),"\n",(0,l.jsxs)(n.blockquote,{children:["\n",(0,l.jsx)(n.p,{children:"Called on client side on join"}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Definition"})}),"\n",(0,l.jsxs)(n.blockquote,{children:["\n",(0,l.jsx)(n.p,{children:"onReadStream(integer streamId, table connection)"}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,l.jsxs)(n.table,{children:[(0,l.jsx)(n.thead,{children:(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.th,{children:"integer"}),(0,l.jsx)(n.th,{children:"streamId"}),(0,l.jsx)(n.th,{children:"stream ID"})]})}),(0,l.jsx)(n.tbody,{children:(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{children:"table"}),(0,l.jsx)(n.td,{children:"connection"}),(0,l.jsx)(n.td,{children:"connection"})]})})]}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Code"})}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-lua",children:"function PlaceableLights:onReadStream(streamId, connection)\n    local spec = self.spec_lights\n    for k, group in ipairs(spec.groups) do\n        if group.hasManualLights then\n            self:setGroupIsActive(k, streamReadBool(streamId), true )\n        end\n    end\nend\n\n"})}),"\n",(0,l.jsx)(n.h3,{id:"onwritestream",children:"onWriteStream"}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Description"})}),"\n",(0,l.jsxs)(n.blockquote,{children:["\n",(0,l.jsx)(n.p,{children:"Called on server side on join"}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Definition"})}),"\n",(0,l.jsxs)(n.blockquote,{children:["\n",(0,l.jsx)(n.p,{children:"onWriteStream(integer streamId, table connection)"}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,l.jsxs)(n.table,{children:[(0,l.jsx)(n.thead,{children:(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.th,{children:"integer"}),(0,l.jsx)(n.th,{children:"streamId"}),(0,l.jsx)(n.th,{children:"stream ID"})]})}),(0,l.jsx)(n.tbody,{children:(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{children:"table"}),(0,l.jsx)(n.td,{children:"connection"}),(0,l.jsx)(n.td,{children:"connection"})]})})]}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Code"})}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-lua",children:"function PlaceableLights:onWriteStream(streamId, connection)\n    local spec = self.spec_lights\n    for _, group in ipairs(spec.groups) do\n        if group.hasManualLights then\n            streamWriteBool(streamId, group.isActive)\n        end\n    end\nend\n\n"})}),"\n",(0,l.jsx)(n.h3,{id:"prerequisitespresent",children:"prerequisitesPresent"}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Description"})}),"\n",(0,l.jsxs)(n.blockquote,{children:["\n",(0,l.jsx)(n.p,{children:"Checks if all prerequisite specializations are loaded"}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Definition"})}),"\n",(0,l.jsxs)(n.blockquote,{children:["\n",(0,l.jsx)(n.p,{children:"prerequisitesPresent(table specializations)"}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n",(0,l.jsx)(n.table,{children:(0,l.jsx)(n.thead,{children:(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.th,{children:"table"}),(0,l.jsx)(n.th,{children:"specializations"}),(0,l.jsx)(n.th,{children:"specializations"})]})})}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Return Values"})}),"\n\n\n\n\n\n\n\n\n",(0,l.jsx)(n.table,{children:(0,l.jsx)(n.thead,{children:(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.th,{children:"table"}),(0,l.jsx)(n.th,{children:"hasPrerequisite"}),(0,l.jsx)(n.th,{children:"true if all prerequisite specializations are loaded"})]})})}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Code"})}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-lua",children:"function PlaceableLights.prerequisitesPresent(specializations)\n    return true\nend\n\n"})}),"\n",(0,l.jsx)(n.h3,{id:"registereventlisteners",children:"registerEventListeners"}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Description"})}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Definition"})}),"\n",(0,l.jsxs)(n.blockquote,{children:["\n",(0,l.jsx)(n.p,{children:"registerEventListeners()"}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,l.jsx)(n.table,{children:(0,l.jsx)(n.thead,{children:(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.th,{children:"any"}),(0,l.jsx)(n.th,{children:"placeableType"})]})})}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Code"})}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-lua",children:'function PlaceableLights.registerEventListeners(placeableType)\n    SpecializationUtil.registerEventListener(placeableType, "onLoad" , PlaceableLights )\n    SpecializationUtil.registerEventListener(placeableType, "onDelete" , PlaceableLights )\n    SpecializationUtil.registerEventListener(placeableType, "onWriteStream" , PlaceableLights )\n    SpecializationUtil.registerEventListener(placeableType, "onReadStream" , PlaceableLights )\n    SpecializationUtil.registerEventListener(placeableType, "onFinalizePlacement" , PlaceableLights )\nend\n\n'})}),"\n",(0,l.jsx)(n.h3,{id:"registerfunctions",children:"registerFunctions"}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Description"})}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Definition"})}),"\n",(0,l.jsxs)(n.blockquote,{children:["\n",(0,l.jsx)(n.p,{children:"registerFunctions()"}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,l.jsx)(n.table,{children:(0,l.jsx)(n.thead,{children:(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.th,{children:"any"}),(0,l.jsx)(n.th,{children:"placeableType"})]})})}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Code"})}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-lua",children:'function PlaceableLights.registerFunctions(placeableType)\n    SpecializationUtil.registerFunction(placeableType, "lightSetupChanged" , PlaceableLights.lightSetupChanged)\n    SpecializationUtil.registerFunction(placeableType, "getUseHighProfile" , PlaceableLights.getUseHighProfile)\n    SpecializationUtil.registerFunction(placeableType, "setGroupIsActive" , PlaceableLights.setGroupIsActive)\n    SpecializationUtil.registerFunction(placeableType, "lightsTriggerCallback" , PlaceableLights.lightsTriggerCallback)\n    SpecializationUtil.registerFunction(placeableType, "sharedLightLoaded" , PlaceableLights.sharedLightLoaded)\n    SpecializationUtil.registerFunction(placeableType, "updateLightState" , PlaceableLights.updateLightState)\nend\n\n'})}),"\n",(0,l.jsx)(n.h3,{id:"registerxmlpaths",children:"registerXMLPaths"}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Description"})}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Definition"})}),"\n",(0,l.jsxs)(n.blockquote,{children:["\n",(0,l.jsx)(n.p,{children:"registerXMLPaths()"}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,l.jsxs)(n.table,{children:[(0,l.jsx)(n.thead,{children:(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.th,{children:"any"}),(0,l.jsx)(n.th,{children:"schema"})]})}),(0,l.jsx)(n.tbody,{children:(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{children:"any"}),(0,l.jsx)(n.td,{children:"basePath"})]})})]}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Code"})}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-lua",children:'function PlaceableLights.registerXMLPaths(schema, basePath)\n    schema:setXMLSpecializationType( "Lights" )\n    schema:register(XMLValueType.STRING, basePath .. ".lights.sharedLight(?)#filename" , "Path to shared light xml file" )\n    schema:register(XMLValueType.INT, basePath .. ".lights.sharedLight(?)#groupIndex" , "Parent group" , 1 )\n    schema:register(XMLValueType.NODE_INDEX, basePath .. ".lights.sharedLight(?)#linkNode" , "Link node" )\n    schema:register(XMLValueType.COLOR, basePath .. ".lights.sharedLight(?)#color" , "Light color" )\n    schema:register(XMLValueType.STRING, basePath .. ".lights.sharedLight(?).rotationNode(?)#name" , "Rotation node name" )\n    schema:register(XMLValueType.VECTOR_ROT, basePath .. ".lights.sharedLight(?).rotationNode(?)#rotation" , "Rotation to set" )\n\n    schema:register(XMLValueType.INT, basePath .. ".lights.lightShape(?)#groupIndex" , "Parent group" , 1 )\n    schema:register(XMLValueType.NODE_INDEX, basePath .. ".lights.lightShape(?)#node" , "Light shape / self-illum-mesh node.Always visible, only shader is set" )\n    schema:register(XMLValueType.FLOAT, basePath .. ".lights.lightShape(?)#intensity" , "Intensity for the shader if active" , 5 )\n\n        schema:register(XMLValueType.NODE_INDEX, basePath .. ".lights.realLights.low.light(?)#node" , "Real light node used on low performance profile.Visibility is toggled based on settings" )\n        schema:register(XMLValueType.INT, basePath .. ".lights.realLights.low.light(?)#groupIndex" , "Parent group" , 1 )\n        schema:register(XMLValueType.NODE_INDEX, basePath .. ".lights.realLights.high.light(?)#node" , "Real light node used on high performance profile.Visibility is toggled based on settings" )\n        schema:register(XMLValueType.INT, basePath .. ".lights.realLights.high.light(?)#groupIndex" , "Parent group" , 1 )\n\n        schema:register(XMLValueType.NODE_INDEX, basePath .. ".lights.group(?)#triggerNode" , "Activation Trigger for manual control" )\n            schema:register(XMLValueType.STRING, basePath .. ".lights.group(?)#inputAction" , "Input Action name" , "INTERACT" )\n            schema:register(XMLValueType.L10N_STRING, basePath .. ".lights.group(?)#name" , "Group name for display" , "action_placeableLightShed" )\n                schema:register(XMLValueType.L10N_STRING, basePath .. ".lights.group(?)#activateText" , "Activate text to display in help menu" , "action_placeableLightPos" )\n                schema:register(XMLValueType.L10N_STRING, basePath .. ".lights.group(?)#deactivateText" , "Deactivate text to display in help menu" , "action_placeableLightNeg" )\n\n                schema:register(XMLValueType.STRING, basePath .. ".lights.group(?)#activateTime" , "If defined, light will be turned on at this time of day.Format hh:mm" )\n                schema:register(XMLValueType.STRING, basePath .. ".lights.group(?)#deactivateTime" , "If defined, light will be turned off at this time of day.Format hh:mm" )\n                schema:register(XMLValueType.STRING, basePath .. ".lights.group(?)#weatherRequiredFlags" , "Space separated list of environment flag names to be used as required mask" )\n                schema:register(XMLValueType.STRING, basePath .. ".lights.group(?)#weatherPreventFlags" , "Space separated list of environment flag names to be used as prevent mask" )\n\n                SoundManager.registerSampleXMLPaths(schema, basePath .. ".lights.group(?).sounds" , "toggle" )\n\n                schema:setXMLSpecializationType()\n            end\n\n'})}),"\n",(0,l.jsx)(n.h3,{id:"setgroupisactive",children:"setGroupIsActive"}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Description"})}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Definition"})}),"\n",(0,l.jsxs)(n.blockquote,{children:["\n",(0,l.jsx)(n.p,{children:"setGroupIsActive()"}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,l.jsxs)(n.table,{children:[(0,l.jsx)(n.thead,{children:(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.th,{children:"any"}),(0,l.jsx)(n.th,{children:"groupIndex"})]})}),(0,l.jsxs)(n.tbody,{children:[(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{children:"any"}),(0,l.jsx)(n.td,{children:"isActive"})]}),(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{children:"any"}),(0,l.jsx)(n.td,{children:"noEventSend"})]})]})]}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Code"})}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-lua",children:"function PlaceableLights:setGroupIsActive(groupIndex, isActive, noEventSend)\n    local spec = self.spec_lights\n    local group = spec.groups[groupIndex]\n    if group ~ = nil then\n        -- group is always active unless toggled by script\n        group.isActive = Utils.getNoNil(isActive, not group.isActive)\n\n        self:updateLightState(groupIndex, group.isActive)\n\n        PlaceableLightsStateEvent.sendEvent( self , groupIndex, group.isActive, noEventSend)\n\n        if self.isClient then\n            g_soundManager:playSample(group.samples.toggle, 1 )\n        end\n    end\nend\n\n"})}),"\n",(0,l.jsx)(n.h3,{id:"sharedlightloaded",children:"sharedLightLoaded"}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Description"})}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Definition"})}),"\n",(0,l.jsxs)(n.blockquote,{children:["\n",(0,l.jsx)(n.p,{children:"sharedLightLoaded()"}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,l.jsxs)(n.table,{children:[(0,l.jsx)(n.thead,{children:(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.th,{children:"any"}),(0,l.jsx)(n.th,{children:"i3dNode"})]})}),(0,l.jsxs)(n.tbody,{children:[(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{children:"any"}),(0,l.jsx)(n.td,{children:"failedReason"})]}),(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{children:"any"}),(0,l.jsx)(n.td,{children:"args"})]})]})]}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Code"})}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-lua",children:'function PlaceableLights:sharedLightLoaded(i3dNode, failedReason, args)\n    local sharedLight = args.sharedLight\n    local lightXMLFile = args.lightXMLFile\n    local loadingTask = args.loadingTask\n    local lightGroup = args.group\n    local i3dFilename = args.filename\n\n    if i3dNode ~ = nil and i3dNode ~ = 0 then\n        if self.loadingState = = PlaceableLoadingState.OK then\n            sharedLight.node = lightXMLFile:getValue( "light.rootNode#node" , "0" , i3dNode)\n            sharedLight.i3dFilename = i3dFilename\n\n            sharedLight.lightShapes = { }\n            lightXMLFile:iterate( "light.defaultLight" , function (lightIndex, lightKey)\n                local lightShape = { }\n                lightShape.node = lightXMLFile:getValue(lightKey .. "#node" , nil , i3dNode)\n                if lightShape.node ~ = nil then\n                    if getHasShaderParameter(lightShape.node, "lightControl" ) then\n                        lightShape.intensity = lightXMLFile:getValue(lightKey .. "#intensity" , 5 )\n\n                        if lightGroup.hasManualLights then\n                            setShaderParameter(lightShape.node, "lightControl" , 0 , 0 , 0 , 0 , false )\n                        else\n                                if lightGroup.activateMinute ~ = nil then\n                                    setVisibilityConditionMinuteOfDay(lightShape.node, lightGroup.activateMinute, lightGroup.deactivateMinute)\n                                end\n                                if lightGroup.weatherRequiredMask ~ = nil or lightGroup.weatherPreventMask ~ = nil then\n                                    setVisibilityConditionWeatherMask(lightShape.node, lightGroup.weatherRequiredMask or 0 , lightGroup.weatherPreventMask or 0 )\n                                end\n                                setVisibilityConditionRenderInvisible(lightShape.node, true ) -- still render self illum faces when group is not visible, only apply shader\n                                setVisibilityConditionVisibleShaderParameter(lightShape.node, lightShape.intensity)\n                            end\n\n                            table.insert(sharedLight.lightShapes, lightShape)\n                        else\n                                Logging.xmlWarning(lightXMLFile, "Node \'%s\' has no shaderparameter \'lightControl\'.Ignoring node!" , getName(lightShape.node))\n                            end\n\n                            if sharedLight.color ~ = nil and getHasShaderParameter(lightShape.node, "colorScale" ) then\n                                setShaderParameter(lightShape.node, "colorScale" , sharedLight.color[ 1 ], sharedLight.color[ 2 ], sharedLight.color[ 3 ], 0 , false )\n                            end\n                        else\n                                Logging.xmlWarning(lightXMLFile, "Could not find node for \'%s\'!" , lightKey)\n                                end\n                            end )\n\n                            lightXMLFile:iterate( "light.rotationNode" , function (rotIndex, rotKey)\n                                local name = lightXMLFile:getValue(rotKey .. "#name" )\n                                if name ~ = nil then\n                                    local node = lightXMLFile:getValue(rotKey .. "#node" , nil , i3dNode)\n                                    if sharedLight.rotations ~ = nil and sharedLight.rotations[name] ~ = nil then\n                                        setRotation(node, unpack(sharedLight.rotations[name]))\n                                    end\n                                end\n                            end )\n                            sharedLight.rotations = nil\n\n                            link(sharedLight.linkNode, sharedLight.node)\n                        end\n\n                        delete(i3dNode)\n                    end\n\n                    lightXMLFile:delete()\n                    sharedLight.lightXMLFile = nil\n\n                    self:finishLoadingTask(loadingTask)\n                end\n\n'})}),"\n",(0,l.jsx)(n.h3,{id:"updatelightstate",children:"updateLightState"}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Description"})}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Definition"})}),"\n",(0,l.jsxs)(n.blockquote,{children:["\n",(0,l.jsx)(n.p,{children:"updateLightState()"}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,l.jsxs)(n.table,{children:[(0,l.jsx)(n.thead,{children:(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.th,{children:"any"}),(0,l.jsx)(n.th,{children:"groupIndex"})]})}),(0,l.jsx)(n.tbody,{children:(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{children:"any"}),(0,l.jsx)(n.td,{children:"isActive"})]})})]}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Code"})}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-lua",children:'function PlaceableLights:updateLightState(groupIndex, isActive)\n    local spec = self.spec_lights\n    local group = spec.groups[groupIndex]\n\n    if group.hasManualLights then\n        -- visibility condition shapes have their intensity set once on load\n        for _, sharedLight in ipairs(spec.sharedLights) do\n            if sharedLight.groupIndex = = groupIndex then\n                for j = 1 , #sharedLight.lightShapes do\n                    local lightShape = sharedLight.lightShapes[j]\n                    setShaderParameter(lightShape.node, "lightControl" , isActive and lightShape.intensity or 0 , 0 , 0 , 0 , false )\n                end\n            end\n        end\n\n        for _, lightShape in ipairs(spec.lightShapes) do\n            if lightShape.groupIndex = = groupIndex then\n                setShaderParameter(lightShape.node, "lightControl" , isActive and lightShape.intensity or 0 , 0 , 0 , 0 , false )\n            end\n        end\n    end\n\n    local activeLightSetup = spec.realLights.low\n    local inactiveLightSetup = spec.realLights.high\n    if self:getUseHighProfile() then\n        activeLightSetup = spec.realLights.high\n        inactiveLightSetup = spec.realLights.low\n    end\n\n    for _, realLight in ipairs(activeLightSetup) do\n        if realLight.groupIndex = = groupIndex then\n            setVisibility(realLight.node, not group.hasManualLights or isActive) -- lights are always active for groups which cannot be toggled manually(visibility condition)\n            end\n        end\n\n        for _, realLight in ipairs(inactiveLightSetup) do\n            if realLight.groupIndex = = groupIndex then\n                setVisibility(realLight.node, false )\n            end\n        end\n    end\n\n'})})]})}function g(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,l.jsx)(n,{...e,children:(0,l.jsx)(d,{...e})}):d(e)}}}]);