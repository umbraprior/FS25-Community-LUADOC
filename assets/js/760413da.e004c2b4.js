"use strict";(globalThis.webpackChunkfs25_community_luadoc=globalThis.webpackChunkfs25_community_luadoc||[]).push([[45729],{28453(e,n,t){t.d(n,{R:()=>a,x:()=>l});var i=t(96540);const s={},r=i.createContext(s);function a(e){const n=i.useContext(r);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:a(e.components),i.createElement(r.Provider,{value:n},e.children)}},85704(e,n,t){t.r(n),t.d(n,{assets:()=>o,contentTitle:()=>l,default:()=>h,frontMatter:()=>a,metadata:()=>i,toc:()=>c});const i=JSON.parse('{"id":"script/Shop/StoreManager","title":"StoreManager","description":"StoreManager","source":"@site/../docs/script/Shop/StoreManager.md","sourceDirName":"script/Shop","slug":"/script/Shop/StoreManager","permalink":"/FS25-Community-LUADOC/script/Shop/StoreManager","draft":false,"unlisted":false,"tags":[],"version":"current","lastUpdatedAt":1767161192000,"frontMatter":{},"sidebar":"docsSidebar","previous":{"title":"BuyVehicleData","permalink":"/FS25-Community-LUADOC/script/Shop/BuyVehicleData"},"next":{"title":"ServerSoundManager","permalink":"/FS25-Community-LUADOC/script/Sounds/ServerSoundManager"}}');var s=t(74848),r=t(28453);const a={},l=void 0,o={},c=[{value:"StoreManager",id:"storemanager",level:2},{value:"addCategory",id:"addcategory",level:3},{value:"addConstructionCategory",id:"addconstructioncategory",level:3},{value:"addConstructionTab",id:"addconstructiontab",level:3},{value:"addItem",id:"additem",level:3},{value:"addModStoreItem",id:"addmodstoreitem",level:3},{value:"addModStorePack",id:"addmodstorepack",level:3},{value:"addPack",id:"addpack",level:3},{value:"addPackItem",id:"addpackitem",level:3},{value:"addSpecType",id:"addspectype",level:3},{value:"consoleCommandReloadStoreItems",id:"consolecommandreloadstoreitems",level:3},{value:"getCategoryByName",id:"getcategorybyname",level:3},{value:"getConstructionCategories",id:"getconstructioncategories",level:3},{value:"getConstructionCategoryByName",id:"getconstructioncategorybyname",level:3},{value:"getConstructionTabByName",id:"getconstructiontabbyname",level:3},{value:"getIsItemUnlocked",id:"getisitemunlocked",level:3},{value:"getItemByCustomEnvironment",id:"getitembycustomenvironment",level:3},{value:"getItemByIndex",id:"getitembyindex",level:3},{value:"getItemByXMLFilename",id:"getitembyxmlfilename",level:3},{value:"getItems",id:"getitems",level:3},{value:"getItemsByCombinationData",id:"getitemsbycombinationdata",level:3},{value:"getPackItems",id:"getpackitems",level:3},{value:"getPacks",id:"getpacks",level:3},{value:"getSpecTypeByName",id:"getspectypebyname",level:3},{value:"getSpecTypeByProfile",id:"getspectypebyprofile",level:3},{value:"getSpecTypes",id:"getspectypes",level:3},{value:"initDataStructures",id:"initdatastructures",level:3},{value:"loadCategoryFromXML",id:"loadcategoryfromxml",level:3},{value:"loadItem",id:"loaditem",level:3},{value:"loadItemsFromXML",id:"loaditemsfromxml",level:3},{value:"loadMapData",id:"loadmapdata",level:3},{value:"new",id:"new",level:3},{value:"registerStoreDataXMLPaths",id:"registerstoredataxmlpaths",level:3},{value:"removeItemByIndex",id:"removeitembyindex",level:3},{value:"unloadMapData",id:"unloadmapdata",level:3}];function d(e){const n={a:"a",blockquote:"blockquote",code:"code",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,r.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.h2,{id:"storemanager",children:"StoreManager"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"This class handles all store categories and items"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Parent"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.a,{href:"?version=script&category=75&class=615",children:"AbstractManager"})}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Functions"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#addcategory",children:"addCategory"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#addconstructioncategory",children:"addConstructionCategory"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#addconstructiontab",children:"addConstructionTab"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#additem",children:"addItem"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#addmodstoreitem",children:"addModStoreItem"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#addmodstorepack",children:"addModStorePack"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#addpack",children:"addPack"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#addpackitem",children:"addPackItem"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#addspectype",children:"addSpecType"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#consolecommandreloadstoreitems",children:"consoleCommandReloadStoreItems"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#getcategorybyname",children:"getCategoryByName"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#getconstructioncategories",children:"getConstructionCategories"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#getconstructioncategorybyname",children:"getConstructionCategoryByName"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#getconstructiontabbyname",children:"getConstructionTabByName"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#getisitemunlocked",children:"getIsItemUnlocked"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#getitembycustomenvironment",children:"getItemByCustomEnvironment"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#getitembyindex",children:"getItemByIndex"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#getitembyxmlfilename",children:"getItemByXMLFilename"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#getitems",children:"getItems"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#getitemsbycombinationdata",children:"getItemsByCombinationData"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#getpackitems",children:"getPackItems"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#getpacks",children:"getPacks"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#getspectypebyname",children:"getSpecTypeByName"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#getspectypebyprofile",children:"getSpecTypeByProfile"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#getspectypes",children:"getSpecTypes"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#initdatastructures",children:"initDataStructures"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#loadcategoryfromxml",children:"loadCategoryFromXML"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#loaditem",children:"loadItem"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#loaditemsfromxml",children:"loadItemsFromXML"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#loadmapdata",children:"loadMapData"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#new",children:"new"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#registerstoredataxmlpaths",children:"registerStoreDataXMLPaths"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#removeitembyindex",children:"removeItemByIndex"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#unloadmapdata",children:"unloadMapData"})}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"addcategory",children:"addCategory"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"Adds a new store category"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Definition"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"addCategory(string name, string title, string imageFilename, string categoryTypeName, string baseDir, string\ninsertAfter)"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"string"}),(0,s.jsx)(n.th,{children:"name"}),(0,s.jsx)(n.th,{children:"category index name"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"string"}),(0,s.jsx)(n.td,{children:"title"}),(0,s.jsx)(n.td,{children:"category title"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"string"}),(0,s.jsx)(n.td,{children:"imageFilename"}),(0,s.jsx)(n.td,{children:"image"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"string"}),(0,s.jsx)(n.td,{children:"categoryTypeName"}),(0,s.jsx)(n.td,{children:"name of the category type"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"string"}),(0,s.jsx)(n.td,{children:"baseDir"}),(0,s.jsx)(n.td,{children:"base directory"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"string"}),(0,s.jsx)(n.td,{children:"insertAfter"}),(0,s.jsx)(n.td,{children:"insert the category after this category name"})]})]})]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Return Values"})}),"\n\n\n\n\n\n\n\n\n",(0,s.jsx)(n.table,{children:(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"string"}),(0,s.jsx)(n.th,{children:"true"}),(0,s.jsx)(n.th,{children:"if adding was successful else false"})]})})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Code"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:'function StoreManager:addCategory(name, title, imageFilename, categoryTypeName, baseDir, insertAfter)\n    if string.isNilOrWhitespace(name) then\n        Logging.warning( "Could not register store category.Name is missing or empty!" )\n        return false\n    end\n    if not ClassUtil.getIsValidIndexName(name) then\n        Logging.warning( "Could not register store category \'%s\'.Invalid name for a category!" , name)\n            return false\n        end\n        if string.isNilOrWhitespace(title) then\n            Logging.warning( "Could not register store category \'%s\'.Title is missing or empty!" , name)\n            return false\n        end\n        if string.isNilOrWhitespace(imageFilename) then\n            Logging.warning( "Could not register store category \'%s\'.Image is missing or empty!" , name)\n            return false\n        end\n        if baseDir = = nil then\n            Logging.warning( "Could not register store category \'%s\'.Basedirectory not defined!" , name)\n            return false\n        end\n        if string.isNilOrWhitespace(categoryTypeName) then\n            Logging.warning( "Could not register store category \'%s\'.CategoryType is missing or empty!" , name)\n            return false\n        end\n        local categoryTypeNameUpper = string.upper(categoryTypeName)\n        local categoryType = self.categoryTypesByName[categoryTypeNameUpper]\n        if categoryType = = nil then\n            Logging.warning( "Could not register store category \'%s\'.CategoryType \'%s\' is not defined!" , name, categoryTypeName)\n            return false\n        end\n\n        local nameUpper = string.upper(name)\n        if GS_PLATFORM_SWITCH and name = = "COINS" then\n            return false\n        end\n\n        if self.categoryByName[nameUpper] ~ = nil then\n            Logging.warning( "Could not register store category \'%s\'.Already exists!" , name)\n            return false\n        end\n\n        local category = {\n        name = nameUpper,\n        title = title,\n        image = Utils.getFilename(imageFilename, baseDir),\n        type = categoryTypeNameUpper,\n        orderId = # self.categories\n        }\n\n        local needsInsert = true\n        if insertAfter ~ = nil then\n            local insertAfterUpper = string.upper(insertAfter)\n            for k, existingCategory in ipairs( self.categories) do\n                if existingCategory.name = = insertAfterUpper then\n                    table.insert( self.categories, k + 1 , category)\n                    needsInsert = false\n\n                    for index, _category in ipairs( self.categories) do\n                        _category.orderId = index\n                    end\n\n                    break\n                end\n            end\n        end\n\n        if needsInsert then\n            table.insert( self.categories, category)\n        end\n\n        self.categoryByName[nameUpper] = category\n\n        return true\n    end\n\n'})}),"\n",(0,s.jsx)(n.h3,{id:"addconstructioncategory",children:"addConstructionCategory"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"Add a new construction category."}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Definition"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"addConstructionCategory()"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"any"}),(0,s.jsx)(n.th,{children:"name"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"any"}),(0,s.jsx)(n.td,{children:"title"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"any"}),(0,s.jsx)(n.td,{children:"iconFilename"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"any"}),(0,s.jsx)(n.td,{children:"iconUVs"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"any"}),(0,s.jsx)(n.td,{children:"baseDir"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"any"}),(0,s.jsx)(n.td,{children:"iconSliceId"})]})]})]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Code"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:"function StoreManager:addConstructionCategory(name, title, iconFilename, iconUVs, baseDir, iconSliceId)\n    name = string.upper(name)\n\n    if self.constructionCategoriesByName[name] ~ = nil then\n        Logging.warning( \"Construction category '%s' already exists.\" , name)\n        return\n    end\n\n    local category = {\n    name = name,\n    title = title,\n    iconFilename = Utils.getFilename(iconFilename, baseDir),\n    iconUVs = iconUVs,\n    iconSliceId = iconSliceId,\n    tabs = { } ,\n    index = # self.constructionCategories + 1\n    }\n\n    table.insert( self.constructionCategories, category)\n    self.constructionCategoriesByName[name] = category\nend\n\n"})}),"\n",(0,s.jsx)(n.h3,{id:"addconstructiontab",children:"addConstructionTab"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"Add a new construction tab"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Definition"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"addConstructionTab()"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"any"}),(0,s.jsx)(n.th,{children:"categoryName"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"any"}),(0,s.jsx)(n.td,{children:"name"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"any"}),(0,s.jsx)(n.td,{children:"title"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"any"}),(0,s.jsx)(n.td,{children:"iconFilename"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"any"}),(0,s.jsx)(n.td,{children:"iconUVs"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"any"}),(0,s.jsx)(n.td,{children:"baseDir"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"any"}),(0,s.jsx)(n.td,{children:"iconSliceId"})]})]})]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Code"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:"function StoreManager:addConstructionTab(categoryName, name, title, iconFilename, iconUVs, baseDir, iconSliceId)\n    local category = self:getConstructionCategoryByName(categoryName)\n    if category = = nil then\n        return\n    end\n\n    table.insert(category.tabs, {\n    name = string.upper(name),\n    title = title,\n    iconFilename = Utils.getFilename(iconFilename, baseDir),\n    iconUVs = iconUVs,\n    iconSliceId = iconSliceId,\n    index = #category.tabs + 1\n    } )\nend\n\n"})}),"\n",(0,s.jsx)(n.h3,{id:"additem",children:"addItem"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"Adds a new store item"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Definition"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"addItem(table storeItem)"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n",(0,s.jsx)(n.table,{children:(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"table"}),(0,s.jsx)(n.th,{children:"storeItem"}),(0,s.jsx)(n.th,{children:"the storeitem object"})]})})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Return Values"})}),"\n\n\n\n\n\n\n\n\n",(0,s.jsx)(n.table,{children:(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"table"}),(0,s.jsx)(n.th,{children:"wasSuccessfull"}),(0,s.jsx)(n.th,{children:"true if added else false"})]})})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Code"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:'function StoreManager:addItem(storeItem)\n    local otherItem = self.xmlFilenameToItem[storeItem.xmlFilenameLower]\n    if otherItem ~ = nil then\n        -- in case we have added a item already as bundle item, but then afterwards want to add it as regular item as well\n        -- so we copy isBundleItem and showInStore from the regular item\n        if otherItem.isBundleItem and not storeItem.isBundleItem then\n            otherItem.isBundleItem = storeItem.isBundleItem\n            otherItem.showInStore = storeItem.showInStore\n        end\n\n        return false\n    end\n\n    table.insert( self.items, storeItem)\n    storeItem.id = # self.items\n    self.xmlFilenameToItem[storeItem.xmlFilenameLower] = storeItem\n\n    local isUnlocked = storeItem.extraContentId = = nil or g_extraContentSystem = = nil or g_extraContentSystem:getIsItemIdUnlocked(storeItem.extraContentId)\n    if not storeItem.isBundleItem and isUnlocked and storeItem.showInStore and(storeItem.species = = StoreSpecies.VEHICLE or storeItem.species = = StoreSpecies.HANDTOOL) then\n        local author = ""\n        local customEnvironment = storeItem.customEnvironment\n        if storeItem.isMod then\n            local mod = g_modManager.nameToMod[customEnvironment]\n            if mod ~ = nil and mod.author ~ = nil then\n                author = mod.author\n            end\n        end\n\n        local brand = g_brandManager:getBrandByIndex(storeItem.brandIndex)\n        local brandName = storeItem.brandNameRaw or ""\n        if brand ~ = nil and brand.name ~ = "NONE" then\n            brandName = brand.title\n        end\n\n        self.indexedSearch:addDocument(\n        {\n        title = storeItem.name,\n        brand = brandName,\n        author = author,\n        dlcTitle = storeItem.dlcTitle\n        } ,\n        storeItem\n        )\n    end\n\n    return true\nend\n\n'})}),"\n",(0,s.jsx)(n.h3,{id:"addmodstoreitem",children:"addModStoreItem"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Definition"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"addModStoreItem()"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"any"}),(0,s.jsx)(n.th,{children:"xmlFilename"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"any"}),(0,s.jsx)(n.td,{children:"baseDir"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"any"}),(0,s.jsx)(n.td,{children:"customEnvironment"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"any"}),(0,s.jsx)(n.td,{children:"isMod"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"any"}),(0,s.jsx)(n.td,{children:"isBundleItem"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"any"}),(0,s.jsx)(n.td,{children:"dlcTitle"})]})]})]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Code"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:"function StoreManager:addModStoreItem(xmlFilename, baseDir, customEnvironment, isMod, isBundleItem, dlcTitle)\n    table.insert( self.modStoreItems, { xmlFilename = xmlFilename, baseDir = baseDir, customEnvironment = customEnvironment, isMod = isMod, isBundleItem = isBundleItem, dlcTitle = dlcTitle } )\nend\n\n"})}),"\n",(0,s.jsx)(n.h3,{id:"addmodstorepack",children:"addModStorePack"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Definition"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"addModStorePack()"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"any"}),(0,s.jsx)(n.th,{children:"name"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"any"}),(0,s.jsx)(n.td,{children:"title"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"any"}),(0,s.jsx)(n.td,{children:"imageFilename"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"any"}),(0,s.jsx)(n.td,{children:"baseDir"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"any"}),(0,s.jsx)(n.td,{children:"storeItems"})]})]})]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Code"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:"function StoreManager:addModStorePack(name, title, imageFilename, baseDir, storeItems)\n    table.insert( self.modStorePacks,\n    {\n    name = name,\n    title = title,\n    imageFilename = imageFilename,\n    baseDir = baseDir,\n    storeItems = storeItems or { }\n    }\n    )\nend\n\n"})}),"\n",(0,s.jsx)(n.h3,{id:"addpack",children:"addPack"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"Adds a new store pack"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Definition"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"addPack(string name, string title, string imageFilename, string baseDir)"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"string"}),(0,s.jsx)(n.th,{children:"name"}),(0,s.jsx)(n.th,{children:"pack name"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"string"}),(0,s.jsx)(n.td,{children:"title"}),(0,s.jsx)(n.td,{children:"pack title"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"string"}),(0,s.jsx)(n.td,{children:"imageFilename"}),(0,s.jsx)(n.td,{children:"image"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"string"}),(0,s.jsx)(n.td,{children:"baseDir"}),(0,s.jsx)(n.td,{children:"base directory"})]})]})]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Return Values"})}),"\n\n\n\n\n\n\n\n\n",(0,s.jsx)(n.table,{children:(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"string"}),(0,s.jsx)(n.th,{children:"true"}),(0,s.jsx)(n.th,{children:"if adding was successful else false"})]})})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Code"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:'function StoreManager:addPack(name, title, imageFilename, baseDir)\n    if name = = nil or name = = "" then\n        printWarning( "Warning:Could not register store pack.Name is missing or empty!" )\n        return false\n    end\n    if not ClassUtil.getIsValidIndexName(name) then\n        printWarning( "Warning: \'" .. tostring(name) .. "\' is no valid name for a store pack!" )\n            return false\n        end\n        if title = = nil or title = = "" then\n            printWarning( "Warning:Could not register store pack.Title is missing or empty!" )\n            return false\n        end\n        if imageFilename = = nil or imageFilename = = "" then\n            printWarning( "Warning:Could not register store pack.Image is missing or empty!" )\n            return false\n        end\n        if baseDir = = nil then\n            printWarning( "Warning:Could not register store pack.Basedirectory not defined!" )\n            return false\n        end\n\n        name = string.upper(name)\n\n        if self.packs[name] = = nil then\n            self.numOfPacks = self.numOfPacks + 1\n\n            self.packs[name] = {\n            name = name,\n            title = title,\n            image = Utils.getFilename(imageFilename, baseDir),\n            baseDir = baseDir,\n            orderId = self.numOfPacks,\n            items = { }\n            }\n\n            return true\n        end\n\n        return false\n    end\n\n'})}),"\n",(0,s.jsx)(n.h3,{id:"addpackitem",children:"addPackItem"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"Add a new pack item."}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Definition"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"addPackItem(string name, string itemFilename)"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"string"}),(0,s.jsx)(n.th,{children:"name"}),(0,s.jsx)(n.th,{children:"Name of the pack"})]})}),(0,s.jsx)(n.tbody,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"string"}),(0,s.jsx)(n.td,{children:"itemFilename"}),(0,s.jsx)(n.td,{children:"XML filename of the vehicle in the pack"})]})})]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Code"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:'function StoreManager:addPackItem(name, itemFilename)\n    if name = = nil or name = = "" then\n        Logging.warning( "Could not add pack item.Name is missing or empty." )\n        return\n    end\n    if self.packs[name] = = nil then\n        Logging.warning( "Could not add pack item.Pack \'%s\' does not exist." , name)\n        return\n    end\n    if itemFilename = = nil or itemFilename = = "" then\n        Logging.warning( "Could not add pack item to \'%s\'.Item filename is missing." , name)\n        return\n    end\n\n    table.insert( self.packs[name].items, itemFilename)\nend\n\n'})}),"\n",(0,s.jsx)(n.h3,{id:"addspectype",children:"addSpecType"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"Adds a new spec type"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Definition"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"addSpecType(string name, string? profile, function? loadFunc, function getValueFunc, int species, table?\nrelatedConfigurations, function? configDataFunc)"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"string"}),(0,s.jsx)(n.th,{children:"name"}),(0,s.jsx)(n.th,{children:"spec type index name"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"string?"}),(0,s.jsx)(n.td,{children:"profile"}),(0,s.jsx)(n.td,{children:"spec type gui profile"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"function?"}),(0,s.jsx)(n.td,{children:"loadFunc"}),(0,s.jsx)(n.td,{children:"the loading function pointer"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"function"}),(0,s.jsx)(n.td,{children:"getValueFunc"}),(0,s.jsx)(n.td,{children:"the get value function pointer"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"int"}),(0,s.jsx)(n.td,{children:"species"}),(0,s.jsx)(n.td,{children:"the species identifier"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"table?"}),(0,s.jsx)(n.td,{children:"relatedConfigurations"}),(0,s.jsx)(n.td,{})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"function?"}),(0,s.jsx)(n.td,{children:"configDataFunc"}),(0,s.jsx)(n.td,{})]})]})]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Code"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:'function StoreManager:addSpecType(name, profile, loadFunc, getValueFunc, species, relatedConfigurations, configDataFunc)\n    if not ClassUtil.getIsValidIndexName(name) then\n        printWarning( "Warning: \'" .. tostring(name) .. "\' is no valid name for a spec type!" )\n            return\n        end\n\n        --#debug Assert.isNilOrType(relatedConfigurations, "table")\n        --#debug Assert.isNilOrType(configDataFunc, "function")\n\n            name = name\n\n            if self.nameToSpecType = = nil then\n                printCallstack()\n            end\n\n            if self.nameToSpecType[name] ~ = nil then\n                printError( "Error:spec type name \'" .. name .. "\' is already in use!" )\n                return\n            end\n\n            local specType = { }\n            specType.name = name\n            specType.profile = profile\n            specType.loadFunc = loadFunc\n            specType.getValueFunc = getValueFunc\n            specType.species = species or StoreSpecies.VEHICLE\n            specType.relatedConfigurations = relatedConfigurations\n            specType.configDataFunc = configDataFunc\n\n            self.nameToSpecType[name] = specType\n            table.insert( self.specTypes, specType)\n        end\n\n'})}),"\n",(0,s.jsx)(n.h3,{id:"consolecommandreloadstoreitems",children:"consoleCommandReloadStoreItems"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Definition"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"consoleCommandReloadStoreItems()"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Code"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:"function StoreManager:consoleCommandReloadStoreItems()\n    for i, item in ipairs( self.items) do\n        self.items[i] = self:loadItem(item.rawXMLFilename, item.baseDir, item.customEnvironment, item.isMod, item.isBundleItem, item.dlcTitle, item.extraContentId, true )\n        if self.items[i] ~ = nil then\n            self.xmlFilenameToItem[ self.items[i].xmlFilenameLower] = self.items[i]\n        end\n    end\n\n    g_messageCenter:publish(MessageType.STORE_ITEMS_RELOADED)\nend\n\n"})}),"\n",(0,s.jsx)(n.h3,{id:"getcategorybyname",children:"getCategoryByName"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"Gets a store category by name"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Definition"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"getCategoryByName(string name)"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n",(0,s.jsx)(n.table,{children:(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"string"}),(0,s.jsx)(n.th,{children:"name"}),(0,s.jsx)(n.th,{children:"category index name"})]})})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Return Values"})}),"\n\n\n\n\n\n\n\n\n",(0,s.jsx)(n.table,{children:(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"string"}),(0,s.jsx)(n.th,{children:"category"}),(0,s.jsx)(n.th,{children:"the category object"})]})})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Code"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:"function StoreManager:getCategoryByName(name)\n    if name ~ = nil then\n        return self.categoryByName[ string.upper(name)]\n    end\n    return nil\nend\n\n"})}),"\n",(0,s.jsx)(n.h3,{id:"getconstructioncategories",children:"getConstructionCategories"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"Get categories for construction screen"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Definition"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"getConstructionCategories()"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Code"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:"function StoreManager:getConstructionCategories()\n    return self.constructionCategories\nend\n\n"})}),"\n",(0,s.jsx)(n.h3,{id:"getconstructioncategorybyname",children:"getConstructionCategoryByName"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"Get construction category by name"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Definition"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"getConstructionCategoryByName()"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,s.jsx)(n.table,{children:(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"any"}),(0,s.jsx)(n.th,{children:"name"})]})})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Code"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:"function StoreManager:getConstructionCategoryByName(name)\n    if name ~ = nil then\n        return self.constructionCategoriesByName[ string.upper(name)]\n    end\n    return nil\nend\n\n"})}),"\n",(0,s.jsx)(n.h3,{id:"getconstructiontabbyname",children:"getConstructionTabByName"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"Get a construction tab using its name and category name"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Definition"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"getConstructionTabByName()"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"any"}),(0,s.jsx)(n.th,{children:"name"})]})}),(0,s.jsx)(n.tbody,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"any"}),(0,s.jsx)(n.td,{children:"categoryName"})]})})]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Code"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:"function StoreManager:getConstructionTabByName(name, categoryName)\n    local category = self:getConstructionCategoryByName(categoryName)\n    if category = = nil or name = = nil then\n        return nil\n    end\n\n    name = string.upper(name)\n\n    for i, tab in ipairs(category.tabs) do\n        if tab.name = = name then\n            return tab\n        end\n    end\n\n    return nil\nend\n\n"})}),"\n",(0,s.jsx)(n.h3,{id:"getisitemunlocked",children:"getIsItemUnlocked"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"Returns if store item is unlocked"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Definition"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"getIsItemUnlocked(table storeItem)"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n",(0,s.jsx)(n.table,{children:(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"table"}),(0,s.jsx)(n.th,{children:"storeItem"}),(0,s.jsx)(n.th,{children:"the storeitem oject"})]})})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Return Values"})}),"\n\n\n\n\n\n\n\n\n",(0,s.jsx)(n.table,{children:(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"table"}),(0,s.jsx)(n.th,{children:"isUnlocked"}),(0,s.jsx)(n.th,{children:"is unlocked"})]})})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Code"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:"function StoreManager:getIsItemUnlocked(storeItem)\n    if storeItem ~ = nil and(storeItem.extraContentId = = nil or g_extraContentSystem:getIsItemIdUnlocked(storeItem.extraContentId)) then\n        return true\n    end\n\n    return false\nend\n\n"})}),"\n",(0,s.jsx)(n.h3,{id:"getitembycustomenvironment",children:"getItemByCustomEnvironment"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"Gets a store item xml filename"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Definition"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"getItemByCustomEnvironment(string xmlFilename)"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n",(0,s.jsx)(n.table,{children:(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"string"}),(0,s.jsx)(n.th,{children:"xmlFilename"}),(0,s.jsx)(n.th,{children:"storeitem xml filename"})]})})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Return Values"})}),"\n\n\n\n\n\n\n\n\n",(0,s.jsx)(n.table,{children:(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"string"}),(0,s.jsx)(n.th,{children:"storeItem"}),(0,s.jsx)(n.th,{children:"the storeitem object"})]})})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Code"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:"function StoreManager:getItemByCustomEnvironment(customEnvironment)\n    local items = { }\n    for _, item in ipairs( self.items) do\n        if item.customEnvironment = = customEnvironment then\n            table.insert(items, item)\n        end\n    end\n\n    return items\nend\n\n"})}),"\n",(0,s.jsx)(n.h3,{id:"getitembyindex",children:"getItemByIndex"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"Gets a store item by index"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Definition"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"getItemByIndex(integer index)"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n",(0,s.jsx)(n.table,{children:(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"integer"}),(0,s.jsx)(n.th,{children:"index"}),(0,s.jsx)(n.th,{children:"store item index"})]})})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Return Values"})}),"\n\n\n\n\n\n\n\n\n",(0,s.jsx)(n.table,{children:(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"integer"}),(0,s.jsx)(n.th,{children:"storeItem"}),(0,s.jsx)(n.th,{children:"the storeitem oject"})]})})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Code"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:"function StoreManager:getItemByIndex(index)\n    if index ~ = nil then\n        return self.items[index]\n    end\n    return nil\nend\n\n"})}),"\n",(0,s.jsx)(n.h3,{id:"getitembyxmlfilename",children:"getItemByXMLFilename"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"Gets a store item xml filename"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Definition"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"getItemByXMLFilename(string xmlFilename)"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n",(0,s.jsx)(n.table,{children:(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"string"}),(0,s.jsx)(n.th,{children:"xmlFilename"}),(0,s.jsx)(n.th,{children:"storeitem xml filename"})]})})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Return Values"})}),"\n\n\n\n\n\n\n\n\n",(0,s.jsx)(n.table,{children:(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"string"}),(0,s.jsx)(n.th,{children:"storeItem"}),(0,s.jsx)(n.th,{children:"the storeitem object"})]})})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Code"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:"function StoreManager:getItemByXMLFilename(xmlFilename)\n    if xmlFilename ~ = nil then\n        return self.xmlFilenameToItem[ string.lower(xmlFilename)]\n    end\n\n    return nil\nend\n\n"})}),"\n",(0,s.jsx)(n.h3,{id:"getitems",children:"getItems"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"Gets all storeitems"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Definition"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"getItems()"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Return Values"})}),"\n\n\n\n\n\n\n\n\n",(0,s.jsx)(n.table,{children:(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"string"}),(0,s.jsx)(n.th,{children:"items"}),(0,s.jsx)(n.th,{children:"a list of all store items"})]})})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Code"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:"function StoreManager:getItems()\n    return self.items\nend\n\n"})}),"\n",(0,s.jsx)(n.h3,{id:"getitemsbycombinationdata",children:"getItemsByCombinationData"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"Returns store items that match the given combination data"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Definition"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"getItemsByCombinationData(table combinationData)"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n",(0,s.jsx)(n.table,{children:(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"table"}),(0,s.jsx)(n.th,{children:"combinationData"}),(0,s.jsx)(n.th,{children:"combination data"})]})})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Return Values"})}),"\n\n\n\n\n\n\n\n\n",(0,s.jsx)(n.table,{children:(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"table"}),(0,s.jsx)(n.th,{children:"storeItems"}),(0,s.jsx)(n.th,{children:"table with store items"})]})})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Code"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:'function StoreManager:getItemsByCombinationData(combinationData)\n    local items = { }\n\n    if combinationData.xmlFilename ~ = nil then\n        -- case 1:combination is direct xml reference\n        local storeItem = self.xmlFilenameToItem[ string.lower(combinationData.customXMLFilename)]\n        if storeItem = = nil then\n            storeItem = self.xmlFilenameToItem[ string.lower(combinationData.xmlFilename)]\n            if storeItem = = nil then\n                Logging.warning( "Could not find combination vehicle \'%s\'" , combinationData.xmlFilename)\n            end\n        end\n\n        if self:getIsItemUnlocked(storeItem) then\n            table.insert(items, { storeItem = storeItem } )\n        end\n    else\n            -- case 2:combination is a filter category\n            for _, storeItem in ipairs( self.items) do\n                if not self:getIsItemUnlocked(storeItem) then\n                    continue\n                end\n\n                local categoryAllowed = true\n                if combinationData.filterCategories ~ = nil then\n                    categoryAllowed = false\n                    if storeItem.categoryNames ~ = nil then\n                        for _, filterCategoryName in ipairs(combinationData.filterCategories) do\n                            for _, storeItemCategoryName in ipairs(storeItem.categoryNames) do\n                                if string.upper(filterCategoryName) = = storeItemCategoryName then\n                                    categoryAllowed = true\n                                    break\n                                end\n                            end\n                        end\n                    end\n                end\n\n                if not categoryAllowed then\n                    continue\n                end\n\n                if combinationData.filterSpec = = nil then\n                    -- basic category filter, no further limitations\n                    table.insert(items, { storeItem = storeItem } )\n                else\n                        local desc = self:getSpecTypeByName(combinationData.filterSpec)\n                        if desc = = nil then\n                            continue\n                        end\n\n                        if desc.species ~ = storeItem.species then\n                            continue\n                        end\n\n                        StoreItemUtil.loadSpecsFromXML(storeItem)\n\n                        local value, _maxValue = desc.getValueFunc(storeItem, nil , nil , nil , true , true )\n                        if value = = nil then\n                            continue\n                        end\n\n                        local specMin = combinationData.filterSpecMin\n                        local specMax = combinationData.filterSpecMax\n                        -- special case weight -> in the xml we defined it as kg, but in code we handle it always as tons\n                        if combinationData.filterSpec = = "weight" then\n                            specMin = specMin / 1000\n                            specMax = specMax / 1000\n                        end\n\n                        if value > = specMin and value < = specMax then\n                            -- filter with extra spec limit matches\n                            table.insert(items, { storeItem = storeItem } )\n                        else\n                                if desc.configDataFunc ~ = nil then\n                                    local configDatas = desc.configDataFunc(storeItem)\n                                    if configDatas ~ = nil then\n                                        for _, configData in ipairs(configDatas) do\n                                            if configData.value > = specMin and configData.value < = specMax then\n                                                table.insert(items, { storeItem = storeItem, configData = { [configData.name] = configData.index } } )\n                                            end\n                                        end\n                                    end\n                                else\n                                        if desc.relatedConfigurations ~ = nil and storeItem.configurations ~ = nil then\n                                            for _, configurationName in ipairs(desc.relatedConfigurations) do\n                                                if storeItem.configurations[configurationName] ~ = nil then\n                                                    local configItems = storeItem.configurations[configurationName]\n                                                    for configIndex = 1 , #configItems do\n                                                        local configData = { [configurationName] = configIndex }\n                                                        value = desc.getValueFunc(storeItem, nil , configData, nil , true , true )\n                                                        if value > = specMin and value < = specMax then\n                                                            table.insert(items, { storeItem = storeItem, configData = configData } )\n                                                        end\n                                                    end\n                                                end\n                                            end\n                                        end\n                                    end\n                                end\n                            end\n                        end\n                    end\n\n                    return items\n                end\n\n'})}),"\n",(0,s.jsx)(n.h3,{id:"getpackitems",children:"getPackItems"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"Get the items in the pack."}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Definition"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"getPackItems(string name)"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n",(0,s.jsx)(n.table,{children:(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"string"}),(0,s.jsx)(n.th,{children:"name"}),(0,s.jsx)(n.th,{children:"name of the pack."})]})})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Code"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:"function StoreManager:getPackItems(name)\n    local pack = self.packs[name]\n    if pack = = nil then\n        return nil\n    else\n            return pack.items\n        end\n    end\n\n"})}),"\n",(0,s.jsx)(n.h3,{id:"getpacks",children:"getPacks"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"Get a list of all packs"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Definition"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"getPacks()"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Code"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:"function StoreManager:getPacks()\n    return self.packs\nend\n\n"})}),"\n",(0,s.jsx)(n.h3,{id:"getspectypebyname",children:"getSpecTypeByName"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"Gets a spec type by name"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Definition"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"getSpecTypeByName(string name)"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n",(0,s.jsx)(n.table,{children:(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"string"}),(0,s.jsx)(n.th,{children:"name"}),(0,s.jsx)(n.th,{children:"spec type index name"})]})})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Return Values"})}),"\n\n\n\n\n\n\n\n\n",(0,s.jsx)(n.table,{children:(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"string"}),(0,s.jsx)(n.th,{children:"specType"}),(0,s.jsx)(n.th,{children:"the corresponding spectype"})]})})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Code"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:'function StoreManager:getSpecTypeByName(name)\n    if not ClassUtil.getIsValidIndexName(name) then\n        printWarning( "Warning: \'" .. tostring(name) .. "\' is no valid name for a spec type!" )\n            return\n        end\n\n        return self.nameToSpecType[name]\n    end\n\n'})}),"\n",(0,s.jsx)(n.h3,{id:"getspectypebyprofile",children:"getSpecTypeByProfile"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"Gets a spec type by name"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Definition"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"getSpecTypeByProfile(string profile)"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n",(0,s.jsx)(n.table,{children:(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"string"}),(0,s.jsx)(n.th,{children:"profile"}),(0,s.jsx)(n.th,{children:"spec type profile name"})]})})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Return Values"})}),"\n\n\n\n\n\n\n\n\n",(0,s.jsx)(n.table,{children:(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"string"}),(0,s.jsx)(n.th,{children:"specType"}),(0,s.jsx)(n.th,{children:"the corresponding spectype"})]})})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Code"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:"function StoreManager:getSpecTypeByProfile(profile)\n    for i = 1 , # self.specTypes do\n        if self.specTypes[i].profile = = profile then\n            return self.specTypes[i]\n        end\n    end\n\n    return nil\nend\n\n"})}),"\n",(0,s.jsx)(n.h3,{id:"getspectypes",children:"getSpecTypes"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"Gets all spec types"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Definition"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"getSpecTypes()"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Return Values"})}),"\n\n\n\n\n\n\n\n\n",(0,s.jsx)(n.table,{children:(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"string"}),(0,s.jsx)(n.th,{children:"specTypes"}),(0,s.jsx)(n.th,{children:"a list of spec types"})]})})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Code"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:"function StoreManager:getSpecTypes()\n    return self.specTypes\nend\n\n"})}),"\n",(0,s.jsx)(n.h3,{id:"initdatastructures",children:"initDataStructures"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"Initialize data structures"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Definition"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"initDataStructures()"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Code"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:"function StoreManager:initDataStructures()\n    self.numOfCategories = 0\n    self.numOfPacks = 0\n    self.categories = { }\n    self.categoryByName = { }\n    self.categoryTypes = { }\n    self.categoryTypesByName = { }\n    self.packs = { }\n    self.items = { }\n    self.xmlFilenameToItem = { }\n    self.modStoreItems = { }\n    self.modStorePacks = { }\n    self.modConstructionTabs = { }\n\n    self.modCategoryTypes = { }\n\n    self.specTypes = { }\n    self.nameToSpecType = { }\n\n    self.vramUsageFunctions = { }\n\n    self.constructionCategoriesByName = { }\n    self.constructionCategories = { }\n\n    if self.indexedSearch ~ = nil then\n        self.indexedSearch:clear()\n    end\nend\n\n"})}),"\n",(0,s.jsx)(n.h3,{id:"loadcategoryfromxml",children:"loadCategoryFromXML"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"Load shop category from XML file"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Definition"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"loadCategoryFromXML(table xmlFile, string key, string baseDir, , )"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"table"}),(0,s.jsx)(n.th,{children:"xmlFile"}),(0,s.jsx)(n.th,{children:"xml file object"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"string"}),(0,s.jsx)(n.td,{children:"key"}),(0,s.jsx)(n.td,{children:"key"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"string"}),(0,s.jsx)(n.td,{children:"baseDir"}),(0,s.jsx)(n.td,{children:"base directory"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"any"}),(0,s.jsx)(n.td,{children:"customEnv"}),(0,s.jsx)(n.td,{})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"any"}),(0,s.jsx)(n.td,{children:"isMod"}),(0,s.jsx)(n.td,{})]})]})]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Code"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:'function StoreManager:loadCategoryFromXML(xmlFile, key, baseDir, customEnv, isMod)\n    local name = xmlFile:getString(key .. "#name" )\n    local title = xmlFile:getString(key .. "#title" )\n    local imageFilename = xmlFile:getString(key .. "#image" )\n    local categoryType = xmlFile:getString(key .. "#type" )\n    local insertAfter = xmlFile:getString(key .. "#insertAfter" )\n\n    if title ~ = nil then\n        title = g_i18n:convertText(title, customEnv)\n    end\n\n    if isMod then\n        local categoryData = { }\n        categoryData.name = name\n        categoryData.title = title\n        categoryData.imageFilename = imageFilename\n        categoryData.categoryType = categoryType\n        categoryData.baseDir = baseDir\n        categoryData.insertAfter = insertAfter\n        table.insert( self.modCategoryTypes, categoryData)\n    else\n            self:addCategory(name, title, imageFilename, categoryType, baseDir, insertAfter)\n        end\n    end\n\n'})}),"\n",(0,s.jsx)(n.h3,{id:"loaditem",children:"loadItem"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"Loads a storeitem from xml file"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Definition"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"loadItem(string xmlFilename, string baseDir, string customEnvironment, boolean isMod, boolean isBundleItem, string?\ndlcTitle, , )"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"string"}),(0,s.jsx)(n.th,{children:"xmlFilename"}),(0,s.jsx)(n.th,{children:"the storeitem xml filename"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"string"}),(0,s.jsx)(n.td,{children:"baseDir"}),(0,s.jsx)(n.td,{children:"the base directory"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"string"}),(0,s.jsx)(n.td,{children:"customEnvironment"}),(0,s.jsx)(n.td,{children:"a custom environment"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"boolean"}),(0,s.jsx)(n.td,{children:"isMod"}),(0,s.jsx)(n.td,{children:"true if item is a mod, else false"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"boolean"}),(0,s.jsx)(n.td,{children:"isBundleItem"}),(0,s.jsx)(n.td,{children:"true if item is bundleItem, else false"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"string?"}),(0,s.jsx)(n.td,{children:"dlcTitle"}),(0,s.jsx)(n.td,{children:"optional dlc title"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"any"}),(0,s.jsx)(n.td,{children:"extraContentId"}),(0,s.jsx)(n.td,{})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"any"}),(0,s.jsx)(n.td,{children:"ignoreAdd"}),(0,s.jsx)(n.td,{})]})]})]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Return Values"})}),"\n\n\n\n\n\n\n\n\n",(0,s.jsx)(n.table,{children:(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"any"}),(0,s.jsx)(n.th,{children:"storeItem"}),(0,s.jsx)(n.th,{children:"the storeitem object"})]})})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Code"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:'function StoreManager:loadItem(rawXMLFilename, baseDir, customEnvironment, isMod, isBundleItem, dlcTitle, extraContentId, ignoreAdd)\n    local xmlFilename = Utils.getFilename(rawXMLFilename, baseDir)\n    local xmlFile = loadXMLFile( "storeItemXML" , xmlFilename)\n    if xmlFile = = 0 then\n        return nil\n    end\n\n    local baseXMLName = getXMLRootName(xmlFile)\n    local storeDataXMLKey = baseXMLName .. ".storeData"\n\n    -- just load the species the old way to categorize the file\n    local speciesStr = getXMLString(xmlFile, storeDataXMLKey .. ".species" )\n    local species = StoreSpecies.getByName(speciesStr) or StoreSpecies.VEHICLE\n\n    local xmlSchema = self.speciesToSchema[species]\n    if xmlSchema ~ = nil then\n        delete(xmlFile)\n        xmlFile = XMLFile.load( "storeManagerLoadItemXml" , xmlFilename, xmlSchema)\n    else\n            Logging.xmlError(xmlFile, "Unable to get xml schema for species \'%s\' in \'%s\'" , species, xmlFilename)\n                return nil\n            end\n\n            -- check if file name matches naming convention\n                local xmlName = Utils.getFilenameInfo(xmlFilename, true )\n                local firstLetter = string.sub(xmlName, 1 , 1 )\n                if firstLetter ~ = string.lower(firstLetter) then\n                    Logging.xmlDevWarning(xmlFile, "Filename is starting with upper case character.Please follow the lower camel case naming convention." )\n                end\n                if tonumber(firstLetter) ~ = nil then\n                    Logging.xmlDevWarning(xmlFile, "Filename is starting with a number.Please start always with a character." )\n                end\n                local xmlPathPaths = xmlFilename:split( "/" )\n                local numParts = #xmlPathPaths\n                if numParts > = 4 then\n                    if xmlPathPaths[numParts - 3 ] = = "vehicles" then\n                        if string.startsWith( string.lower(xmlPathPaths[numParts]), string.lower(xmlPathPaths[numParts - 2 ])) then\n                            Logging.xmlDevWarning(xmlFile, "Vehicle filename \'%s\' starts with brand name \'%s\'." , xmlName, xmlPathPaths[numParts - 2 ])\n                        end\n                    end\n                end\n\n                if not xmlFile:hasProperty(storeDataXMLKey) then\n                    Logging.xmlError(xmlFile, "No storeData found.StoreItem will be ignored!" )\n                    xmlFile:delete()\n                    return nil\n                end\n\n                local isValid = true\n                local name = xmlFile:getValue(storeDataXMLKey .. ".name" , nil , customEnvironment, true )\n                if name = = nil then\n                    Logging.xmlWarning(xmlFile, "Name missing for storeitem.Ignoring store item!" )\n                        isValid = false\n                    end\n\n                    if name ~ = nil then\n                        local params = xmlFile:getValue(storeDataXMLKey .. ".name#params" )\n                        if params ~ = nil then\n                            name = g_i18n:insertTextParams(name, params, customEnvironment, xmlFile)\n                        end\n                    end\n\n                    local imageFilename = xmlFile:getValue(storeDataXMLKey .. ".image" , "" )\n                    if imageFilename = = "" then\n                        imageFilename = nil\n                    end\n                    if imageFilename = = nil and xmlFile:getValue(storeDataXMLKey .. ".showInStore" , true ) then\n                        Logging.xmlWarning(xmlFile, "Image icon is missing for storeitem.Ignoring store item!" )\n                            isValid = false\n                        end\n\n                        if not isValid then\n                            xmlFile:delete()\n                            return nil\n                        end\n\n                        local storeItem = { }\n                        storeItem.name = name\n                        storeItem.extraContentId = extraContentId\n                        storeItem.rawXMLFilename = rawXMLFilename\n                        storeItem.baseDir = baseDir\n                        storeItem.xmlSchema = xmlSchema\n                        storeItem.xmlFilename = xmlFilename\n                        storeItem.xmlFilenameLower = string.lower(xmlFilename)\n                        storeItem.imageFilename = imageFilename and Utils.getFilename(imageFilename, baseDir)\n                        storeItem.species = species\n                        storeItem.functions = StoreItemUtil.getFunctionsFromXML(xmlFile, storeDataXMLKey, customEnvironment)\n                        storeItem.specs = nil\n                        storeItem.brandIndex = StoreItemUtil.getBrandIndexFromXML(xmlFile, storeDataXMLKey)\n                        storeItem.brandNameRaw = xmlFile:getValue(storeDataXMLKey .. ".brand" , "" )\n                        storeItem.customBrandIcon = xmlFile:getValue(storeDataXMLKey .. ".brand#customIcon" )\n                        storeItem.customBrandIconOffset = xmlFile:getValue(storeDataXMLKey .. ".brand#imageOffset" )\n                        if storeItem.customBrandIcon ~ = nil then\n                            storeItem.customBrandIcon = Utils.getFilename(storeItem.customBrandIcon, baseDir)\n                        end\n                        storeItem.canBeSold = xmlFile:getValue(storeDataXMLKey .. ".canBeSold" , true )\n                        storeItem.showInStore = xmlFile:getValue(storeDataXMLKey .. ".showInStore" , not isBundleItem)\n                        storeItem.isBundleItem = isBundleItem\n                        storeItem.allowLeasing = xmlFile:getValue(storeDataXMLKey .. ".allowLeasing" , true )\n                        storeItem.maxItemCount = xmlFile:getValue(storeDataXMLKey .. ".maxItemCount" )\n                        storeItem.rotation = xmlFile:getValue(storeDataXMLKey .. ".rotation" , 0 )\n                        storeItem.spawnRotationOffset = xmlFile:getValue(storeDataXMLKey .. ".spawnRotationOffset" , nil , true )\n                        storeItem.spawnSizeOffset = xmlFile:getValue(storeDataXMLKey .. ".spawnSizeOffset" , nil , true )\n                        storeItem.shopDynamicTitle = xmlFile:getValue(storeDataXMLKey .. ".shopDynamicTitle" , false )\n                        storeItem.shopTranslationOffset = xmlFile:getValue(storeDataXMLKey .. ".shopTranslationOffset" , nil , true )\n                        storeItem.shopRotationOffset = xmlFile:getValue(storeDataXMLKey .. ".shopRotationOffset" , nil , true )\n                        storeItem.shopIgnoreLastComponentPositions = xmlFile:getValue(storeDataXMLKey .. ".shopIgnoreLastComponentPositions" , false )\n                        storeItem.shopInitialLoadingDelay = xmlFile:getValue(storeDataXMLKey .. ".shopLoadingDelay#initial" )\n                        storeItem.shopConfigLoadingDelay = xmlFile:getValue(storeDataXMLKey .. ".shopLoadingDelay#config" )\n                        storeItem.shopHeight = xmlFile:getValue(storeDataXMLKey .. ".shopHeight" , 0 )\n                        storeItem.financeCategory = xmlFile:getValue(storeDataXMLKey .. ".financeCategory" )\n                        storeItem.shopFoldingState = xmlFile:getValue(storeDataXMLKey .. ".shopFoldingState" , 0 )\n                        storeItem.shopFoldingTime = xmlFile:getValue(storeDataXMLKey .. ".shopFoldingTime" )\n\n                        --#debug if storeItem.shopTranslationOffset ~ = nil then\n                            --#debug if storeItem.shopTranslationOffset[1] ~ = 0 or storeItem.shopTranslationOffset[3] ~ = 0 then\n                                --#debug Logging.xmlDevWarning(xmlFile, "Shop translation offset on X and Z axis must be 0! Vehicle will automatically be center based on width and length offset.")\n                                --#debug end\n                                --#debug end\n\n                                local sharedVramUsage, perInstanceVramUsage, ignoreVramUsage = StoreItemUtil.getVRamUsageFromXML(xmlFile, storeDataXMLKey)\n                                for _, func in ipairs( self.vramUsageFunctions) do\n                                    local customSharedVramUsage, customPerInstanceVramUsage = func(xmlFile)\n\n                                    sharedVramUsage = sharedVramUsage + customSharedVramUsage\n                                    perInstanceVramUsage = perInstanceVramUsage + customPerInstanceVramUsage\n                                end\n\n                                storeItem.sharedVramUsage, storeItem.perInstanceVramUsage, storeItem.ignoreVramUsage = sharedVramUsage, perInstanceVramUsage, ignoreVramUsage\n\n                                storeItem.dlcTitle = dlcTitle\n                                storeItem.isMod = isMod\n                                storeItem.customEnvironment = customEnvironment\n\n                                storeItem.categoryNames = { }\n                                local categoryNames = xmlFile:getValue(storeDataXMLKey .. ".category" )\n                                if categoryNames ~ = nil then\n                                    for i = 1 , #categoryNames do\n                                        local category = self:getCategoryByName(categoryNames[i])\n                                        if category ~ = nil then\n                                            table.insert(storeItem.categoryNames, category.name)\n                                        else\n                                                Logging.xmlWarning(xmlFile, "Invalid category \'%s\' in store data!" , tostring(categoryNames[i]))\n                                            end\n                                        end\n                                    end\n\n                                    -- ensure some category is always set\n                                    if #storeItem.categoryNames = = 0 then\n                                        if storeItem.showInStore then\n                                            -- only show warning for actually displayed items\n                                                Logging.xmlWarning(xmlFile, "No categories defined in store data! Using \'misc\' instead!" )\n                                            end\n                                            table.insert(storeItem.categoryNames, "MISC" )\n                                        end\n\n                                        -- .categoryName still as reference to the \'root\' shop category, so we are also backwards compatible\n                                        storeItem.categoryName = storeItem.categoryNames[ 1 ]\n\n                                        if species = = StoreSpecies.VEHICLE then\n                                            --#profile RemoteProfiler.zoneBeginN("Load configurations")\n                                            storeItem.configurations, storeItem.defaultConfigurationIds = ConfigurationUtil.getConfigurationsFromXML(g_vehicleConfigurationManager, xmlFile, baseXMLName, baseDir, customEnvironment, isMod, storeItem)\n                                            storeItem.subConfigurations = ConfigurationUtil.getSubConfigurationsFromConfigurations(g_vehicleConfigurationManager, storeItem.configurations)\n                                            storeItem.configurationSets = ConfigurationUtil.getConfigurationSetsFromXML(storeItem, xmlFile, baseXMLName, baseDir, customEnvironment, isMod)\n\n                                            storeItem.hasLicensePlates = xmlFile:hasProperty( "vehicle.licensePlates.licensePlate(0)" )\n                                            --#profile RemoteProfiler.zoneEnd()\n                                        elseif species = = StoreSpecies.PLACEABLE then\n                                                storeItem.configurations, storeItem.defaultConfigurationIds = ConfigurationUtil.getConfigurationsFromXML(g_placeableConfigurationManager, xmlFile, baseXMLName, baseDir, customEnvironment, isMod, storeItem)\n                                            end\n\n                                            storeItem.price = xmlFile:getValue(storeDataXMLKey .. ".price" , 0 )\n                                            if storeItem.price < 0 then\n                                                Logging.xmlWarning(xmlFile, "Price has to be greater than 0.Using default 10.000 instead!" )\n                                                storeItem.price = 10000\n                                            end\n                                            storeItem.dailyUpkeep = xmlFile:getValue(storeDataXMLKey .. ".dailyUpkeep" , 0 )\n                                            storeItem.runningLeasingFactor = xmlFile:getValue(storeDataXMLKey .. ".runningLeasingFactor" , EconomyManager.DEFAULT_RUNNING_LEASING_FACTOR)\n                                            storeItem.lifetime = xmlFile:getValue(storeDataXMLKey .. ".lifetime" , 600 )\n                                            if storeItem.lifetime < = 0 then\n                                                Logging.xmlWarning(xmlFile, "Lifetime has to be greater than 0.Using default 600 instead!" )\n                                                storeItem.lifetime = 600\n                                            end\n\n                                            xmlFile:iterate( "handTool.storeData.storePacks.storePack" , function (_, key)\n                                                local packName = xmlFile:getValue(key)\n                                                self:addPackItem(packName, xmlFilename)\n                                            end )\n\n                                            xmlFile:iterate( "vehicle.storeData.storePacks.storePack" , function (_, key)\n                                                local packName = xmlFile:getValue(key)\n                                                self:addPackItem(packName, xmlFilename)\n                                            end )\n\n                                            local bundleItemsToAdd = { }\n                                            if xmlFile:hasProperty(storeDataXMLKey .. ".bundleElements" ) then\n                                                local bundleInfo = { bundleItems = { } , attacherInfo = { } }\n                                                local price = 0\n                                                local lifetime = math.huge\n                                                local dailyUpkeep = 0\n                                                local runningLeasingFactor = 0\n\n                                                for bundleIndex, bundleKey in xmlFile:iterator(storeDataXMLKey .. ".bundleElements.bundleElement" ) do\n                                                    local bundleXmlFile = xmlFile:getValue(bundleKey .. ".xmlFilename" )\n                                                    local offset = xmlFile:getValue(bundleKey .. ".offset" , "0 0 0" , true )\n                                                    local rotationOffset = xmlFile:getValue(bundleKey .. ".rotationOffset" , "0 0 0" , true )\n                                                    local rotation = xmlFile:getValue(bundleKey .. ".yRotation" , 0 )\n                                                    rotationOffset[ 2 ] = rotationOffset[ 2 ] + rotation\n                                                    if bundleXmlFile ~ = nil then\n                                                        local completePath = Utils.getFilename(bundleXmlFile, baseDir)\n                                                        local item = self:getItemByXMLFilename(completePath)\n                                                        if item = = nil then\n                                                            item = self:loadItem(bundleXmlFile, baseDir, customEnvironment, isMod, true , dlcTitle, nil , true )\n                                                            table.insert(bundleItemsToAdd, item)\n                                                        end\n                                                        if item ~ = nil then\n                                                            price = price + item.price\n                                                            dailyUpkeep = dailyUpkeep + item.dailyUpkeep\n                                                            runningLeasingFactor = runningLeasingFactor + item.runningLeasingFactor\n                                                            lifetime = math.min(lifetime, item.lifetime)\n\n                                                            if item.configurations ~ = nil then\n                                                                storeItem.configurations = storeItem.configurations or { }\n\n                                                                for configName, configOptions in pairs(item.configurations) do\n                                                                    if storeItem.configurations[configName] ~ = nil then\n                                                                        -- sum the prices of the configurations on multiple items\n                                                                        local itemConfigOptions = storeItem.configurations[configName]\n                                                                        for j = 1 , #configOptions do\n                                                                            if itemConfigOptions[j] = = nil then\n                                                                                itemConfigOptions[j] = configOptions[j]\n                                                                            else\n                                                                                    itemConfigOptions[j].price = itemConfigOptions[j].price + configOptions[j].price\n                                                                                end\n                                                                            end\n                                                                        else\n                                                                                storeItem.configurations[configName] = table.clone(configOptions, 5 )\n                                                                            end\n                                                                        end\n                                                                    end\n\n                                                                    if item.defaultConfigurationIds ~ = nil then\n                                                                        storeItem.defaultConfigurationIds = storeItem.defaultConfigurationIds or { }\n                                                                    end\n\n                                                                    if item.subConfigurations ~ = nil then\n                                                                        storeItem.subConfigurations = storeItem.subConfigurations or { }\n                                                                        for configName, configOptions in pairs(item.subConfigurations) do\n                                                                            storeItem.subConfigurations[configName] = configOptions\n                                                                        end\n                                                                    end\n\n                                                                    if item.configurationSets ~ = nil then\n                                                                        storeItem.configurationSets = storeItem.configurationSets or { }\n                                                                        for configName, configOptions in pairs(item.configurationSets) do\n                                                                            storeItem.configurationSets[configName] = configOptions\n                                                                        end\n                                                                    end\n\n                                                                    local preSelectedConfigurations = { }\n                                                                    xmlFile:iterate(bundleKey .. ".configurations.configuration" , function (_, configKey)\n                                                                        local configName = xmlFile:getValue(configKey .. "#name" )\n                                                                        local configValue = xmlFile:getValue(configKey .. "#value" )\n                                                                        if configValue = = nil then\n                                                                            local configSaveId = xmlFile:getValue(configKey .. "#saveId" )\n                                                                            if item.configurations ~ = nil then\n                                                                                local configs = item.configurations[configName]\n                                                                                if configs ~ = nil then\n                                                                                    for j = 1 , #configs do\n                                                                                        if configs[j].saveId = = configSaveId then\n                                                                                            configValue = configs[j].index\n                                                                                            break\n                                                                                        end\n                                                                                    end\n                                                                                end\n                                                                            end\n                                                                        end\n                                                                        if configName ~ = nil and configValue ~ = nil then\n                                                                            local allowChange = xmlFile:getValue(configKey .. "#allowChange" , false )\n                                                                            local hideOption = xmlFile:getValue(configKey .. "#hideOption" , false )\n                                                                            local disableOption = xmlFile:getValue(configKey .. "#disableOption" , false )\n                                                                            if not disableOption then\n                                                                                preSelectedConfigurations[configName] = { configValue = configValue, allowChange = allowChange, hideOption = hideOption }\n                                                                            else\n                                                                                    local configElements = storeItem.configurations[configName]\n                                                                                    if configElements ~ = nil then\n                                                                                        for j = 1 , #configElements do\n                                                                                            if j = = configValue then\n                                                                                                configElements[j].isSelectable = not configElements[j].isSelectable\n                                                                                            end\n                                                                                        end\n                                                                                    end\n                                                                                end\n                                                                            end\n                                                                        end )\n\n                                                                        storeItem.hasLicensePlates = storeItem.hasLicensePlates or item.hasLicensePlates\n\n                                                                        table.insert(bundleInfo.bundleItems, { item = item, xmlFilename = item.xmlFilename, offset = offset, rotationOffset = rotationOffset, rotation = 0 , price = item.price, preSelectedConfigurations = preSelectedConfigurations } )\n                                                                    end\n                                                                end\n                                                            end\n\n                                                            for attachIndex, attachKey in xmlFile:iterator(storeDataXMLKey .. ".attacherInfo.attach" ) do\n                                                                local bundleElement0 = xmlFile:getValue(attachKey .. "#bundleElement0" )\n                                                                local bundleElement1 = xmlFile:getValue(attachKey .. "#bundleElement1" )\n                                                                local attacherJointIndex = xmlFile:getValue(attachKey .. "#attacherJointIndex" )\n                                                                local inputAttacherJointIndex = xmlFile:getValue(attachKey .. "#inputAttacherJointIndex" )\n                                                                if bundleElement0 ~ = nil and bundleElement1 ~ = nil and attacherJointIndex ~ = nil and inputAttacherJointIndex ~ = nil then\n                                                                    table.insert(bundleInfo.attacherInfo, { bundleElement0 = bundleElement0, bundleElement1 = bundleElement1, attacherJointIndex = attacherJointIndex, inputAttacherJointIndex = inputAttacherJointIndex } )\n                                                                end\n                                                            end\n\n                                                            storeItem.price = price\n                                                            storeItem.dailyUpkeep = dailyUpkeep\n                                                            storeItem.runningLeasingFactor = runningLeasingFactor\n                                                            storeItem.lifetime = lifetime\n                                                            storeItem.bundleInfo = bundleInfo\n                                                        end\n\n                                                        -- Construction brush\n                                                        if Platform.hasContruction then\n                                                            if xmlFile:hasProperty(storeDataXMLKey .. ".brush" ) and storeItem.showInStore then\n                                                                local brushType = xmlFile:getValue(storeDataXMLKey .. ".brush.type" )\n\n                                                                if brushType ~ = nil and brushType ~ = "none" then\n                                                                    if g_constructionBrushTypeManager:getClassObjectByTypeName(brushType) = = nil then\n                                                                        Logging.xmlError(xmlFile, "Unknown brush type %q" , brushType)\n                                                                        printf( "Available brush types: %s" , table.concat( table.toList(g_constructionBrushTypeManager:getBrushTypes()), ", " ))\n                                                                    end\n\n                                                                    local parameters = { }\n                                                                    xmlFile:iterate(storeDataXMLKey .. ".brush.parameters.parameter" , function (index, key)\n                                                                        local value = xmlFile:getValue(key)\n                                                                        if xmlFile:getValue(key .. "#isFilename" , false ) then\n                                                                            value = Utils.getFilename(value, baseDir)\n                                                                        end\n\n                                                                        parameters[index] = value\n                                                                    end )\n\n                                                                    local brushCategoryString = xmlFile:getValue(storeDataXMLKey .. ".brush.category" )\n                                                                    if brushCategoryString ~ = nil then\n                                                                        local brushCategory = self:getConstructionCategoryByName(brushCategoryString)\n                                                                        if brushCategory ~ = nil then\n                                                                            local tab = self:getConstructionTabByName(xmlFile:getValue(storeDataXMLKey .. ".brush.tab" ), brushCategory.name)\n                                                                            if tab ~ = nil then\n                                                                                storeItem.brush = {\n                                                                                type = brushType,\n                                                                                parameters = parameters,\n                                                                                category = brushCategory,\n                                                                                tab = tab,\n                                                                                }\n                                                                            else\n                                                                                    Logging.xmlWarning(xmlFile, "Missing brush tab" )\n                                                                                end\n                                                                            else\n                                                                                    Logging.xmlWarning(xmlFile, "Missing brush category: %s" , storeDataXMLKey .. ".brush.category" )\n                                                                                end\n                                                                            else\n                                                                                    Logging.xmlWarning(xmlFile, "Unknown brush category \'%s\'" , brushCategoryString)\n                                                                                end\n                                                                            end\n\n                                                                            -- Placeables without brush just get the default placeable brush\n                                                                        elseif storeItem.species = = StoreSpecies.PLACEABLE and storeItem.showInStore then\n                                                                                local constructionCategory = self.constructionCategories[ 1 ]\n                                                                                if constructionCategory ~ = nil then\n                                                                                    storeItem.brush = {\n                                                                                    type = "placeable" ,\n                                                                                    parameters = { } ,\n                                                                                    category = constructionCategory,\n                                                                                    tab = constructionCategory.tabs[ 1 ],\n                                                                                    }\n                                                                                else\n                                                                                        Logging.xmlDevWarning(xmlFile, "Construction category not found for \'%s\'" , storeDataXMLKey)\n                                                                                        end\n                                                                                    end\n                                                                                end\n\n                                                                                if not ignoreAdd then\n                                                                                    self:addItem(storeItem)\n\n                                                                                    for i = 1 , #bundleItemsToAdd do\n                                                                                        self:addItem(bundleItemsToAdd[i])\n                                                                                    end\n                                                                                end\n\n                                                                                xmlFile:delete()\n\n                                                                                return storeItem\n                                                                            end\n\n'})}),"\n",(0,s.jsx)(n.h3,{id:"loaditemsfromxml",children:"loadItemsFromXML"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Definition"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"loadItemsFromXML()"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"any"}),(0,s.jsx)(n.th,{children:"filename"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"any"}),(0,s.jsx)(n.td,{children:"baseDirectory"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"any"}),(0,s.jsx)(n.td,{children:"customEnvironment"})]})]})]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Code"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:'function StoreManager:loadItemsFromXML(filename, baseDirectory, customEnvironment)\n    local xmlFile = XMLFile.load( "storeItemsXML" , filename)\n\n    if xmlFile = = nil then\n        return\n    end\n\n    xmlFile:iterate( "storeItems.storeItem" , function (_, key)\n        local xmlFilename = xmlFile:getString(key .. "#xmlFilename" )\n        local extraContentId = xmlFile:getString(key .. "#extraContentId" )\n        g_asyncTaskManager:addSubtask( function ()\n            local isMod = false\n            local dlcTitle = ""\n\n            local absFilename = Utils.getFilename(xmlFilename, baseDirectory)\n            local modName, _ = Utils.getModNameAndBaseDirectory(absFilename)\n            if modName ~ = nil then\n                local modItem = g_modManager:getModByName(modName)\n                if modItem ~ = nil then\n                    dlcTitle = modItem.title\n                end\n                isMod = not modItem.isDLC\n            end\n\n            --#profile RemoteProfiler.zoneBeginN("StoreManager:loadItem_" .. xmlFilename)\n            self:loadItem(xmlFilename, baseDirectory, customEnvironment, isMod, false , dlcTitle, extraContentId)\n            --#profile RemoteProfiler.zoneEnd()\n        end , string.format( "StoreManager-loadItemsFromXML \'%s\'" , xmlFilename))\n    end )\n\n    xmlFile:delete()\nend\n\n'})}),"\n",(0,s.jsx)(n.h3,{id:"loadmapdata",children:"loadMapData"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"Load manager data on map load"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Definition"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"loadMapData()"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"any"}),(0,s.jsx)(n.th,{children:"xmlFile"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"any"}),(0,s.jsx)(n.td,{children:"missionInfo"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"any"}),(0,s.jsx)(n.td,{children:"baseDirectory"})]})]})]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Return Values"})}),"\n\n\n\n\n\n\n\n\n",(0,s.jsx)(n.table,{children:(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"any"}),(0,s.jsx)(n.th,{children:"true"}),(0,s.jsx)(n.th,{children:"if loading was successful else false"})]})})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Code"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:'function StoreManager:loadMapData(xmlFile, missionInfo, baseDirectory)\n    StoreManager:superClass().loadMapData( self )\n\n    -- local all store categories\n    local categoryXMLFile = XMLFile.load( "storeCategoriesXML" , "dataS/storeCategories.xml" )\n\n    for _, key in categoryXMLFile:iterator( "categories.types.type" ) do\n        self:loadCategoryType(categoryXMLFile, key, nil )\n    end\n\n    for _, key in categoryXMLFile:iterator( "categories.category" ) do\n        self:loadCategoryFromXML(categoryXMLFile, key, "" , false )\n    end\n\n    categoryXMLFile:delete()\n\n    for _, categoryData in ipairs( self.modCategoryTypes) do\n        self:addCategory(categoryData.name, categoryData.title, categoryData.imageFilename, categoryData.categoryType, categoryData.baseDir, categoryData.insertAfter)\n    end\n\n    -- load store pack definitions\n    local packsXMLFile = XMLFile.load( "storePacksXML" , "dataS/storePacks.xml" )\n    for _, key in packsXMLFile:iterator( "storePacks.storePack" ) do\n        local name = packsXMLFile:getString(key .. "#name" )\n        local title = packsXMLFile:getString(key .. "#title" )\n        local imageFilename = packsXMLFile:getString(key .. "#image" )\n\n        if title ~ = nil and title:sub( 1 , 6 ) = = "$l10n_" then\n            title = g_i18n:getText(title:sub( 7 ))\n        end\n\n        self:addPack(name, title, imageFilename, "" )\n\n        packsXMLFile:iterate(key .. ".storeItem" , function (_, storeItemKey)\n            local xmlFilename = packsXMLFile:getString(storeItemKey)\n            self:addPackItem(name, Utils.getFilename(xmlFilename, baseDirectory))\n        end )\n    end\n    packsXMLFile:delete()\n\n    -- also for mods\n        for _, item in ipairs( self.modStorePacks) do\n            self:addPack(item.name, item.title, item.imageFilename, item.baseDir)\n            for _, storeItem in ipairs(item.storeItems) do\n                self:addPackItem(item.name, storeItem)\n            end\n        end\n\n        -- Load categories for the construction system\n            if Platform.hasContruction then\n                local constructionXMLFile = XMLFile.load( "constructionXML" , "dataS/constructionCategories.xml" )\n                if constructionXMLFile ~ = nil then\n                    local defaultIconFilename = constructionXMLFile:getString( "constructionCategories#defaultIconFilename" )\n                    local defaultRefSize = constructionXMLFile:getVector( "constructionCategories#refSize" , nil , 2 ) or { 1024 , 1024 }\n\n                    for _, key in constructionXMLFile:iterator( "constructionCategories.category" ) do\n                        local categoryName = constructionXMLFile:getString(key .. "#name" )\n                        local title = g_i18n:convertText(constructionXMLFile:getString(key .. "#title" ))\n                        local iconFilename = constructionXMLFile:getString(key .. "#iconFilename" ) or defaultIconFilename\n                        local refSize = constructionXMLFile:getVector(key .. "#refSize" , defaultRefSize, 2 )\n                        local iconUVs = GuiUtils.getUVs(constructionXMLFile:getString(key .. "#iconUVs" , "0 0 1 1" ), refSize)\n                        local iconSliceId = constructionXMLFile:getString(key .. "#iconSliceId" )\n\n                        self:addConstructionCategory(categoryName, title, iconFilename, iconUVs, "" , iconSliceId)\n\n                        for _, tKey in constructionXMLFile:iterator(key .. ".tab" ) do\n                            local tabName = constructionXMLFile:getString(tKey .. "#name" )\n                            local tabTitle = g_i18n:convertText(constructionXMLFile:getString(tKey .. "#title" ))\n                            local tabIconFilename = constructionXMLFile:getString(tKey .. "#iconFilename" ) or defaultIconFilename\n                            local tabRefSize = constructionXMLFile:getVector(tKey .. "#refSize" , defaultRefSize, 2 )\n                            local tabIconUVs = GuiUtils.getUVs(constructionXMLFile:getString(tKey .. "#iconUVs" , "0 0 1 1" ), tabRefSize)\n                            local tabIconSliceId = constructionXMLFile:getString(tKey .. "#iconSliceId" )\n\n                            self:addConstructionTab(categoryName, tabName, tabTitle, tabIconFilename, tabIconUVs, "" , tabIconSliceId)\n                        end\n                    end\n\n                    constructionXMLFile:delete()\n                end\n\n                for _, item in ipairs( self.modConstructionTabs) do\n                    self:addConstructionTab(item.categoryName, item.tabName, item.tabTitle, item.tabIconFilename, item.tabIconUVs, "" , item.tabIconSliceId)\n                end\n            end\n\n            -- now load all storeitems\n\n            local storeItemsFilename = self:getDefaultStoreItemsFilename()\n            self:loadItemsFromXML(storeItemsFilename, "" , nil )\n\n            if xmlFile ~ = nil then\n                local mapStoreItemsFilename = getXMLString(xmlFile, "map.storeItems#filename" )\n                if mapStoreItemsFilename ~ = nil then\n                    mapStoreItemsFilename = Utils.getFilename(mapStoreItemsFilename, baseDirectory)\n                    self:loadItemsFromXML(mapStoreItemsFilename, baseDirectory, missionInfo.customEnvironment)\n                end\n            end\n\n            for _, item in ipairs( self.modStoreItems) do\n                g_asyncTaskManager:addSubtask( function ()\n                    self:loadItem(item.xmlFilename, item.baseDir, item.customEnvironment, item.isMod, item.isBundleItem, item.dlcTitle, item.extraContentId)\n                end )\n            end\n\n            g_asyncTaskManager:addSubtask( function ()\n                self.indexedSearch:build()\n            end )\n\n            addConsoleCommand( "gsStoreItemsReload" , "Reloads storeItem data" , "consoleCommandReloadStoreItems" , self )\n\n            return true\n        end\n\n'})}),"\n",(0,s.jsx)(n.h3,{id:"new",children:"new"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"Creating manager"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Definition"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"new()"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,s.jsx)(n.table,{children:(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"any"}),(0,s.jsx)(n.th,{children:"customMt"})]})})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Return Values"})}),"\n\n\n\n\n\n\n\n\n",(0,s.jsx)(n.table,{children:(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"any"}),(0,s.jsx)(n.th,{children:"instance"}),(0,s.jsx)(n.th,{children:"instance of object"})]})})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Code"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:"function StoreManager.new(customMt)\n    local self = AbstractManager.new(customMt or StoreManager _mt)\n\n    self.speciesToSchema = { }\n\n    self.indexedSearch = IndexedSearch.new( { title = 10 , brand = 5 , author = 3 , dlcTitle = 3 } )\n\n    return self\nend\n\n"})}),"\n",(0,s.jsx)(n.h3,{id:"registerstoredataxmlpaths",children:"registerStoreDataXMLPaths"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Definition"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"registerStoreDataXMLPaths(XMLSchema schema, string basePath)"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"XMLSchema"}),(0,s.jsx)(n.th,{children:"schema"})]})}),(0,s.jsx)(n.tbody,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"string"}),(0,s.jsx)(n.td,{children:"basePath"})]})})]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Code"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:'function StoreManager.registerStoreDataXMLPaths(schema, basePath)\n    schema:register(XMLValueType.L10N_STRING, basePath .. ".storeData.name" , "Name of store item" , nil , true )\n    schema:register(XMLValueType.STRING, basePath .. ".storeData.name#params" , "Parameters to add to name" )\n\n    local speciesDefaultValue = StoreSpecies.getName(StoreSpecies.VEHICLE)\n    local speciesDefaultValues = StoreSpecies.getAllOrderedByName()\n    schema:register(XMLValueType.STRING, basePath .. ".storeData.species" , "Store species" , speciesDefaultValue, false , speciesDefaultValues)\n    schema:register(XMLValueType.STRING, basePath .. ".storeData.image" , "Path to store icon" , nil , true )\n    schema:register(XMLValueType.STRING, basePath .. ".storeData.brand" , "Brand identifier" , "LIZARD" )\n    schema:registerAutoCompletionDataSource(basePath .. ".storeData.brand" , "$dataS/brands.xml" , "brands.brand#name" )\n    schema:register(XMLValueType.STRING, basePath .. ".storeData.brand#customIcon" , "Custom brand icon to display in the shop config screen" )\n    schema:register(XMLValueType.STRING, basePath .. ".storeData.brand#imageOffset" , "Offset of custom brand icon" )\n\n    schema:register(XMLValueType.BOOL, basePath .. ".storeData.canBeSold" , "Defines of the vehicle can be sold" , true )\n    schema:register(XMLValueType.BOOL, basePath .. ".storeData.showInStore" , "Defines of the vehicle is shown in shop" , true )\n    schema:register(XMLValueType.BOOL, basePath .. ".storeData.allowLeasing" , "Defines of the vehicle can be leased" , true )\n    schema:register(XMLValueType.INT, basePath .. ".storeData.maxItemCount" , "Defines the max.amount vehicle of this type" )\n    schema:register(XMLValueType.ANGLE, basePath .. ".storeData.rotation" , "Y rotation of the vehicle" , 0 )\n\n    schema:register(XMLValueType.VECTOR_ROT, basePath .. ".storeData.spawnRotationOffset" , "Y rotation of the vehicle when spawned at the shop loading places" )\n    schema:register(XMLValueType.VECTOR_ 3 , basePath .. ".storeData.spawnSizeOffset" , "Additional size that is reserved for the tool when spawned at the shop loading places(width, height, length)" )\n\n        schema:register(XMLValueType.STRING_LIST, basePath .. ".storeData.category" , "Store category name or names(space separated)" , "misc" )\n        schema:registerAutoCompletionDataSource(basePath .. ".storeData.category" , "$dataS/storeCategories.xml" , "categories.category#name" )\n        schema:register(XMLValueType.STRING, basePath .. ".storeData.storePacks.storePack(?)" , "Store pack" )\n        schema:register(XMLValueType.FLOAT, basePath .. ".storeData.price" , "Store price" , 10000 )\n        schema:register(XMLValueType.FLOAT, basePath .. ".storeData.dailyUpkeep" , "Daily up keep" , 0 )\n        schema:register(XMLValueType.FLOAT, basePath .. ".storeData.runningLeasingFactor" , "Running leasing factor" , EconomyManager.DEFAULT_RUNNING_LEASING_FACTOR)\n        schema:register(XMLValueType.FLOAT, basePath .. ".storeData.lifetime" , "Lifetime of vehicle used to calculate price drop, in months" , 600 )\n\n        schema:register(XMLValueType.BOOL, basePath .. ".storeData.shopDynamicTitle" , "Vehicle brand icon and vehicle name is dynamically updated based on the selected configuration in the shop" , false )\n        schema:register(XMLValueType.VECTOR_TRANS, basePath .. ".storeData.shopTranslationOffset" , "Translation offset for shop spawning and store icon" , "0 0 0" )\n            schema:register(XMLValueType.VECTOR_ROT, basePath .. ".storeData.shopRotationOffset" , "Rotation offset for shop spawning and store icon" , "0 0 0" )\n                schema:register(XMLValueType.BOOL, basePath .. ".storeData.shopIgnoreLastComponentPositions" , "If set to true the component positions from last spawning are now reused" , false )\n                schema:register(XMLValueType.TIME, basePath .. ".storeData.shopLoadingDelay#initial" , "Delay of initial shop loading until the vehicle is displayed. (Used e.g.to hide vehicle while components still moving)" )\n                    schema:register(XMLValueType.TIME, basePath .. ".storeData.shopLoadingDelay#config" , "Delay of shop loading after config change until the vehicle is displayed. (Used e.g.to hide vehicle while components still moving)" )\n\n                        schema:register(XMLValueType.FLOAT, basePath .. ".storeData.shopHeight" , "Height of vehicle for shop placement" , 0 )\n                            schema:register(XMLValueType.STRING, basePath .. ".storeData.financeCategory" , "Finance category name" )\n                            schema:register(XMLValueType.INT, basePath .. ".storeData.shopFoldingState" , "Inverts the shop folding state if set to \'1\'" , 0 )\n                                schema:register(XMLValueType.FLOAT, basePath .. ".storeData.shopFoldingTime" , "Defines a custom folding time for the shop" )\n\n                                    schema:register(XMLValueType.INT, basePath .. ".storeData.vertexBufferMemoryUsage" , "Vertex buffer memory usage" , 0 )\n                                    schema:register(XMLValueType.INT, basePath .. ".storeData.indexBufferMemoryUsage" , "Index buffer memory usage" , 0 )\n                                    schema:register(XMLValueType.INT, basePath .. ".storeData.textureMemoryUsage" , "Texture memory usage" , 0 )\n                                    schema:register(XMLValueType.INT, basePath .. ".storeData.instanceVertexBufferMemoryUsage" , "Instance vertex buffer memory usage" , 0 )\n                                    schema:register(XMLValueType.INT, basePath .. ".storeData.instanceIndexBufferMemoryUsage" , "Instance index buffer memory usage" , 0 )\n                                    schema:register(XMLValueType.BOOL, basePath .. ".storeData.ignoreVramUsage" , "Ignore VRAM usage" , false )\n                                    schema:register(XMLValueType.INT, basePath .. ".storeData.audioMemoryUsage" , "Audio memory usage" , 0 )\n\n                                    schema:register(XMLValueType.STRING, basePath .. ".storeData.bundleElements.bundleElement(?).xmlFilename" , "XML filename" )\n                                    schema:register(XMLValueType.VECTOR_TRANS, basePath .. ".storeData.bundleElements.bundleElement(?).offset" , "Translation offset of vehicle" )\n                                    schema:register(XMLValueType.VECTOR_ROT, basePath .. ".storeData.bundleElements.bundleElement(?).rotationOffset" , "Rotation offset of vehicle" )\n                                    schema:register(XMLValueType.ANGLE, basePath .. ".storeData.bundleElements.bundleElement(?).yRotation" , "Y rotation of vehicle" )\n\n                                    schema:register(XMLValueType.STRING, basePath .. ".storeData.bundleElements.bundleElement(?).configurations.configuration(?)#name" , "Name of configuration" )\n                                    schema:register(XMLValueType.INT, basePath .. ".storeData.bundleElements.bundleElement(?).configurations.configuration(?)#value" , "Configuration index that is forced for this config" )\n                                        schema:register(XMLValueType.STRING, basePath .. ".storeData.bundleElements.bundleElement(?).configurations.configuration(?)#saveId" , "Configuration save id that is forced for this config" )\n                                            schema:register(XMLValueType.BOOL, basePath .. ".storeData.bundleElements.bundleElement(?).configurations.configuration(?)#allowChange" , "Allow change of option" , false )\n                                            schema:register(XMLValueType.BOOL, basePath .. ".storeData.bundleElements.bundleElement(?).configurations.configuration(?)#hideOption" , "Hide the option completely" , false )\n                                            schema:register(XMLValueType.BOOL, basePath .. ".storeData.bundleElements.bundleElement(?).configurations.configuration(?)#disableOption" , "Disabled this particular config option" , false )\n\n                                            schema:register(XMLValueType.INT, basePath .. ".storeData.attacherInfo.attach(?)#bundleElement0" , "First bundle element" )\n                                            schema:register(XMLValueType.INT, basePath .. ".storeData.attacherInfo.attach(?)#bundleElement1" , "Second bundle element" )\n                                            schema:register(XMLValueType.INT, basePath .. ".storeData.attacherInfo.attach(?)#attacherJointIndex" , "Attacher joint index" )\n                                            schema:register(XMLValueType.INT, basePath .. ".storeData.attacherInfo.attach(?)#inputAttacherJointIndex" , "Input attacher joint index" )\n\n                                            schema:register(XMLValueType.L10N_STRING, basePath .. ".storeData.functions.function (?)" , "Function description text" )\n                                                schema:registerAutoCompletionDataSource(basePath .. ".storeData.functions.function (?)" , "dataS/l10n/l10n_en.xml" , "l10n.elements.e#k" , "$l10n_" )\n\n                                                    schema:register(XMLValueType.STRING, basePath .. ".storeData.brush.type" , "Brush type" )\n                                                    schema:register(XMLValueType.STRING, basePath .. ".storeData.brush.category" , "Brush category" )\n                                                    schema:register(XMLValueType.STRING, basePath .. ".storeData.brush.tab" , "Brush tab" )\n                                                    schema:register(XMLValueType.STRING, basePath .. ".storeData.brush.parameters.parameter(?)" , "Brush parameter value" )\n                                                    schema:register(XMLValueType.STRING, basePath .. ".storeData.brush.parameters.parameter(?)#isFilename" , "Whether the parameter is a filename" )\n\n                                                    -- Store Icon Generator - Not used in the game\n                                                    schema:register(XMLValueType.ANGLE, basePath .. ".storeData.storeIconRendering.settings#cameraYRot" , "Y Rot of camera" , "Setting from Icon Generator" )\n                                                    schema:register(XMLValueType.ANGLE, basePath .. ".storeData.storeIconRendering.settings#cameraXRot" , "X Rot of camera" , "Setting from Icon Generator" )\n                                                    schema:register(XMLValueType.BOOL, basePath .. ".storeData.storeIconRendering.settings#advancedBoundingBox" , "Advanced BB is used for icon placement" , "Setting from Icon Generator" )\n                                                        schema:register(XMLValueType.BOOL, basePath .. ".storeData.storeIconRendering.settings#centerIcon" , "Center item on icon" , "Setting from Icon Generator" )\n                                                        schema:register(XMLValueType.FLOAT, basePath .. ".storeData.storeIconRendering.settings#zoomFactor" , "Camera zoom factor" )\n                                                        schema:register(XMLValueType.FLOAT, basePath .. ".storeData.storeIconRendering.settings#lightIntensity" , "Intensity of light sources" , "Setting from Icon Generator" )\n                                                        schema:register(XMLValueType.BOOL, basePath .. ".storeData.storeIconRendering.settings#showTriggerMarkers" , "Show trigger markers on icon(for placeables)" , false )\n\n                                                            schema:register(XMLValueType.BOOL, basePath .. ".storeData.storeIconRendering.objectBundle#useClipPlane" , "Clip plane is used" )\n                                                            schema:register(XMLValueType.STRING, basePath .. ".storeData.storeIconRendering.objectBundle.object(?)#filename" , "Path to i3d file" )\n                                                            schema:register(XMLValueType.NODE_INDEX, basePath .. ".storeData.storeIconRendering.objectBundle.object(?).node(?)#node" , "Index Path of node to load" )\n                                                            schema:register(XMLValueType.VECTOR_TRANS, basePath .. ".storeData.storeIconRendering.objectBundle.object(?).node(?)#translation" , "Translation" , "0 0 0" )\n                                                            schema:register(XMLValueType.VECTOR_ROT, basePath .. ".storeData.storeIconRendering.objectBundle.object(?).node(?)#rotation" , "Rotation" , "0 0 0" )\n                                                            schema:register(XMLValueType.VECTOR_SCALE, basePath .. ".storeData.storeIconRendering.objectBundle.object(?).node(?)#scale" , "Scale" , "1 1 1" )\n\n                                                            schema:register(XMLValueType.STRING, basePath .. ".storeData.storeIconRendering.shaderParameter(?)#name" , "Name if shader parameter" )\n                                                                schema:register(XMLValueType.STRING, basePath .. ".storeData.storeIconRendering.shaderParameter(?)#values" , "Values of shader parameter" )\n                                                            end\n\n'})}),"\n",(0,s.jsx)(n.h3,{id:"removeitembyindex",children:"removeItemByIndex"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"Removes a storeitem by index"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Definition"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"removeItemByIndex(integer index)"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n",(0,s.jsx)(n.table,{children:(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"integer"}),(0,s.jsx)(n.th,{children:"index"}),(0,s.jsx)(n.th,{children:"storeitem index"})]})})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Code"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:"function StoreManager:removeItemByIndex(index)\n    local item = self.items[index]\n    if item ~ = nil then\n        self.xmlFilenameToItem[item.xmlFilenameLower] = nil\n\n        -- item.id must always match the index in the arry, thus swap the last to the removed position and reduce size\n        local numItems = # self.items\n        if index < numItems then\n            self.items[index] = self.items[numItems]\n            self.items[index].id = index\n        end\n        table.remove( self.items, numItems)\n    end\nend\n\n"})}),"\n",(0,s.jsx)(n.h3,{id:"unloadmapdata",children:"unloadMapData"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"Unload data on mission delete"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Definition"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"unloadMapData()"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Code"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:'function StoreManager:unloadMapData()\n    StoreManager:superClass().unloadMapData( self )\n\n    removeConsoleCommand( "gsStoreItemsReload" )\nend\n\n'})})]})}function h(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}}}]);