"use strict";(globalThis.webpackChunkfs25_community_luadoc=globalThis.webpackChunkfs25_community_luadoc||[]).push([[67739],{28453(e,n,i){i.d(n,{R:()=>h,x:()=>a});var t=i(96540);const l={},s=t.createContext(l);function h(e){const n=t.useContext(s);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(l):e.components||l:h(e.components),t.createElement(s.Provider,{value:n},e.children)}},70265(e,n,i){i.r(n),i.d(n,{assets:()=>r,contentTitle:()=>a,default:()=>c,frontMatter:()=>h,metadata:()=>t,toc:()=>d});const t=JSON.parse('{"id":"script/Components/SharedLight","title":"SharedLight","description":"SharedLight","source":"@site/../docs/script/Components/SharedLight.md","sourceDirName":"script/Components","slug":"/script/Components/SharedLight","permalink":"/FS25-Community-LUADOC/script/Components/SharedLight","draft":false,"unlisted":false,"tags":[],"version":"current","lastUpdatedAt":1767161192000,"frontMatter":{},"sidebar":"docsSidebar","previous":{"title":"RealLight","permalink":"/FS25-Community-LUADOC/script/Components/RealLight"},"next":{"title":"StaticLight","permalink":"/FS25-Community-LUADOC/script/Components/StaticLight"}}');var l=i(74848),s=i(28453);const h={},a=void 0,r={},d=[{value:"SharedLight",id:"sharedlight",level:2},{value:"consoleCommandDebug",id:"consolecommanddebug",level:3},{value:"delete",id:"delete",level:3},{value:"loadFromVehicleXML",id:"loadfromvehiclexml",level:3},{value:"loadFromXML",id:"loadfromxml",level:3},{value:"new",id:"new",level:3},{value:"onFinished",id:"onfinished",level:3},{value:"onI3DLoaded",id:"oni3dloaded",level:3},{value:"registerExternalXMLPaths",id:"registerexternalxmlpaths",level:3},{value:"registerXMLPaths",id:"registerxmlpaths",level:3},{value:"setCallback",id:"setcallback",level:3},{value:"setLightTypes",id:"setlighttypes",level:3},{value:"setRotationNodes",id:"setrotationnodes",level:3}];function o(e){const n={a:"a",blockquote:"blockquote",code:"code",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,s.R)(),...e.components};return(0,l.jsxs)(l.Fragment,{children:[(0,l.jsx)(n.h2,{id:"sharedlight",children:"SharedLight"}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Description"})}),"\n",(0,l.jsxs)(n.blockquote,{children:["\n",(0,l.jsx)(n.p,{children:"Class for shared lights"}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Functions"})}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsx)(n.li,{children:(0,l.jsx)(n.a,{href:"#consolecommanddebug",children:"consoleCommandDebug"})}),"\n",(0,l.jsx)(n.li,{children:(0,l.jsx)(n.a,{href:"#delete",children:"delete"})}),"\n",(0,l.jsx)(n.li,{children:(0,l.jsx)(n.a,{href:"#loadfromvehiclexml",children:"loadFromVehicleXML"})}),"\n",(0,l.jsx)(n.li,{children:(0,l.jsx)(n.a,{href:"#loadfromxml",children:"loadFromXML"})}),"\n",(0,l.jsx)(n.li,{children:(0,l.jsx)(n.a,{href:"#new",children:"new"})}),"\n",(0,l.jsx)(n.li,{children:(0,l.jsx)(n.a,{href:"#onfinished",children:"onFinished"})}),"\n",(0,l.jsx)(n.li,{children:(0,l.jsx)(n.a,{href:"#oni3dloaded",children:"onI3DLoaded"})}),"\n",(0,l.jsx)(n.li,{children:(0,l.jsx)(n.a,{href:"#registerexternalxmlpaths",children:"registerExternalXMLPaths"})}),"\n",(0,l.jsx)(n.li,{children:(0,l.jsx)(n.a,{href:"#registerxmlpaths",children:"registerXMLPaths"})}),"\n",(0,l.jsx)(n.li,{children:(0,l.jsx)(n.a,{href:"#setcallback",children:"setCallback"})}),"\n",(0,l.jsx)(n.li,{children:(0,l.jsx)(n.a,{href:"#setlighttypes",children:"setLightTypes"})}),"\n",(0,l.jsx)(n.li,{children:(0,l.jsx)(n.a,{href:"#setrotationnodes",children:"setRotationNodes"})}),"\n"]}),"\n",(0,l.jsx)(n.h3,{id:"consolecommanddebug",children:"consoleCommandDebug"}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Description"})}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Definition"})}),"\n",(0,l.jsxs)(n.blockquote,{children:["\n",(0,l.jsx)(n.p,{children:"consoleCommandDebug()"}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,l.jsxs)(n.table,{children:[(0,l.jsx)(n.thead,{children:(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.th,{children:"any"}),(0,l.jsx)(n.th,{children:"_"})]})}),(0,l.jsxs)(n.tbody,{children:[(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{children:"any"}),(0,l.jsx)(n.td,{children:"defaultLight"})]}),(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{children:"any"}),(0,l.jsx)(n.td,{children:"brakeLight"})]}),(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{children:"any"}),(0,l.jsx)(n.td,{children:"highBeam"})]}),(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{children:"any"}),(0,l.jsx)(n.td,{children:"workLightBack"})]}),(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{children:"any"}),(0,l.jsx)(n.td,{children:"workLightFront"})]}),(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{children:"any"}),(0,l.jsx)(n.td,{children:"turnLightLeft"})]}),(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{children:"any"}),(0,l.jsx)(n.td,{children:"turnLeftRight"})]}),(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{children:"any"}),(0,l.jsx)(n.td,{children:"reverseLight"})]})]})]}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Code"})}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-lua",children:'function SharedLight.consoleCommandDebug(_, defaultLight, brakeLight, highBeam, workLightBack, workLightFront, turnLightLeft, turnLeftRight, reverseLight)\n    if SharedLight.debugRootNode = = nil then\n        SharedLight.debugRootNode = createTransformGroup( "sharedLightDebugRoot" )\n        link(getRootNode(), SharedLight.debugRootNode)\n\n        local x, y, z = g_localPlayer:getPosition()\n        local dirX, dirZ = g_localPlayer:getCurrentFacingDirection()\n\n        x, z = x + dirX * 4 , z + dirZ * 4\n        local ry = MathUtil.getYRotationFromDirection(dirX, dirZ)\n\n        setWorldTranslation( SharedLight.debugRootNode, x, y, z)\n        setWorldRotation( SharedLight.debugRootNode, 0 , ry, 0 )\n    end\n\n    if SharedLight.debugSharedLights ~ = nil then\n        for _, light in ipairs( SharedLight.debugSharedLights) do\n            light:delete()\n            delete(light.linkNode)\n        end\n    end\n    SharedLight.debugSharedLights = { }\n\n    SharedLight.debugStaticLights = { }\n    SharedLight.debugStaticLights.defaultLights = { }\n    SharedLight.debugStaticLights.topLights = { }\n    SharedLight.debugStaticLights.bottomLights = { }\n    SharedLight.debugStaticLights.brakeLights = { }\n    SharedLight.debugStaticLights.reverseLights = { }\n    SharedLight.debugStaticLights.dayTimeLights = { }\n    SharedLight.debugStaticLights.turnLightsLeft = { }\n    SharedLight.debugStaticLights.turnLightsRight = { }\n\n    local dummyVehicle = { }\n    dummyVehicle.getIsPowered = function ( .. .) return true end\n    dummyVehicle.getIsInShowroom = function ( .. .) return false end\n    dummyVehicle.getIsLightActive = function ( .. .) return true end\n    dummyVehicle.getIsActiveForLights = function ( .. .) return true end\n    dummyVehicle.getStaticLightFromNode = function ( .. .) return nil end\n    dummyVehicle.spec_lights = { }\n    local spec = dummyVehicle.spec_lights\n    spec.topLightsVisibility = false\n    spec.maxLightState = Lights.LIGHT_TYPE_HIGHBEAM\n    spec.additionalLightTypes = { }\n    spec.additionalLightTypes.bottomLight = spec.maxLightState + 1\n    spec.additionalLightTypes.topLight = spec.maxLightState + 2\n    spec.additionalLightTypes.brakeLight = spec.maxLightState + 3\n    spec.additionalLightTypes.turnLightLeft = spec.maxLightState + 4\n    spec.additionalLightTypes.turnLightRight = spec.maxLightState + 5\n    spec.additionalLightTypes.turnLightAny = spec.maxLightState + 6\n    spec.additionalLightTypes.reverseLight = spec.maxLightState + 7\n    spec.additionalLightTypes.interiorLight = spec.maxLightState + 8\n\n    local lightTypeMask = 0\n    local lightStates = { }\n    lightStates[ Lights.LIGHT_TYPE_DEFAULT] = string.lower(defaultLight or "false" ) = = "true"\n    lightStates[spec.additionalLightTypes.brakeLight] = string.lower(brakeLight or "false" ) = = "true"\n    lightStates[ Lights.LIGHT_TYPE_HIGHBEAM] = string.lower(highBeam or "false" ) = = "true"\n    lightStates[ Lights.LIGHT_TYPE_WORK_BACK] = string.lower(workLightBack or "false" ) = = "true"\n    lightStates[ Lights.LIGHT_TYPE_WORK_FRONT] = string.lower(workLightFront or "false" ) = = "true"\n    lightStates[spec.additionalLightTypes.turnLightLeft] = string.lower(turnLightLeft or "false" ) = = "true"\n    lightStates[spec.additionalLightTypes.turnLightRight] = string.lower(turnLeftRight or "false" ) = = "true"\n    lightStates[spec.additionalLightTypes.reverseLight] = string.lower(reverseLight or "false" ) = = "true"\n\n    for bitIndex, value in pairs(lightStates) do\n        if value then\n            lightTypeMask = bit32.bor(lightTypeMask, bit32.lshift( 1 , bitIndex))\n        end\n    end\n\n    local files = Files.getFilesRecursive(getAppBasePath() .. "data/shared/assets/lights" )\n    table.sort(files, function (a, b)\n        return a.path < b.path\n    end )\n\n    local rowIndex = 0\n    local rowPosition = 0\n    local lastBasePath = nil\n    local lastName = nil\n    local numLightsToLoad, numLightsToLoadTotal = 0 , 0\n    local numLightsSuccess, numLightsFailed = 0 , 0\n    for _, file in ipairs(files) do\n        if not file.isDirectory then\n            if file.filename:contains( ".xml" ) then\n                numLightsToLoad = numLightsToLoad + 1\n                numLightsToLoadTotal = numLightsToLoadTotal + 1\n\n                local linkNode = createTransformGroup( "linkNode" )\n                link( SharedLight.debugRootNode, linkNode)\n\n                local name = file.filename\n                name = string.gsub(name, "White" , "" )\n                name = string.gsub(name, "Orange" , "" )\n                name = string.gsub(name, "Red" , "" )\n                name = string.gsub(name, "Reverse" , "" )\n                name = string.gsub(name, ".xml" , "" )\n                name = string.split(name, "_" )[ 1 ]\n                name = string.gsub(name, "%d" , "" )\n\n                local basePath = file.path:split(file.filename)[ 1 ]\n                if basePath ~ = lastBasePath or name ~ = lastName then\n                    rowIndex = rowIndex + 1\n                    rowPosition = 0\n                    lastBasePath = basePath\n                    lastName = name\n\n                    local wx, wy, wz = localToWorld( SharedLight.debugRootNode, rowIndex * 2 , 1 , - 1 )\n                    local rx, ry, rz = localRotationToWorld( SharedLight.debugRootNode, - math.pi * 0.5 , math.pi, 0 )\n                    g_debugManager:addElement( DebugText3D.new():createWithWorldPos(wx, wy, wz, rx, ry, rz, name, 0.15 ), nil , nil , math.huge)\n                end\n\n                local x = rowIndex * 2\n                local y = 1\n                local z = rowPosition\n\n                rowPosition = rowPosition + 1\n\n                setTranslation(linkNode, x, y, z)\n                setRotation(linkNode, 0 , math.pi, 0 )\n\n                local sharedLight = SharedLight.new(dummyVehicle, SharedLight.debugStaticLights)\n                sharedLight:setCallback( function (success)\n                    numLightsToLoad = numLightsToLoad - 1\n                    if success then\n                        numLightsSuccess = numLightsSuccess + 1\n                        table.insert( SharedLight.debugSharedLights, sharedLight)\n                    else\n                            numLightsFailed = numLightsFailed + 1\n                        end\n\n                        if numLightsToLoad = = 0 then\n                            Lights.applyAdditionalActiveLightType(dummyVehicle, SharedLight.debugStaticLights.topLights, spec.additionalLightTypes.topLight)\n                            Lights.applyAdditionalActiveLightType(dummyVehicle, SharedLight.debugStaticLights.bottomLights, spec.additionalLightTypes.bottomLight)\n                            Lights.applyAdditionalActiveLightType(dummyVehicle, SharedLight.debugStaticLights.brakeLights, spec.additionalLightTypes.brakeLight)\n                            Lights.applyAdditionalActiveLightType(dummyVehicle, SharedLight.debugStaticLights.reverseLights, spec.additionalLightTypes.reverseLight)\n                            Lights.applyAdditionalActiveLightType(dummyVehicle, SharedLight.debugStaticLights.turnLightsLeft, spec.additionalLightTypes.turnLightLeft, true )\n                            Lights.applyAdditionalActiveLightType(dummyVehicle, SharedLight.debugStaticLights.turnLightsLeft, spec.additionalLightTypes.turnLightAny, true )\n                            Lights.applyAdditionalActiveLightType(dummyVehicle, SharedLight.debugStaticLights.turnLightsRight, spec.additionalLightTypes.turnLightRight, true )\n                            Lights.applyAdditionalActiveLightType(dummyVehicle, SharedLight.debugStaticLights.turnLightsRight, spec.additionalLightTypes.turnLightAny, true )\n\n                            for _, staticLightsByType in pairs( SharedLight.debugStaticLights) do\n                                for _, staticLight in ipairs(staticLightsByType) do\n                                    staticLight:setLightTypesMask(lightTypeMask)\n                                end\n                            end\n\n                            for _, _sharedLight in ipairs( SharedLight.debugSharedLights) do\n                                if _sharedLight.staticLightCompound ~ = nil then\n                                    _sharedLight.staticLightCompound:setLightTypesMask(lightTypeMask, dummyVehicle)\n                                end\n                            end\n\n                            Logging.info( "%d Static lights: %d loaded, %d failed to load" , numLightsToLoadTotal, numLightsSuccess, numLightsFailed)\n                        end\n                    end )\n\n                    local filename = string.gsub(file.path, getAppBasePath(), "" )\n                    if sharedLight:loadFromXML(linkNode, filename, "" ) then\n                        local wx, wy, wz = localToWorld(linkNode, 0 , 0 , - 0.2 )\n                        local rx, ry, rz = localRotationToWorld(linkNode, - math.pi * 0.5 , 0 , 0 )\n                        g_debugManager:addElement( DebugText3D.new():createWithWorldPos(wx, wy, wz, rx, ry, rz, file.filename, 0.07 ), nil , nil , math.huge)\n                        g_debugManager:addElement( DebugGizmo.new():createWithNode(linkNode, "" , nil , nil , 0.1 ), nil , nil , math.huge)\n                    end\n                end\n            end\n        end\n\n        BeaconLight.spawnDebugBeacons( SharedLight.debugRootNode)\n    end\n\n'})}),"\n",(0,l.jsx)(n.h3,{id:"delete",children:"delete"}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Description"})}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Definition"})}),"\n",(0,l.jsxs)(n.blockquote,{children:["\n",(0,l.jsx)(n.p,{children:"delete()"}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Code"})}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-lua",children:"function SharedLight:delete()\n    if self.xmlFile ~ = nil then\n        self.xmlFile:delete()\n        self.xmlFile = nil\n    end\n\n    if self.node ~ = nil then\n        delete( self.node)\n        self.node = nil\n    end\n\n    if self.sharedLoadRequestId ~ = nil then\n        g_i3DManager:releaseSharedI3DFile( self.sharedLoadRequestId)\n        self.sharedLoadRequestId = nil\n    end\nend\n\n"})}),"\n",(0,l.jsx)(n.h3,{id:"loadfromvehiclexml",children:"loadFromVehicleXML"}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Description"})}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Definition"})}),"\n",(0,l.jsxs)(n.blockquote,{children:["\n",(0,l.jsx)(n.p,{children:"loadFromVehicleXML()"}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,l.jsxs)(n.table,{children:[(0,l.jsx)(n.thead,{children:(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.th,{children:"any"}),(0,l.jsx)(n.th,{children:"key"})]})}),(0,l.jsxs)(n.tbody,{children:[(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{children:"any"}),(0,l.jsx)(n.td,{children:"baseDirectory"})]}),(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{children:"any"}),(0,l.jsx)(n.td,{children:"callback"})]})]})]}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Code"})}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-lua",children:'function SharedLight:loadFromVehicleXML(key, baseDirectory, callback)\n    local xmlFile = self.vehicle.xmlFile\n    local xmlFilename = xmlFile:getValue(key .. "#filename" )\n    if xmlFilename ~ = nil then\n        xmlFilename = Utils.getFilename(xmlFilename, baseDirectory)\n\n        local linkNode = xmlFile:getValue(key .. "#linkNode" , "0>" , self.vehicle.components, self.vehicle.i3dMappings)\n        if linkNode = = nil then\n            Logging.xmlWarning(xmlFile, "Missing light linkNode in \'%s\'!" , key)\n            return\n        else\n                local isReference, filename, runtimeLoaded = getReferenceInfo(linkNode)\n                if isReference and runtimeLoaded then\n                    local xmlName = Utils.getFilenameInfo(xmlFilename, true )\n                    local i3dName = Utils.getFilenameInfo(filename, true )\n\n                    if xmlName ~ = i3dName then\n                        Logging.xmlWarning(xmlFile, "Shared light \'%s\' loading different file from XML compared to i3D. (XML: %s vs i3D: %s)" , getName(linkNode), xmlName, i3dName)\n                    end\n\n                    Logging.xmlWarning(xmlFile, "Shared light link node \'%s\' is a runtime loaded reference.Please load functional lights via XML and non-functional(e.g.reflectors) as i3D reference, but not both!" , getName(linkNode))\n                    return\n                end\n\n                if not getVisibility(linkNode) then\n                    Logging.xmlWarning(xmlFile, "Shared light link node \'%s\' is hidden!" , getName(linkNode))\n                    return\n                end\n            end\n\n            local rotationNodes = { }\n            for _, rotKey in xmlFile:iterator(key .. ".rotationNode" ) do\n                local name = xmlFile:getValue(rotKey .. "#name" )\n                if name ~ = nil then\n                    rotationNodes[name] = xmlFile:getValue(rotKey .. "#rotation" , nil , true )\n                end\n            end\n\n            local lightTypes = xmlFile:getValue(key .. "#lightTypes" , nil , true )\n            local excludedLightTypes = xmlFile:getValue(key .. "#excludedLightTypes" , nil , true )\n\n            self.reverseLight = xmlFile:getValue(key .. "#reverseLight" , self.reverseLight)\n            self.turnLightLeft = xmlFile:getValue(key .. "#turnLightLeft" , self.turnLightLeft)\n            self.turnLightRight = xmlFile:getValue(key .. "#turnLightRight" , self.turnLightRight)\n\n            self.functionMappingData = StaticLightCompound.loadFunctionMappingData(xmlFile, key)\n\n            self.additionalAttributes = { }\n            self.vehicle:loadAdditionalLightAttributesFromXML(xmlFile, key, self.additionalAttributes)\n\n            self:setRotationNodes(rotationNodes)\n            self:setLightTypes(lightTypes, excludedLightTypes)\n            self:setCallback( function (success)\n                callback(success, success and self or nil )\n            end )\n\n            self:loadFromXML(linkNode, xmlFilename, baseDirectory)\n        end\n    end\n\n'})}),"\n",(0,l.jsx)(n.h3,{id:"loadfromxml",children:"loadFromXML"}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Description"})}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Definition"})}),"\n",(0,l.jsxs)(n.blockquote,{children:["\n",(0,l.jsx)(n.p,{children:"loadFromXML()"}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,l.jsxs)(n.table,{children:[(0,l.jsx)(n.thead,{children:(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.th,{children:"any"}),(0,l.jsx)(n.th,{children:"linkNode"})]})}),(0,l.jsxs)(n.tbody,{children:[(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{children:"any"}),(0,l.jsx)(n.td,{children:"xmlFilename"})]}),(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{children:"any"}),(0,l.jsx)(n.td,{children:"baseDirectory"})]})]})]}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Code"})}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-lua",children:"function SharedLight:loadFromXML(linkNode, xmlFilename, baseDirectory)\n    self.xmlFile = XMLFile.loadIfExists( \"sharedLight\" , xmlFilename, SharedLight.xmlSchema)\n\n    if self.xmlFile = = nil then\n        -- check if there is a replacement after file rename\n            for old, new in pairs( SharedLight.FS22_RENAMED_LIGHTS) do\n                if xmlFilename:find(old) then\n                    local newPath = xmlFilename:gsub(old, new)\n                    if fileExists(newPath) then\n                        if self.vehicle ~ = nil then\n                            Logging.xmlWarning( self.vehicle.xmlFile, \"Light has been renamed from '%s' to '%s'!\" , old, new)\n                        else\n                                Logging.warning( \"Light '%s' has been renamed to '%s' in '%s'!\" , old, new)\n                            end\n\n                            self:onFinished( false )\n                            return false\n                        end\n                    end\n                end\n\n                if self.vehicle ~ = nil then\n                    Logging.xmlWarning( self.vehicle.xmlFile, \"Unable to load shared lights from xml '%s'\" , xmlFilename)\n                else\n                        Logging.warning( \"Unable to load shared lights from xml '%s'\" , xmlFilename)\n                    end\n\n                    self:onFinished( false )\n                    return false\n                end\n\n                local filename = self.xmlFile:getValue( \"light.filename\" )\n                if filename = = nil then\n                    Logging.xmlWarning( self.xmlFile, \"Missing light i3d filename!\" )\n                    self.xmlFile:delete()\n                    self.xmlFile = nil\n\n                    self:onFinished( false )\n                    return false\n                end\n\n                self.filename = Utils.getFilename(filename, baseDirectory)\n                self.linkNode = linkNode\n\n                if self.vehicle ~ = nil and self.vehicle.loadSubSharedI3DFile ~ = nil then\n                    self.sharedLoadRequestId = self.vehicle:loadSubSharedI3DFile( self.filename, false , false , self.onI3DLoaded, self , nil )\n                else\n                        self.sharedLoadRequestId = g_i3DManager:loadSharedI3DFileAsync( self.filename, false , false , self.onI3DLoaded, self , nil )\n                    end\n\n                    return true\n                end\n\n"})}),"\n",(0,l.jsx)(n.h3,{id:"new",children:"new"}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Description"})}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Definition"})}),"\n",(0,l.jsxs)(n.blockquote,{children:["\n",(0,l.jsx)(n.p,{children:"new()"}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,l.jsxs)(n.table,{children:[(0,l.jsx)(n.thead,{children:(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.th,{children:"any"}),(0,l.jsx)(n.th,{children:"vehicle"})]})}),(0,l.jsxs)(n.tbody,{children:[(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{children:"any"}),(0,l.jsx)(n.td,{children:"staticLights"})]}),(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{children:"any"}),(0,l.jsx)(n.td,{children:"customMt"})]})]})]}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Code"})}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-lua",children:"function SharedLight.new(vehicle, staticLights, customMt)\n    local self = setmetatable( { } , customMt or SharedLight _mt)\n\n    self.vehicle = vehicle\n    self.staticLights = staticLights\n\n    self.reverseLight = false\n    self.turnLightLeft = false\n    self.turnLightRight = false\n\n    return self\nend\n\n"})}),"\n",(0,l.jsx)(n.h3,{id:"onfinished",children:"onFinished"}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Description"})}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Definition"})}),"\n",(0,l.jsxs)(n.blockquote,{children:["\n",(0,l.jsx)(n.p,{children:"onFinished()"}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,l.jsx)(n.table,{children:(0,l.jsx)(n.thead,{children:(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.th,{children:"any"}),(0,l.jsx)(n.th,{children:"success"})]})})}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Code"})}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-lua",children:"function SharedLight:onFinished(success)\n    if self.callback ~ = nil then\n        if self.callbackTarget ~ = nil then\n            self.callback( self.callbackTarget, success)\n        else\n                self.callback(success)\n            end\n        end\n    end\n\n"})}),"\n",(0,l.jsx)(n.h3,{id:"oni3dloaded",children:"onI3DLoaded"}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Description"})}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Definition"})}),"\n",(0,l.jsxs)(n.blockquote,{children:["\n",(0,l.jsx)(n.p,{children:"onI3DLoaded()"}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,l.jsxs)(n.table,{children:[(0,l.jsx)(n.thead,{children:(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.th,{children:"any"}),(0,l.jsx)(n.th,{children:"i3dNode"})]})}),(0,l.jsxs)(n.tbody,{children:[(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{children:"any"}),(0,l.jsx)(n.td,{children:"failedReason"})]}),(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{children:"any"}),(0,l.jsx)(n.td,{children:"args"})]})]})]}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Code"})}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-lua",children:'function SharedLight:onI3DLoaded(i3dNode, failedReason, args)\n    if i3dNode ~ = 0 then\n        self.node = self.xmlFile:getValue( "light.rootNode#node" , "0" , i3dNode)\n\n        if self.node ~ = nil then\n            if self.reverseLight then\n                StaticLight.loadLightsFromXML( self.staticLights.reverseLights, self.xmlFile, "light.defaultLight" , self.vehicle, i3dNode, nil , false , self )\n            elseif self.turnLightLeft then\n                    StaticLight.loadLightsFromXML( self.staticLights.turnLightsLeft, self.xmlFile, "light.defaultLight" , self.vehicle, i3dNode, nil , false , self )\n                elseif self.turnLightRight then\n                        StaticLight.loadLightsFromXML( self.staticLights.turnLightsRight, self.xmlFile, "light.defaultLight" , self.vehicle, i3dNode, nil , false , self )\n                    else\n                            StaticLight.loadLightsFromXML( self.staticLights.defaultLights, self.xmlFile, "light.defaultLight" , self.vehicle, i3dNode, nil , true , self )\n                        end\n\n                        StaticLight.loadLightsFromXML( self.staticLights.topLights, self.xmlFile, "light.topLight" , self.vehicle, i3dNode, nil , false , self )\n                        StaticLight.loadLightsFromXML( self.staticLights.bottomLights, self.xmlFile, "light.bottomLight" , self.vehicle, i3dNode, nil , false , self )\n                        StaticLight.loadLightsFromXML( self.staticLights.brakeLights, self.xmlFile, "light.brakeLight" , self.vehicle, i3dNode, nil , false , self )\n                        StaticLight.loadLightsFromXML( self.staticLights.reverseLights, self.xmlFile, "light.reverseLight" , self.vehicle, i3dNode, nil , false , self )\n                        StaticLight.loadLightsFromXML( self.staticLights.dayTimeLights, self.xmlFile, "light.dayTimeLight" , self.vehicle, i3dNode, nil , false , self )\n                        StaticLight.loadLightsFromXML( self.staticLights.turnLightsLeft, self.xmlFile, "light.turnLightLeft" , self.vehicle, i3dNode, nil , false , self )\n                        StaticLight.loadLightsFromXML( self.staticLights.turnLightsRight, self.xmlFile, "light.turnLightRight" , self.vehicle, i3dNode, nil , false , self )\n\n                        if self.rotationNodes ~ = nil then\n                            self.xmlFile:iterate( "light.rotationNode" , function (_, baseKey)\n                                local name = self.xmlFile:getValue(baseKey .. "#name" )\n                                if name ~ = nil then\n                                    local node = self.xmlFile:getValue(baseKey .. "#node" , nil , i3dNode)\n                                    if self.rotationNodes[name] ~ = nil then\n                                        setRotation(node, unpack( self.rotationNodes[name]))\n                                    end\n                                end\n                            end )\n                        end\n\n                        if self.xmlFile:hasProperty( "light.staticLightCompound" ) then\n                            local staticLightCompound = StaticLightCompound.new( self.vehicle)\n                            if staticLightCompound:loadFromXML( self.xmlFile, "light.staticLightCompound" , i3dNode, nil , nil , self ) then\n                                staticLightCompound:setLightTypes( self.lightTypes, self.excludedLightTypes)\n                                staticLightCompound:setOverwriteSettings( self.turnLightLeft, self.turnLightRight, self.reverseLight)\n                                self.staticLightCompound = staticLightCompound\n                            end\n                        end\n\n                        if self.xmlFile:hasProperty( "light.baseMaterial" ) then\n                            local material = VehicleMaterial.new( self.vehicle.baseDirectory)\n                            if material:loadFromXML( self.xmlFile, "light.baseMaterial" , self.vehicle.customEnvironment) then\n                                material:apply( self.node, "sharedLightBase_mat" )\n                            end\n                        end\n\n                        if self.xmlFile:hasProperty( "light.glassMaterial" ) then\n                            local material = VehicleMaterial.new( self.vehicle.baseDirectory)\n                            if material:loadFromXML( self.xmlFile, "light.glassMaterial" , self.vehicle.customEnvironment) then\n                                material:apply( self.node, "sharedLightGlass_mat" )\n                            end\n                        end\n\n                        link( self.linkNode, self.node)\n                    end\n\n                    delete(i3dNode)\n                end\n\n                self.xmlFile:delete()\n                self.xmlFile = nil\n                self:onFinished( self.node ~ = nil )\n            end\n\n'})}),"\n",(0,l.jsx)(n.h3,{id:"registerexternalxmlpaths",children:"registerExternalXMLPaths"}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Description"})}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Definition"})}),"\n",(0,l.jsxs)(n.blockquote,{children:["\n",(0,l.jsx)(n.p,{children:"registerExternalXMLPaths()"}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,l.jsx)(n.table,{children:(0,l.jsx)(n.thead,{children:(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.th,{children:"any"}),(0,l.jsx)(n.th,{children:"schema"})]})})}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Code"})}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-lua",children:'function SharedLight.registerExternalXMLPaths(schema)\n    schema:register(XMLValueType.STRING, "light.filename" , "Path to i3d file" , nil , true )\n    schema:register(XMLValueType.NODE_INDEX, "light.rootNode#node" , "Node index" , "0" )\n\n    StaticLight.registerXMLPaths(schema, "light.defaultLight(?)" )\n    StaticLight.registerXMLPaths(schema, "light.topLight(?)" )\n    StaticLight.registerXMLPaths(schema, "light.bottomLight(?)" )\n    StaticLight.registerXMLPaths(schema, "light.brakeLight(?)" )\n    StaticLight.registerXMLPaths(schema, "light.reverseLight(?)" )\n    StaticLight.registerXMLPaths(schema, "light.dayTimeLight(?)" )\n    StaticLight.registerXMLPaths(schema, "light.turnLightLeft(?)" )\n    StaticLight.registerXMLPaths(schema, "light.turnLightRight(?)" )\n\n    schema:register(XMLValueType.STRING, "light.rotationNode(?)#name" , "Name for reference in vehicle xml" )\n        schema:register(XMLValueType.NODE_INDEX, "light.rotationNode(?)#node" , "Node" )\n\n        VehicleMaterial.registerXMLPaths(schema, "light.baseMaterial" )\n        VehicleMaterial.registerXMLPaths(schema, "light.glassMaterial" )\n\n        StaticLightCompound.registerXMLPaths(schema, "light.staticLightCompound" )\n    end\n\n'})}),"\n",(0,l.jsx)(n.h3,{id:"registerxmlpaths",children:"registerXMLPaths"}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Description"})}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Definition"})}),"\n",(0,l.jsxs)(n.blockquote,{children:["\n",(0,l.jsx)(n.p,{children:"registerXMLPaths()"}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,l.jsxs)(n.table,{children:[(0,l.jsx)(n.thead,{children:(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.th,{children:"any"}),(0,l.jsx)(n.th,{children:"schema"})]})}),(0,l.jsx)(n.tbody,{children:(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{children:"any"}),(0,l.jsx)(n.td,{children:"basePath"})]})})]}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Code"})}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-lua",children:'function SharedLight.registerXMLPaths(schema, basePath)\n    schema:register(XMLValueType.STRING, basePath .. "#filename" , "Shared light filename" )\n    schema:register(XMLValueType.NODE_INDEX, basePath .. "#linkNode" , "Link node" , "0>" )\n    schema:register(XMLValueType.VECTOR_N, basePath .. "#lightTypes" , "Light types" )\n    schema:register(XMLValueType.VECTOR_N, basePath .. "#excludedLightTypes" , "Excluded light types" )\n    schema:register(XMLValueType.STRING, basePath .. ".rotationNode(?)#name" , "Rotation node name" )\n    schema:register(XMLValueType.VECTOR_ROT, basePath .. ".rotationNode(?)#rotation" , "Rotation" )\n\n    schema:register(XMLValueType.BOOL, basePath .. "#reverseLight" , "All \'defaultLight\' nodes will be used as reverse light" , false )\n    schema:register(XMLValueType.BOOL, basePath .. "#turnLightLeft" , "All \'defaultLight\' nodes will be used as left turn light" , false )\n    schema:register(XMLValueType.BOOL, basePath .. "#turnLightRight" , "All \'defaultLight\' nodes will be used as right turn light" , false )\n\n    schema:register(XMLValueType.STRING, basePath .. ".function (?)#name" , "Function name" , nil , nil , StaticLightCompoundUVSlot.getAllOrderedByName())\n        schema:register(XMLValueType.INT, basePath .. ".function (?)#uvSlotIndex" , "Custom UV slot index to assign the defined function name" )\n            schema:register(XMLValueType.INT, basePath .. ".function (?)#uvOffset" , "Vertical UV offset that is used while this light function is active(value range:0-64 -> this represents the height of the texture with a resolution of 1/64).This is used for double usage of certain lights with different colors." , 0 )\n                schema:register(XMLValueType.FLOAT, basePath .. ".function (?)#intensityScale" , "Custom intensity scale for this light type(is multiplied by the intensity defined in the node)" )\n                    schema:register(XMLValueType.STRING, basePath .. ".function (?)#lightType" , "Name of the light type to use" , nil , nil , StaticLightCompoundLightType.getAllOrderedByName())\n                    end\n\n'})}),"\n",(0,l.jsx)(n.h3,{id:"setcallback",children:"setCallback"}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Description"})}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Definition"})}),"\n",(0,l.jsxs)(n.blockquote,{children:["\n",(0,l.jsx)(n.p,{children:"setCallback()"}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,l.jsxs)(n.table,{children:[(0,l.jsx)(n.thead,{children:(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.th,{children:"any"}),(0,l.jsx)(n.th,{children:"callback"})]})}),(0,l.jsx)(n.tbody,{children:(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{children:"any"}),(0,l.jsx)(n.td,{children:"callbackTarget"})]})})]}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Code"})}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-lua",children:"function SharedLight:setCallback(callback, callbackTarget)\n    self.callback = callback\n    self.callbackTarget = callbackTarget\nend\n\n"})}),"\n",(0,l.jsx)(n.h3,{id:"setlighttypes",children:"setLightTypes"}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Description"})}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Definition"})}),"\n",(0,l.jsxs)(n.blockquote,{children:["\n",(0,l.jsx)(n.p,{children:"setLightTypes()"}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,l.jsxs)(n.table,{children:[(0,l.jsx)(n.thead,{children:(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.th,{children:"any"}),(0,l.jsx)(n.th,{children:"lightTypes"})]})}),(0,l.jsx)(n.tbody,{children:(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{children:"any"}),(0,l.jsx)(n.td,{children:"excludedLightTypes"})]})})]}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Code"})}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-lua",children:"function SharedLight:setLightTypes(lightTypes, excludedLightTypes)\n    self.lightTypes = lightTypes\n    self.excludedLightTypes = excludedLightTypes\nend\n\n"})}),"\n",(0,l.jsx)(n.h3,{id:"setrotationnodes",children:"setRotationNodes"}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Description"})}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Definition"})}),"\n",(0,l.jsxs)(n.blockquote,{children:["\n",(0,l.jsx)(n.p,{children:"setRotationNodes()"}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,l.jsx)(n.table,{children:(0,l.jsx)(n.thead,{children:(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.th,{children:"any"}),(0,l.jsx)(n.th,{children:"rotationNodes"})]})})}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Code"})}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-lua",children:"function SharedLight:setRotationNodes(rotationNodes)\n    self.rotationNodes = rotationNodes\nend\n\n"})})]})}function c(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,l.jsx)(n,{...e,children:(0,l.jsx)(o,{...e})}):o(e)}}}]);