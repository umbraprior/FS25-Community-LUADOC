"use strict";(globalThis.webpackChunkfs25_community_luadoc=globalThis.webpackChunkfs25_community_luadoc||[]).push([[61857],{28453(e,n,d){d.d(n,{R:()=>r,x:()=>o});var s=d(96540);const t={},i=s.createContext(t);function r(e){const n=s.useContext(i);return s.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:r(e.components),s.createElement(i.Provider,{value:n},e.children)}},65527(e,n,d){d.r(n),d.d(n,{assets:()=>l,contentTitle:()=>o,default:()=>u,frontMatter:()=>r,metadata:()=>s,toc:()=>a});const s=JSON.parse('{"id":"script/Specializations/CropRowAdjustedNodes","title":"CropRowAdjustedNodes","description":"CropRowAdjustedNodes","source":"@site/../docs/script/Specializations/CropRowAdjustedNodes.md","sourceDirName":"script/Specializations","slug":"/script/Specializations/CropRowAdjustedNodes","permalink":"/FS25-Community-LUADOC/script/Specializations/CropRowAdjustedNodes","draft":false,"unlisted":false,"tags":[],"version":"current","lastUpdatedAt":1767161192000,"frontMatter":{},"sidebar":"docsSidebar","previous":{"title":"Crawlers","permalink":"/FS25-Community-LUADOC/script/Specializations/Crawlers"},"next":{"title":"CropSensor","permalink":"/FS25-Community-LUADOC/script/Specializations/CropSensor"}}');var t=d(74848),i=d(28453);const r={},o=void 0,l={},a=[{value:"CropRowAdjustedNodes",id:"croprowadjustednodes",level:2},{value:"getIsCropRowAdjustedNodeActive",id:"getiscroprowadjustednodeactive",level:3},{value:"initSpecialization",id:"initspecialization",level:3},{value:"loadCropRowAdjustedNodeFromXML",id:"loadcroprowadjustednodefromxml",level:3},{value:"onLoad",id:"onload",level:3},{value:"onUpdate",id:"onupdate",level:3},{value:"prerequisitesPresent",id:"prerequisitespresent",level:3},{value:"registerEventListeners",id:"registereventlisteners",level:3},{value:"registerFunctions",id:"registerfunctions",level:3},{value:"updateCropRowAdjustedNode",id:"updatecroprowadjustednode",level:3}];function c(e){const n={a:"a",blockquote:"blockquote",code:"code",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,i.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.h2,{id:"croprowadjustednodes",children:"CropRowAdjustedNodes"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Description"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"Specialization for adjusting nodes to crop rows / terrain raster"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Functions"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#getiscroprowadjustednodeactive",children:"getIsCropRowAdjustedNodeActive"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#initspecialization",children:"initSpecialization"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#loadcroprowadjustednodefromxml",children:"loadCropRowAdjustedNodeFromXML"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#onload",children:"onLoad"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#onupdate",children:"onUpdate"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#prerequisitespresent",children:"prerequisitesPresent"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#registereventlisteners",children:"registerEventListeners"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#registerfunctions",children:"registerFunctions"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#updatecroprowadjustednode",children:"updateCropRowAdjustedNode"})}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"getiscroprowadjustednodeactive",children:"getIsCropRowAdjustedNodeActive"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Description"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Definition"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"getIsCropRowAdjustedNodeActive()"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,t.jsx)(n.table,{children:(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"any"}),(0,t.jsx)(n.th,{children:"adjustedNode"})]})})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Code"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:"function CropRowAdjustedNodes:getIsCropRowAdjustedNodeActive(adjustedNode)\n    local spec_foldable = self.spec_foldable\n    if spec_foldable ~ = nil then\n        local foldAnimTime = spec_foldable.foldAnimTime\n        if foldAnimTime ~ = nil and(foldAnimTime > adjustedNode.foldMaxLimit or foldAnimTime < adjustedNode.foldMinLimit) then\n            return false\n        end\n    end\n\n    if self.getIsLowered = = nil or not self:getIsLowered() then\n        return false\n    end\n\n    local dx, _, dz = localDirectionToWorld(adjustedNode.referenceFrame, 0 , 0 , 1 )\n    local yRot = MathUtil.getYRotationFromDirection( MathUtil.vector2Normalize(dx, dz))\n    yRot = yRot % ( math.pi * 0.5 )\n\n    if math.abs(yRot) < CropRowAdjustedNodes.MAX_ACTIVE_ANGLE or math.abs(yRot) > 1.5708 - CropRowAdjustedNodes.MAX_ACTIVE_ANGLE then\n        return true\n    end\n\n    return false\nend\n\n"})}),"\n",(0,t.jsx)(n.h3,{id:"initspecialization",children:"initSpecialization"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Description"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"Called on specialization initializing"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Definition"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"initSpecialization()"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Code"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:'function CropRowAdjustedNodes.initSpecialization()\n    local schema = Vehicle.xmlSchema\n    schema:setXMLSpecializationType( "CropRowAdjustedNodes" )\n\n    schema:register(XMLValueType.FLOAT, "vehicle.cropRowAdjustedNodes#maxUpdateDistance" , "If the player is more than this distance away the nodes will no longer be updated" , 100 )\n\n    local adjustedNodePath = "vehicle.cropRowAdjustedNodes.adjustedNode(?)"\n\n    schema:register(XMLValueType.NODE_INDEX, adjustedNodePath .. "#node" , "Row adjusted node" )\n    schema:register(XMLValueType.INT, adjustedNodePath .. "#transAxis" , "Translation Axis" , 1 )\n    schema:register(XMLValueType.FLOAT, adjustedNodePath .. "#minTrans" , "Min.translation value" , - 0.25 )\n    schema:register(XMLValueType.FLOAT, adjustedNodePath .. "#maxTrans" , "Max.translation value" , 0.25 )\n    schema:register(XMLValueType.FLOAT, adjustedNodePath .. "#moveSpeed" , "Move speed(m/sec)" , 0.25 )\n\n    schema:register(XMLValueType.BOOL, adjustedNodePath .. "#betweenRows" , "Defines if the node is aligned on the rows or the middle between the rows" , true )\n        schema:register(XMLValueType.STRING, adjustedNodePath .. "#fruitTypes" , "List of supported fruit types separated by a whitespace" , "maize potato sunflower" )\n\n        schema:register(XMLValueType.FLOAT, adjustedNodePath .. ".foldable#minLimit" , "Fold min.time" , 0 )\n        schema:register(XMLValueType.FLOAT, adjustedNodePath .. ".foldable#maxLimit" , "Fold max.time" , 1 )\n\n        schema:setXMLSpecializationType()\n    end\n\n'})}),"\n",(0,t.jsx)(n.h3,{id:"loadcroprowadjustednodefromxml",children:"loadCropRowAdjustedNodeFromXML"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Description"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Definition"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"loadCropRowAdjustedNodeFromXML()"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"any"}),(0,t.jsx)(n.th,{children:"xmlFile"})]})}),(0,t.jsxs)(n.tbody,{children:[(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"any"}),(0,t.jsx)(n.td,{children:"key"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"any"}),(0,t.jsx)(n.td,{children:"adjustedNode"})]})]})]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Code"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:'function CropRowAdjustedNodes:loadCropRowAdjustedNodeFromXML(xmlFile, key, adjustedNode)\n    adjustedNode.node = xmlFile:getValue(key .. "#node" , nil , self.components, self.i3dMappings)\n    if adjustedNode.node ~ = nil then\n        adjustedNode.referenceFrame = createTransformGroup( "cropRowAdjustedNodeRefFrame" )\n        link(getParent(adjustedNode.node), adjustedNode.referenceFrame)\n        setTranslation(adjustedNode.referenceFrame, getTranslation(adjustedNode.node))\n        setRotation(adjustedNode.referenceFrame, getRotation(adjustedNode.node))\n\n        adjustedNode.startTrans = { getTranslation(adjustedNode.node) }\n        adjustedNode.curTrans = { getTranslation(adjustedNode.node) }\n\n        adjustedNode.transAxis = xmlFile:getValue(key .. "#transAxis" , 1 )\n        adjustedNode.minTrans = xmlFile:getValue(key .. "#minTrans" , - 0.25 )\n        adjustedNode.maxTrans = xmlFile:getValue(key .. "#maxTrans" , 0.25 )\n\n        adjustedNode.moveSpeed = xmlFile:getValue(key .. "#moveSpeed" , 0.25 ) / 1000\n\n        adjustedNode.betweenRows = xmlFile:getValue(key .. "#betweenRows" , true )\n\n        adjustedNode.fruitTypes = { }\n        local fruitTypesStr = xmlFile:getValue(key .. "#fruitTypes" , "maize potato sunflower" )\n        if fruitTypesStr ~ = nil then\n            local fruitTypes = fruitTypesStr:split( " " )\n            for _, fruitTypeName in pairs(fruitTypes) do\n                local fruitType = g_fruitTypeManager:getFruitTypeByName(fruitTypeName)\n                if fruitType ~ = nil then\n                    adjustedNode.fruitTypes[fruitType.index] = true\n                end\n            end\n        end\n\n        if next(adjustedNode.fruitTypes) ~ = nil then\n            adjustedNode.foldMinLimit = xmlFile:getValue(key .. ".foldable#minLimit" , 0 )\n            adjustedNode.foldMaxLimit = xmlFile:getValue(key .. ".foldable#maxLimit" , 1 )\n\n            return true\n        else\n                Logging.xmlWarning(xmlFile, "Missing fruit types in \'%s\'" , key)\n            end\n        else\n                Logging.xmlWarning(xmlFile, "Missing node in \'%s\'" , key)\n            end\n\n            return false\n        end\n\n'})}),"\n",(0,t.jsx)(n.h3,{id:"onload",children:"onLoad"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Description"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Definition"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"onLoad()"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,t.jsx)(n.table,{children:(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"any"}),(0,t.jsx)(n.th,{children:"savegame"})]})})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Code"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:'function CropRowAdjustedNodes:onLoad(savegame)\n    local spec = self.spec_cropRowAdjustedNodes\n\n    spec.adjustedNodes = { }\n    self.xmlFile:iterate( "vehicle.cropRowAdjustedNodes.adjustedNode" , function (index, key)\n        local adjustedNode = { }\n        if self:loadCropRowAdjustedNodeFromXML( self.xmlFile, key, adjustedNode) then\n            table.insert(spec.adjustedNodes, adjustedNode)\n        end\n    end )\n\n    if #spec.adjustedNodes = = 0 then\n        SpecializationUtil.removeEventListener( self , "onUpdate" , CropRowAdjustedNodes )\n    else\n            spec.maxUpdateDistance = self.xmlFile:getValue( "vehicle.cropRowAdjustedNodes#maxUpdateDistance" , 100 )\n        end\n    end\n\n'})}),"\n",(0,t.jsx)(n.h3,{id:"onupdate",children:"onUpdate"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Description"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Definition"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"onUpdate()"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"any"}),(0,t.jsx)(n.th,{children:"dt"})]})}),(0,t.jsxs)(n.tbody,{children:[(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"any"}),(0,t.jsx)(n.td,{children:"isActiveForInput"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"any"}),(0,t.jsx)(n.td,{children:"isActiveForInputIgnoreSelection"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"any"}),(0,t.jsx)(n.td,{children:"isSelected"})]})]})]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Code"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:"function CropRowAdjustedNodes:onUpdate(dt, isActiveForInput, isActiveForInputIgnoreSelection, isSelected)\n    local spec = self.spec_cropRowAdjustedNodes\n    if self.currentUpdateDistance < spec.maxUpdateDistance then\n        for _, adjustedNode in pairs(spec.adjustedNodes) do\n            self:updateCropRowAdjustedNode(adjustedNode, dt)\n        end\n    end\nend\n\n"})}),"\n",(0,t.jsx)(n.h3,{id:"prerequisitespresent",children:"prerequisitesPresent"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Description"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Definition"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"prerequisitesPresent()"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,t.jsx)(n.table,{children:(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"any"}),(0,t.jsx)(n.th,{children:"specializations"})]})})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Code"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:"function CropRowAdjustedNodes.prerequisitesPresent(specializations)\n    return true\nend\n\n"})}),"\n",(0,t.jsx)(n.h3,{id:"registereventlisteners",children:"registerEventListeners"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Description"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Definition"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"registerEventListeners()"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,t.jsx)(n.table,{children:(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"any"}),(0,t.jsx)(n.th,{children:"vehicleType"})]})})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Code"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:'function CropRowAdjustedNodes.registerEventListeners(vehicleType)\n    SpecializationUtil.registerEventListener(vehicleType, "onLoad" , CropRowAdjustedNodes )\n    SpecializationUtil.registerEventListener(vehicleType, "onUpdate" , CropRowAdjustedNodes )\nend\n\n'})}),"\n",(0,t.jsx)(n.h3,{id:"registerfunctions",children:"registerFunctions"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Description"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Definition"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"registerFunctions()"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,t.jsx)(n.table,{children:(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"any"}),(0,t.jsx)(n.th,{children:"vehicleType"})]})})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Code"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:'function CropRowAdjustedNodes.registerFunctions(vehicleType)\n    SpecializationUtil.registerFunction(vehicleType, "loadCropRowAdjustedNodeFromXML" , CropRowAdjustedNodes.loadCropRowAdjustedNodeFromXML)\n    SpecializationUtil.registerFunction(vehicleType, "updateCropRowAdjustedNode" , CropRowAdjustedNodes.updateCropRowAdjustedNode)\n    SpecializationUtil.registerFunction(vehicleType, "getIsCropRowAdjustedNodeActive" , CropRowAdjustedNodes.getIsCropRowAdjustedNodeActive)\nend\n\n'})}),"\n",(0,t.jsx)(n.h3,{id:"updatecroprowadjustednode",children:"updateCropRowAdjustedNode"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Description"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Definition"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"updateCropRowAdjustedNode()"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"any"}),(0,t.jsx)(n.th,{children:"adjustedNode"})]})}),(0,t.jsx)(n.tbody,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"any"}),(0,t.jsx)(n.td,{children:"dt"})]})})]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Code"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:"function CropRowAdjustedNodes:updateCropRowAdjustedNode(adjustedNode, dt)\n    local wasActive = adjustedNode.isActive\n    adjustedNode.isActive = self:getIsCropRowAdjustedNodeActive(adjustedNode)\n\n    if adjustedNode.isActive then\n        local wx, _, wz = getWorldTranslation(adjustedNode.referenceFrame)\n        local fruitTypeIndex, _ = FSDensityMapUtil.getFruitTypeIndexAtWorldPos(wx, wz)\n        if adjustedNode.fruitTypes[fruitTypeIndex] = = nil then\n            adjustedNode.isActive = false\n            return\n        end\n\n        local fruitTypeDesc = g_fruitTypeManager:getFruitTypeByIndex(fruitTypeIndex)\n        local spacing = fruitTypeDesc.plantSpacing\n        local snapAngle = math.pi * 0.5 -- currently only 90\xb0 angles are supported\n\n        local rasteredX1, rasteredZ1 = rasterize(wx, wz, spacing, g_currentMission.terrainSize, adjustedNode.betweenRows)\n\n        local wx2, _, wz2 = localToWorld(adjustedNode.referenceFrame, 0 , 0 , 10 )\n        local rasteredX2, rasteredZ2 = rasterize(wx2, wz2, spacing, g_currentMission.terrainSize, adjustedNode.betweenRows)\n\n        local normlineDirX, normlineDirZ = MathUtil.vector2Normalize(rasteredX2 - rasteredX1, rasteredZ2 - rasteredZ1)\n\n        -- snap to closest foliage angle\n        local yRot = MathUtil.getYRotationFromDirection(normlineDirX, normlineDirZ)\n        yRot = MathUtil.round(yRot / snapAngle) * snapAngle\n        normlineDirX, normlineDirZ = MathUtil.getDirectionFromYRotation(yRot)\n\n        local lineX, lineZ = rasteredX1 - normlineDirX, rasteredZ1 - normlineDirZ\n        local signedDistance = MathUtil.getSignedDistanceToLineSegment2D(wx, wz, lineX, lineZ, normlineDirX, normlineDirZ, spacing + 1 )\n\n        --#debug local dx, _, dz = localToWorld(adjustedNode.referenceFrame, 0, 0, -5)\n        --#debug local origX, origZ = rasterize(dx, dz, spacing, g_currentMission.terrainSize, false)\n        --#debug for rowIndex = -10, 10, 1 do\n            --#debug local x, z = origX + normlineDirZ * rowIndex * spacing, origZ - normlineDirX * rowIndex * spacing\n            --#debug local y = getTerrainHeightAtWorldPos(g_terrainNode, x, 0, z) + 0.8\n            --#debug drawDebugLine(x, y, z, 0, 1, 0, x + normlineDirX * 10, y, z + normlineDirZ * 10, 0, 1, 0, true)\n            --#debug end\n            --#debug\n            --#debug local origBetweenX, origBetweenZ = rasterize(dx, dz, spacing, g_currentMission.terrainSize, true)\n            --#debug for rowIndex = -10, 10, 1 do\n                --#debug local x, z = origBetweenX + normlineDirZ * rowIndex * spacing, origBetweenZ - normlineDirX * rowIndex * spacing\n                --#debug local y = getTerrainHeightAtWorldPos(g_terrainNode, x, 0, z) + 0.4\n                --#debug drawDebugLine(x, y, z, 1, 0, 0, x + normlineDirX * 10, y, z + normlineDirZ * 10, 1, 0, 0, true)\n                --#debug end\n\n                local transX = math.clamp( - signedDistance, adjustedNode.startTrans[adjustedNode.transAxis] + adjustedNode.minTrans, adjustedNode.startTrans[adjustedNode.transAxis] + adjustedNode.maxTrans)\n                adjustedNode.targetTrans = transX\n\n                local difference = adjustedNode.targetTrans - adjustedNode.curTrans[adjustedNode.transAxis]\n                if math.abs(difference) > 0.001 then\n                    adjustedNode.isDirty = true\n                end\n            elseif wasActive then\n                    adjustedNode.targetTrans = adjustedNode.startTrans[adjustedNode.transAxis]\n                    adjustedNode.isDirty = true\n                end\n\n                if adjustedNode.isDirty then\n                    adjustedNode.curTrans[ 1 ], adjustedNode.curTrans[ 2 ], adjustedNode.curTrans[ 3 ] = getTranslation(adjustedNode.node)\n                    local difference = adjustedNode.targetTrans - adjustedNode.curTrans[adjustedNode.transAxis]\n                    if math.abs(difference) > 0.001 then\n                        local direction = math.sign(difference)\n                        local limit = direction > 0 and math.min or math.max\n                        adjustedNode.curTrans[adjustedNode.transAxis] = limit(adjustedNode.curTrans[adjustedNode.transAxis] + direction * adjustedNode.moveSpeed * dt, adjustedNode.targetTrans)\n                        setTranslation(adjustedNode.node, adjustedNode.curTrans[ 1 ], adjustedNode.curTrans[ 2 ], adjustedNode.curTrans[ 3 ])\n\n                        if self.setMovingToolDirty ~ = nil then\n                            self:setMovingToolDirty(adjustedNode.node)\n                        end\n                    else\n                            adjustedNode.isDirty = false\n                        end\n                    end\n                end\n\n"})})]})}function u(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(c,{...e})}):c(e)}}}]);