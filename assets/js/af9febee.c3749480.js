"use strict";(globalThis.webpackChunkfs25_community_luadoc=globalThis.webpackChunkfs25_community_luadoc||[]).push([[78512],{14628(e,n,i){i.r(n),i.d(n,{assets:()=>d,contentTitle:()=>h,default:()=>c,frontMatter:()=>r,metadata:()=>l,toc:()=>a});const l=JSON.parse('{"id":"script/Components/RealLight","title":"RealLight","description":"RealLight","source":"@site/../docs/script/Components/RealLight.md","sourceDirName":"script/Components","slug":"/script/Components/RealLight","permalink":"/FS25-Community-LUADOC/script/Components/RealLight","draft":false,"unlisted":false,"tags":[],"version":"current","lastUpdatedAt":1767161192000,"frontMatter":{},"sidebar":"docsSidebar","previous":{"title":"BeaconLight","permalink":"/FS25-Community-LUADOC/script/Components/BeaconLight"},"next":{"title":"SharedLight","permalink":"/FS25-Community-LUADOC/script/Components/SharedLight"}}');var t=i(74848),s=i(28453);const r={},h=void 0,d={},a=[{value:"RealLight",id:"reallight",level:2},{value:"consoleCommandDebugIES",id:"consolecommanddebugies",level:3},{value:"finalize",id:"finalize",level:3},{value:"getAreShadowsMergable",id:"getareshadowsmergable",level:3},{value:"getMergedConeAngleSize",id:"getmergedconeanglesize",level:3},{value:"loadFromXML",id:"loadfromxml",level:3},{value:"loadLightsFromXML",id:"loadlightsfromxml",level:3},{value:"merge",id:"merge",level:3},{value:"new",id:"new",level:3},{value:"onLightsProfileChanged",id:"onlightsprofilechanged",level:3},{value:"registerXMLPaths",id:"registerxmlpaths",level:3},{value:"setCharge",id:"setcharge",level:3},{value:"setChargeFunction",id:"setchargefunction",level:3},{value:"setIsBlinking",id:"setisblinking",level:3},{value:"setLightTypesMask",id:"setlighttypesmask",level:3},{value:"setState",id:"setstate",level:3},{value:"updateIESProfile",id:"updateiesprofile",level:3},{value:"updateLightScattering",id:"updatelightscattering",level:3},{value:"updateMergedShadows",id:"updatemergedshadows",level:3}];function o(e){const n={a:"a",blockquote:"blockquote",code:"code",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,s.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.h2,{id:"reallight",children:"RealLight"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Description"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"Class for real light source control"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Functions"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#consolecommanddebugies",children:"consoleCommandDebugIES"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#finalize",children:"finalize"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#getareshadowsmergable",children:"getAreShadowsMergable"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#getmergedconeanglesize",children:"getMergedConeAngleSize"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#loadfromxml",children:"loadFromXML"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#loadlightsfromxml",children:"loadLightsFromXML"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#merge",children:"merge"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#new",children:"new"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#onlightsprofilechanged",children:"onLightsProfileChanged"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#registerxmlpaths",children:"registerXMLPaths"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#setcharge",children:"setCharge"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#setchargefunction",children:"setChargeFunction"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#setisblinking",children:"setIsBlinking"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#setlighttypesmask",children:"setLightTypesMask"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#setstate",children:"setState"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#updateiesprofile",children:"updateIESProfile"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#updatelightscattering",children:"updateLightScattering"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#updatemergedshadows",children:"updateMergedShadows"})}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"consolecommanddebugies",children:"consoleCommandDebugIES"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Description"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Definition"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"consoleCommandDebugIES()"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"any"}),(0,t.jsx)(n.th,{children:"_"})]})}),(0,t.jsx)(n.tbody,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"any"}),(0,t.jsx)(n.td,{children:"enabled"})]})})]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Code"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:"function RealLight.consoleCommandDebugIES(_, enabled)\n    if RealLight.IES_DEBUG_ENABLED = = nil then\n        local performanceClass = Utils.getPerformanceClassId()\n        RealLight.IES_DEBUG_ENABLED = performanceClass = = GS_PROFILE_VERY_HIGH or performanceClass = = GS_PROFILE_ULTRA\n    end\n\n    if enabled ~ = nil then\n        enabled = enabled = = \"true\"\n    else\n            enabled = not RealLight.IES_DEBUG_ENABLED\n        end\n\n        RealLight.IES_DEBUG_ENABLED = enabled\n\n        if g_currentMission ~ = nil and g_localPlayer:getCurrentVehicle() ~ = nil then\n            local vehicle = g_localPlayer:getCurrentVehicle()\n            for i = 1 , #vehicle.childVehicles do\n                local childVehicle = vehicle.childVehicles[i]\n                Logging.info( \"IES Profiles Enabled: '%s' on '%s'\" , enabled, vehicle:getFullName())\n\n                if childVehicle.spec_lights ~ = nil then\n                    for _, profile in pairs(childVehicle.spec_lights.realLights) do\n                        for _, lights in pairs(profile) do\n                            for _, realLight in ipairs(lights) do\n                                realLight:updateIESProfile(enabled)\n                            end\n                        end\n                    end\n                end\n            end\n        end\n    end\n\n"})}),"\n",(0,t.jsx)(n.h3,{id:"finalize",children:"finalize"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Description"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Definition"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"finalize()"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Code"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:"function RealLight:finalize()\n    self:updateMergedShadows()\nend\n\n"})}),"\n",(0,t.jsx)(n.h3,{id:"getareshadowsmergable",children:"getAreShadowsMergable"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Description"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"Returns true if all lights are in a 180deg lighting range and can be used for merged shadows"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Definition"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"getAreShadowsMergable()"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,t.jsx)(n.table,{children:(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"any"}),(0,t.jsx)(n.th,{children:"lightSources"})]})})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Code"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:"function RealLight.getAreShadowsMergable(lightSources)\n    for _, lightSource1 in ipairs(lightSources) do\n        for _, lightSource2 in ipairs(lightSources) do\n            if lightSource1 ~ = lightSource2 then\n                local coneAngle = getLightConeAngle(lightSource2)\n\n                local dx, dz = MathUtil.getDirectionFromYRotation(coneAngle * 0.5 )\n                local lx, ly, lz = localDirectionToLocal(lightSource2, lightSource1, dx, 0 , - dz)\n\n                local radius = math.sqrt(lx ^ 2 + ly ^ 2 )\n                local angle = math.acos( math.abs(lz) / ( math.sqrt( math.abs(lz) ^ 2 + radius ^ 2 )))\n                if lz > 0 then\n                    angle = math.pi - angle\n                end\n\n                if angle + coneAngle * 0.5 > math.pi then\n                    return false\n                end\n\n                dx, dz = MathUtil.getDirectionFromYRotation( - coneAngle * 0.5 )\n                lx, ly, lz = localDirectionToLocal(lightSource2, lightSource1, dx, 0 , - dz)\n\n                radius = math.sqrt(lx ^ 2 + ly ^ 2 )\n                angle = math.acos( math.abs(lz) / ( math.sqrt( math.abs(lz) ^ 2 + radius ^ 2 )))\n                if lz > 0 then\n                    angle = math.pi - angle\n                end\n\n                if angle + coneAngle * 0.5 > math.pi then\n                    return false\n                end\n            end\n        end\n    end\n\n    return true\nend\n\n"})}),"\n",(0,t.jsx)(n.h3,{id:"getmergedconeanglesize",children:"getMergedConeAngleSize"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Description"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"Returns the max. cone angle if we merge the given lights sources together to one"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Definition"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"getMergedConeAngleSize()"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,t.jsx)(n.table,{children:(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"any"}),(0,t.jsx)(n.th,{children:"lightSources"})]})})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Code"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:"function RealLight.getMergedConeAngleSize(lightSources)\n    local mergedConeAngle = 0\n    for _, lightSource1 in ipairs(lightSources) do\n        for _, lightSource2 in ipairs(lightSources) do\n            if lightSource1 ~ = lightSource2 then\n                local coneAngle = getLightConeAngle(lightSource2)\n\n                local dx, dz = MathUtil.getDirectionFromYRotation(coneAngle * 0.5 )\n                local lx, ly, lz = localDirectionToLocal(lightSource2, lightSource1, dx, 0 , - dz)\n\n                local radius = math.sqrt(lx ^ 2 + ly ^ 2 )\n                local angle = math.acos( math.abs(lz) / ( math.sqrt( math.abs(lz) ^ 2 + radius ^ 2 )))\n                if lz > 0 then\n                    angle = math.pi - angle\n                end\n\n                mergedConeAngle = math.max(mergedConeAngle, (angle + coneAngle * 0.5 ))\n\n                dx, dz = MathUtil.getDirectionFromYRotation( - coneAngle * 0.5 )\n                lx, ly, lz = localDirectionToLocal(lightSource2, lightSource1, dx, 0 , - dz)\n\n                radius = math.sqrt(lx ^ 2 + ly ^ 2 )\n                angle = math.acos( math.abs(lz) / ( math.sqrt( math.abs(lz) ^ 2 + radius ^ 2 )))\n                if lz > 0 then\n                    angle = math.pi - angle\n                end\n\n                mergedConeAngle = math.max(mergedConeAngle, (angle + coneAngle * 0.5 ))\n            end\n        end\n    end\n\n    return mergedConeAngle\nend\n\n"})}),"\n",(0,t.jsx)(n.h3,{id:"loadfromxml",children:"loadFromXML"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Description"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Definition"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"loadFromXML()"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"any"}),(0,t.jsx)(n.th,{children:"xmlFile"})]})}),(0,t.jsxs)(n.tbody,{children:[(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"any"}),(0,t.jsx)(n.td,{children:"baseKey"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"any"}),(0,t.jsx)(n.td,{children:"components"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"any"}),(0,t.jsx)(n.td,{children:"i3dMappings"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"any"}),(0,t.jsx)(n.td,{children:"loadLightTypes"})]})]})]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Code"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:'function RealLight:loadFromXML(xmlFile, baseKey, components, i3dMappings, loadLightTypes)\n    self.node = xmlFile:getValue(baseKey .. "#node" , nil , components, i3dMappings)\n    if self.node = = nil then\n        Logging.xmlWarning(xmlFile, "Missing light source node in \'%s\'" , baseKey)\n        return false\n    end\n\n    if not getHasClassId( self.node, ClassIds.LIGHT_SOURCE) then\n        Logging.xmlWarning(xmlFile, "Defined node is not a light source \'%s\'" , baseKey)\n        return false\n    end\n\n    self.lightSources = { self.node }\n    I3DUtil.iterateRecursively( self.node, function (childNode)\n        if not getVisibility(childNode) then\n            Logging.xmlWarning(xmlFile, "Real light source \'%s\' is hidden in \'%s\'!" , getName(childNode), baseKey)\n        end\n\n        if getHasClassId(childNode, ClassIds.LIGHT_SOURCE) then\n            table.insert( self.lightSources, childNode)\n        end\n    end )\n\n    self.defaultColor = self.defaultColor or { getLightColor( self.node) }\n    self.intensityScale = xmlFile:getValue(baseKey .. "#intensityScale" , 1 )\n    self.curIntensityScale = self.intensityScale\n\n    setVisibility( self.node, false )\n\n    if loadLightTypes ~ = false then\n        self.lightTypes = xmlFile:getValue(baseKey .. "#lightTypes" , nil , true )\n        self.excludedLightTypes = xmlFile:getValue(baseKey .. "#excludedLightTypes" , nil , true )\n    end\n\n    if self.lightTypes = = nil then\n        self.lightTypes = { }\n    end\n\n    if self.excludedLightTypes = = nil then\n        self.excludedLightTypes = { }\n    end\n\n    local lightsProfile = g_gameSettings:getValue(GameSettings.SETTING.LIGHTS_PROFILE)\n\n    local xmlIESProfile = xmlFile:getValue(baseKey .. "#iesProfile" )\n    if xmlIESProfile ~ = nil then\n        self.xmlIESProfile = Utils.getFilename(xmlIESProfile, self.vehicle.baseDirectory)\n    else\n            local iesProfile = getLightIESProfile( self.lightSources[ 1 ])\n            if iesProfile ~ = "" then\n                self.xmlIESProfile = iesProfile\n            end\n        end\n\n        self.useLightScattering = xmlFile:getValue(baseKey .. "#useLightScattering" )\n\n        self:updateIESProfile(lightsProfile = = GS_PROFILE_VERY_HIGH or lightsProfile = = GS_PROFILE_ULTRA)\n        self:updateLightScattering()\n\n        self.hasMergedShadows = false\n\n        self.hasShadows = xmlFile:getValue(baseKey .. "#hasShadows" , getLightRange( self.node) > 7.5 )\n        if self.hasShadows then\n            if # self.lightSources > 1 then\n                local shadowLightOffset = xmlFile:getValue(baseKey .. "#shadowLightOffset" , nil , true )\n\n                local x, y, z = 0 , 0 , 0\n                local tx, ty, tz = 0 , 0 , 0\n                local maxLightRange = 0\n                local maxConeAngle = 0\n                for i, lightSource in ipairs( self.lightSources) do\n                    maxLightRange = math.max(maxLightRange, getLightRange(lightSource))\n                    maxConeAngle = math.max(maxConeAngle, getLightConeAngle(lightSource))\n                    local _x, _y, _z = localToLocal(lightSource, getParent( self.node), 0 , 0 , 0 )\n                    x, y, z = x + _x, y + _y, z + _z\n\n                    local _tx, _ty, _tz = localToLocal(lightSource, getParent( self.node), 0 , 0 , - 20 )\n                    tx, ty, tz = tx + _tx, ty + _ty, tz + _tz\n                end\n\n                local numLightSources = # self.lightSources\n                if numLightSources > 1 then\n                    x, y, z = x / numLightSources, y / numLightSources, z / numLightSources\n                    tx, ty, tz = tx / numLightSources, ty / numLightSources, tz / numLightSources\n                end\n\n                self.shadowLightSource = createLightSource(getName( self.node) .. "_shadow" , LightType.SPOT, 0.85 , 0.85 , 1 , maxLightRange)\n                setLightConeAngle( self.shadowLightSource, math.max(maxConeAngle, RealLight.getMergedConeAngleSize( self.lightSources)))\n                setLightShadowMap( self.shadowLightSource, true , 512 )\n                setVisibility( self.shadowLightSource, false )\n\n                link(getParent( self.node), self.shadowLightSource)\n                setTranslation( self.shadowLightSource, x, y, z)\n\n                setLightSoftShadowSize( self.shadowLightSource, 0.008 )\n                setLightSoftShadowDistance( self.shadowLightSource, 15 )\n\n                setLightSoftShadowDepthBiasFactor( self.shadowLightSource, 0.02 )\n\n                local dx, dy, dz = MathUtil.vector3Normalize(tx - x, ty - y, tz - z)\n                setDirection( self.shadowLightSource, - dx, - dy, - dz, 0 , 1 , 0 )\n\n                if shadowLightOffset ~ = nil then\n                    local ox, oy, oz = localToLocal( self.shadowLightSource, getParent( self.shadowLightSource), shadowLightOffset[ 1 ], shadowLightOffset[ 2 ], - shadowLightOffset[ 3 ])\n                    setTranslation( self.shadowLightSource, ox, oy, oz)\n                end\n\n                for i, lightSource in ipairs( self.lightSources) do\n                    setLightShadowMap(lightSource, true , 512 )\n                end\n            end\n        end\n\n        -- additional attributes are not supported inside shared lights\n        if xmlFile:getRootName() = = "vehicle" then\n            self.vehicle:loadAdditionalLightAttributesFromXML(xmlFile, baseKey, self )\n        end\n\n        return true\n    end\n\n'})}),"\n",(0,t.jsx)(n.h3,{id:"loadlightsfromxml",children:"loadLightsFromXML"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Description"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Definition"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"loadLightsFromXML()"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"any"}),(0,t.jsx)(n.th,{children:"lights"})]})}),(0,t.jsxs)(n.tbody,{children:[(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"any"}),(0,t.jsx)(n.td,{children:"xmlFile"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"any"}),(0,t.jsx)(n.td,{children:"baseKey"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"any"}),(0,t.jsx)(n.td,{children:"vehicle"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"any"}),(0,t.jsx)(n.td,{children:"components"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"any"}),(0,t.jsx)(n.td,{children:"i3dMappings"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"any"}),(0,t.jsx)(n.td,{children:"loadLightTypes"})]})]})]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Code"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:"function RealLight.loadLightsFromXML(lights, xmlFile, baseKey, vehicle, components, i3dMappings, loadLightTypes)\n    if lights = = nil then\n        lights = { }\n    end\n\n    for _, key in xmlFile:iterator(baseKey) do\n        local light = RealLight.new(vehicle)\n        if light:loadFromXML(xmlFile, key, components, i3dMappings, loadLightTypes) then\n            local otherLight = vehicle:getRealLightFromNode(light.node)\n            if otherLight ~ = nil then\n                light = light:merge(otherLight)\n            end\n\n            table.insert(lights, light)\n        end\n    end\n\n    return lights\nend\n\n"})}),"\n",(0,t.jsx)(n.h3,{id:"merge",children:"merge"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Description"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Definition"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"merge()"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,t.jsx)(n.table,{children:(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"any"}),(0,t.jsx)(n.th,{children:"otherLight"})]})})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Code"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:"function RealLight:merge(otherLight)\n    -- add the light types and exluded light types from ourself to the other light\n    -- and return the other light - so our instance is dropped, so we only have one RealLight instance per node\n\n    for i, lightType in ipairs( self.lightTypes) do\n        table.addElement(otherLight.lightTypes, lightType)\n    end\n\n    for i, excludedLightType in ipairs( self.excludedLightTypes) do\n        table.addElement(otherLight.excludedLightTypes, excludedLightType)\n    end\n\n    return otherLight\nend\n\n"})}),"\n",(0,t.jsx)(n.h3,{id:"new",children:"new"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Description"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Definition"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"new()"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"any"}),(0,t.jsx)(n.th,{children:"vehicle"})]})}),(0,t.jsx)(n.tbody,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"any"}),(0,t.jsx)(n.td,{children:"customMt"})]})})]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Code"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:"function RealLight.new(vehicle, customMt)\n    local self = setmetatable( { } , customMt or RealLight _mt)\n\n    self.vehicle = vehicle\n\n    self.chargeFunction = nil\n\n    return self\nend\n\n"})}),"\n",(0,t.jsx)(n.h3,{id:"onlightsprofilechanged",children:"onLightsProfileChanged"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Description"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Definition"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"onLightsProfileChanged()"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,t.jsx)(n.table,{children:(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"any"}),(0,t.jsx)(n.th,{children:"lightsProfile"})]})})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Code"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:"function RealLight:onLightsProfileChanged(lightsProfile)\n    self:updateIESProfile(lightsProfile = = GS_PROFILE_VERY_HIGH or lightsProfile = = GS_PROFILE_ULTRA)\n\n    self:updateLightScattering()\n    self:updateMergedShadows()\nend\n\n"})}),"\n",(0,t.jsx)(n.h3,{id:"registerxmlpaths",children:"registerXMLPaths"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Description"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Definition"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"registerXMLPaths()"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"any"}),(0,t.jsx)(n.th,{children:"schema"})]})}),(0,t.jsx)(n.tbody,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"any"}),(0,t.jsx)(n.td,{children:"basePath"})]})})]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Code"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:'function RealLight.registerXMLPaths(schema, basePath)\n    schema:register(XMLValueType.NODE_INDEX, basePath .. "#node" , "Real light node" )\n\n    schema:register(XMLValueType.FLOAT, basePath .. "#intensityScale" , "Additional scale of the light source intensity" , 1 )\n\n    schema:register(XMLValueType.VECTOR_N, basePath .. "#excludedLightTypes" , "Excluded light types" )\n    schema:register(XMLValueType.VECTOR_N, basePath .. "#lightTypes" , "Light types" )\n\n    schema:register(XMLValueType.BOOL, basePath .. "#hasShadows" , "Defines if the light has shadows or not(Only in ULTRA game setting)" , "Automatically when range is greater 7.5m" )\n        schema:register(XMLValueType.VECTOR_TRANS, basePath .. "#shadowLightOffset" , "Offset of the shadow light calculation from the center of all light sources(in lighting direction)" )\n        schema:register(XMLValueType.STRING, basePath .. "#iesProfile" , "Path to IES profile file(Only used in very high and above)" )\n        schema:register(XMLValueType.BOOL, basePath .. "#useLightScattering" , "Defines if light scattering is used" , "automatically calculated based on lightType and range" )\n        end\n\n'})}),"\n",(0,t.jsx)(n.h3,{id:"setcharge",children:"setCharge"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Description"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Definition"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"setCharge()"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,t.jsx)(n.table,{children:(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"any"}),(0,t.jsx)(n.th,{children:"alpha"})]})})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Code"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:"function RealLight:setCharge(alpha)\n    alpha = alpha * self.curIntensityScale\n    local color = self.defaultColor\n    for _, lightSource in ipairs( self.lightSources) do\n        setLightColor(lightSource, color[ 1 ] * alpha, color[ 2 ] * alpha, color[ 3 ] * alpha)\n    end\nend\n\n"})}),"\n",(0,t.jsx)(n.h3,{id:"setchargefunction",children:"setChargeFunction"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Description"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Definition"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"setChargeFunction()"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"any"}),(0,t.jsx)(n.th,{children:"func"})]})}),(0,t.jsx)(n.tbody,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"any"}),(0,t.jsx)(n.td,{children:"funcTarget"})]})})]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Code"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:"function RealLight:setChargeFunction(func, funcTarget)\n    self.chargeFunction, self.chargeFunctionTarget = func, funcTarget\nend\n\n"})}),"\n",(0,t.jsx)(n.h3,{id:"setisblinking",children:"setIsBlinking"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Description"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Definition"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"setIsBlinking()"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,t.jsx)(n.table,{children:(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"any"}),(0,t.jsx)(n.th,{children:"isBlinking"})]})})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Code"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:"function RealLight:setIsBlinking(isBlinking)\nend\n\n"})}),"\n",(0,t.jsx)(n.h3,{id:"setlighttypesmask",children:"setLightTypesMask"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Description"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Definition"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"setLightTypesMask()"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,t.jsx)(n.table,{children:(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"any"}),(0,t.jsx)(n.th,{children:"lightsTypesMask"})]})})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Code"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:"function RealLight:setLightTypesMask(lightsTypesMask)\n    if self.vehicle:getIsLightActive( self ) then\n        local isActive, chargeScale = false , 1\n\n        if self.lightTypes ~ = nil then\n            for _, lightType in pairs( self.lightTypes) do\n                if bit32.band(lightsTypesMask, 2 ^ lightType) ~ = 0 or(lightType = = - 1 and self.vehicle:getIsActiveForLights( true )) then\n                    if not isActive then\n                        isActive = true\n                    else\n                            -- if one base light type + one additional light type is enabled we increase the brightness(e.g.back and brake light)\n                                if lightType > self.vehicle.spec_lights.maxLightState then\n                                    chargeScale = 2\n                                end\n                            end\n                        end\n                    end\n\n                    if isActive and self.excludedLightTypes ~ = nil then\n                        for _, excludedLightType in pairs( self.excludedLightTypes) do\n                            if bit32.band(lightsTypesMask, 2 ^ excludedLightType) ~ = 0 then\n                                isActive = false\n                                break\n                            end\n                        end\n                    end\n                else\n                        isActive = false\n                    end\n\n                    if self.chargeFunction ~ = nil then\n                        chargeScale = self.chargeFunction( self.chargeFunctionTarget)\n                    end\n\n                    self:setState(isActive, chargeScale)\n                else\n                        self:setState( false , 0 )\n                    end\n                end\n\n"})}),"\n",(0,t.jsx)(n.h3,{id:"setstate",children:"setState"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Description"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Definition"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"setState()"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"any"}),(0,t.jsx)(n.th,{children:"isActive"})]})}),(0,t.jsx)(n.tbody,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"any"}),(0,t.jsx)(n.td,{children:"chargeScale"})]})})]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Code"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:"function RealLight:setState(isActive, chargeScale)\n    self:setCharge(chargeScale or(isActive and 1 or 0 ))\n    setVisibility( self.node, isActive)\nend\n\n"})}),"\n",(0,t.jsx)(n.h3,{id:"updateiesprofile",children:"updateIESProfile"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Description"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Definition"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"updateIESProfile()"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,t.jsx)(n.table,{children:(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"any"}),(0,t.jsx)(n.th,{children:"iesEnabled"})]})})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Code"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:'function RealLight:updateIESProfile(iesEnabled)\n    for i, lightSource in ipairs( self.lightSources) do\n        local nodeName = string.lower(getName(lightSource))\n        for searchString, profile in pairs( RealLight.DEFAULT_LIGHT_PROFILE) do\n            if string.contains(nodeName, searchString) then\n                if iesEnabled then\n                    if self.xmlIESProfile ~ = nil then\n                        -- xml profile overwrites the i3d setting completely\n                        setLightIESProfile(lightSource, self.xmlIESProfile)\n                    else\n                            local iesProfile = getLightIESProfile(lightSource)\n                            if iesProfile = = "" then\n                                setLightIESProfile(lightSource, profile.iesProfile)\n                            end\n                        end\n                    else\n                            -- remove ies profiles that were set inside the i3d file\n                            local iesProfile = getLightIESProfile(lightSource)\n                            if iesProfile ~ = "" then\n                                setLightIESProfile(lightSource, "" )\n                                self.curIntensityScale = self.intensityScale\n                            end\n                        end\n\n                        self.curIntensityScale = self.intensityScale * profile.intensityScale\n                        break\n                    end\n                end\n            end\n        end\n\n'})}),"\n",(0,t.jsx)(n.h3,{id:"updatelightscattering",children:"updateLightScattering"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Description"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Definition"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"updateLightScattering()"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Code"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:"function RealLight:updateLightScattering()\n    local lightsProfile = g_gameSettings:getValue(GameSettings.SETTING.LIGHTS_PROFILE)\n\n    local isDefaultLightOrHighBeam = false\n    for i, lightType in ipairs( self.lightTypes) do\n        if lightType = = Lights.LIGHT_TYPE_DEFAULT or lightType = = Lights.LIGHT_TYPE_HIGHBEAM then\n            isDefaultLightOrHighBeam = true\n            break\n        end\n    end\n\n    for i, lightSource in ipairs( self.lightSources) do\n        local useLightScattering = false\n\n        if self.useLightScattering = = true then\n            useLightScattering = lightsProfile > = GS_PROFILE_HIGH\n        elseif self.useLightScattering = = nil then\n                if isDefaultLightOrHighBeam then\n                    useLightScattering = lightsProfile > = GS_PROFILE_HIGH\n                else\n                        -- only used typed lights like work lights etc\n                        if # self.lightTypes > 0 then\n                            useLightScattering = lightsProfile > = GS_PROFILE_VERY_HIGH\n                        end\n                    end\n\n                    useLightScattering = useLightScattering and getLightRange(lightSource) > 7.5\n                end\n\n                if useLightScattering then\n                    setLightUseLightScattering(lightSource, true )\n\n                    local coneAngle = getLightConeAngle(lightSource)\n                    if coneAngle > RealLight.SCATTERING_MAX_ANGLE then\n                        setLightScatteringConeAngle(lightSource, RealLight.SCATTERING_MAX_ANGLE)\n                    end\n\n                    setLightScatteringIntensity(lightSource, 1 )\n                else\n                        if getLightUseLightScattering(lightSource) then\n                            setLightUseLightScattering(lightSource, false )\n                        end\n                    end\n                end\n            end\n\n"})}),"\n",(0,t.jsx)(n.h3,{id:"updatemergedshadows",children:"updateMergedShadows"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Description"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Definition"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"updateMergedShadows()"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Code"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:"function RealLight:updateMergedShadows()\n    if not self.hasShadows then\n        return\n    end\n\n    local lightsProfile = g_gameSettings:getValue(GameSettings.SETTING.LIGHTS_PROFILE)\n    if lightsProfile = = GS_PROFILE_ULTRA then\n        if # self.lightSources > 1 then\n            if not self.mergedShadowLightCreated then\n                mergeLightShadows( table.unpack( self.lightSources))\n                setMergedShadowSettingsLight( self.node, self.shadowLightSource)\n\n                for _, component in ipairs( self.vehicle.components) do\n                    addMergedShadowIgnoreShapes( self.lightSources[ 1 ], component.node)\n                end\n\n                self.mergedShadowLightCreated = true\n            end\n\n            for _, lightSource in ipairs( self.lightSources) do\n                setLightShadowMap(lightSource, true , 512 )\n                setLightShadowPriority( self.node, 1.0 )\n            end\n\n            setMergedShadowActive( self.node, true )\n        else\n                setLightShadowMap( self.node, true , 512 )\n                setLightShadowPriority( self.node, 0.5 )\n\n                for _, component in ipairs( self.vehicle.components) do\n                    addLightShadowIgnoreShapes( self.lightSources[ 1 ], component.node)\n                end\n            end\n        else\n                if # self.lightSources > 1 then\n                    setMergedShadowActive( self.node, false )\n\n                    for _, lightSource in ipairs( self.lightSources) do\n                        setLightShadowMap(lightSource, false , 512 )\n                    end\n                else\n                        setLightShadowMap( self.node, false , 512 )\n                    end\n                end\n            end\n\n"})})]})}function c(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(o,{...e})}):o(e)}},28453(e,n,i){i.d(n,{R:()=>r,x:()=>h});var l=i(96540);const t={},s=l.createContext(t);function r(e){const n=l.useContext(s);return l.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function h(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:r(e.components),l.createElement(s.Provider,{value:n},e.children)}}}]);