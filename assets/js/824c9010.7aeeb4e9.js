"use strict";(globalThis.webpackChunkfs25_community_luadoc=globalThis.webpackChunkfs25_community_luadoc||[]).push([[5746],{7501(n,e,i){i.r(e),i.d(e,{assets:()=>d,contentTitle:()=>r,default:()=>p,frontMatter:()=>l,metadata:()=>t,toc:()=>c});const t=JSON.parse('{"id":"script/Specialization/TypeManager","title":"TypeManager","description":"TypeManager","source":"@site/../docs/script/Specialization/TypeManager.md","sourceDirName":"script/Specialization","slug":"/script/Specialization/TypeManager","permalink":"/FS25-Community-LUADOC/script/Specialization/TypeManager","draft":false,"unlisted":false,"tags":[],"version":"current","lastUpdatedAt":1767161192000,"frontMatter":{},"sidebar":"docsSidebar","previous":{"title":"SpecializationUtil","permalink":"/FS25-Community-LUADOC/script/Specialization/SpecializationUtil"},"next":{"title":"AIAutomaticSteering","permalink":"/FS25-Community-LUADOC/script/Specializations/AIAutomaticSteering"}}');var s=i(74848),a=i(28453);const l={},r=void 0,d={},c=[{value:"TypeManager",id:"typemanager",level:2},{value:"addSpecialization",id:"addspecialization",level:3},{value:"addType",id:"addtype",level:3},{value:"finalizeTypes",id:"finalizetypes",level:3},{value:"getObjectTypeFromXML",id:"getobjecttypefromxml",level:3},{value:"getTypeByName",id:"gettypebyname",level:3},{value:"getTypes",id:"gettypes",level:3},{value:"loadMapData",id:"loadmapdata",level:3},{value:"loadTypeFromXML",id:"loadtypefromxml",level:3},{value:"new",id:"new",level:3},{value:"removeType",id:"removetype",level:3},{value:"unloadMapData",id:"unloadmapdata",level:3},{value:"validateTypes",id:"validatetypes",level:3}];function o(n){const e={a:"a",blockquote:"blockquote",code:"code",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,a.R)(),...n.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(e.h2,{id:"typemanager",children:"TypeManager"}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.strong,{children:"Description"})}),"\n",(0,s.jsxs)(e.blockquote,{children:["\n",(0,s.jsx)(e.p,{children:"This class handles all types"}),"\n"]}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.strong,{children:"Functions"})}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:(0,s.jsx)(e.a,{href:"#addspecialization",children:"addSpecialization"})}),"\n",(0,s.jsx)(e.li,{children:(0,s.jsx)(e.a,{href:"#addtype",children:"addType"})}),"\n",(0,s.jsx)(e.li,{children:(0,s.jsx)(e.a,{href:"#finalizetypes",children:"finalizeTypes"})}),"\n",(0,s.jsx)(e.li,{children:(0,s.jsx)(e.a,{href:"#getobjecttypefromxml",children:"getObjectTypeFromXML"})}),"\n",(0,s.jsx)(e.li,{children:(0,s.jsx)(e.a,{href:"#gettypebyname",children:"getTypeByName"})}),"\n",(0,s.jsx)(e.li,{children:(0,s.jsx)(e.a,{href:"#gettypes",children:"getTypes"})}),"\n",(0,s.jsx)(e.li,{children:(0,s.jsx)(e.a,{href:"#loadmapdata",children:"loadMapData"})}),"\n",(0,s.jsx)(e.li,{children:(0,s.jsx)(e.a,{href:"#loadtypefromxml",children:"loadTypeFromXML"})}),"\n",(0,s.jsx)(e.li,{children:(0,s.jsx)(e.a,{href:"#new",children:"new"})}),"\n",(0,s.jsx)(e.li,{children:(0,s.jsx)(e.a,{href:"#removetype",children:"removeType"})}),"\n",(0,s.jsx)(e.li,{children:(0,s.jsx)(e.a,{href:"#unloadmapdata",children:"unloadMapData"})}),"\n",(0,s.jsx)(e.li,{children:(0,s.jsx)(e.a,{href:"#validatetypes",children:"validateTypes"})}),"\n"]}),"\n",(0,s.jsx)(e.h3,{id:"addspecialization",children:"addSpecialization"}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.strong,{children:"Description"})}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.strong,{children:"Definition"})}),"\n",(0,s.jsxs)(e.blockquote,{children:["\n",(0,s.jsx)(e.p,{children:"addSpecialization()"}),"\n"]}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,s.jsxs)(e.table,{children:[(0,s.jsx)(e.thead,{children:(0,s.jsxs)(e.tr,{children:[(0,s.jsx)(e.th,{children:"any"}),(0,s.jsx)(e.th,{children:"typeName"})]})}),(0,s.jsx)(e.tbody,{children:(0,s.jsxs)(e.tr,{children:[(0,s.jsx)(e.td,{children:"any"}),(0,s.jsx)(e.td,{children:"specName"})]})})]}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.strong,{children:"Code"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lua",children:"function TypeManager:addSpecialization(typeName, specName)\n    local typeEntry = self.types[typeName]\n    if typeEntry ~ = nil then\n        if typeEntry.specializationsByName[specName] = = nil then\n            local spec = self.specializationManager:getSpecializationObjectByName(specName)\n            if spec = = nil then\n                Logging.error( \"%s type '%s' has unknown specialization '%s!\" , self.typeName, tostring(typeName), tostring(specName))\n                return false\n            end\n\n            table.insert(typeEntry.specializations, spec)\n            table.insert(typeEntry.specializationNames, specName)\n            typeEntry.specializationsByName[specName] = spec\n\n            return true\n        else\n                Logging.error( \"Specialization '%s' already exists for %s type '%s'!\" , specName, self.typeName, typeName)\n                    return false\n                end\n            else\n                    Logging.error( \"%s type '%s' is not defined!\" , self.typeName, typeName)\n                    return false\n                end\n            end\n\n"})}),"\n",(0,s.jsx)(e.h3,{id:"addtype",children:"addType"}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.strong,{children:"Description"})}),"\n",(0,s.jsxs)(e.blockquote,{children:["\n",(0,s.jsx)(e.p,{children:"Adds a new type"}),"\n"]}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.strong,{children:"Definition"})}),"\n",(0,s.jsxs)(e.blockquote,{children:["\n",(0,s.jsx)(e.p,{children:"addType(string typeName, string className, string filename, string customEnvironment, )"}),"\n"]}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,s.jsxs)(e.table,{children:[(0,s.jsx)(e.thead,{children:(0,s.jsxs)(e.tr,{children:[(0,s.jsx)(e.th,{children:"string"}),(0,s.jsx)(e.th,{children:"typeName"}),(0,s.jsx)(e.th,{children:"type name"})]})}),(0,s.jsxs)(e.tbody,{children:[(0,s.jsxs)(e.tr,{children:[(0,s.jsx)(e.td,{children:"string"}),(0,s.jsx)(e.td,{children:"className"}),(0,s.jsx)(e.td,{children:"classname"})]}),(0,s.jsxs)(e.tr,{children:[(0,s.jsx)(e.td,{children:"string"}),(0,s.jsx)(e.td,{children:"filename"}),(0,s.jsx)(e.td,{children:"filename"})]}),(0,s.jsxs)(e.tr,{children:[(0,s.jsx)(e.td,{children:"string"}),(0,s.jsx)(e.td,{children:"customEnvironment"}),(0,s.jsx)(e.td,{children:"a custom environment"})]}),(0,s.jsxs)(e.tr,{children:[(0,s.jsx)(e.td,{children:"any"}),(0,s.jsx)(e.td,{children:"parent"}),(0,s.jsx)(e.td,{})]})]})]}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.strong,{children:"Return Values"})}),"\n\n\n\n\n\n\n\n\n",(0,s.jsx)(e.table,{children:(0,s.jsx)(e.thead,{children:(0,s.jsxs)(e.tr,{children:[(0,s.jsx)(e.th,{children:"any"}),(0,s.jsx)(e.th,{children:"success"}),(0,s.jsx)(e.th,{children:"true if added else false"})]})})}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.strong,{children:"Code"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lua",children:'function TypeManager:addType(typeName, className, filename, customEnvironment, parent)\n\n    if self.types[typeName] ~ = nil then\n        Logging.error( "Multiple specifications of %s type \'%s\'" , self.typeName, typeName)\n        return false\n    elseif className = = nil then\n            Logging.error( "No className specified for %s type \'%s\'" , self.typeName, typeName)\n                return false\n            elseif filename = = nil then\n                    Logging.error( "No filename specified for %s type \'%s\'" , self.typeName, typeName)\n                        return false\n                    else\n                            customEnvironment = customEnvironment or ""\n                            source(filename, customEnvironment)\n\n                            local typeEntry = { }\n                            typeEntry.name = typeName\n                            typeEntry.className = className\n                            typeEntry.filename = filename\n                            typeEntry.specializations = { }\n                            typeEntry.specializationNames = { }\n                            typeEntry.specializationsByName = { }\n                            typeEntry.functions = { }\n                            typeEntry.events = { }\n                            typeEntry.eventListeners = { }\n                            typeEntry.customEnvironment = customEnvironment\n                            typeEntry.parent = parent\n\n                            self.types[typeName] = typeEntry\n                        end\n\n                        return true\n                    end\n\n'})}),"\n",(0,s.jsx)(e.h3,{id:"finalizetypes",children:"finalizeTypes"}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.strong,{children:"Description"})}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.strong,{children:"Definition"})}),"\n",(0,s.jsxs)(e.blockquote,{children:["\n",(0,s.jsx)(e.p,{children:"finalizeTypes()"}),"\n"]}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.strong,{children:"Code"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lua",children:'function TypeManager:finalizeTypes()\n    for typeName, typeEntry in pairs( self.types) do\n        local classObject = ClassUtil.getClassObject(typeEntry.className)\n        g_asyncTaskManager:addSubtask( function ()\n            if classObject.registerEvents ~ = nil then\n                classObject.registerEvents(typeEntry)\n            end\n        end )\n\n        g_asyncTaskManager:addSubtask( function ()\n            if classObject.registerFunctions ~ = nil then\n                classObject.registerFunctions(typeEntry)\n            end\n        end )\n\n        g_asyncTaskManager:addSubtask( function ()\n            -- register events, functions, and overwritten functions for all specializations\n                for _,specialization in ipairs(typeEntry.specializations) do\n                    if specialization.registerEvents ~ = nil then\n                        specialization.registerEvents(typeEntry)\n                    end\n                end\n            end )\n\n            g_asyncTaskManager:addSubtask( function ()\n                for _,specialization in ipairs(typeEntry.specializations) do\n                    if specialization.registerFunctions ~ = nil then\n                        specialization.registerFunctions(typeEntry)\n                    end\n                end\n            end )\n\n            g_asyncTaskManager:addSubtask( function ()\n                for _,specialization in ipairs(typeEntry.specializations) do\n                    if specialization.registerOverwrittenFunctions ~ = nil then\n                        specialization.registerOverwrittenFunctions(typeEntry)\n                    end\n                end\n            end )\n\n            g_asyncTaskManager:addSubtask( function ()\n                for _,specialization in ipairs(typeEntry.specializations) do\n                    if specialization.registerEventListeners ~ = nil then\n                        specialization.registerEventListeners(typeEntry)\n                    end\n                end\n            end )\n\n            g_asyncTaskManager:addSubtask( function ()\n                if typeEntry.customEnvironment ~ = "" then\n                    print( string.format( " Register %s type: %s" , self.typeName, typeName))\n                end\n            end )\n        end\n\n        return true\n    end\n\n'})}),"\n",(0,s.jsx)(e.h3,{id:"getobjecttypefromxml",children:"getObjectTypeFromXML"}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.strong,{children:"Description"})}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.strong,{children:"Definition"})}),"\n",(0,s.jsxs)(e.blockquote,{children:["\n",(0,s.jsx)(e.p,{children:"getObjectTypeFromXML()"}),"\n"]}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,s.jsx)(e.table,{children:(0,s.jsx)(e.thead,{children:(0,s.jsxs)(e.tr,{children:[(0,s.jsx)(e.th,{children:"any"}),(0,s.jsx)(e.th,{children:"xmlFilename"})]})})}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.strong,{children:"Code"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lua",children:"function TypeManager:getObjectTypeFromXML(xmlFilename)\n    local xmlFile = XMLFile.loadIfExists( string.format( \"%sXML\" , self.typeName), xmlFilename, self.xmlSchema)\n    if xmlFile = = nil then\n        Logging.error( \"Unable to find %s xml file '%s'\" , self.typeName, xmlFilename)\n        return nil , nil\n    end\n\n    local typeName = xmlFile:getValue(xmlFile:getRootName() .. \"#type\" )\n    xmlFile:delete()\n\n    if typeName = = nil then\n        Logging.error( \"Missing type declaration in '%s'\" , xmlFilename)\n        return nil , nil\n    end\n\n    local modName, _ = Utils.getModNameAndBaseDirectory(xmlFilename)\n    local typeEntry = self:getTypeByName(typeName, modName)\n\n    if typeEntry = = nil then\n        Logging.error( \"Unknown type '%s' in '%s'\" , typeName, xmlFilename)\n        return nil , nil\n    end\n\n    local class = ClassUtil.getClassObject(typeEntry.className)\n    if class = = nil then\n        Logging.error( \"Unknown type className '%s' of type '%s' (%s)\" , typeEntry.className, typeName, xmlFilename)\n        return nil , nil\n    end\n\n    return typeEntry, class\nend\n\n"})}),"\n",(0,s.jsx)(e.h3,{id:"gettypebyname",children:"getTypeByName"}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.strong,{children:"Description"})}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.strong,{children:"Definition"})}),"\n",(0,s.jsxs)(e.blockquote,{children:["\n",(0,s.jsx)(e.p,{children:"getTypeByName()"}),"\n"]}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,s.jsxs)(e.table,{children:[(0,s.jsx)(e.thead,{children:(0,s.jsxs)(e.tr,{children:[(0,s.jsx)(e.th,{children:"any"}),(0,s.jsx)(e.th,{children:"typeName"})]})}),(0,s.jsx)(e.tbody,{children:(0,s.jsxs)(e.tr,{children:[(0,s.jsx)(e.td,{children:"any"}),(0,s.jsx)(e.td,{children:"modName"})]})})]}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.strong,{children:"Code"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lua",children:'function TypeManager:getTypeByName(typeName, modName)\n    if typeName ~ = nil then\n        local typeEntry = self.types[typeName]\n        if typeEntry ~ = nil then\n            return typeEntry\n        else\n                if g_modIsLoaded[modName] = = nil or not g_modIsLoaded[modName] then\n                    Logging.error( "Unable to get type \'%s\' from xml file.Corresponding mod is not loaded" , modName)\n                    return nil\n                end\n\n                if typeEntry = = nil then\n                    typeName = modName .. "." .. typeName\n                    return self.types[typeName]\n                end\n            end\n        end\n\n        return nil\n    end\n\n'})}),"\n",(0,s.jsx)(e.h3,{id:"gettypes",children:"getTypes"}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.strong,{children:"Description"})}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.strong,{children:"Definition"})}),"\n",(0,s.jsxs)(e.blockquote,{children:["\n",(0,s.jsx)(e.p,{children:"getTypes()"}),"\n"]}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.strong,{children:"Code"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lua",children:"function TypeManager:getTypes()\n    return self.types\nend\n\n"})}),"\n",(0,s.jsx)(e.h3,{id:"loadmapdata",children:"loadMapData"}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.strong,{children:"Description"})}),"\n",(0,s.jsxs)(e.blockquote,{children:["\n",(0,s.jsx)(e.p,{children:"Load data on map load"}),"\n"]}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.strong,{children:"Definition"})}),"\n",(0,s.jsxs)(e.blockquote,{children:["\n",(0,s.jsx)(e.p,{children:"loadMapData()"}),"\n"]}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.strong,{children:"Return Values"})}),"\n\n\n\n\n\n\n\n\n",(0,s.jsx)(e.table,{children:(0,s.jsx)(e.thead,{children:(0,s.jsxs)(e.tr,{children:[(0,s.jsx)(e.th,{children:"any"}),(0,s.jsx)(e.th,{children:"true"}),(0,s.jsx)(e.th,{children:"if loading was successful else false"})]})})}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.strong,{children:"Code"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lua",children:'function TypeManager:loadMapData()\n    local xmlFile = loadXMLFile( "typesXML" , self.xmlFilename)\n\n    local i = 0\n    while true do\n        local key = string.format( "%s.type(%d)" , self.rootElementName, i)\n        if not hasXMLProperty(xmlFile, key) then\n            break\n        end\n\n        local typeName = getXMLString(xmlFile, key .. "#name" )\n        g_asyncTaskManager:addSubtask( function ()\n            self:loadTypeFromXML(xmlFile, key, nil , nil , nil )\n        end , string.format( "TypeManager - Load Type \'%s\'" , typeName))\n\n        i = i + 1\n    end\n\n    g_asyncTaskManager:addSubtask( function ()\n        delete(xmlFile)\n    end )\n\n    g_asyncTaskManager:addSubtask( function ()\n        print( " Loaded " .. self.typeName .. " types" )\n    end )\n\n    return true\nend\n\n'})}),"\n",(0,s.jsx)(e.h3,{id:"loadtypefromxml",children:"loadTypeFromXML"}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.strong,{children:"Description"})}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.strong,{children:"Definition"})}),"\n",(0,s.jsxs)(e.blockquote,{children:["\n",(0,s.jsx)(e.p,{children:"loadTypeFromXML()"}),"\n"]}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,s.jsxs)(e.table,{children:[(0,s.jsx)(e.thead,{children:(0,s.jsxs)(e.tr,{children:[(0,s.jsx)(e.th,{children:"any"}),(0,s.jsx)(e.th,{children:"xmlFile"})]})}),(0,s.jsxs)(e.tbody,{children:[(0,s.jsxs)(e.tr,{children:[(0,s.jsx)(e.td,{children:"any"}),(0,s.jsx)(e.td,{children:"key"})]}),(0,s.jsxs)(e.tr,{children:[(0,s.jsx)(e.td,{children:"any"}),(0,s.jsx)(e.td,{children:"isDLC"})]}),(0,s.jsxs)(e.tr,{children:[(0,s.jsx)(e.td,{children:"any"}),(0,s.jsx)(e.td,{children:"modDir"})]}),(0,s.jsxs)(e.tr,{children:[(0,s.jsx)(e.td,{children:"any"}),(0,s.jsx)(e.td,{children:"modName"})]})]})]}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.strong,{children:"Code"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lua",children:'function TypeManager:loadTypeFromXML(xmlFile, key, isDLC, modDir, modName)\n    local typeName = getXMLString(xmlFile, key .. "#name" )\n    local parentName = getXMLString(xmlFile, key .. "#parent" )\n\n    if typeName = = nil and parentName = = nil then\n        Logging.error( "Missing name or parent for placeableType \'%s\'" , key)\n            return false\n        end\n\n        local parent\n        if parentName ~ = nil then\n            parent = self.types[parentName]\n            if parent = = nil then\n                if modName ~ = nil and modName ~ = "" then\n                    parentName = modName .. "." .. parentName\n                end\n\n                parent = self.types[parentName]\n                if parent = = nil then\n                    Logging.error( "Parent %s type \'%s\' is not defined!" , self.typeName, parentName)\n                    return false\n                end\n            end\n        end\n\n        local className = getXMLString(xmlFile, key .. "#className" )\n        local filename = getXMLString(xmlFile, key .. "#filename" )\n        if parent ~ = nil then\n            className = className or parent.className\n            filename = filename or parent.filename\n        end\n\n        if modName ~ = nil and modName ~ = "" then\n            typeName = modName .. "." .. typeName\n        end\n\n        if className ~ = nil and filename ~ = nil then\n            local customEnvironment = nil\n            if modDir ~ = nil then\n                local useModDirectory\n                filename, useModDirectory = Utils.getFilename(filename, modDir)\n                if useModDirectory then\n                    customEnvironment = modName\n                    className = modName .. "." .. className\n                end\n            end\n\n            if Platform.allowsScriptMods or isDLC or customEnvironment = = nil then\n                self:addType(typeName, className, filename, customEnvironment, parent)\n\n                -- add parent specializations\n                if parent ~ = nil then\n                    for _, specName in ipairs(parent.specializationNames) do\n                        self:addSpecialization(typeName, specName)\n                    end\n                end\n\n                -- add type specializations\n                local j = 0\n                while true do\n                    local specKey = string.format( "%s.specialization(%d)" , key, j)\n                    if not hasXMLProperty(xmlFile, specKey) then\n                        break\n                    end\n\n                    local specName = getXMLString(xmlFile, specKey .. "#name" )\n                    local entry = self.specializationManager:getSpecializationByName(specName)\n                    if entry = = nil then\n                        if modName ~ = nil then\n                            specName = modName .. "." .. specName\n                        end\n\n                        entry = self.specializationManager:getSpecializationByName(specName)\n                        if entry = = nil then\n                            Logging.error( "Could not find specialization \'%s\' for %s type \'%s\'." , specName, self.typeName, typeName)\n                                specName = nil\n                            end\n                        end\n\n                        if specName ~ = nil then\n                            self:addSpecialization(typeName, specName)\n                        end\n\n                        j = j + 1\n                    end\n\n                    return true\n\n                else\n                        Logging.error( "Can\'t register %s type \'%s\' with scripts on consoles." , self.typeName, typeName)\n                    end\n                else\n                        Logging.error( "Can\'t register %s type as its className and filename do not resolve to any valid values.Ensure the types have a className and filename defined, or a base type with them defined." , self.typeName)\n                        end\n\n                        return false\n                    end\n\n'})}),"\n",(0,s.jsx)(e.h3,{id:"new",children:"new"}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.strong,{children:"Description"})}),"\n",(0,s.jsxs)(e.blockquote,{children:["\n",(0,s.jsx)(e.p,{children:"Creating manager"}),"\n"]}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.strong,{children:"Definition"})}),"\n",(0,s.jsxs)(e.blockquote,{children:["\n",(0,s.jsx)(e.p,{children:"new()"}),"\n"]}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,s.jsxs)(e.table,{children:[(0,s.jsx)(e.thead,{children:(0,s.jsxs)(e.tr,{children:[(0,s.jsx)(e.th,{children:"any"}),(0,s.jsx)(e.th,{children:"typeName"})]})}),(0,s.jsxs)(e.tbody,{children:[(0,s.jsxs)(e.tr,{children:[(0,s.jsx)(e.td,{children:"any"}),(0,s.jsx)(e.td,{children:"rootElementName"})]}),(0,s.jsxs)(e.tr,{children:[(0,s.jsx)(e.td,{children:"any"}),(0,s.jsx)(e.td,{children:"xmlFilename"})]}),(0,s.jsxs)(e.tr,{children:[(0,s.jsx)(e.td,{children:"any"}),(0,s.jsx)(e.td,{children:"specializationManager"})]}),(0,s.jsxs)(e.tr,{children:[(0,s.jsx)(e.td,{children:"any"}),(0,s.jsx)(e.td,{children:"customMt"})]})]})]}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.strong,{children:"Return Values"})}),"\n\n\n\n\n\n\n\n\n",(0,s.jsx)(e.table,{children:(0,s.jsx)(e.thead,{children:(0,s.jsxs)(e.tr,{children:[(0,s.jsx)(e.th,{children:"any"}),(0,s.jsx)(e.th,{children:"instance"}),(0,s.jsx)(e.th,{children:"instance of object"})]})})}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.strong,{children:"Code"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lua",children:"function TypeManager.new(typeName, rootElementName, xmlFilename, specializationManager, customMt)\n    local self = setmetatable( { } , customMt or TypeManager _mt)\n\n    self.types = { }\n    self.typeName = typeName\n    self.rootElementName = rootElementName\n    self.xmlFilename = xmlFilename\n    self.specializationManager = specializationManager\n\n    return self\nend\n\n"})}),"\n",(0,s.jsx)(e.h3,{id:"removetype",children:"removeType"}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.strong,{children:"Description"})}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.strong,{children:"Definition"})}),"\n",(0,s.jsxs)(e.blockquote,{children:["\n",(0,s.jsx)(e.p,{children:"removeType()"}),"\n"]}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,s.jsx)(e.table,{children:(0,s.jsx)(e.thead,{children:(0,s.jsxs)(e.tr,{children:[(0,s.jsx)(e.th,{children:"any"}),(0,s.jsx)(e.th,{children:"typeName"})]})})}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.strong,{children:"Code"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lua",children:"function TypeManager:removeType(typeName)\n    self.types[typeName] = nil\nend\n\n"})}),"\n",(0,s.jsx)(e.h3,{id:"unloadmapdata",children:"unloadMapData"}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.strong,{children:"Description"})}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.strong,{children:"Definition"})}),"\n",(0,s.jsxs)(e.blockquote,{children:["\n",(0,s.jsx)(e.p,{children:"unloadMapData()"}),"\n"]}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.strong,{children:"Code"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lua",children:"function TypeManager:unloadMapData()\n    self.types = { }\nend\n\n"})}),"\n",(0,s.jsx)(e.h3,{id:"validatetypes",children:"validateTypes"}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.strong,{children:"Description"})}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.strong,{children:"Definition"})}),"\n",(0,s.jsxs)(e.blockquote,{children:["\n",(0,s.jsx)(e.p,{children:"validateTypes()"}),"\n"]}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.strong,{children:"Code"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lua",children:"function TypeManager:validateTypes()\n    for typeName, typeEntry in pairs( self.types) do\n        g_asyncTaskManager:addSubtask( function ()\n            for _, specName in ipairs(typeEntry.specializationNames) do\n                local spec = typeEntry.specializationsByName[specName]\n                if spec.prerequisitesPresent = = nil then\n                    Logging.error( \"Specialisation with name %s is missing prerequisitesPresent function.If no prerequisites are needed, this function can just return true.\" , specName)\n                        self:removeType(typeName)\n                    elseif not spec.prerequisitesPresent(typeEntry.specializations) then\n                            Logging.error( \"Not all prerequisites of specialization '%s' in %s type '%s' are fulfilled\" , specName, self.typeName, typeName)\n                            self:removeType(typeName)\n                        end\n                    end\n                end )\n            end\n        end\n\n"})})]})}function p(n={}){const{wrapper:e}={...(0,a.R)(),...n.components};return e?(0,s.jsx)(e,{...n,children:(0,s.jsx)(o,{...n})}):o(n)}},28453(n,e,i){i.d(e,{R:()=>l,x:()=>r});var t=i(96540);const s={},a=t.createContext(s);function l(n){const e=t.useContext(a);return t.useMemo(function(){return"function"==typeof n?n(e):{...e,...n}},[e,n])}function r(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(s):n.components||s:l(n.components),t.createElement(a.Provider,{value:e},n.children)}}}]);