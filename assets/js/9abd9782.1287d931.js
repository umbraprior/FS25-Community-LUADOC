"use strict";(globalThis.webpackChunkfs25_community_luadoc=globalThis.webpackChunkfs25_community_luadoc||[]).push([[38605],{28453(e,n,t){t.d(n,{R:()=>l,x:()=>r});var i=t(96540);const o={},a=i.createContext(o);function l(e){const n=i.useContext(a);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:l(e.components),i.createElement(a.Provider,{value:n},e.children)}},99173(e,n,t){t.r(n),t.d(n,{assets:()=>s,contentTitle:()=>r,default:()=>h,frontMatter:()=>l,metadata:()=>i,toc:()=>c});const i=JSON.parse('{"id":"script/Specializations/AttacherJoints","title":"AttacherJoints","description":"AttacherJoints","source":"@site/../docs/script/Specializations/AttacherJoints.md","sourceDirName":"script/Specializations","slug":"/script/Specializations/AttacherJoints","permalink":"/FS25-Community-LUADOC/script/Specializations/AttacherJoints","draft":false,"unlisted":false,"tags":[],"version":"current","lastUpdatedAt":1767161192000,"frontMatter":{},"sidebar":"docsSidebar","previous":{"title":"AttacherJointControl","permalink":"/FS25-Community-LUADOC/script/Specializations/AttacherJointControl"},"next":{"title":"AutoLoadable","permalink":"/FS25-Community-LUADOC/script/Specializations/AutoLoadable"}}');var o=t(74848),a=t(28453);const l={},r=void 0,s={},c=[{value:"AttacherJoints",id:"attacherjoints",level:2},{value:"actionEventAttach",id:"actioneventattach",level:3},{value:"actionEventDetach",id:"actioneventdetach",level:3},{value:"actionEventLowerAllImplements",id:"actioneventlowerallimplements",level:3},{value:"actionEventLowerImplement",id:"actioneventlowerimplement",level:3},{value:"activateAttachments",id:"activateattachments",level:3},{value:"addChildVehicles",id:"addchildvehicles",level:3},{value:"additionalAttachmentLoaded",id:"additionalattachmentloaded",level:3},{value:"addToPhysics",id:"addtophysics",level:3},{value:"addVehicleToAIImplementList",id:"addvehicletoaiimplementlist",level:3},{value:"attachableAddToolCameras",id:"attachableaddtoolcameras",level:3},{value:"attachableRemoveToolCameras",id:"attachableremovetoolcameras",level:3},{value:"attachAdditionalAttachment",id:"attachadditionalattachment",level:3},{value:"attachImplementFromInfo",id:"attachimplementfrominfo",level:3},{value:"calculateAttacherJointMoveUpperLowerAlpha",id:"calculateattacherjointmoveupperloweralpha",level:3},{value:"callFunctionOnAllImplements",id:"callfunctiononallimplements",level:3},{value:"collectAIAgentAttachments",id:"collectaiagentattachments",level:3},{value:"consoleCommandBottomArmWidth",id:"consolecommandbottomarmwidth",level:3},{value:"createAttachmentJoint",id:"createattachmentjoint",level:3},{value:"deactivateAttachments",id:"deactivateattachments",level:3},{value:"deactivateAttachmentsLights",id:"deactivateattachmentslights",level:3},{value:"detachAdditionalAttachment",id:"detachadditionalattachment",level:3},{value:"detachAttachedImplement",id:"detachattachedimplement",level:3},{value:"detachImplement",id:"detachimplement",level:3},{value:"detachImplementByObject",id:"detachimplementbyobject",level:3},{value:"detachingIsPossible",id:"detachingispossible",level:3},{value:"doGroundHeightNodeCheck",id:"dogroundheightnodecheck",level:3},{value:"findVehicleInAttachRange",id:"findvehicleinattachrange",level:3},{value:"finishGroundHeightNodeCheck",id:"finishgroundheightnodecheck",level:3},{value:"getAdditionalComponentMass",id:"getadditionalcomponentmass",level:3},{value:"getAirConsumerUsage",id:"getairconsumerusage",level:3},{value:"getAreControlledActionsAllowed",id:"getarecontrolledactionsallowed",level:3},{value:"getAttachedImplements",id:"getattachedimplements",level:3},{value:"getAttacherJointByJointDescIndex",id:"getattacherjointbyjointdescindex",level:3},{value:"getAttacherJointByNode",id:"getattacherjointbynode",level:3},{value:"getAttacherJointCompatibility",id:"getattacherjointcompatibility",level:3},{value:"getAttacherJointDescFromObject",id:"getattacherjointdescfromobject",level:3},{value:"getAttacherJointIndexByNode",id:"getattacherjointindexbynode",level:3},{value:"getAttacherJointIndexFromImplementIndex",id:"getattacherjointindexfromimplementindex",level:3},{value:"getAttacherJointIndexFromObject",id:"getattacherjointindexfromobject",level:3},{value:"getAttacherJoints",id:"getattacherjoints",level:3},{value:"getCanSteerAttachable",id:"getcansteerattachable",level:3},{value:"getCanToggleAttach",id:"getcantoggleattach",level:3},{value:"getClosestLowerLinkCategoryIndex",id:"getclosestlowerlinkcategoryindex",level:3},{value:"getConnectionHoseConfigIndex",id:"getconnectionhoseconfigindex",level:3},{value:"getDirectionSnapAngle",id:"getdirectionsnapangle",level:3},{value:"getFillLevelInformation",id:"getfilllevelinformation",level:3},{value:"getFillUnitSupportsToolType",id:"getfillunitsupportstooltype",level:3},{value:"getHasObjectMounted",id:"gethasobjectmounted",level:3},{value:"getImplementByJointDescIndex",id:"getimplementbyjointdescindex",level:3},{value:"getImplementByObject",id:"getimplementbyobject",level:3},{value:"getImplementFromAttacherJointIndex",id:"getimplementfromattacherjointindex",level:3},{value:"getImplementIndexByJointDescIndex",id:"getimplementindexbyjointdescindex",level:3},{value:"getImplementIndexByObject",id:"getimplementindexbyobject",level:3},{value:"getIsAttacherJointCompatible",id:"getisattacherjointcompatible",level:3},{value:"getIsAttacherJointHeightNodeActive",id:"getisattacherjointheightnodeactive",level:3},{value:"getIsAttachingAllowed",id:"getisattachingallowed",level:3},{value:"getIsAutomaticShiftingAllowed",id:"getisautomaticshiftingallowed",level:3},{value:"getIsConnectionTargetUsed",id:"getisconnectiontargetused",level:3},{value:"getIsDashboardGroupActive",id:"getisdashboardgroupactive",level:3},{value:"getIsFoldAllowed",id:"getisfoldallowed",level:3},{value:"getIsHardAttachAllowed",id:"getishardattachallowed",level:3},{value:"getIsReadyForAutomatedTrainTravel",id:"getisreadyforautomatedtraintravel",level:3},{value:"getIsSmoothAttachUpdateAllowed",id:"getissmoothattachupdateallowed",level:3},{value:"getIsTipSideAvailable",id:"getistipsideavailable",level:3},{value:"getIsWheelFoliageDestructionAllowed",id:"getiswheelfoliagedestructionallowed",level:3},{value:"getJointMoveDown",id:"getjointmovedown",level:3},{value:"getObjectFromImplementIndex",id:"getobjectfromimplementindex",level:3},{value:"getPowerTakeOffConfigIndex",id:"getpowertakeoffconfigindex",level:3},{value:"getRequiresPower",id:"getrequirespower",level:3},{value:"getSelectedImplement",id:"getselectedimplement",level:3},{value:"getShowAttachControlBarAction",id:"getshowattachcontrolbaraction",level:3},{value:"getTotalMass",id:"gettotalmass",level:3},{value:"groundHeightNodeCheckCallback",id:"groundheightnodecheckcallback",level:3},{value:"handleLowerImplementByAttacherJointIndex",id:"handlelowerimplementbyattacherjointindex",level:3},{value:"handleLowerImplementEvent",id:"handlelowerimplementevent",level:3},{value:"hardAttachImplement",id:"hardattachimplement",level:3},{value:"hardDetachImplement",id:"harddetachimplement",level:3},{value:"initSpecialization",id:"initspecialization",level:3},{value:"isDetachAllowed",id:"isdetachallowed",level:3},{value:"loadAttacherJointFromXML",id:"loadattacherjointfromxml",level:3},{value:"loadAttacherJointHeightNode",id:"loadattacherjointheightnode",level:3},{value:"loadAttachmentsFinished",id:"loadattachmentsfinished",level:3},{value:"loadDashboardGroupFromXML",id:"loaddashboardgroupfromxml",level:3},{value:"loadFillUnitFromXML",id:"loadfillunitfromxml",level:3},{value:"loadHoseTargetNode",id:"loadhosetargetnode",level:3},{value:"loadTipSide",id:"loadtipside",level:3},{value:"onActivate",id:"onactivate",level:3},{value:"onAttacherJointsVehicleLoaded",id:"onattacherjointsvehicleloaded",level:3},{value:"onBeaconLightsVisibilityChanged",id:"onbeaconlightsvisibilitychanged",level:3},{value:"onBottomArmToolbarI3DLoaded",id:"onbottomarmtoolbari3dloaded",level:3},{value:"onBrake",id:"onbrake",level:3},{value:"onBrakeLightsVisibilityChanged",id:"onbrakelightsvisibilitychanged",level:3},{value:"onDeactivate",id:"ondeactivate",level:3},{value:"onDelete",id:"ondelete",level:3},{value:"onLeaveVehicle",id:"onleavevehicle",level:3},{value:"onLightsTypesMaskChanged",id:"onlightstypesmaskchanged",level:3},{value:"onLoad",id:"onload",level:3},{value:"onLoadFinished",id:"onloadfinished",level:3},{value:"onPostLoad",id:"onpostload",level:3},{value:"onPreDelete",id:"onpredelete",level:3},{value:"onPreLoad",id:"onpreload",level:3},{value:"onReadStream",id:"onreadstream",level:3},{value:"onRegisterActionEvents",id:"onregisteractionevents",level:3},{value:"onRegisterDashboardValueTypes",id:"onregisterdashboardvaluetypes",level:3},{value:"onReverseDirectionChanged",id:"onreversedirectionchanged",level:3},{value:"onReverseLightsVisibilityChanged",id:"onreverselightsvisibilitychanged",level:3},{value:"onStateChange",id:"onstatechange",level:3},{value:"onTurnedOff",id:"onturnedoff",level:3},{value:"onTurnedOn",id:"onturnedon",level:3},{value:"onTurnLightStateChanged",id:"onturnlightstatechanged",level:3},{value:"onUpdate",id:"onupdate",level:3},{value:"onUpdateEnd",id:"onupdateend",level:3},{value:"onUpdateInterpolation",id:"onupdateinterpolation",level:3},{value:"onUpdateTick",id:"onupdatetick",level:3},{value:"onWriteStream",id:"onwritestream",level:3},{value:"playAttachSound",id:"playattachsound",level:3},{value:"playDetachSound",id:"playdetachsound",level:3},{value:"postAttachImplement",id:"postattachimplement",level:3},{value:"prerequisitesPresent",id:"prerequisitespresent",level:3},{value:"raiseActive",id:"raiseactive",level:3},{value:"registerActionEvents",id:"registeractionevents",level:3},{value:"registerAttacherJointXMLPaths",id:"registerattacherjointxmlpaths",level:3},{value:"registerEventListeners",id:"registereventlisteners",level:3},{value:"registerEvents",id:"registerevents",level:3},{value:"registerFunctions",id:"registerfunctions",level:3},{value:"registerJointType",id:"registerjointtype",level:3},{value:"registerOverwrittenFunctions",id:"registeroverwrittenfunctions",level:3},{value:"registerSelectableObjects",id:"registerselectableobjects",level:3},{value:"registerSelfLoweringActionEvent",id:"registerselfloweringactionevent",level:3},{value:"removeActionEvents",id:"removeactionevents",level:3},{value:"removeFromPhysics",id:"removefromphysics",level:3},{value:"saveToXMLFile",id:"savetoxmlfile",level:3},{value:"setAIVehicleObstacleStateDirty",id:"setaivehicleobstaclestatedirty",level:3},{value:"setAttacherJointBottomArmWidth",id:"setattacherjointbottomarmwidth",level:3},{value:"setJointMoveDown",id:"setjointmovedown",level:3},{value:"setSelectedImplementByObject",id:"setselectedimplementbyobject",level:3},{value:"startAttacherJointCombo",id:"startattacherjointcombo",level:3},{value:"updateActionEvents",id:"updateactionevents",level:3},{value:"updateAttacherJointGraphics",id:"updateattacherjointgraphics",level:3},{value:"updateAttacherJointLimits",id:"updateattacherjointlimits",level:3},{value:"updateAttacherJointRotation",id:"updateattacherjointrotation",level:3},{value:"updateAttacherJointRotationLimit",id:"updateattacherjointrotationlimit",level:3},{value:"updateAttacherJointRotationNodes",id:"updateattacherjointrotationnodes",level:3},{value:"updateAttacherJointSettingsByObject",id:"updateattacherjointsettingsbyobject",level:3},{value:"updateAttacherJointTranslationLimit",id:"updateattacherjointtranslationlimit",level:3},{value:"updateRequiredTopLightsState",id:"updaterequiredtoplightsstate",level:3},{value:"updateVehiclesInAttachRange",id:"updatevehiclesinattachrange",level:3}];function d(e){const n={a:"a",blockquote:"blockquote",code:"code",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,a.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(n.h2,{id:"attacherjoints",children:"AttacherJoints"}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Description"})}),"\n",(0,o.jsxs)(n.blockquote,{children:["\n",(0,o.jsx)(n.p,{children:"Specialization for vehicles with attacherJoints allowing attaching/coupling of tools"}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Functions"})}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.a,{href:"#actioneventattach",children:"actionEventAttach"})}),"\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.a,{href:"#actioneventdetach",children:"actionEventDetach"})}),"\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.a,{href:"#actioneventlowerallimplements",children:"actionEventLowerAllImplements"})}),"\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.a,{href:"#actioneventlowerimplement",children:"actionEventLowerImplement"})}),"\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.a,{href:"#activateattachments",children:"activateAttachments"})}),"\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.a,{href:"#addchildvehicles",children:"addChildVehicles"})}),"\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.a,{href:"#additionalattachmentloaded",children:"additionalAttachmentLoaded"})}),"\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.a,{href:"#addtophysics",children:"addToPhysics"})}),"\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.a,{href:"#addvehicletoaiimplementlist",children:"addVehicleToAIImplementList"})}),"\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.a,{href:"#attachableaddtoolcameras",children:"attachableAddToolCameras"})}),"\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.a,{href:"#attachableremovetoolcameras",children:"attachableRemoveToolCameras"})}),"\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.a,{href:"#attachadditionalattachment",children:"attachAdditionalAttachment"})}),"\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.a,{href:"#attachimplementfrominfo",children:"attachImplementFromInfo"})}),"\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.a,{href:"#calculateattacherjointmoveupperloweralpha",children:"calculateAttacherJointMoveUpperLowerAlpha"})}),"\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.a,{href:"#callfunctiononallimplements",children:"callFunctionOnAllImplements"})}),"\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.a,{href:"#collectaiagentattachments",children:"collectAIAgentAttachments"})}),"\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.a,{href:"#consolecommandbottomarmwidth",children:"consoleCommandBottomArmWidth"})}),"\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.a,{href:"#createattachmentjoint",children:"createAttachmentJoint"})}),"\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.a,{href:"#deactivateattachments",children:"deactivateAttachments"})}),"\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.a,{href:"#deactivateattachmentslights",children:"deactivateAttachmentsLights"})}),"\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.a,{href:"#detachadditionalattachment",children:"detachAdditionalAttachment"})}),"\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.a,{href:"#detachattachedimplement",children:"detachAttachedImplement"})}),"\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.a,{href:"#detachimplement",children:"detachImplement"})}),"\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.a,{href:"#detachimplementbyobject",children:"detachImplementByObject"})}),"\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.a,{href:"#detachingispossible",children:"detachingIsPossible"})}),"\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.a,{href:"#dogroundheightnodecheck",children:"doGroundHeightNodeCheck"})}),"\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.a,{href:"#findvehicleinattachrange",children:"findVehicleInAttachRange"})}),"\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.a,{href:"#finishgroundheightnodecheck",children:"finishGroundHeightNodeCheck"})}),"\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.a,{href:"#getadditionalcomponentmass",children:"getAdditionalComponentMass"})}),"\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.a,{href:"#getairconsumerusage",children:"getAirConsumerUsage"})}),"\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.a,{href:"#getarecontrolledactionsallowed",children:"getAreControlledActionsAllowed"})}),"\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.a,{href:"#getattachedimplements",children:"getAttachedImplements"})}),"\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.a,{href:"#getattacherjointbyjointdescindex",children:"getAttacherJointByJointDescIndex"})}),"\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.a,{href:"#getattacherjointbynode",children:"getAttacherJointByNode"})}),"\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.a,{href:"#getattacherjointcompatibility",children:"getAttacherJointCompatibility"})}),"\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.a,{href:"#getattacherjointdescfromobject",children:"getAttacherJointDescFromObject"})}),"\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.a,{href:"#getattacherjointindexbynode",children:"getAttacherJointIndexByNode"})}),"\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.a,{href:"#getattacherjointindexfromimplementindex",children:"getAttacherJointIndexFromImplementIndex"})}),"\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.a,{href:"#getattacherjointindexfromobject",children:"getAttacherJointIndexFromObject"})}),"\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.a,{href:"#getattacherjoints",children:"getAttacherJoints"})}),"\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.a,{href:"#getcansteerattachable",children:"getCanSteerAttachable"})}),"\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.a,{href:"#getcantoggleattach",children:"getCanToggleAttach"})}),"\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.a,{href:"#getclosestlowerlinkcategoryindex",children:"getClosestLowerLinkCategoryIndex"})}),"\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.a,{href:"#getconnectionhoseconfigindex",children:"getConnectionHoseConfigIndex"})}),"\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.a,{href:"#getdirectionsnapangle",children:"getDirectionSnapAngle"})}),"\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.a,{href:"#getfilllevelinformation",children:"getFillLevelInformation"})}),"\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.a,{href:"#getfillunitsupportstooltype",children:"getFillUnitSupportsToolType"})}),"\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.a,{href:"#gethasobjectmounted",children:"getHasObjectMounted"})}),"\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.a,{href:"#getimplementbyjointdescindex",children:"getImplementByJointDescIndex"})}),"\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.a,{href:"#getimplementbyobject",children:"getImplementByObject"})}),"\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.a,{href:"#getimplementfromattacherjointindex",children:"getImplementFromAttacherJointIndex"})}),"\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.a,{href:"#getimplementindexbyjointdescindex",children:"getImplementIndexByJointDescIndex"})}),"\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.a,{href:"#getimplementindexbyobject",children:"getImplementIndexByObject"})}),"\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.a,{href:"#getisattacherjointcompatible",children:"getIsAttacherJointCompatible"})}),"\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.a,{href:"#getisattacherjointheightnodeactive",children:"getIsAttacherJointHeightNodeActive"})}),"\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.a,{href:"#getisattachingallowed",children:"getIsAttachingAllowed"})}),"\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.a,{href:"#getisautomaticshiftingallowed",children:"getIsAutomaticShiftingAllowed"})}),"\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.a,{href:"#getisconnectiontargetused",children:"getIsConnectionTargetUsed"})}),"\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.a,{href:"#getisdashboardgroupactive",children:"getIsDashboardGroupActive"})}),"\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.a,{href:"#getisfoldallowed",children:"getIsFoldAllowed"})}),"\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.a,{href:"#getishardattachallowed",children:"getIsHardAttachAllowed"})}),"\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.a,{href:"#getisreadyforautomatedtraintravel",children:"getIsReadyForAutomatedTrainTravel"})}),"\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.a,{href:"#getissmoothattachupdateallowed",children:"getIsSmoothAttachUpdateAllowed"})}),"\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.a,{href:"#getistipsideavailable",children:"getIsTipSideAvailable"})}),"\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.a,{href:"#getiswheelfoliagedestructionallowed",children:"getIsWheelFoliageDestructionAllowed"})}),"\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.a,{href:"#getjointmovedown",children:"getJointMoveDown"})}),"\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.a,{href:"#getobjectfromimplementindex",children:"getObjectFromImplementIndex"})}),"\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.a,{href:"#getpowertakeoffconfigindex",children:"getPowerTakeOffConfigIndex"})}),"\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.a,{href:"#getrequirespower",children:"getRequiresPower"})}),"\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.a,{href:"#getselectedimplement",children:"getSelectedImplement"})}),"\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.a,{href:"#getshowattachcontrolbaraction",children:"getShowAttachControlBarAction"})}),"\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.a,{href:"#gettotalmass",children:"getTotalMass"})}),"\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.a,{href:"#groundheightnodecheckcallback",children:"groundHeightNodeCheckCallback"})}),"\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.a,{href:"#handlelowerimplementbyattacherjointindex",children:"handleLowerImplementByAttacherJointIndex"})}),"\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.a,{href:"#handlelowerimplementevent",children:"handleLowerImplementEvent"})}),"\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.a,{href:"#hardattachimplement",children:"hardAttachImplement"})}),"\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.a,{href:"#harddetachimplement",children:"hardDetachImplement"})}),"\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.a,{href:"#initspecialization",children:"initSpecialization"})}),"\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.a,{href:"#isdetachallowed",children:"isDetachAllowed"})}),"\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.a,{href:"#loadattacherjointfromxml",children:"loadAttacherJointFromXML"})}),"\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.a,{href:"#loadattacherjointheightnode",children:"loadAttacherJointHeightNode"})}),"\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.a,{href:"#loadattachmentsfinished",children:"loadAttachmentsFinished"})}),"\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.a,{href:"#loaddashboardgroupfromxml",children:"loadDashboardGroupFromXML"})}),"\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.a,{href:"#loadfillunitfromxml",children:"loadFillUnitFromXML"})}),"\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.a,{href:"#loadhosetargetnode",children:"loadHoseTargetNode"})}),"\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.a,{href:"#loadtipside",children:"loadTipSide"})}),"\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.a,{href:"#onactivate",children:"onActivate"})}),"\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.a,{href:"#onattacherjointsvehicleloaded",children:"onAttacherJointsVehicleLoaded"})}),"\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.a,{href:"#onbeaconlightsvisibilitychanged",children:"onBeaconLightsVisibilityChanged"})}),"\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.a,{href:"#onbottomarmtoolbari3dloaded",children:"onBottomArmToolbarI3DLoaded"})}),"\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.a,{href:"#onbrake",children:"onBrake"})}),"\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.a,{href:"#onbrakelightsvisibilitychanged",children:"onBrakeLightsVisibilityChanged"})}),"\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.a,{href:"#ondeactivate",children:"onDeactivate"})}),"\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.a,{href:"#ondelete",children:"onDelete"})}),"\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.a,{href:"#onleavevehicle",children:"onLeaveVehicle"})}),"\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.a,{href:"#onlightstypesmaskchanged",children:"onLightsTypesMaskChanged"})}),"\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.a,{href:"#onload",children:"onLoad"})}),"\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.a,{href:"#onloadfinished",children:"onLoadFinished"})}),"\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.a,{href:"#onpostload",children:"onPostLoad"})}),"\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.a,{href:"#onpredelete",children:"onPreDelete"})}),"\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.a,{href:"#onpreload",children:"onPreLoad"})}),"\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.a,{href:"#onreadstream",children:"onReadStream"})}),"\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.a,{href:"#onregisteractionevents",children:"onRegisterActionEvents"})}),"\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.a,{href:"#onregisterdashboardvaluetypes",children:"onRegisterDashboardValueTypes"})}),"\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.a,{href:"#onreversedirectionchanged",children:"onReverseDirectionChanged"})}),"\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.a,{href:"#onreverselightsvisibilitychanged",children:"onReverseLightsVisibilityChanged"})}),"\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.a,{href:"#onstatechange",children:"onStateChange"})}),"\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.a,{href:"#onturnedoff",children:"onTurnedOff"})}),"\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.a,{href:"#onturnedon",children:"onTurnedOn"})}),"\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.a,{href:"#onturnlightstatechanged",children:"onTurnLightStateChanged"})}),"\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.a,{href:"#onupdate",children:"onUpdate"})}),"\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.a,{href:"#onupdateend",children:"onUpdateEnd"})}),"\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.a,{href:"#onupdateinterpolation",children:"onUpdateInterpolation"})}),"\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.a,{href:"#onupdatetick",children:"onUpdateTick"})}),"\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.a,{href:"#onwritestream",children:"onWriteStream"})}),"\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.a,{href:"#playattachsound",children:"playAttachSound"})}),"\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.a,{href:"#playdetachsound",children:"playDetachSound"})}),"\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.a,{href:"#postattachimplement",children:"postAttachImplement"})}),"\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.a,{href:"#prerequisitespresent",children:"prerequisitesPresent"})}),"\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.a,{href:"#raiseactive",children:"raiseActive"})}),"\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.a,{href:"#registeractionevents",children:"registerActionEvents"})}),"\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.a,{href:"#registerattacherjointxmlpaths",children:"registerAttacherJointXMLPaths"})}),"\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.a,{href:"#registereventlisteners",children:"registerEventListeners"})}),"\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.a,{href:"#registerevents",children:"registerEvents"})}),"\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.a,{href:"#registerfunctions",children:"registerFunctions"})}),"\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.a,{href:"#registerjointtype",children:"registerJointType"})}),"\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.a,{href:"#registeroverwrittenfunctions",children:"registerOverwrittenFunctions"})}),"\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.a,{href:"#registerselectableobjects",children:"registerSelectableObjects"})}),"\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.a,{href:"#registerselfloweringactionevent",children:"registerSelfLoweringActionEvent"})}),"\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.a,{href:"#removeactionevents",children:"removeActionEvents"})}),"\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.a,{href:"#removefromphysics",children:"removeFromPhysics"})}),"\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.a,{href:"#savetoxmlfile",children:"saveToXMLFile"})}),"\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.a,{href:"#setaivehicleobstaclestatedirty",children:"setAIVehicleObstacleStateDirty"})}),"\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.a,{href:"#setattacherjointbottomarmwidth",children:"setAttacherJointBottomArmWidth"})}),"\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.a,{href:"#setjointmovedown",children:"setJointMoveDown"})}),"\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.a,{href:"#setselectedimplementbyobject",children:"setSelectedImplementByObject"})}),"\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.a,{href:"#startattacherjointcombo",children:"startAttacherJointCombo"})}),"\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.a,{href:"#updateactionevents",children:"updateActionEvents"})}),"\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.a,{href:"#updateattacherjointgraphics",children:"updateAttacherJointGraphics"})}),"\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.a,{href:"#updateattacherjointlimits",children:"updateAttacherJointLimits"})}),"\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.a,{href:"#updateattacherjointrotation",children:"updateAttacherJointRotation"})}),"\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.a,{href:"#updateattacherjointrotationlimit",children:"updateAttacherJointRotationLimit"})}),"\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.a,{href:"#updateattacherjointrotationnodes",children:"updateAttacherJointRotationNodes"})}),"\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.a,{href:"#updateattacherjointsettingsbyobject",children:"updateAttacherJointSettingsByObject"})}),"\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.a,{href:"#updateattacherjointtranslationlimit",children:"updateAttacherJointTranslationLimit"})}),"\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.a,{href:"#updaterequiredtoplightsstate",children:"updateRequiredTopLightsState"})}),"\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.a,{href:"#updatevehiclesinattachrange",children:"updateVehiclesInAttachRange"})}),"\n"]}),"\n",(0,o.jsx)(n.h3,{id:"actioneventattach",children:"actionEventAttach"}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Description"})}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Definition"})}),"\n",(0,o.jsxs)(n.blockquote,{children:["\n",(0,o.jsx)(n.p,{children:"actionEventAttach()"}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,o.jsxs)(n.table,{children:[(0,o.jsx)(n.thead,{children:(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.th,{children:"any"}),(0,o.jsx)(n.th,{children:"self"})]})}),(0,o.jsxs)(n.tbody,{children:[(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:"any"}),(0,o.jsx)(n.td,{children:"actionName"})]}),(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:"any"}),(0,o.jsx)(n.td,{children:"inputValue"})]}),(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:"any"}),(0,o.jsx)(n.td,{children:"callbackState"})]}),(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:"any"}),(0,o.jsx)(n.td,{children:"isAnalog"})]})]})]}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Code"})}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-lua",children:"function AttacherJoints.actionEventAttach( self , actionName, inputValue, callbackState, isAnalog)\n    -- attach or detach something\n    local info = self.spec_attacherJoints.attachableInfo\n    if info.attachable ~ = nil then\n        -- attach\n        local attachAllowed, warning = info.attachable:isAttachAllowed( self:getActiveFarm(), info.attacherVehicle)\n        if attachAllowed then\n            if self.isServer then\n                self:attachImplementFromInfo(info)\n            else\n                    g_client:getServerConnection():sendEvent( VehicleAttachRequestEvent.new(info))\n                end\n            else\n                    if warning ~ = nil then\n                        g_currentMission:showBlinkingWarning(warning, 2000 )\n                    end\n                end\n            else\n                    -- detach\n                    local object = self:getSelectedVehicle()\n                    if object ~ = nil and object ~ = self and object.isDetachAllowed ~ = nil then\n                        local detachAllowed, warning, showWarning = object:isDetachAllowed()\n                        if detachAllowed then\n                            object:startDetachProcess()\n                        elseif showWarning = = nil or showWarning then\n                                g_currentMission:showBlinkingWarning(warning or self.spec_attacherJoints.texts.detachNotAllowed, 2000 )\n                            end\n                        end\n                    end\n                end\n\n"})}),"\n",(0,o.jsx)(n.h3,{id:"actioneventdetach",children:"actionEventDetach"}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Description"})}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Definition"})}),"\n",(0,o.jsxs)(n.blockquote,{children:["\n",(0,o.jsx)(n.p,{children:"actionEventDetach()"}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,o.jsxs)(n.table,{children:[(0,o.jsx)(n.thead,{children:(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.th,{children:"any"}),(0,o.jsx)(n.th,{children:"self"})]})}),(0,o.jsxs)(n.tbody,{children:[(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:"any"}),(0,o.jsx)(n.td,{children:"actionName"})]}),(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:"any"}),(0,o.jsx)(n.td,{children:"inputValue"})]}),(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:"any"}),(0,o.jsx)(n.td,{children:"callbackState"})]}),(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:"any"}),(0,o.jsx)(n.td,{children:"isAnalog"})]})]})]}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Code"})}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-lua",children:"function AttacherJoints.actionEventDetach( self , actionName, inputValue, callbackState, isAnalog)\n    -- detach\n    local object = self:getSelectedVehicle()\n    if object ~ = nil and object ~ = self and object.isDetachAllowed ~ = nil then\n        local detachAllowed, warning, showWarning = object:isDetachAllowed()\n        if detachAllowed then\n            object:startDetachProcess()\n        elseif showWarning = = nil or showWarning then\n                g_currentMission:showBlinkingWarning(warning or self.spec_attacherJoints.texts.detachNotAllowed, 2000 )\n            end\n        end\n    end\n\n"})}),"\n",(0,o.jsx)(n.h3,{id:"actioneventlowerallimplements",children:"actionEventLowerAllImplements"}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Description"})}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Definition"})}),"\n",(0,o.jsxs)(n.blockquote,{children:["\n",(0,o.jsx)(n.p,{children:"actionEventLowerAllImplements()"}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,o.jsxs)(n.table,{children:[(0,o.jsx)(n.thead,{children:(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.th,{children:"any"}),(0,o.jsx)(n.th,{children:"self"})]})}),(0,o.jsxs)(n.tbody,{children:[(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:"any"}),(0,o.jsx)(n.td,{children:"actionName"})]}),(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:"any"}),(0,o.jsx)(n.td,{children:"inputValue"})]}),(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:"any"}),(0,o.jsx)(n.td,{children:"callbackState"})]}),(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:"any"}),(0,o.jsx)(n.td,{children:"isAnalog"})]})]})]}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Code"})}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-lua",children:"function AttacherJoints.actionEventLowerAllImplements( self , actionName, inputValue, callbackState, isAnalog)\n    self:startAttacherJointCombo( true )\n\n    self.rootVehicle:raiseStateChange(VehicleStateChange.LOWER_ALL_IMPLEMENTS)\nend\n\n"})}),"\n",(0,o.jsx)(n.h3,{id:"actioneventlowerimplement",children:"actionEventLowerImplement"}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Description"})}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Definition"})}),"\n",(0,o.jsxs)(n.blockquote,{children:["\n",(0,o.jsx)(n.p,{children:"actionEventLowerImplement()"}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,o.jsxs)(n.table,{children:[(0,o.jsx)(n.thead,{children:(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.th,{children:"any"}),(0,o.jsx)(n.th,{children:"self"})]})}),(0,o.jsxs)(n.tbody,{children:[(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:"any"}),(0,o.jsx)(n.td,{children:"actionName"})]}),(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:"any"}),(0,o.jsx)(n.td,{children:"inputValue"})]}),(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:"any"}),(0,o.jsx)(n.td,{children:"callbackState"})]}),(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:"any"}),(0,o.jsx)(n.td,{children:"isAnalog"})]})]})]}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Code"})}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-lua",children:"function AttacherJoints.actionEventLowerImplement( self , actionName, inputValue, callbackState, isAnalog)\n    -- self is the implement object to lower, so we call the function on the attacher vehicle\n        if self.getAttacherVehicle ~ = nil then\n            self:getAttacherVehicle():handleLowerImplementEvent()\n        end\n    end\n\n"})}),"\n",(0,o.jsx)(n.h3,{id:"activateattachments",children:"activateAttachments"}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Description"})}),"\n",(0,o.jsxs)(n.blockquote,{children:["\n",(0,o.jsx)(n.p,{children:'Call "activate" on all attachments'}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Definition"})}),"\n",(0,o.jsxs)(n.blockquote,{children:["\n",(0,o.jsx)(n.p,{children:"activateAttachments()"}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Code"})}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-lua",children:"function AttacherJoints:activateAttachments()\n    local spec = self.spec_attacherJoints\n\n    for _,v in pairs(spec.attachedImplements) do\n        if v.object ~ = nil then\n            v.object:activate()\n        end\n    end\nend\n\n"})}),"\n",(0,o.jsx)(n.h3,{id:"addchildvehicles",children:"addChildVehicles"}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Description"})}),"\n",(0,o.jsxs)(n.blockquote,{children:["\n",(0,o.jsx)(n.p,{children:"Inserts all child vehicles into the given table"}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Definition"})}),"\n",(0,o.jsxs)(n.blockquote,{children:["\n",(0,o.jsx)(n.p,{children:"addChildVehicles(table vehicles, , )"}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,o.jsxs)(n.table,{children:[(0,o.jsx)(n.thead,{children:(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.th,{children:"table"}),(0,o.jsx)(n.th,{children:"vehicles"}),(0,o.jsx)(n.th,{children:"child vehicles table"})]})}),(0,o.jsxs)(n.tbody,{children:[(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:"any"}),(0,o.jsx)(n.td,{children:"vehicles"}),(0,o.jsx)(n.td,{})]}),(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:"any"}),(0,o.jsx)(n.td,{children:"rootVehicle"}),(0,o.jsx)(n.td,{})]})]})]}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Code"})}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-lua",children:"function AttacherJoints:addChildVehicles(superFunc, vehicles, rootVehicle)\n    local spec = self.spec_attacherJoints\n\n    for _, implement in pairs(spec.attachedImplements) do\n        local object = implement.object\n        if object ~ = nil and object.addChildVehicles ~ = nil then\n            object:addChildVehicles(vehicles, rootVehicle)\n        end\n    end\n\n    return superFunc( self , vehicles, rootVehicle)\nend\n\n"})}),"\n",(0,o.jsx)(n.h3,{id:"additionalattachmentloaded",children:"additionalAttachmentLoaded"}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Description"})}),"\n",(0,o.jsxs)(n.blockquote,{children:["\n",(0,o.jsx)(n.p,{children:"Called after the additional attachment was loaded"}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Definition"})}),"\n",(0,o.jsxs)(n.blockquote,{children:["\n",(0,o.jsx)(n.p,{children:"additionalAttachmentLoaded()"}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,o.jsxs)(n.table,{children:[(0,o.jsx)(n.thead,{children:(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.th,{children:"any"}),(0,o.jsx)(n.th,{children:"vehicles"})]})}),(0,o.jsxs)(n.tbody,{children:[(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:"any"}),(0,o.jsx)(n.td,{children:"vehicleLoadState"})]}),(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:"any"}),(0,o.jsx)(n.td,{children:"asyncCallbackArguments"})]})]})]}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Code"})}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-lua",children:"function AttacherJoints:additionalAttachmentLoaded(vehicles, vehicleLoadState, asyncCallbackArguments)\n    if vehicleLoadState ~ = VehicleLoadingState.OK then\n        Logging.warning( \"Failed to load additional attachment '%s'.\" , asyncCallbackArguments[ 6 ].xmlFilename)\n        return\n    end\n\n    local vehicle = vehicles[ 1 ]\n    if vehicle = = nil or vehicle.setIsAdditionalAttachment = = nil then\n        Logging.warning( \"Invalid additional attachment '%s'.\" , asyncCallbackArguments[ 6 ].xmlFilename)\n        return\n    end\n\n    local offset = { 0 , 0 , 0 }\n    if vehicle.getInputAttacherJoints ~ = nil then\n        local inputAttacherJoints = vehicle:getInputAttacherJoints()\n        if inputAttacherJoints[asyncCallbackArguments[ 2 ]] ~ = nil then\n            offset = inputAttacherJoints[asyncCallbackArguments[ 2 ]].jointOrigOffsetComponent\n        end\n    end\n\n    local x, y, z = localToWorld(asyncCallbackArguments[ 3 ], unpack(offset))\n    local dirX, _, dirZ = localDirectionToWorld(asyncCallbackArguments[ 3 ], 1 , 0 , 0 )\n    local yRot = MathUtil.getYRotationFromDirection(dirX, dirZ)\n    local terrainY = getTerrainHeightAtWorldPos(g_terrainNode, x, 0 , z)\n\n    vehicle:setAbsolutePosition(x, math.max(y, terrainY + 0.05 ), z, 0 , yRot, 0 )\n    self:attachImplement(vehicle, asyncCallbackArguments[ 2 ], asyncCallbackArguments[ 1 ], true , nil , nil , true , true )\n    vehicle:setIsAdditionalAttachment(asyncCallbackArguments[ 4 ], true )\n    if vehicle.addDirtAmount ~ = nil and asyncCallbackArguments[ 5 ] ~ = nil and asyncCallbackArguments[ 5 ].getDirtAmount ~ = nil then\n        vehicle:addDirtAmount(asyncCallbackArguments[ 5 ]:getDirtAmount())\n    end\n\n    self.rootVehicle:updateSelectableObjects()\n    self.rootVehicle:setSelectedVehicle(asyncCallbackArguments[ 5 ] or self )\nend\n\n"})}),"\n",(0,o.jsx)(n.h3,{id:"addtophysics",children:"addToPhysics"}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Description"})}),"\n",(0,o.jsxs)(n.blockquote,{children:["\n",(0,o.jsx)(n.p,{children:"Add to physics"}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Definition"})}),"\n",(0,o.jsxs)(n.blockquote,{children:["\n",(0,o.jsx)(n.p,{children:"addToPhysics()"}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,o.jsx)(n.table,{children:(0,o.jsx)(n.thead,{children:(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.th,{children:"any"}),(0,o.jsx)(n.th,{children:"superFunc"})]})})}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Return Values"})}),"\n\n\n\n\n\n\n\n\n",(0,o.jsx)(n.table,{children:(0,o.jsx)(n.thead,{children:(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.th,{children:"any"}),(0,o.jsx)(n.th,{children:"success"}),(0,o.jsx)(n.th,{children:"success"})]})})}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Code"})}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-lua",children:"function AttacherJoints:addToPhysics(superFunc)\n    if not superFunc( self ) then\n        return false\n    end\n\n    local spec = self.spec_attacherJoints\n    for _, implement in pairs(spec.attachedImplements) do\n        if not implement.object.spec_attachable.isHardAttached then\n            self:createAttachmentJoint(implement, true )\n        else\n                -- needs to be called on hard attached implements, as it automatically is added to physics as well\n                implement.object:addToPhysics()\n            end\n        end\n\n        return true\n    end\n\n"})}),"\n",(0,o.jsx)(n.h3,{id:"addvehicletoaiimplementlist",children:"addVehicleToAIImplementList"}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Description"})}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Definition"})}),"\n",(0,o.jsxs)(n.blockquote,{children:["\n",(0,o.jsx)(n.p,{children:"addVehicleToAIImplementList()"}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,o.jsxs)(n.table,{children:[(0,o.jsx)(n.thead,{children:(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.th,{children:"any"}),(0,o.jsx)(n.th,{children:"superFunc"})]})}),(0,o.jsx)(n.tbody,{children:(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:"any"}),(0,o.jsx)(n.td,{children:"list"})]})})]}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Code"})}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-lua",children:"function AttacherJoints:addVehicleToAIImplementList(superFunc, list)\n    superFunc( self , list)\n\n    for _, implement in pairs( self:getAttachedImplements()) do\n        local object = implement.object\n        if object ~ = nil and object.addVehicleToAIImplementList ~ = nil then\n            object:addVehicleToAIImplementList(list)\n        end\n    end\nend\n\n"})}),"\n",(0,o.jsx)(n.h3,{id:"attachableaddtoolcameras",children:"attachableAddToolCameras"}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Description"})}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Definition"})}),"\n",(0,o.jsxs)(n.blockquote,{children:["\n",(0,o.jsx)(n.p,{children:"attachableAddToolCameras()"}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,o.jsx)(n.table,{children:(0,o.jsx)(n.thead,{children:(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.th,{children:"any"}),(0,o.jsx)(n.th,{children:"superFunc"})]})})}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Code"})}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-lua",children:"function AttacherJoints:attachableAddToolCameras(superFunc)\n    local spec = self.spec_attacherJoints\n    superFunc( self )\n\n    for _,implement in pairs(spec.attachedImplements) do\n        local object = implement.object\n        if object ~ = nil and object.attachableAddToolCameras ~ = nil then\n            object:attachableAddToolCameras()\n        end\n    end\nend\n\n"})}),"\n",(0,o.jsx)(n.h3,{id:"attachableremovetoolcameras",children:"attachableRemoveToolCameras"}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Description"})}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Definition"})}),"\n",(0,o.jsxs)(n.blockquote,{children:["\n",(0,o.jsx)(n.p,{children:"attachableRemoveToolCameras()"}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,o.jsx)(n.table,{children:(0,o.jsx)(n.thead,{children:(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.th,{children:"any"}),(0,o.jsx)(n.th,{children:"superFunc"})]})})}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Code"})}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-lua",children:"function AttacherJoints:attachableRemoveToolCameras(superFunc)\n    local spec = self.spec_attacherJoints\n    superFunc( self )\n\n    for _,implement in pairs(spec.attachedImplements) do\n        local object = implement.object\n        if object ~ = nil and object.attachableRemoveToolCameras ~ = nil then\n            object:attachableRemoveToolCameras()\n        end\n    end\nend\n\n"})}),"\n",(0,o.jsx)(n.h3,{id:"attachadditionalattachment",children:"attachAdditionalAttachment"}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Description"})}),"\n",(0,o.jsxs)(n.blockquote,{children:["\n",(0,o.jsx)(n.p,{children:"Creates and attaches additional attachment"}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Definition"})}),"\n",(0,o.jsxs)(n.blockquote,{children:["\n",(0,o.jsx)(n.p,{children:"attachAdditionalAttachment()"}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,o.jsxs)(n.table,{children:[(0,o.jsx)(n.thead,{children:(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.th,{children:"any"}),(0,o.jsx)(n.th,{children:"jointDesc"})]})}),(0,o.jsxs)(n.tbody,{children:[(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:"any"}),(0,o.jsx)(n.td,{children:"inputJointDesc"})]}),(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:"any"}),(0,o.jsx)(n.td,{children:"object"})]})]})]}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Code"})}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-lua",children:"function AttacherJoints:attachAdditionalAttachment(jointDesc, inputJointDesc, object)\n    if jointDesc.attacherJointDirection ~ = nil and inputJointDesc.additionalAttachment.filename ~ = nil then\n        local storeItem = g_storeManager:getItemByXMLFilename(inputJointDesc.additionalAttachment.filename)\n        if storeItem ~ = nil then\n            local targetDirection = - jointDesc.attacherJointDirection\n            local attacherJoint, attacherJointIndex\n            for index, attacherJointToCheck in ipairs( self:getAttacherJoints()) do\n                if attacherJointToCheck.attacherJointDirection = = targetDirection then\n                    if attacherJointToCheck.jointIndex ~ = 0 then\n                        attacherJoint = nil\n                        break\n                    else\n                            if attacherJointToCheck.jointType = = inputJointDesc.additionalAttachment.jointType then\n                                attacherJoint = attacherJointToCheck\n                                attacherJointIndex = index\n                            end\n                        end\n                    end\n                end\n\n                if attacherJoint ~ = nil then\n                    local x, y, z = localToWorld(attacherJoint.jointTransform, 0 , 0 , 0 )\n                    local dirX, _, dirZ = localDirectionToWorld(attacherJoint.jointTransform, 1 , 0 , 0 )\n                    local yRot = MathUtil.getYRotationFromDirection(dirX, dirZ)\n\n                    jointDesc.additionalAttachment.currentAttacherJointIndex = attacherJointIndex\n                    local asyncCallbackArguments = { attacherJointIndex,\n                    inputJointDesc.additionalAttachment.inputAttacherJointIndex,\n                    attacherJoint.jointTransform,\n                    inputJointDesc.additionalAttachment.needsLowering,\n                    object,\n                    storeItem.xmlFilename }\n\n                    local data = VehicleLoadingData.new()\n                    data:setStoreItem(storeItem)\n                    data:setPosition(x, y, z)\n                    data:setRotation( 0 , yRot, 0 )\n                    data:setPropertyState(VehiclePropertyState.NONE)\n                    data:setOwnerFarmId( self:getActiveFarm())\n\n                    data:load( AttacherJoints.additionalAttachmentLoaded, self , asyncCallbackArguments)\n                end\n            end\n        end\n    end\n\n"})}),"\n",(0,o.jsx)(n.h3,{id:"attachimplementfrominfo",children:"attachImplementFromInfo"}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Description"})}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Definition"})}),"\n",(0,o.jsxs)(n.blockquote,{children:["\n",(0,o.jsx)(n.p,{children:"attachImplementFromInfo()"}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,o.jsx)(n.table,{children:(0,o.jsx)(n.thead,{children:(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.th,{children:"any"}),(0,o.jsx)(n.th,{children:"info"})]})})}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Code"})}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-lua",children:"function AttacherJoints:attachImplementFromInfo(info)\n    if info.attachable ~ = nil then\n        local attacherJoints = info.attacherVehicle.spec_attacherJoints.attacherJoints\n        if attacherJoints[info.attacherVehicleJointDescIndex].jointIndex = = 0 then\n            if info.attachable:getActiveInputAttacherJointDescIndex() ~ = nil then\n                if info.attachable:getAllowMultipleAttachments() then\n                    info.attachable:resolveMultipleAttachments()\n                else\n                        return false\n                    end\n                end\n\n                -- do not allow multiple implements in the same direction for mobile\n                    if GS_IS_MOBILE_VERSION then\n                        local attacherJointDirection = attacherJoints[info.attacherVehicleJointDescIndex].attacherJointDirection\n                        if attacherJointDirection ~ = nil then\n                            local attachedImplements = info.attacherVehicle:getAttachedImplements()\n                            for i = 1 , #attachedImplements do\n                                local jointDesc = attacherJoints[attachedImplements[i].jointDescIndex]\n\n                                if attacherJointDirection = = jointDesc.attacherJointDirection then\n                                    return false\n                                end\n                            end\n                        end\n                    end\n\n                    info.attacherVehicle:attachImplement(info.attachable, info.attachableJointDescIndex, info.attacherVehicleJointDescIndex)\n                    return true\n                end\n            end\n\n            return false\n        end\n\n"})}),"\n",(0,o.jsx)(n.h3,{id:"calculateattacherjointmoveupperloweralpha",children:"calculateAttacherJointMoveUpperLowerAlpha"}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Description"})}),"\n",(0,o.jsxs)(n.blockquote,{children:["\n",(0,o.jsx)(n.p,{children:"Calculate move upper and lower alpha of attacher joint"}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Definition"})}),"\n",(0,o.jsxs)(n.blockquote,{children:["\n",(0,o.jsx)(n.p,{children:"calculateAttacherJointMoveUpperLowerAlpha(table jointDesc, table object, boolean initial)"}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,o.jsxs)(n.table,{children:[(0,o.jsx)(n.thead,{children:(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.th,{children:"table"}),(0,o.jsx)(n.th,{children:"jointDesc"}),(0,o.jsx)(n.th,{children:"joint desc of used attacher"})]})}),(0,o.jsxs)(n.tbody,{children:[(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:"table"}),(0,o.jsx)(n.td,{children:"object"}),(0,o.jsx)(n.td,{children:"object of attached vehicle"})]}),(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:"boolean"}),(0,o.jsx)(n.td,{children:"initial"}),(0,o.jsx)(n.td,{children:"initial call to reset"})]})]})]}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Code"})}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-lua",children:"function AttacherJoints:calculateAttacherJointMoveUpperLowerAlpha(jointDesc, object, initial)\n    local objectAttacherJoint = object.spec_attachable.attacherJoint\n\n    if jointDesc.allowsLowering then\n        local lowerDistanceToGround = jointDesc.lowerDistanceToGround\n        local upperDistanceToGround = jointDesc.upperDistanceToGround\n\n        local upperAlpha\n        local lowerAlpha\n\n        if #objectAttacherJoint.heightNodes > 0 and jointDesc.rotationNode ~ = nil then\n            local checkData = self.spec_attacherJoints.groundHeightNodeCheckData\n            if initial then\n                checkData.heightNodes = objectAttacherJoint.heightNodes\n                checkData.jointDesc = jointDesc\n                checkData.objectAttacherJoint = objectAttacherJoint\n                checkData.object = object\n                checkData.index = - 1\n\n                lowerDistanceToGround = jointDesc.lowerDistanceToGround\n                upperDistanceToGround = jointDesc.upperDistanceToGround\n\n                for i = 1 , #objectAttacherJoint.heightNodes do\n                    local heightNode = objectAttacherJoint.heightNodes[i]\n                    local offX, offY, offZ = localToLocal(heightNode.node, heightNode.attacherJointNode, 0 , 0 , 0 )\n\n                    self:updateAttacherJointRotationNodes(jointDesc, 1 )\n                    setRotation(jointDesc.jointTransform, unpack(jointDesc.jointOrigRot))\n                    local _, y, _ = localToLocal(jointDesc.jointTransform, jointDesc.rootNode, 0 , 0 , 0 )\n                    local delta = jointDesc.lowerDistanceToGround - y\n                    local _, hy, _ = localToLocal(jointDesc.jointTransform, jointDesc.rootNode, offX, offY, offZ)\n                    lowerDistanceToGround = hy + delta\n\n                    self:updateAttacherJointRotationNodes(jointDesc, 0 )\n                    _, y, _ = localToLocal(jointDesc.jointTransform, jointDesc.rootNode, 0 , 0 , 0 )\n                    delta = jointDesc.upperDistanceToGround - y\n                    _, hy, _ = localToLocal(jointDesc.jointTransform, jointDesc.rootNode, offX, offY, offZ)\n                    upperDistanceToGround = hy + delta\n                end\n            else\n                    if (jointDesc.moveAlpha or 0 ) > 0 then\n                        if checkData.index = = - 1 then\n                            checkData.index = 1\n\n                            checkData.minDistance = math.huge\n                            checkData.hit = false\n                            self:doGroundHeightNodeCheck()\n                        end\n\n                        if checkData.isDirty then\n                            checkData.isDirty = false\n                            self:doGroundHeightNodeCheck()\n                        end\n\n                        if jointDesc.upperAlpha ~ = nil and checkData.upperAlpha ~ = nil then\n                            upperAlpha = jointDesc.upperAlpha * 0.9 + checkData.upperAlpha * 0.1\n                            lowerAlpha = jointDesc.lowerAlpha * 0.9 + checkData.lowerAlpha * 0.1\n                        else\n                                upperAlpha = checkData.upperAlpha\n                                lowerAlpha = checkData.lowerAlpha\n                            end\n                        else\n                                upperAlpha = jointDesc.upperAlpha\n                                lowerAlpha = jointDesc.lowerAlpha\n                            end\n                        end\n                    end\n\n                    if upperDistanceToGround = = lowerDistanceToGround then\n                        upperAlpha = upperAlpha or 1\n                        lowerAlpha = lowerAlpha or 1\n                    else\n                            upperAlpha = upperAlpha or math.clamp((objectAttacherJoint.upperDistanceToGround - upperDistanceToGround) / (lowerDistanceToGround - upperDistanceToGround), 0 , 1 )\n                            lowerAlpha = lowerAlpha or math.clamp((objectAttacherJoint.lowerDistanceToGround - upperDistanceToGround) / (lowerDistanceToGround - upperDistanceToGround), 0 , 1 )\n                        end\n\n                        if initial then\n                            local checkData = self.spec_attacherJoints.groundHeightNodeCheckData\n                            checkData.upperAlpha = upperAlpha\n                            checkData.lowerAlpha = lowerAlpha\n                        end\n\n                        if objectAttacherJoint.allowsLowering and jointDesc.allowsLowering then\n                            return upperAlpha, lowerAlpha\n                        else\n                                if objectAttacherJoint.isDefaultLowered then\n                                    return lowerAlpha, lowerAlpha\n                                else\n                                        return upperAlpha, upperAlpha\n                                    end\n                                end\n                            end\n\n                            if objectAttacherJoint.isDefaultLowered then\n                                return 1 , 1\n                            else\n                                    return 0 , 0\n                                end\n                            end\n\n"})}),"\n",(0,o.jsx)(n.h3,{id:"callfunctiononallimplements",children:"callFunctionOnAllImplements"}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Description"})}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Definition"})}),"\n",(0,o.jsxs)(n.blockquote,{children:["\n",(0,o.jsx)(n.p,{children:"callFunctionOnAllImplements()"}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,o.jsxs)(n.table,{children:[(0,o.jsx)(n.thead,{children:(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.th,{children:"any"}),(0,o.jsx)(n.th,{children:"functionName"})]})}),(0,o.jsx)(n.tbody,{children:(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:"any"}),(0,o.jsx)(n.td,{children:"..."})]})})]}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Code"})}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-lua",children:"function AttacherJoints:callFunctionOnAllImplements(functionName, .. .)\n    for _, implement in pairs( self:getAttachedImplements()) do\n        local vehicle = implement.object\n        if vehicle ~ = nil then\n            if vehicle[functionName] ~ = nil then\n                vehicle[functionName](vehicle, .. .)\n            end\n        end\n    end\nend\n\n"})}),"\n",(0,o.jsx)(n.h3,{id:"collectaiagentattachments",children:"collectAIAgentAttachments"}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Description"})}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Definition"})}),"\n",(0,o.jsxs)(n.blockquote,{children:["\n",(0,o.jsx)(n.p,{children:"collectAIAgentAttachments()"}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,o.jsxs)(n.table,{children:[(0,o.jsx)(n.thead,{children:(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.th,{children:"any"}),(0,o.jsx)(n.th,{children:"superFunc"})]})}),(0,o.jsx)(n.tbody,{children:(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:"any"}),(0,o.jsx)(n.td,{children:"aiDrivableVehicle"})]})})]}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Code"})}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-lua",children:"function AttacherJoints:collectAIAgentAttachments(superFunc, aiDrivableVehicle)\n    superFunc( self , aiDrivableVehicle)\n\n    for _, implement in pairs( self:getAttachedImplements()) do\n        local object = implement.object\n        if object ~ = nil and object.collectAIAgentAttachments ~ = nil then\n            object:collectAIAgentAttachments(aiDrivableVehicle)\n            aiDrivableVehicle:startNewAIAgentAttachmentChain()\n        end\n    end\nend\n\n"})}),"\n",(0,o.jsx)(n.h3,{id:"consolecommandbottomarmwidth",children:"consoleCommandBottomArmWidth"}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Description"})}),"\n",(0,o.jsxs)(n.blockquote,{children:["\n",(0,o.jsx)(n.p,{children:"Sets the width of the bottom arm to a certain category width"}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Definition"})}),"\n",(0,o.jsxs)(n.blockquote,{children:["\n",(0,o.jsx)(n.p,{children:"consoleCommandBottomArmWidth()"}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,o.jsxs)(n.table,{children:[(0,o.jsx)(n.thead,{children:(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.th,{children:"any"}),(0,o.jsx)(n.th,{children:"_"})]})}),(0,o.jsxs)(n.tbody,{children:[(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:"any"}),(0,o.jsx)(n.td,{children:"category"})]}),(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:"any"}),(0,o.jsx)(n.td,{children:"width"})]})]})]}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Code"})}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-lua",children:'function AttacherJoints.consoleCommandBottomArmWidth(_, category, width)\n    if width ~ = nil then\n        width = tonumber(width) or AttacherJoints.LOWER_LINK_WIDTH_BY_CATEGORY[ 2 ]\n    else\n            width = AttacherJoints.LOWER_LINK_WIDTH_BY_CATEGORY[ tonumber(category) or 2 ]\n        end\n\n        Logging.info( "Set bottom arm width to %.3f m. (Category %d)" , width, AttacherJoints.getClosestLowerLinkCategoryIndex(width))\n\n        if g_currentMission ~ = nil and g_localPlayer:getCurrentVehicle() ~ = nil then\n            for i, vehicle in ipairs(g_localPlayer:getCurrentVehicle().childVehicles) do\n                local spec = vehicle.spec_attacherJoints\n                if spec ~ = nil then\n                    for jointDescIndex, _ in ipairs(spec.attacherJoints) do\n                        vehicle:setAttacherJointBottomArmWidth(jointDescIndex, width)\n                    end\n                end\n            end\n        end\n    end\n\n'})}),"\n",(0,o.jsx)(n.h3,{id:"createattachmentjoint",children:"createAttachmentJoint"}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Description"})}),"\n",(0,o.jsxs)(n.blockquote,{children:["\n",(0,o.jsx)(n.p,{children:"Create attacher joint between vehicle and implement"}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Definition"})}),"\n",(0,o.jsxs)(n.blockquote,{children:["\n",(0,o.jsx)(n.p,{children:"createAttachmentJoint(table implement, boolean noSmoothAttach)"}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,o.jsxs)(n.table,{children:[(0,o.jsx)(n.thead,{children:(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.th,{children:"table"}),(0,o.jsx)(n.th,{children:"implement"}),(0,o.jsx)(n.th,{children:"implement to attach"})]})}),(0,o.jsx)(n.tbody,{children:(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:"boolean"}),(0,o.jsx)(n.td,{children:"noSmoothAttach"}),(0,o.jsx)(n.td,{children:"dont use smooth attach"})]})})]}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Code"})}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-lua",children:"function AttacherJoints:createAttachmentJoint(implement, noSmoothAttach)\n\n    local spec = self.spec_attacherJoints\n    local jointDesc = spec.attacherJoints[implement.jointDescIndex]\n    local objectAttacherJoint = implement.object.spec_attachable.inputAttacherJoints[implement.inputJointDescIndex]\n\n    if self.isServer and objectAttacherJoint ~ = nil then\n        if (getRigidBodyType(jointDesc.rootNode) ~ = RigidBodyType.DYNAMIC and getRigidBodyType(jointDesc.rootNode) ~ = RigidBodyType.KINEMATIC)\n            or(getRigidBodyType(objectAttacherJoint.rootNode) ~ = RigidBodyType.DYNAMIC and getRigidBodyType(objectAttacherJoint.rootNode) ~ = RigidBodyType.KINEMATIC) then\n            return\n        end\n\n        -- root vehicle can be different, if we are hard attached\n            local rootVehicle = g_currentMission:getNodeObject(jointDesc.rootNode) or self\n            if not rootVehicle.isAddedToPhysics or not implement.object.isAddedToPhysics then\n                return\n            end\n\n            local xNew = jointDesc.jointOrigTrans[ 1 ] + jointDesc.jointPositionOffset[ 1 ]\n            local yNew = jointDesc.jointOrigTrans[ 2 ] + jointDesc.jointPositionOffset[ 2 ]\n            local zNew = jointDesc.jointOrigTrans[ 3 ] + jointDesc.jointPositionOffset[ 3 ]\n\n            local rx, ry, rz = getRotation(jointDesc.jointTransform)\n\n            -- restore original joint position for worldToLocal operation(in case the vehicle was not completely detached and just remove from physics)\n                setTranslation(jointDesc.jointTransform, jointDesc.jointOrigTrans[ 1 ], jointDesc.jointOrigTrans[ 2 ], jointDesc.jointOrigTrans[ 3 ])\n                setRotation(jointDesc.jointTransform, jointDesc.jointOrigRot[ 1 ], jointDesc.jointOrigRot[ 2 ], jointDesc.jointOrigRot[ 3 ])\n\n                -- transform offset position to world coord and to jointTransform coord to get position offset dependend on angle and position\n                local x, y, z = localToWorld(getParent(jointDesc.jointTransform), xNew, yNew, zNew)\n                local x1, y1, z1 = worldToLocal(jointDesc.jointTransform, x, y, z)\n\n                -- move jointTransform to offset pos\n                setTranslation(jointDesc.jointTransform, xNew, yNew, zNew)\n\n                -- reapply the rotation that was already calculated by updateAttacherJointRotation before\n                setRotation(jointDesc.jointTransform, rx, ry, rz)\n\n                -- transform it to implement position and angle\n                x, y, z = localToWorld(objectAttacherJoint.node, x1, y1, z1)\n                local x2, y2, z2 = worldToLocal(getParent(objectAttacherJoint.node), x, y, z)\n\n                setTranslation(objectAttacherJoint.node, x2, y2, z2)\n\n                local constr = JointConstructor.new()\n                constr:setActors(jointDesc.rootNode, objectAttacherJoint.rootNode)\n                constr:setJointTransforms(jointDesc.jointTransform, objectAttacherJoint.node)\n                --constr:setBreakable(20, 10)\n\n                implement.jointRotLimit = { }\n                implement.jointTransLimit = { }\n\n                implement.lowerRotLimit = { }\n                implement.lowerTransLimit = { }\n\n                implement.upperRotLimit = { }\n                implement.upperTransLimit = { }\n\n                if noSmoothAttach = = nil or not noSmoothAttach then\n                    local _\n                    local dx,dy,dz = localToLocal(objectAttacherJoint.node, jointDesc.jointTransform, 0 , 0 , 0 )\n\n                    local dirX,dirY,dirZ = localDirectionToLocal(objectAttacherJoint.node, jointDesc.jointTransform, 0 , 1 , 0 )\n                    local rX = math.atan2(dirZ,dirY)\n\n                    dirX,_,dirZ = localDirectionToLocal(objectAttacherJoint.node, jointDesc.jointTransform, 0 , 0 , 1 )\n                    local rY = math.atan2(dirX,dirZ)\n\n                    dirX,dirY,_ = localDirectionToLocal(objectAttacherJoint.node, jointDesc.jointTransform, 1 , 0 , 0 )\n                    local rZ = math.atan2(dirY,dirX)\n\n                    local smoothAttachTime = objectAttacherJoint.smoothAttachTime or AttacherJoints.SMOOTH_ATTACH_TIME\n\n                    implement.attachingTransLimit = { math.abs(dx), math.abs(dy), math.abs(dz) }\n                    implement.attachingRotLimit = { math.abs(rX), math.abs(rY), math.abs(rZ) }\n                    implement.attachingTransLimitSpeed = { }\n                    implement.attachingRotLimitSpeed = { }\n                    for i = 1 , 3 do\n                        implement.attachingTransLimitSpeed[i] = implement.attachingTransLimit[i] / smoothAttachTime\n                        implement.attachingRotLimitSpeed[i] = implement.attachingRotLimit[i] / smoothAttachTime\n                    end\n                    implement.attachingIsInProgress = true\n                else\n                        implement.attachingTransLimit = { 0 , 0 , 0 }\n                        implement.attachingRotLimit = { 0 , 0 , 0 }\n                    end\n\n                    implement.rotLimitThreshold = objectAttacherJoint.rotLimitThreshold or 0\n                    implement.transLimitThreshold = objectAttacherJoint.transLimitThreshold or 0\n\n                    for i = 1 , 3 do\n                        local rotLimit, transLimit = AttacherJoints.updateAttacherJointLimits(implement, jointDesc, objectAttacherJoint, i)\n\n                        local limitRot = rotLimit\n                        local limitTrans = transLimit\n                        if noSmoothAttach = = nil or not noSmoothAttach then\n                            limitRot = math.max(rotLimit, implement.attachingRotLimit[i])\n                            limitTrans = math.max(transLimit, implement.attachingTransLimit[i])\n                        end\n\n                        local rotLimitDown, rotLimitUp = - limitRot, limitRot\n                        if i = = 3 then\n                            if jointDesc.lockDownRotLimit then\n                                rotLimitDown = math.min( - implement.attachingRotLimit[i], 0 )\n                            end\n                            if jointDesc.lockUpRotLimit then\n                                rotLimitUp = math.max(implement.attachingRotLimit[i], 0 )\n                            end\n                        end\n                        constr:setRotationLimit(i - 1 , rotLimitDown, rotLimitUp)\n                        implement.jointRotLimit[i] = limitRot\n\n                        local transLimitDown, transLimitUp = - limitTrans, limitTrans\n                        if i = = 2 then\n                            if jointDesc.lockDownTransLimit then\n                                transLimitDown = math.min( - implement.attachingTransLimit[i], 0 )\n                            end\n                            if jointDesc.lockUpTransLimit then\n                                transLimitUp = math.max(implement.attachingTransLimit[i], 0 )\n                            end\n                        end\n                        constr:setTranslationLimit(i - 1 , true , transLimitDown, transLimitUp)\n                        implement.jointTransLimit[i] = limitTrans\n                    end\n\n                    if jointDesc.enableCollision then\n                        constr:setEnableCollision( true )\n                    else\n                            for _, component in pairs( self.components) do\n                                if component.node ~ = jointDesc.rootNodeBackup and not component.collideWithAttachables then\n                                    setPairCollision(component.node, objectAttacherJoint.rootNode, false )\n                                end\n                            end\n                        end\n\n                        local springX = math.max(jointDesc.rotLimitSpring[ 1 ], objectAttacherJoint.rotLimitSpring[ 1 ])\n                        local springY = math.max(jointDesc.rotLimitSpring[ 2 ], objectAttacherJoint.rotLimitSpring[ 2 ])\n                        local springZ = math.max(jointDesc.rotLimitSpring[ 3 ], objectAttacherJoint.rotLimitSpring[ 3 ])\n                        local dampingX = math.max(jointDesc.rotLimitDamping[ 1 ], objectAttacherJoint.rotLimitDamping[ 1 ])\n                        local dampingY = math.max(jointDesc.rotLimitDamping[ 2 ], objectAttacherJoint.rotLimitDamping[ 2 ])\n                        local dampingZ = math.max(jointDesc.rotLimitDamping[ 3 ], objectAttacherJoint.rotLimitDamping[ 3 ])\n                        local forceLimitX = Utils.getMaxJointForceLimit(jointDesc.rotLimitForceLimit[ 1 ], objectAttacherJoint.rotLimitForceLimit[ 1 ])\n                        local forceLimitY = Utils.getMaxJointForceLimit(jointDesc.rotLimitForceLimit[ 2 ], objectAttacherJoint.rotLimitForceLimit[ 2 ])\n                        local forceLimitZ = Utils.getMaxJointForceLimit(jointDesc.rotLimitForceLimit[ 3 ], objectAttacherJoint.rotLimitForceLimit[ 3 ])\n                        constr:setRotationLimitSpring(springX, dampingX, springY, dampingY, springZ, dampingZ)\n                        constr:setRotationLimitForceLimit(forceLimitX, forceLimitY, forceLimitZ)\n\n                        springX = math.max(jointDesc.transLimitSpring[ 1 ], objectAttacherJoint.transLimitSpring[ 1 ])\n                        springY = math.max(jointDesc.transLimitSpring[ 2 ], objectAttacherJoint.transLimitSpring[ 2 ])\n                        springZ = math.max(jointDesc.transLimitSpring[ 3 ], objectAttacherJoint.transLimitSpring[ 3 ])\n                        dampingX = math.max(jointDesc.transLimitDamping[ 1 ], objectAttacherJoint.transLimitDamping[ 1 ])\n                        dampingY = math.max(jointDesc.transLimitDamping[ 2 ], objectAttacherJoint.transLimitDamping[ 2 ])\n                        dampingZ = math.max(jointDesc.transLimitDamping[ 3 ], objectAttacherJoint.transLimitDamping[ 3 ])\n                        forceLimitX = Utils.getMaxJointForceLimit(jointDesc.transLimitForceLimit[ 1 ], objectAttacherJoint.transLimitForceLimit[ 1 ])\n                        forceLimitY = Utils.getMaxJointForceLimit(jointDesc.transLimitForceLimit[ 2 ], objectAttacherJoint.transLimitForceLimit[ 2 ])\n                        forceLimitZ = Utils.getMaxJointForceLimit(jointDesc.transLimitForceLimit[ 3 ], objectAttacherJoint.transLimitForceLimit[ 3 ])\n                        constr:setTranslationLimitSpring(springX, dampingX, springY, dampingY, springZ, dampingZ)\n                        constr:setTranslationLimitForceLimit(forceLimitX, forceLimitY, forceLimitZ)\n\n                        jointDesc.jointIndex = constr:finalize()\n\n                        -- restore implement attacher joint position(to ensure correct bottom arm alignment)\n                        setTranslation(objectAttacherJoint.node, unpack(objectAttacherJoint.jointOrigTrans))\n                    else\n                            -- set joint index to '1' on client side, so we can check if something is attached\n                                jointDesc.jointIndex = 1\n                            end\n                        end\n\n"})}),"\n",(0,o.jsx)(n.h3,{id:"deactivateattachments",children:"deactivateAttachments"}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Description"})}),"\n",(0,o.jsxs)(n.blockquote,{children:["\n",(0,o.jsx)(n.p,{children:'Call "deactivate" on all attachments'}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Definition"})}),"\n",(0,o.jsxs)(n.blockquote,{children:["\n",(0,o.jsx)(n.p,{children:"deactivateAttachments()"}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Code"})}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-lua",children:"function AttacherJoints:deactivateAttachments()\n    local spec = self.spec_attacherJoints\n\n    for _,v in pairs(spec.attachedImplements) do\n        if v.object ~ = nil then\n            v.object:deactivate()\n        end\n    end\nend\n\n"})}),"\n",(0,o.jsx)(n.h3,{id:"deactivateattachmentslights",children:"deactivateAttachmentsLights"}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Description"})}),"\n",(0,o.jsxs)(n.blockquote,{children:["\n",(0,o.jsx)(n.p,{children:'Call "deactivateLights" on all attachments'}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Definition"})}),"\n",(0,o.jsxs)(n.blockquote,{children:["\n",(0,o.jsx)(n.p,{children:"deactivateAttachmentsLights()"}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Code"})}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-lua",children:"function AttacherJoints:deactivateAttachmentsLights()\n    local spec = self.spec_attacherJoints\n\n    for _,v in pairs(spec.attachedImplements) do\n        if v.object ~ = nil and v.object.deactivateLights ~ = nil then\n            v.object:deactivateLights()\n        end\n    end\nend\n\n"})}),"\n",(0,o.jsx)(n.h3,{id:"detachadditionalattachment",children:"detachAdditionalAttachment"}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Description"})}),"\n",(0,o.jsxs)(n.blockquote,{children:["\n",(0,o.jsx)(n.p,{children:"Creates and attaches additional attachment"}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Definition"})}),"\n",(0,o.jsxs)(n.blockquote,{children:["\n",(0,o.jsx)(n.p,{children:"detachAdditionalAttachment()"}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,o.jsxs)(n.table,{children:[(0,o.jsx)(n.thead,{children:(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.th,{children:"any"}),(0,o.jsx)(n.th,{children:"jointDesc"})]})}),(0,o.jsx)(n.tbody,{children:(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:"any"}),(0,o.jsx)(n.td,{children:"inputJointDesc"})]})})]}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Code"})}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-lua",children:"function AttacherJoints:detachAdditionalAttachment(jointDesc, inputJointDesc)\n    if jointDesc.additionalAttachment.currentAttacherJointIndex ~ = nil and inputJointDesc.additionalAttachment.filename ~ = nil then\n        local implement = self:getImplementByJointDescIndex(jointDesc.additionalAttachment.currentAttacherJointIndex)\n        if implement ~ = nil then\n            if implement.object:getIsAdditionalAttachment() then\n                self:detachImplementByObject(implement.object)\n\n                -- on the exit the vehicle will be removed by BaseMission.delete\n                if not g_currentMission.isExitingGame then\n                    implement.object:delete()\n                end\n            end\n        end\n    end\nend\n\n"})}),"\n",(0,o.jsx)(n.h3,{id:"detachattachedimplement",children:"detachAttachedImplement"}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Description"})}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Definition"})}),"\n",(0,o.jsxs)(n.blockquote,{children:["\n",(0,o.jsx)(n.p,{children:"detachAttachedImplement()"}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Code"})}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-lua",children:"function AttacherJoints:detachAttachedImplement()\n    if self:getCanToggleAttach() then\n        AttacherJoints.actionEventAttach( self )\n    end\nend\n\n"})}),"\n",(0,o.jsx)(n.h3,{id:"detachimplement",children:"detachImplement"}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Description"})}),"\n",(0,o.jsxs)(n.blockquote,{children:["\n",(0,o.jsx)(n.p,{children:"Detach implement"}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Definition"})}),"\n",(0,o.jsxs)(n.blockquote,{children:["\n",(0,o.jsx)(n.p,{children:"detachImplement(integer implementIndex, boolean noEventSend)"}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,o.jsxs)(n.table,{children:[(0,o.jsx)(n.thead,{children:(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.th,{children:"integer"}),(0,o.jsx)(n.th,{children:"implementIndex"}),(0,o.jsx)(n.th,{children:"index of implement in self.attachedImplements"})]})}),(0,o.jsx)(n.tbody,{children:(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:"boolean"}),(0,o.jsx)(n.td,{children:"noEventSend"}),(0,o.jsx)(n.td,{children:"no event send"})]})})]}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Return Values"})}),"\n\n\n\n\n\n\n\n\n",(0,o.jsx)(n.table,{children:(0,o.jsx)(n.thead,{children:(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.th,{children:"boolean"}),(0,o.jsx)(n.th,{children:"success"}),(0,o.jsx)(n.th,{children:"success"})]})})}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Code"})}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-lua",children:'function AttacherJoints:detachImplement(implementIndex, noEventSend)\n    local spec = self.spec_attacherJoints\n\n    if noEventSend = = nil or noEventSend = = false then\n        if g_server ~ = nil then\n            g_server:broadcastEvent( VehicleDetachEvent.new( self , spec.attachedImplements[implementIndex].object), nil , nil , self )\n        else\n                -- Send detach request to server and return\n                local implement = spec.attachedImplements[implementIndex]\n                if implement.object ~ = nil then\n                    g_client:getServerConnection():sendEvent( VehicleDetachEvent.new( self , implement.object))\n                end\n                return\n            end\n        end\n\n        local implement = spec.attachedImplements[implementIndex]\n        implement.isDetaching = true\n\n        SpecializationUtil.raiseEvent( self , "onPreDetachImplement" , implement)\n        implement.object:preDetach( self , implement)\n\n        local jointDesc\n        if implement.object ~ = nil then\n            jointDesc = spec.attacherJoints[implement.jointDescIndex]\n            if jointDesc.transNode ~ = nil then\n                setTranslation(jointDesc.transNode, unpack(jointDesc.transNodeOrgTrans))\n\n                if jointDesc.transNodeDependentBottomArm ~ = nil then\n                    local bottomArmJointDesc = jointDesc.transNodeDependentBottomArmAttacherJoint\n                    local interpolator = ValueInterpolator.new(bottomArmJointDesc.bottomArm.interpolatorKey, bottomArmJointDesc.bottomArm.interpolatorGet, bottomArmJointDesc.bottomArm.interpolatorSet, { bottomArmJointDesc.bottomArm.rotX, bottomArmJointDesc.bottomArm.rotY, bottomArmJointDesc.bottomArm.rotZ } , AttacherJoints.SMOOTH_ATTACH_TIME * 2 )\n                    if interpolator ~ = nil then\n                        interpolator:setDeleteListenerObject( self )\n                        interpolator:setFinishedFunc(bottomArmJointDesc.bottomArm.interpolatorFinished, bottomArmJointDesc.bottomArm)\n                        bottomArmJointDesc.bottomArm.bottomArmInterpolating = true\n                    end\n                end\n            end\n            if not implement.object.spec_attachable.isHardAttached then\n                if self.isServer then\n                    if jointDesc.jointIndex ~ = 0 then\n                        removeJoint(jointDesc.jointIndex)\n                    end\n\n                    if not jointDesc.enableCollision then\n                        for _, component in pairs( self.components) do\n                            if component.node ~ = jointDesc.rootNodeBackup and not component.collideWithAttachables then\n                                local attacherJoint = implement.object:getActiveInputAttacherJoint()\n                                setPairCollision(component.node, attacherJoint.rootNode, true )\n                            end\n                        end\n                    end\n                end\n            end\n            jointDesc.jointIndex = 0\n\n            self:setAttacherJointBottomArmWidth(implement.jointDescIndex, nil ) -- reset width\n        end\n\n        if not jointDesc.delayedObjectChanges or jointDesc.bottomArm = = nil then\n            ObjectChangeUtil.setObjectChanges(jointDesc.changeObjects, false , self , self.setMovingToolDirty)\n        end\n\n        for i = 1 , #jointDesc.hideVisuals do\n            local node = jointDesc.hideVisuals[i]\n\n            local allowedToShow = true\n            local attacherJoints = spec.hideVisualNodeToAttacherJoints[node]\n            if attacherJoints ~ = nil then\n                for j = 1 , #attacherJoints do\n                    if attacherJoints[j].jointIndex ~ = 0 then\n                        allowedToShow = false\n                    end\n                end\n            end\n\n            if allowedToShow then\n                setVisibility(node, true )\n            end\n        end\n\n        for i = 1 , #jointDesc.visualNodes do\n            local node = jointDesc.visualNodes[i]\n\n            local hideNode = false\n            local attacherJoints = spec.hideVisualNodeToAttacherJoints[node]\n            if attacherJoints ~ = nil then\n                for j = 1 , #attacherJoints do\n                    if attacherJoints[j].jointIndex ~ = 0 then\n                        hideNode = true\n                    end\n                end\n            end\n\n            if hideNode then\n                setVisibility(node, false )\n            end\n        end\n\n        if implement.object ~ = nil then\n            local object = implement.object\n\n            if object.spec_attachable.isHardAttached then\n                self:hardDetachImplement(implement)\n            end\n\n            if self.isClient then\n                if jointDesc.topArm ~ = nil then\n                    jointDesc.topArm:setIsActive( false )\n                end\n\n                if jointDesc.bottomArm ~ = nil then\n                    local interpolator = ValueInterpolator.new(jointDesc.bottomArm.interpolatorKey, jointDesc.bottomArm.interpolatorGet, jointDesc.bottomArm.interpolatorSet, { jointDesc.bottomArm.rotX, jointDesc.bottomArm.rotY, jointDesc.bottomArm.rotZ } , nil , jointDesc.bottomArm.resetSpeed)\n                    if interpolator ~ = nil then\n                        interpolator:setDeleteListenerObject( self )\n                        interpolator:setFinishedFunc(jointDesc.bottomArm.interpolatorFinished, jointDesc.bottomArm)\n                        jointDesc.bottomArm.bottomArmInterpolating = true\n\n                        if jointDesc.delayedObjectChanges then\n                            interpolator:setFinishedFunc( function ()\n                                jointDesc.bottomArm.interpolatorFinished(jointDesc.bottomArm)\n\n                                -- in case we already attached another vehicle\n                                if jointDesc.jointIndex = = 0 then\n                                    ObjectChangeUtil.setObjectChanges(jointDesc.changeObjects, false , self , self.setMovingToolDirty)\n                                end\n                            end )\n                        end\n                    end\n\n                    jointDesc.bottomArm.lastDirection[ 1 ], jointDesc.bottomArm.lastDirection[ 2 ], jointDesc.bottomArm.lastDirection[ 3 ] = 0 , 0 , 0\n\n                    if jointDesc.bottomArm.translationNode ~ = nil then\n                        setTranslation(jointDesc.bottomArm.translationNode, 0 , 0 , 0 )\n                    end\n                    if jointDesc.bottomArm.toolbarNode ~ = nil then\n                        setVisibility(jointDesc.bottomArm.toolbarNode, false )\n                    end\n                    if jointDesc.bottomArm.toggleVisibility then\n                        setVisibility(jointDesc.bottomArm.rotationNode, false )\n                    end\n\n                    if jointDesc.bottomArm.leftNode ~ = nil then\n                        self:setMovingPartReferenceNode(jointDesc.bottomArm.leftNode, nil , false )\n                    end\n                    if jointDesc.bottomArm.rightNode ~ = nil then\n                        self:setMovingPartReferenceNode(jointDesc.bottomArm.rightNode, nil , false )\n                    end\n                end\n            end\n\n            -- restore original translation\n            setTranslation(jointDesc.jointTransform, unpack(jointDesc.jointOrigTrans))\n            local attacherJoint = object:getActiveInputAttacherJoint()\n            setTranslation(attacherJoint.node, unpack(attacherJoint.jointOrigTrans))\n            if jointDesc.rotationNode ~ = nil then\n                setRotation(jointDesc.rotationNode, jointDesc.rotX, jointDesc.rotY, jointDesc.rotZ)\n            end\n            if jointDesc.rotationNode2 ~ = nil then\n                setRotation(jointDesc.rotationNode2, - jointDesc.rotX, - jointDesc.rotY, - jointDesc.rotZ)\n            end\n\n            if jointDesc.visualAlignNodes ~ = nil then\n                for _, visualAlignNode in ipairs(jointDesc.visualAlignNodes) do\n                    self:setMovingPartReferenceNode(visualAlignNode.node, jointDesc.jointTransform, false )\n                end\n            end\n\n            SpecializationUtil.raiseEvent( self , "onPostDetachImplement" , implementIndex)\n            object:postDetach(implementIndex)\n\n            self:detachAdditionalAttachment(jointDesc, attacherJoint)\n        end\n\n        table.remove(spec.attachedImplements, implementIndex)\n\n        self:playDetachSound(jointDesc)\n\n        spec.wasInAttachRange = nil\n\n        self:updateVehicleChain()\n        implement.object:updateVehicleChain()\n\n        local data = { attacherVehicle = self , attachedVehicle = implement.object }\n        implement.object:raiseStateChange(VehicleStateChange.DETACH, data)\n        local rootVehicle = self.rootVehicle\n        rootVehicle:raiseStateChange(VehicleStateChange.DETACH, data)\n\n        self.rootVehicle:updateSelectableObjects()\n        if GS_IS_MOBILE_VERSION then\n            -- for mobile we select the next vehicle that can be detached, if non available we select the root\n                local nextImplement = next(spec.attachedImplements)\n                if spec.attachedImplements[nextImplement] ~ = nil then\n                    self.rootVehicle:setSelectedVehicle(spec.attachedImplements[nextImplement].object, nil , true )\n                else\n                        self.rootVehicle:setSelectedVehicle( self , nil , true )\n                    end\n                else\n                        self.rootVehicle:setSelectedVehicle( self , nil , true )\n                    end\n                    self.rootVehicle:requestActionEventUpdate() -- do action event update independent of a successful selection(important since we cannot select every vehicle)\n                        implement.object:updateSelectableObjects()\n                        implement.object:setSelectedVehicle(implement.object, nil , true )\n                        implement.object:requestActionEventUpdate() -- do action event update independent of a successful selection(important since we cannot select every vehicle)\n\n                            AttacherJoints.updateRequiredTopLightsState( self )\n\n                            return true\n                        end\n\n'})}),"\n",(0,o.jsx)(n.h3,{id:"detachimplementbyobject",children:"detachImplementByObject"}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Description"})}),"\n",(0,o.jsxs)(n.blockquote,{children:["\n",(0,o.jsx)(n.p,{children:"Detach implement by object of implement"}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Definition"})}),"\n",(0,o.jsxs)(n.blockquote,{children:["\n",(0,o.jsx)(n.p,{children:"detachImplementByObject(table object, boolean noEventSend)"}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,o.jsxs)(n.table,{children:[(0,o.jsx)(n.thead,{children:(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.th,{children:"table"}),(0,o.jsx)(n.th,{children:"object"}),(0,o.jsx)(n.th,{children:"object of implement to detach"})]})}),(0,o.jsx)(n.tbody,{children:(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:"boolean"}),(0,o.jsx)(n.td,{children:"noEventSend"}),(0,o.jsx)(n.td,{children:"no event send"})]})})]}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Return Values"})}),"\n\n\n\n\n\n\n\n\n",(0,o.jsx)(n.table,{children:(0,o.jsx)(n.thead,{children:(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.th,{children:"boolean"}),(0,o.jsx)(n.th,{children:"success"}),(0,o.jsx)(n.th,{children:"success"})]})})}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Code"})}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-lua",children:"function AttacherJoints:detachImplementByObject(object, noEventSend)\n    local spec = self.spec_attacherJoints\n\n    for i,implement in ipairs(spec.attachedImplements) do\n        if implement.object = = object then\n            self:detachImplement(i, noEventSend)\n            break\n        end\n    end\n\n    return true\nend\n\n"})}),"\n",(0,o.jsx)(n.h3,{id:"detachingispossible",children:"detachingIsPossible"}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Description"})}),"\n",(0,o.jsxs)(n.blockquote,{children:["\n",(0,o.jsx)(n.p,{children:"Returns true if it is possible to detach selected implement"}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Definition"})}),"\n",(0,o.jsxs)(n.blockquote,{children:["\n",(0,o.jsx)(n.p,{children:"detachingIsPossible()"}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Return Values"})}),"\n\n\n\n\n\n\n\n\n",(0,o.jsx)(n.table,{children:(0,o.jsx)(n.thead,{children:(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.th,{children:"boolean"}),(0,o.jsx)(n.th,{children:"possibleToDetach"}),(0,o.jsx)(n.th,{children:"possible to detach selected implement"})]})})}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Code"})}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-lua",children:"function AttacherJoints:detachingIsPossible()\n    local implement = self:getImplementByObject( self:getSelectedVehicle())\n    if implement ~ = nil then\n        local object = implement.object\n        if object ~ = nil and object.attacherVehicle ~ = nil and object:isDetachAllowed() then\n            local implementIndex = object.attacherVehicle:getImplementIndexByObject(object)\n            if implementIndex ~ = nil then\n                return true\n            end\n        end\n    end\n    return false\nend\n\n"})}),"\n",(0,o.jsx)(n.h3,{id:"dogroundheightnodecheck",children:"doGroundHeightNodeCheck"}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Description"})}),"\n",(0,o.jsxs)(n.blockquote,{children:["\n",(0,o.jsx)(n.p,{children:"Starts the next step in the ground height node check (raycast)"}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Definition"})}),"\n",(0,o.jsxs)(n.blockquote,{children:["\n",(0,o.jsx)(n.p,{children:"doGroundHeightNodeCheck()"}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Code"})}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-lua",children:'function AttacherJoints:doGroundHeightNodeCheck()\n    local checkData = self.spec_attacherJoints.groundHeightNodeCheckData\n\n    local heightNode = checkData.heightNodes[checkData.index]\n    if heightNode ~ = nil and checkData.object:getIsAttacherJointHeightNodeActive(heightNode) then\n        local offX, offY, offZ = localToLocal(heightNode.node, heightNode.attacherJointNode, 0 , 0 , 0 )\n\n        self:updateAttacherJointRotationNodes(checkData.jointDesc, 1 )\n        local lWx, lWy, lWz = localToWorld(checkData.jointDesc.jointTransformOrig, offX, offY, offZ)\n\n        self:updateAttacherJointRotationNodes(checkData.jointDesc, 0 )\n        local uWx, uWy, uWz = localToWorld(checkData.jointDesc.jointTransformOrig, offX, offY, offZ)\n\n        --#debug if VehicleDebug.state = = VehicleDebug.DEBUG then\n            --#debug DebugGizmo.renderAtPositionSimple(lWx, lWy, lWz)\n            --#debug DebugGizmo.renderAtPositionSimple(uWx, uWy, uWz)\n            --#debug drawDebugLine(uWx, uWy, uWz, 0, 1, 0, lWx, lWy, lWz, 1, 0, 0, true)\n            --#debug end\n\n            local dirX, dirY, dirZ = lWx - uWx, lWy - uWy, lWz - uWz\n            local distance = MathUtil.vector3Length(dirX, dirY, dirZ)\n            dirX, dirY, dirZ = MathUtil.vector3Normalize(dirX, dirY, dirZ)\n\n            checkData.currentRaycastDistance = distance\n            checkData.currentRaycastWorldPos[ 1 ] = uWx\n            checkData.currentRaycastWorldPos[ 2 ] = uWy\n            checkData.currentRaycastWorldPos[ 3 ] = uWz\n            checkData.currentRaycastWorldDir[ 1 ] = dirX\n            checkData.currentRaycastWorldDir[ 2 ] = dirY\n            checkData.currentRaycastWorldDir[ 3 ] = dirZ\n\n            checkData.currentJointTransformPos[ 1 ], checkData.currentJointTransformPos[ 2 ], checkData.currentJointTransformPos[ 3 ] = getWorldTranslation(checkData.jointDesc.jointTransform)\n\n            -- as real raycast distance we also add the lower distance to ground\n            distance = distance + checkData.objectAttacherJoint.lowerDistanceToGround\n            checkData.minDistance = math.min(checkData.minDistance, distance)\n            raycastAllAsync(uWx, uWy, uWz, dirX, dirY, dirZ, distance, "groundHeightNodeCheckCallback" , self , CollisionFlag.TERRAIN)\n\n            self:updateAttacherJointRotationNodes(checkData.jointDesc, checkData.jointDesc.moveAlpha or 0 )\n        else\n                checkData.index = checkData.index + 1\n                if checkData.index > #checkData.heightNodes then\n                    self:finishGroundHeightNodeCheck()\n                else\n                        checkData.isDirty = true\n                    end\n                end\n            end\n\n'})}),"\n",(0,o.jsx)(n.h3,{id:"findvehicleinattachrange",children:"findVehicleInAttachRange"}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Description"})}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Definition"})}),"\n",(0,o.jsxs)(n.blockquote,{children:["\n",(0,o.jsx)(n.p,{children:"findVehicleInAttachRange()"}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Code"})}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-lua",children:"function AttacherJoints.findVehicleInAttachRange()\n    log( \"function 'AttacherJoints.findVehicleInAttachRange' is deprecated.Use 'AttacherJoints.updateVehiclesInAttachRange' instead.Valid output of this function is now up to 5 frames delayed, if parameter 4 is not 'true'.\" )\n    end\n\n"})}),"\n",(0,o.jsx)(n.h3,{id:"finishgroundheightnodecheck",children:"finishGroundHeightNodeCheck"}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Description"})}),"\n",(0,o.jsxs)(n.blockquote,{children:["\n",(0,o.jsx)(n.p,{children:"Called to finish the ground height node check and calculate the upper and lower alpha based on the results"}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Definition"})}),"\n",(0,o.jsxs)(n.blockquote,{children:["\n",(0,o.jsx)(n.p,{children:"finishGroundHeightNodeCheck()"}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Code"})}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-lua",children:"function AttacherJoints:finishGroundHeightNodeCheck()\n    local checkData = self.spec_attacherJoints.groundHeightNodeCheckData\n\n    if checkData.minDistance ~ = math.huge then\n        if not checkData.hit then\n            checkData.raycastDistance = checkData.currentRaycastDistance\n\n            checkData.raycastWorldPos[ 1 ] = checkData.currentRaycastWorldPos[ 1 ]\n            checkData.raycastWorldPos[ 2 ] = checkData.currentRaycastWorldPos[ 2 ]\n            checkData.raycastWorldPos[ 3 ] = checkData.currentRaycastWorldPos[ 3 ]\n\n            checkData.raycastWorldDir[ 1 ] = checkData.currentRaycastWorldDir[ 1 ]\n            checkData.raycastWorldDir[ 2 ] = checkData.currentRaycastWorldDir[ 2 ]\n            checkData.raycastWorldDir[ 3 ] = checkData.currentRaycastWorldDir[ 3 ]\n\n            checkData.jointTransformPos[ 1 ] = checkData.currentJointTransformPos[ 1 ]\n            checkData.jointTransformPos[ 2 ] = checkData.currentJointTransformPos[ 2 ]\n            checkData.jointTransformPos[ 3 ] = checkData.currentJointTransformPos[ 3 ]\n        end\n\n        local upperAlpha = (checkData.minDistance - checkData.objectAttacherJoint.upperDistanceToGround) / checkData.raycastDistance\n        local lowerAlpha = (checkData.minDistance - checkData.objectAttacherJoint.lowerDistanceToGround) / checkData.raycastDistance\n\n        local uWx, uWy, uWz = checkData.raycastWorldPos[ 1 ], checkData.raycastWorldPos[ 2 ], checkData.raycastWorldPos[ 3 ]\n        local dirX, dirY, dirZ = checkData.raycastWorldDir[ 1 ], checkData.raycastWorldDir[ 2 ], checkData.raycastWorldDir[ 3 ]\n\n        -- correction since we raycast straight to lower point, but rotate in a circle\n        local x1, y1, z1 = uWx + dirX * checkData.raycastDistance * lowerAlpha, uWy + dirY * checkData.raycastDistance * lowerAlpha, uWz + dirZ * checkData.raycastDistance * lowerAlpha\n\n        local x3, y3, z3 = checkData.jointTransformPos[ 1 ], checkData.jointTransformPos[ 2 ], checkData.jointTransformPos[ 3 ]\n        local straightToCenter = MathUtil.vector3Length(x1 - x3, y1 - y3, z1 - z3)\n        local circleToCenter = MathUtil.vector3Length(uWx - x3, uWy - y3, uWz - z3)\n        local straightOffset = circleToCenter - straightToCenter\n\n        local _, h1, h2\n        _, h1, _ = worldToLocal( self.rootNode, x1, y1, z1)\n        _, h2, _ = worldToLocal( self.rootNode, uWx, uWy, uWz)\n\n        local angle = math.atan(straightOffset / (h2 - h1))\n        local offset = straightOffset * math.sin(angle)\n        lowerAlpha = (checkData.minDistance - checkData.objectAttacherJoint.lowerDistanceToGround - offset) / checkData.raycastDistance\n\n        checkData.lowerAlpha = math.clamp(lowerAlpha, 0 , 1 )\n        checkData.upperAlpha = math.clamp(upperAlpha, 0 , 1 )\n    end\n\n    checkData.index = - 1\nend\n\n"})}),"\n",(0,o.jsx)(n.h3,{id:"getadditionalcomponentmass",children:"getAdditionalComponentMass"}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Description"})}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Definition"})}),"\n",(0,o.jsxs)(n.blockquote,{children:["\n",(0,o.jsx)(n.p,{children:"getAdditionalComponentMass()"}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,o.jsxs)(n.table,{children:[(0,o.jsx)(n.thead,{children:(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.th,{children:"any"}),(0,o.jsx)(n.th,{children:"superFunc"})]})}),(0,o.jsx)(n.tbody,{children:(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:"any"}),(0,o.jsx)(n.td,{children:"component"})]})})]}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Code"})}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-lua",children:"function AttacherJoints:getAdditionalComponentMass(superFunc, component)\n    local additionalMass = superFunc( self , component)\n\n    if component.node = = self.rootNode then\n        local spec = self.spec_attacherJoints\n        for _, implement in pairs(spec.attachedImplements) do\n            local object = implement.object\n            if object ~ = nil and object.spec_attachable.isHardAttached then\n                additionalMass = additionalMass + object:getTotalMass( true )\n            end\n        end\n    end\n\n    return additionalMass\nend\n\n"})}),"\n",(0,o.jsx)(n.h3,{id:"getairconsumerusage",children:"getAirConsumerUsage"}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Description"})}),"\n",(0,o.jsxs)(n.blockquote,{children:["\n",(0,o.jsx)(n.p,{children:"Returns air consumer usage of attached vehicles"}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Definition"})}),"\n",(0,o.jsxs)(n.blockquote,{children:["\n",(0,o.jsx)(n.p,{children:"getAirConsumerUsage()"}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,o.jsx)(n.table,{children:(0,o.jsx)(n.thead,{children:(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.th,{children:"any"}),(0,o.jsx)(n.th,{children:"superFunc"})]})})}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Return Values"})}),"\n\n\n\n\n\n\n\n\n",(0,o.jsx)(n.table,{children:(0,o.jsx)(n.thead,{children:(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.th,{children:"any"}),(0,o.jsx)(n.th,{children:"usage"}),(0,o.jsx)(n.th,{children:"air usage"})]})})}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Code"})}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-lua",children:"function AttacherJoints:getAirConsumerUsage(superFunc)\n    local spec = self.spec_attacherJoints\n    local usage = superFunc( self )\n\n    for _, implement in pairs(spec.attachedImplements) do\n        local object = implement.object\n        if object ~ = nil and object.getAttachbleAirConsumerUsage ~ = nil then\n            usage = usage + object:getAttachbleAirConsumerUsage()\n        end\n    end\n\n    return usage\nend\n\n"})}),"\n",(0,o.jsx)(n.h3,{id:"getarecontrolledactionsallowed",children:"getAreControlledActionsAllowed"}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Description"})}),"\n",(0,o.jsxs)(n.blockquote,{children:["\n",(0,o.jsx)(n.p,{children:"Returns if controlled actions are allowed"}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Definition"})}),"\n",(0,o.jsxs)(n.blockquote,{children:["\n",(0,o.jsx)(n.p,{children:"getAreControlledActionsAllowed()"}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,o.jsx)(n.table,{children:(0,o.jsx)(n.thead,{children:(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.th,{children:"any"}),(0,o.jsx)(n.th,{children:"superFunc"})]})})}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Return Values"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,o.jsxs)(n.table,{children:[(0,o.jsx)(n.thead,{children:(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.th,{children:"any"}),(0,o.jsx)(n.th,{children:"allow"}),(0,o.jsx)(n.th,{children:"allow controlled actions"})]})}),(0,o.jsx)(n.tbody,{children:(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:"any"}),(0,o.jsx)(n.td,{children:"warning"}),(0,o.jsx)(n.td,{children:"not allowed warning"})]})})]}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Code"})}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-lua",children:"function AttacherJoints:getAreControlledActionsAllowed(superFunc)\n    local allowed, warning = superFunc( self )\n    if not allowed then\n        return false , warning\n    end\n\n    local spec = self.spec_attacherJoints\n    for _, implement in pairs(spec.attachedImplements) do\n        local object = implement.object\n        if object ~ = nil then\n            if object.getAreControlledActionsAllowed ~ = nil then\n                allowed, warning = object:getAreControlledActionsAllowed()\n                if not allowed then\n                    return false , warning\n                end\n            end\n        end\n\n        if implement.attachingIsInProgress then\n            return false\n        end\n    end\n\n    return true , warning\nend\n\n"})}),"\n",(0,o.jsx)(n.h3,{id:"getattachedimplements",children:"getAttachedImplements"}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Description"})}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Definition"})}),"\n",(0,o.jsxs)(n.blockquote,{children:["\n",(0,o.jsx)(n.p,{children:"getAttachedImplements()"}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Code"})}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-lua",children:"function AttacherJoints:getAttachedImplements()\n    return self.spec_attacherJoints.attachedImplements\nend\n\n"})}),"\n",(0,o.jsx)(n.h3,{id:"getattacherjointbyjointdescindex",children:"getAttacherJointByJointDescIndex"}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Description"})}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Definition"})}),"\n",(0,o.jsxs)(n.blockquote,{children:["\n",(0,o.jsx)(n.p,{children:"getAttacherJointByJointDescIndex()"}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,o.jsx)(n.table,{children:(0,o.jsx)(n.thead,{children:(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.th,{children:"any"}),(0,o.jsx)(n.th,{children:"jointDescIndex"})]})})}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Code"})}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-lua",children:"function AttacherJoints:getAttacherJointByJointDescIndex(jointDescIndex)\n    return self.spec_attacherJoints.attacherJoints[jointDescIndex]\nend\n\n"})}),"\n",(0,o.jsx)(n.h3,{id:"getattacherjointbynode",children:"getAttacherJointByNode"}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Description"})}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Definition"})}),"\n",(0,o.jsxs)(n.blockquote,{children:["\n",(0,o.jsx)(n.p,{children:"getAttacherJointByNode()"}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,o.jsx)(n.table,{children:(0,o.jsx)(n.thead,{children:(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.th,{children:"any"}),(0,o.jsx)(n.th,{children:"node"})]})})}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Code"})}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-lua",children:"function AttacherJoints:getAttacherJointByNode(node)\n    local spec = self.spec_attacherJoints\n    for i = 1 , #spec.attacherJoints do\n        local attacherJoint = spec.attacherJoints[i]\n        if attacherJoint.jointTransform = = node then\n            return attacherJoint\n        end\n    end\n\n    return nil\nend\n\n"})}),"\n",(0,o.jsx)(n.h3,{id:"getattacherjointcompatibility",children:"getAttacherJointCompatibility"}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Description"})}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Definition"})}),"\n",(0,o.jsxs)(n.blockquote,{children:["\n",(0,o.jsx)(n.p,{children:"getAttacherJointCompatibility()"}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,o.jsxs)(n.table,{children:[(0,o.jsx)(n.thead,{children:(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.th,{children:"any"}),(0,o.jsx)(n.th,{children:"vehicle"})]})}),(0,o.jsxs)(n.tbody,{children:[(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:"any"}),(0,o.jsx)(n.td,{children:"attacherJoint"})]}),(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:"any"}),(0,o.jsx)(n.td,{children:"inputAttacherVehicle"})]}),(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:"any"}),(0,o.jsx)(n.td,{children:"inputAttacherJoint"})]})]})]}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Code"})}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-lua",children:'function AttacherJoints.getAttacherJointCompatibility(vehicle, attacherJoint, inputAttacherVehicle, inputAttacherJoint)\n    if inputAttacherJoint.forcedAttachingDirection ~ = 0 and attacherJoint.attacherJointDirection ~ = nil then\n        if inputAttacherJoint.forcedAttachingDirection ~ = attacherJoint.attacherJointDirection then\n            return false\n        end\n    end\n\n    if attacherJoint.isBlocked then\n        return false\n    end\n\n    if attacherJoint.subTypes ~ = nil then\n        if inputAttacherJoint.subTypes = = nil then\n            if attacherJoint.subTypeShowWarning and inputAttacherJoint.subTypeShowWarning then\n                return false , vehicle.spec_attacherJoints.texts.warningToolNotCompatible\n            end\n\n            return false\n        end\n\n        local found = false\n        for i = 1 , #attacherJoint.subTypes do\n            for j = 1 , #inputAttacherJoint.subTypes do\n                if attacherJoint.subTypes[i] = = inputAttacherJoint.subTypes[j] then\n                    found = true\n                    break\n                end\n            end\n        end\n\n        if not found then\n            if attacherJoint.subTypeShowWarning and inputAttacherJoint.subTypeShowWarning then\n                return false , vehicle.spec_attacherJoints.texts.warningToolNotCompatible\n            end\n\n            return false\n        end\n    else\n            if inputAttacherJoint.subTypes ~ = nil then\n                if inputAttacherJoint.subTypeShowWarning and attacherJoint.subTypeShowWarning then\n                    return false , vehicle.spec_attacherJoints.texts.warningToolNotCompatible\n                end\n\n                return false\n            end\n        end\n\n        if attacherJoint.brandRestrictions ~ = nil then\n            local found = false\n            for i = 1 , #attacherJoint.brandRestrictions do\n                if inputAttacherVehicle.brand ~ = nil then\n                    if inputAttacherVehicle.brand = = attacherJoint.brandRestrictions[i] then\n                        found = true\n                        break\n                    end\n                end\n            end\n\n            if not found then\n                local brandString = ""\n                for i = 1 , #attacherJoint.brandRestrictions do\n                    if i > 1 then\n                        brandString = brandString .. ", "\n                    end\n                    brandString = brandString .. attacherJoint.brandRestrictions[i].title\n                end\n\n                return false , string.format(vehicle.spec_attacherJoints.texts.warningToolBrandNotCompatible, brandString)\n            end\n        end\n\n        if attacherJoint.vehicleRestrictions ~ = nil then\n            local found = false\n            for i = 1 , #attacherJoint.vehicleRestrictions do\n                if inputAttacherVehicle.configFileName:find(attacherJoint.vehicleRestrictions[i]) ~ = nil then\n                    found = true\n                    break\n                end\n            end\n\n            if not found then\n                return false , vehicle.spec_attacherJoints.texts.warningToolNotCompatible\n            end\n        end\n\n        local compatibility, warning = vehicle:getIsAttacherJointCompatible(vehicle, attacherJoint, inputAttacherVehicle, inputAttacherJoint)\n        if not compatibility then\n            return false , warning\n        end\n\n        return true\n    end\n\n'})}),"\n",(0,o.jsx)(n.h3,{id:"getattacherjointdescfromobject",children:"getAttacherJointDescFromObject"}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Description"})}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Definition"})}),"\n",(0,o.jsxs)(n.blockquote,{children:["\n",(0,o.jsx)(n.p,{children:"getAttacherJointDescFromObject()"}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,o.jsx)(n.table,{children:(0,o.jsx)(n.thead,{children:(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.th,{children:"any"}),(0,o.jsx)(n.th,{children:"object"})]})})}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Code"})}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-lua",children:"function AttacherJoints:getAttacherJointDescFromObject(object)\n    local spec = self.spec_attacherJoints\n    for _,attachedImplement in pairs(spec.attachedImplements) do\n        if attachedImplement.object = = object then\n            return spec.attacherJoints[attachedImplement.jointDescIndex]\n        end\n    end\n\n    return nil\nend\n\n"})}),"\n",(0,o.jsx)(n.h3,{id:"getattacherjointindexbynode",children:"getAttacherJointIndexByNode"}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Description"})}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Definition"})}),"\n",(0,o.jsxs)(n.blockquote,{children:["\n",(0,o.jsx)(n.p,{children:"getAttacherJointIndexByNode()"}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,o.jsx)(n.table,{children:(0,o.jsx)(n.thead,{children:(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.th,{children:"any"}),(0,o.jsx)(n.th,{children:"node"})]})})}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Code"})}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-lua",children:"function AttacherJoints:getAttacherJointIndexByNode(node)\n    local spec = self.spec_attacherJoints\n    for i = 1 , #spec.attacherJoints do\n        local attacherJoint = spec.attacherJoints[i]\n        if attacherJoint.jointTransform = = node then\n            return i\n        end\n    end\n\n    return nil\nend\n\n"})}),"\n",(0,o.jsx)(n.h3,{id:"getattacherjointindexfromimplementindex",children:"getAttacherJointIndexFromImplementIndex"}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Description"})}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Definition"})}),"\n",(0,o.jsxs)(n.blockquote,{children:["\n",(0,o.jsx)(n.p,{children:"getAttacherJointIndexFromImplementIndex()"}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,o.jsx)(n.table,{children:(0,o.jsx)(n.thead,{children:(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.th,{children:"any"}),(0,o.jsx)(n.th,{children:"implementIndex"})]})})}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Code"})}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-lua",children:"function AttacherJoints:getAttacherJointIndexFromImplementIndex(implementIndex)\n    local spec = self.spec_attacherJoints\n    local attachedImplement = spec.attachedImplements[implementIndex]\n    if attachedImplement ~ = nil then\n        return attachedImplement.jointDescIndex\n    end\n    return nil\nend\n\n"})}),"\n",(0,o.jsx)(n.h3,{id:"getattacherjointindexfromobject",children:"getAttacherJointIndexFromObject"}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Description"})}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Definition"})}),"\n",(0,o.jsxs)(n.blockquote,{children:["\n",(0,o.jsx)(n.p,{children:"getAttacherJointIndexFromObject()"}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,o.jsx)(n.table,{children:(0,o.jsx)(n.thead,{children:(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.th,{children:"any"}),(0,o.jsx)(n.th,{children:"object"})]})})}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Code"})}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-lua",children:"function AttacherJoints:getAttacherJointIndexFromObject(object)\n    local spec = self.spec_attacherJoints\n    for _,attachedImplement in pairs(spec.attachedImplements) do\n        if attachedImplement.object = = object then\n            return attachedImplement.jointDescIndex\n        end\n    end\n\n    return nil\nend\n\n"})}),"\n",(0,o.jsx)(n.h3,{id:"getattacherjoints",children:"getAttacherJoints"}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Description"})}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Definition"})}),"\n",(0,o.jsxs)(n.blockquote,{children:["\n",(0,o.jsx)(n.p,{children:"getAttacherJoints()"}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Code"})}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-lua",children:"function AttacherJoints:getAttacherJoints()\n    return self.spec_attacherJoints.attacherJoints\nend\n\n"})}),"\n",(0,o.jsx)(n.h3,{id:"getcansteerattachable",children:"getCanSteerAttachable"}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Description"})}),"\n",(0,o.jsxs)(n.blockquote,{children:["\n",(0,o.jsx)(n.p,{children:"Returns if the vehicle can control the steering axles of the given attachable"}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Definition"})}),"\n",(0,o.jsxs)(n.blockquote,{children:["\n",(0,o.jsx)(n.p,{children:"getCanSteerAttachable(table jointDesc)"}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n",(0,o.jsx)(n.table,{children:(0,o.jsx)(n.thead,{children:(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.th,{children:"table"}),(0,o.jsx)(n.th,{children:"jointDesc"}),(0,o.jsx)(n.th,{children:"joint desc"})]})})}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Return Values"})}),"\n\n\n\n\n\n\n\n\n",(0,o.jsx)(n.table,{children:(0,o.jsx)(n.thead,{children:(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.th,{children:"table"}),(0,o.jsx)(n.th,{children:"success"}),(0,o.jsx)(n.th,{children:"success"})]})})}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Code"})}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-lua",children:"function AttacherJoints:getCanSteerAttachable(attachable)\n    local jointDesc = self:getAttacherJointDescFromObject(attachable)\n    if jointDesc ~ = nil then\n        if jointDesc.steeringBarLeftNode ~ = nil or jointDesc.steeringBarRightNode ~ = nil or jointDesc.steeringBarForceUsage then\n            return true\n        end\n    end\n\n    return false\nend\n\n"})}),"\n",(0,o.jsx)(n.h3,{id:"getcantoggleattach",children:"getCanToggleAttach"}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Description"})}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Definition"})}),"\n",(0,o.jsxs)(n.blockquote,{children:["\n",(0,o.jsx)(n.p,{children:"getCanToggleAttach()"}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Code"})}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-lua",children:"function AttacherJoints:getCanToggleAttach()\n    return true\nend\n\n"})}),"\n",(0,o.jsx)(n.h3,{id:"getclosestlowerlinkcategoryindex",children:"getClosestLowerLinkCategoryIndex"}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Description"})}),"\n",(0,o.jsxs)(n.blockquote,{children:["\n",(0,o.jsx)(n.p,{children:"Returns the closest lower link category for a given width"}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Definition"})}),"\n",(0,o.jsxs)(n.blockquote,{children:["\n",(0,o.jsx)(n.p,{children:"getClosestLowerLinkCategoryIndex()"}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,o.jsx)(n.table,{children:(0,o.jsx)(n.thead,{children:(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.th,{children:"any"}),(0,o.jsx)(n.th,{children:"width"})]})})}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Return Values"})}),"\n\n\n\n\n\n\n\n\n",(0,o.jsx)(n.table,{children:(0,o.jsx)(n.thead,{children:(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.th,{children:"any"}),(0,o.jsx)(n.th,{children:"index"}),(0,o.jsx)(n.th,{children:"category index (0-4)"})]})})}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Code"})}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-lua",children:"function AttacherJoints.getClosestLowerLinkCategoryIndex(width)\n    local minDistance, index = math.huge, 1\n    for categoryIndex, categoryWidth in pairs( AttacherJoints.LOWER_LINK_WIDTH_BY_CATEGORY) do\n        local distance = math.abs(width - categoryWidth)\n        if distance < minDistance then\n            minDistance = distance\n            index = categoryIndex\n        end\n    end\n\n    return index\nend\n\n"})}),"\n",(0,o.jsx)(n.h3,{id:"getconnectionhoseconfigindex",children:"getConnectionHoseConfigIndex"}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Description"})}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Definition"})}),"\n",(0,o.jsxs)(n.blockquote,{children:["\n",(0,o.jsx)(n.p,{children:"getConnectionHoseConfigIndex()"}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,o.jsx)(n.table,{children:(0,o.jsx)(n.thead,{children:(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.th,{children:"any"}),(0,o.jsx)(n.th,{children:"superFunc"})]})})}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Code"})}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-lua",children:'function AttacherJoints:getConnectionHoseConfigIndex(superFunc)\n    local index = superFunc( self )\n    index = self.xmlFile:getValue( "vehicle.attacherJoints#connectionHoseConfigId" , index)\n\n    if self.configurations[ "attacherJoint" ] ~ = nil then\n        local configKey = string.format( "vehicle.attacherJoints.attacherJointConfigurations.attacherJointConfiguration(%d)" , self.configurations[ "attacherJoint" ] - 1 )\n        index = self.xmlFile:getValue(configKey .. "#connectionHoseConfigId" , index)\n    end\n\n    return index\nend\n\n'})}),"\n",(0,o.jsx)(n.h3,{id:"getdirectionsnapangle",children:"getDirectionSnapAngle"}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Description"})}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Definition"})}),"\n",(0,o.jsxs)(n.blockquote,{children:["\n",(0,o.jsx)(n.p,{children:"getDirectionSnapAngle()"}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,o.jsx)(n.table,{children:(0,o.jsx)(n.thead,{children:(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.th,{children:"any"}),(0,o.jsx)(n.th,{children:"superFunc"})]})})}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Code"})}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-lua",children:"function AttacherJoints:getDirectionSnapAngle(superFunc)\n    local spec = self.spec_attacherJoints\n    local maxAngle = superFunc( self )\n\n    for _, implement in pairs(spec.attachedImplements) do\n        local object = implement.object\n        if object ~ = nil and object.getDirectionSnapAngle ~ = nil then\n            maxAngle = math.max(maxAngle + object:getDirectionSnapAngle())\n        end\n    end\n\n    return maxAngle\nend\n\n"})}),"\n",(0,o.jsx)(n.h3,{id:"getfilllevelinformation",children:"getFillLevelInformation"}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Description"})}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Definition"})}),"\n",(0,o.jsxs)(n.blockquote,{children:["\n",(0,o.jsx)(n.p,{children:"getFillLevelInformation()"}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,o.jsxs)(n.table,{children:[(0,o.jsx)(n.thead,{children:(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.th,{children:"any"}),(0,o.jsx)(n.th,{children:"superFunc"})]})}),(0,o.jsx)(n.tbody,{children:(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:"any"}),(0,o.jsx)(n.td,{children:"display"})]})})]}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Code"})}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-lua",children:"function AttacherJoints:getFillLevelInformation(superFunc, display)\n    local spec = self.spec_attacherJoints\n\n    superFunc( self , display)\n\n    for _, implement in pairs(spec.attachedImplements) do\n        local object = implement.object\n        if object ~ = nil and object.getFillLevelInformation ~ = nil then\n            object:getFillLevelInformation(display)\n        end\n    end\nend\n\n"})}),"\n",(0,o.jsx)(n.h3,{id:"getfillunitsupportstooltype",children:"getFillUnitSupportsToolType"}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Description"})}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Definition"})}),"\n",(0,o.jsxs)(n.blockquote,{children:["\n",(0,o.jsx)(n.p,{children:"getFillUnitSupportsToolType()"}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,o.jsxs)(n.table,{children:[(0,o.jsx)(n.thead,{children:(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.th,{children:"any"}),(0,o.jsx)(n.th,{children:"superFunc"})]})}),(0,o.jsxs)(n.tbody,{children:[(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:"any"}),(0,o.jsx)(n.td,{children:"fillUnitIndex"})]}),(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:"any"}),(0,o.jsx)(n.td,{children:"toolType"})]})]})]}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Code"})}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-lua",children:"function AttacherJoints:getFillUnitSupportsToolType(superFunc, fillUnitIndex, toolType)\n    if not superFunc( self , fillUnitIndex, toolType) then\n        return false\n    end\n\n    local spec = self.spec_fillUnit\n    local fillUnit = spec.fillUnits[fillUnitIndex]\n    if fillUnit ~ = nil then\n        if fillUnit.disablingAttacherJointNodes ~ = nil then\n            fillUnit.disablingAttacherJointIndices = { }\n            for _, jointNode in ipairs(fillUnit.disablingAttacherJointNodes) do\n                local jointIndex = self:getAttacherJointIndexByNode(jointNode)\n                if jointIndex ~ = nil then\n                    table.insert(fillUnit.disablingAttacherJointIndices, jointIndex)\n                end\n            end\n\n            if #fillUnit.disablingAttacherJointIndices = = 0 then\n                fillUnit.disablingAttacherJointIndices = nil\n            end\n        end\n\n        if fillUnit.disablingAttacherJointIndices ~ = nil then\n            for _, jointIndex in ipairs(fillUnit.disablingAttacherJointIndices) do\n                if self:getImplementFromAttacherJointIndex(jointIndex) ~ = nil then\n                    return false\n                end\n            end\n        end\n    end\n\n    return true\nend\n\n"})}),"\n",(0,o.jsx)(n.h3,{id:"gethasobjectmounted",children:"getHasObjectMounted"}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Description"})}),"\n",(0,o.jsxs)(n.blockquote,{children:["\n",(0,o.jsx)(n.p,{children:"Returns if the vehicle (or any child) has the given object mounted"}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Definition"})}),"\n",(0,o.jsxs)(n.blockquote,{children:["\n",(0,o.jsx)(n.p,{children:"getHasObjectMounted(table object, )"}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,o.jsxs)(n.table,{children:[(0,o.jsx)(n.thead,{children:(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.th,{children:"table"}),(0,o.jsx)(n.th,{children:"object"}),(0,o.jsx)(n.th,{children:"object"})]})}),(0,o.jsx)(n.tbody,{children:(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:"any"}),(0,o.jsx)(n.td,{children:"object"}),(0,o.jsx)(n.td,{})]})})]}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Return Values"})}),"\n\n\n\n\n\n\n\n\n",(0,o.jsx)(n.table,{children:(0,o.jsx)(n.thead,{children:(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.th,{children:"any"}),(0,o.jsx)(n.th,{children:"hasObjectMounted"}),(0,o.jsx)(n.th,{children:"has object mounted"})]})})}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Code"})}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-lua",children:"function AttacherJoints:getHasObjectMounted(superFunc, object)\n    if superFunc( self , object) then\n        return true\n    end\n\n    local spec = self.spec_attacherJoints\n    for _, implement in pairs(spec.attachedImplements) do\n        if implement.object ~ = nil then\n            if implement.object:getHasObjectMounted(object) then\n                return true\n            end\n        end\n    end\n\n    return false\nend\n\n"})}),"\n",(0,o.jsx)(n.h3,{id:"getimplementbyjointdescindex",children:"getImplementByJointDescIndex"}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Description"})}),"\n",(0,o.jsxs)(n.blockquote,{children:["\n",(0,o.jsx)(n.p,{children:"Returns implement by jointDescIndex"}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Definition"})}),"\n",(0,o.jsxs)(n.blockquote,{children:["\n",(0,o.jsx)(n.p,{children:"getImplementByJointDescIndex(integer jointDescIndex)"}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n",(0,o.jsx)(n.table,{children:(0,o.jsx)(n.thead,{children:(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.th,{children:"integer"}),(0,o.jsx)(n.th,{children:"jointDescIndex"}),(0,o.jsx)(n.th,{children:"joint desc index"})]})})}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Return Values"})}),"\n\n\n\n\n\n\n\n\n",(0,o.jsx)(n.table,{children:(0,o.jsx)(n.thead,{children:(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.th,{children:"integer"}),(0,o.jsx)(n.th,{children:"implement"}),(0,o.jsx)(n.th,{children:"implement"})]})})}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Code"})}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-lua",children:"function AttacherJoints:getImplementByJointDescIndex(jointDescIndex)\n    local spec = self.spec_attacherJoints\n\n    for i, implement in pairs(spec.attachedImplements) do\n        if implement.jointDescIndex = = jointDescIndex then\n            return implement\n        end\n    end\n\n    return nil\nend\n\n"})}),"\n",(0,o.jsx)(n.h3,{id:"getimplementbyobject",children:"getImplementByObject"}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Description"})}),"\n",(0,o.jsxs)(n.blockquote,{children:["\n",(0,o.jsx)(n.p,{children:"Returns implement by object"}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Definition"})}),"\n",(0,o.jsxs)(n.blockquote,{children:["\n",(0,o.jsx)(n.p,{children:"getImplementByObject(table object)"}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n",(0,o.jsx)(n.table,{children:(0,o.jsx)(n.thead,{children:(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.th,{children:"table"}),(0,o.jsx)(n.th,{children:"object"}),(0,o.jsx)(n.th,{children:"object of attached implement"})]})})}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Return Values"})}),"\n\n\n\n\n\n\n\n\n",(0,o.jsx)(n.table,{children:(0,o.jsx)(n.thead,{children:(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.th,{children:"table"}),(0,o.jsx)(n.th,{children:"implement"}),(0,o.jsx)(n.th,{children:"implement"})]})})}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Code"})}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-lua",children:"function AttacherJoints:getImplementByObject(object)\n    local spec = self.spec_attacherJoints\n\n    for i, implement in pairs(spec.attachedImplements) do\n        if implement.object = = object then\n            return implement\n        end\n    end\n\n    return nil\nend\n\n"})}),"\n",(0,o.jsx)(n.h3,{id:"getimplementfromattacherjointindex",children:"getImplementFromAttacherJointIndex"}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Description"})}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Definition"})}),"\n",(0,o.jsxs)(n.blockquote,{children:["\n",(0,o.jsx)(n.p,{children:"getImplementFromAttacherJointIndex()"}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,o.jsx)(n.table,{children:(0,o.jsx)(n.thead,{children:(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.th,{children:"any"}),(0,o.jsx)(n.th,{children:"attacherJointIndex"})]})})}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Code"})}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-lua",children:"function AttacherJoints:getImplementFromAttacherJointIndex(attacherJointIndex)\n    local spec = self.spec_attacherJoints\n    for _,attachedImplement in pairs(spec.attachedImplements) do\n        if attachedImplement.jointDescIndex = = attacherJointIndex then\n            return attachedImplement\n        end\n    end\n\n    return nil\nend\n\n"})}),"\n",(0,o.jsx)(n.h3,{id:"getimplementindexbyjointdescindex",children:"getImplementIndexByJointDescIndex"}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Description"})}),"\n",(0,o.jsxs)(n.blockquote,{children:["\n",(0,o.jsx)(n.p,{children:"Returns implement index in 'self.attachedImplements' by jointDescIndex"}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Definition"})}),"\n",(0,o.jsxs)(n.blockquote,{children:["\n",(0,o.jsx)(n.p,{children:"getImplementIndexByJointDescIndex(integer jointDescIndex)"}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n",(0,o.jsx)(n.table,{children:(0,o.jsx)(n.thead,{children:(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.th,{children:"integer"}),(0,o.jsx)(n.th,{children:"jointDescIndex"}),(0,o.jsx)(n.th,{children:"joint desc index"})]})})}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Return Values"})}),"\n\n\n\n\n\n\n\n\n",(0,o.jsx)(n.table,{children:(0,o.jsx)(n.thead,{children:(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.th,{children:"integer"}),(0,o.jsx)(n.th,{children:"index"}),(0,o.jsx)(n.th,{children:"index of implement"})]})})}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Code"})}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-lua",children:"function AttacherJoints:getImplementIndexByJointDescIndex(jointDescIndex)\n    local spec = self.spec_attacherJoints\n\n    for i, implement in pairs(spec.attachedImplements) do\n        if implement.jointDescIndex = = jointDescIndex then\n            return i\n        end\n    end\n\n    return nil\nend\n\n"})}),"\n",(0,o.jsx)(n.h3,{id:"getimplementindexbyobject",children:"getImplementIndexByObject"}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Description"})}),"\n",(0,o.jsxs)(n.blockquote,{children:["\n",(0,o.jsx)(n.p,{children:"Returns implement index in 'self.attachedImplements' by object"}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Definition"})}),"\n",(0,o.jsxs)(n.blockquote,{children:["\n",(0,o.jsx)(n.p,{children:"getImplementIndexByObject(table object)"}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n",(0,o.jsx)(n.table,{children:(0,o.jsx)(n.thead,{children:(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.th,{children:"table"}),(0,o.jsx)(n.th,{children:"object"}),(0,o.jsx)(n.th,{children:"object of attached implement"})]})})}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Return Values"})}),"\n\n\n\n\n\n\n\n\n",(0,o.jsx)(n.table,{children:(0,o.jsx)(n.thead,{children:(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.th,{children:"table"}),(0,o.jsx)(n.th,{children:"index"}),(0,o.jsx)(n.th,{children:"index of implement"})]})})}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Code"})}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-lua",children:"function AttacherJoints:getImplementIndexByObject(object)\n    local spec = self.spec_attacherJoints\n\n    for i, implement in pairs(spec.attachedImplements) do\n        if implement.object = = object then\n            return i\n        end\n    end\n\n    return nil\nend\n\n"})}),"\n",(0,o.jsx)(n.h3,{id:"getisattacherjointcompatible",children:"getIsAttacherJointCompatible"}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Description"})}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Definition"})}),"\n",(0,o.jsxs)(n.blockquote,{children:["\n",(0,o.jsx)(n.p,{children:"getIsAttacherJointCompatible()"}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,o.jsxs)(n.table,{children:[(0,o.jsx)(n.thead,{children:(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.th,{children:"any"}),(0,o.jsx)(n.th,{children:"vehicle"})]})}),(0,o.jsxs)(n.tbody,{children:[(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:"any"}),(0,o.jsx)(n.td,{children:"attacherJoint"})]}),(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:"any"}),(0,o.jsx)(n.td,{children:"inputAttacherVehicle"})]}),(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:"any"}),(0,o.jsx)(n.td,{children:"inputAttacherJoint"})]})]})]}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Code"})}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-lua",children:"function AttacherJoints:getIsAttacherJointCompatible(vehicle, attacherJoint, inputAttacherVehicle, inputAttacherJoint)\n    return true\nend\n\n"})}),"\n",(0,o.jsx)(n.h3,{id:"getisattacherjointheightnodeactive",children:"getIsAttacherJointHeightNodeActive"}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Description"})}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Definition"})}),"\n",(0,o.jsxs)(n.blockquote,{children:["\n",(0,o.jsx)(n.p,{children:"getIsAttacherJointHeightNodeActive()"}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,o.jsxs)(n.table,{children:[(0,o.jsx)(n.thead,{children:(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.th,{children:"any"}),(0,o.jsx)(n.th,{children:"superFunc"})]})}),(0,o.jsx)(n.tbody,{children:(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:"any"}),(0,o.jsx)(n.td,{children:"heightNode"})]})})]}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Code"})}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-lua",children:"function AttacherJoints:getIsAttacherJointHeightNodeActive(superFunc, heightNode)\n    for _, jointIndex in ipairs(heightNode.disablingAttacherJointIndices) do\n        if self:getImplementFromAttacherJointIndex(jointIndex) ~ = nil then\n            return false\n        end\n    end\n\n    return superFunc( self , heightNode)\nend\n\n"})}),"\n",(0,o.jsx)(n.h3,{id:"getisattachingallowed",children:"getIsAttachingAllowed"}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Description"})}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Definition"})}),"\n",(0,o.jsxs)(n.blockquote,{children:["\n",(0,o.jsx)(n.p,{children:"getIsAttachingAllowed()"}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,o.jsx)(n.table,{children:(0,o.jsx)(n.thead,{children:(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.th,{children:"any"}),(0,o.jsx)(n.th,{children:"attacherJoint"})]})})}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Code"})}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-lua",children:"function AttacherJoints:getIsAttachingAllowed(attacherJoint)\n    if attacherJoint.jointIndex ~ = 0 then\n        return false\n    end\n\n    if attacherJoint.isBlocked then\n        return false\n    end\n\n    if attacherJoint.disabledByAttacherJoints ~ = nil and #attacherJoint.disabledByAttacherJoints > 0 then\n        for i = 1 , #attacherJoint.disabledByAttacherJoints do\n            local jointIndex = attacherJoint.disabledByAttacherJoints[i]\n            if self:getImplementByJointDescIndex(jointIndex) ~ = nil then\n                return false\n            end\n        end\n    end\n\n    return true\nend\n\n"})}),"\n",(0,o.jsx)(n.h3,{id:"getisautomaticshiftingallowed",children:"getIsAutomaticShiftingAllowed"}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Description"})}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Definition"})}),"\n",(0,o.jsxs)(n.blockquote,{children:["\n",(0,o.jsx)(n.p,{children:"getIsAutomaticShiftingAllowed()"}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,o.jsx)(n.table,{children:(0,o.jsx)(n.thead,{children:(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.th,{children:"any"}),(0,o.jsx)(n.th,{children:"superFunc"})]})})}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Code"})}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-lua",children:"function AttacherJoints:getIsAutomaticShiftingAllowed(superFunc)\n    local spec = self.spec_attacherJoints\n    local lastSpeed = self:getLastSpeed()\n    for _, implement in pairs(spec.attachedImplements) do\n        if lastSpeed < 2 then\n            if implement.attachingIsInProgress then\n                return false\n            else\n                    local jointDescIndex = implement.jointDescIndex\n                    local jointDesc = spec.attacherJoints[jointDescIndex]\n                    if jointDesc.isMoving then\n                        return false\n                    end\n                end\n            end\n\n            local object = implement.object\n            if object ~ = nil and object.getIsAutomaticShiftingAllowed ~ = nil then\n                if not object:getIsAutomaticShiftingAllowed() then\n                    return false\n                end\n            end\n        end\n\n        return superFunc( self )\n    end\n\n"})}),"\n",(0,o.jsx)(n.h3,{id:"getisconnectiontargetused",children:"getIsConnectionTargetUsed"}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Description"})}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Definition"})}),"\n",(0,o.jsxs)(n.blockquote,{children:["\n",(0,o.jsx)(n.p,{children:"getIsConnectionTargetUsed()"}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,o.jsxs)(n.table,{children:[(0,o.jsx)(n.thead,{children:(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.th,{children:"any"}),(0,o.jsx)(n.th,{children:"superFunc"})]})}),(0,o.jsx)(n.tbody,{children:(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:"any"}),(0,o.jsx)(n.td,{children:"desc"})]})})]}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Code"})}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-lua",children:"function AttacherJoints:getIsConnectionTargetUsed(superFunc, desc)\n    if superFunc( self , desc) then\n        return true\n    end\n\n    if desc.blockedByAttacherJointIndices ~ = nil then\n        for _, jointNode in ipairs(desc.blockedByAttacherJointIndices) do\n            local jointIndex = self:getAttacherJointIndexByNode(jointNode)\n            if jointIndex ~ = nil then\n                local implement = self:getImplementFromAttacherJointIndex(jointIndex)\n                if implement ~ = nil then\n                    return true\n                end\n            end\n        end\n    end\n\n    return false\nend\n\n"})}),"\n",(0,o.jsx)(n.h3,{id:"getisdashboardgroupactive",children:"getIsDashboardGroupActive"}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Description"})}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Definition"})}),"\n",(0,o.jsxs)(n.blockquote,{children:["\n",(0,o.jsx)(n.p,{children:"getIsDashboardGroupActive()"}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,o.jsxs)(n.table,{children:[(0,o.jsx)(n.thead,{children:(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.th,{children:"any"}),(0,o.jsx)(n.th,{children:"superFunc"})]})}),(0,o.jsx)(n.tbody,{children:(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:"any"}),(0,o.jsx)(n.td,{children:"group"})]})})]}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Code"})}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-lua",children:"function AttacherJoints:getIsDashboardGroupActive(superFunc, group)\n    if group.attacherJointNodes ~ = nil and self.finishedLoading then\n        if group.attacherJointIndices = = nil then\n            group.attacherJointIndices = { }\n        end\n\n        for _, node in ipairs(group.attacherJointNodes) do\n            local attacherJointIndex = self:getAttacherJointIndexByNode(node)\n            if attacherJointIndex ~ = nil then\n                table.insert(group.attacherJointIndices, attacherJointIndex)\n            end\n        end\n\n        if #group.attacherJointIndices = = 0 then\n            group.attacherJointIndices = nil\n        end\n\n        group.attacherJointNodes = nil\n    end\n\n    if group.attacherJointIndices ~ = nil then\n        local hasAttachment = false\n        for _, jointIndex in ipairs(group.attacherJointIndices) do\n            if self:getImplementFromAttacherJointIndex(jointIndex) ~ = nil then\n                hasAttachment = true\n            end\n        end\n\n        if not hasAttachment then\n            return false\n        end\n    end\n\n    return superFunc( self , group)\nend\n\n"})}),"\n",(0,o.jsx)(n.h3,{id:"getisfoldallowed",children:"getIsFoldAllowed"}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Description"})}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Definition"})}),"\n",(0,o.jsxs)(n.blockquote,{children:["\n",(0,o.jsx)(n.p,{children:"getIsFoldAllowed()"}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,o.jsxs)(n.table,{children:[(0,o.jsx)(n.thead,{children:(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.th,{children:"any"}),(0,o.jsx)(n.th,{children:"superFunc"})]})}),(0,o.jsxs)(n.tbody,{children:[(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:"any"}),(0,o.jsx)(n.td,{children:"direction"})]}),(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:"any"}),(0,o.jsx)(n.td,{children:"onAiTurnOn"})]})]})]}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Code"})}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-lua",children:"function AttacherJoints:getIsFoldAllowed(superFunc, direction, onAiTurnOn)\n    local spec = self.spec_attacherJoints\n    for attacherJointIndex, attacherJoint in ipairs(spec.attacherJoints) do\n        if not attacherJoint.allowFoldingWhileAttached then\n            if attacherJoint.jointIndex ~ = 0 then\n                return false , spec.texts.warningFoldingAttacherJoint\n            end\n        end\n    end\n\n    return superFunc( self , direction, onAiTurnOn)\nend\n\n"})}),"\n",(0,o.jsx)(n.h3,{id:"getishardattachallowed",children:"getIsHardAttachAllowed"}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Description"})}),"\n",(0,o.jsxs)(n.blockquote,{children:["\n",(0,o.jsx)(n.p,{children:"Returns if attacher joint supports hard attach"}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Definition"})}),"\n",(0,o.jsxs)(n.blockquote,{children:["\n",(0,o.jsx)(n.p,{children:"getIsHardAttachAllowed(integer jointDescIndex)"}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n",(0,o.jsx)(n.table,{children:(0,o.jsx)(n.thead,{children:(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.th,{children:"integer"}),(0,o.jsx)(n.th,{children:"jointDescIndex"}),(0,o.jsx)(n.th,{children:"index of joint"})]})})}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Return Values"})}),"\n\n\n\n\n\n\n\n\n",(0,o.jsx)(n.table,{children:(0,o.jsx)(n.thead,{children:(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.th,{children:"integer"}),(0,o.jsx)(n.th,{children:"supportsHardAttach"}),(0,o.jsx)(n.th,{children:"attacher joint supports hard attach"})]})})}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Code"})}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-lua",children:"function AttacherJoints:getIsHardAttachAllowed(jointDescIndex)\n    local spec = self.spec_attacherJoints\n\n    return spec.attacherJoints[jointDescIndex].supportsHardAttach\nend\n\n"})}),"\n",(0,o.jsx)(n.h3,{id:"getisreadyforautomatedtraintravel",children:"getIsReadyForAutomatedTrainTravel"}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Description"})}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Definition"})}),"\n",(0,o.jsxs)(n.blockquote,{children:["\n",(0,o.jsx)(n.p,{children:"getIsReadyForAutomatedTrainTravel()"}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,o.jsx)(n.table,{children:(0,o.jsx)(n.thead,{children:(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.th,{children:"any"}),(0,o.jsx)(n.th,{children:"superFunc"})]})})}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Code"})}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-lua",children:"function AttacherJoints:getIsReadyForAutomatedTrainTravel(superFunc)\n    local spec = self.spec_attacherJoints\n    for _,implement in pairs(spec.attachedImplements) do\n        local object = implement.object\n        if object ~ = nil and object.getIsReadyForAutomatedTrainTravel ~ = nil then\n            if not object:getIsReadyForAutomatedTrainTravel() then\n                return false\n            end\n        end\n    end\n\n    return superFunc( self )\nend\n\n"})}),"\n",(0,o.jsx)(n.h3,{id:"getissmoothattachupdateallowed",children:"getIsSmoothAttachUpdateAllowed"}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Description"})}),"\n",(0,o.jsxs)(n.blockquote,{children:["\n",(0,o.jsx)(n.p,{children:"Returns if smooth attach joint update is allowed"}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Definition"})}),"\n",(0,o.jsxs)(n.blockquote,{children:["\n",(0,o.jsx)(n.p,{children:"getIsSmoothAttachUpdateAllowed()"}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,o.jsx)(n.table,{children:(0,o.jsx)(n.thead,{children:(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.th,{children:"any"}),(0,o.jsx)(n.th,{children:"implement"})]})})}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Code"})}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-lua",children:"function AttacherJoints:getIsSmoothAttachUpdateAllowed(implement)\n    return true\nend\n\n"})}),"\n",(0,o.jsx)(n.h3,{id:"getistipsideavailable",children:"getIsTipSideAvailable"}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Description"})}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Definition"})}),"\n",(0,o.jsxs)(n.blockquote,{children:["\n",(0,o.jsx)(n.p,{children:"getIsTipSideAvailable()"}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,o.jsxs)(n.table,{children:[(0,o.jsx)(n.thead,{children:(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.th,{children:"any"}),(0,o.jsx)(n.th,{children:"superFunc"})]})}),(0,o.jsx)(n.tbody,{children:(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:"any"}),(0,o.jsx)(n.td,{children:"sideIndex"})]})})]}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Code"})}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-lua",children:"function AttacherJoints:getIsTipSideAvailable(superFunc, sideIndex)\n    if not superFunc( self , sideIndex) then\n        return false\n    end\n\n    local spec = self.spec_trailer\n    local tipSide = spec.tipSides[sideIndex]\n    if tipSide ~ = nil then\n        if tipSide.disablingAttacherJointNodes ~ = nil then\n            tipSide.disablingAttacherJointIndices = { }\n            for _, jointNode in ipairs(tipSide.disablingAttacherJointNodes) do\n                local jointIndex = self:getAttacherJointIndexByNode(jointNode)\n                if jointIndex ~ = nil then\n                    table.insert(tipSide.disablingAttacherJointIndices, jointIndex)\n                end\n            end\n\n            if #tipSide.disablingAttacherJointIndices = = 0 then\n                tipSide.disablingAttacherJointIndices = nil\n            end\n        end\n\n        if tipSide.disablingAttacherJointIndices ~ = nil then\n            for _, jointIndex in ipairs(tipSide.disablingAttacherJointIndices) do\n                if self:getImplementFromAttacherJointIndex(jointIndex) ~ = nil then\n                    return false\n                end\n            end\n        end\n    end\n\n    return true\nend\n\n"})}),"\n",(0,o.jsx)(n.h3,{id:"getiswheelfoliagedestructionallowed",children:"getIsWheelFoliageDestructionAllowed"}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Description"})}),"\n",(0,o.jsxs)(n.blockquote,{children:["\n",(0,o.jsx)(n.p,{children:"Returns true if foliage destruction is allowed"}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Definition"})}),"\n",(0,o.jsxs)(n.blockquote,{children:["\n",(0,o.jsx)(n.p,{children:"getIsWheelFoliageDestructionAllowed()"}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,o.jsxs)(n.table,{children:[(0,o.jsx)(n.thead,{children:(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.th,{children:"any"}),(0,o.jsx)(n.th,{children:"superFunc"})]})}),(0,o.jsx)(n.tbody,{children:(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:"any"}),(0,o.jsx)(n.td,{children:"wheel"})]})})]}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Return Values"})}),"\n\n\n\n\n\n\n\n\n",(0,o.jsx)(n.table,{children:(0,o.jsx)(n.thead,{children:(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.th,{children:"any"}),(0,o.jsx)(n.th,{children:"isAllowed"}),(0,o.jsx)(n.th,{children:"tfoliage destruction is allowed"})]})})}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Code"})}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-lua",children:"function AttacherJoints:getIsWheelFoliageDestructionAllowed(superFunc, wheel)\n    if not superFunc( self , wheel) then\n        return false\n    end\n\n    local spec = self.spec_attacherJoints\n    for _,implement in pairs(spec.attachedImplements) do\n        local object = implement.object\n        if object ~ = nil then\n            if object.getBlockFoliageDestruction ~ = nil then\n                if object:getBlockFoliageDestruction() then\n                    return false\n                end\n            end\n        end\n    end\n\n    return true\nend\n\n"})}),"\n",(0,o.jsx)(n.h3,{id:"getjointmovedown",children:"getJointMoveDown"}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Description"})}),"\n",(0,o.jsxs)(n.blockquote,{children:["\n",(0,o.jsx)(n.p,{children:"Returns the current joint move down state"}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Definition"})}),"\n",(0,o.jsxs)(n.blockquote,{children:["\n",(0,o.jsx)(n.p,{children:"getJointMoveDown(integer jointDescIndex)"}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n",(0,o.jsx)(n.table,{children:(0,o.jsx)(n.thead,{children:(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.th,{children:"integer"}),(0,o.jsx)(n.th,{children:"jointDescIndex"}),(0,o.jsx)(n.th,{children:"index of joint desc"})]})})}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Return Values"})}),"\n\n\n\n\n\n\n\n\n",(0,o.jsx)(n.table,{children:(0,o.jsx)(n.thead,{children:(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.th,{children:"integer"}),(0,o.jsx)(n.th,{children:"moveDown"}),(0,o.jsx)(n.th,{children:"move down"})]})})}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Code"})}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-lua",children:"function AttacherJoints:getJointMoveDown(jointDescIndex)\n    local jointDesc = self.spec_attacherJoints.attacherJoints[jointDescIndex]\n    if jointDesc.allowsLowering then\n        return jointDesc.moveDown\n    end\n\n    return false\nend\n\n"})}),"\n",(0,o.jsx)(n.h3,{id:"getobjectfromimplementindex",children:"getObjectFromImplementIndex"}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Description"})}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Definition"})}),"\n",(0,o.jsxs)(n.blockquote,{children:["\n",(0,o.jsx)(n.p,{children:"getObjectFromImplementIndex()"}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,o.jsx)(n.table,{children:(0,o.jsx)(n.thead,{children:(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.th,{children:"any"}),(0,o.jsx)(n.th,{children:"implementIndex"})]})})}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Code"})}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-lua",children:"function AttacherJoints:getObjectFromImplementIndex(implementIndex)\n    local spec = self.spec_attacherJoints\n    local attachedImplement = spec.attachedImplements[implementIndex]\n    if attachedImplement ~ = nil then\n        return attachedImplement.object\n    end\n    return nil\nend\n\n"})}),"\n",(0,o.jsx)(n.h3,{id:"getpowertakeoffconfigindex",children:"getPowerTakeOffConfigIndex"}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Description"})}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Definition"})}),"\n",(0,o.jsxs)(n.blockquote,{children:["\n",(0,o.jsx)(n.p,{children:"getPowerTakeOffConfigIndex()"}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,o.jsx)(n.table,{children:(0,o.jsx)(n.thead,{children:(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.th,{children:"any"}),(0,o.jsx)(n.th,{children:"superFunc"})]})})}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Code"})}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-lua",children:'function AttacherJoints:getPowerTakeOffConfigIndex(superFunc)\n    local index = superFunc( self )\n    index = self.xmlFile:getValue( "vehicle.attacherJoints#powerTakeOffConfigId" , index)\n\n    if self.configurations[ "attacherJoint" ] ~ = nil then\n        local configKey = string.format( "vehicle.attacherJoints.attacherJointConfigurations.attacherJointConfiguration(%d)" , self.configurations[ "attacherJoint" ] - 1 )\n        index = self.xmlFile:getValue(configKey .. "#powerTakeOffConfigId" , index)\n    end\n\n    return index\nend\n\n'})}),"\n",(0,o.jsx)(n.h3,{id:"getrequirespower",children:"getRequiresPower"}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Description"})}),"\n",(0,o.jsxs)(n.blockquote,{children:["\n",(0,o.jsx)(n.p,{children:"Returns if the vehicle is currently requiring power for a certain activity (e.g. for unloading via the pipe) - this\ncan be used to automatically try to enable the power (e.g. motor turn on)"}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Definition"})}),"\n",(0,o.jsxs)(n.blockquote,{children:["\n",(0,o.jsx)(n.p,{children:"getRequiresPower()"}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,o.jsx)(n.table,{children:(0,o.jsx)(n.thead,{children:(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.th,{children:"any"}),(0,o.jsx)(n.th,{children:"superFunc"})]})})}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Code"})}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-lua",children:"function AttacherJoints:getRequiresPower(superFunc)\n    local spec = self.spec_attacherJoints\n    for _, implement in pairs(spec.attachedImplements) do\n        if implement.object ~ = nil then\n            if implement.object:getRequiresPower() then\n                return true\n            end\n        end\n    end\n\n    return superFunc( self )\nend\n\n"})}),"\n",(0,o.jsx)(n.h3,{id:"getselectedimplement",children:"getSelectedImplement"}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Description"})}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Definition"})}),"\n",(0,o.jsxs)(n.blockquote,{children:["\n",(0,o.jsx)(n.p,{children:"getSelectedImplement()"}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Code"})}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-lua",children:"function AttacherJoints:getSelectedImplement()\n    local spec = self.spec_attacherJoints\n\n    -- check if implement is still attached\n        if spec.selectedImplement ~ = nil then\n            if spec.selectedImplement.object:getAttacherVehicle() ~ = self then\n                return nil\n            end\n        end\n\n        return spec.selectedImplement\n    end\n\n"})}),"\n",(0,o.jsx)(n.h3,{id:"getshowattachcontrolbaraction",children:"getShowAttachControlBarAction"}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Description"})}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Definition"})}),"\n",(0,o.jsxs)(n.blockquote,{children:["\n",(0,o.jsx)(n.p,{children:"getShowAttachControlBarAction()"}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Code"})}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-lua",children:"function AttacherJoints:getShowAttachControlBarAction()\n    if self:getIsAIActive() then\n        return false\n    end\n\n    local spec = self.spec_attacherJoints\n    local info = spec.attachableInfo\n\n    local selectedVehicle = self:getSelectedVehicle()\n    if info.attacherVehicle = = nil then\n        if selectedVehicle ~ = nil and not selectedVehicle.isDeleted then\n            if selectedVehicle.getAttacherVehicle ~ = nil and selectedVehicle:getAttacherVehicle() ~ = nil then\n                return true\n            end\n        end\n    elseif selectedVehicle = = nil then\n            return true\n        end\n\n        if info.attachable ~ = nil and info.attacherVehicle = = self then\n            return true\n        end\n\n        return false\n    end\n\n"})}),"\n",(0,o.jsx)(n.h3,{id:"gettotalmass",children:"getTotalMass"}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Description"})}),"\n",(0,o.jsxs)(n.blockquote,{children:["\n",(0,o.jsx)(n.p,{children:"Returns total mass of vehicle (optional including attached vehicles)"}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Definition"})}),"\n",(0,o.jsxs)(n.blockquote,{children:["\n",(0,o.jsx)(n.p,{children:"getTotalMass(boolean onlyGivenVehicle, )"}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,o.jsxs)(n.table,{children:[(0,o.jsx)(n.thead,{children:(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.th,{children:"boolean"}),(0,o.jsx)(n.th,{children:"onlyGivenVehicle"}),(0,o.jsx)(n.th,{children:"use only the given vehicle, if false or nil it includes all attachables"})]})}),(0,o.jsx)(n.tbody,{children:(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:"any"}),(0,o.jsx)(n.td,{children:"onlyGivenVehicle"}),(0,o.jsx)(n.td,{})]})})]}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Return Values"})}),"\n\n\n\n\n\n\n\n\n",(0,o.jsx)(n.table,{children:(0,o.jsx)(n.thead,{children:(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.th,{children:"any"}),(0,o.jsx)(n.th,{children:"totalMass"}),(0,o.jsx)(n.th,{children:"total mass"})]})})}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Code"})}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-lua",children:"function AttacherJoints:getTotalMass(superFunc, onlyGivenVehicle)\n    local spec = self.spec_attacherJoints\n    local mass = superFunc( self )\n\n    if onlyGivenVehicle = = nil or not onlyGivenVehicle then\n        for _, implement in pairs(spec.attachedImplements) do\n            local object = implement.object\n            if object ~ = nil then\n                mass = mass + object:getTotalMass(onlyGivenVehicle)\n            end\n        end\n    end\n\n    return mass\nend\n\n"})}),"\n",(0,o.jsx)(n.h3,{id:"groundheightnodecheckcallback",children:"groundHeightNodeCheckCallback"}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Description"})}),"\n",(0,o.jsxs)(n.blockquote,{children:["\n",(0,o.jsx)(n.p,{children:"Callback used when raycast hits an object."}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Definition"})}),"\n",(0,o.jsxs)(n.blockquote,{children:["\n",(0,o.jsx)(n.p,{children:"groundHeightNodeCheckCallback(integer hitObjectId, float x, float y, float z, float distance, float nx, float ny,\nfloat nz, integer subShapeIndex, integer shapeId, boolean isLast)"}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,o.jsxs)(n.table,{children:[(0,o.jsx)(n.thead,{children:(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.th,{children:"integer"}),(0,o.jsx)(n.th,{children:"hitObjectId"}),(0,o.jsx)(n.th,{children:"scenegraph object id"})]})}),(0,o.jsxs)(n.tbody,{children:[(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:"float"}),(0,o.jsx)(n.td,{children:"x"}),(0,o.jsx)(n.td,{children:"world x hit position"})]}),(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:"float"}),(0,o.jsx)(n.td,{children:"y"}),(0,o.jsx)(n.td,{children:"world y hit position"})]}),(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:"float"}),(0,o.jsx)(n.td,{children:"z"}),(0,o.jsx)(n.td,{children:"world z hit position"})]}),(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:"float"}),(0,o.jsx)(n.td,{children:"distance"}),(0,o.jsx)(n.td,{children:"distance at which the cast hit the object"})]}),(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:"float"}),(0,o.jsx)(n.td,{children:"nx"}),(0,o.jsx)(n.td,{children:"normal x direction"})]}),(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:"float"}),(0,o.jsx)(n.td,{children:"ny"}),(0,o.jsx)(n.td,{children:"normal y direction"})]}),(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:"float"}),(0,o.jsx)(n.td,{children:"nz"}),(0,o.jsx)(n.td,{children:"normal z direction"})]}),(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:"integer"}),(0,o.jsx)(n.td,{children:"subShapeIndex"}),(0,o.jsx)(n.td,{children:"sub shape index"})]}),(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:"integer"}),(0,o.jsx)(n.td,{children:"shapeId"}),(0,o.jsx)(n.td,{children:"id of shape"})]}),(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:"boolean"}),(0,o.jsx)(n.td,{children:"isLast"}),(0,o.jsx)(n.td,{children:"is last hit"})]})]})]}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Return Values"})}),"\n\n\n\n\n\n\n\n\n",(0,o.jsx)(n.table,{children:(0,o.jsx)(n.thead,{children:(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.th,{children:"boolean"}),(0,o.jsx)(n.th,{children:"return"}),(0,o.jsx)(n.th,{children:"false to stop raycast"})]})})}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Code"})}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-lua",children:"function AttacherJoints:groundHeightNodeCheckCallback(hitObjectId, x, y, z, distance, nx, ny, nz, subShapeIndex, shapeId, isLast)\n    if self.isDeleted then\n        return\n    end\n\n    local checkData = self.spec_attacherJoints.groundHeightNodeCheckData\n\n    if hitObjectId ~ = 0 then\n        if getRigidBodyType(hitObjectId) = = RigidBodyType.STATIC then\n            if distance < checkData.minDistance then\n                --#debug if VehicleDebug.state = = VehicleDebug.DEBUG then\n                    --#debug DebugGizmo.renderAtPosition(x, y, z, 0, 0, 1, 0, 1, 0)\n                    --#debug end\n\n                    checkData.raycastDistance = checkData.currentRaycastDistance\n                    checkData.minDistance = distance\n                    checkData.hit = true\n\n                    checkData.raycastWorldPos[ 1 ] = checkData.currentRaycastWorldPos[ 1 ]\n                    checkData.raycastWorldPos[ 2 ] = checkData.currentRaycastWorldPos[ 2 ]\n                    checkData.raycastWorldPos[ 3 ] = checkData.currentRaycastWorldPos[ 3 ]\n\n                    checkData.raycastWorldDir[ 1 ] = checkData.currentRaycastWorldDir[ 1 ]\n                    checkData.raycastWorldDir[ 2 ] = checkData.currentRaycastWorldDir[ 2 ]\n                    checkData.raycastWorldDir[ 3 ] = checkData.currentRaycastWorldDir[ 3 ]\n\n                    checkData.jointTransformPos[ 1 ] = checkData.currentJointTransformPos[ 1 ]\n                    checkData.jointTransformPos[ 2 ] = checkData.currentJointTransformPos[ 2 ]\n                    checkData.jointTransformPos[ 3 ] = checkData.currentJointTransformPos[ 3 ]\n                end\n            else\n                    if not isLast then\n                        return true\n                    end\n                end\n            end\n\n            checkData.index = checkData.index + 1\n            if checkData.index > #checkData.heightNodes then\n                self:finishGroundHeightNodeCheck()\n            else\n                    checkData.isDirty = true\n                end\n\n                return false\n            end\n\n"})}),"\n",(0,o.jsx)(n.h3,{id:"handlelowerimplementbyattacherjointindex",children:"handleLowerImplementByAttacherJointIndex"}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Description"})}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Definition"})}),"\n",(0,o.jsxs)(n.blockquote,{children:["\n",(0,o.jsx)(n.p,{children:"handleLowerImplementByAttacherJointIndex()"}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,o.jsxs)(n.table,{children:[(0,o.jsx)(n.thead,{children:(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.th,{children:"any"}),(0,o.jsx)(n.th,{children:"attacherJointIndex"})]})}),(0,o.jsx)(n.tbody,{children:(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:"any"}),(0,o.jsx)(n.td,{children:"direction"})]})})]}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Code"})}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-lua",children:"function AttacherJoints:handleLowerImplementByAttacherJointIndex(attacherJointIndex, direction)\n    if attacherJointIndex ~ = nil then\n        local implement = self:getImplementByJointDescIndex(attacherJointIndex)\n        if implement ~ = nil then\n            local object = implement.object\n            local attacherJoints = self:getAttacherJoints()\n            local attacherJoint = attacherJoints[attacherJointIndex]\n\n            local allowsLowering, warning = object:getAllowsLowering()\n            if allowsLowering and attacherJoint.allowsLowering then\n                if direction = = nil then\n                    direction = not attacherJoint.moveDown\n                end\n                self:setJointMoveDown(implement.jointDescIndex, direction, false )\n            elseif not allowsLowering and warning ~ = nil then\n                    g_currentMission:showBlinkingWarning(warning, 2000 )\n                end\n            end\n        end\n    end\n\n"})}),"\n",(0,o.jsx)(n.h3,{id:"handlelowerimplementevent",children:"handleLowerImplementEvent"}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Description"})}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Definition"})}),"\n",(0,o.jsxs)(n.blockquote,{children:["\n",(0,o.jsx)(n.p,{children:"handleLowerImplementEvent()"}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,o.jsxs)(n.table,{children:[(0,o.jsx)(n.thead,{children:(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.th,{children:"any"}),(0,o.jsx)(n.th,{children:"vehicle"})]})}),(0,o.jsx)(n.tbody,{children:(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:"any"}),(0,o.jsx)(n.td,{children:"direction"})]})})]}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Code"})}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-lua",children:"function AttacherJoints:handleLowerImplementEvent(vehicle, direction)\n    local selectedVehicle = self:getSelectedVehicle()\n    if vehicle = = nil and selectedVehicle = = self then\n        local spec = self.spec_attacherJoints\n        if #spec.attachedImplements = = 1 then\n            vehicle = spec.attachedImplements[ 1 ].object\n        end\n    end\n\n    local implement = self:getImplementByObject(vehicle or selectedVehicle)\n    if implement ~ = nil then\n        local object = implement.object\n        if object ~ = nil and object.getAttacherVehicle ~ = nil then\n\n            local attacherVehicle = object:getAttacherVehicle()\n            if attacherVehicle ~ = nil then\n\n                local attacherJointIndex = attacherVehicle:getAttacherJointIndexFromObject(object)\n                attacherVehicle:handleLowerImplementByAttacherJointIndex(attacherJointIndex, direction)\n            end\n        end\n    end\nend\n\n"})}),"\n",(0,o.jsx)(n.h3,{id:"hardattachimplement",children:"hardAttachImplement"}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Description"})}),"\n",(0,o.jsxs)(n.blockquote,{children:["\n",(0,o.jsx)(n.p,{children:"Hard attach implement"}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Definition"})}),"\n",(0,o.jsxs)(n.blockquote,{children:["\n",(0,o.jsx)(n.p,{children:"hardAttachImplement(table implement)"}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n",(0,o.jsx)(n.table,{children:(0,o.jsx)(n.thead,{children:(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.th,{children:"table"}),(0,o.jsx)(n.th,{children:"implement"}),(0,o.jsx)(n.th,{children:"implement to attach"})]})})}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Code"})}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-lua",children:"function AttacherJoints:hardAttachImplement(implement)\n    local spec = self.spec_attacherJoints\n\n    local implements = { }\n    local attachedImplements\n    if implement.object.getAttachedImplements ~ = nil then\n        attachedImplements = implement.object:getAttachedImplements()\n    end\n    if attachedImplements ~ = nil then\n        for i = 1 , #attachedImplements do\n            local impl = attachedImplements[i]\n\n            local object = impl.object\n            local jointDescIndex = impl.jointDescIndex\n            local jointDesc = implement.object.spec_attacherJoints.attacherJoints[jointDescIndex]\n            local inputJointDescIndex = object.spec_attachable.inputAttacherJointDescIndex\n            local moveDown = jointDesc.moveDown\n\n            table.insert(implements, { object = object, implementIndex = i, jointDescIndex = jointDescIndex, inputJointDescIndex = inputJointDescIndex, moveDown = moveDown } )\n        end\n\n        for i = 1 , #attachedImplements do\n            implement.object:detachImplement( 1 , true )\n        end\n    end\n\n    local attacherJoint = spec.attacherJoints[implement.jointDescIndex]\n    local implementJoint = implement.object.spec_attachable.attacherJoint\n\n    local baseVehicleComponentNode = self:getParentComponent(attacherJoint.jointTransform)\n    local attachedVehicleComponentNode = implement.object:getParentComponent(implement.object.spec_attachable.attacherJoint.node)\n\n    -- remove all components from physics\n    local wasAddedToPhysics = self.isAddedToPhysics\n    if wasAddedToPhysics then\n        local currentVehicle = self\n        while currentVehicle ~ = nil do\n            currentVehicle:removeFromPhysics()\n            currentVehicle = currentVehicle.attacherVehicle\n        end\n        implement.object:removeFromPhysics()\n    end\n\n    -- set valid baseVehicle compound\n    if spec.attacherVehicle = = nil then\n        setIsCompound(baseVehicleComponentNode, true )\n    end\n    -- set attachedVehicle to compound child\n    setIsCompoundChild(attachedVehicleComponentNode, true )\n\n    -- set direction and local position\n    local dirX, dirY, dirZ = localDirectionToLocal(attachedVehicleComponentNode, implementJoint.node, 0 , 0 , 1 )\n    local upX, upY, upZ = localDirectionToLocal(attachedVehicleComponentNode, implementJoint.node, 0 , 1 , 0 )\n    setDirection(attachedVehicleComponentNode, dirX, dirY, dirZ, upX, upY, upZ)\n    local x,y,z = localToLocal(attachedVehicleComponentNode, implementJoint.node, 0 , 0 , 0 )\n    setTranslation(attachedVehicleComponentNode, x, y, z)\n    link(attacherJoint.jointTransform, attachedVehicleComponentNode)\n\n    -- link visual and set to correct position\n    if implementJoint.visualNode ~ = nil and attacherJoint.jointTransformVisual ~ = nil then\n        dirX, dirY, dirZ = localDirectionToLocal(implementJoint.visualNode, implementJoint.node, 0 , 0 , 1 )\n        upX, upY, upZ = localDirectionToLocal(implementJoint.visualNode, implementJoint.node, 0 , 1 , 0 )\n        setDirection(implementJoint.visualNode, dirX, dirY, dirZ, upX, upY, upZ)\n        x,y,z = localToLocal(implementJoint.visualNode, implementJoint.node, 0 , 0 , 0 )\n        setTranslation(implementJoint.visualNode, x, y, z)\n        link(attacherJoint.jointTransformVisual, implementJoint.visualNode)\n    end\n\n    implement.object.spec_attachable.isHardAttached = true\n\n    -- add to physics again\n    if wasAddedToPhysics then\n        local currentVehicle = self\n        while currentVehicle ~ = nil do\n            currentVehicle:addToPhysics()\n            currentVehicle = currentVehicle.attacherVehicle\n        end\n    end\n\n    -- set new joint rootNodes\n    for _, attacherJointToUpdate in pairs(implement.object.spec_attacherJoints.attacherJoints) do\n        attacherJointToUpdate.rootNode = baseVehicleComponentNode\n    end\n\n    for _, impl in pairs(implements) do\n        implement.object:attachImplement(impl.object, impl.inputJointDescIndex, impl.jointDescIndex, true , impl.implementIndex, impl.moveDown, true )\n    end\n\n    if self.isServer then\n        self:setMassDirty()\n        self:raiseDirtyFlags( self.vehicleDirtyFlag)\n    end\n\n    return true\nend\n\n"})}),"\n",(0,o.jsx)(n.h3,{id:"harddetachimplement",children:"hardDetachImplement"}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Description"})}),"\n",(0,o.jsxs)(n.blockquote,{children:["\n",(0,o.jsx)(n.p,{children:"Hard detach implement"}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Definition"})}),"\n",(0,o.jsxs)(n.blockquote,{children:["\n",(0,o.jsx)(n.p,{children:"hardDetachImplement(table implement)"}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n",(0,o.jsx)(n.table,{children:(0,o.jsx)(n.thead,{children:(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.th,{children:"table"}),(0,o.jsx)(n.th,{children:"implement"}),(0,o.jsx)(n.th,{children:"implement to detach"})]})})}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Code"})}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-lua",children:"function AttacherJoints:hardDetachImplement(implement)\n    -- restore original joint rootNode\n    for _, attacherJoint in pairs(implement.object.spec_attacherJoints.attacherJoints) do\n        attacherJoint.rootNode = attacherJoint.rootNodeBackup\n    end\n\n    local implementJoint = implement.object.spec_attachable.attacherJoint\n\n    local attachedVehicleComponentNode = implement.object:getParentComponent(implementJoint.node)\n\n    local wasAddedToPhysics = self.isAddedToPhysics\n    if wasAddedToPhysics then\n        local currentVehicle = self\n        while currentVehicle ~ = nil do\n            currentVehicle:removeFromPhysics()\n            currentVehicle = currentVehicle.attacherVehicle\n        end\n    end\n\n    setIsCompound(attachedVehicleComponentNode, true )\n\n    local x,y,z = getWorldTranslation(attachedVehicleComponentNode)\n    setTranslation(attachedVehicleComponentNode, x,y,z)\n    local dirX, dirY, dirZ = localDirectionToWorld(implement.object.rootNode, 0 , 0 , 1 )\n    local upX, upY, upZ = localDirectionToWorld(implement.object.rootNode, 0 , 1 , 0 )\n    setDirection(attachedVehicleComponentNode, dirX, dirY, dirZ, upX, upY, upZ)\n    link(getRootNode(), attachedVehicleComponentNode)\n\n    if implementJoint.visualNode ~ = nil and getParent(implementJoint.visualNode) ~ = implementJoint.visualNodeData.parent then\n        link(implementJoint.visualNodeData.parent, implementJoint.visualNode, implementJoint.visualNodeData.index)\n        setRotation(implementJoint.visualNode, implementJoint.visualNodeData.rotation[ 1 ], implementJoint.visualNodeData.rotation[ 2 ], implementJoint.visualNodeData.rotation[ 3 ])\n        setTranslation(implementJoint.visualNode, implementJoint.visualNodeData.translation[ 1 ], implementJoint.visualNodeData.translation[ 2 ], implementJoint.visualNodeData.translation[ 3 ])\n    end\n\n    if wasAddedToPhysics then\n        local currentVehicle = self\n        while currentVehicle ~ = nil do\n            currentVehicle:addToPhysics()\n            currentVehicle = currentVehicle.attacherVehicle\n        end\n        implement.object:addToPhysics()\n    end\n\n    implement.object.spec_attachable.isHardAttached = false\n\n    if self.isServer then\n        self:setMassDirty()\n        self:raiseDirtyFlags( self.vehicleDirtyFlag)\n    end\n\n    return true\nend\n\n"})}),"\n",(0,o.jsx)(n.h3,{id:"initspecialization",children:"initSpecialization"}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Description"})}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Definition"})}),"\n",(0,o.jsxs)(n.blockquote,{children:["\n",(0,o.jsx)(n.p,{children:"initSpecialization()"}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Code"})}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-lua",children:'function AttacherJoints.initSpecialization()\n    g_vehicleConfigurationManager:addConfigurationType( "attacherJoint" , g_i18n:getText( "configuration_attacherJoint" ), "attacherJoints" , VehicleConfigurationItem )\n\n    local schema = Vehicle.xmlSchema\n    schema:setXMLSpecializationType( "AttacherJoints" )\n\n    AttacherJoints.registerAttacherJointXMLPaths(schema, "vehicle.attacherJoints" )\n\n    SoundManager.registerSampleXMLPaths(schema, "vehicle.attacherJoints.sounds" , "hydraulic" )\n    SoundManager.registerSampleXMLPaths(schema, "vehicle.attacherJoints.sounds" , "attach" )\n    SoundManager.registerSampleXMLPaths(schema, "vehicle.attacherJoints.sounds" , "detach" )\n\n    schema:register(XMLValueType.FLOAT, "vehicle.attacherJoints#comboDuration" , "Combo duration" , 2 )\n\n    schema:register(XMLValueType.INT, "vehicle.attacherJoints#connectionHoseConfigId" , "Connection hose configuration index to use" )\n    schema:register(XMLValueType.INT, "vehicle.attacherJoints#powerTakeOffConfigId" , "Power take off configuration index to use" )\n    schema:register(XMLValueType.INT, "vehicle.attacherJoints.attacherJointConfigurations.attacherJointConfiguration(?)#connectionHoseConfigId" , "Connection hose configuration index to use" )\n    schema:register(XMLValueType.INT, "vehicle.attacherJoints.attacherJointConfigurations.attacherJointConfiguration(?)#powerTakeOffConfigId" , "Power take off configuration index to use" )\n\n    schema:register(XMLValueType.FLOAT, "vehicle.attacherJoints#maxUpdateDistance" , "Max.distance to vehicle root to update attacher joint graphics" , AttacherJoints.DEFAULT_MAX_UPDATE_DISTANCE)\n\n    schema:register(XMLValueType.VECTOR_N, Dashboard.GROUP_XML_KEY .. "#attacherJointIndices" , "Group is only active if something is attached to those joints(List if indices of the attacher joint in xml)" )\n        schema:register(XMLValueType.NODE_INDICES, Dashboard.GROUP_XML_KEY .. "#attacherJointNodes" , "Group is only active if something is attached to those joints(List of attacherJoint nodes)" )\n\n            schema:register(XMLValueType.VECTOR_N, Attachable.INPUT_ATTACHERJOINT_XML_KEY .. ".heightNode(?)#disablingAttacherJointIndices" , "Attacher joint indices that disable height node if something is attached" )\n                schema:register(XMLValueType.VECTOR_N, Attachable.INPUT_ATTACHERJOINT_CONFIG_XML_KEY .. ".heightNode(?)#disablingAttacherJointIndices" , "Attacher joint indices that disable height node if something is attached" )\n\n                    schema:register(XMLValueType.NODE_INDICES, "vehicle.trailer.trailerConfigurations.trailerConfiguration(?).trailer.tipSide(?)#disablingAttacherJointNodes" , "Attacher joint nodes that disable the tip side if something is attached" )\n\n                        schema:register(XMLValueType.NODE_INDICES, FillUnit.FILL_UNIT_XML_KEY .. "#disablingAttacherJointNodes" , "Attacher joint nodes that disable the filling if something is attached" )\n\n                            schema:addDelayedRegistrationFunc( "ConnectionHoses:targetNode" , function (cSchema, cKey)\n                                cSchema:register(XMLValueType.NODE_INDICES, cKey .. "#blockedByAttacherJointNodes" , "List of attacher joints that block the usage of this hose target node" )\n                            end )\n\n                            Dashboard.addDelayedRegistrationFunc(schema, function (cSchema, cKey)\n                                cSchema:register(XMLValueType.NODE_INDEX, cKey .. "#attacherJointNode" , "Node of the attacher joint to use" )\n                                cSchema:register(XMLValueType.NODE_INDICES, cKey .. "#attacherJointNodes" , "List of attacher joint indices to use(first active one is used)" )\n                            end )\n\n                            Dashboard.registerDashboardXMLPaths(schema, "vehicle.attacherJoints.dashboards" , { "bottomArmPosition" , "bottomArmPositionMin" , "bottomArmPositionMax" } )\n\n                            schema:setXMLSpecializationType()\n\n                            local schemaSavegame = Vehicle.xmlSchemaSavegame\n                            schemaSavegame:register(XMLValueType.INT, "vehicles.vehicle(?).attacherJoints#comboDirection" , "Current combo direction" )\n\n                            schemaSavegame:register(XMLValueType.INT, "vehicles.vehicle(?).attacherJoints.attachedImplement(?)#jointIndex" , "Index of attacherJoint" )\n                            schemaSavegame:register(XMLValueType.BOOL, "vehicles.vehicle(?).attacherJoints.attachedImplement(?)#moveDown" , "Attacher joint is lowered or not" )\n                            schemaSavegame:register(XMLValueType.STRING, "vehicles.vehicle(?).attacherJoints.attachedImplement(?)#attachedVehicleUniqueId" , "Unique id of attached vehicle" )\n                            schemaSavegame:register(XMLValueType.INT, "vehicles.vehicle(?).attacherJoints.attachedImplement(?)#inputJointIndex" , "Index of input attacher joint on the attached vehicle" )\n\n                            schemaSavegame:register(XMLValueType.INT, "vehicles.vehicle(?).attacherJoints.attacherJoint(?)#jointIndex" , "Index of attacherJoint" )\n                            schemaSavegame:register(XMLValueType.BOOL, "vehicles.vehicle(?).attacherJoints.attacherJoint(?)#isBlocked" , "Attacher joint is blocked or not" )\n\n                            schemaSavegame:register(XMLValueType.INT, "vehicles.attachments(?)#rootVehicleId" , "Root vehicle id" )\n                            schemaSavegame:register(XMLValueType.INT, "vehicles.attachments(?).attachment(?)#attachmentId" , "Attachment vehicle id" )\n                            schemaSavegame:register(XMLValueType.INT, "vehicles.attachments(?).attachment(?)#inputJointDescIndex" , "Index of input attacher joint" , 1 )\n                            schemaSavegame:register(XMLValueType.INT, "vehicles.attachments(?).attachment(?)#jointIndex" , "Index of attacher joint" )\n                            schemaSavegame:register(XMLValueType.BOOL, "vehicles.attachments(?).attachment(?)#moveDown" , "Attachment lowered or lifted" )\n                        end\n\n'})}),"\n",(0,o.jsx)(n.h3,{id:"isdetachallowed",children:"isDetachAllowed"}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Description"})}),"\n",(0,o.jsxs)(n.blockquote,{children:["\n",(0,o.jsx)(n.p,{children:"Returns true if detach is allowed"}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Definition"})}),"\n",(0,o.jsxs)(n.blockquote,{children:["\n",(0,o.jsx)(n.p,{children:"isDetachAllowed()"}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,o.jsx)(n.table,{children:(0,o.jsx)(n.thead,{children:(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.th,{children:"any"}),(0,o.jsx)(n.th,{children:"superFunc"})]})})}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Return Values"})}),"\n\n\n\n\n\n\n\n\n",(0,o.jsx)(n.table,{children:(0,o.jsx)(n.thead,{children:(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.th,{children:"any"}),(0,o.jsx)(n.th,{children:"detachAllowed"}),(0,o.jsx)(n.th,{children:"detach is allowed"})]})})}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Code"})}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-lua",children:"function AttacherJoints:isDetachAllowed(superFunc)\n    local detachAllowed, warning, showWarning = superFunc( self )\n    if not detachAllowed then\n        return detachAllowed, warning, showWarning\n    end\n\n    local spec = self.spec_attacherJoints\n    for attacherJointIndex, attacherJoint in ipairs(spec.attacherJoints) do\n        if not attacherJoint.allowDetachingWhileLifted then\n            if not attacherJoint.moveDown then\n                local implement = self:getImplementByJointDescIndex(attacherJointIndex)\n                if implement ~ = nil then\n                    local inputAttacherJoint = implement.object:getInputAttacherJointByJointDescIndex(implement.inputJointDescIndex)\n                    if inputAttacherJoint ~ = nil and not inputAttacherJoint.forceAllowDetachWhileLifted then\n                        return false , string.format(spec.texts.lowerImplementFirst, implement.object.typeDesc)\n                    end\n                end\n            end\n        end\n    end\n\n    return true\nend\n\n"})}),"\n",(0,o.jsx)(n.h3,{id:"loadattacherjointfromxml",children:"loadAttacherJointFromXML"}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Description"})}),"\n",(0,o.jsxs)(n.blockquote,{children:["\n",(0,o.jsx)(n.p,{children:"Load attacher joint from xml"}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Definition"})}),"\n",(0,o.jsxs)(n.blockquote,{children:["\n",(0,o.jsx)(n.p,{children:"loadAttacherJointFromXML(table attacherJoint, integer fileId, string baseName, integer index)"}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,o.jsxs)(n.table,{children:[(0,o.jsx)(n.thead,{children:(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.th,{children:"table"}),(0,o.jsx)(n.th,{children:"attacherJoint"}),(0,o.jsx)(n.th,{children:"attacherJoint"})]})}),(0,o.jsxs)(n.tbody,{children:[(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:"integer"}),(0,o.jsx)(n.td,{children:"fileId"}),(0,o.jsx)(n.td,{children:"xml file id"})]}),(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:"string"}),(0,o.jsx)(n.td,{children:"baseName"}),(0,o.jsx)(n.td,{children:"baseName"})]}),(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:"integer"}),(0,o.jsx)(n.td,{children:"index"}),(0,o.jsx)(n.td,{children:"index of attacher joint"})]})]})]}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Code"})}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-lua",children:'function AttacherJoints:loadAttacherJointFromXML(attacherJoint, xmlFile, baseName, index)\n    local spec = self.spec_attacherJoints\n\n    XMLUtil.checkDeprecatedXMLElements(xmlFile, baseName .. "#index" , baseName .. "#node" ) -- FS17\n    XMLUtil.checkDeprecatedXMLElements(xmlFile, baseName .. "#indexVisual" , baseName .. "#nodeVisual" ) -- FS17\n    XMLUtil.checkDeprecatedXMLElements(xmlFile, baseName .. "#ptoOutputNode" , "vehicle.powerTakeOffs.output" ) -- FS17 to FS19\n    XMLUtil.checkDeprecatedXMLElements(xmlFile, baseName .. "#lowerDistanceToGround" , baseName .. ".distanceToGround#lower" ) -- FS17 to FS19\n    XMLUtil.checkDeprecatedXMLElements(xmlFile, baseName .. "#upperDistanceToGround" , baseName .. ".distanceToGround#upper" ) -- FS17 to FS19\n    XMLUtil.checkDeprecatedXMLElements(xmlFile, baseName .. "#rotationNode" , baseName .. ".rotationNode#node" ) -- FS17 to FS19\n    XMLUtil.checkDeprecatedXMLElements(xmlFile, baseName .. "#upperRotation" , baseName .. ".rotationNode#upperRotation" ) -- FS17 to FS19\n    XMLUtil.checkDeprecatedXMLElements(xmlFile, baseName .. "#lowerRotation" , baseName .. ".rotationNode#lowerRotation" ) -- FS17 to FS19\n    XMLUtil.checkDeprecatedXMLElements(xmlFile, baseName .. "#startRotation" , baseName .. ".rotationNode#startRotation" ) -- FS17 to FS19\n    XMLUtil.checkDeprecatedXMLElements(xmlFile, baseName .. "#rotationNode2" , baseName .. ".rotationNode2#node" ) -- FS17 to FS19\n    XMLUtil.checkDeprecatedXMLElements(xmlFile, baseName .. "#upperRotation2" , baseName .. ".rotationNode2#upperRotation" ) -- FS17 to FS19\n    XMLUtil.checkDeprecatedXMLElements(xmlFile, baseName .. "#lowerRotation2" , baseName .. ".rotationNode2#lowerRotation" ) -- FS17 to FS19\n    XMLUtil.checkDeprecatedXMLElements(xmlFile, baseName .. "#transNode" , baseName .. ".transNode#node" ) -- FS17 to FS19\n    XMLUtil.checkDeprecatedXMLElements(xmlFile, baseName .. "#transNodeMinY" , baseName .. ".transNode#minY" ) -- FS17 to FS19\n    XMLUtil.checkDeprecatedXMLElements(xmlFile, baseName .. "#transNodeMaxY" , baseName .. ".transNode#maxY" ) -- FS17 to FS19\n    XMLUtil.checkDeprecatedXMLElements(xmlFile, baseName .. "#transNodeHeight" , baseName .. ".transNode#height" ) -- FS17 to FS19\n    XMLUtil.checkDeprecatedXMLElements(xmlFile, baseName .. ".additionalAttachment#attacherJointDirection" , baseName .. "#direction" ) -- FS22 to FS25\n\n    local node = xmlFile:getValue(baseName .. "#node" , nil , self.components, self.i3dMappings)\n    if node = = nil then\n        Logging.xmlWarning( self.xmlFile, "Missing node for attacherJoint \'%s\'" , baseName)\n            return false\n        end\n\n        attacherJoint.jointTransform = node\n        attacherJoint.jointComponent = self:getParentComponent(attacherJoint.jointTransform)\n\n        attacherJoint.jointTransformVisual = xmlFile:getValue(baseName .. "#nodeVisual" , nil , self.components, self.i3dMappings)\n        attacherJoint.supportsHardAttach = xmlFile:getValue(baseName .. "#supportsHardAttach" , true )\n\n        attacherJoint.jointOrigOffsetComponent = { localToLocal(attacherJoint.jointComponent, attacherJoint.jointTransform, 0 , 0 , 0 ) }\n        attacherJoint.jointOrigRotOffsetComponent = { localRotationToLocal(attacherJoint.jointComponent, attacherJoint.jointTransform, 0 , 0 , 0 ) }\n\n        attacherJoint.jointTransformOrig = createTransformGroup(getName(node) .. "_jointTransformOrig" )\n        link(getParent(node), attacherJoint.jointTransformOrig)\n        setTranslation(attacherJoint.jointTransformOrig, getTranslation(node))\n        setRotation(attacherJoint.jointTransformOrig, getRotation(node))\n\n        local jointTypeStr = xmlFile:getValue(baseName .. "#jointType" )\n        local jointType\n        if jointTypeStr ~ = nil then\n            jointType = AttacherJoints.jointTypeNameToInt[jointTypeStr]\n            if jointType = = nil then\n                Logging.xmlWarning( self.xmlFile, "Invalid jointType \'%s\' for attacherJoint \'%s\'!" , tostring(jointTypeStr), baseName)\n                end\n            end\n            if jointType = = nil then\n                jointType = AttacherJoints.JOINTTYPE_IMPLEMENT\n            end\n            attacherJoint.jointType = jointType\n\n            local subTypeStr = xmlFile:getValue(baseName .. ".subType#name" )\n            if not string.isNilOrWhitespace(subTypeStr) then\n                attacherJoint.subTypes = string.split(subTypeStr, " " )\n            end\n\n            local brandRestrictionStr = xmlFile:getValue(baseName .. ".subType#brandRestriction" )\n            if brandRestrictionStr ~ = nil and string.trim(brandRestrictionStr) ~ = "" then\n                attacherJoint.brandRestrictions = string.split(brandRestrictionStr, " " )\n\n                for i = 1 , #attacherJoint.brandRestrictions do\n                    local brand = g_brandManager:getBrandByName(attacherJoint.brandRestrictions[i])\n                    if brand ~ = nil then\n                        attacherJoint.brandRestrictions[i] = brand\n                    else\n                            Logging.xmlError(xmlFile, "Unknown brand \'%s\' in \'%s\'" , attacherJoint.brandRestrictions[i], baseName .. ".subType#brandRestriction" )\n                            attacherJoint.brandRestrictions = nil\n                            break\n                        end\n                    end\n                end\n\n                local vehicleRestrictionStr = xmlFile:getValue(baseName .. ".subType#vehicleRestriction" )\n                if vehicleRestrictionStr ~ = nil and string.trim(vehicleRestrictionStr) ~ = "" then\n                    attacherJoint.vehicleRestrictions = string.split(vehicleRestrictionStr, " " )\n                end\n\n                attacherJoint.subTypeShowWarning = xmlFile:getValue(baseName .. ".subType#subTypeShowWarning" , true )\n\n                attacherJoint.allowsJointLimitMovement = xmlFile:getValue(baseName .. "#allowsJointLimitMovement" , true )\n                attacherJoint.allowsLowering = xmlFile:getValue(baseName .. "#allowsLowering" , true )\n                attacherJoint.isDefaultLowered = xmlFile:getValue(baseName .. "#isDefaultLowered" , false )\n\n                attacherJoint.allowDetachingWhileLifted = xmlFile:getValue(baseName .. "#allowDetachingWhileLifted" , true )\n                attacherJoint.allowFoldingWhileAttached = xmlFile:getValue(baseName .. "#allowFoldingWhileAttached" , true )\n\n                if jointType = = AttacherJoints.JOINTTYPE_TRAILER or jointType = = AttacherJoints.JOINTTYPE_TRAILERLOW or jointType = = AttacherJoints.JOINTTYPE_TRAILERCAR then\n                    attacherJoint.allowsLowering = false\n                end\n\n                attacherJoint.canTurnOnImplement = xmlFile:getValue(baseName .. "#canTurnOnImplement" , true )\n\n                local rotationNode = xmlFile:getValue(baseName .. ".rotationNode#node" , nil , self.components, self.i3dMappings)\n                if rotationNode ~ = nil then\n                    attacherJoint.rotationNode = rotationNode\n\n                    attacherJoint.lowerRotation = xmlFile:getValue(baseName .. ".rotationNode#lowerRotation" , "0 0 0" , true )\n                    attacherJoint.upperRotation = xmlFile:getValue(baseName .. ".rotationNode#upperRotation" , nil , true ) or { getRotation(rotationNode) }\n                    attacherJoint.rotX, attacherJoint.rotY, attacherJoint.rotZ = xmlFile:getValue(baseName .. ".rotationNode#startRotation" , nil )\n                    if attacherJoint.rotX = = nil then\n                        attacherJoint.rotX, attacherJoint.rotY, attacherJoint.rotZ = getRotation(rotationNode)\n                    end\n\n                    local lowerValues = { attacherJoint.lowerRotation[ 1 ], attacherJoint.lowerRotation[ 2 ], attacherJoint.lowerRotation[ 3 ] }\n                    local upperValues = { attacherJoint.upperRotation[ 1 ], attacherJoint.upperRotation[ 2 ], attacherJoint.upperRotation[ 3 ] }\n\n                    for i = 1 , 3 do\n                        local l = lowerValues[i]\n                        local u = upperValues[i]\n\n                        if l > u then\n                            upperValues[i] = l\n                            lowerValues[i] = u\n                        end\n                    end\n\n                    attacherJoint.rotX = math.clamp(attacherJoint.rotX, lowerValues[ 1 ], upperValues[ 1 ])\n                    attacherJoint.rotY = math.clamp(attacherJoint.rotY, lowerValues[ 2 ], upperValues[ 2 ])\n                    attacherJoint.rotZ = math.clamp(attacherJoint.rotZ, lowerValues[ 3 ], upperValues[ 3 ])\n                end\n\n                local rotationNode2 = xmlFile:getValue(baseName .. ".rotationNode2#node" , nil , self.components, self.i3dMappings)\n                if rotationNode2 ~ = nil then\n                    attacherJoint.rotationNode2 = rotationNode2\n\n                    attacherJoint.lowerRotation2 = xmlFile:getValue(baseName .. ".rotationNode2#lowerRotation" , nil , true ) or { - attacherJoint.lowerRotation[ 1 ], - attacherJoint.lowerRotation[ 2 ], - attacherJoint.lowerRotation[ 3 ] }\n                    attacherJoint.upperRotation2 = xmlFile:getValue(baseName .. ".rotationNode2#upperRotation" , nil , true ) or { - attacherJoint.upperRotation[ 1 ], - attacherJoint.upperRotation[ 2 ], - attacherJoint.upperRotation[ 3 ] }\n                end\n\n                attacherJoint.transNode = xmlFile:getValue(baseName .. ".transNode#node" , nil , self.components, self.i3dMappings)\n                if attacherJoint.transNode ~ = nil then\n                    attacherJoint.transNodeOrgTrans = { getTranslation(attacherJoint.transNode) }\n                    attacherJoint.transNodeHeight = xmlFile:getValue(baseName .. ".transNode#height" , 0.12 )\n                    attacherJoint.transNodeMinY = xmlFile:getValue(baseName .. ".transNode#minY" )\n                    attacherJoint.transNodeMaxY = xmlFile:getValue(baseName .. ".transNode#maxY" )\n\n                    attacherJoint.transNodeDependentBottomArm = xmlFile:getValue(baseName .. ".transNode.dependentBottomArm#node" , nil , self.components, self.i3dMappings)\n                    attacherJoint.transNodeDependentBottomArmThreshold = xmlFile:getValue(baseName .. ".transNode.dependentBottomArm#threshold" , math.huge)\n                    attacherJoint.transNodeDependentBottomArmRotation = xmlFile:getValue(baseName .. ".transNode.dependentBottomArm#rotation" , "0 0 0" , true )\n                end\n\n                -- lowerDistanceToGround is a mandatory attribute if a rotationNode is available\n                    if (attacherJoint.rotationNode ~ = nil or attacherJoint.transNode ~ = nil ) and xmlFile:getValue(baseName .. ".distanceToGround#lower" ) = = nil then\n                        Logging.xmlWarning( self.xmlFile, "Missing \'.distanceToGround#lower\' for attacherJoint \'%s\'.Use console command \'gsVehicleAnalyze\' to get correct values!" , baseName)\n                        end\n                        attacherJoint.lowerDistanceToGround = xmlFile:getValue(baseName .. ".distanceToGround#lower" , 0.7 )\n\n                        -- upperDistanceToGround is a mandatory attribute if a rotationNode is available\n                            if (attacherJoint.rotationNode ~ = nil or attacherJoint.transNode ~ = nil ) and xmlFile:getValue(baseName .. ".distanceToGround#upper" ) = = nil then\n                                Logging.xmlWarning( self.xmlFile, "Missing \'.distanceToGround#upper\' for attacherJoint \'%s\'.Use console command \'gsVehicleAnalyze\' to get correct values!" , baseName)\n                                end\n                                attacherJoint.upperDistanceToGround = xmlFile:getValue(baseName .. ".distanceToGround#upper" , 1.0 )\n\n                                if attacherJoint.lowerDistanceToGround > attacherJoint.upperDistanceToGround then\n                                    Logging.xmlWarning( self.xmlFile, "distanceToGround#lower may not be larger than distanceToGround#upper for attacherJoint \'%s\'.Switching values!" , baseName)\n                                        local copy = attacherJoint.lowerDistanceToGround\n                                        attacherJoint.lowerDistanceToGround = attacherJoint.upperDistanceToGround\n                                        attacherJoint.upperDistanceToGround = copy\n                                    end\n\n                                    attacherJoint.lowerRotationOffset = xmlFile:getValue(baseName .. "#lowerRotationOffset" , 0 )\n                                    attacherJoint.upperRotationOffset = xmlFile:getValue(baseName .. "#upperRotationOffset" , 0 )\n\n                                    attacherJoint.dynamicLowerRotLimit = xmlFile:getValue(baseName .. "#dynamicLowerRotLimit" , false )\n\n                                    attacherJoint.lockDownRotLimit = xmlFile:getValue(baseName .. "#lockDownRotLimit" , false )\n                                    attacherJoint.lockUpRotLimit = xmlFile:getValue(baseName .. "#lockUpRotLimit" , false )\n                                    -- only use translimit in +y.Set -y to 0\n                                    attacherJoint.lockDownTransLimit = xmlFile:getValue(baseName .. "#lockDownTransLimit" , true )\n                                    attacherJoint.lockUpTransLimit = xmlFile:getValue(baseName .. "#lockUpTransLimit" , false )\n\n                                    local lowerRotLimitStr = "20 20 20"\n                                    if jointType ~ = AttacherJoints.JOINTTYPE_IMPLEMENT then\n                                        lowerRotLimitStr = "0 0 0"\n                                    end\n                                    local lx, ly, lz = xmlFile:getValue(baseName .. "#lowerRotLimit" , lowerRotLimitStr)\n                                    attacherJoint.lowerRotLimit = {\n                                    math.abs(lx or 20 ),\n                                    math.abs(ly or 20 ),\n                                    math.abs(lz or 20 )\n                                    }\n\n                                    local ux, uy, uz = xmlFile:getValue(baseName .. "#upperRotLimit" )\n                                    attacherJoint.upperRotLimit = {\n                                    math.abs(ux or lx or 20 ),\n                                    math.abs(uy or ly or 20 ),\n                                    math.abs(uz or lz or 20 )\n                                    }\n\n                                    local lowerTransLimitStr = "0.5 0.5 0.5"\n                                    if jointType ~ = AttacherJoints.JOINTTYPE_IMPLEMENT then\n                                        lowerTransLimitStr = "0 0 0"\n                                    end\n                                    lx, ly, lz = xmlFile:getValue(baseName .. "#lowerTransLimit" , lowerTransLimitStr)\n                                    attacherJoint.lowerTransLimit = {\n                                    math.abs(lx or 0 ),\n                                    math.abs(ly or 0 ),\n                                    math.abs(lz or 0 )\n                                    }\n\n                                    ux, uy, uz = xmlFile:getValue(baseName .. "#upperTransLimit" )\n                                    attacherJoint.upperTransLimit = {\n                                    math.abs(ux or lx or 0 ),\n                                    math.abs(uy or ly or 0 ),\n                                    math.abs(uz or lz or 0 )\n                                    }\n\n                                    attacherJoint.jointPositionOffset = xmlFile:getValue(baseName .. "#jointPositionOffset" , "0 0 0" , true )\n\n                                    attacherJoint.rotLimitSpring = xmlFile:getValue( baseName .. "#rotLimitSpring" , "0 0 0" , true )\n                                    attacherJoint.rotLimitDamping = xmlFile:getValue( baseName .. "#rotLimitDamping" , "1 1 1" , true )\n                                    attacherJoint.rotLimitForceLimit = xmlFile:getValue( baseName .. "#rotLimitForceLimit" , "-1 -1 -1" , true )\n\n                                    attacherJoint.transLimitSpring = xmlFile:getValue( baseName .. "#transLimitSpring" , "0 0 0" , true )\n                                    attacherJoint.transLimitDamping = xmlFile:getValue( baseName .. "#transLimitDamping" , "1 1 1" , true )\n                                    attacherJoint.transLimitForceLimit = xmlFile:getValue( baseName .. "#transLimitForceLimit" , "-1 -1 -1" , true )\n\n                                    attacherJoint.moveDefaultTime = xmlFile:getValue(baseName .. "#moveTime" , 0.5 ) * 1000\n                                    attacherJoint.moveTime = attacherJoint.moveDefaultTime\n\n                                    attacherJoint.disabledByAttacherJoints = xmlFile:getValue(baseName .. "#disabledByAttacherJoints" , nil , true )\n\n                                    attacherJoint.enableCollision = xmlFile:getValue(baseName .. "#enableCollision" , false )\n\n                                    attacherJoint.topArm = AttacherJointTopArm.loadFromVehicleXML( self , baseName .. ".topArm" )\n\n                                    local bottomArmRotationNode = xmlFile:getValue(baseName .. ".bottomArm#rotationNode" , nil , self.components, self.i3dMappings)\n                                    local translationNode = xmlFile:getValue(baseName .. ".bottomArm#translationNode" , nil , self.components, self.i3dMappings)\n                                    local referenceNode = xmlFile:getValue(baseName .. ".bottomArm#referenceNode" , nil , self.components, self.i3dMappings)\n                                    if bottomArmRotationNode ~ = nil then\n                                        local bottomArm = { }\n                                        bottomArm.rotationNode = bottomArmRotationNode\n                                        bottomArm.rotationNodeDir = createTransformGroup( "rotationNodeDirTemp" )\n                                        link(getParent(bottomArmRotationNode), bottomArm.rotationNodeDir)\n                                        setTranslation(bottomArm.rotationNodeDir, getTranslation(bottomArmRotationNode))\n                                        setRotation(bottomArm.rotationNodeDir, getRotation(bottomArmRotationNode))\n                                        bottomArm.lastDirection = { 0 , 0 , 0 }\n                                        bottomArm.rotX, bottomArm.rotY, bottomArm.rotZ = xmlFile:getValue(baseName .. ".bottomArm#startRotation" , nil )\n                                        if bottomArm.rotX = = nil then\n                                            bottomArm.rotX, bottomArm.rotY, bottomArm.rotZ = getRotation(bottomArmRotationNode)\n                                        end\n\n                                        bottomArm.interpolatorGet = function ()\n                                            return getRotation(bottomArm.rotationNode)\n                                        end\n                                        bottomArm.interpolatorSet = function (x, y, z)\n                                            setRotation(bottomArm.rotationNode, x, y, z)\n                                            if self.setMovingToolDirty ~ = nil then\n                                                self:setMovingToolDirty(bottomArm.rotationNode)\n                                            end\n                                        end\n                                        bottomArm.interpolatorFinished = function (_)\n                                            bottomArm.bottomArmInterpolating = false\n                                        end\n\n                                        bottomArm.interpolatorKey = bottomArmRotationNode .. "rotation"\n                                        bottomArm.bottomArmInterpolating = false\n\n                                        if translationNode ~ = nil and referenceNode ~ = nil then\n                                            bottomArm.translationNode = translationNode\n                                            bottomArm.referenceNode = referenceNode\n\n                                            local x,y,z = getTranslation(translationNode)\n                                            if math.abs(x) > = 0.0001 or math.abs(y) > = 0.0001 or math.abs(z) > = 0.0001 then\n                                                Logging.xmlWarning( self.xmlFile, "BottomArm translation of attacherJoint \'%s\' is not 0/0/0!" , baseName)\n                                            end\n                                            bottomArm.referenceDistance = calcDistanceFrom(referenceNode, translationNode)\n                                        end\n                                        bottomArm.zScale = math.sign(xmlFile:getValue(baseName .. ".bottomArm#zScale" , 1 ))\n                                        bottomArm.lockDirection = xmlFile:getValue(baseName .. ".bottomArm#lockDirection" , true )\n                                        bottomArm.resetSpeed = xmlFile:getValue(baseName .. ".bottomArm#resetSpeed" , 45 )\n                                        bottomArm.updateReferenceDistance = xmlFile:getValue(baseName .. ".bottomArm#updateReferenceDistance" , false )\n\n                                        bottomArm.jointPositionNode = xmlFile:getValue(baseName .. ".bottomArm#jointPositionNode" , nil , self.components, self.i3dMappings)\n\n                                        bottomArm.toggleVisibility = xmlFile:getValue(baseName .. ".bottomArm#toggleVisibility" , false )\n                                        if bottomArm.toggleVisibility then\n                                            setVisibility(bottomArm.rotationNode, false )\n                                        end\n\n                                        if jointType = = AttacherJoints.JOINTTYPE_IMPLEMENT then\n                                            local toolbarI3dFilename = Utils.getFilename(xmlFile:getValue(baseName .. ".toolbar#filename" , "$data/shared/assets/toolbars/toolbars.i3d" ), self.baseDirectory)\n                                            local arguments = {\n                                            bottomArm = bottomArm,\n                                            referenceNode = referenceNode\n                                            }\n                                            bottomArm.sharedLoadRequestIdToolbar = self:loadSubSharedI3DFile(toolbarI3dFilename, false , false , self.onBottomArmToolbarI3DLoaded, self , arguments)\n                                        end\n\n                                        bottomArm.minWidth, bottomArm.maxWidth = AttacherJoints.LOWER_LINK_WIDTH_BY_CATEGORY[ 2 ], AttacherJoints.LOWER_LINK_WIDTH_BY_CATEGORY[ 2 ]\n                                        local categoryRange = xmlFile:getValue(baseName .. ".bottomArm#categoryRange" , "1 4" , true )\n                                        if categoryRange ~ = nil and #categoryRange > = 1 then\n                                            bottomArm.minWidth = AttacherJoints.LOWER_LINK_WIDTH_BY_CATEGORY[categoryRange[ 1 ]] or bottomArm.minWidth\n                                            bottomArm.maxWidth = AttacherJoints.LOWER_LINK_WIDTH_BY_CATEGORY[categoryRange[ 2 ] or categoryRange[ 1 ]] or bottomArm.maxWidth\n                                        end\n\n                                        local widthRange = xmlFile:getValue(baseName .. ".bottomArm#widthRange" , nil , true )\n                                        if widthRange ~ = nil and #widthRange > = 1 then\n                                            bottomArm.minWidth = widthRange[ 1 ] or bottomArm.minWidth\n                                            bottomArm.maxWidth = widthRange[ 2 ] or widthRange[ 1 ] or bottomArm.maxWidth\n                                        end\n\n                                        if jointType = = AttacherJoints.JOINTTYPE_IMPLEMENT then\n                                            if not xmlFile:hasProperty(baseName .. ".bottomArm#categoryRange" ) and not xmlFile:hasProperty(baseName .. ".bottomArm#widthRange" ) then\n                                                Logging.xmlWarning(xmlFile, "Missing categoryRange or widthRange attribute for bottom arm in \'%s\'" , baseName)\n                                                end\n                                            end\n\n                                            bottomArm.armLeft = xmlFile:getValue(baseName .. ".bottomArm.armLeft#node" , nil , self.components, self.i3dMappings)\n                                            bottomArm.armLeftReferenceNode = xmlFile:getValue(baseName .. ".bottomArm.armLeft#referenceNode" , nil , self.components, self.i3dMappings)\n                                            if bottomArm.armLeft ~ = nil and bottomArm.armLeftReferenceNode ~ = nil then\n                                                bottomArm.armLeftLength = calcDistanceFrom(bottomArm.armLeft, bottomArm.armLeftReferenceNode)\n                                            end\n\n                                            bottomArm.armRight = xmlFile:getValue(baseName .. ".bottomArm.armRight#node" , nil , self.components, self.i3dMappings)\n                                            bottomArm.armRightReferenceNode = xmlFile:getValue(baseName .. ".bottomArm.armRight#referenceNode" , nil , self.components, self.i3dMappings)\n                                            if bottomArm.armRight ~ = nil and bottomArm.armRightReferenceNode ~ = nil then\n                                                bottomArm.armRightLength = calcDistanceFrom(bottomArm.armRight, bottomArm.armRightReferenceNode)\n                                            end\n\n                                            bottomArm.ballVisibility = xmlFile:getValue(baseName .. ".bottomArm#ballVisibility" , true )\n\n                                            if bottomArm.armLeft ~ = nil and bottomArm.armRight ~ = nil and bottomArm.referenceNode ~ = nil then\n                                                bottomArm.variableWidthAvailable = true\n                                                local defaultWidth\n\n                                                local defaultCategory = xmlFile:getValue(baseName .. ".bottomArm#defaultCategory" )\n                                                if defaultCategory ~ = nil then\n                                                    if defaultCategory > = 0 and defaultCategory < = 4 then\n                                                        defaultWidth = AttacherJoints.LOWER_LINK_WIDTH_BY_CATEGORY[defaultCategory]\n                                                    end\n                                                end\n\n                                                if defaultWidth = = nil then\n                                                    defaultWidth = xmlFile:getValue(baseName .. ".bottomArm#defaultWidth" )\n                                                end\n\n                                                if defaultWidth = = nil then\n                                                    local xOffset, _, _ = localToLocal(bottomArm.armLeftReferenceNode or bottomArm.armLeft, bottomArm.referenceNode, 0 , 0 , 0 )\n                                                    defaultWidth = math.abs(xOffset) * 2\n                                                end\n\n                                                bottomArm.defaultWidth = defaultWidth\n                                            else\n                                                    bottomArm.defaultWidth = (bottomArm.minWidth + bottomArm.maxWidth) * 0.5\n                                                end\n\n                                                if self.setMovingPartReferenceNode ~ = nil then\n                                                    bottomArm.leftNode = xmlFile:getValue(baseName .. ".bottomArm#leftNode" , nil , self.components, self.i3dMappings)\n                                                    bottomArm.rightNode = xmlFile:getValue(baseName .. ".bottomArm#rightNode" , nil , self.components, self.i3dMappings)\n                                                end\n\n                                                attacherJoint.bottomArm = bottomArm\n                                            end\n\n                                            if self.isClient then\n                                                attacherJoint.sampleAttach = g_soundManager:loadSampleFromXML(xmlFile, baseName, "attachSound" , self.baseDirectory, self.components, 1 , AudioGroup.VEHICLE, self.i3dMappings, self )\n                                                attacherJoint.sampleDetach = g_soundManager:loadSampleFromXML(xmlFile, baseName, "detachSound" , self.baseDirectory, self.components, 1 , AudioGroup.VEHICLE, self.i3dMappings, self )\n                                            end\n\n                                            attacherJoint.steeringBarLeftNode = xmlFile:getValue(baseName .. ".steeringBars#leftNode" , nil , self.components, self.i3dMappings)\n                                            attacherJoint.steeringBarRightNode = xmlFile:getValue(baseName .. ".steeringBars#rightNode" , nil , self.components, self.i3dMappings)\n                                            attacherJoint.steeringBarForceUsage = xmlFile:getValue(baseName .. ".steeringBars#forceUsage" , true )\n\n                                            if self.setMovingPartReferenceNode ~ = nil then\n                                                for _, key in self.xmlFile:iterator(baseName .. ".visualAlignNode" ) do\n                                                    local node = xmlFile:getValue(key .. "#node" , nil , self.components, self.i3dMappings)\n                                                    if node ~ = nil then\n                                                        if attacherJoint.visualAlignNodes = = nil then\n                                                            attacherJoint.visualAlignNodes = { }\n                                                        end\n\n                                                        local visualAlignNode = { }\n                                                        visualAlignNode.node = node\n                                                        visualAlignNode.delayedOnAttach = xmlFile:getValue(key .. "#delayedOnAttach" , true )\n\n                                                        table.insert(attacherJoint.visualAlignNodes, visualAlignNode)\n                                                    end\n                                                end\n                                            end\n\n                                            attacherJoint.visualNodes = xmlFile:getValue(baseName .. ".visuals#nodes" , nil , self.components, self.i3dMappings, true )\n                                            for i = 1 , #attacherJoint.visualNodes do\n                                                local visualNode = attacherJoint.visualNodes[i]\n\n                                                if spec.visualNodeToAttacherJoints[visualNode] = = nil then\n                                                    spec.visualNodeToAttacherJoints[visualNode] = { }\n                                                end\n\n                                                table.insert(spec.visualNodeToAttacherJoints[visualNode], attacherJoint)\n                                            end\n\n                                            attacherJoint.hideVisuals = xmlFile:getValue(baseName .. ".visuals#hide" , nil , self.components, self.i3dMappings, true )\n                                            for i = 1 , #attacherJoint.hideVisuals do\n                                                local hideNode = attacherJoint.hideVisuals[i]\n\n                                                if spec.hideVisualNodeToAttacherJoints[hideNode] = = nil then\n                                                    spec.hideVisualNodeToAttacherJoints[hideNode] = { }\n                                                end\n\n                                                table.insert(spec.hideVisualNodeToAttacherJoints[hideNode], attacherJoint)\n                                            end\n\n                                            attacherJoint.changeObjects = { }\n                                            ObjectChangeUtil.loadObjectChangeFromXML(xmlFile, baseName, attacherJoint.changeObjects, self.components, self )\n                                            ObjectChangeUtil.setObjectChanges(attacherJoint.changeObjects, false , self , self.setMovingToolDirty, true )\n                                            attacherJoint.delayedObjectChanges = xmlFile:getValue(baseName .. "#delayedObjectChanges" , true )\n                                            attacherJoint.delayedObjectChangesOnAttach = xmlFile:getValue(baseName .. "#delayedObjectChangesOnAttach" , false )\n\n                                            attacherJoint.additionalAttachment = { }\n\n                                            local _, _, zOffset = localToLocal(attacherJoint.jointTransform, self.rootNode, 0 , 0 , 0 )\n                                            attacherJoint.attacherJointDirection = xmlFile:getValue(baseName .. "#direction" , math.sign(zOffset))\n\n                                            attacherJoint.useTopLights = xmlFile:getValue(baseName .. "#useTopLights" , attacherJoint.attacherJointDirection = = 1 )\n\n                                            attacherJoint.rootNode = xmlFile:getValue(baseName .. "#rootNode" , self:getParentComponent(attacherJoint.jointTransform), self.components, self.i3dMappings)\n                                            attacherJoint.rootNodeBackup = attacherJoint.rootNode\n                                            attacherJoint.jointIndex = 0\n\n                                            attacherJoint.isBlocked = false\n                                            attacherJoint.comboTime = xmlFile:getValue(baseName .. "#comboTime" )\n\n                                            local schemaKey = baseName .. ".schema"\n                                            if xmlFile:hasProperty(schemaKey) then\n                                                local x, y = xmlFile:getValue(schemaKey .. "#position" )\n                                                if x = = nil then\n                                                    Logging.xmlWarning( self.xmlFile, "Missing values for \'%s\'" , schemaKey .. "#position" )\n                                                    else\n                                                            local liftedOffsetX, liftedOffsetY = xmlFile:getValue(schemaKey .. "#liftedOffset" , "0 5" )\n\n                                                            self.schemaOverlay:addAttacherJoint(\n                                                            x, y,\n                                                            xmlFile:getValue(schemaKey .. "#rotation" , 0 ),\n                                                            xmlFile:getValue(schemaKey .. "#invertX" , false ),\n                                                            liftedOffsetX, liftedOffsetY\n                                                            )\n                                                        end\n                                                    else\n                                                            Logging.xmlWarning( self.xmlFile, "Missing schema overlay attacherJoint \'%s\'!" , baseName)\n                                                        end\n\n                                                        return true\n                                                    end\n\n'})}),"\n",(0,o.jsx)(n.h3,{id:"loadattacherjointheightnode",children:"loadAttacherJointHeightNode"}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Description"})}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Definition"})}),"\n",(0,o.jsxs)(n.blockquote,{children:["\n",(0,o.jsx)(n.p,{children:"loadAttacherJointHeightNode()"}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,o.jsxs)(n.table,{children:[(0,o.jsx)(n.thead,{children:(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.th,{children:"any"}),(0,o.jsx)(n.th,{children:"superFunc"})]})}),(0,o.jsxs)(n.tbody,{children:[(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:"any"}),(0,o.jsx)(n.td,{children:"xmlFile"})]}),(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:"any"}),(0,o.jsx)(n.td,{children:"key"})]}),(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:"any"}),(0,o.jsx)(n.td,{children:"heightNode"})]}),(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:"any"}),(0,o.jsx)(n.td,{children:"attacherJointNode"})]})]})]}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Code"})}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-lua",children:'function AttacherJoints:loadAttacherJointHeightNode(superFunc, xmlFile, key, heightNode, attacherJointNode)\n    heightNode.disablingAttacherJointIndices = xmlFile:getValue(key .. "#disablingAttacherJointIndices" , "" , true )\n\n    return superFunc( self , xmlFile, key, heightNode, attacherJointNode)\nend\n\n'})}),"\n",(0,o.jsx)(n.h3,{id:"loadattachmentsfinished",children:"loadAttachmentsFinished"}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Description"})}),"\n",(0,o.jsxs)(n.blockquote,{children:["\n",(0,o.jsx)(n.p,{children:"Called after all attachments were loaded"}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Definition"})}),"\n",(0,o.jsxs)(n.blockquote,{children:["\n",(0,o.jsx)(n.p,{children:"loadAttachmentsFinished()"}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Code"})}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-lua",children:"function AttacherJoints:loadAttachmentsFinished()\n    -- apply loaded selection from savegame after all implemented were attached\n    if self.rootVehicle = = self then\n        if self.loadedSelectedObjectIndex ~ = nil then\n            local object = self.selectableObjects[ self.loadedSelectedObjectIndex]\n            if object ~ = nil then\n                self:setSelectedObject(object, self.loadedSubSelectedObjectIndex or 1 )\n            end\n\n            self.loadedSelectedObjectIndex = nil\n            self.loadedSubSelectedObjectIndex = nil\n        end\n    end\nend\n\n"})}),"\n",(0,o.jsx)(n.h3,{id:"loaddashboardgroupfromxml",children:"loadDashboardGroupFromXML"}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Description"})}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Definition"})}),"\n",(0,o.jsxs)(n.blockquote,{children:["\n",(0,o.jsx)(n.p,{children:"loadDashboardGroupFromXML()"}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,o.jsxs)(n.table,{children:[(0,o.jsx)(n.thead,{children:(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.th,{children:"any"}),(0,o.jsx)(n.th,{children:"superFunc"})]})}),(0,o.jsxs)(n.tbody,{children:[(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:"any"}),(0,o.jsx)(n.td,{children:"xmlFile"})]}),(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:"any"}),(0,o.jsx)(n.td,{children:"key"})]}),(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:"any"}),(0,o.jsx)(n.td,{children:"group"})]})]})]}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Code"})}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-lua",children:'function AttacherJoints:loadDashboardGroupFromXML(superFunc, xmlFile, key, group)\n    if not superFunc( self , xmlFile, key, group) then\n        return false\n    end\n\n    group.attacherJointIndices = { }\n\n    local attacherJointIndices = xmlFile:getValue(key .. "#attacherJointIndices" , nil , true )\n    if attacherJointIndices ~ = nil then\n        for _, attacherJointIndex in ipairs(attacherJointIndices) do\n            table.insert(group.attacherJointIndices, attacherJointIndex)\n        end\n    end\n\n    if #group.attacherJointIndices = = 0 then\n        group.attacherJointIndices = nil\n    end\n\n    group.attacherJointNodes = xmlFile:getValue(key .. "#attacherJointNodes" , nil , self.components, self.i3dMappings, true )\n    if #group.attacherJointNodes = = 0 then\n        group.attacherJointNodes = nil\n    end\n\n    return true\nend\n\n'})}),"\n",(0,o.jsx)(n.h3,{id:"loadfillunitfromxml",children:"loadFillUnitFromXML"}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Description"})}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Definition"})}),"\n",(0,o.jsxs)(n.blockquote,{children:["\n",(0,o.jsx)(n.p,{children:"loadFillUnitFromXML()"}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,o.jsxs)(n.table,{children:[(0,o.jsx)(n.thead,{children:(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.th,{children:"any"}),(0,o.jsx)(n.th,{children:"superFunc"})]})}),(0,o.jsxs)(n.tbody,{children:[(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:"any"}),(0,o.jsx)(n.td,{children:"xmlFile"})]}),(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:"any"}),(0,o.jsx)(n.td,{children:"key"})]}),(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:"any"}),(0,o.jsx)(n.td,{children:"entry"})]}),(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:"any"}),(0,o.jsx)(n.td,{children:"index"})]})]})]}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Code"})}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-lua",children:'function AttacherJoints:loadFillUnitFromXML(superFunc, xmlFile, key, entry, index)\n    if not superFunc( self , xmlFile, key, entry, index) then\n        return false\n    end\n\n    local disablingAttacherJointNodes = xmlFile:getValue(key .. "#disablingAttacherJointNodes" , nil , self.components, self.i3dMappings, true )\n    if #disablingAttacherJointNodes > 0 then\n        entry.disablingAttacherJointNodes = disablingAttacherJointNodes\n    end\n\n    return true\n\nend\n\n'})}),"\n",(0,o.jsx)(n.h3,{id:"loadhosetargetnode",children:"loadHoseTargetNode"}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Description"})}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Definition"})}),"\n",(0,o.jsxs)(n.blockquote,{children:["\n",(0,o.jsx)(n.p,{children:"loadHoseTargetNode()"}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,o.jsxs)(n.table,{children:[(0,o.jsx)(n.thead,{children:(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.th,{children:"any"}),(0,o.jsx)(n.th,{children:"superFunc"})]})}),(0,o.jsxs)(n.tbody,{children:[(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:"any"}),(0,o.jsx)(n.td,{children:"xmlFile"})]}),(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:"any"}),(0,o.jsx)(n.td,{children:"targetKey"})]}),(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:"any"}),(0,o.jsx)(n.td,{children:"entry"})]})]})]}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Code"})}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-lua",children:'function AttacherJoints:loadHoseTargetNode(superFunc, xmlFile, targetKey, entry)\n    if not superFunc( self , xmlFile, targetKey, entry) then\n        return false\n    end\n\n    local attacherJointNodes = xmlFile:getValue(targetKey .. "#blockedByAttacherJointNodes" , nil , self.components, self.i3dMappings, true )\n    if attacherJointNodes ~ = nil then\n        entry.blockedByAttacherJointIndices = attacherJointNodes\n    end\n\n    return true\nend\n\n'})}),"\n",(0,o.jsx)(n.h3,{id:"loadtipside",children:"loadTipSide"}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Description"})}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Definition"})}),"\n",(0,o.jsxs)(n.blockquote,{children:["\n",(0,o.jsx)(n.p,{children:"loadTipSide()"}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,o.jsxs)(n.table,{children:[(0,o.jsx)(n.thead,{children:(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.th,{children:"any"}),(0,o.jsx)(n.th,{children:"superFunc"})]})}),(0,o.jsxs)(n.tbody,{children:[(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:"any"}),(0,o.jsx)(n.td,{children:"xmlFile"})]}),(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:"any"}),(0,o.jsx)(n.td,{children:"key"})]}),(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:"any"}),(0,o.jsx)(n.td,{children:"entry"})]})]})]}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Code"})}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-lua",children:'function AttacherJoints:loadTipSide(superFunc, xmlFile, key, entry)\n    if not superFunc( self , xmlFile, key, entry) then\n        return false\n    end\n\n    local disablingAttacherJointNodes = xmlFile:getValue(key .. "#disablingAttacherJointNodes" , nil , self.components, self.i3dMappings, true )\n    if #disablingAttacherJointNodes > 0 then\n        entry.disablingAttacherJointNodes = disablingAttacherJointNodes\n    end\n\n    return true\nend\n\n'})}),"\n",(0,o.jsx)(n.h3,{id:"onactivate",children:"onActivate"}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Description"})}),"\n",(0,o.jsxs)(n.blockquote,{children:["\n",(0,o.jsx)(n.p,{children:"Called on activate"}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Definition"})}),"\n",(0,o.jsxs)(n.blockquote,{children:["\n",(0,o.jsx)(n.p,{children:"onActivate()"}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Code"})}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-lua",children:"function AttacherJoints:onActivate()\n    self:activateAttachments()\nend\n\n"})}),"\n",(0,o.jsx)(n.h3,{id:"onattacherjointsvehicleloaded",children:"onAttacherJointsVehicleLoaded"}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Description"})}),"\n",(0,o.jsxs)(n.blockquote,{children:["\n",(0,o.jsx)(n.p,{children:"Called when a new vehicle has been loaded"}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Definition"})}),"\n",(0,o.jsxs)(n.blockquote,{children:["\n",(0,o.jsx)(n.p,{children:"onAttacherJointsVehicleLoaded(table vehicle)"}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n",(0,o.jsx)(n.table,{children:(0,o.jsx)(n.thead,{children:(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.th,{children:"table"}),(0,o.jsx)(n.th,{children:"vehicle"}),(0,o.jsx)(n.th,{children:"vehicle object"})]})})}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Code"})}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-lua",children:"function AttacherJoints:onAttacherJointsVehicleLoaded(vehicle)\n    local spec = self.spec_attacherJoints\n\n    if spec.attachmentDataToLoad ~ = nil then\n        for i = #spec.attachmentDataToLoad, 1 , - 1 do\n            local attachmentData = spec.attachmentDataToLoad[i]\n            if attachmentData.attachedVehicleUniqueId = = vehicle:getUniqueId() then\n                self:attachImplement(vehicle, attachmentData.inputIndex, attachmentData.jointIndex, true , nil , attachmentData.moveDown, true , true )\n                self:setJointMoveDown(attachmentData.jointIndex, attachmentData.moveDown, true )\n\n                table.remove(spec.attachmentDataToLoad, i)\n            end\n        end\n\n        if #spec.attachmentDataToLoad = = 0 then\n            self:loadAttachmentsFinished()\n            spec.attachmentDataToLoad = nil\n\n            g_messageCenter:unsubscribe(MessageType.VEHICLE_LOADED, self )\n        end\n    else\n            g_messageCenter:unsubscribe(MessageType.VEHICLE_LOADED, self )\n        end\n    end\n\n"})}),"\n",(0,o.jsx)(n.h3,{id:"onbeaconlightsvisibilitychanged",children:"onBeaconLightsVisibilityChanged"}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Description"})}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Definition"})}),"\n",(0,o.jsxs)(n.blockquote,{children:["\n",(0,o.jsx)(n.p,{children:"onBeaconLightsVisibilityChanged()"}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,o.jsx)(n.table,{children:(0,o.jsx)(n.thead,{children:(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.th,{children:"any"}),(0,o.jsx)(n.th,{children:"visibility"})]})})}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Code"})}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-lua",children:"function AttacherJoints:onBeaconLightsVisibilityChanged(visibility)\n    local spec = self.spec_attacherJoints\n    for _, implement in pairs(spec.attachedImplements) do\n        local vehicle = implement.object\n        if vehicle ~ = nil and vehicle.setBeaconLightsVisibility ~ = nil then\n            vehicle:setBeaconLightsVisibility(visibility, true , true )\n        end\n    end\nend\n\n"})}),"\n",(0,o.jsx)(n.h3,{id:"onbottomarmtoolbari3dloaded",children:"onBottomArmToolbarI3DLoaded"}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Description"})}),"\n",(0,o.jsxs)(n.blockquote,{children:["\n",(0,o.jsx)(n.p,{children:"Called when toolbar was loaded"}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Definition"})}),"\n",(0,o.jsxs)(n.blockquote,{children:["\n",(0,o.jsx)(n.p,{children:"onBottomArmToolbarI3DLoaded(integer i3dNode, table args, )"}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,o.jsxs)(n.table,{children:[(0,o.jsx)(n.thead,{children:(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.th,{children:"integer"}),(0,o.jsx)(n.th,{children:"i3dNode"}),(0,o.jsx)(n.th,{children:"top arm i3d node"})]})}),(0,o.jsxs)(n.tbody,{children:[(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:"table"}),(0,o.jsx)(n.td,{children:"args"}),(0,o.jsx)(n.td,{children:"async arguments"})]}),(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:"any"}),(0,o.jsx)(n.td,{children:"args"}),(0,o.jsx)(n.td,{})]})]})]}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Code"})}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-lua",children:"function AttacherJoints:onBottomArmToolbarI3DLoaded(i3dNode, failedReason, args)\n    local bottomArm = args.bottomArm\n    local referenceNode = args.referenceNode\n\n    if i3dNode ~ = 0 then\n        local rootNode = getChildAt(i3dNode, 0 )\n        link(referenceNode, rootNode)\n        setTranslation(rootNode, 0 , 0 , 0 )\n        setVisibility(rootNode, false )\n\n        local activeIndex = AttacherJoints.getClosestLowerLinkCategoryIndex(bottomArm.defaultWidth or AttacherJoints.LOWER_LINK_WIDTH_BY_CATEGORY[ 2 ])\n\n        bottomArm.toolbarNode = rootNode\n        bottomArm.toolbars = { }\n        for index = 1 , getNumOfChildren(rootNode) do\n            local toolbar = getChildAt(rootNode, index - 1 )\n            setTranslation(toolbar, 0 , 0 , 0 )\n            setVisibility(toolbar, activeIndex = = index - 1 )\n\n            table.insert(bottomArm.toolbars, toolbar)\n        end\n\n        delete(i3dNode)\n    end\nend\n\n"})}),"\n",(0,o.jsx)(n.h3,{id:"onbrake",children:"onBrake"}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Description"})}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Definition"})}),"\n",(0,o.jsxs)(n.blockquote,{children:["\n",(0,o.jsx)(n.p,{children:"onBrake()"}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,o.jsx)(n.table,{children:(0,o.jsx)(n.thead,{children:(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.th,{children:"any"}),(0,o.jsx)(n.th,{children:"brakePedal"})]})})}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Code"})}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-lua",children:"function AttacherJoints:onBrake(brakePedal)\n    local spec = self.spec_attacherJoints\n    for _, implement in pairs(spec.attachedImplements) do\n        local vehicle = implement.object\n        if vehicle ~ = nil and vehicle.brake ~ = nil then\n            vehicle:brake(brakePedal)\n        end\n    end\nend\n\n"})}),"\n",(0,o.jsx)(n.h3,{id:"onbrakelightsvisibilitychanged",children:"onBrakeLightsVisibilityChanged"}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Description"})}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Definition"})}),"\n",(0,o.jsxs)(n.blockquote,{children:["\n",(0,o.jsx)(n.p,{children:"onBrakeLightsVisibilityChanged()"}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,o.jsx)(n.table,{children:(0,o.jsx)(n.thead,{children:(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.th,{children:"any"}),(0,o.jsx)(n.th,{children:"visibility"})]})})}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Code"})}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-lua",children:"function AttacherJoints:onBrakeLightsVisibilityChanged(visibility)\n    local spec = self.spec_attacherJoints\n    for _, implement in pairs(spec.attachedImplements) do\n        local vehicle = implement.object\n        if vehicle ~ = nil and vehicle.setBrakeLightsVisibility ~ = nil then\n            vehicle:setBrakeLightsVisibility(visibility)\n        end\n    end\nend\n\n"})}),"\n",(0,o.jsx)(n.h3,{id:"ondeactivate",children:"onDeactivate"}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Description"})}),"\n",(0,o.jsxs)(n.blockquote,{children:["\n",(0,o.jsx)(n.p,{children:"Called on deactivate"}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Definition"})}),"\n",(0,o.jsxs)(n.blockquote,{children:["\n",(0,o.jsx)(n.p,{children:"onDeactivate()"}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Code"})}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-lua",children:"function AttacherJoints:onDeactivate()\n    self:deactivateAttachments()\n    if self.isClient then\n        local spec = self.spec_attacherJoints\n        g_soundManager:stopSample(spec.samples.hydraulic)\n        spec.isHydraulicSamplePlaying = false\n    end\nend\n\n"})}),"\n",(0,o.jsx)(n.h3,{id:"ondelete",children:"onDelete"}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Description"})}),"\n",(0,o.jsxs)(n.blockquote,{children:["\n",(0,o.jsx)(n.p,{children:"Called on deleting"}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Definition"})}),"\n",(0,o.jsxs)(n.blockquote,{children:["\n",(0,o.jsx)(n.p,{children:"onDelete()"}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Code"})}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-lua",children:"function AttacherJoints:onDelete()\n    local spec = self.spec_attacherJoints\n\n    if spec.attacherJoints ~ = nil then\n        for _, jointDesc in pairs(spec.attacherJoints) do\n            g_soundManager:deleteSample(jointDesc.sampleAttach)\n            g_soundManager:deleteSample(jointDesc.sampleDetach)\n\n            if jointDesc.topArm ~ = nil then\n                jointDesc.topArm:delete()\n                jointDesc.topArm = nil\n            end\n\n            local bottomArm = jointDesc.bottomArm\n            if bottomArm ~ = nil then\n                if bottomArm.sharedLoadRequestIdToolbar ~ = nil then\n                    g_i3DManager:releaseSharedI3DFile(bottomArm.sharedLoadRequestIdToolbar)\n                    bottomArm.sharedLoadRequestIdToolbar = nil\n                end\n            end\n        end\n\n        g_soundManager:deleteSamples(spec.samples)\n    end\nend\n\n"})}),"\n",(0,o.jsx)(n.h3,{id:"onleavevehicle",children:"onLeaveVehicle"}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Description"})}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Definition"})}),"\n",(0,o.jsxs)(n.blockquote,{children:["\n",(0,o.jsx)(n.p,{children:"onLeaveVehicle()"}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Code"})}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-lua",children:'function AttacherJoints:onLeaveVehicle()\n    local spec = self.spec_attacherJoints\n    for _, implement in pairs(spec.attachedImplements) do\n        local vehicle = implement.object\n        if vehicle ~ = nil then\n            SpecializationUtil.raiseEvent(vehicle, "onLeaveRootVehicle" )\n        end\n    end\nend\n\n'})}),"\n",(0,o.jsx)(n.h3,{id:"onlightstypesmaskchanged",children:"onLightsTypesMaskChanged"}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Description"})}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Definition"})}),"\n",(0,o.jsxs)(n.blockquote,{children:["\n",(0,o.jsx)(n.p,{children:"onLightsTypesMaskChanged()"}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,o.jsx)(n.table,{children:(0,o.jsx)(n.thead,{children:(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.th,{children:"any"}),(0,o.jsx)(n.th,{children:"lightsTypesMask"})]})})}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Code"})}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-lua",children:"function AttacherJoints:onLightsTypesMaskChanged(lightsTypesMask)\n    -- execute only on server, as only he knows the correct additional light states\n    -- and can assemble the correct mask if the number of light types is different on the implement\n        if self.isServer then\n            local spec = self.spec_attacherJoints\n            for _, implement in pairs(spec.attachedImplements) do\n                local vehicle = implement.object\n                if vehicle ~ = nil and vehicle.setLightsTypesMask ~ = nil then\n                    vehicle:setLightsTypesMask(lightsTypesMask, true )\n                end\n            end\n        end\n    end\n\n"})}),"\n",(0,o.jsx)(n.h3,{id:"onload",children:"onLoad"}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Description"})}),"\n",(0,o.jsxs)(n.blockquote,{children:["\n",(0,o.jsx)(n.p,{children:"Called on loading"}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Definition"})}),"\n",(0,o.jsxs)(n.blockquote,{children:["\n",(0,o.jsx)(n.p,{children:"onLoad(table savegame)"}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n",(0,o.jsx)(n.table,{children:(0,o.jsx)(n.thead,{children:(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.th,{children:"table"}),(0,o.jsx)(n.th,{children:"savegame"}),(0,o.jsx)(n.th,{children:"savegame"})]})})}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Code"})}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-lua",children:'function AttacherJoints:onLoad(savegame)\n    local spec = self.spec_attacherJoints\n\n    spec.attacherJointCombos = { }\n    spec.attacherJointCombos.duration = self.xmlFile:getValue( "vehicle.attacherJoints#comboDuration" , 2 ) * 1000\n    spec.attacherJointCombos.currentTime = 0\n    spec.attacherJointCombos.direction = - 1\n    spec.attacherJointCombos.isRunning = false\n    spec.attacherJointCombos.joints = { }\n\n    spec.maxUpdateDistance = self.xmlFile:getValue( "vehicle.attacherJoints#maxUpdateDistance" , AttacherJoints.DEFAULT_MAX_UPDATE_DISTANCE)\n\n    spec.visualNodeToAttacherJoints = { }\n    spec.hideVisualNodeToAttacherJoints = { }\n\n    spec.attacherJoints = { }\n    local i = 0\n    while true do\n        local baseName = string.format( "vehicle.attacherJoints.attacherJoint(%d)" , i)\n        if not self.xmlFile:hasProperty(baseName) then\n            break\n        end\n        local attacherJoint = { }\n        if self:loadAttacherJointFromXML(attacherJoint, self.xmlFile, baseName, i) then\n            table.insert(spec.attacherJoints, attacherJoint)\n            attacherJoint.index = #spec.attacherJoints\n        end\n        i = i + 1\n    end\n\n    -- data structure to store information about eventually attachable vehicles\n    spec.attachableInfo = { }\n    spec.attachableInfo.attacherVehicle = nil\n    spec.attachableInfo.attacherVehicleJointDescIndex = nil\n    spec.attachableInfo.attachable = nil\n    spec.attachableInfo.attachableJointDescIndex = nil\n\n    spec.pendingAttachableInfo = { }\n    spec.pendingAttachableInfo.minDistance = math.huge\n    spec.pendingAttachableInfo.minDistanceY = math.huge\n    spec.pendingAttachableInfo.attacherVehicle = nil\n    spec.pendingAttachableInfo.attacherVehicleJointDescIndex = nil\n    spec.pendingAttachableInfo.attachable = nil\n    spec.pendingAttachableInfo.attachableJointDescIndex = nil\n    spec.pendingAttachableInfo.warning = nil\n\n    if self.isClient then\n        spec.samples = { }\n        spec.isHydraulicSamplePlaying = false\n        spec.samples.hydraulic = g_soundManager:loadSampleFromXML( self.xmlFile, "vehicle.attacherJoints.sounds" , "hydraulic" , self.baseDirectory, self.components, 0 , AudioGroup.VEHICLE, self.i3dMappings, self )\n        spec.samples.attach = g_soundManager:loadSampleFromXML( self.xmlFile, "vehicle.attacherJoints.sounds" , "attach" , self.baseDirectory, self.components, 1 , AudioGroup.VEHICLE, self.i3dMappings, self )\n        spec.samples.detach = g_soundManager:loadSampleFromXML( self.xmlFile, "vehicle.attacherJoints.sounds" , "detach" , self.baseDirectory, self.components, 1 , AudioGroup.VEHICLE, self.i3dMappings, self )\n    end\n\n    if self.isClient and g_isDevelopmentVersion then\n        for k, attacherJoint in ipairs(spec.attacherJoints) do\n            if spec.samples.attach = = nil and attacherJoint.sampleAttach = = nil then\n                Logging.xmlDevWarning( self.xmlFile, "Missing attach sound for attacherjoint \'%d\'" , k)\n                end\n                if attacherJoint.rotationNode ~ = nil and spec.samples.hydraulic = = nil then\n                    Logging.xmlDevWarning( self.xmlFile, "Missing hydraulic sound for attacherjoint \'%d\'" , k)\n                    end\n                end\n            end\n\n            spec.showAttachNotAllowedText = 0\n            spec.wasInAttachRange = false\n\n            spec.texts = { }\n            spec.texts.warningToolNotCompatible = g_i18n:getText( "warning_toolNotCompatible" )\n            spec.texts.warningToolBrandNotCompatible = g_i18n:getText( "warning_toolBrandNotCompatible" )\n            spec.texts.infoAttachNotAllowed = g_i18n:getText( "info_attach_not_allowed" )\n            spec.texts.lowerImplementFirst = g_i18n:getText( "warning_lowerImplementFirst" )\n            spec.texts.detachNotAllowed = g_i18n:getText( "warning_detachNotAllowed" )\n            spec.texts.actionAttach = g_i18n:getText( "action_attach" )\n            spec.texts.actionDetach = g_i18n:getText( "action_detach" )\n            spec.texts.warningFoldingAttacherJoint = g_i18n:getText( "warning_foldingNotWhileAttachedToAttacherJoint" )\n\n            spec.groundHeightNodeCheckData = {\n            isDirty = false ,\n            minDistance = math.huge,\n            hit = false ,\n            raycastDistance = 1 ,\n            currentRaycastDistance = 1 ,\n            heightNodes = { } ,\n            jointDesc = { } ,\n            index = - 1 ,\n            lowerDistanceToGround = 0 ,\n            upperDistanceToGround = 0 ,\n            currentRaycastWorldPos = { 0 , 0 , 0 } ,\n            currentRaycastWorldDir = { 0 , 0 , 0 } ,\n            currentJointTransformPos = { 0 , 0 , 0 } ,\n            raycastWorldPos = { 0 , 0 , 0 } ,\n            raycastWorldDir = { 0 , 0 , 0 } ,\n            jointTransformPos = { 0 , 0 , 0 } ,\n            upperAlpha = 0 ,\n            lowerAlpha = 0 ,\n            }\n\n            spec.dirtyFlag = self:getNextDirtyFlag()\n        end\n\n'})}),"\n",(0,o.jsx)(n.h3,{id:"onloadfinished",children:"onLoadFinished"}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Description"})}),"\n",(0,o.jsxs)(n.blockquote,{children:["\n",(0,o.jsx)(n.p,{children:"Called after loading"}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Definition"})}),"\n",(0,o.jsxs)(n.blockquote,{children:["\n",(0,o.jsx)(n.p,{children:"onLoadFinished(table savegame)"}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n",(0,o.jsx)(n.table,{children:(0,o.jsx)(n.thead,{children:(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.th,{children:"table"}),(0,o.jsx)(n.th,{children:"savegame"}),(0,o.jsx)(n.th,{children:"savegame"})]})})}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Code"})}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-lua",children:'function AttacherJoints:onLoadFinished(savegame)\n    local spec = self.spec_attacherJoints\n    if savegame ~ = nil and( not savegame.resetVehicles or savegame.keepPosition) then\n        spec.attachmentDataToLoad = { }\n\n        local xmlFile = savegame.xmlFile\n\n        for index, attachedImplementKey in xmlFile:iterator(savegame.key .. ".attacherJoints.attachedImplement" ) do\n            local jointIndex = xmlFile:getValue(attachedImplementKey .. "#jointIndex" )\n\n            local attachmentData = { }\n            attachmentData.jointIndex = jointIndex\n            attachmentData.attachedVehicleUniqueId = xmlFile:getValue(attachedImplementKey .. "#attachedVehicleUniqueId" )\n            attachmentData.inputIndex = xmlFile:getValue(attachedImplementKey .. "#inputJointIndex" )\n            attachmentData.moveDown = xmlFile:getValue(attachedImplementKey .. "#moveDown" , false )\n            if attachmentData.jointIndex ~ = nil and attachmentData.attachedVehicleUniqueId ~ = nil and attachmentData.inputIndex ~ = nil then\n                local vehicle = g_currentMission.vehicleSystem:getVehicleByUniqueId(attachmentData.attachedVehicleUniqueId)\n                if vehicle ~ = nil then\n                    self:attachImplement(vehicle, attachmentData.inputIndex, attachmentData.jointIndex, true , nil , attachmentData.moveDown, true , true )\n                    self:setJointMoveDown(attachmentData.jointIndex, attachmentData.moveDown, true )\n                else\n                        table.insert(spec.attachmentDataToLoad, attachmentData)\n                    end\n                end\n            end\n\n            for index, attacherJointKey in xmlFile:iterator(savegame.key .. ".attacherJoints.attacherJoint" ) do\n                local jointIndex = xmlFile:getValue(attacherJointKey .. "#jointIndex" )\n                local isBlocked = xmlFile:getValue(attacherJointKey .. "#isBlocked" )\n                if isBlocked then\n                    local attacherJoint = spec.attacherJoints[jointIndex]\n                    attacherJoint.isBlocked = isBlocked\n                end\n            end\n\n            if #spec.attachmentDataToLoad > 0 then\n                g_messageCenter:subscribe(MessageType.VEHICLE_LOADED, self.onAttacherJointsVehicleLoaded, self )\n            end\n        end\n    end\n\n'})}),"\n",(0,o.jsx)(n.h3,{id:"onpostload",children:"onPostLoad"}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Description"})}),"\n",(0,o.jsxs)(n.blockquote,{children:["\n",(0,o.jsx)(n.p,{children:"Called after loading"}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Definition"})}),"\n",(0,o.jsxs)(n.blockquote,{children:["\n",(0,o.jsx)(n.p,{children:"onPostLoad(table savegame)"}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n",(0,o.jsx)(n.table,{children:(0,o.jsx)(n.thead,{children:(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.th,{children:"table"}),(0,o.jsx)(n.th,{children:"savegame"}),(0,o.jsx)(n.th,{children:"savegame"})]})})}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Code"})}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-lua",children:'function AttacherJoints:onPostLoad(savegame)\n    local spec = self.spec_attacherJoints\n\n    for attacherJointIndex, attacherJoint in pairs(spec.attacherJoints) do\n        attacherJoint.jointOrigRot = { getRotation(attacherJoint.jointTransform) }\n        attacherJoint.jointOrigTrans = { getTranslation(attacherJoint.jointTransform) }\n        if attacherJoint.transNode ~ = nil then\n            local _\n            attacherJoint.transNodeMinY = Utils.getNoNil(attacherJoint.transNodeMinY, attacherJoint.jointOrigTrans[ 2 ])\n            attacherJoint.transNodeMaxY = Utils.getNoNil(attacherJoint.transNodeMaxY, attacherJoint.jointOrigTrans[ 2 ])\n            _, attacherJoint.transNodeOffsetY, _ = localToLocal(attacherJoint.jointTransform, attacherJoint.transNode, 0 , 0 , 0 )\n            _, attacherJoint.transNodeMinY, _ = localToLocal(getParent(attacherJoint.transNode), attacherJoint.rootNode, 0 , attacherJoint.transNodeMinY, 0 )\n            _, attacherJoint.transNodeMaxY, _ = localToLocal(getParent(attacherJoint.transNode), attacherJoint.rootNode, 0 , attacherJoint.transNodeMaxY, 0 )\n        end\n\n        if attacherJoint.transNodeDependentBottomArm ~ = nil then\n            for _, attacherJoint2 in pairs(spec.attacherJoints) do\n                if attacherJoint2.bottomArm ~ = nil then\n                    if attacherJoint2.bottomArm.rotationNode = = attacherJoint.transNodeDependentBottomArm then\n                        attacherJoint.transNodeDependentBottomArmAttacherJoint = attacherJoint2\n                    end\n                end\n            end\n\n            if attacherJoint.transNodeDependentBottomArmAttacherJoint = = nil then\n                Logging.xmlWarning( self.xmlFile, "Unable to find dependent bottom arm \'%s\' in any attacher joint." , getName(attacherJoint.transNodeDependentBottomArm))\n                attacherJoint.transNodeDependentBottomArm = nil\n            end\n        end\n\n        if attacherJoint.bottomArm ~ = nil then\n            setRotation(attacherJoint.bottomArm.rotationNode, attacherJoint.bottomArm.rotX, attacherJoint.bottomArm.rotY, attacherJoint.bottomArm.rotZ)\n            if self.setMovingToolDirty ~ = nil then\n                self:setMovingToolDirty(attacherJoint.bottomArm.rotationNode)\n            end\n        end\n        if attacherJoint.rotationNode ~ = nil then\n            setRotation(attacherJoint.rotationNode, attacherJoint.rotX, attacherJoint.rotY, attacherJoint.rotZ)\n        end\n\n        if attacherJoint.visualAlignNodes ~ = nil then\n            for _, visualAlignNode in ipairs(attacherJoint.visualAlignNodes) do\n                self:setMovingPartReferenceNode(visualAlignNode.node, attacherJoint.jointTransform, false )\n            end\n        end\n\n        if self.getInputAttacherJoints ~ = nil then\n            attacherJoint.inputAttacherJointOffsets = { }\n            for _, inputAttacherJoint in ipairs( self:getInputAttacherJoints()) do\n                local xDir, yDir, zDir = localDirectionToLocal(attacherJoint.jointTransform, inputAttacherJoint.node, 0 , 0 , 1 )\n                local xUp, yUp, zUp = localDirectionToLocal(attacherJoint.jointTransform, inputAttacherJoint.node, 0 , 1 , 0 )\n                local xNorm, yNorm, zNorm = localDirectionToLocal(attacherJoint.jointTransform, inputAttacherJoint.node, 1 , 0 , 0 )\n                local xOffset, yOffset, zOffset = localToLocal(attacherJoint.jointTransform, inputAttacherJoint.node, 0 , 0 , 0 )\n                table.insert(attacherJoint.inputAttacherJointOffsets, { xOffset, yOffset, zOffset, xDir, yDir, zDir, xUp, yUp, zUp, xNorm, yNorm, zNorm } )\n            end\n        end\n\n        if self.getAIRootNode ~ = nil then\n            local aiRootNode = self:getAIRootNode()\n            local xDir, yDir, zDir = localDirectionToLocal(attacherJoint.jointTransform, aiRootNode, 0 , 0 , 1 )\n            local xUp, yUp, zUp = localDirectionToLocal(attacherJoint.jointTransform, aiRootNode, 0 , 1 , 0 )\n            local xNorm, yNorm, zNorm = localDirectionToLocal(attacherJoint.jointTransform, aiRootNode, 1 , 0 , 0 )\n            local xOffset, yOffset, zOffset = localToLocal(attacherJoint.jointTransform, aiRootNode, 0 , 0 , 0 )\n            attacherJoint.aiRootNodeOffset = { xOffset, yOffset, zOffset, xDir, yDir, zDir, xUp, yUp, zUp, xNorm, yNorm, zNorm }\n        end\n\n        if attacherJoint.comboTime ~ = nil then\n            local comboData = { }\n            comboData.jointIndex = attacherJointIndex\n            comboData.time = math.clamp(attacherJoint.comboTime, 0 , 1 ) * spec.attacherJointCombos.duration\n            comboData.initialTime = comboData.time\n            table.insert(spec.attacherJointCombos.joints, comboData)\n        end\n\n        -- set all attacher joints to the defined default width including toolbar visibility\n        self:setAttacherJointBottomArmWidth(attacherJointIndex, nil )\n    end\n\n    if savegame ~ = nil and not savegame.resetVehicles then\n        if spec.attacherJointCombos ~ = nil then\n            local comboDirection = savegame.xmlFile:getValue(savegame.key .. ".attacherJoints#comboDirection" )\n            if comboDirection ~ = nil then\n                spec.attacherJointCombos.direction = comboDirection\n                if comboDirection = = 1 then\n                    spec.attacherJointCombos.currentTime = spec.attacherJointCombos.duration\n                end\n            end\n        end\n    end\n\n    if #spec.attacherJoints = = 0 then\n        SpecializationUtil.removeEventListener( self , "onReadStream" , AttacherJoints )\n        SpecializationUtil.removeEventListener( self , "onWriteStream" , AttacherJoints )\n        SpecializationUtil.removeEventListener( self , "onUpdateInterpolation" , AttacherJoints )\n        SpecializationUtil.removeEventListener( self , "onUpdate" , AttacherJoints )\n        SpecializationUtil.removeEventListener( self , "onUpdateEnd" , AttacherJoints )\n        SpecializationUtil.removeEventListener( self , "onStateChange" , AttacherJoints )\n        SpecializationUtil.removeEventListener( self , "onLightsTypesMaskChanged" , AttacherJoints )\n        SpecializationUtil.removeEventListener( self , "onTurnLightStateChanged" , AttacherJoints )\n        SpecializationUtil.removeEventListener( self , "onBrakeLightsVisibilityChanged" , AttacherJoints )\n        SpecializationUtil.removeEventListener( self , "onReverseLightsVisibilityChanged" , AttacherJoints )\n        SpecializationUtil.removeEventListener( self , "onBeaconLightsVisibilityChanged" , AttacherJoints )\n        SpecializationUtil.removeEventListener( self , "onBrake" , AttacherJoints )\n        SpecializationUtil.removeEventListener( self , "onTurnedOn" , AttacherJoints )\n        SpecializationUtil.removeEventListener( self , "onTurnedOff" , AttacherJoints )\n        SpecializationUtil.removeEventListener( self , "onLeaveVehicle" , AttacherJoints )\n        SpecializationUtil.removeEventListener( self , "onActivate" , AttacherJoints )\n        SpecializationUtil.removeEventListener( self , "onDeactivate" , AttacherJoints )\n        SpecializationUtil.removeEventListener( self , "onReverseDirectionChanged" , AttacherJoints )\n    end\nend\n\n'})}),"\n",(0,o.jsx)(n.h3,{id:"onpredelete",children:"onPreDelete"}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Description"})}),"\n",(0,o.jsxs)(n.blockquote,{children:["\n",(0,o.jsx)(n.p,{children:"Called on before deleting"}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Definition"})}),"\n",(0,o.jsxs)(n.blockquote,{children:["\n",(0,o.jsx)(n.p,{children:"onPreDelete()"}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Code"})}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-lua",children:"function AttacherJoints:onPreDelete()\n    local spec = self.spec_attacherJoints\n\n    if spec.attachedImplements ~ = nil then\n        for i = #spec.attachedImplements, 1 , - 1 do\n            local implement = spec.attachedImplements[i]\n            -- additional attachments will be detached and remove by the leading attachment\n            if not implement.object:getIsAdditionalAttachment() then\n                self:detachImplementByObject(implement.object, true )\n            end\n        end\n    end\nend\n\n"})}),"\n",(0,o.jsx)(n.h3,{id:"onpreload",children:"onPreLoad"}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Description"})}),"\n",(0,o.jsxs)(n.blockquote,{children:["\n",(0,o.jsx)(n.p,{children:"Called before loading"}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Definition"})}),"\n",(0,o.jsxs)(n.blockquote,{children:["\n",(0,o.jsx)(n.p,{children:"onPreLoad(table savegame)"}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n",(0,o.jsx)(n.table,{children:(0,o.jsx)(n.thead,{children:(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.th,{children:"table"}),(0,o.jsx)(n.th,{children:"savegame"}),(0,o.jsx)(n.th,{children:"savegame"})]})})}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Code"})}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-lua",children:"function AttacherJoints:onPreLoad(savegame)\n    local spec = self.spec_attacherJoints\n    spec.attachedImplements = { }\n    spec.selectedImplement = nil\n\n    spec.lastInputAttacherCheckIndex = 0\nend\n\n"})}),"\n",(0,o.jsx)(n.h3,{id:"onreadstream",children:"onReadStream"}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Description"})}),"\n",(0,o.jsxs)(n.blockquote,{children:["\n",(0,o.jsx)(n.p,{children:"Called on client side on join"}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Definition"})}),"\n",(0,o.jsxs)(n.blockquote,{children:["\n",(0,o.jsx)(n.p,{children:"onReadStream(integer streamId, Connection connection)"}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,o.jsxs)(n.table,{children:[(0,o.jsx)(n.thead,{children:(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.th,{children:"integer"}),(0,o.jsx)(n.th,{children:"streamId"}),(0,o.jsx)(n.th,{children:"streamId"})]})}),(0,o.jsx)(n.tbody,{children:(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:"Connection"}),(0,o.jsx)(n.td,{children:"connection"}),(0,o.jsx)(n.td,{children:"connection"})]})})]}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Code"})}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-lua",children:"function AttacherJoints:onReadStream(streamId, connection)\n    local numImplements = streamReadInt8(streamId)\n    for i = 1 , numImplements do\n        local object = NetworkUtil.readNodeObject(streamId)\n        local inputJointDescIndex = streamReadInt8(streamId)\n        local jointDescIndex = streamReadInt8(streamId)\n        local moveDown = streamReadBool(streamId)\n        if object ~ = nil and object:getIsSynchronized() then\n            self:attachImplement(object, inputJointDescIndex, jointDescIndex, true , i, moveDown, true , true )\n            self:setJointMoveDown(jointDescIndex, moveDown, true )\n        end\n    end\nend\n\n"})}),"\n",(0,o.jsx)(n.h3,{id:"onregisteractionevents",children:"onRegisterActionEvents"}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Description"})}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Definition"})}),"\n",(0,o.jsxs)(n.blockquote,{children:["\n",(0,o.jsx)(n.p,{children:"onRegisterActionEvents()"}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,o.jsxs)(n.table,{children:[(0,o.jsx)(n.thead,{children:(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.th,{children:"any"}),(0,o.jsx)(n.th,{children:"isActiveForInput"})]})}),(0,o.jsx)(n.tbody,{children:(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:"any"}),(0,o.jsx)(n.td,{children:"isActiveForInputIgnoreSelection"})]})})]}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Code"})}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-lua",children:"function AttacherJoints:onRegisterActionEvents(isActiveForInput, isActiveForInputIgnoreSelection)\n    if self.isClient then\n        local spec = self.spec_attacherJoints\n        self:clearActionEventsTable(spec.actionEvents)\n\n        -- ignore vehicle selection on 'getIsActiveForInput', so we can select the target vehicle and attach or lower it\n        if isActiveForInputIgnoreSelection then\n            if #spec.attacherJoints > 0 then\n                -- only display lower and attach action if selected implement is direct child of vehicle, not sub child\n                    local selectedImplement = self:getSelectedImplement()\n                    if selectedImplement ~ = nil and selectedImplement.object ~ = self then\n                        for _, attachedImplement in pairs(spec.attachedImplements) do\n                            if attachedImplement = = selectedImplement then\n                                -- custom registration of the action event.This allows us to overwritte it in the implement(e.g in Foldable)\n                                selectedImplement.object:registerLoweringActionEvent(spec.actionEvents, InputAction.LOWER_IMPLEMENT, selectedImplement.object, AttacherJoints.actionEventLowerImplement, false , true , false , true , nil , nil , true )\n                            end\n                        end\n                    end\n\n                    local _, actionEventId = self:addPoweredActionEvent(spec.actionEvents, InputAction.LOWER_ALL_IMPLEMENTS, self , AttacherJoints.actionEventLowerAllImplements, false , true , false , true , nil , nil , true )\n                    g_inputBinding:setActionEventTextVisibility(actionEventId, false )\n                end\n\n                if self:getSelectedVehicle() = = self then\n                    local state, _ = self:registerSelfLoweringActionEvent(spec.actionEvents, InputAction.LOWER_IMPLEMENT, self , AttacherJoints.actionEventLowerImplement, false , true , false , true , nil , nil , true )\n\n                    -- if the selected attacher vehicle can not be lowered and we got only one implement that can be lowered\n                        -- we add the lowering action for the first implement\n                            if state = = nil or not state then\n                                if #spec.attachedImplements = = 1 then\n                                    local firstImplement = spec.attachedImplements[ 1 ]\n                                    if firstImplement ~ = nil then\n                                        firstImplement.object:registerLoweringActionEvent(spec.actionEvents, InputAction.LOWER_IMPLEMENT, firstImplement.object, AttacherJoints.actionEventLowerImplement, false , true , false , true , nil , nil , true )\n                                    end\n                                end\n                            end\n                        end\n\n                        local _, actionEventId = self:addActionEvent(spec.actionEvents, InputAction.ATTACH, self , AttacherJoints.actionEventAttach, false , true , false , true , nil , nil , true )\n                        g_inputBinding:setActionEventTextPriority(actionEventId, GS_PRIO_VERY_HIGH)\n\n                        _, actionEventId = self:addActionEvent(spec.actionEvents, InputAction.DETACH, self , AttacherJoints.actionEventDetach, false , true , false , true , nil , nil , true )\n                        g_inputBinding:setActionEventTextVisibility(actionEventId, false )\n\n                        AttacherJoints.updateActionEvents( self )\n                    end\n                end\n            end\n\n"})}),"\n",(0,o.jsx)(n.h3,{id:"onregisterdashboardvaluetypes",children:"onRegisterDashboardValueTypes"}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Description"})}),"\n",(0,o.jsxs)(n.blockquote,{children:["\n",(0,o.jsx)(n.p,{children:"Called on post load to register dashboard value types"}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Definition"})}),"\n",(0,o.jsxs)(n.blockquote,{children:["\n",(0,o.jsx)(n.p,{children:"onRegisterDashboardValueTypes()"}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Code"})}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-lua",children:'function AttacherJoints:onRegisterDashboardValueTypes()\n    local spec = self.spec_attacherJoints\n\n    local loadAttacherJointNodeFunc = function (_, xmlFile, key, dashboard, isActive)\n        dashboard.attacherJointNode = xmlFile:getValue(key .. "#attacherJointNode" , nil , self.components, self.i3dMappings)\n        if dashboard.attacherJointNode = = nil then\n            dashboard.attacherJointNodes = xmlFile:getValue(key .. "#attacherJointNodes" , nil , self.components, self.i3dMappings, true )\n            return #dashboard.attacherJointNodes ~ = 0\n        else\n                return true\n            end\n        end\n\n        local setAttacherJointFromNodes = function (dashboard)\n            if dashboard.attacherJointNode ~ = nil then\n                local attacherJoint = self:getAttacherJointByNode(dashboard.attacherJointNode)\n                if attacherJoint ~ = nil and attacherJoint.bottomArm ~ = nil then\n                    dashboard.attacherJoint = attacherJoint\n                else\n                        dashboard.attacherJointNode = nil\n                    end\n                elseif dashboard.attacherJointNodes ~ = nil then\n                        for _, attacherJointNode in ipairs(dashboard.attacherJointNodes) do\n                            local attacherJoint = self:getAttacherJointByNode(attacherJointNode)\n                            if attacherJoint ~ = nil and attacherJoint.bottomArm ~ = nil then\n                                dashboard.attacherJoint = attacherJoint\n                                break\n                            end\n                        end\n\n                        if dashboard.attacherJoint = = nil then\n                            dashboard.attacherJointNodes = nil\n                        end\n                    end\n                end\n\n                local bottomArmPosition = DashboardValueType.new( "attacherJoints" , "bottomArmPosition" )\n                bottomArmPosition:setValue(spec, function (_, dashboard)\n                    if dashboard.attacherJoint = = nil then\n                        setAttacherJointFromNodes(dashboard)\n\n                        if dashboard.attacherJoint = = nil then\n                            return 0\n                        end\n                    end\n\n                    return 1 - (dashboard.attacherJoint.moveAlpha or 0 )\n                end )\n                bottomArmPosition:setAdditionalFunctions(loadAttacherJointNodeFunc)\n                bottomArmPosition:setValueFactor( 100 )\n                bottomArmPosition:setRange( 0 , 100 )\n                bottomArmPosition:setPollUpdate( false )\n                self:registerDashboardValueType(bottomArmPosition)\n\n                local bottomArmPositionMin = DashboardValueType.new( "attacherJoints" , "bottomArmPositionMin" )\n                bottomArmPositionMin:setValue(spec, function (_, dashboard)\n                    if dashboard.attacherJoint = = nil then\n                        setAttacherJointFromNodes(dashboard)\n\n                        if dashboard.attacherJoint = = nil then\n                            return 0\n                        end\n                    end\n\n                    return 1 - (dashboard.attacherJoint.lowerAlpha or 1 )\n                end )\n                bottomArmPositionMin:setAdditionalFunctions(loadAttacherJointNodeFunc)\n                bottomArmPositionMin:setValueFactor( 100 )\n                bottomArmPositionMin:setRange( 0 , 100 )\n                bottomArmPositionMin:setPollUpdate( false )\n                self:registerDashboardValueType(bottomArmPositionMin)\n\n                local bottomArmPositionMax = DashboardValueType.new( "attacherJoints" , "bottomArmPositionMax" )\n                bottomArmPositionMax:setValue(spec, function (_, dashboard)\n                    if dashboard.attacherJoint = = nil then\n                        setAttacherJointFromNodes(dashboard)\n\n                        if dashboard.attacherJoint = = nil then\n                            return 0\n                        end\n                    end\n\n                    return 1 - (dashboard.attacherJoint.upperAlpha or 0 )\n                end )\n                bottomArmPositionMax:setAdditionalFunctions(loadAttacherJointNodeFunc)\n                bottomArmPositionMax:setValueFactor( 100 )\n                bottomArmPositionMax:setRange( 0 , 100 )\n                bottomArmPositionMax:setPollUpdate( false )\n                self:registerDashboardValueType(bottomArmPositionMax)\n            end\n\n'})}),"\n",(0,o.jsx)(n.h3,{id:"onreversedirectionchanged",children:"onReverseDirectionChanged"}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Description"})}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Definition"})}),"\n",(0,o.jsxs)(n.blockquote,{children:["\n",(0,o.jsx)(n.p,{children:"onReverseDirectionChanged()"}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,o.jsx)(n.table,{children:(0,o.jsx)(n.thead,{children:(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.th,{children:"any"}),(0,o.jsx)(n.th,{children:"direction"})]})})}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Code"})}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-lua",children:"function AttacherJoints:onReverseDirectionChanged(direction)\n    local spec = self.spec_attacherJoints\n\n    local reverserDirection = self:getReverserDirection()\n    if spec.attacherJointCombos ~ = nil then\n        for _, joint in pairs(spec.attacherJointCombos.joints) do\n            if reverserDirection < 0 then\n                joint.time = math.abs(joint.initialTime - spec.attacherJointCombos.duration)\n            else\n                    joint.time = joint.initialTime\n                end\n            end\n        end\n    end\n\n"})}),"\n",(0,o.jsx)(n.h3,{id:"onreverselightsvisibilitychanged",children:"onReverseLightsVisibilityChanged"}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Description"})}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Definition"})}),"\n",(0,o.jsxs)(n.blockquote,{children:["\n",(0,o.jsx)(n.p,{children:"onReverseLightsVisibilityChanged()"}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,o.jsx)(n.table,{children:(0,o.jsx)(n.thead,{children:(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.th,{children:"any"}),(0,o.jsx)(n.th,{children:"visibility"})]})})}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Code"})}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-lua",children:"function AttacherJoints:onReverseLightsVisibilityChanged(visibility)\n    local spec = self.spec_attacherJoints\n    for _, implement in pairs(spec.attachedImplements) do\n        local vehicle = implement.object\n        if vehicle ~ = nil and vehicle.setReverseLightsVisibility ~ = nil then\n            vehicle:setReverseLightsVisibility(visibility)\n        end\n    end\nend\n\n"})}),"\n",(0,o.jsx)(n.h3,{id:"onstatechange",children:"onStateChange"}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Description"})}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Definition"})}),"\n",(0,o.jsxs)(n.blockquote,{children:["\n",(0,o.jsx)(n.p,{children:"onStateChange()"}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,o.jsxs)(n.table,{children:[(0,o.jsx)(n.thead,{children:(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.th,{children:"any"}),(0,o.jsx)(n.th,{children:"state"})]})}),(0,o.jsx)(n.tbody,{children:(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:"any"}),(0,o.jsx)(n.td,{children:"data"})]})})]}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Code"})}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-lua",children:"function AttacherJoints:onStateChange(state, data)\n    local spec = self.spec_attacherJoints\n\n    for _, implement in pairs(spec.attachedImplements) do\n        if implement.object ~ = nil then\n            implement.object:raiseStateChange(state, data)\n        end\n    end\n\n    if state = = VehicleStateChange.LOWER_ALL_IMPLEMENTS then\n        if #spec.attacherJoints > 0 then\n            self:startAttacherJointCombo()\n        end\n    end\nend\n\n"})}),"\n",(0,o.jsx)(n.h3,{id:"onturnedoff",children:"onTurnedOff"}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Description"})}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Definition"})}),"\n",(0,o.jsxs)(n.blockquote,{children:["\n",(0,o.jsx)(n.p,{children:"onTurnedOff()"}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Code"})}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-lua",children:"function AttacherJoints:onTurnedOff()\n    local spec = self.spec_attacherJoints\n    for _, implement in pairs(spec.attachedImplements) do\n        local vehicle = implement.object\n        if vehicle ~ = nil then\n            local turnedOnVehicleSpec = vehicle.spec_turnOnVehicle\n            if turnedOnVehicleSpec then\n                if turnedOnVehicleSpec.turnedOnByAttacherVehicle then\n                    vehicle:setIsTurnedOn( false , true )\n                end\n            end\n        end\n    end\nend\n\n"})}),"\n",(0,o.jsx)(n.h3,{id:"onturnedon",children:"onTurnedOn"}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Description"})}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Definition"})}),"\n",(0,o.jsxs)(n.blockquote,{children:["\n",(0,o.jsx)(n.p,{children:"onTurnedOn()"}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Code"})}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-lua",children:"function AttacherJoints:onTurnedOn()\n    local spec = self.spec_attacherJoints\n    for _, implement in pairs(spec.attachedImplements) do\n        local vehicle = implement.object\n        if vehicle ~ = nil then\n            local turnedOnVehicleSpec = vehicle.spec_turnOnVehicle\n            if turnedOnVehicleSpec then\n                if turnedOnVehicleSpec.turnedOnByAttacherVehicle then\n                    vehicle:setIsTurnedOn( true , true )\n                end\n            end\n        end\n    end\nend\n\n"})}),"\n",(0,o.jsx)(n.h3,{id:"onturnlightstatechanged",children:"onTurnLightStateChanged"}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Description"})}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Definition"})}),"\n",(0,o.jsxs)(n.blockquote,{children:["\n",(0,o.jsx)(n.p,{children:"onTurnLightStateChanged()"}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,o.jsx)(n.table,{children:(0,o.jsx)(n.thead,{children:(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.th,{children:"any"}),(0,o.jsx)(n.th,{children:"state"})]})})}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Code"})}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-lua",children:"function AttacherJoints:onTurnLightStateChanged(state)\n    local spec = self.spec_attacherJoints\n    for _, implement in pairs(spec.attachedImplements) do\n        local vehicle = implement.object\n        if vehicle ~ = nil and vehicle.setTurnLightState ~ = nil then\n            vehicle:setTurnLightState(state, true , true )\n        end\n    end\nend\n\n"})}),"\n",(0,o.jsx)(n.h3,{id:"onupdate",children:"onUpdate"}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Description"})}),"\n",(0,o.jsxs)(n.blockquote,{children:["\n",(0,o.jsx)(n.p,{children:"Called on update"}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Definition"})}),"\n",(0,o.jsxs)(n.blockquote,{children:["\n",(0,o.jsx)(n.p,{children:"onUpdate(float dt, boolean isActiveForInput, boolean isSelected, )"}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,o.jsxs)(n.table,{children:[(0,o.jsx)(n.thead,{children:(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.th,{children:"float"}),(0,o.jsx)(n.th,{children:"dt"}),(0,o.jsx)(n.th,{children:"time since last call in ms"})]})}),(0,o.jsxs)(n.tbody,{children:[(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:"boolean"}),(0,o.jsx)(n.td,{children:"isActiveForInput"}),(0,o.jsx)(n.td,{children:"true if vehicle is active for input"})]}),(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:"boolean"}),(0,o.jsx)(n.td,{children:"isSelected"}),(0,o.jsx)(n.td,{children:"true if vehicle is selected"})]}),(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:"any"}),(0,o.jsx)(n.td,{children:"isSelected"}),(0,o.jsx)(n.td,{})]})]})]}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Code"})}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-lua",children:"function AttacherJoints:onUpdate(dt, isActiveForInput, isActiveForInputIgnoreSelection, isSelected)\n    local spec = self.spec_attacherJoints\n\n    if self.isClient then\n        spec.showAttachNotAllowedText = math.max(spec.showAttachNotAllowedText - dt, 0 )\n        if spec.showAttachNotAllowedText > 0 then\n            g_currentMission:addExtraPrintText(spec.texts.infoAttachNotAllowed)\n        end\n    end\n\n    -- update attachables in range\n    local info = spec.attachableInfo\n\n    if (Platform.gameplay.automaticAttach and self.isServer)\n        or( self.isClient and spec.actionEvents ~ = nil and spec.actionEvents[InputAction.ATTACH] ~ = nil ) then\n        if self:getCanToggleAttach() then\n            AttacherJoints.updateVehiclesInAttachRange( self , AttacherJoints.MAX_ATTACH_DISTANCE_SQ, AttacherJoints.MAX_ATTACH_ANGLE, true )\n        else\n                info.attacherVehicle, info.attacherVehicleJointDescIndex, info.attachable, info.attachableJointDescIndex = nil , nil , nil , nil\n            end\n        end\n    end\n\n"})}),"\n",(0,o.jsx)(n.h3,{id:"onupdateend",children:"onUpdateEnd"}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Description"})}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Definition"})}),"\n",(0,o.jsxs)(n.blockquote,{children:["\n",(0,o.jsx)(n.p,{children:"onUpdateEnd()"}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,o.jsxs)(n.table,{children:[(0,o.jsx)(n.thead,{children:(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.th,{children:"any"}),(0,o.jsx)(n.th,{children:"dt"})]})}),(0,o.jsxs)(n.tbody,{children:[(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:"any"}),(0,o.jsx)(n.td,{children:"isActiveForInput"})]}),(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:"any"}),(0,o.jsx)(n.td,{children:"isActiveForInputIgnoreSelection"})]}),(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:"any"}),(0,o.jsx)(n.td,{children:"isSelected"})]})]})]}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Code"})}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-lua",children:"function AttacherJoints:onUpdateEnd(dt, isActiveForInput, isActiveForInputIgnoreSelection, isSelected)\n    -- force update of all attacher joint graphics independent of camera distance right before vehicles starts to sleep\n    -- so if we get into the update distance agan we are already in the right state without waking up the vehicle\n        local spec = self.spec_attacherJoints\n        for _, implement in pairs(spec.attachedImplements) do\n            if implement.object ~ = nil then\n                if self.updateLoopIndex = = implement.object.updateLoopIndex then\n                    self:updateAttacherJointGraphics(implement, dt, true )\n                end\n            end\n        end\n    end\n\n"})}),"\n",(0,o.jsx)(n.h3,{id:"onupdateinterpolation",children:"onUpdateInterpolation"}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Description"})}),"\n",(0,o.jsxs)(n.blockquote,{children:["\n",(0,o.jsx)(n.p,{children:"Called after position interpolation update"}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Definition"})}),"\n",(0,o.jsxs)(n.blockquote,{children:["\n",(0,o.jsx)(n.p,{children:"onUpdateInterpolation(float dt, boolean isActiveForInput, boolean isSelected, )"}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,o.jsxs)(n.table,{children:[(0,o.jsx)(n.thead,{children:(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.th,{children:"float"}),(0,o.jsx)(n.th,{children:"dt"}),(0,o.jsx)(n.th,{children:"time since last call in ms"})]})}),(0,o.jsxs)(n.tbody,{children:[(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:"boolean"}),(0,o.jsx)(n.td,{children:"isActiveForInput"}),(0,o.jsx)(n.td,{children:"true if vehicle is active for input"})]}),(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:"boolean"}),(0,o.jsx)(n.td,{children:"isSelected"}),(0,o.jsx)(n.td,{children:"true if vehicle is selected"})]}),(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:"any"}),(0,o.jsx)(n.td,{children:"isSelected"}),(0,o.jsx)(n.td,{})]})]})]}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Code"})}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-lua",children:'function AttacherJoints:onUpdateInterpolation(dt, isActiveForInput, isActiveForInputIgnoreSelection, isSelected)\n    local spec = self.spec_attacherJoints\n    if self.currentUpdateDistance < spec.maxUpdateDistance then\n        for _, implement in pairs(spec.attachedImplements) do\n            if implement.object ~ = nil then\n                if self.updateLoopIndex = = implement.object.updateLoopIndex then\n                    self:updateAttacherJointGraphics(implement, dt, true )\n                    implement.object:updateInputAttacherJointGraphics(implement, dt)\n                end\n            end\n        end\n    end\n\n    -- call the update interpolation function on hard attached implements\n        -- as their position depends on our own position\n        -- this results in a doubled call on the tools side, as we do not surpress the first call\n            for _, implement in pairs(spec.attachedImplements) do\n                if implement.object ~ = nil then\n                    if implement.object.spec_attachable.isHardAttached then\n                        SpecializationUtil.raiseEvent(implement.object, "onUpdateInterpolation" , dt, isActiveForInput, isActiveForInputIgnoreSelection, isSelected)\n                    end\n                end\n            end\n        end\n\n'})}),"\n",(0,o.jsx)(n.h3,{id:"onupdatetick",children:"onUpdateTick"}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Description"})}),"\n",(0,o.jsxs)(n.blockquote,{children:["\n",(0,o.jsx)(n.p,{children:"Called on update tick"}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Definition"})}),"\n",(0,o.jsxs)(n.blockquote,{children:["\n",(0,o.jsx)(n.p,{children:"onUpdateTick(float dt, boolean isActiveForInput, boolean isSelected, )"}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,o.jsxs)(n.table,{children:[(0,o.jsx)(n.thead,{children:(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.th,{children:"float"}),(0,o.jsx)(n.th,{children:"dt"}),(0,o.jsx)(n.th,{children:"time since last call in ms"})]})}),(0,o.jsxs)(n.tbody,{children:[(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:"boolean"}),(0,o.jsx)(n.td,{children:"isActiveForInput"}),(0,o.jsx)(n.td,{children:"true if vehicle is active for input"})]}),(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:"boolean"}),(0,o.jsx)(n.td,{children:"isSelected"}),(0,o.jsx)(n.td,{children:"true if vehicle is selected"})]}),(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:"any"}),(0,o.jsx)(n.td,{children:"isSelected"}),(0,o.jsx)(n.td,{})]})]})]}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Code"})}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-lua",children:'function AttacherJoints:onUpdateTick(dt, isActiveForInput, isActiveForInputIgnoreSelection, isSelected)\n    local spec = self.spec_attacherJoints\n\n    local playHydraulicSound = false\n\n    for _, implement in pairs(spec.attachedImplements) do\n        if implement.object ~ = nil then\n            local jointDesc = spec.attacherJoints[implement.jointDescIndex]\n\n            if not implement.object.spec_attachable.isHardAttached then\n                if self.isServer then\n                    if implement.attachingIsInProgress and self:getIsSmoothAttachUpdateAllowed(implement) then\n                        local done = true\n                        for i = 1 , 3 do\n                            local lastRotLimit = implement.attachingRotLimit[i]\n                            local lastTransLimit = implement.attachingTransLimit[i]\n                            implement.attachingRotLimit[i] = math.max( 0 , implement.attachingRotLimit[i] - implement.attachingRotLimitSpeed[i] * dt)\n                            implement.attachingTransLimit[i] = math.max( 0 , implement.attachingTransLimit[i] - implement.attachingTransLimitSpeed[i] * dt)\n                            if (implement.attachingRotLimit[i] > 0 or implement.attachingTransLimit[i] > 0 ) or\n                                (lastRotLimit > 0 or lastTransLimit > 0 )\n                                then\n                                done = false\n                            end\n                        end\n                        implement.attachingIsInProgress = not done\n\n                        if done then\n                            if implement.object.spec_attachable.attacherJoint.hardAttach and self:getIsHardAttachAllowed(implement.jointDescIndex) then\n                                self:hardAttachImplement(implement)\n                            end\n                            self:postAttachImplement(implement)\n                        end\n                    end\n                end\n                if not implement.attachingIsInProgress then\n                    local jointFrameInvalid = false\n                    if jointDesc.allowsLowering then\n                        if self:getIsActive() then\n                            local upperAlpha, lowerAlpha = jointDesc.upperAlpha, jointDesc.lowerAlpha\n                            if jointDesc.moveDown then\n                                upperAlpha, lowerAlpha = self:calculateAttacherJointMoveUpperLowerAlpha(jointDesc, implement.object)\n                                jointDesc.moveTime = jointDesc.moveDefaultTime * math.abs(upperAlpha - lowerAlpha)\n                            end\n\n                            local moveAlpha = Utils.getMovedLimitedValue(jointDesc.moveAlpha, lowerAlpha, upperAlpha, jointDesc.moveTime, dt, not jointDesc.moveDown)\n                            if moveAlpha ~ = jointDesc.moveAlpha or upperAlpha ~ = jointDesc.upperAlpha or lowerAlpha ~ = jointDesc.lowerAlpha then\n                                jointDesc.upperAlpha = upperAlpha\n                                jointDesc.lowerAlpha = lowerAlpha\n\n                                if jointDesc.moveDown then\n                                    if math.abs(jointDesc.moveAlpha - jointDesc.lowerAlpha) < 0.05 then\n                                        jointDesc.isMoving = false\n                                    end\n                                else\n                                        if math.abs(jointDesc.moveAlpha - jointDesc.upperAlpha) < 0.05 then\n                                            jointDesc.isMoving = false\n                                        end\n                                    end\n\n                                    playHydraulicSound = jointDesc.isMoving\n\n                                    jointDesc.moveAlpha = moveAlpha\n                                    if jointDesc.upperAlpha - jointDesc.lowerAlpha ~ = 0 then\n                                        jointDesc.moveLimitAlpha = 1 - (moveAlpha - jointDesc.lowerAlpha) / (jointDesc.upperAlpha - jointDesc.lowerAlpha)\n                                    else\n                                            jointDesc.moveLimitAlpha = 1\n                                        end\n                                        jointFrameInvalid = true\n                                        self:updateAttacherJointRotationNodes(jointDesc, jointDesc.moveAlpha)\n                                        self:updateAttacherJointRotation(jointDesc, implement.object)\n\n                                        if self.isClient then\n                                            if self.updateDashboardValueType ~ = nil then\n                                                self:updateDashboardValueType( "attacherJoints.bottomArmPosition" )\n                                            end\n                                        end\n                                    end\n                                end\n                            end\n\n                            jointFrameInvalid = jointFrameInvalid or jointDesc.jointFrameInvalid\n                            if jointFrameInvalid then\n                                jointDesc.jointFrameInvalid = false\n                                if self.isServer then\n                                    setJointFrame(jointDesc.jointIndex, 0 , jointDesc.jointTransform)\n                                end\n                            end\n                        end\n                        if self.isServer then\n                            local force = implement.attachingIsInProgress\n                            if force or(jointDesc.allowsLowering and jointDesc.allowsJointLimitMovement) then\n                                if jointDesc.jointIndex ~ = nil and jointDesc.jointIndex ~ = 0 then\n                                    if force or implement.object.spec_attachable.attacherJoint.allowsJointRotLimitMovement then\n                                        local alpha = math.max(jointDesc.moveLimitAlpha - implement.rotLimitThreshold, 0 ) / ( 1 - implement.rotLimitThreshold)\n\n                                        for i = 1 , 3 do\n                                            AttacherJoints.updateAttacherJointRotationLimit(implement, jointDesc, i, force, alpha)\n                                        end\n                                    end\n\n                                    if force or implement.object.spec_attachable.attacherJoint.allowsJointTransLimitMovement then\n                                        local alpha = math.max(jointDesc.moveLimitAlpha - implement.transLimitThreshold, 0 ) / ( 1 - implement.transLimitThreshold)\n\n                                        for i = 1 , 3 do\n                                            AttacherJoints.updateAttacherJointTranslationLimit(implement, jointDesc, i, force, alpha)\n                                        end\n                                    end\n                                end\n                            end\n                        end\n                    end\n                end\n            end\n\n            if self.isClient and spec.samples.hydraulic ~ = nil then\n                for i = 1 , #spec.attacherJoints do\n                    local jointDesc = spec.attacherJoints[i]\n                    if jointDesc.bottomArm ~ = nil and jointDesc.bottomArm.bottomArmInterpolating then\n                        playHydraulicSound = true\n                    end\n                end\n\n                if playHydraulicSound then\n                    if not spec.isHydraulicSamplePlaying then\n                        g_soundManager:playSample(spec.samples.hydraulic)\n                        spec.isHydraulicSamplePlaying = true\n                    end\n                else\n                        if spec.isHydraulicSamplePlaying then\n                            g_soundManager:stopSample(spec.samples.hydraulic)\n                            spec.isHydraulicSamplePlaying = false\n                        end\n                    end\n                end\n\n                local combos = spec.attacherJointCombos\n                if combos ~ = nil and combos.isRunning then\n                    for _, joint in pairs(combos.joints) do\n                        local doLowering\n                        if combos.direction = = 1 and combos.currentTime > = joint.time then\n                            doLowering = true\n                        elseif combos.direction = = - 1 and combos.currentTime < = combos.duration - joint.time then\n                                doLowering = false\n                            end\n\n                            if doLowering ~ = nil then\n                                local implement = self:getImplementFromAttacherJointIndex(joint.jointIndex)\n                                if implement ~ = nil then\n                                    if implement.object.setLoweredAll ~ = nil then\n                                        implement.object:setLoweredAll(doLowering, joint.jointIndex)\n                                    end\n                                end\n                            end\n                        end\n\n                        if (combos.direction = = - 1 and combos.currentTime = = 0 ) or\n                            (combos.direction = = 1 and combos.currentTime = = combos.duration) then\n                            combos.isRunning = false\n                        end\n\n                        combos.currentTime = math.clamp(combos.currentTime + dt * combos.direction, 0 , combos.duration)\n                    end\n\n                    AttacherJoints.updateActionEvents( self )\n\n                    -- auto attach for mobile version\n                        if Platform.gameplay.automaticAttach then\n                            if self.isServer then\n                                if self:getCanToggleAttach() then\n                                    local info = spec.attachableInfo\n\n                                    if info.attachable ~ = nil and not spec.wasInAttachRange and info.attacherVehicle = = self then\n                                        if not self.isReconfigurating and not info.attachable.isReconfigurating then\n                                            local attachAllowed, warning = info.attachable:isAttachAllowed( self:getActiveFarm(), info.attacherVehicle)\n                                            if attachAllowed then\n                                                -- wasInAttachRange is nil after detach until the detached implement is in range\n                                                if spec.wasInAttachRange = = nil then\n                                                    spec.wasInAttachRange = true\n                                                else\n                                                        self:attachImplementFromInfo(info)\n                                                    end\n                                                elseif warning ~ = nil then\n                                                        g_currentMission:showBlinkingWarning(warning, 2000 )\n                                                    end\n                                                end\n                                            elseif info.attachable = = nil and spec.wasInAttachRange then\n                                                    spec.wasInAttachRange = false\n                                                end\n                                            end\n                                        end\n                                    end\n                                end\n\n'})}),"\n",(0,o.jsx)(n.h3,{id:"onwritestream",children:"onWriteStream"}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Description"})}),"\n",(0,o.jsxs)(n.blockquote,{children:["\n",(0,o.jsx)(n.p,{children:"Called on server side on join"}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Definition"})}),"\n",(0,o.jsxs)(n.blockquote,{children:["\n",(0,o.jsx)(n.p,{children:"onWriteStream(integer streamId, Connection connection)"}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,o.jsxs)(n.table,{children:[(0,o.jsx)(n.thead,{children:(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.th,{children:"integer"}),(0,o.jsx)(n.th,{children:"streamId"}),(0,o.jsx)(n.th,{children:"streamId"})]})}),(0,o.jsx)(n.tbody,{children:(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:"Connection"}),(0,o.jsx)(n.td,{children:"connection"}),(0,o.jsx)(n.td,{children:"connection"})]})})]}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Code"})}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-lua",children:"function AttacherJoints:onWriteStream(streamId, connection)\n    local spec = self.spec_attacherJoints\n\n    -- write attached implements\n    streamWriteInt8(streamId, #spec.attachedImplements)\n    for i = 1 , #spec.attachedImplements do\n        local implement = spec.attachedImplements[i]\n        local inputJointDescIndex = implement.object.spec_attachable.inputAttacherJointDescIndex\n        local jointDescIndex = implement.jointDescIndex\n        local jointDesc = spec.attacherJoints[jointDescIndex]\n        local moveDown = jointDesc.moveDown\n        NetworkUtil.writeNodeObject(streamId, implement.object)\n        streamWriteInt8(streamId, inputJointDescIndex)\n        streamWriteInt8(streamId, jointDescIndex)\n        streamWriteBool(streamId, moveDown)\n    end\nend\n\n"})}),"\n",(0,o.jsx)(n.h3,{id:"playattachsound",children:"playAttachSound"}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Description"})}),"\n",(0,o.jsxs)(n.blockquote,{children:["\n",(0,o.jsx)(n.p,{children:"Play attach sound"}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Definition"})}),"\n",(0,o.jsxs)(n.blockquote,{children:["\n",(0,o.jsx)(n.p,{children:"playAttachSound(table jointDesc)"}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n",(0,o.jsx)(n.table,{children:(0,o.jsx)(n.thead,{children:(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.th,{children:"table"}),(0,o.jsx)(n.th,{children:"jointDesc"}),(0,o.jsx)(n.th,{children:"joint desc"})]})})}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Return Values"})}),"\n\n\n\n\n\n\n\n\n",(0,o.jsx)(n.table,{children:(0,o.jsx)(n.thead,{children:(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.th,{children:"table"}),(0,o.jsx)(n.th,{children:"success"}),(0,o.jsx)(n.th,{children:"success"})]})})}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Code"})}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-lua",children:"function AttacherJoints:playAttachSound(jointDesc)\n    local spec = self.spec_attacherJoints\n\n    if self.isClient then\n        if jointDesc ~ = nil and jointDesc.sampleAttach ~ = nil then\n            g_soundManager:playSample(jointDesc.sampleAttach)\n        else\n                g_soundManager:playSample(spec.samples.attach)\n            end\n        end\n\n        return true\n    end\n\n"})}),"\n",(0,o.jsx)(n.h3,{id:"playdetachsound",children:"playDetachSound"}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Description"})}),"\n",(0,o.jsxs)(n.blockquote,{children:["\n",(0,o.jsx)(n.p,{children:"Play detach sound"}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Definition"})}),"\n",(0,o.jsxs)(n.blockquote,{children:["\n",(0,o.jsx)(n.p,{children:"playDetachSound(table jointDesc)"}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n",(0,o.jsx)(n.table,{children:(0,o.jsx)(n.thead,{children:(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.th,{children:"table"}),(0,o.jsx)(n.th,{children:"jointDesc"}),(0,o.jsx)(n.th,{children:"joint desc"})]})})}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Return Values"})}),"\n\n\n\n\n\n\n\n\n",(0,o.jsx)(n.table,{children:(0,o.jsx)(n.thead,{children:(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.th,{children:"table"}),(0,o.jsx)(n.th,{children:"success"}),(0,o.jsx)(n.th,{children:"success"})]})})}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Code"})}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-lua",children:"function AttacherJoints:playDetachSound(jointDesc)\n    local spec = self.spec_attacherJoints\n\n    if self.isClient then\n        if jointDesc ~ = nil and jointDesc.sampleDetach ~ = nil then\n            g_soundManager:playSample(jointDesc.sampleDetach)\n        elseif spec.samples.detach ~ = nil then\n                g_soundManager:playSample(spec.samples.detach)\n            elseif jointDesc ~ = nil and jointDesc.sampleAttach ~ = nil then\n                    g_soundManager:playSample(jointDesc.sampleAttach)\n                else\n                        g_soundManager:playSample(spec.samples.attach)\n                    end\n                end\n\n                return true\n            end\n\n"})}),"\n",(0,o.jsx)(n.h3,{id:"postattachimplement",children:"postAttachImplement"}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Description"})}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Definition"})}),"\n",(0,o.jsxs)(n.blockquote,{children:["\n",(0,o.jsx)(n.p,{children:"postAttachImplement()"}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,o.jsx)(n.table,{children:(0,o.jsx)(n.thead,{children:(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.th,{children:"any"}),(0,o.jsx)(n.th,{children:"implement"})]})})}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Code"})}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-lua",children:'function AttacherJoints:postAttachImplement(implement)\n    local spec = self.spec_attacherJoints\n\n    local object = implement.object\n    local inputJointDescIndex = implement.inputJointDescIndex\n    local jointDescIndex = implement.jointDescIndex\n    local objectAttacherJoint = object.spec_attachable.inputAttacherJoints[inputJointDescIndex]\n    local jointDesc = spec.attacherJoints[jointDescIndex]\n\n    if objectAttacherJoint.topReferenceNode ~ = nil then\n        if jointDesc.topArm ~ = nil then\n            jointDesc.topArm:setIsActive( true )\n        end\n    end\n\n    if jointDesc.bottomArm ~ = nil then\n        if jointDesc.bottomArm.toggleVisibility then\n            setVisibility(jointDesc.bottomArm.rotationNode, true )\n        end\n\n        if objectAttacherJoint.needsToolbar and jointDesc.bottomArm.toolbarNode ~ = nil then\n            setVisibility(jointDesc.bottomArm.toolbarNode, true )\n        end\n\n        if jointDesc.bottomArm.leftNode ~ = nil and objectAttacherJoint.bottomArmLeftNode ~ = nil then\n            self:setMovingPartReferenceNode(jointDesc.bottomArm.leftNode, objectAttacherJoint.bottomArmLeftNode, false )\n        end\n        if jointDesc.bottomArm.rightNode ~ = nil and objectAttacherJoint.bottomArmRightNode ~ = nil then\n            self:setMovingPartReferenceNode(jointDesc.bottomArm.rightNode, objectAttacherJoint.bottomArmRightNode, false )\n        end\n    end\n\n    if jointDesc.visualAlignNodes ~ = nil then\n        for _, visualAlignNode in ipairs(jointDesc.visualAlignNodes) do\n            if visualAlignNode.delayedOnAttach then\n                self:setMovingPartReferenceNode(visualAlignNode.node, objectAttacherJoint.node, false )\n            end\n        end\n    end\n\n    if jointDesc.delayedObjectChangesOnAttach then\n        ObjectChangeUtil.setObjectChanges(jointDesc.changeObjects, true , self , self.setMovingToolDirty)\n    end\n\n    if not implement.loadFromSavegame then\n        self:playAttachSound(jointDesc)\n    end\n\n    self:updateAttacherJointGraphics(implement, 0 )\n\n    SpecializationUtil.raiseEvent( self , "onPostAttachImplement" , object, inputJointDescIndex, jointDescIndex, implement.loadFromSavegame)\n    object:postAttach( self , inputJointDescIndex, jointDescIndex, implement.loadFromSavegame)\n\n    local data = { attacherVehicle = self , attachedVehicle = implement.object, loadFromSavegame = implement.loadFromSavegame }\n    local rootVehicle = self.rootVehicle\n    rootVehicle:raiseStateChange(VehicleStateChange.ATTACH, data)\nend\n\n'})}),"\n",(0,o.jsx)(n.h3,{id:"prerequisitespresent",children:"prerequisitesPresent"}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Description"})}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Definition"})}),"\n",(0,o.jsxs)(n.blockquote,{children:["\n",(0,o.jsx)(n.p,{children:"prerequisitesPresent()"}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,o.jsx)(n.table,{children:(0,o.jsx)(n.thead,{children:(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.th,{children:"any"}),(0,o.jsx)(n.th,{children:"specializations"})]})})}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Code"})}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-lua",children:"function AttacherJoints.prerequisitesPresent(specializations)\n    return true\nend\n\n"})}),"\n",(0,o.jsx)(n.h3,{id:"raiseactive",children:"raiseActive"}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Description"})}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Definition"})}),"\n",(0,o.jsxs)(n.blockquote,{children:["\n",(0,o.jsx)(n.p,{children:"raiseActive()"}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,o.jsx)(n.table,{children:(0,o.jsx)(n.thead,{children:(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.th,{children:"any"}),(0,o.jsx)(n.th,{children:"superFunc"})]})})}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Code"})}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-lua",children:"function AttacherJoints:raiseActive(superFunc)\n    local spec = self.spec_attacherJoints\n\n    superFunc( self )\n    for _,implement in pairs(spec.attachedImplements) do\n        if implement.object ~ = nil then\n            implement.object:raiseActive()\n        end\n    end\nend\n\n"})}),"\n",(0,o.jsx)(n.h3,{id:"registeractionevents",children:"registerActionEvents"}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Description"})}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Definition"})}),"\n",(0,o.jsxs)(n.blockquote,{children:["\n",(0,o.jsx)(n.p,{children:"registerActionEvents()"}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,o.jsxs)(n.table,{children:[(0,o.jsx)(n.thead,{children:(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.th,{children:"any"}),(0,o.jsx)(n.th,{children:"superFunc"})]})}),(0,o.jsx)(n.tbody,{children:(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:"any"}),(0,o.jsx)(n.td,{children:"excludedVehicle"})]})})]}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Code"})}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-lua",children:"function AttacherJoints:registerActionEvents(superFunc, excludedVehicle)\n    local spec = self.spec_attacherJoints\n\n    superFunc( self , excludedVehicle)\n    if self ~ = excludedVehicle then\n        -- at first we register the inputs of the selected vehicle\n        -- so they got the higest prio and cannot be overwritten by another vehicle\n        local selectedObject = self:getSelectedObject()\n        if selectedObject ~ = nil and self ~ = selectedObject.vehicle and excludedVehicle ~ = selectedObject.vehicle then\n            selectedObject.vehicle:registerActionEvents()\n        end\n\n        for _,implement in pairs(spec.attachedImplements) do\n            if implement.object ~ = nil then\n                if selectedObject = = nil then printCallstack() end\n                implement.object:registerActionEvents(selectedObject.vehicle)\n            end\n        end\n    end\nend\n\n"})}),"\n",(0,o.jsx)(n.h3,{id:"registerattacherjointxmlpaths",children:"registerAttacherJointXMLPaths"}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Description"})}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Definition"})}),"\n",(0,o.jsxs)(n.blockquote,{children:["\n",(0,o.jsx)(n.p,{children:"registerAttacherJointXMLPaths()"}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,o.jsxs)(n.table,{children:[(0,o.jsx)(n.thead,{children:(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.th,{children:"any"}),(0,o.jsx)(n.th,{children:"schema"})]})}),(0,o.jsx)(n.tbody,{children:(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:"any"}),(0,o.jsx)(n.td,{children:"baseName"})]})})]}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Code"})}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-lua",children:'function AttacherJoints.registerAttacherJointXMLPaths(schema, baseName)\n    schema:setXMLSharedRegistration( "AttacherJoint" , baseName)\n\n    baseName = baseName .. ".attacherJoint(?)"\n\n    schema:register(XMLValueType.NODE_INDEX, baseName .. "#node" , "Node" )\n    schema:register(XMLValueType.NODE_INDEX, baseName .. "#nodeVisual" , "Visual node" )\n\n    schema:register(XMLValueType.BOOL, baseName .. "#supportsHardAttach" , "Supports hard attach" )\n    schema:register(XMLValueType.STRING, baseName .. "#jointType" , "Joint type" , "implement" )\n\n    schema:register(XMLValueType.STRING, baseName .. ".subType#name" , "If defined this type needs to match with the sub type in the tool" )\n    schema:register(XMLValueType.STRING, baseName .. ".subType#brandRestriction" , "If defined it\'s only possible to attach tools from these brands(can be multiple separated by \' \')" )\n    schema:register(XMLValueType.STRING, baseName .. ".subType#vehicleRestriction" , "If defined it\'s only possible to attach tools containing these strings in there xml path(can be multiple separated by \' \')" )\n    schema:register(XMLValueType.BOOL, baseName .. ".subType#subTypeShowWarning" , "Show warning if sub type does not match" , true )\n\n        schema:register(XMLValueType.BOOL, baseName .. "#allowsJointLimitMovement" , "Allows joint limit movement" , true )\n        schema:register(XMLValueType.BOOL, baseName .. "#allowsLowering" , "Allows lowering" , true )\n        schema:register(XMLValueType.BOOL, baseName .. "#isDefaultLowered" , "Default lowered state" , false )\n        schema:register(XMLValueType.BOOL, baseName .. "#allowDetachingWhileLifted" , "Allow detach while lifted" , true )\n            schema:register(XMLValueType.BOOL, baseName .. "#allowFoldingWhileAttached" , "Allow folding while attached" , true )\n\n                schema:register(XMLValueType.BOOL, baseName .. "#canTurnOnImplement" , "Can turn on implement" , true )\n\n                schema:register(XMLValueType.NODE_INDEX, baseName .. ".rotationNode#node" , "Rotation node" )\n                schema:register(XMLValueType.VECTOR_ROT, baseName .. ".rotationNode#lowerRotation" , "Lower rotation" , "0 0 0" )\n                schema:register(XMLValueType.VECTOR_ROT, baseName .. ".rotationNode#upperRotation" , "Upper rotation" , "rotation in i3d" )\n                schema:register(XMLValueType.VECTOR_ROT, baseName .. ".rotationNode#startRotation" , "Start rotation" , "rotation in i3d" )\n\n                schema:register(XMLValueType.NODE_INDEX, baseName .. ".rotationNode2#node" , "Rotation node" )\n                schema:register(XMLValueType.VECTOR_ROT, baseName .. ".rotationNode2#lowerRotation" , "Lower rotation" , "0 0 0" )\n                schema:register(XMLValueType.VECTOR_ROT, baseName .. ".rotationNode2#upperRotation" , "Upper rotation" , "rotation in i3d" )\n\n                schema:register(XMLValueType.NODE_INDEX, baseName .. ".transNode#node" , "Translation node" )\n                schema:register(XMLValueType.FLOAT, baseName .. ".transNode#height" , "Height of visual translation node" , 0.12 )\n                schema:register(XMLValueType.FLOAT, baseName .. ".transNode#minY" , "Min Y translation" )\n                schema:register(XMLValueType.FLOAT, baseName .. ".transNode#maxY" , "Max Y translation" )\n\n                schema:register(XMLValueType.NODE_INDEX, baseName .. ".transNode.dependentBottomArm#node" , "Dependent bottom arm node" )\n                schema:register(XMLValueType.FLOAT, baseName .. ".transNode.dependentBottomArm#threshold" , "If the trans node Y translation is below this threshold the rotation will be set" , "unlimited, so rotation is always set" )\n                schema:register(XMLValueType.VECTOR_ROT, baseName .. ".transNode.dependentBottomArm#rotation" , "Rotation to be set when the translation node is below the threshold" , "0 0 0" )\n\n                schema:register(XMLValueType.FLOAT, baseName .. ".distanceToGround#lower" , "Lower distance to ground" , 0.7 )\n                schema:register(XMLValueType.FLOAT, baseName .. ".distanceToGround#upper" , "Upper distance to ground" , 1.0 )\n\n                schema:register(XMLValueType.ANGLE, baseName .. "#lowerRotationOffset" , "Upper rotation offset" , 0 )\n                schema:register(XMLValueType.ANGLE, baseName .. "#upperRotationOffset" , "Lower rotation offset" , 0 )\n\n                schema:register(XMLValueType.BOOL, baseName .. "#dynamicLowerRotLimit" , "Set the lower rot limit dynamically based on the lowered state(so the attacher can freely rotate between it\'s upper and lower rotation value.E.g.for combines)" , false )\n\n                    schema:register(XMLValueType.BOOL, baseName .. "#lockDownRotLimit" , "Lock down rotation limit" , false )\n                    schema:register(XMLValueType.BOOL, baseName .. "#lockUpRotLimit" , "Lock up rotation limit" , false )\n\n                    schema:register(XMLValueType.BOOL, baseName .. "#lockDownTransLimit" , "Lock down translation limit" , true )\n                    schema:register(XMLValueType.BOOL, baseName .. "#lockUpTransLimit" , "Lock up translation limit" , false )\n\n                    schema:register(XMLValueType.VECTOR_ROT, baseName .. "#lowerRotLimit" , "Lower rotation limit" , "(20 20 20) for implement type, otherwise(0 0 0)" )\n                        schema:register(XMLValueType.VECTOR_ROT, baseName .. "#upperRotLimit" , "Upper rotation limit" , "Lower rot limit" )\n\n                        schema:register(XMLValueType.VECTOR_ 3 , baseName .. "#lowerTransLimit" , "Lower translation limit" , "(0.5 0.5 0.5) for implement type, otherwise(0 0 0)" )\n                            schema:register(XMLValueType.VECTOR_ 3 , baseName .. "#upperTransLimit" , "Upper translation limit" , "Lower trans limit" )\n\n                            schema:register(XMLValueType.VECTOR_ 3 , baseName .. "#jointPositionOffset" , "Joint position offset" , "0 0 0" )\n\n                            schema:register(XMLValueType.VECTOR_ 3 , baseName .. "#rotLimitSpring" , "Rotation limit spring" , "0 0 0" )\n                            schema:register(XMLValueType.VECTOR_ 3 , baseName .. "#rotLimitDamping" , "Rotation limit damping" , "1 1 1" )\n                            schema:register(XMLValueType.VECTOR_ 3 , baseName .. "#rotLimitForceLimit" , "Rotation limit force limit" , "-1 -1 -1" )\n\n                            schema:register(XMLValueType.VECTOR_ 3 , baseName .. "#transLimitSpring" , "Translation limit spring" , "0 0 0" )\n                            schema:register(XMLValueType.VECTOR_ 3 , baseName .. "#transLimitDamping" , "Translation limit damping" , "1 1 1" )\n                            schema:register(XMLValueType.VECTOR_ 3 , baseName .. "#transLimitForceLimit" , "Translation limit force limit" , "-1 -1 -1" )\n\n                            schema:register(XMLValueType.FLOAT, baseName .. "#moveTime" , "Move time" , 0.5 )\n                            schema:register(XMLValueType.VECTOR_N, baseName .. "#disabledByAttacherJoints" , "This attacher becomes unavailable after attaching something to these attacher joint indices" )\n                            schema:register(XMLValueType.BOOL, baseName .. "#enableCollision" , "Collision between vehicle is enabled" , false )\n\n                            AttacherJointTopArm.registerVehicleXMLPaths(schema, baseName .. ".topArm" )\n\n                            schema:register(XMLValueType.NODE_INDEX, baseName .. ".bottomArm#rotationNode" , "Rotation node of bottom arm" )\n                            schema:register(XMLValueType.NODE_INDEX, baseName .. ".bottomArm#translationNode" , "Translation node of bottom arm" )\n                            schema:register(XMLValueType.NODE_INDEX, baseName .. ".bottomArm#referenceNode" , "Reference node of bottom arm" )\n                            schema:register(XMLValueType.VECTOR_ROT, baseName .. ".bottomArm#startRotation" , "Start rotation" , "values set in i3d" )\n                            schema:register(XMLValueType.INT, baseName .. ".bottomArm#zScale" , "Inverts bottom arm direction" , 1 )\n                            schema:register(XMLValueType.BOOL, baseName .. ".bottomArm#lockDirection" , "Lock direction" , true )\n                            schema:register(XMLValueType.ANGLE, baseName .. ".bottomArm#resetSpeed" , "Speed of bottom arm to return to idle position(deg/sec)" , 45 )\n                            schema:register(XMLValueType.BOOL, baseName .. ".bottomArm#updateReferenceDistance" , "If \'true\', the reference distance will be updated dynamically.So it\'s possible to adjust the bottom arm length." , false )\n                            schema:register(XMLValueType.NODE_INDEX, baseName .. ".bottomArm#jointPositionNode" , "Node that will be equalized with the current attacher joint position of the attached implement" )\n                            schema:register(XMLValueType.BOOL, baseName .. ".bottomArm#toggleVisibility" , "Bottom arm will be hidden on detach" , false )\n                            schema:register(XMLValueType.VECTOR_N, baseName .. ".bottomArm#categoryRange" , "Defines the min.and max.category that can be used separated by a whitespace. (if only one value is given it will be used as min.and max.value.)" , "1 4" )\n                                schema:register(XMLValueType.VECTOR_N, baseName .. ".bottomArm#widthRange" , "Defines the min.and max.bottom arm width that can be used separated by a whitespace.Overwrites the categoryRange attribute. (if only one value is given it will be used as min.and max.value.)" )\n                                    schema:register(XMLValueType.FLOAT, baseName .. ".bottomArm#defaultWidth" , "Defines the default bottom arm width while nothing is attached" , "Width inside i3d file" )\n                                        schema:register(XMLValueType.INT, baseName .. ".bottomArm#defaultCategory" , "Defines the default width category which is used when nothing is attached" , "Width inside i3d file" )\n                                        schema:register(XMLValueType.BOOL, baseName .. ".bottomArm#ballVisibility" , "Defines if the balls of the tool are visible while the tool is attached to us" , true )\n                                            schema:register(XMLValueType.NODE_INDEX, baseName .. ".bottomArm.armLeft#node" , "Left bottom arm" )\n                                            schema:register(XMLValueType.NODE_INDEX, baseName .. ".bottomArm.armLeft#referenceNode" , "Left bottom arm reference node(placed at the attaching point at the end of the bottom arm.If not defined the arm will be translated on the X axis to the target width.)" )\n                                            schema:register(XMLValueType.NODE_INDEX, baseName .. ".bottomArm.armRight#node" , "Right bottom arm" )\n                                            schema:register(XMLValueType.NODE_INDEX, baseName .. ".bottomArm.armRight#referenceNode" , "Right bottom arm reference node(placed at the attaching point at the end of the bottom arm.If not defined the arm will be translated on the X axis to the target width.)" )\n\n                                            schema:register(XMLValueType.NODE_INDEX, baseName .. ".bottomArm#leftNode" , "Node of moving tool that will be aligned to \'bottomArmLeftNode\', if defined in the tool" )\n                                                schema:register(XMLValueType.NODE_INDEX, baseName .. ".bottomArm#rightNode" , "Node of moving tool that will be aligned to \'bottomArmRightNode\', if defined in the tool" )\n\n                                                    schema:register(XMLValueType.STRING, baseName .. ".toolbar#filename" , "Filename to toolbars i3d containing 5 meshes for category 0-4" , "$data/shared/assets/toolbars/toolbars.i3d" )\n\n                                                        SoundManager.registerSampleXMLPaths(schema, baseName, "attachSound" )\n                                                        SoundManager.registerSampleXMLPaths(schema, baseName, "detachSound" )\n\n                                                        schema:register(XMLValueType.NODE_INDEX, baseName .. ".steeringBars#leftNode" , "Steering bar left node" )\n                                                        schema:register(XMLValueType.NODE_INDEX, baseName .. ".steeringBars#rightNode" , "Steering bar right node" )\n                                                        schema:register(XMLValueType.BOOL, baseName .. ".steeringBars#forceUsage" , "Forces usage of tools steering axle even if no steering bars are defined" , true )\n\n                                                            schema:register(XMLValueType.NODE_INDEX, baseName .. ".visualAlignNode(?)#node" , "Node of movingPart that should point towards the inputAttacherJoint node of the implement" )\n                                                            schema:register(XMLValueType.BOOL, baseName .. ".visualAlignNode(?)#delayedOnAttach" , "Node is updated after the smooth attach is finished" , true )\n\n                                                            schema:register(XMLValueType.NODE_INDICES, baseName .. ".visuals#nodes" , "Visual nodes of attacher joint that will be visible when the joint is active" )\n                                                            schema:register(XMLValueType.NODE_INDICES, baseName .. ".visuals#hide" , "Visual nodes that will be hidden while attacher joint is active if there attacher is inactive" )\n\n                                                                ObjectChangeUtil.registerObjectChangeXMLPaths(schema, baseName)\n                                                                schema:register(XMLValueType.BOOL, baseName .. "#delayedObjectChanges" , "Defines if object change is deactivated after the bottomArm has moved(if available)" , true )\n                                                                    schema:register(XMLValueType.BOOL, baseName .. "#delayedObjectChangesOnAttach" , "Defines if object change is activated on attach or post attach" , false )\n\n                                                                        schema:register(XMLValueType.INT, baseName .. "#direction" , "Direction of attacher joint(1 = front, -1 = back).Used for additional attachments on mobile and top light control in basegame." )\n                                                                            schema:register(XMLValueType.BOOL, baseName .. "#useTopLights" , "Defines if the attacher joint enables the top lights if something is attached.Flag needs to be set on the implement as well." , "\'true\' if the attacher joint is on the front" )\n\n                                                                                schema:register(XMLValueType.NODE_INDEX, baseName .. "#rootNode" , "Root node" , "Parent component of attacher joint node" )\n\n                                                                                schema:register(XMLValueType.FLOAT, baseName .. "#comboTime" , "Combo time" )\n\n                                                                                schema:register(XMLValueType.VECTOR_ 2 , baseName .. ".schema#position" , "Schema position" )\n                                                                                schema:register(XMLValueType.VECTOR_ 2 , baseName .. ".schema#liftedOffset" , "Offset if lifted" , "0 5" )\n                                                                                    schema:register(XMLValueType.ANGLE, baseName .. ".schema#rotation" , "Schema rotation" , 0 )\n                                                                                    schema:register(XMLValueType.BOOL, baseName .. ".schema#invertX" , "Invert X" , false )\n\n                                                                                    schema:addDelayedRegistrationPath(baseName, "AttacherJoint" )\n\n                                                                                    schema:resetXMLSharedRegistration( "AttacherJoint" , baseName)\n                                                                                end\n\n'})}),"\n",(0,o.jsx)(n.h3,{id:"registereventlisteners",children:"registerEventListeners"}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Description"})}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Definition"})}),"\n",(0,o.jsxs)(n.blockquote,{children:["\n",(0,o.jsx)(n.p,{children:"registerEventListeners()"}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,o.jsx)(n.table,{children:(0,o.jsx)(n.thead,{children:(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.th,{children:"any"}),(0,o.jsx)(n.th,{children:"vehicleType"})]})})}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Code"})}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-lua",children:'function AttacherJoints.registerEventListeners(vehicleType)\n    SpecializationUtil.registerEventListener(vehicleType, "onPreLoad" , AttacherJoints )\n    SpecializationUtil.registerEventListener(vehicleType, "onLoad" , AttacherJoints )\n    SpecializationUtil.registerEventListener(vehicleType, "onPostLoad" , AttacherJoints )\n    SpecializationUtil.registerEventListener(vehicleType, "onLoadFinished" , AttacherJoints )\n    SpecializationUtil.registerEventListener(vehicleType, "onRegisterDashboardValueTypes" , AttacherJoints )\n    SpecializationUtil.registerEventListener(vehicleType, "onPreDelete" , AttacherJoints )\n    SpecializationUtil.registerEventListener(vehicleType, "onDelete" , AttacherJoints )\n    SpecializationUtil.registerEventListener(vehicleType, "onReadStream" , AttacherJoints )\n    SpecializationUtil.registerEventListener(vehicleType, "onWriteStream" , AttacherJoints )\n    SpecializationUtil.registerEventListener(vehicleType, "onUpdateInterpolation" , AttacherJoints )\n    SpecializationUtil.registerEventListener(vehicleType, "onUpdate" , AttacherJoints )\n    SpecializationUtil.registerEventListener(vehicleType, "onUpdateEnd" , AttacherJoints )\n    SpecializationUtil.registerEventListener(vehicleType, "onUpdateTick" , AttacherJoints )\n    SpecializationUtil.registerEventListener(vehicleType, "onRegisterActionEvents" , AttacherJoints )\n    SpecializationUtil.registerEventListener(vehicleType, "onStateChange" , AttacherJoints )\n    SpecializationUtil.registerEventListener(vehicleType, "onLightsTypesMaskChanged" , AttacherJoints )\n    SpecializationUtil.registerEventListener(vehicleType, "onTurnLightStateChanged" , AttacherJoints )\n    SpecializationUtil.registerEventListener(vehicleType, "onBrakeLightsVisibilityChanged" , AttacherJoints )\n    SpecializationUtil.registerEventListener(vehicleType, "onReverseLightsVisibilityChanged" , AttacherJoints )\n    SpecializationUtil.registerEventListener(vehicleType, "onBeaconLightsVisibilityChanged" , AttacherJoints )\n    SpecializationUtil.registerEventListener(vehicleType, "onBrake" , AttacherJoints )\n    SpecializationUtil.registerEventListener(vehicleType, "onTurnedOn" , AttacherJoints )\n    SpecializationUtil.registerEventListener(vehicleType, "onTurnedOff" , AttacherJoints )\n    SpecializationUtil.registerEventListener(vehicleType, "onLeaveVehicle" , AttacherJoints )\n    SpecializationUtil.registerEventListener(vehicleType, "onActivate" , AttacherJoints )\n    SpecializationUtil.registerEventListener(vehicleType, "onDeactivate" , AttacherJoints )\n    SpecializationUtil.registerEventListener(vehicleType, "onReverseDirectionChanged" , AttacherJoints )\nend\n\n'})}),"\n",(0,o.jsx)(n.h3,{id:"registerevents",children:"registerEvents"}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Description"})}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Definition"})}),"\n",(0,o.jsxs)(n.blockquote,{children:["\n",(0,o.jsx)(n.p,{children:"registerEvents()"}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,o.jsx)(n.table,{children:(0,o.jsx)(n.thead,{children:(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.th,{children:"any"}),(0,o.jsx)(n.th,{children:"vehicleType"})]})})}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Code"})}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-lua",children:'function AttacherJoints.registerEvents(vehicleType)\n    SpecializationUtil.registerEvent(vehicleType, "onPreAttachImplement" )\n    SpecializationUtil.registerEvent(vehicleType, "onPostAttachImplement" )\n    SpecializationUtil.registerEvent(vehicleType, "onPreDetachImplement" )\n    SpecializationUtil.registerEvent(vehicleType, "onPostDetachImplement" )\n    SpecializationUtil.registerEvent(vehicleType, "onRequiresTopLightsChanged" )\nend\n\n'})}),"\n",(0,o.jsx)(n.h3,{id:"registerfunctions",children:"registerFunctions"}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Description"})}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Definition"})}),"\n",(0,o.jsxs)(n.blockquote,{children:["\n",(0,o.jsx)(n.p,{children:"registerFunctions()"}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,o.jsx)(n.table,{children:(0,o.jsx)(n.thead,{children:(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.th,{children:"any"}),(0,o.jsx)(n.th,{children:"vehicleType"})]})})}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Code"})}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-lua",children:'function AttacherJoints.registerFunctions(vehicleType)\n    SpecializationUtil.registerFunction(vehicleType, "loadAttachmentsFinished" , AttacherJoints.loadAttachmentsFinished)\n    SpecializationUtil.registerFunction(vehicleType, "handleLowerImplementEvent" , AttacherJoints.handleLowerImplementEvent)\n    SpecializationUtil.registerFunction(vehicleType, "handleLowerImplementByAttacherJointIndex" , AttacherJoints.handleLowerImplementByAttacherJointIndex)\n    SpecializationUtil.registerFunction(vehicleType, "getAttachedImplements" , AttacherJoints.getAttachedImplements)\n    SpecializationUtil.registerFunction(vehicleType, "getAttacherJoints" , AttacherJoints.getAttacherJoints)\n    SpecializationUtil.registerFunction(vehicleType, "getAttacherJointByJointDescIndex" , AttacherJoints.getAttacherJointByJointDescIndex)\n    SpecializationUtil.registerFunction(vehicleType, "getAttacherJointIndexByNode" , AttacherJoints.getAttacherJointIndexByNode)\n    SpecializationUtil.registerFunction(vehicleType, "getAttacherJointByNode" , AttacherJoints.getAttacherJointByNode)\n    SpecializationUtil.registerFunction(vehicleType, "getImplementFromAttacherJointIndex" , AttacherJoints.getImplementFromAttacherJointIndex)\n    SpecializationUtil.registerFunction(vehicleType, "getAttacherJointIndexFromObject" , AttacherJoints.getAttacherJointIndexFromObject)\n    SpecializationUtil.registerFunction(vehicleType, "getAttacherJointDescFromObject" , AttacherJoints.getAttacherJointDescFromObject)\n    SpecializationUtil.registerFunction(vehicleType, "getAttacherJointIndexFromImplementIndex" , AttacherJoints.getAttacherJointIndexFromImplementIndex)\n    SpecializationUtil.registerFunction(vehicleType, "getObjectFromImplementIndex" , AttacherJoints.getObjectFromImplementIndex)\n    SpecializationUtil.registerFunction(vehicleType, "updateAttacherJointGraphics" , AttacherJoints.updateAttacherJointGraphics)\n    SpecializationUtil.registerFunction(vehicleType, "calculateAttacherJointMoveUpperLowerAlpha" , AttacherJoints.calculateAttacherJointMoveUpperLowerAlpha)\n    SpecializationUtil.registerFunction(vehicleType, "doGroundHeightNodeCheck" , AttacherJoints.doGroundHeightNodeCheck)\n    SpecializationUtil.registerFunction(vehicleType, "finishGroundHeightNodeCheck" , AttacherJoints.finishGroundHeightNodeCheck)\n    SpecializationUtil.registerFunction(vehicleType, "groundHeightNodeCheckCallback" , AttacherJoints.groundHeightNodeCheckCallback)\n    SpecializationUtil.registerFunction(vehicleType, "updateAttacherJointRotation" , AttacherJoints.updateAttacherJointRotation)\n    SpecializationUtil.registerFunction(vehicleType, "updateAttacherJointRotationNodes" , AttacherJoints.updateAttacherJointRotationNodes)\n    SpecializationUtil.registerFunction(vehicleType, "updateAttacherJointSettingsByObject" , AttacherJoints.updateAttacherJointSettingsByObject)\n    SpecializationUtil.registerFunction(vehicleType, "setAttacherJointBottomArmWidth" , AttacherJoints.setAttacherJointBottomArmWidth)\n    SpecializationUtil.registerFunction(vehicleType, "attachImplementFromInfo" , AttacherJoints.attachImplementFromInfo)\n    SpecializationUtil.registerFunction(vehicleType, "attachImplement" , AttacherJoints.attachImplement)\n    SpecializationUtil.registerFunction(vehicleType, "postAttachImplement" , AttacherJoints.postAttachImplement)\n    SpecializationUtil.registerFunction(vehicleType, "createAttachmentJoint" , AttacherJoints.createAttachmentJoint)\n    SpecializationUtil.registerFunction(vehicleType, "hardAttachImplement" , AttacherJoints.hardAttachImplement)\n    SpecializationUtil.registerFunction(vehicleType, "hardDetachImplement" , AttacherJoints.hardDetachImplement)\n    SpecializationUtil.registerFunction(vehicleType, "detachImplement" , AttacherJoints.detachImplement)\n    SpecializationUtil.registerFunction(vehicleType, "detachImplementByObject" , AttacherJoints.detachImplementByObject)\n    SpecializationUtil.registerFunction(vehicleType, "playAttachSound" , AttacherJoints.playAttachSound)\n    SpecializationUtil.registerFunction(vehicleType, "playDetachSound" , AttacherJoints.playDetachSound)\n    SpecializationUtil.registerFunction(vehicleType, "detachingIsPossible" , AttacherJoints.detachingIsPossible)\n    SpecializationUtil.registerFunction(vehicleType, "attachAdditionalAttachment" , AttacherJoints.attachAdditionalAttachment)\n    SpecializationUtil.registerFunction(vehicleType, "detachAdditionalAttachment" , AttacherJoints.detachAdditionalAttachment)\n    SpecializationUtil.registerFunction(vehicleType, "getImplementIndexByJointDescIndex" , AttacherJoints.getImplementIndexByJointDescIndex)\n    SpecializationUtil.registerFunction(vehicleType, "getImplementByJointDescIndex" , AttacherJoints.getImplementByJointDescIndex)\n    SpecializationUtil.registerFunction(vehicleType, "getImplementIndexByObject" , AttacherJoints.getImplementIndexByObject)\n    SpecializationUtil.registerFunction(vehicleType, "getImplementByObject" , AttacherJoints.getImplementByObject)\n    SpecializationUtil.registerFunction(vehicleType, "callFunctionOnAllImplements" , AttacherJoints.callFunctionOnAllImplements)\n    SpecializationUtil.registerFunction(vehicleType, "activateAttachments" , AttacherJoints.activateAttachments)\n    SpecializationUtil.registerFunction(vehicleType, "deactivateAttachments" , AttacherJoints.deactivateAttachments)\n    SpecializationUtil.registerFunction(vehicleType, "deactivateAttachmentsLights" , AttacherJoints.deactivateAttachmentsLights)\n    SpecializationUtil.registerFunction(vehicleType, "setJointMoveDown" , AttacherJoints.setJointMoveDown)\n    SpecializationUtil.registerFunction(vehicleType, "getJointMoveDown" , AttacherJoints.getJointMoveDown)\n    SpecializationUtil.registerFunction(vehicleType, "getIsHardAttachAllowed" , AttacherJoints.getIsHardAttachAllowed)\n    SpecializationUtil.registerFunction(vehicleType, "getIsSmoothAttachUpdateAllowed" , AttacherJoints.getIsSmoothAttachUpdateAllowed)\n    SpecializationUtil.registerFunction(vehicleType, "loadAttacherJointFromXML" , AttacherJoints.loadAttacherJointFromXML)\n    SpecializationUtil.registerFunction(vehicleType, "onBottomArmToolbarI3DLoaded" , AttacherJoints.onBottomArmToolbarI3DLoaded)\n    SpecializationUtil.registerFunction(vehicleType, "setSelectedImplementByObject" , AttacherJoints.setSelectedImplementByObject)\n    SpecializationUtil.registerFunction(vehicleType, "getSelectedImplement" , AttacherJoints.getSelectedImplement)\n    SpecializationUtil.registerFunction(vehicleType, "getCanToggleAttach" , AttacherJoints.getCanToggleAttach)\n    SpecializationUtil.registerFunction(vehicleType, "getShowAttachControlBarAction" , AttacherJoints.getShowAttachControlBarAction)\n    SpecializationUtil.registerFunction(vehicleType, "getAttachControlBarActionAccessible" , AttacherJoints.getAttachControlBarActionAccessible)\n    SpecializationUtil.registerFunction(vehicleType, "detachAttachedImplement" , AttacherJoints.detachAttachedImplement)\n    SpecializationUtil.registerFunction(vehicleType, "startAttacherJointCombo" , AttacherJoints.startAttacherJointCombo)\n    SpecializationUtil.registerFunction(vehicleType, "registerSelfLoweringActionEvent" , AttacherJoints.registerSelfLoweringActionEvent)\n    SpecializationUtil.registerFunction(vehicleType, "getIsAttachingAllowed" , AttacherJoints.getIsAttachingAllowed)\n    SpecializationUtil.registerFunction(vehicleType, "getIsAttacherJointCompatible" , AttacherJoints.getIsAttacherJointCompatible)\n    SpecializationUtil.registerFunction(vehicleType, "getCanSteerAttachable" , AttacherJoints.getCanSteerAttachable)\n    SpecializationUtil.registerFunction(vehicleType, "onAttacherJointsVehicleLoaded" , AttacherJoints.onAttacherJointsVehicleLoaded)\n    SpecializationUtil.registerFunction(vehicleType, "getAttachableInfo" , AttacherJoints.getAttachableInfo)\n    SpecializationUtil.registerFunction(vehicleType, "setAttacherJointBlocked" , AttacherJoints.setAttacherJointBlocked)\nend\n\n'})}),"\n",(0,o.jsx)(n.h3,{id:"registerjointtype",children:"registerJointType"}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Description"})}),"\n",(0,o.jsxs)(n.blockquote,{children:["\n",(0,o.jsx)(n.p,{children:"Registration of attacher joint type"}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Definition"})}),"\n",(0,o.jsxs)(n.blockquote,{children:["\n",(0,o.jsx)(n.p,{children:"registerJointType(string name)"}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n",(0,o.jsx)(n.table,{children:(0,o.jsx)(n.thead,{children:(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.th,{children:"string"}),(0,o.jsx)(n.th,{children:"name"}),(0,o.jsx)(n.th,{children:"name if attacher type"})]})})}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Code"})}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-lua",children:'function AttacherJoints.registerJointType(name)\n    local key = "JOINTTYPE_" .. string.upper(name)\n    if AttacherJoints [key] = = nil then\n        AttacherJoints.NUM_JOINTTYPES = AttacherJoints.NUM_JOINTTYPES + 1\n        AttacherJoints [key] = AttacherJoints.NUM_JOINTTYPES\n        AttacherJoints.jointTypeNameToInt[name] = AttacherJoints.NUM_JOINTTYPES\n    end\n\n    return AttacherJoints [key]\nend\n\n'})}),"\n",(0,o.jsx)(n.h3,{id:"registeroverwrittenfunctions",children:"registerOverwrittenFunctions"}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Description"})}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Definition"})}),"\n",(0,o.jsxs)(n.blockquote,{children:["\n",(0,o.jsx)(n.p,{children:"registerOverwrittenFunctions()"}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,o.jsx)(n.table,{children:(0,o.jsx)(n.thead,{children:(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.th,{children:"any"}),(0,o.jsx)(n.th,{children:"vehicleType"})]})})}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Code"})}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-lua",children:'function AttacherJoints.registerOverwrittenFunctions(vehicleType)\n    SpecializationUtil.registerOverwrittenFunction(vehicleType, "raiseActive" , AttacherJoints.raiseActive)\n    SpecializationUtil.registerOverwrittenFunction(vehicleType, "registerActionEvents" , AttacherJoints.registerActionEvents)\n    SpecializationUtil.registerOverwrittenFunction(vehicleType, "removeActionEvents" , AttacherJoints.removeActionEvents)\n    SpecializationUtil.registerOverwrittenFunction(vehicleType, "addToPhysics" , AttacherJoints.addToPhysics)\n    SpecializationUtil.registerOverwrittenFunction(vehicleType, "removeFromPhysics" , AttacherJoints.removeFromPhysics)\n    SpecializationUtil.registerOverwrittenFunction(vehicleType, "getTotalMass" , AttacherJoints.getTotalMass)\n    SpecializationUtil.registerOverwrittenFunction(vehicleType, "getAdditionalComponentMass" , AttacherJoints.getAdditionalComponentMass)\n    SpecializationUtil.registerOverwrittenFunction(vehicleType, "addChildVehicles" , AttacherJoints.addChildVehicles)\n    SpecializationUtil.registerOverwrittenFunction(vehicleType, "getAirConsumerUsage" , AttacherJoints.getAirConsumerUsage)\n    SpecializationUtil.registerOverwrittenFunction(vehicleType, "getRequiresPower" , AttacherJoints.getRequiresPower)\n    SpecializationUtil.registerOverwrittenFunction(vehicleType, "addVehicleToAIImplementList" , AttacherJoints.addVehicleToAIImplementList)\n    SpecializationUtil.registerOverwrittenFunction(vehicleType, "collectAIAgentAttachments" , AttacherJoints.collectAIAgentAttachments)\n    SpecializationUtil.registerOverwrittenFunction(vehicleType, "setAIVehicleObstacleStateDirty" , AttacherJoints.setAIVehicleObstacleStateDirty)\n    SpecializationUtil.registerOverwrittenFunction(vehicleType, "getDirectionSnapAngle" , AttacherJoints.getDirectionSnapAngle)\n    SpecializationUtil.registerOverwrittenFunction(vehicleType, "getFillLevelInformation" , AttacherJoints.getFillLevelInformation)\n    SpecializationUtil.registerOverwrittenFunction(vehicleType, "getHasObjectMounted" , AttacherJoints.getHasObjectMounted)\n    SpecializationUtil.registerOverwrittenFunction(vehicleType, "attachableAddToolCameras" , AttacherJoints.attachableAddToolCameras)\n    SpecializationUtil.registerOverwrittenFunction(vehicleType, "attachableRemoveToolCameras" , AttacherJoints.attachableRemoveToolCameras)\n    SpecializationUtil.registerOverwrittenFunction(vehicleType, "registerSelectableObjects" , AttacherJoints.registerSelectableObjects)\n    SpecializationUtil.registerOverwrittenFunction(vehicleType, "getIsReadyForAutomatedTrainTravel" , AttacherJoints.getIsReadyForAutomatedTrainTravel)\n    SpecializationUtil.registerOverwrittenFunction(vehicleType, "getIsAutomaticShiftingAllowed" , AttacherJoints.getIsAutomaticShiftingAllowed)\n    SpecializationUtil.registerOverwrittenFunction(vehicleType, "loadDashboardGroupFromXML" , AttacherJoints.loadDashboardGroupFromXML)\n    SpecializationUtil.registerOverwrittenFunction(vehicleType, "getIsDashboardGroupActive" , AttacherJoints.getIsDashboardGroupActive)\n    SpecializationUtil.registerOverwrittenFunction(vehicleType, "loadAttacherJointHeightNode" , AttacherJoints.loadAttacherJointHeightNode)\n    SpecializationUtil.registerOverwrittenFunction(vehicleType, "getIsAttacherJointHeightNodeActive" , AttacherJoints.getIsAttacherJointHeightNodeActive)\n    SpecializationUtil.registerOverwrittenFunction(vehicleType, "loadTipSide" , AttacherJoints.loadTipSide)\n    SpecializationUtil.registerOverwrittenFunction(vehicleType, "getIsTipSideAvailable" , AttacherJoints.getIsTipSideAvailable)\n    SpecializationUtil.registerOverwrittenFunction(vehicleType, "loadFillUnitFromXML" , AttacherJoints.loadFillUnitFromXML)\n    SpecializationUtil.registerOverwrittenFunction(vehicleType, "getFillUnitSupportsToolType" , AttacherJoints.getFillUnitSupportsToolType)\n    SpecializationUtil.registerOverwrittenFunction(vehicleType, "isDetachAllowed" , AttacherJoints.isDetachAllowed)\n    SpecializationUtil.registerOverwrittenFunction(vehicleType, "getIsFoldAllowed" , AttacherJoints.getIsFoldAllowed)\n    SpecializationUtil.registerOverwrittenFunction(vehicleType, "getIsWheelFoliageDestructionAllowed" , AttacherJoints.getIsWheelFoliageDestructionAllowed)\n    SpecializationUtil.registerOverwrittenFunction(vehicleType, "getAreControlledActionsAllowed" , AttacherJoints.getAreControlledActionsAllowed)\n    SpecializationUtil.registerOverwrittenFunction(vehicleType, "getConnectionHoseConfigIndex" , AttacherJoints.getConnectionHoseConfigIndex)\n    SpecializationUtil.registerOverwrittenFunction(vehicleType, "getPowerTakeOffConfigIndex" , AttacherJoints.getPowerTakeOffConfigIndex)\n    SpecializationUtil.registerOverwrittenFunction(vehicleType, "loadHoseTargetNode" , AttacherJoints.loadHoseTargetNode)\n    SpecializationUtil.registerOverwrittenFunction(vehicleType, "getIsConnectionTargetUsed" , AttacherJoints.getIsConnectionTargetUsed)\nend\n\n'})}),"\n",(0,o.jsx)(n.h3,{id:"registerselectableobjects",children:"registerSelectableObjects"}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Description"})}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Definition"})}),"\n",(0,o.jsxs)(n.blockquote,{children:["\n",(0,o.jsx)(n.p,{children:"registerSelectableObjects()"}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,o.jsxs)(n.table,{children:[(0,o.jsx)(n.thead,{children:(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.th,{children:"any"}),(0,o.jsx)(n.th,{children:"superFunc"})]})}),(0,o.jsx)(n.tbody,{children:(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:"any"}),(0,o.jsx)(n.td,{children:"selectableObjects"})]})})]}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Code"})}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-lua",children:"function AttacherJoints:registerSelectableObjects(superFunc, selectableObjects)\n    superFunc( self , selectableObjects)\n\n    local spec = self.spec_attacherJoints\n    for _,implement in pairs(spec.attachedImplements) do\n        local object = implement.object\n        if object ~ = nil and object.registerSelectableObjects ~ = nil then\n            object:registerSelectableObjects(selectableObjects)\n        end\n    end\nend\n\n"})}),"\n",(0,o.jsx)(n.h3,{id:"registerselfloweringactionevent",children:"registerSelfLoweringActionEvent"}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Description"})}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Definition"})}),"\n",(0,o.jsxs)(n.blockquote,{children:["\n",(0,o.jsx)(n.p,{children:"registerSelfLoweringActionEvent()"}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,o.jsxs)(n.table,{children:[(0,o.jsx)(n.thead,{children:(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.th,{children:"any"}),(0,o.jsx)(n.th,{children:"actionEventsTable"})]})}),(0,o.jsxs)(n.tbody,{children:[(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:"any"}),(0,o.jsx)(n.td,{children:"inputAction"})]}),(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:"any"}),(0,o.jsx)(n.td,{children:"target"})]}),(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:"any"}),(0,o.jsx)(n.td,{children:"callback"})]}),(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:"any"}),(0,o.jsx)(n.td,{children:"triggerUp"})]}),(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:"any"}),(0,o.jsx)(n.td,{children:"triggerDown"})]}),(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:"any"}),(0,o.jsx)(n.td,{children:"triggerAlways"})]}),(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:"any"}),(0,o.jsx)(n.td,{children:"startActive"})]}),(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:"any"}),(0,o.jsx)(n.td,{children:"callbackState"})]}),(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:"any"}),(0,o.jsx)(n.td,{children:"customIconName"})]}),(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:"any"}),(0,o.jsx)(n.td,{children:"ignoreCollisions"})]})]})]}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Code"})}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-lua",children:"function AttacherJoints:registerSelfLoweringActionEvent(actionEventsTable, inputAction, target, callback, triggerUp, triggerDown, triggerAlways, startActive, callbackState, customIconName, ignoreCollisions)\nend\n\n"})}),"\n",(0,o.jsx)(n.h3,{id:"removeactionevents",children:"removeActionEvents"}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Description"})}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Definition"})}),"\n",(0,o.jsxs)(n.blockquote,{children:["\n",(0,o.jsx)(n.p,{children:"removeActionEvents()"}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,o.jsx)(n.table,{children:(0,o.jsx)(n.thead,{children:(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.th,{children:"any"}),(0,o.jsx)(n.th,{children:"superFunc"})]})})}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Code"})}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-lua",children:"function AttacherJoints:removeActionEvents(superFunc)\n    local spec = self.spec_attacherJoints\n\n    superFunc( self )\n\n    for _,implement in pairs(spec.attachedImplements) do\n        if implement.object ~ = nil then\n            implement.object:removeActionEvents()\n        end\n    end\nend\n\n"})}),"\n",(0,o.jsx)(n.h3,{id:"removefromphysics",children:"removeFromPhysics"}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Description"})}),"\n",(0,o.jsxs)(n.blockquote,{children:["\n",(0,o.jsx)(n.p,{children:"Add to physics"}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Definition"})}),"\n",(0,o.jsxs)(n.blockquote,{children:["\n",(0,o.jsx)(n.p,{children:"removeFromPhysics()"}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,o.jsx)(n.table,{children:(0,o.jsx)(n.thead,{children:(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.th,{children:"any"}),(0,o.jsx)(n.th,{children:"superFunc"})]})})}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Return Values"})}),"\n\n\n\n\n\n\n\n\n",(0,o.jsx)(n.table,{children:(0,o.jsx)(n.thead,{children:(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.th,{children:"any"}),(0,o.jsx)(n.th,{children:"success"}),(0,o.jsx)(n.th,{children:"success"})]})})}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Code"})}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-lua",children:"function AttacherJoints:removeFromPhysics(superFunc)\n    local spec = self.spec_attacherJoints\n\n    for _, implement in pairs(spec.attachedImplements) do\n        if not implement.object.spec_attachable.isHardAttached then\n            local jointDesc = spec.attacherJoints[implement.jointDescIndex]\n            if jointDesc.jointIndex ~ = 0 then\n                jointDesc.jointIndex = 0\n            end\n        else\n                -- needs to be called on hard attached implements, as it automatically is removed from physics as well\n                implement.object:removeFromPhysics()\n            end\n        end\n\n        if not superFunc( self ) then\n            return false\n        end\n\n        return true\n    end\n\n"})}),"\n",(0,o.jsx)(n.h3,{id:"savetoxmlfile",children:"saveToXMLFile"}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Description"})}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Definition"})}),"\n",(0,o.jsxs)(n.blockquote,{children:["\n",(0,o.jsx)(n.p,{children:"saveToXMLFile()"}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,o.jsxs)(n.table,{children:[(0,o.jsx)(n.thead,{children:(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.th,{children:"any"}),(0,o.jsx)(n.th,{children:"xmlFile"})]})}),(0,o.jsxs)(n.tbody,{children:[(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:"any"}),(0,o.jsx)(n.td,{children:"key"})]}),(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:"any"}),(0,o.jsx)(n.td,{children:"usedModNames"})]})]})]}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Code"})}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-lua",children:'function AttacherJoints:saveToXMLFile(xmlFile, key, usedModNames)\n    local spec = self.spec_attacherJoints\n    if spec.attacherJointCombos ~ = nil then\n        xmlFile:setValue(key .. "#comboDirection" , spec.attacherJointCombos.direction)\n    end\n\n    if spec.attacherJoints ~ = nil then\n        for index, implement in ipairs(spec.attachedImplements) do\n            if implement.object ~ = nil then\n                local attacherJointKey = string.format( "%s.attachedImplement(%d)" , key, index - 1 )\n\n                local jointDesc = self:getAttacherJointByJointDescIndex(implement.jointDescIndex)\n                xmlFile:setValue(attacherJointKey .. "#jointIndex" , implement.jointDescIndex)\n                xmlFile:setValue(attacherJointKey .. "#moveDown" , jointDesc.moveDown)\n\n                xmlFile:setValue(attacherJointKey .. "#attachedVehicleUniqueId" , implement.object:getUniqueId())\n                xmlFile:setValue(attacherJointKey .. "#inputJointIndex" , implement.inputJointDescIndex)\n            end\n        end\n\n        local index = 0\n        for jointIndex, jointDesc in pairs(spec.attacherJoints) do\n            if jointDesc.isBlocked then\n                local attacherJointKey = string.format( "%s.attacherJoint(%d)" , key, index)\n                xmlFile:setValue(attacherJointKey .. "#jointIndex" , jointIndex)\n\n                xmlFile:setValue(attacherJointKey .. "#isBlocked" , jointDesc.isBlocked)\n\n                index = index + 1\n            end\n        end\n    end\nend\n\n'})}),"\n",(0,o.jsx)(n.h3,{id:"setaivehicleobstaclestatedirty",children:"setAIVehicleObstacleStateDirty"}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Description"})}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Definition"})}),"\n",(0,o.jsxs)(n.blockquote,{children:["\n",(0,o.jsx)(n.p,{children:"setAIVehicleObstacleStateDirty()"}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,o.jsx)(n.table,{children:(0,o.jsx)(n.thead,{children:(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.th,{children:"any"}),(0,o.jsx)(n.th,{children:"superFunc"})]})})}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Code"})}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-lua",children:"function AttacherJoints:setAIVehicleObstacleStateDirty(superFunc)\n    superFunc( self )\n\n    for _, implement in pairs( self:getAttachedImplements()) do\n        local object = implement.object\n        if object ~ = nil and object.setAIVehicleObstacleStateDirty ~ = nil then\n            object:setAIVehicleObstacleStateDirty()\n        end\n    end\nend\n\n"})}),"\n",(0,o.jsx)(n.h3,{id:"setattacherjointbottomarmwidth",children:"setAttacherJointBottomArmWidth"}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Description"})}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Definition"})}),"\n",(0,o.jsxs)(n.blockquote,{children:["\n",(0,o.jsx)(n.p,{children:"setAttacherJointBottomArmWidth()"}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,o.jsxs)(n.table,{children:[(0,o.jsx)(n.thead,{children:(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.th,{children:"any"}),(0,o.jsx)(n.th,{children:"jointDescIndex"})]})}),(0,o.jsx)(n.tbody,{children:(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:"any"}),(0,o.jsx)(n.td,{children:"width"})]})})]}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Code"})}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-lua",children:"function AttacherJoints:setAttacherJointBottomArmWidth(jointDescIndex, width)\n    local spec = self.spec_attacherJoints\n    local jointDesc = spec.attacherJoints[jointDescIndex]\n    local bottomArm = jointDesc.bottomArm\n\n    if bottomArm ~ = nil and bottomArm.variableWidthAvailable ~ = nil then\n        width = width or bottomArm.defaultWidth\n\n        if bottomArm.armLeftReferenceNode ~ = nil and bottomArm.armRightReferenceNode ~ = nil then\n            local upX, upY, upZ = localDirectionToWorld(bottomArm.rotationNode, 0 , 1 , 0 )\n\n            local wx, wy, wz = localToWorld(bottomArm.referenceNode, width * 0.5 , 0 , 0 )\n            local ax, ay, az = getWorldTranslation(bottomArm.armLeft)\n            local dx, dy, dz = MathUtil.vector3Normalize(wx - ax, wy - ay, wz - az)\n            I3DUtil.setWorldDirection(bottomArm.armLeft, dx, dy, dz, upX, upY, upZ, nil , nil , nil )\n\n            wx, wy, wz = localToWorld(bottomArm.referenceNode, - width * 0.5 , 0 , 0 )\n            ax, ay, az = getWorldTranslation(bottomArm.armRight)\n            dx, dy, dz = MathUtil.vector3Normalize(wx - ax, wy - ay, wz - az)\n            I3DUtil.setWorldDirection(bottomArm.armRight, dx, dy, dz, upX, upY, upZ, nil , nil , nil )\n\n            local _, _, zOffsetLeft = localToLocal(bottomArm.armLeftReferenceNode, bottomArm.rotationNode, 0 , 0 , 0 )\n            local _, _, zOffsetRight = localToLocal(bottomArm.armRightReferenceNode, bottomArm.rotationNode, 0 , 0 , 0 )\n            bottomArm.referenceDistance = ( math.abs(zOffsetLeft) + math.abs(zOffsetRight)) * 0.5\n\n            -- update reference node since the toolbars are linked inside\n            setTranslation(bottomArm.referenceNode, 0 , 0 , - bottomArm.referenceDistance)\n        else\n                local _, y, z = getTranslation(bottomArm.armLeft)\n                setTranslation(bottomArm.armLeft, width * 0.5 , y, z)\n\n                _, y, z = getTranslation(bottomArm.armRight)\n                setTranslation(bottomArm.armRight, - width * 0.5 , y, z)\n            end\n\n            if self.setMovingToolDirty ~ = nil then\n                self:setMovingToolDirty(bottomArm.rotationNode)\n            end\n        end\n\n        if bottomArm ~ = nil and bottomArm.toolbars ~ = nil then\n            local activeIndex = AttacherJoints.getClosestLowerLinkCategoryIndex(width or bottomArm.defaultWidth)\n            for index, node in ipairs(jointDesc.bottomArm.toolbars) do\n                setVisibility(node, activeIndex = = index - 1 )\n            end\n        end\n    end\n\n"})}),"\n",(0,o.jsx)(n.h3,{id:"setjointmovedown",children:"setJointMoveDown"}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Description"})}),"\n",(0,o.jsxs)(n.blockquote,{children:["\n",(0,o.jsx)(n.p,{children:"Set joint move down"}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Definition"})}),"\n",(0,o.jsxs)(n.blockquote,{children:["\n",(0,o.jsx)(n.p,{children:"setJointMoveDown(integer jointDescIndex, boolean moveDown, boolean noEventSend)"}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,o.jsxs)(n.table,{children:[(0,o.jsx)(n.thead,{children:(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.th,{children:"integer"}),(0,o.jsx)(n.th,{children:"jointDescIndex"}),(0,o.jsx)(n.th,{children:"index of joint desc"})]})}),(0,o.jsxs)(n.tbody,{children:[(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:"boolean"}),(0,o.jsx)(n.td,{children:"moveDown"}),(0,o.jsx)(n.td,{children:"move down"})]}),(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:"boolean"}),(0,o.jsx)(n.td,{children:"noEventSend"}),(0,o.jsx)(n.td,{children:"no event send"})]})]})]}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Return Values"})}),"\n\n\n\n\n\n\n\n\n",(0,o.jsx)(n.table,{children:(0,o.jsx)(n.thead,{children:(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.th,{children:"boolean"}),(0,o.jsx)(n.th,{children:"success"}),(0,o.jsx)(n.th,{children:"success"})]})})}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Code"})}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-lua",children:"function AttacherJoints:setJointMoveDown(jointDescIndex, moveDown, noEventSend)\n    local spec = self.spec_attacherJoints\n\n    local jointDesc = spec.attacherJoints[jointDescIndex]\n    if jointDesc ~ = nil then\n        if moveDown ~ = jointDesc.moveDown then\n            if jointDesc.allowsLowering then\n                jointDesc.moveDown = moveDown\n                jointDesc.isMoving = true\n\n                local implementIndex = self:getImplementIndexByJointDescIndex(jointDescIndex)\n                if implementIndex ~ = nil then\n                    local implement = spec.attachedImplements[implementIndex]\n                    if implement.object ~ = nil then\n                        implement.object:setLowered(moveDown)\n                    end\n                end\n            end\n\n            VehicleLowerImplementEvent.sendEvent( self , jointDescIndex, moveDown, noEventSend)\n        end\n    end\n\n    return true\nend\n\n"})}),"\n",(0,o.jsx)(n.h3,{id:"setselectedimplementbyobject",children:"setSelectedImplementByObject"}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Description"})}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Definition"})}),"\n",(0,o.jsxs)(n.blockquote,{children:["\n",(0,o.jsx)(n.p,{children:"setSelectedImplementByObject()"}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,o.jsx)(n.table,{children:(0,o.jsx)(n.thead,{children:(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.th,{children:"any"}),(0,o.jsx)(n.th,{children:"object"})]})})}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Code"})}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-lua",children:"function AttacherJoints:setSelectedImplementByObject(object)\n    self.spec_attacherJoints.selectedImplement = self:getImplementByObject(object)\nend\n\n"})}),"\n",(0,o.jsx)(n.h3,{id:"startattacherjointcombo",children:"startAttacherJointCombo"}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Description"})}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Definition"})}),"\n",(0,o.jsxs)(n.blockquote,{children:["\n",(0,o.jsx)(n.p,{children:"startAttacherJointCombo()"}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,o.jsx)(n.table,{children:(0,o.jsx)(n.thead,{children:(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.th,{children:"any"}),(0,o.jsx)(n.th,{children:"force"})]})})}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Code"})}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-lua",children:"function AttacherJoints:startAttacherJointCombo(force)\n    local spec = self.spec_attacherJoints\n\n    if not spec.attacherJointCombos.isRunning or force then\n        spec.attacherJointCombos.direction = - spec.attacherJointCombos.direction\n        spec.attacherJointCombos.isRunning = true\n    end\nend\n\n"})}),"\n",(0,o.jsx)(n.h3,{id:"updateactionevents",children:"updateActionEvents"}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Description"})}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Definition"})}),"\n",(0,o.jsxs)(n.blockquote,{children:["\n",(0,o.jsx)(n.p,{children:"updateActionEvents()"}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,o.jsx)(n.table,{children:(0,o.jsx)(n.thead,{children:(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.th,{children:"any"}),(0,o.jsx)(n.th,{children:"self"})]})})}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Code"})}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-lua",children:'function AttacherJoints.updateActionEvents( self )\n    local spec = self.spec_attacherJoints\n    local info = spec.attachableInfo\n\n    if self.isClient then\n        if spec.actionEvents ~ = nil then\n            local attachActionEvent = spec.actionEvents[InputAction.ATTACH]\n            if attachActionEvent ~ = nil then\n                local visible = false\n\n                if self:getCanToggleAttach() then\n                    if info.warning ~ = nil then\n                        g_currentMission:showBlinkingWarning(info.warning, 500 )\n                    end\n\n                    local text = ""\n                    local prio = GS_PRIO_VERY_LOW\n\n                    local selectedVehicle = self:getSelectedVehicle()\n                    if selectedVehicle ~ = nil and not selectedVehicle.isDeleted and selectedVehicle.isDetachAllowed ~ = nil and selectedVehicle:isDetachAllowed() then\n                        if selectedVehicle:getAttacherVehicle() ~ = nil then\n                            visible = true\n                            text = spec.texts.actionDetach\n                        end\n                    end\n\n                    if info.attacherVehicle ~ = nil then\n                        if g_currentMission.accessHandler:canFarmAccess( self:getActiveFarm(), info.attachable) then\n                            visible = true\n                            text = spec.texts.actionAttach\n                            g_currentMission:showAttachContext(info.attachable)\n                            prio = GS_PRIO_VERY_HIGH\n                        else\n                                spec.showAttachNotAllowedText = 100\n                            end\n                        end\n\n                        g_inputBinding:setActionEventText(attachActionEvent.actionEventId, text)\n                        g_inputBinding:setActionEventTextPriority(attachActionEvent.actionEventId, prio)\n                    end\n\n                    g_inputBinding:setActionEventTextVisibility(attachActionEvent.actionEventId, visible)\n                end\n\n                local lowerActionEvent = spec.actionEvents[InputAction.LOWER_IMPLEMENT]\n                if lowerActionEvent ~ = nil then\n                    local showLower = false\n                    local text = ""\n                    local selectedImplement = self:getSelectedImplement()\n                    if selectedImplement ~ = nil then\n                        for _, attachedImplement in pairs(spec.attachedImplements) do\n                            if attachedImplement = = selectedImplement then\n                                showLower, text = attachedImplement.object:getLoweringActionEventState()\n                                break\n                            end\n                        end\n                    elseif #spec.attachedImplements = = 1 then\n                            local attachedImplement = spec.attachedImplements[ 1 ]\n                            showLower, text = attachedImplement.object:getLoweringActionEventState()\n                        end\n\n                        g_inputBinding:setActionEventActive(lowerActionEvent.actionEventId, showLower)\n                        g_inputBinding:setActionEventText(lowerActionEvent.actionEventId, text)\n                        g_inputBinding:setActionEventTextPriority(lowerActionEvent.actionEventId, GS_PRIO_NORMAL)\n                    end\n                end\n            end\n        end\n\n'})}),"\n",(0,o.jsx)(n.h3,{id:"updateattacherjointgraphics",children:"updateAttacherJointGraphics"}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Description"})}),"\n",(0,o.jsxs)(n.blockquote,{children:["\n",(0,o.jsx)(n.p,{children:"Update attacher joint graphics"}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Definition"})}),"\n",(0,o.jsxs)(n.blockquote,{children:["\n",(0,o.jsx)(n.p,{children:"updateAttacherJointGraphics(table implement, float dt, )"}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,o.jsxs)(n.table,{children:[(0,o.jsx)(n.thead,{children:(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.th,{children:"table"}),(0,o.jsx)(n.th,{children:"implement"}),(0,o.jsx)(n.th,{children:"implement"})]})}),(0,o.jsxs)(n.tbody,{children:[(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:"float"}),(0,o.jsx)(n.td,{children:"dt"}),(0,o.jsx)(n.td,{children:"time since last call in ms"})]}),(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:"any"}),(0,o.jsx)(n.td,{children:"forceUpdate"}),(0,o.jsx)(n.td,{})]})]})]}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Code"})}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-lua",children:"function AttacherJoints:updateAttacherJointGraphics(implement, dt, forceUpdate)\n    local spec = self.spec_attacherJoints\n\n    if implement.object ~ = nil then\n        local jointDesc = spec.attacherJoints[implement.jointDescIndex]\n\n        local attacherJoint = implement.object:getInputAttacherJointByJointDescIndex(implement.inputJointDescIndex)\n\n        if jointDesc.bottomArm ~ = nil then\n            local ax, ay, az = getWorldTranslation(jointDesc.bottomArm.rotationNode)\n            local bx, by, bz = getWorldTranslation(attacherJoint.node)\n\n            local x, y, z = worldDirectionToLocal(getParent(jointDesc.bottomArm.rotationNode), bx - ax, by - ay, bz - az)\n            local distance = MathUtil.vector3Length(x,y,z)\n            local upX, upY, upZ = 0 , 1 , 0\n            if math.abs(y) > 0.99 * distance then\n                -- direction and up is parallel\n                upY = 0\n                if y > 0 then\n                    upZ = 1\n                else\n                        upZ = - 1\n                    end\n                end\n                local dirX, dirY, dirZ = 0 , y * jointDesc.bottomArm.zScale, z * jointDesc.bottomArm.zScale\n                if not jointDesc.bottomArm.lockDirection then\n                    dirX = x * jointDesc.bottomArm.zScale\n                end\n\n                local changed = false\n                if math.abs(jointDesc.bottomArm.lastDirection[ 1 ] - dirX) > 0.001 or\n                    math.abs(jointDesc.bottomArm.lastDirection[ 2 ] - dirY) > 0.001 or\n                    math.abs(jointDesc.bottomArm.lastDirection[ 3 ] - dirZ) > 0.001 then\n\n                    if implement.attachingIsInProgress then\n                        -- set only direction node so we can use this rotation as reference for the interpolator\n                            setDirection(jointDesc.bottomArm.rotationNodeDir, dirX, dirY, dirZ, upX, upY, upZ)\n                        else\n                                setDirection(jointDesc.bottomArm.rotationNode, dirX, dirY, dirZ, upX, upY, upZ)\n                            end\n\n                            jointDesc.bottomArm.lastDirection[ 1 ] = dirX\n                            jointDesc.bottomArm.lastDirection[ 2 ] = dirY\n                            jointDesc.bottomArm.lastDirection[ 3 ] = dirZ\n\n                            changed = true\n                        end\n\n                        if implement.attachingIsInProgress then\n                            if changed then\n                                if not implement.bottomArmInterpolating then\n                                    local interpolator = ValueInterpolator.new(jointDesc.bottomArm.interpolatorKey, jointDesc.bottomArm.interpolatorGet, jointDesc.bottomArm.interpolatorSet, { getRotation(jointDesc.bottomArm.rotationNodeDir) } , AttacherJoints.SMOOTH_ATTACH_TIME)\n                                    if interpolator ~ = nil then\n                                        interpolator:setDeleteListenerObject( self )\n                                        interpolator:setFinishedFunc(jointDesc.bottomArm.interpolatorFinished, jointDesc.bottomArm)\n\n                                        jointDesc.bottomArm.bottomArmInterpolating = true\n                                        implement.bottomArmInterpolating = true\n                                        implement.bottomArmInterpolator = interpolator\n                                    end\n                                else\n                                        local rx, ry, rz = getRotation(jointDesc.bottomArm.rotationNodeDir)\n                                        local target = implement.bottomArmInterpolator:getTarget()\n                                        target[ 1 ], target[ 2 ], target[ 3 ] = rx, ry, rz\n                                        implement.bottomArmInterpolator:updateSpeed()\n                                    end\n                                end\n                            else\n                                    if implement.bottomArmInterpolator ~ = nil then\n                                        ValueInterpolator.removeInterpolator(jointDesc.bottomArm.interpolatorKey)\n                                        jointDesc.bottomArm.bottomArmInterpolating = false\n                                        implement.bottomArmInterpolating = false\n                                        implement.bottomArmInterpolator = nil\n                                    end\n                                end\n\n                                if jointDesc.bottomArm.translationNode ~ = nil and not implement.attachingIsInProgress then\n                                    if jointDesc.bottomArm.updateReferenceDistance then\n                                        jointDesc.bottomArm.referenceDistance = calcDistanceFrom(jointDesc.bottomArm.referenceNode, jointDesc.bottomArm.translationNode)\n                                    end\n\n                                    setTranslation(jointDesc.bottomArm.translationNode, 0 , 0 , (distance - jointDesc.bottomArm.referenceDistance) * jointDesc.bottomArm.zScale)\n                                end\n\n                                if jointDesc.bottomArm.jointPositionNode ~ = nil and not implement.attachingIsInProgress then\n                                    setWorldTranslation(jointDesc.bottomArm.jointPositionNode, bx, by, bz)\n\n                                    if self.setMovingToolDirty ~ = nil then\n                                        self:setMovingToolDirty(jointDesc.bottomArm.jointPositionNode, forceUpdate, dt)\n                                    end\n                                end\n\n                                if self.setMovingToolDirty ~ = nil then\n                                    self:setMovingToolDirty(jointDesc.bottomArm.rotationNode, forceUpdate, dt)\n                                end\n\n                                if attacherJoint.needsToolbar and jointDesc.bottomArm.toolbarNode ~ = nil then\n                                    local parent = getParent(jointDesc.bottomArm.toolbarNode)\n\n                                    local xDir, yDir, zDir = localDirectionToLocal(attacherJoint.node, jointDesc.rootNode, 1 , 0 , 0 )\n                                    xDir, yDir, zDir = localDirectionToLocal(jointDesc.rootNode, parent, 0 , yDir, zDir)\n\n                                    local xUp, yUp, zUp = localDirectionToLocal(attacherJoint.node, jointDesc.rootNode, 0 , 1 , 0 )\n                                    xUp, yUp, zUp = localDirectionToLocal(jointDesc.rootNode, parent, 0 , yUp, zUp)\n\n                                    setDirection(jointDesc.bottomArm.toolbarNode, xDir, yDir, zDir, xUp, yUp, zUp)\n                                end\n\n                                if self.updateMovingPartByNode ~ = nil then\n                                    if jointDesc.bottomArm.leftNode ~ = nil then\n                                        self:updateMovingPartByNode(jointDesc.bottomArm.leftNode, forceUpdate, dt)\n                                    end\n                                    if jointDesc.bottomArm.rightNode ~ = nil then\n                                        self:updateMovingPartByNode(jointDesc.bottomArm.rightNode, forceUpdate, dt)\n                                    end\n                                end\n                            end\n\n                            -- update top arm after the bottom arm as on some vehicles the top arm mounting is depending on the bottom arm\n                            if jointDesc.topArm ~ = nil then\n                                if not implement.attachingIsInProgress and attacherJoint.topReferenceNode ~ = nil then\n                                    jointDesc.topArm:update(dt, attacherJoint.topReferenceNode)\n                                end\n                            end\n\n                            if jointDesc.visualAlignNodes ~ = nil then\n                                for _, visualAlignNode in ipairs(jointDesc.visualAlignNodes) do\n                                    self:updateMovingPartByNode(visualAlignNode.node, dt)\n                                end\n                            end\n                        end\n                    end\n\n"})}),"\n",(0,o.jsx)(n.h3,{id:"updateattacherjointlimits",children:"updateAttacherJointLimits"}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Description"})}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Definition"})}),"\n",(0,o.jsxs)(n.blockquote,{children:["\n",(0,o.jsx)(n.p,{children:"updateAttacherJointLimits()"}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,o.jsxs)(n.table,{children:[(0,o.jsx)(n.thead,{children:(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.th,{children:"any"}),(0,o.jsx)(n.th,{children:"implement"})]})}),(0,o.jsxs)(n.tbody,{children:[(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:"any"}),(0,o.jsx)(n.td,{children:"attacherJointDesc"})]}),(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:"any"}),(0,o.jsx)(n.td,{children:"inputAttacherJointDesc"})]}),(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:"any"}),(0,o.jsx)(n.td,{children:"axis"})]})]})]}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Code"})}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-lua",children:"function AttacherJoints.updateAttacherJointLimits(implement, attacherJointDesc, inputAttacherJointDesc, axis)\n    local lowerRotLimit = attacherJointDesc.lowerRotLimit[axis] * inputAttacherJointDesc.lowerRotLimitScale[axis]\n    local upperRotLimit = attacherJointDesc.upperRotLimit[axis] * inputAttacherJointDesc.upperRotLimitScale[axis]\n    if inputAttacherJointDesc.fixedRotation then\n        lowerRotLimit = 0\n        upperRotLimit = 0\n    end\n\n    local upperTransLimit = attacherJointDesc.lowerTransLimit[axis] * inputAttacherJointDesc.lowerTransLimitScale[axis]\n    local lowerTransLimit = attacherJointDesc.upperTransLimit[axis] * inputAttacherJointDesc.upperTransLimitScale[axis]\n    implement.lowerRotLimit[axis] = lowerRotLimit\n    implement.upperRotLimit[axis] = upperRotLimit\n\n    implement.lowerTransLimit[axis] = upperTransLimit\n    implement.upperTransLimit[axis] = lowerTransLimit\n\n    if not attacherJointDesc.allowsLowering then\n        implement.upperRotLimit[axis] = lowerRotLimit\n        implement.upperTransLimit[axis] = upperTransLimit\n    end\n\n    local rotLimit = lowerRotLimit\n    local transLimit = upperTransLimit\n    if attacherJointDesc.allowsLowering and attacherJointDesc.allowsJointLimitMovement then\n        if inputAttacherJointDesc.allowsJointRotLimitMovement then\n            rotLimit = MathUtil.lerp(upperRotLimit, lowerRotLimit, attacherJointDesc.moveAlpha)\n        end\n        if inputAttacherJointDesc.allowsJointTransLimitMovement then\n            transLimit = MathUtil.lerp(lowerTransLimit, upperTransLimit, attacherJointDesc.moveAlpha)\n        end\n    end\n\n    return rotLimit, transLimit\nend\n\n"})}),"\n",(0,o.jsx)(n.h3,{id:"updateattacherjointrotation",children:"updateAttacherJointRotation"}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Description"})}),"\n",(0,o.jsxs)(n.blockquote,{children:["\n",(0,o.jsx)(n.p,{children:"Update attacher joint rotations depending on move alpha"}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Definition"})}),"\n",(0,o.jsxs)(n.blockquote,{children:["\n",(0,o.jsx)(n.p,{children:"updateAttacherJointRotation(table jointDesc, table object)"}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,o.jsxs)(n.table,{children:[(0,o.jsx)(n.thead,{children:(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.th,{children:"table"}),(0,o.jsx)(n.th,{children:"jointDesc"}),(0,o.jsx)(n.th,{children:"joint desc of used attacher"})]})}),(0,o.jsx)(n.tbody,{children:(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:"table"}),(0,o.jsx)(n.td,{children:"object"}),(0,o.jsx)(n.td,{children:"object of attached vehicle"})]})})]}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Code"})}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-lua",children:"function AttacherJoints:updateAttacherJointRotation(jointDesc, object)\n    local objectAttacherJoint = object.spec_attachable.attacherJoint\n\n    -- rotate attacher such that\n    local targetRot = MathUtil.lerp(objectAttacherJoint.upperRotationOffset, objectAttacherJoint.lowerRotationOffset, jointDesc.moveAlpha)\n    local curRot = MathUtil.lerp(jointDesc.upperRotationOffset, jointDesc.lowerRotationOffset, jointDesc.moveAlpha)\n    local rotDiff = targetRot - curRot\n\n    setRotation(jointDesc.jointTransform, unpack(jointDesc.jointOrigRot))\n    rotateAboutLocalAxis(jointDesc.jointTransform, rotDiff, 0 , 0 , 1 )\nend\n\n"})}),"\n",(0,o.jsx)(n.h3,{id:"updateattacherjointrotationlimit",children:"updateAttacherJointRotationLimit"}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Description"})}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Definition"})}),"\n",(0,o.jsxs)(n.blockquote,{children:["\n",(0,o.jsx)(n.p,{children:"updateAttacherJointRotationLimit()"}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,o.jsxs)(n.table,{children:[(0,o.jsx)(n.thead,{children:(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.th,{children:"any"}),(0,o.jsx)(n.th,{children:"implement"})]})}),(0,o.jsxs)(n.tbody,{children:[(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:"any"}),(0,o.jsx)(n.td,{children:"attacherJointDesc"})]}),(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:"any"}),(0,o.jsx)(n.td,{children:"axis"})]}),(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:"any"}),(0,o.jsx)(n.td,{children:"force"})]}),(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:"any"}),(0,o.jsx)(n.td,{children:"alpha"})]})]})]}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Code"})}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-lua",children:"function AttacherJoints.updateAttacherJointRotationLimit(implement, attacherJointDesc, axis, force, alpha)\n    local newRotLimit = MathUtil.lerp( math.max(implement.attachingRotLimit[axis], implement.upperRotLimit[axis]),\n    math.max(implement.attachingRotLimit[axis], implement.lowerRotLimit[axis]), alpha)\n    if force or math.abs(newRotLimit - implement.jointRotLimit[axis]) > 0.0005 then\n        local rotLimitDown = - newRotLimit\n        local rotLimitUp = newRotLimit\n        if axis = = 3 then\n            if attacherJointDesc.lockDownRotLimit then\n                rotLimitDown = math.min( - implement.attachingRotLimit[axis], 0 )\n            end\n            if attacherJointDesc.lockUpRotLimit then\n                rotLimitUp = math.max(implement.attachingRotLimit[axis], 0 )\n            end\n            if attacherJointDesc.dynamicLowerRotLimit then\n                if attacherJointDesc.rotationNode ~ = nil then\n                    local rotLimit = math.abs(attacherJointDesc.upperRotation[ 1 ] - attacherJointDesc.lowerRotation[ 1 ]) * alpha\n                    rotLimitUp = rotLimit\n                    rotLimitDown = 0\n                end\n            end\n        end\n\n        setJointRotationLimit(attacherJointDesc.jointIndex, axis - 1 , true , rotLimitDown, rotLimitUp)\n        implement.jointRotLimit[axis] = newRotLimit\n    end\nend\n\n"})}),"\n",(0,o.jsx)(n.h3,{id:"updateattacherjointrotationnodes",children:"updateAttacherJointRotationNodes"}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Description"})}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Definition"})}),"\n",(0,o.jsxs)(n.blockquote,{children:["\n",(0,o.jsx)(n.p,{children:"updateAttacherJointRotationNodes()"}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,o.jsxs)(n.table,{children:[(0,o.jsx)(n.thead,{children:(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.th,{children:"any"}),(0,o.jsx)(n.th,{children:"jointDesc"})]})}),(0,o.jsx)(n.tbody,{children:(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:"any"}),(0,o.jsx)(n.td,{children:"alpha"})]})})]}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Code"})}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-lua",children:"function AttacherJoints:updateAttacherJointRotationNodes(jointDesc, alpha)\n    if jointDesc.rotationNode ~ = nil then\n        setRotation(jointDesc.rotationNode, MathUtil.vector3ArrayLerp(jointDesc.upperRotation, jointDesc.lowerRotation, alpha))\n    end\n    if jointDesc.rotationNode2 ~ = nil then\n        setRotation(jointDesc.rotationNode2, MathUtil.vector3ArrayLerp(jointDesc.upperRotation2, jointDesc.lowerRotation2, alpha))\n    end\nend\n\n"})}),"\n",(0,o.jsx)(n.h3,{id:"updateattacherjointsettingsbyobject",children:"updateAttacherJointSettingsByObject"}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Description"})}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Definition"})}),"\n",(0,o.jsxs)(n.blockquote,{children:["\n",(0,o.jsx)(n.p,{children:"updateAttacherJointSettingsByObject()"}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,o.jsxs)(n.table,{children:[(0,o.jsx)(n.thead,{children:(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.th,{children:"any"}),(0,o.jsx)(n.th,{children:"vehicle"})]})}),(0,o.jsxs)(n.tbody,{children:[(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:"any"}),(0,o.jsx)(n.td,{children:"updateLimit"})]}),(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:"any"}),(0,o.jsx)(n.td,{children:"updateRotationOffset"})]}),(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:"any"}),(0,o.jsx)(n.td,{children:"updateDistanceToGround"})]})]})]}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Code"})}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-lua",children:'function AttacherJoints:updateAttacherJointSettingsByObject(vehicle, updateLimit, updateRotationOffset, updateDistanceToGround)\n    local jointDesc = self:getAttacherJointDescFromObject(vehicle)\n    local implement = self:getImplementByObject(vehicle)\n    local objectAttacherJoint = vehicle:getActiveInputAttacherJoint()\n    if jointDesc ~ = nil and implement ~ = nil then\n        if updateLimit then\n            for i = 1 , 3 do\n                AttacherJoints.updateAttacherJointLimits(implement, jointDesc, objectAttacherJoint, i)\n                AttacherJoints.updateAttacherJointRotationLimit(implement, jointDesc, i, false , jointDesc.moveLimitAlpha)\n                AttacherJoints.updateAttacherJointTranslationLimit(implement, jointDesc, i, false , jointDesc.moveLimitAlpha)\n            end\n        end\n\n        if updateRotationOffset then\n            self:updateAttacherJointRotation(jointDesc, vehicle)\n            if self.isServer then\n                setJointFrame(jointDesc.jointIndex, 0 , jointDesc.jointTransform)\n            end\n        end\n\n        if updateDistanceToGround then\n            local upperAlpha, lowerAlpha = self:calculateAttacherJointMoveUpperLowerAlpha(jointDesc, vehicle)\n            jointDesc.moveTime = jointDesc.moveDefaultTime * math.abs(upperAlpha - lowerAlpha)\n            jointDesc.upperAlpha = upperAlpha\n            jointDesc.lowerAlpha = lowerAlpha\n\n            if self.isClient then\n                if self.updateDashboardValueType ~ = nil then\n                    self:updateDashboardValueType( "attacherJoints.bottomArmPositionMin" )\n                    self:updateDashboardValueType( "attacherJoints.bottomArmPositionMax" )\n                end\n            end\n        end\n    end\nend\n\n'})}),"\n",(0,o.jsx)(n.h3,{id:"updateattacherjointtranslationlimit",children:"updateAttacherJointTranslationLimit"}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Description"})}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Definition"})}),"\n",(0,o.jsxs)(n.blockquote,{children:["\n",(0,o.jsx)(n.p,{children:"updateAttacherJointTranslationLimit()"}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,o.jsxs)(n.table,{children:[(0,o.jsx)(n.thead,{children:(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.th,{children:"any"}),(0,o.jsx)(n.th,{children:"implement"})]})}),(0,o.jsxs)(n.tbody,{children:[(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:"any"}),(0,o.jsx)(n.td,{children:"attacherJointDesc"})]}),(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:"any"}),(0,o.jsx)(n.td,{children:"axis"})]}),(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:"any"}),(0,o.jsx)(n.td,{children:"force"})]}),(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:"any"}),(0,o.jsx)(n.td,{children:"alpha"})]})]})]}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Code"})}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-lua",children:"function AttacherJoints.updateAttacherJointTranslationLimit(implement, attacherJointDesc, axis, force, alpha)\n    local newTransLimit = MathUtil.lerp( math.max(implement.attachingTransLimit[axis], implement.upperTransLimit[axis]),\n    math.max(implement.attachingTransLimit[axis], implement.lowerTransLimit[axis]), alpha)\n\n    if force or math.abs(newTransLimit - implement.jointTransLimit[axis]) > 0.0005 then\n        local transLimitDown = - newTransLimit\n        local transLimitUp = newTransLimit\n        if axis = = 2 then\n            if attacherJointDesc.lockDownTransLimit then\n                transLimitDown = math.min( - implement.attachingTransLimit[axis], 0 )\n            end\n            if attacherJointDesc.lockUpTransLimit then\n                transLimitUp = math.max(implement.attachingTransLimit[axis], 0 )\n            end\n        end\n\n        setJointTranslationLimit(attacherJointDesc.jointIndex, axis - 1 , true , transLimitDown, transLimitUp)\n        implement.jointTransLimit[axis] = newTransLimit\n    end\nend\n\n"})}),"\n",(0,o.jsx)(n.h3,{id:"updaterequiredtoplightsstate",children:"updateRequiredTopLightsState"}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Description"})}),"\n",(0,o.jsxs)(n.blockquote,{children:["\n",(0,o.jsx)(n.p,{children:"Updates the requires top lights state based on the attached implements"}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Definition"})}),"\n",(0,o.jsxs)(n.blockquote,{children:["\n",(0,o.jsx)(n.p,{children:"updateRequiredTopLightsState()"}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,o.jsx)(n.table,{children:(0,o.jsx)(n.thead,{children:(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.th,{children:"any"}),(0,o.jsx)(n.th,{children:"self"})]})})}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Code"})}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-lua",children:'function AttacherJoints.updateRequiredTopLightsState( self )\n    local spec = self.spec_attacherJoints\n    local requiresTopLights = false\n    for i, implement in ipairs(spec.attachedImplements) do\n        local attacherJoint = spec.attacherJoints[implement.jointDescIndex]\n        local implementJoint = implement.object:getActiveInputAttacherJoint()\n        if attacherJoint.useTopLights and implementJoint.useTopLights then\n            requiresTopLights = true\n            break\n        end\n    end\n\n    SpecializationUtil.raiseEvent( self , "onRequiresTopLightsChanged" , requiresTopLights)\nend\n\n'})}),"\n",(0,o.jsx)(n.h3,{id:"updatevehiclesinattachrange",children:"updateVehiclesInAttachRange"}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Description"})}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Definition"})}),"\n",(0,o.jsxs)(n.blockquote,{children:["\n",(0,o.jsx)(n.p,{children:"updateVehiclesInAttachRange()"}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,o.jsxs)(n.table,{children:[(0,o.jsx)(n.thead,{children:(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.th,{children:"any"}),(0,o.jsx)(n.th,{children:"vehicle"})]})}),(0,o.jsxs)(n.tbody,{children:[(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:"any"}),(0,o.jsx)(n.td,{children:"maxDistanceSq"})]}),(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:"any"}),(0,o.jsx)(n.td,{children:"maxAngle"})]}),(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:"any"}),(0,o.jsx)(n.td,{children:"fullUpdate"})]})]})]}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Code"})}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-lua",children:"function AttacherJoints.updateVehiclesInAttachRange(vehicle, maxDistanceSq, maxAngle, fullUpdate)\n    local spec = vehicle.spec_attacherJoints\n\n    if spec ~ = nil then\n        local attachableInfo = spec.attachableInfo\n        local pendingInfo = spec.pendingAttachableInfo\n\n        -- first, check if attached implements can attach something\n            if vehicle.getAttachedImplements ~ = nil then\n                local implements = vehicle:getAttachedImplements()\n                for _,implement in pairs(implements) do\n                    if implement.object ~ = nil then\n                        local attacherVehicle, attacherVehicleJointDescIndex, attachable, attachableJointDescIndex, warning = AttacherJoints.updateVehiclesInAttachRange(implement.object, maxDistanceSq, maxAngle, fullUpdate)\n                        if attacherVehicle ~ = nil then\n                            attachableInfo.attacherVehicle, attachableInfo.attacherVehicleJointDescIndex, attachableInfo.attachable, attachableInfo.attachableJointDescIndex, attachableInfo.warning = attacherVehicle, attacherVehicleJointDescIndex, attachable, attachableJointDescIndex, warning\n                            return attacherVehicle, attacherVehicleJointDescIndex, attachable, attachableJointDescIndex, warning\n                        end\n                    end\n                end\n            end\n\n            local numJoints = #g_currentMission.vehicleSystem.inputAttacherJoints\n            local minUpdateJoints = math.max( math.floor(numJoints / 5 ), 1 ) -- update each joint at least every 5 frames\n            local firstJoint = spec.lastInputAttacherCheckIndex % numJoints + 1\n            local lastJoint = math.min(firstJoint + minUpdateJoints, numJoints)\n\n            if fullUpdate then\n                firstJoint = 1\n                lastJoint = numJoints\n            end\n\n            spec.lastInputAttacherCheckIndex = lastJoint % numJoints\n\n            for attacherJointIndex = 1 , #spec.attacherJoints do\n                local attacherJoint = spec.attacherJoints[attacherJointIndex]\n\n                if attacherJoint.jointIndex = = 0 then\n                    if vehicle:getIsAttachingAllowed(attacherJoint) then\n                        local x, y, z = getWorldTranslation(attacherJoint.jointTransform)\n\n                        for i = firstJoint, lastJoint do\n                            local jointInfo = g_currentMission.vehicleSystem.inputAttacherJoints[i]\n\n                            if jointInfo.jointType = = attacherJoint.jointType then\n                                if jointInfo.vehicle:getIsInputAttacherActive(jointInfo.inputAttacherJoint) then\n                                    local distSq = MathUtil.vector2LengthSq(x - jointInfo.translation[ 1 ], z - jointInfo.translation[ 3 ])\n                                    if distSq < maxDistanceSq and distSq < pendingInfo.minDistance then\n                                        local distY = y - jointInfo.translation[ 2 ]\n                                        local distSqY = distY * distY\n\n                                        if distSqY < maxDistanceSq * 4 and distSqY < pendingInfo.minDistanceY then\n                                            if jointInfo.vehicle:getActiveInputAttacherJointDescIndex() = = nil or jointInfo.vehicle:getAllowMultipleAttachments() then\n                                                local compatibility, notAllowedWarning = getAttacherJointCompatibility(vehicle, attacherJoint, jointInfo.vehicle, jointInfo.inputAttacherJoint)\n                                                if compatibility then\n                                                    local angleInRange\n                                                    local attachAngleLimitAxis = jointInfo.inputAttacherJoint.attachAngleLimitAxis\n                                                    if attachAngleLimitAxis = = 1 then\n                                                        local dx, _, _ = localDirectionToLocal(jointInfo.node, attacherJoint.jointTransform, 1 , 0 , 0 )\n                                                        angleInRange = dx > maxAngle\n                                                    elseif attachAngleLimitAxis = = 2 then\n                                                            local _, dy, _ = localDirectionToLocal(jointInfo.node, attacherJoint.jointTransform, 0 , 1 , 0 )\n                                                            angleInRange = dy > maxAngle\n                                                        else\n                                                                local _, _, dz = localDirectionToLocal(jointInfo.node, attacherJoint.jointTransform, 0 , 0 , 1 )\n                                                                angleInRange = dz > maxAngle\n                                                            end\n\n                                                            if angleInRange then\n                                                                pendingInfo.minDistance = distSq\n                                                                pendingInfo.minDistanceY = distSqY\n                                                                pendingInfo.attacherVehicle = vehicle\n                                                                pendingInfo.attacherVehicleJointDescIndex = attacherJointIndex\n                                                                pendingInfo.attachable = jointInfo.vehicle\n                                                                pendingInfo.attachableJointDescIndex = jointInfo.jointIndex\n                                                            end\n                                                        else\n                                                                pendingInfo.warning = pendingInfo.warning or notAllowedWarning\n                                                            end\n                                                        end\n                                                    end\n                                                end\n                                            end\n                                        end\n                                    end\n                                end\n                            end\n                        end\n\n                        if spec.lastInputAttacherCheckIndex = = 0 or numJoints = = 0 then\n                            attachableInfo.attacherVehicle = pendingInfo.attacherVehicle\n                            attachableInfo.attacherVehicleJointDescIndex = pendingInfo.attacherVehicleJointDescIndex\n                            attachableInfo.attachable = pendingInfo.attachable\n                            attachableInfo.attachableJointDescIndex = pendingInfo.attachableJointDescIndex\n                            attachableInfo.warning = pendingInfo.warning\n\n                            pendingInfo.minDistance = math.huge\n                            pendingInfo.minDistanceY = math.huge\n                            pendingInfo.attacherVehicle = nil\n                            pendingInfo.attacherVehicleJointDescIndex = nil\n                            pendingInfo.attachable = nil\n                            pendingInfo.attachableJointDescIndex = nil\n                            pendingInfo.warning = nil\n                        end\n\n                        return attachableInfo.attacherVehicle, attachableInfo.attacherVehicleJointDescIndex, attachableInfo.attachable, attachableInfo.attachableJointDescIndex, attachableInfo.warning\n                    end\n\n                    return nil , nil , nil , nil\n                end\n\n"})})]})}function h(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(d,{...e})}):d(e)}}}]);