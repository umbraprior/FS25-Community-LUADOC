"use strict";(globalThis.webpackChunkfs25_community_luadoc=globalThis.webpackChunkfs25_community_luadoc||[]).push([[12215],{10670(e,n,i){i.r(n),i.d(n,{assets:()=>o,contentTitle:()=>s,default:()=>h,frontMatter:()=>d,metadata:()=>l,toc:()=>c});const l=JSON.parse('{"id":"script/Specializations/Foldable","title":"Foldable","description":"Foldable","source":"@site/../docs/script/Specializations/Foldable.md","sourceDirName":"script/Specializations","slug":"/script/Specializations/Foldable","permalink":"/FS25-Community-LUADOC/script/Specializations/Foldable","draft":false,"unlisted":false,"tags":[],"version":"current","lastUpdatedAt":1767161192000,"frontMatter":{},"sidebar":"docsSidebar","previous":{"title":"FillVolume","permalink":"/FS25-Community-LUADOC/script/Specializations/FillVolume"},"next":{"title":"FoliageBending","permalink":"/FS25-Community-LUADOC/script/Specializations/FoliageBending"}}');var t=i(74848),r=i(28453);const d={},s=void 0,o={},c=[{value:"Foldable",id:"foldable",level:2},{value:"actionControllerFoldEvent",id:"actioncontrollerfoldevent",level:3},{value:"actionControllerLowerEvent",id:"actioncontrollerlowerevent",level:3},{value:"actionControllerLowerEventAIStart",id:"actioncontrollerlowereventaistart",level:3},{value:"actionEventFold",id:"actioneventfold",level:3},{value:"actionEventFoldAll",id:"actioneventfoldall",level:3},{value:"actionEventFoldMiddle",id:"actioneventfoldmiddle",level:3},{value:"allowLoadMovingToolStates",id:"allowloadmovingtoolstates",level:3},{value:"externalActionEventRegister",id:"externalactioneventregister",level:3},{value:"externalActionEventUpdate",id:"externalactioneventupdate",level:3},{value:"getAllowDynamicMountObjects",id:"getallowdynamicmountobjects",level:3},{value:"getAllowsLowering",id:"getallowslowering",level:3},{value:"getBrakeForce",id:"getbrakeforce",level:3},{value:"getCanAIImplementContinueWork",id:"getcanaiimplementcontinuework",level:3},{value:"getCanBeSelected",id:"getcanbeselected",level:3},{value:"getCanBeTurnedOn",id:"getcanbeturnedon",level:3},{value:"getCanChangePickupState",id:"getcanchangepickupstate",level:3},{value:"getCanToggleCrabSteering",id:"getcantogglecrabsteering",level:3},{value:"getCrabSteeringModeAvailable",id:"getcrabsteeringmodeavailable",level:3},{value:"getCraneShovelStateChangedAllowed",id:"getcraneshovelstatechangedallowed",level:3},{value:"getCutterTiltIsActive",id:"getcuttertiltisactive",level:3},{value:"getFillUnitSupportsToolType",id:"getfillunitsupportstooltype",level:3},{value:"getFoldAnimTime",id:"getfoldanimtime",level:3},{value:"getIsAdditionalCharacterActive",id:"getisadditionalcharacteractive",level:3},{value:"getIsAIPreparingToDrive",id:"getisaipreparingtodrive",level:3},{value:"getIsAIReadyToDrive",id:"getisaireadytodrive",level:3},{value:"getIsAttacherJointHeightNodeActive",id:"getisattacherjointheightnodeactive",level:3},{value:"getIsFoldActionAllowed",id:"getisfoldactionallowed",level:3},{value:"getIsFoldAllowed",id:"getisfoldallowed",level:3},{value:"getIsFoldMiddleAllowed",id:"getisfoldmiddleallowed",level:3},{value:"getIsGroundAdjustedNodeActive",id:"getisgroundadjustednodeactive",level:3},{value:"getIsInputAttacherActive",id:"getisinputattacheractive",level:3},{value:"getIsInWorkPosition",id:"getisinworkposition",level:3},{value:"getIsLevelerPickupNodeActive",id:"getislevelerpickupnodeactive",level:3},{value:"getIsLowered",id:"getislowered",level:3},{value:"getIsMovingPartActive",id:"getismovingpartactive",level:3},{value:"getIsMovingToolActive",id:"getismovingtoolactive",level:3},{value:"getIsNextCoverStateAllowed",id:"getisnextcoverstateallowed",level:3},{value:"getIsNextCoverStateAllowedWarning",id:"getisnextcoverstateallowedwarning",level:3},{value:"getIsPreprunerNodeActive",id:"getispreprunernodeactive",level:3},{value:"getIsSpeedRotatingPartActive",id:"getisspeedrotatingpartactive",level:3},{value:"getIsSprayTypeActive",id:"getisspraytypeactive",level:3},{value:"getIsSteeringAxleAllowed",id:"getissteeringaxleallowed",level:3},{value:"getIsSupportAnimationAllowed",id:"getissupportanimationallowed",level:3},{value:"getIsSuspensionNodeActive",id:"getissuspensionnodeactive",level:3},{value:"getIsTurnedOnAnimationActive",id:"getisturnedonanimationactive",level:3},{value:"getIsUnfolded",id:"getisunfolded",level:3},{value:"getIsVehicleControlAllowed",id:"getisvehiclecontrolallowed",level:3},{value:"getIsVersatileYRotActive",id:"getisversatileyrotactive",level:3},{value:"getIsWheelChockAllowed",id:"getiswheelchockallowed",level:3},{value:"getIsWoodHarvesterTiltStateAllowed",id:"getiswoodharvestertiltstateallowed",level:3},{value:"getIsWorkAreaActive",id:"getisworkareaactive",level:3},{value:"getRequiresPower",id:"getrequirespower",level:3},{value:"getShovelNodeIsActive",id:"getshovelnodeisactive",level:3},{value:"getSlopeCompensationAngleScale",id:"getslopecompensationanglescale",level:3},{value:"getToggledFoldDirection",id:"gettoggledfolddirection",level:3},{value:"getToggledFoldMiddleDirection",id:"gettoggledfoldmiddledirection",level:3},{value:"getTurnedOnNotAllowedWarning",id:"getturnedonnotallowedwarning",level:3},{value:"initSpecialization",id:"initspecialization",level:3},{value:"isAttachAllowed",id:"isattachallowed",level:3},{value:"isDetachAllowed",id:"isdetachallowed",level:3},{value:"loadAdditionalCharacterFromXML",id:"loadadditionalcharacterfromxml",level:3},{value:"loadAttacherJointHeightNode",id:"loadattacherjointheightnode",level:3},{value:"loadCrabSteeringModeFromXML",id:"loadcrabsteeringmodefromxml",level:3},{value:"loadCraneShovelFromXML",id:"loadcraneshovelfromxml",level:3},{value:"loadCutterTiltFromXML",id:"loadcuttertiltfromxml",level:3},{value:"loadFillUnitFromXML",id:"loadfillunitfromxml",level:3},{value:"loadFoldingPartFromXML",id:"loadfoldingpartfromxml",level:3},{value:"loadGroundAdjustedNodeFromXML",id:"loadgroundadjustednodefromxml",level:3},{value:"loadGroundReferenceNode",id:"loadgroundreferencenode",level:3},{value:"loadInputAttacherJoint",id:"loadinputattacherjoint",level:3},{value:"loadLevelerNodeFromXML",id:"loadlevelernodefromxml",level:3},{value:"loadMovingPartFromXML",id:"loadmovingpartfromxml",level:3},{value:"loadMovingToolFromXML",id:"loadmovingtoolfromxml",level:3},{value:"loadPickupFromXML",id:"loadpickupfromxml",level:3},{value:"loadPreprunerNodeFromXML",id:"loadpreprunernodefromxml",level:3},{value:"loadShovelNode",id:"loadshovelnode",level:3},{value:"loadSlopeCompensationNodeFromXML",id:"loadslopecompensationnodefromxml",level:3},{value:"loadSpeedRotatingPartFromXML",id:"loadspeedrotatingpartfromxml",level:3},{value:"loadSprayTypeFromXML",id:"loadspraytypefromxml",level:3},{value:"loadSteeringAngleNodeFromXML",id:"loadsteeringanglenodefromxml",level:3},{value:"loadSteeringAxleFromXML",id:"loadsteeringaxlefromxml",level:3},{value:"loadSupportAnimationFromXML",id:"loadsupportanimationfromxml",level:3},{value:"loadSuspensionNodeFromXML",id:"loadsuspensionnodefromxml",level:3},{value:"loadTurnedOnAnimationFromXML",id:"loadturnedonanimationfromxml",level:3},{value:"loadWheelFromXML",id:"loadwheelfromxml",level:3},{value:"loadWoodHarvesterHeaderTiltFromXML",id:"loadwoodharvesterheadertiltfromxml",level:3},{value:"loadWorkAreaFromXML",id:"loadworkareafromxml",level:3},{value:"onDeactivate",id:"ondeactivate",level:3},{value:"onDynamicMountTypeChanged",id:"ondynamicmounttypechanged",level:3},{value:"onLoad",id:"onload",level:3},{value:"onLoadWheelChockFromXML",id:"onloadwheelchockfromxml",level:3},{value:"onPostAttach",id:"onpostattach",level:3},{value:"onPostLoad",id:"onpostload",level:3},{value:"onPreAttachImplement",id:"onpreattachimplement",level:3},{value:"onPreDetach",id:"onpredetach",level:3},{value:"onPreDetachImplement",id:"onpredetachimplement",level:3},{value:"onReadStream",id:"onreadstream",level:3},{value:"onRegisterActionEvents",id:"onregisteractionevents",level:3},{value:"onRegistered",id:"onregistered",level:3},{value:"onRegisterExternalActionEvents",id:"onregisterexternalactionevents",level:3},{value:"onRootVehicleChanged",id:"onrootvehiclechanged",level:3},{value:"onSetLoweredAll",id:"onsetloweredall",level:3},{value:"onUpdate",id:"onupdate",level:3},{value:"onUpdateTick",id:"onupdatetick",level:3},{value:"onWriteStream",id:"onwritestream",level:3},{value:"prerequisitesPresent",id:"prerequisitespresent",level:3},{value:"registerEventListeners",id:"registereventlisteners",level:3},{value:"registerEvents",id:"registerevents",level:3},{value:"registerFoldingXMLPaths",id:"registerfoldingxmlpaths",level:3},{value:"registerFunctions",id:"registerfunctions",level:3},{value:"registerLoweringActionEvent",id:"registerloweringactionevent",level:3},{value:"registerOverwrittenFunctions",id:"registeroverwrittenfunctions",level:3},{value:"registerSelfLoweringActionEvent",id:"registerselfloweringactionevent",level:3},{value:"saveToXMLFile",id:"savetoxmlfile",level:3},{value:"setAnimTime",id:"setanimtime",level:3},{value:"setFoldDirection",id:"setfolddirection",level:3},{value:"setFoldMiddleState",id:"setfoldmiddlestate",level:3},{value:"setFoldState",id:"setfoldstate",level:3},{value:"setIsFoldActionAllowed",id:"setisfoldactionallowed",level:3},{value:"updateActionEventFold",id:"updateactioneventfold",level:3},{value:"updateActionEventFoldMiddle",id:"updateactioneventfoldmiddle",level:3},{value:"updateGroundReferenceNode",id:"updategroundreferencenode",level:3},{value:"updateSteeringAngleNode",id:"updatesteeringanglenode",level:3}];function a(e){const n={a:"a",blockquote:"blockquote",code:"code",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,r.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.h2,{id:"foldable",children:"Foldable"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Description"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"Specialization for vehicle parts with two or three folding states (e.g. tedder, cultivator, sowing machine)"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Functions"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#actioncontrollerfoldevent",children:"actionControllerFoldEvent"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#actioncontrollerlowerevent",children:"actionControllerLowerEvent"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#actioncontrollerlowereventaistart",children:"actionControllerLowerEventAIStart"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#actioneventfold",children:"actionEventFold"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#actioneventfoldall",children:"actionEventFoldAll"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#actioneventfoldmiddle",children:"actionEventFoldMiddle"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#allowloadmovingtoolstates",children:"allowLoadMovingToolStates"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#externalactioneventregister",children:"externalActionEventRegister"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#externalactioneventupdate",children:"externalActionEventUpdate"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#getallowdynamicmountobjects",children:"getAllowDynamicMountObjects"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#getallowslowering",children:"getAllowsLowering"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#getbrakeforce",children:"getBrakeForce"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#getcanaiimplementcontinuework",children:"getCanAIImplementContinueWork"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#getcanbeselected",children:"getCanBeSelected"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#getcanbeturnedon",children:"getCanBeTurnedOn"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#getcanchangepickupstate",children:"getCanChangePickupState"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#getcantogglecrabsteering",children:"getCanToggleCrabSteering"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#getcrabsteeringmodeavailable",children:"getCrabSteeringModeAvailable"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#getcraneshovelstatechangedallowed",children:"getCraneShovelStateChangedAllowed"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#getcuttertiltisactive",children:"getCutterTiltIsActive"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#getfillunitsupportstooltype",children:"getFillUnitSupportsToolType"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#getfoldanimtime",children:"getFoldAnimTime"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#getisadditionalcharacteractive",children:"getIsAdditionalCharacterActive"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#getisaipreparingtodrive",children:"getIsAIPreparingToDrive"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#getisaireadytodrive",children:"getIsAIReadyToDrive"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#getisattacherjointheightnodeactive",children:"getIsAttacherJointHeightNodeActive"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#getisfoldactionallowed",children:"getIsFoldActionAllowed"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#getisfoldallowed",children:"getIsFoldAllowed"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#getisfoldmiddleallowed",children:"getIsFoldMiddleAllowed"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#getisgroundadjustednodeactive",children:"getIsGroundAdjustedNodeActive"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#getisinputattacheractive",children:"getIsInputAttacherActive"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#getisinworkposition",children:"getIsInWorkPosition"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#getislevelerpickupnodeactive",children:"getIsLevelerPickupNodeActive"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#getislowered",children:"getIsLowered"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#getismovingpartactive",children:"getIsMovingPartActive"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#getismovingtoolactive",children:"getIsMovingToolActive"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#getisnextcoverstateallowed",children:"getIsNextCoverStateAllowed"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#getisnextcoverstateallowedwarning",children:"getIsNextCoverStateAllowedWarning"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#getispreprunernodeactive",children:"getIsPreprunerNodeActive"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#getisspeedrotatingpartactive",children:"getIsSpeedRotatingPartActive"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#getisspraytypeactive",children:"getIsSprayTypeActive"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#getissteeringaxleallowed",children:"getIsSteeringAxleAllowed"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#getissupportanimationallowed",children:"getIsSupportAnimationAllowed"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#getissuspensionnodeactive",children:"getIsSuspensionNodeActive"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#getisturnedonanimationactive",children:"getIsTurnedOnAnimationActive"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#getisunfolded",children:"getIsUnfolded"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#getisvehiclecontrolallowed",children:"getIsVehicleControlAllowed"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#getisversatileyrotactive",children:"getIsVersatileYRotActive"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#getiswheelchockallowed",children:"getIsWheelChockAllowed"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#getiswoodharvestertiltstateallowed",children:"getIsWoodHarvesterTiltStateAllowed"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#getisworkareaactive",children:"getIsWorkAreaActive"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#getrequirespower",children:"getRequiresPower"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#getshovelnodeisactive",children:"getShovelNodeIsActive"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#getslopecompensationanglescale",children:"getSlopeCompensationAngleScale"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#gettoggledfolddirection",children:"getToggledFoldDirection"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#gettoggledfoldmiddledirection",children:"getToggledFoldMiddleDirection"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#getturnedonnotallowedwarning",children:"getTurnedOnNotAllowedWarning"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#initspecialization",children:"initSpecialization"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#isattachallowed",children:"isAttachAllowed"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#isdetachallowed",children:"isDetachAllowed"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#loadadditionalcharacterfromxml",children:"loadAdditionalCharacterFromXML"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#loadattacherjointheightnode",children:"loadAttacherJointHeightNode"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#loadcrabsteeringmodefromxml",children:"loadCrabSteeringModeFromXML"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#loadcraneshovelfromxml",children:"loadCraneShovelFromXML"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#loadcuttertiltfromxml",children:"loadCutterTiltFromXML"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#loadfillunitfromxml",children:"loadFillUnitFromXML"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#loadfoldingpartfromxml",children:"loadFoldingPartFromXML"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#loadgroundadjustednodefromxml",children:"loadGroundAdjustedNodeFromXML"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#loadgroundreferencenode",children:"loadGroundReferenceNode"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#loadinputattacherjoint",children:"loadInputAttacherJoint"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#loadlevelernodefromxml",children:"loadLevelerNodeFromXML"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#loadmovingpartfromxml",children:"loadMovingPartFromXML"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#loadmovingtoolfromxml",children:"loadMovingToolFromXML"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#loadpickupfromxml",children:"loadPickupFromXML"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#loadpreprunernodefromxml",children:"loadPreprunerNodeFromXML"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#loadshovelnode",children:"loadShovelNode"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#loadslopecompensationnodefromxml",children:"loadSlopeCompensationNodeFromXML"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#loadspeedrotatingpartfromxml",children:"loadSpeedRotatingPartFromXML"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#loadspraytypefromxml",children:"loadSprayTypeFromXML"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#loadsteeringanglenodefromxml",children:"loadSteeringAngleNodeFromXML"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#loadsteeringaxlefromxml",children:"loadSteeringAxleFromXML"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#loadsupportanimationfromxml",children:"loadSupportAnimationFromXML"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#loadsuspensionnodefromxml",children:"loadSuspensionNodeFromXML"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#loadturnedonanimationfromxml",children:"loadTurnedOnAnimationFromXML"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#loadwheelfromxml",children:"loadWheelFromXML"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#loadwoodharvesterheadertiltfromxml",children:"loadWoodHarvesterHeaderTiltFromXML"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#loadworkareafromxml",children:"loadWorkAreaFromXML"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#ondeactivate",children:"onDeactivate"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#ondynamicmounttypechanged",children:"onDynamicMountTypeChanged"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#onload",children:"onLoad"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#onloadwheelchockfromxml",children:"onLoadWheelChockFromXML"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#onpostattach",children:"onPostAttach"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#onpostload",children:"onPostLoad"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#onpreattachimplement",children:"onPreAttachImplement"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#onpredetach",children:"onPreDetach"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#onpredetachimplement",children:"onPreDetachImplement"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#onreadstream",children:"onReadStream"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#onregisteractionevents",children:"onRegisterActionEvents"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#onregistered",children:"onRegistered"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#onregisterexternalactionevents",children:"onRegisterExternalActionEvents"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#onrootvehiclechanged",children:"onRootVehicleChanged"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#onsetloweredall",children:"onSetLoweredAll"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#onupdate",children:"onUpdate"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#onupdatetick",children:"onUpdateTick"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#onwritestream",children:"onWriteStream"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#prerequisitespresent",children:"prerequisitesPresent"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#registereventlisteners",children:"registerEventListeners"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#registerevents",children:"registerEvents"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#registerfoldingxmlpaths",children:"registerFoldingXMLPaths"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#registerfunctions",children:"registerFunctions"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#registerloweringactionevent",children:"registerLoweringActionEvent"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#registeroverwrittenfunctions",children:"registerOverwrittenFunctions"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#registerselfloweringactionevent",children:"registerSelfLoweringActionEvent"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#savetoxmlfile",children:"saveToXMLFile"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#setanimtime",children:"setAnimTime"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#setfolddirection",children:"setFoldDirection"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#setfoldmiddlestate",children:"setFoldMiddleState"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#setfoldstate",children:"setFoldState"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#setisfoldactionallowed",children:"setIsFoldActionAllowed"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#updateactioneventfold",children:"updateActionEventFold"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#updateactioneventfoldmiddle",children:"updateActionEventFoldMiddle"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#updategroundreferencenode",children:"updateGroundReferenceNode"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#updatesteeringanglenode",children:"updateSteeringAngleNode"})}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"actioncontrollerfoldevent",children:"actionControllerFoldEvent"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Description"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Definition"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"actionControllerFoldEvent()"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,t.jsx)(n.table,{children:(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"any"}),(0,t.jsx)(n.th,{children:"direction"})]})})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Code"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:"function Foldable:actionControllerFoldEvent(direction)\n    local spec = self.spec_foldable\n\n    if spec.hasFoldingParts then\n        if self:getIsFoldMiddleAllowed() then\n            if spec.foldAnimTime > 0 and spec.foldAnimTime < spec.foldMiddleAnimTime then\n                return false\n            end\n        end\n\n        direction = spec.turnOnFoldDirection * direction\n        if self:getIsFoldAllowed(direction, false ) then\n            if direction = = spec.turnOnFoldDirection then\n                if (direction < 0 and spec.foldAnimTime > 0 ) or(direction > 0 and spec.foldAnimTime < 1 ) then\n                    self:setFoldState(direction, true )\n                end\n            else\n                    if (direction < 0 and spec.foldAnimTime > 0 ) or(direction > 0 and spec.foldAnimTime < 1 ) then\n                        self:setFoldState(direction, false )\n                    end\n                end\n\n                return true\n            end\n        end\n\n        return false\n    end\n\n"})}),"\n",(0,t.jsx)(n.h3,{id:"actioncontrollerlowerevent",children:"actionControllerLowerEvent"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Description"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Definition"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"actionControllerLowerEvent()"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,t.jsx)(n.table,{children:(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"any"}),(0,t.jsx)(n.th,{children:"direction"})]})})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Code"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:"function Foldable:actionControllerLowerEvent(direction)\n    local spec = self.spec_foldable\n    if spec.hasFoldingParts then\n        direction = spec.turnOnFoldDirection * direction\n        if self:getIsFoldMiddleAllowed() then\n            if direction = = spec.turnOnFoldDirection then\n                self:setFoldState(direction, false )\n            else\n                    -- move to fold middle position, no matter where we are\n                    if spec.foldMiddleDirection > 0 then\n                        if spec.foldAnimTime > spec.foldMiddleAnimTime then\n                            self:setFoldState( - direction, true )\n                        else\n                                self:setFoldState(direction, true )\n                            end\n                        else\n                                if spec.foldAnimTime < spec.foldMiddleAnimTime then\n                                    self:setFoldState( - direction, true )\n                                else\n                                        self:setFoldState(direction, true )\n                                    end\n                                end\n                            end\n\n                            return true\n                        end\n                    end\n\n                    return false\n                end\n\n"})}),"\n",(0,t.jsx)(n.h3,{id:"actioncontrollerlowereventaistart",children:"actionControllerLowerEventAIStart"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Description"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Definition"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"actionControllerLowerEventAIStart()"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,t.jsx)(n.table,{children:(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"any"}),(0,t.jsx)(n.th,{children:"direction"})]})})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Code"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:"function Foldable:actionControllerLowerEventAIStart(direction)\n    local spec = self.spec_foldable\n    if spec.hasFoldingParts then\n        direction = spec.turnOnFoldDirection * direction\n        if self:getIsFoldMiddleAllowed() then\n            if spec.foldAnimTime > = spec.foldMiddleAnimTime then\n                return true\n            end\n\n            -- move to fold middle position, no matter where we are\n            if spec.foldMiddleDirection > 0 then\n                if spec.foldAnimTime > spec.foldMiddleAnimTime then\n                    self:setFoldState( - direction, true )\n                else\n                        self:setFoldState(direction, true )\n                    end\n                else\n                        if spec.foldAnimTime < spec.foldMiddleAnimTime then\n                            self:setFoldState( - direction, true )\n                        else\n                                self:setFoldState(direction, true )\n                            end\n                        end\n                    end\n                end\n\n                return true\n            end\n\n"})}),"\n",(0,t.jsx)(n.h3,{id:"actioneventfold",children:"actionEventFold"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Description"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Definition"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"actionEventFold()"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"any"}),(0,t.jsx)(n.th,{children:"self"})]})}),(0,t.jsxs)(n.tbody,{children:[(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"any"}),(0,t.jsx)(n.td,{children:"actionName"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"any"}),(0,t.jsx)(n.td,{children:"inputValue"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"any"}),(0,t.jsx)(n.td,{children:"callbackState"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"any"}),(0,t.jsx)(n.td,{children:"isAnalog"})]})]})]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Code"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:"function Foldable.actionEventFold( self , actionName, inputValue, callbackState, isAnalog)\n    local spec = self.spec_foldable\n\n    if spec.hasFoldingParts then\n        local toggleDirection = self:getToggledFoldDirection()\n        local allowed, warning = self:getIsFoldAllowed(toggleDirection, false )\n        if allowed then\n            if toggleDirection = = spec.turnOnFoldDirection then\n                self:setFoldState(toggleDirection, true )\n            else\n                    self:setFoldState(toggleDirection, false )\n\n                    -- while using folding and the tool is still lowered\n                        -- so we need to lift up the attacher joint as well\n                        if self:getIsFoldMiddleAllowed() then\n                            if self.getAttacherVehicle ~ = nil then\n                                local attacherVehicle = self:getAttacherVehicle()\n                                local attacherJointIndex = attacherVehicle:getAttacherJointIndexFromObject( self )\n                                if attacherJointIndex ~ = nil then\n                                    local moveDown = attacherVehicle:getJointMoveDown(attacherJointIndex)\n                                    local targetMoveDown = toggleDirection = = spec.turnOnFoldDirection\n                                    if targetMoveDown ~ = moveDown then\n                                        attacherVehicle:setJointMoveDown(attacherJointIndex, targetMoveDown)\n                                    end\n                                end\n                            end\n                        end\n                    end\n                elseif warning ~ = nil then\n                        g_currentMission:showBlinkingWarning(warning, 2000 )\n                    end\n                end\n            end\n\n"})}),"\n",(0,t.jsx)(n.h3,{id:"actioneventfoldall",children:"actionEventFoldAll"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Description"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Definition"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"actionEventFoldAll()"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"any"}),(0,t.jsx)(n.th,{children:"self"})]})}),(0,t.jsxs)(n.tbody,{children:[(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"any"}),(0,t.jsx)(n.td,{children:"actionName"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"any"}),(0,t.jsx)(n.td,{children:"inputValue"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"any"}),(0,t.jsx)(n.td,{children:"callbackState"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"any"}),(0,t.jsx)(n.td,{children:"isAnalog"})]})]})]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Code"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:"function Foldable.actionEventFoldAll( self , actionName, inputValue, callbackState, isAnalog)\n    local spec = self.spec_foldable\n\n    if spec.hasFoldingParts then\n        local displayWarning = true\n        local warningToDisplay = nil\n        local toggleDirection = self:getToggledFoldDirection()\n        local allowed, warning = self:getIsFoldAllowed(toggleDirection, false )\n        if allowed then\n            if toggleDirection = = spec.turnOnFoldDirection then\n                self:setFoldState(toggleDirection, true )\n            else\n                    self:setFoldState(toggleDirection, false )\n                end\n                displayWarning = false\n            elseif warning ~ = nil then\n                    warningToDisplay = warning\n                end\n\n                local vehicles = self.rootVehicle:getChildVehicles()\n                for i = 1 , #vehicles do\n                    local vehicle = vehicles[i]\n                    if vehicle.setFoldState ~ = nil then\n                        local spec2 = vehicle.spec_foldable\n                        if #spec2.foldingParts > 0 then\n                            local toggleDirection2 = vehicle:getToggledFoldDirection()\n                            local allowed2, warning2 = vehicle:getIsFoldAllowed(toggleDirection, false )\n                            if allowed2 then\n                                if (toggleDirection = = spec.turnOnFoldDirection) = = (toggleDirection2 = = spec2.turnOnFoldDirection) then\n                                    if toggleDirection2 = = spec2.turnOnFoldDirection then\n                                        vehicle:setFoldState(toggleDirection2, true )\n                                    else\n                                            vehicle:setFoldState(toggleDirection2, false )\n                                        end\n                                        displayWarning = false\n                                    end\n                                elseif warning2 ~ = nil then\n                                        warningToDisplay = warning2\n                                    end\n                                end\n                            end\n                        end\n\n                        if displayWarning and warningToDisplay ~ = nil then\n                            g_currentMission:showBlinkingWarning(warningToDisplay, 2000 )\n                        end\n                    end\n                end\n\n"})}),"\n",(0,t.jsx)(n.h3,{id:"actioneventfoldmiddle",children:"actionEventFoldMiddle"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Description"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Definition"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"actionEventFoldMiddle()"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"any"}),(0,t.jsx)(n.th,{children:"self"})]})}),(0,t.jsxs)(n.tbody,{children:[(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"any"}),(0,t.jsx)(n.td,{children:"actionName"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"any"}),(0,t.jsx)(n.td,{children:"inputValue"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"any"}),(0,t.jsx)(n.td,{children:"callbackState"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"any"}),(0,t.jsx)(n.td,{children:"isAnalog"})]})]})]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Code"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:"function Foldable.actionEventFoldMiddle( self , actionName, inputValue, callbackState, isAnalog)\n    local spec = self.spec_foldable\n\n    if spec.hasFoldingParts then\n        if self:getIsFoldMiddleAllowed() then\n            local ignoreFoldMiddle = false\n            if spec.ignoreFoldMiddleWhileFolded then\n                if self:getFoldAnimTime() > spec.foldMiddleAnimTime then\n                    ignoreFoldMiddle = true\n                end\n            end\n\n            if not ignoreFoldMiddle then\n                local direction = self:getToggledFoldMiddleDirection()\n                if direction ~ = 0 then\n                    if direction = = spec.turnOnFoldDirection then\n                        self:setFoldState(direction, false )\n                    else\n                            self:setFoldState(direction, true )\n                        end\n\n                        -- equalize moveDown state of the attacher joint with the inverse fold middle state\n                        -- before we execute setJointMoveDown with the AttacherJoints.actionEventLowerImplement below\n                        -- so the fold middle state and the joint move down state are always in line\n                        if self.getAttacherVehicle ~ = nil then\n                            local attacherVehicle = self:getAttacherVehicle()\n                            local attacherJointIndex = attacherVehicle:getAttacherJointIndexFromObject( self )\n                            if attacherJointIndex ~ = nil then\n                                local moveDown = attacherVehicle:getJointMoveDown(attacherJointIndex)\n                                local targetMoveDown = direction = = spec.turnOnFoldDirection\n                                if targetMoveDown ~ = moveDown then\n                                    attacherVehicle:setJointMoveDown(attacherJointIndex, targetMoveDown)\n                                end\n                            end\n                        end\n                    end\n                elseif self.getAttacherVehicle ~ = nil then\n                        local attacherVehicle = self:getAttacherVehicle()\n                        if attacherVehicle ~ = nil then\n                            attacherVehicle:handleLowerImplementEvent( self )\n                        end\n                    end\n                end\n            end\n        end\n\n"})}),"\n",(0,t.jsx)(n.h3,{id:"allowloadmovingtoolstates",children:"allowLoadMovingToolStates"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Description"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Definition"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"allowLoadMovingToolStates()"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,t.jsx)(n.table,{children:(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"any"}),(0,t.jsx)(n.th,{children:"superFunc"})]})})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Code"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:"function Foldable:allowLoadMovingToolStates(superFunc)\n    local spec = self.spec_foldable\n\n    if spec.foldAnimTime > spec.loadMovingToolStatesMaxLimit or spec.foldAnimTime < spec.loadMovingToolStatesMinLimit then\n        return false\n    end\n\n    return superFunc( self )\nend\n\n"})}),"\n",(0,t.jsx)(n.h3,{id:"externalactioneventregister",children:"externalActionEventRegister"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Description"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Definition"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"externalActionEventRegister()"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"any"}),(0,t.jsx)(n.th,{children:"data"})]})}),(0,t.jsx)(n.tbody,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"any"}),(0,t.jsx)(n.td,{children:"vehicle"})]})})]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Code"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:"function Foldable.externalActionEventRegister(data, vehicle)\n    local spec = vehicle.spec_foldable\n\n    local function actionEvent(_, actionName, inputValue, callbackState, isAnalog)\n        Motorized.tryStartMotor(vehicle)\n\n        if spec.requiresPower then\n            local isPowered, warning = vehicle:getIsPowered()\n            if isPowered then\n                Foldable.actionEventFold(vehicle, actionName, inputValue, callbackState, isAnalog)\n            else\n                    if inputValue ~ = 0 and warning ~ = nil then\n                        g_currentMission:showBlinkingWarning(warning, 2000 )\n                    end\n                end\n            else\n                    Foldable.actionEventFold(vehicle, actionName, inputValue, callbackState, isAnalog)\n                end\n            end\n\n            local _\n            _, data.actionEventId = g_inputBinding:registerActionEvent(spec.foldInputButton, data, actionEvent, false , true , false , true )\n            g_inputBinding:setActionEventTextPriority(data.actionEventId, GS_PRIO_HIGH)\n        end\n\n"})}),"\n",(0,t.jsx)(n.h3,{id:"externalactioneventupdate",children:"externalActionEventUpdate"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Description"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Definition"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"externalActionEventUpdate()"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"any"}),(0,t.jsx)(n.th,{children:"data"})]})}),(0,t.jsx)(n.tbody,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"any"}),(0,t.jsx)(n.td,{children:"vehicle"})]})})]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Code"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:"function Foldable.externalActionEventUpdate(data, vehicle)\n    local spec = vehicle.spec_foldable\n\n    if data.actionEventId ~ = nil then\n        local text\n        if vehicle:getToggledFoldDirection() = = spec.turnOnFoldDirection then\n            text = spec.negDirectionText\n        else\n                text = spec.posDirectionText\n            end\n            g_inputBinding:setActionEventText(data.actionEventId, text)\n        end\n    end\n\n"})}),"\n",(0,t.jsx)(n.h3,{id:"getallowdynamicmountobjects",children:"getAllowDynamicMountObjects"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Description"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Definition"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"getAllowDynamicMountObjects()"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,t.jsx)(n.table,{children:(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"any"}),(0,t.jsx)(n.th,{children:"superFunc"})]})})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Code"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:"function Foldable:getAllowDynamicMountObjects(superFunc)\n    local spec = self.spec_foldable\n    local foldAnimTime = self:getFoldAnimTime()\n    if foldAnimTime < spec.dynamicMountMinLimit or foldAnimTime > spec.dynamicMountMaxLimit then\n        return false\n    end\n\n    return superFunc( self )\nend\n\n"})}),"\n",(0,t.jsx)(n.h3,{id:"getallowslowering",children:"getAllowsLowering"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Description"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"Returns true if tool can be lowered"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Definition"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"getAllowsLowering()"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,t.jsx)(n.table,{children:(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"any"}),(0,t.jsx)(n.th,{children:"superFunc"})]})})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Return Values"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"any"}),(0,t.jsx)(n.th,{children:"detachAllowed"}),(0,t.jsx)(n.th,{children:"detach is allowed"})]})}),(0,t.jsx)(n.tbody,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"any"}),(0,t.jsx)(n.td,{children:"warning"}),(0,t.jsx)(n.td,{children:"[optional] warning text to display"})]})})]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Code"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:"function Foldable:getAllowsLowering(superFunc)\n    local spec = self.spec_foldable\n\n    if spec.foldAnimTime > spec.loweringMaxLimit or spec.foldAnimTime < spec.loweringMinLimit then\n        return false , spec.unfoldWarning\n    end\n\n    return superFunc( self )\nend\n\n"})}),"\n",(0,t.jsx)(n.h3,{id:"getbrakeforce",children:"getBrakeForce"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Description"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Definition"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"getBrakeForce()"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,t.jsx)(n.table,{children:(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"any"}),(0,t.jsx)(n.th,{children:"superFunc"})]})})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Code"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:"function Foldable:getBrakeForce(superFunc)\n    local spec = self.spec_foldable\n    if spec.releaseBrakesWhileFolding then\n        if spec.foldMoveDirection ~ = 0 then\n            return 0\n        end\n    end\n\n    return superFunc( self )\nend\n\n"})}),"\n",(0,t.jsx)(n.h3,{id:"getcanaiimplementcontinuework",children:"getCanAIImplementContinueWork"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Description"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Definition"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"getCanAIImplementContinueWork()"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"any"}),(0,t.jsx)(n.th,{children:"superFunc"})]})}),(0,t.jsx)(n.tbody,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"any"}),(0,t.jsx)(n.td,{children:"isTurning"})]})})]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Code"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:"function Foldable:getCanAIImplementContinueWork(superFunc, isTurning)\n    local canContinue, stopAI, stopReason = superFunc( self , isTurning)\n    if not canContinue then\n        return false , stopAI, stopReason\n    end\n\n    local spec = self.spec_foldable\n\n    if spec.hasFoldingParts and spec.allowUnfoldingByAI then\n        if spec.foldMiddleAnimTime ~ = nil then\n            if math.abs(spec.foldAnimTime - spec.foldMiddleAnimTime) > 0.001 and spec.foldAnimTime ~ = 0 and spec.foldAnimTime ~ = 1 then\n                -- do not block the ai while lifting the implement to save time\n                    if spec.foldAnimTime > 0 and spec.foldAnimTime < spec.foldMiddleAnimTime then\n                        if spec.foldMoveDirection > 0 then\n                            return true\n                        end\n                    end\n\n                    return false\n                end\n            else\n                    if spec.foldAnimTime ~ = 0 and spec.foldAnimTime ~ = 1 then\n                        return false\n                    end\n                end\n            end\n\n            return canContinue\n        end\n\n"})}),"\n",(0,t.jsx)(n.h3,{id:"getcanbeselected",children:"getCanBeSelected"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Description"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Definition"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"getCanBeSelected()"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,t.jsx)(n.table,{children:(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"any"}),(0,t.jsx)(n.th,{children:"superFunc"})]})})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Code"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:"function Foldable:getCanBeSelected(superFunc)\n    return true\nend\n\n"})}),"\n",(0,t.jsx)(n.h3,{id:"getcanbeturnedon",children:"getCanBeTurnedOn"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Description"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Definition"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"getCanBeTurnedOn()"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,t.jsx)(n.table,{children:(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"any"}),(0,t.jsx)(n.th,{children:"superFunc"})]})})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Code"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:"function Foldable:getCanBeTurnedOn(superFunc)\n    local spec = self.spec_foldable\n    if spec.foldAnimTime > spec.turnOnFoldMaxLimit or spec.foldAnimTime < spec.turnOnFoldMinLimit then\n        return false\n    end\n\n    return superFunc( self )\nend\n\n"})}),"\n",(0,t.jsx)(n.h3,{id:"getcanchangepickupstate",children:"getCanChangePickupState"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Description"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Definition"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"getCanChangePickupState()"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"any"}),(0,t.jsx)(n.th,{children:"superFunc"})]})}),(0,t.jsxs)(n.tbody,{children:[(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"any"}),(0,t.jsx)(n.td,{children:"spec"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"any"}),(0,t.jsx)(n.td,{children:"newState"})]})]})]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Code"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:"function Foldable:getCanChangePickupState(superFunc, spec, newState)\n    local foldAnimTime = self:getFoldAnimTime()\n    if foldAnimTime < spec.foldMinLimit or foldAnimTime > spec.foldMaxLimit then\n        return false\n    end\n\n    return superFunc( self , spec, newState)\nend\n\n"})}),"\n",(0,t.jsx)(n.h3,{id:"getcantogglecrabsteering",children:"getCanToggleCrabSteering"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Description"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Definition"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"getCanToggleCrabSteering()"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,t.jsx)(n.table,{children:(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"any"}),(0,t.jsx)(n.th,{children:"superFunc"})]})})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Code"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:"function Foldable:getCanToggleCrabSteering(superFunc)\n    local spec = self.spec_foldable\n    local foldAnimTime = self:getFoldAnimTime()\n    if foldAnimTime < spec.crabSteeringMinLimit or foldAnimTime > spec.crabSteeringMaxLimit then\n        return false , spec.unfoldWarning\n    end\n\n    return superFunc( self )\nend\n\n"})}),"\n",(0,t.jsx)(n.h3,{id:"getcrabsteeringmodeavailable",children:"getCrabSteeringModeAvailable"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Description"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Definition"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"getCrabSteeringModeAvailable()"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"any"}),(0,t.jsx)(n.th,{children:"superFunc"})]})}),(0,t.jsx)(n.tbody,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"any"}),(0,t.jsx)(n.td,{children:"mode"})]})})]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Code"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:"function Foldable:getCrabSteeringModeAvailable(superFunc, mode)\n    local foldAnimTime = self:getFoldAnimTime()\n    if foldAnimTime < mode.foldMinLimit or foldAnimTime > mode.foldMaxLimit then\n        return false\n    end\n\n    return superFunc( self , mode)\nend\n\n"})}),"\n",(0,t.jsx)(n.h3,{id:"getcraneshovelstatechangedallowed",children:"getCraneShovelStateChangedAllowed"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Description"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Definition"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"getCraneShovelStateChangedAllowed()"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"any"}),(0,t.jsx)(n.th,{children:"superFunc"})]})}),(0,t.jsx)(n.tbody,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"any"}),(0,t.jsx)(n.td,{children:"spec"})]})})]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Code"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:"function Foldable:getCraneShovelStateChangedAllowed(superFunc, spec)\n    local foldAnimTime = self:getFoldAnimTime()\n    if foldAnimTime ~ = nil and(foldAnimTime < spec.foldableMinLimit or foldAnimTime > spec.foldableMaxLimit) then\n        return false , self.spec_foldable.unfoldWarning\n    end\n\n    return superFunc( self , spec)\nend\n\n"})}),"\n",(0,t.jsx)(n.h3,{id:"getcuttertiltisactive",children:"getCutterTiltIsActive"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Description"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"Returns if cutter tilt is active"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Definition"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"getCutterTiltIsActive()"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"any"}),(0,t.jsx)(n.th,{children:"superFunc"})]})}),(0,t.jsx)(n.tbody,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"any"}),(0,t.jsx)(n.td,{children:"automaticTilt"})]})})]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Return Values"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"any"}),(0,t.jsx)(n.th,{children:"isActive"}),(0,t.jsx)(n.th,{children:"cutter tilt is active"})]})}),(0,t.jsx)(n.tbody,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"any"}),(0,t.jsx)(n.td,{children:"doReset"}),(0,t.jsx)(n.td,{children:"reset header tilt to initial position"})]})})]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Code"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:"function Foldable:getCutterTiltIsActive(superFunc, automaticTilt)\n    local isActive, doReset = superFunc( self , automaticTilt)\n    if not isActive then\n        return isActive, doReset\n    end\n\n    local foldAnimTime = self:getFoldAnimTime()\n    if foldAnimTime < automaticTilt.foldMinLimit or foldAnimTime > automaticTilt.foldMaxLimit then\n        return false , true\n    end\n\n    return true , false\nend\n\n"})}),"\n",(0,t.jsx)(n.h3,{id:"getfillunitsupportstooltype",children:"getFillUnitSupportsToolType"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Description"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Definition"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"getFillUnitSupportsToolType()"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"any"}),(0,t.jsx)(n.th,{children:"superFunc"})]})}),(0,t.jsxs)(n.tbody,{children:[(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"any"}),(0,t.jsx)(n.td,{children:"fillUnitIndex"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"any"}),(0,t.jsx)(n.td,{children:"toolType"})]})]})]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Code"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:"function Foldable:getFillUnitSupportsToolType(superFunc, fillUnitIndex, toolType)\n    -- tool type undefined is always allowed\n    if toolType ~ = ToolType.UNDEFINED then\n        local fillUnit = self.spec_fillUnit.fillUnits[fillUnitIndex]\n        if fillUnit ~ = nil then\n            if fillUnit.foldMinLimit ~ = nil and fillUnit.foldMaxLimit ~ = nil then\n                local foldAnimTime = self:getFoldAnimTime()\n                if foldAnimTime < fillUnit.foldMinLimit or foldAnimTime > fillUnit.foldMaxLimit then\n                    return false\n                end\n            end\n        end\n    end\n\n    return superFunc( self , fillUnitIndex, toolType)\nend\n\n"})}),"\n",(0,t.jsx)(n.h3,{id:"getfoldanimtime",children:"getFoldAnimTime"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Description"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Definition"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"getFoldAnimTime()"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Code"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:"function Foldable:getFoldAnimTime()\n    local spec = self.spec_foldable\n    return spec.loadedFoldAnimTime or spec.foldAnimTime\nend\n\n"})}),"\n",(0,t.jsx)(n.h3,{id:"getisadditionalcharacteractive",children:"getIsAdditionalCharacterActive"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Description"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Definition"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"getIsAdditionalCharacterActive()"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,t.jsx)(n.table,{children:(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"any"}),(0,t.jsx)(n.th,{children:"superFunc"})]})})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Code"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:"function Foldable:getIsAdditionalCharacterActive(superFunc)\n    local spec = self.spec_enterable\n    if spec.additionalCharacterFoldMinLimit ~ = nil and spec.additionalCharacterFoldMaxLimit ~ = nil then\n        local foldAnimTime = self:getFoldAnimTime()\n        if foldAnimTime > = spec.additionalCharacterFoldMinLimit and foldAnimTime < = spec.additionalCharacterFoldMaxLimit then\n            return true\n        end\n    end\n\n    return superFunc( self )\nend\n\n"})}),"\n",(0,t.jsx)(n.h3,{id:"getisaipreparingtodrive",children:"getIsAIPreparingToDrive"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Description"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Definition"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"getIsAIPreparingToDrive()"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,t.jsx)(n.table,{children:(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"any"}),(0,t.jsx)(n.th,{children:"superFunc"})]})})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Code"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:"function Foldable:getIsAIPreparingToDrive(superFunc)\n    local spec = self.spec_foldable\n\n    if spec.hasFoldingParts and spec.allowUnfoldingByAI then\n        if spec.foldAnimTime ~ = spec.foldMiddleAnimTime and spec.foldAnimTime ~ = 0 and spec.foldAnimTime ~ = 1 then\n            return true\n        end\n    end\n\n    return superFunc( self )\nend\n\n"})}),"\n",(0,t.jsx)(n.h3,{id:"getisaireadytodrive",children:"getIsAIReadyToDrive"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Description"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Definition"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"getIsAIReadyToDrive()"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,t.jsx)(n.table,{children:(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"any"}),(0,t.jsx)(n.th,{children:"superFunc"})]})})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Code"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:"function Foldable:getIsAIReadyToDrive(superFunc)\n    local spec = self.spec_foldable\n\n    if spec.hasFoldingParts and spec.allowUnfoldingByAI then\n        if spec.turnOnFoldDirection > 0 then\n            if spec.foldAnimTime > 0 then\n                return false\n            end\n        else\n                if spec.foldAnimTime < 1 then\n                    return false\n                end\n            end\n        end\n\n        return superFunc( self )\n    end\n\n"})}),"\n",(0,t.jsx)(n.h3,{id:"getisattacherjointheightnodeactive",children:"getIsAttacherJointHeightNodeActive"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Description"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Definition"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"getIsAttacherJointHeightNodeActive()"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"any"}),(0,t.jsx)(n.th,{children:"superFunc"})]})}),(0,t.jsx)(n.tbody,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"any"}),(0,t.jsx)(n.td,{children:"heightNode"})]})})]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Code"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:"function Foldable:getIsAttacherJointHeightNodeActive(superFunc, heightNode)\n    local foldAnimTime = self:getFoldAnimTime()\n    if foldAnimTime < heightNode.foldMinLimit or foldAnimTime > heightNode.foldMaxLimit then\n        return false\n    end\n\n    return superFunc( self , heightNode)\nend\n\n"})}),"\n",(0,t.jsx)(n.h3,{id:"getisfoldactionallowed",children:"getIsFoldActionAllowed"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Description"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"Returns if the fold action is shown or not"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Definition"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"getIsFoldActionAllowed()"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Return Values"})}),"\n\n\n\n\n\n\n\n",(0,t.jsx)(n.table,{children:(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"any"}),(0,t.jsx)(n.th,{children:"isFoldAllowed"})]})})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Code"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:"function Foldable:getIsFoldActionAllowed()\n    return self.spec_foldable.isFoldAllowed\nend\n\n"})}),"\n",(0,t.jsx)(n.h3,{id:"getisfoldallowed",children:"getIsFoldAllowed"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Description"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"Returns if the actual fold action is executed or not & a warning to indicate the reason for the player"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Definition"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"getIsFoldAllowed(integer direction, boolean onAiTurnOn)"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"integer"}),(0,t.jsx)(n.th,{children:"direction"})]})}),(0,t.jsx)(n.tbody,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"boolean"}),(0,t.jsx)(n.td,{children:"onAiTurnOn"})]})})]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Return Values"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"boolean"}),(0,t.jsx)(n.th,{children:"isFoldAllowed"})]})}),(0,t.jsx)(n.tbody,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"boolean"}),(0,t.jsx)(n.td,{children:"warning"})]})})]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Code"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:"function Foldable:getIsFoldAllowed(direction, onAiTurnOn)\n    local spec = self.spec_foldable\n    if not spec.isFoldAllowed then\n        return false , nil\n    end\n\n    if self.getAttacherVehicle ~ = nil and self:getAttacherVehicle() ~ = nil then\n        local inputAttacherJoint = self:getActiveInputAttacherJoint()\n        if inputAttacherJoint.foldMinLimit ~ = nil and inputAttacherJoint.foldMaxLimit ~ = nil then\n            local foldAnimTime = self:getFoldAnimTime()\n            if foldAnimTime < inputAttacherJoint.foldMinLimit or foldAnimTime > inputAttacherJoint.foldMaxLimit then\n                return false , nil\n            end\n        end\n    end\n\n    if (spec.toggleFoldingBlockedDirection = = 0 and spec.foldMoveDirection ~ = 0 ) or(spec.toggleFoldingBlockedDirection ~ = 0 and spec.foldMoveDirection = = - spec.toggleFoldingBlockedDirection) then\n        if spec.foldAnimTime > spec.toggleFoldingMaxLimit or spec.foldAnimTime < spec.toggleFoldingMinLimit then\n            return false , nil\n        end\n    end\n\n    return true , nil\nend\n\n"})}),"\n",(0,t.jsx)(n.h3,{id:"getisfoldmiddleallowed",children:"getIsFoldMiddleAllowed"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Description"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Definition"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"getIsFoldMiddleAllowed()"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Code"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:"function Foldable:getIsFoldMiddleAllowed()\n    local spec = self.spec_foldable\n\n    if not spec.isFoldAllowed then\n        return false\n    end\n\n    return spec.foldMiddleAnimTime ~ = nil\nend\n\n"})}),"\n",(0,t.jsx)(n.h3,{id:"getisgroundadjustednodeactive",children:"getIsGroundAdjustedNodeActive"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Description"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Definition"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"getIsGroundAdjustedNodeActive()"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"any"}),(0,t.jsx)(n.th,{children:"superFunc"})]})}),(0,t.jsxs)(n.tbody,{children:[(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"any"}),(0,t.jsx)(n.td,{children:"adjustedNode"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"any"}),(0,t.jsx)(n.td,{children:"ignoreAttachState"})]})]})]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Code"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:"function Foldable:getIsGroundAdjustedNodeActive(superFunc, adjustedNode, ignoreAttachState)\n    local spec = self.spec_foldable\n\n    local foldAnimTime = spec.foldAnimTime\n    if foldAnimTime ~ = nil and(foldAnimTime > adjustedNode.foldMaxLimit or foldAnimTime < adjustedNode.foldMinLimit) then\n        return false\n    end\n\n    return superFunc( self , adjustedNode, ignoreAttachState)\nend\n\n"})}),"\n",(0,t.jsx)(n.h3,{id:"getisinputattacheractive",children:"getIsInputAttacherActive"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Description"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"Returns true if input attacher is active and can be used to attach"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Definition"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"getIsInputAttacherActive(table inputAttacherJoint, )"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"table"}),(0,t.jsx)(n.th,{children:"inputAttacherJoint"}),(0,t.jsx)(n.th,{children:"input attacher joint"})]})}),(0,t.jsx)(n.tbody,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"any"}),(0,t.jsx)(n.td,{children:"inputAttacherJoint"}),(0,t.jsx)(n.td,{})]})})]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Return Values"})}),"\n\n\n\n\n\n\n\n\n",(0,t.jsx)(n.table,{children:(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"any"}),(0,t.jsx)(n.th,{children:"isActive"}),(0,t.jsx)(n.th,{children:"input attacher is active"})]})})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Code"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:"function Foldable:getIsInputAttacherActive(superFunc, inputAttacherJoint)\n    if inputAttacherJoint.foldMinLimit ~ = nil and inputAttacherJoint.foldMaxLimit ~ = nil then\n        local foldAnimTime = self:getFoldAnimTime()\n        if foldAnimTime < inputAttacherJoint.foldMinLimit or foldAnimTime > inputAttacherJoint.foldMaxLimit then\n            return false\n        end\n    end\n\n    return superFunc( self , inputAttacherJoint)\nend\n\n"})}),"\n",(0,t.jsx)(n.h3,{id:"getisinworkposition",children:"getIsInWorkPosition"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Description"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Definition"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"getIsInWorkPosition()"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,t.jsx)(n.table,{children:(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"any"}),(0,t.jsx)(n.th,{children:"superFunc"})]})})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Code"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:"function Foldable:getIsInWorkPosition(superFunc)\n    local spec = self.spec_foldable\n\n    if spec.turnOnFoldDirection ~ = 0 and not(#spec.foldingParts = = 0 or(spec.turnOnFoldDirection = = - 1 and spec.foldAnimTime = = 0 ) or(spec.turnOnFoldDirection = = 1 and spec.foldAnimTime = = 1 )) then\n        return false\n    end\n\n    return superFunc( self )\nend\n\n"})}),"\n",(0,t.jsx)(n.h3,{id:"getislevelerpickupnodeactive",children:"getIsLevelerPickupNodeActive"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Description"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Definition"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"getIsLevelerPickupNodeActive()"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"any"}),(0,t.jsx)(n.th,{children:"superFunc"})]})}),(0,t.jsx)(n.tbody,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"any"}),(0,t.jsx)(n.td,{children:"levelerNode"})]})})]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Code"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:"function Foldable:getIsLevelerPickupNodeActive(superFunc, levelerNode)\n    local spec = self.spec_foldable\n\n    if not levelerNode.foldLimitedOuterRange then\n        if spec.foldAnimTime > levelerNode.foldMaxLimit or spec.foldAnimTime < levelerNode.foldMinLimit then\n            return false\n        end\n    else\n            if spec.foldAnimTime < = levelerNode.foldMaxLimit and spec.foldAnimTime > levelerNode.foldMinLimit then\n                return false\n            end\n        end\n\n        return superFunc( self , levelerNode)\n    end\n\n"})}),"\n",(0,t.jsx)(n.h3,{id:"getislowered",children:"getIsLowered"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Description"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Definition"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"getIsLowered()"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"any"}),(0,t.jsx)(n.th,{children:"superFunc"})]})}),(0,t.jsx)(n.tbody,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"any"}),(0,t.jsx)(n.td,{children:"default"})]})})]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Code"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:"function Foldable:getIsLowered(superFunc, default)\n    local spec = self.spec_foldable\n\n    if self:getIsFoldMiddleAllowed() then\n        if spec.foldMiddleAnimTime ~ = nil and spec.foldMiddleInputButton ~ = nil then\n            local ignoreFoldMiddle = false\n            if spec.ignoreFoldMiddleWhileFolded then\n                if self:getFoldAnimTime() > spec.foldMiddleAnimTime then\n                    ignoreFoldMiddle = true\n                end\n            end\n\n            if not ignoreFoldMiddle then\n                if spec.foldMoveDirection ~ = 0 then\n                    if spec.foldMiddleDirection > 0 then\n                        if spec.foldAnimTime < spec.foldMiddleAnimTime + 0.01 then\n                            return spec.foldMoveDirection < 0 and spec.moveToMiddle ~ = true\n                        end\n                    else\n                            if spec.foldAnimTime > spec.foldMiddleAnimTime - 0.01 then\n                                return spec.foldMoveDirection > 0 and spec.moveToMiddle ~ = true\n                            end\n                        end\n                    else\n                            if spec.foldMiddleDirection > 0 and spec.foldAnimTime < 0.01 then\n                                return true\n                            elseif spec.foldMiddleDirection < 0 and math.abs( 1.0 - spec.foldAnimTime) < 0.01 then\n                                    return true\n                                end\n                            end\n\n                            return false\n                        else\n                                return superFunc( self , default)\n                            end\n                        end\n                    end\n\n                    return superFunc( self , default)\n                end\n\n"})}),"\n",(0,t.jsx)(n.h3,{id:"getismovingpartactive",children:"getIsMovingPartActive"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Description"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Definition"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"getIsMovingPartActive()"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"any"}),(0,t.jsx)(n.th,{children:"superFunc"})]})}),(0,t.jsx)(n.tbody,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"any"}),(0,t.jsx)(n.td,{children:"movingPart"})]})})]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Code"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:"function Foldable:getIsMovingPartActive(superFunc, movingPart)\n    if movingPart.foldMaxLimit ~ = 1 or movingPart.foldMinLimit ~ = 0 then\n        local foldAnimTime = self:getFoldAnimTime()\n        if foldAnimTime > movingPart.foldMaxLimit or foldAnimTime < movingPart.foldMinLimit then\n            return false\n        end\n    end\n\n    return superFunc( self , movingPart)\nend\n\n"})}),"\n",(0,t.jsx)(n.h3,{id:"getismovingtoolactive",children:"getIsMovingToolActive"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Description"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Definition"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"getIsMovingToolActive()"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"any"}),(0,t.jsx)(n.th,{children:"superFunc"})]})}),(0,t.jsx)(n.tbody,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"any"}),(0,t.jsx)(n.td,{children:"movingTool"})]})})]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Code"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:"function Foldable:getIsMovingToolActive(superFunc, movingTool)\n    if not movingTool.hasRequiredFoldingConfiguration then\n        return false\n    end\n\n    local foldAnimTime = self:getFoldAnimTime()\n    if foldAnimTime > movingTool.foldMaxLimit or foldAnimTime < movingTool.foldMinLimit then\n        return false\n    end\n\n    return superFunc( self , movingTool)\nend\n\n"})}),"\n",(0,t.jsx)(n.h3,{id:"getisnextcoverstateallowed",children:"getIsNextCoverStateAllowed"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Description"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Definition"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"getIsNextCoverStateAllowed()"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"any"}),(0,t.jsx)(n.th,{children:"superFunc"})]})}),(0,t.jsx)(n.tbody,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"any"}),(0,t.jsx)(n.td,{children:"nextState"})]})})]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Code"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:"function Foldable:getIsNextCoverStateAllowed(superFunc, nextState)\n    if not superFunc( self , nextState) then\n        return false\n    end\n\n    local spec = self.spec_foldable\n    if spec.foldAnimTime > spec.toggleCoverMaxLimit or spec.foldAnimTime < spec.toggleCoverMinLimit then\n        return false\n    end\n\n    return true\nend\n\n"})}),"\n",(0,t.jsx)(n.h3,{id:"getisnextcoverstateallowedwarning",children:"getIsNextCoverStateAllowedWarning"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Description"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Definition"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"getIsNextCoverStateAllowedWarning()"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"any"}),(0,t.jsx)(n.th,{children:"superFunc"})]})}),(0,t.jsx)(n.tbody,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"any"}),(0,t.jsx)(n.td,{children:"nextState"})]})})]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Code"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:"function Foldable:getIsNextCoverStateAllowedWarning(superFunc, nextState)\n    local spec = self.spec_foldable\n    if spec.foldAnimTime > spec.toggleCoverMaxLimit or spec.foldAnimTime < spec.toggleCoverMinLimit then\n        return spec.unfoldWarning\n    end\n\n    return superFunc( self , nextState)\nend\n\n"})}),"\n",(0,t.jsx)(n.h3,{id:"getispreprunernodeactive",children:"getIsPreprunerNodeActive"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Description"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Definition"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"getIsPreprunerNodeActive()"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"any"}),(0,t.jsx)(n.th,{children:"superFunc"})]})}),(0,t.jsx)(n.tbody,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"any"}),(0,t.jsx)(n.td,{children:"prunerNode"})]})})]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Code"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:"function Foldable:getIsPreprunerNodeActive(superFunc, prunerNode)\n    local foldAnimTime = self:getFoldAnimTime()\n    if foldAnimTime < prunerNode.foldMinLimit or foldAnimTime > prunerNode.foldMaxLimit then\n        return false\n    end\n\n    return superFunc( self , prunerNode)\nend\n\n"})}),"\n",(0,t.jsx)(n.h3,{id:"getisspeedrotatingpartactive",children:"getIsSpeedRotatingPartActive"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Description"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Definition"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"getIsSpeedRotatingPartActive()"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"any"}),(0,t.jsx)(n.th,{children:"superFunc"})]})}),(0,t.jsx)(n.tbody,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"any"}),(0,t.jsx)(n.td,{children:"speedRotatingPart"})]})})]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Code"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:"function Foldable:getIsSpeedRotatingPartActive(superFunc, speedRotatingPart)\n    local spec = self.spec_foldable\n\n    if not speedRotatingPart.foldLimitedOuterRange then\n        if spec.foldAnimTime > speedRotatingPart.foldMaxLimit or spec.foldAnimTime < speedRotatingPart.foldMinLimit then\n            return false\n        end\n    else\n            if spec.foldAnimTime < = speedRotatingPart.foldMaxLimit and spec.foldAnimTime > speedRotatingPart.foldMinLimit then\n                return false\n            end\n        end\n\n        return superFunc( self , speedRotatingPart)\n    end\n\n"})}),"\n",(0,t.jsx)(n.h3,{id:"getisspraytypeactive",children:"getIsSprayTypeActive"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Description"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Definition"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"getIsSprayTypeActive()"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"any"}),(0,t.jsx)(n.th,{children:"superFunc"})]})}),(0,t.jsx)(n.tbody,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"any"}),(0,t.jsx)(n.td,{children:"sprayType"})]})})]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Code"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:"function Foldable:getIsSprayTypeActive(superFunc, sprayType)\n    local spec = self.spec_foldable\n\n    if sprayType.foldMinLimit ~ = nil and sprayType.foldMaxLimit ~ = nil then\n        local foldAnimTime = spec.foldAnimTime\n        if foldAnimTime ~ = nil and(foldAnimTime > sprayType.foldMaxLimit or foldAnimTime < sprayType.foldMinLimit) then\n            return false\n        end\n    end\n\n    if not sprayType.hasRequiredFoldingConfiguration then\n        return false\n    end\n\n    return superFunc( self , sprayType)\nend\n\n"})}),"\n",(0,t.jsx)(n.h3,{id:"getissteeringaxleallowed",children:"getIsSteeringAxleAllowed"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Description"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Definition"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"getIsSteeringAxleAllowed()"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,t.jsx)(n.table,{children:(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"any"}),(0,t.jsx)(n.th,{children:"superFunc"})]})})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Code"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:"function Foldable:getIsSteeringAxleAllowed(superFunc)\n    local spec = self.spec_attachable\n    local foldAnimTime = self:getFoldAnimTime()\n    if foldAnimTime < spec.foldMinLimit or foldAnimTime > spec.foldMaxLimit then\n        return false\n    end\n\n    return superFunc( self )\nend\n\n"})}),"\n",(0,t.jsx)(n.h3,{id:"getissupportanimationallowed",children:"getIsSupportAnimationAllowed"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Description"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"Returns if support animation is allowed to play"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Definition"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"getIsSupportAnimationAllowed()"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"any"}),(0,t.jsx)(n.th,{children:"superFunc"})]})}),(0,t.jsx)(n.tbody,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"any"}),(0,t.jsx)(n.td,{children:"supportAnimation"})]})})]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Code"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:"function Foldable:getIsSupportAnimationAllowed(superFunc, supportAnimation)\n    local foldAnimTime = self:getFoldAnimTime()\n    if foldAnimTime < supportAnimation.foldMinLimit or foldAnimTime > supportAnimation.foldMaxLimit then\n        return false\n    end\n\n    return superFunc( self , supportAnimation)\nend\n\n"})}),"\n",(0,t.jsx)(n.h3,{id:"getissuspensionnodeactive",children:"getIsSuspensionNodeActive"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Description"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Definition"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"getIsSuspensionNodeActive()"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"any"}),(0,t.jsx)(n.th,{children:"superFunc"})]})}),(0,t.jsx)(n.tbody,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"any"}),(0,t.jsx)(n.td,{children:"suspensionNode"})]})})]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Code"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:"function Foldable:getIsSuspensionNodeActive(superFunc, suspensionNode)\n    local foldAnimTime = self:getFoldAnimTime()\n    if foldAnimTime < suspensionNode.foldMinLimit or foldAnimTime > suspensionNode.foldMaxLimit then\n        return false\n    end\n\n    return superFunc( self , suspensionNode)\nend\n\n"})}),"\n",(0,t.jsx)(n.h3,{id:"getisturnedonanimationactive",children:"getIsTurnedOnAnimationActive"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Description"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Definition"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"getIsTurnedOnAnimationActive()"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"any"}),(0,t.jsx)(n.th,{children:"superFunc"})]})}),(0,t.jsx)(n.tbody,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"any"}),(0,t.jsx)(n.td,{children:"turnedOnAnimation"})]})})]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Code"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:"function Foldable:getIsTurnedOnAnimationActive(superFunc, turnedOnAnimation)\n    local foldAnimTime = self:getFoldAnimTime()\n    if foldAnimTime < turnedOnAnimation.foldMinLimit or foldAnimTime > turnedOnAnimation.foldMaxLimit then\n        return false\n    end\n\n    return superFunc( self , turnedOnAnimation)\nend\n\n"})}),"\n",(0,t.jsx)(n.h3,{id:"getisunfolded",children:"getIsUnfolded"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Description"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Definition"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"getIsUnfolded()"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Code"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:"function Foldable:getIsUnfolded()\n    local spec = self.spec_foldable\n\n    if spec.hasFoldingParts then\n        if spec.foldMiddleAnimTime ~ = nil then\n            if (spec.turnOnFoldDirection = = - 1 and spec.foldAnimTime < spec.foldMiddleAnimTime + 0.01 ) or\n                (spec.turnOnFoldDirection = = 1 and spec.foldAnimTime > spec.foldMiddleAnimTime - 0.01 )\n                then\n                return true\n            else\n                    return false\n                end\n            else\n                    if (spec.turnOnFoldDirection = = - 1 and spec.foldAnimTime = = 0 ) or(spec.turnOnFoldDirection = = 1 and spec.foldAnimTime = = 1 ) then\n                        return true\n                    else\n                            return false\n                        end\n                    end\n                else\n                        return true\n                    end\n                end\n\n"})}),"\n",(0,t.jsx)(n.h3,{id:"getisvehiclecontrolallowed",children:"getIsVehicleControlAllowed"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Description"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Definition"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"getIsVehicleControlAllowed()"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,t.jsx)(n.table,{children:(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"any"}),(0,t.jsx)(n.th,{children:"self"})]})})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Code"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:"function Foldable.getIsVehicleControlAllowed( self )\n    local spec = self.spec_foldable\n    if spec.foldMoveDirection ~ = 0 then\n        return false , nil\n    end\n\n    return true , nil\nend\n\n"})}),"\n",(0,t.jsx)(n.h3,{id:"getisversatileyrotactive",children:"getIsVersatileYRotActive"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Description"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Definition"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"getIsVersatileYRotActive()"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"any"}),(0,t.jsx)(n.th,{children:"superFunc"})]})}),(0,t.jsx)(n.tbody,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"any"}),(0,t.jsx)(n.td,{children:"wheel"})]})})]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Code"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:"function Foldable:getIsVersatileYRotActive(superFunc, wheel)\n    local spec = self.spec_foldable\n\n    if spec.foldAnimTime > wheel.versatileFoldMaxLimit or spec.foldAnimTime < wheel.versatileFoldMinLimit then\n        return false\n    end\n\n    return superFunc( self , wheel)\nend\n\n"})}),"\n",(0,t.jsx)(n.h3,{id:"getiswheelchockallowed",children:"getIsWheelChockAllowed"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Description"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Definition"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"getIsWheelChockAllowed()"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"any"}),(0,t.jsx)(n.th,{children:"superFunc"})]})}),(0,t.jsx)(n.tbody,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"any"}),(0,t.jsx)(n.td,{children:"wheelChock"})]})})]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Code"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:"function Foldable:getIsWheelChockAllowed(superFunc, wheelChock)\n    local foldAnimTime = self:getFoldAnimTime()\n    if foldAnimTime ~ = nil and(foldAnimTime < wheelChock.foldMinLimit or foldAnimTime > wheelChock.foldMaxLimit) then\n        return false\n    end\n\n    return superFunc( self )\nend\n\n"})}),"\n",(0,t.jsx)(n.h3,{id:"getiswoodharvestertiltstateallowed",children:"getIsWoodHarvesterTiltStateAllowed"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Description"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Definition"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"getIsWoodHarvesterTiltStateAllowed()"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"any"}),(0,t.jsx)(n.th,{children:"superFunc"})]})}),(0,t.jsx)(n.tbody,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"any"}),(0,t.jsx)(n.td,{children:"headerTilt"})]})})]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Code"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:"function Foldable:getIsWoodHarvesterTiltStateAllowed(superFunc, headerTilt)\n    local foldAnimTime = self:getFoldAnimTime()\n    if foldAnimTime < headerTilt.foldMinLimit or foldAnimTime > headerTilt.foldMaxLimit then\n        return false\n    end\n\n    return superFunc( self , headerTilt)\nend\n\n"})}),"\n",(0,t.jsx)(n.h3,{id:"getisworkareaactive",children:"getIsWorkAreaActive"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Description"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Definition"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"getIsWorkAreaActive()"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"any"}),(0,t.jsx)(n.th,{children:"superFunc"})]})}),(0,t.jsx)(n.tbody,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"any"}),(0,t.jsx)(n.td,{children:"workArea"})]})})]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Code"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:"function Foldable:getIsWorkAreaActive(superFunc, workArea)\n    local spec = self.spec_foldable\n\n    if not workArea.foldLimitedOuterRange then\n        if spec.foldAnimTime > workArea.foldMaxLimit or spec.foldAnimTime < workArea.foldMinLimit then\n            return false\n        end\n    else\n            if spec.foldAnimTime < = workArea.foldMaxLimit and spec.foldAnimTime > workArea.foldMinLimit then\n                return false\n            end\n        end\n\n        return superFunc( self , workArea)\n    end\n\n"})}),"\n",(0,t.jsx)(n.h3,{id:"getrequirespower",children:"getRequiresPower"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Description"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Definition"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"getRequiresPower()"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,t.jsx)(n.table,{children:(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"any"}),(0,t.jsx)(n.th,{children:"superFunc"})]})})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Code"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:"function Foldable:getRequiresPower(superFunc)\n    return self.spec_foldable.foldMoveDirection ~ = 0 or superFunc( self )\nend\n\n"})}),"\n",(0,t.jsx)(n.h3,{id:"getshovelnodeisactive",children:"getShovelNodeIsActive"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Description"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Definition"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"getShovelNodeIsActive()"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"any"}),(0,t.jsx)(n.th,{children:"superFunc"})]})}),(0,t.jsx)(n.tbody,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"any"}),(0,t.jsx)(n.td,{children:"shovelNode"})]})})]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Code"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:"function Foldable:getShovelNodeIsActive(superFunc, shovelNode)\n    local foldAnimTime = self:getFoldAnimTime()\n    if foldAnimTime < shovelNode.foldMinLimit or foldAnimTime > shovelNode.foldMaxLimit then\n        return false\n    end\n\n    return superFunc( self , shovelNode)\nend\n\n"})}),"\n",(0,t.jsx)(n.h3,{id:"getslopecompensationanglescale",children:"getSlopeCompensationAngleScale"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Description"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Definition"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"getSlopeCompensationAngleScale()"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"any"}),(0,t.jsx)(n.th,{children:"superFunc"})]})}),(0,t.jsx)(n.tbody,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"any"}),(0,t.jsx)(n.td,{children:"compensationNode"})]})})]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Code"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:"function Foldable:getSlopeCompensationAngleScale(superFunc, compensationNode)\n    local scale = superFunc( self , compensationNode)\n\n    if compensationNode.foldAngleScale ~ = nil then\n        local spec = self.spec_foldable\n        local animTime = 1 - spec.foldAnimTime\n        if compensationNode.invertFoldAngleScale then\n            animTime = 1 - animTime\n        end\n\n        if spec.foldMiddleAnimTime ~ = nil then\n            scale = scale * MathUtil.lerp(compensationNode.foldAngleScale, 1 , animTime / ( 1 - spec.foldMiddleAnimTime))\n        else\n                scale = scale * MathUtil.lerp(compensationNode.foldAngleScale, 1 , animTime)\n            end\n        end\n\n        return scale\n    end\n\n"})}),"\n",(0,t.jsx)(n.h3,{id:"gettoggledfolddirection",children:"getToggledFoldDirection"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Description"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Definition"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"getToggledFoldDirection()"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Code"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:"function Foldable:getToggledFoldDirection()\n    local spec = self.spec_foldable\n\n    local foldMidTime = 0.5\n    if spec.foldMiddleAnimTime ~ = nil then\n        if spec.foldMiddleDirection > 0 then\n            foldMidTime = ( 1 + spec.foldMiddleAnimTime) * 0.5\n        else\n                foldMidTime = spec.foldMiddleAnimTime * 0.5\n            end\n        end\n\n        local targetDirection = 0\n\n        if spec.moveToMiddle then\n            targetDirection = spec.foldMiddleDirection\n        elseif spec.foldMoveDirection = = 0 then\n                if spec.foldAnimTime < foldMidTime then\n                    targetDirection = 1\n                else\n                        targetDirection = - 1\n                    end\n                else\n                        targetDirection = - spec.foldMoveDirection\n                    end\n\n                    -- if we are still in lowered range, we always fold the tool\n                        -- otherwise we stay in this inbetween state\n                        if spec.foldMiddleAnimTime ~ = nil then\n                            if spec.foldMiddleDirection > 0 then\n                                if spec.foldAnimTime < spec.foldMiddleAnimTime - 0.01 then\n                                    targetDirection = 1\n                                end\n                            else\n                                    if spec.foldAnimTime > spec.foldMiddleAnimTime + 0.01 then\n                                        targetDirection = - 1\n                                    end\n                                end\n                            end\n\n                            return targetDirection\n                        end\n\n"})}),"\n",(0,t.jsx)(n.h3,{id:"gettoggledfoldmiddledirection",children:"getToggledFoldMiddleDirection"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Description"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Definition"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"getToggledFoldMiddleDirection()"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Code"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:"function Foldable:getToggledFoldMiddleDirection()\n    local spec = self.spec_foldable\n\n    local ret = 0\n    if spec.foldMiddleAnimTime ~ = nil then\n        if spec.foldMoveDirection > 0.1 then\n            ret = - 1\n        else\n                ret = 1\n            end\n            if spec.foldMiddleDirection > 0 then\n                if spec.foldAnimTime > = spec.foldMiddleAnimTime - 0.01 then\n                    ret = - 1\n                end\n            else\n                    if spec.foldAnimTime < = spec.foldMiddleAnimTime + 0.01 then\n                        ret = 1\n                    else\n                            ret = - 1\n                        end\n                    end\n                end\n                return ret\n            end\n\n"})}),"\n",(0,t.jsx)(n.h3,{id:"getturnedonnotallowedwarning",children:"getTurnedOnNotAllowedWarning"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Description"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Definition"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"getTurnedOnNotAllowedWarning()"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,t.jsx)(n.table,{children:(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"any"}),(0,t.jsx)(n.th,{children:"superFunc"})]})})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Code"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:"function Foldable:getTurnedOnNotAllowedWarning(superFunc)\n    local spec = self.spec_foldable\n\n    if spec.foldAnimTime > spec.turnOnFoldMaxLimit or spec.foldAnimTime < spec.turnOnFoldMinLimit then\n        return spec.unfoldWarning\n    end\n\n    return superFunc( self )\nend\n\n"})}),"\n",(0,t.jsx)(n.h3,{id:"initspecialization",children:"initSpecialization"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Description"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Definition"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"initSpecialization()"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Code"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:'function Foldable.initSpecialization()\n    g_vehicleConfigurationManager:addConfigurationType( "folding" , g_i18n:getText( "configuration_folding" ), "foldable" , VehicleConfigurationItem )\n\n    local schema = Vehicle.xmlSchema\n    schema:setXMLSpecializationType( "Foldable" )\n\n    schema:register(XMLValueType.FLOAT, "vehicle.foldable.foldingConfigurations.foldingConfiguration(?)#workingWidth" , "Working width to display in shop" )\n\n    Foldable.registerFoldingXMLPaths(schema, "vehicle.foldable.foldingConfigurations.foldingConfiguration(?).foldingParts" )\n\n    schema:register(XMLValueType.BOOL, WorkArea.WORK_AREA_XML_KEY .. "#foldLimitedOuterRange" , "Fold limit outer range" , false )\n    schema:register(XMLValueType.FLOAT, WorkArea.WORK_AREA_XML_KEY .. ".folding#minLimit" , "Min.fold limit" , 0 )\n    schema:register(XMLValueType.FLOAT, WorkArea.WORK_AREA_XML_KEY .. ".folding#maxLimit" , "Max.fold limit" , 1 )\n\n    schema:register(XMLValueType.BOOL, WorkArea.WORK_AREA_XML_CONFIG_KEY .. "#foldLimitedOuterRange" , "Fold limit outer range" , false )\n    schema:register(XMLValueType.FLOAT, WorkArea.WORK_AREA_XML_CONFIG_KEY .. ".folding#minLimit" , "Min.fold limit" , 0 )\n    schema:register(XMLValueType.FLOAT, WorkArea.WORK_AREA_XML_CONFIG_KEY .. ".folding#maxLimit" , "Max.fold limit" , 1 )\n\n    schema:register(XMLValueType.FLOAT, GroundReference.GROUND_REFERENCE_XML_KEY .. ".folding#minLimit" , "Min.fold limit" , 0 )\n    schema:register(XMLValueType.FLOAT, GroundReference.GROUND_REFERENCE_XML_KEY .. ".folding#maxLimit" , "Max.fold limit" , 1 )\n\n    schema:register(XMLValueType.BOOL, SpeedRotatingParts.SPEED_ROTATING_PART_XML_KEY .. "#foldLimitedOuterRange" , "Fold limit outer range" , false )\n    schema:register(XMLValueType.FLOAT, SpeedRotatingParts.SPEED_ROTATING_PART_XML_KEY .. "#foldMinLimit" , "Min.fold limit" , 0 )\n    schema:register(XMLValueType.FLOAT, SpeedRotatingParts.SPEED_ROTATING_PART_XML_KEY .. "#foldMaxLimit" , "Max.fold limit" , 1 )\n\n    schema:register(XMLValueType.BOOL, Leveler.LEVELER_NODE_XML_KEY .. "#foldLimitedOuterRange" , "Fold limit outer range" , false )\n    schema:register(XMLValueType.FLOAT, Leveler.LEVELER_NODE_XML_KEY .. "#foldMinLimit" , "Min.fold limit" , 0 )\n    schema:register(XMLValueType.FLOAT, Leveler.LEVELER_NODE_XML_KEY .. "#foldMaxLimit" , "Max.fold limit" , 1 )\n\n    schema:addDelayedRegistrationFunc( "SlopeCompensation:compensationNode" , function (cSchema, cKey)\n        cSchema:register(XMLValueType.FLOAT, cKey .. "#foldAngleScale" , "Fold angle scale" )\n        cSchema:register(XMLValueType.BOOL, cKey .. "#invertFoldAngleScale" , "Invert fold angle scale" , false )\n    end )\n\n    schema:addDelayedRegistrationFunc( "Cylindered:movingTool" , function (cSchema, cKey)\n        cSchema:register(XMLValueType.FLOAT, cKey .. "#foldMinLimit" , "Fold min.time" , 0 )\n        cSchema:register(XMLValueType.FLOAT, cKey .. "#foldMaxLimit" , "Fold max.time" , 1 )\n\n        cSchema:register(XMLValueType.INT, cKey .. "#foldingConfigurationIndex" , "Index of folding configuration to activate the moving tool" )\n        cSchema:register(XMLValueType.VECTOR_N, cKey .. "#foldingConfigurationIndices" , "List of folding configuration indices to activate the moving tool" )\n    end )\n\n    schema:addDelayedRegistrationFunc( "Cylindered:movingPart" , function (cSchema, cKey)\n        cSchema:register(XMLValueType.FLOAT, cKey .. "#foldMinLimit" , "Fold min.time" , 0 )\n        cSchema:register(XMLValueType.FLOAT, cKey .. "#foldMaxLimit" , "Fold max.time" , 1 )\n    end )\n\n    schema:addDelayedRegistrationFunc( "Attachable:support" , function (cSchema, cKey)\n        cSchema:register(XMLValueType.FLOAT, cKey .. ".folding#minLimit" , "Min.fold limit" , 0 )\n        cSchema:register(XMLValueType.FLOAT, cKey .. ".folding#maxLimit" , "Max.fold limit" , 1 )\n    end )\n\n    schema:addDelayedRegistrationFunc( "CrabSteering:steeringMode" , function (cSchema, cKey)\n        cSchema:register(XMLValueType.FLOAT, cKey .. ".folding#minLimit" , "Min.fold limit" , 0 )\n        cSchema:register(XMLValueType.FLOAT, cKey .. ".folding#maxLimit" , "Max.fold limit" , 1 )\n    end )\n\n    schema:addDelayedRegistrationFunc( "WheelChock" , function (cSchema, cKey)\n        cSchema:register(XMLValueType.FLOAT, cKey .. "#foldMinLimit" , "Fold min.time" , 0 )\n        cSchema:register(XMLValueType.FLOAT, cKey .. "#foldMaxLimit" , "Fold max.time" , 1 )\n    end )\n\n    schema:addDelayedRegistrationFunc( "GroundAdjustedNodes:node" , function (cSchema, cKey)\n        cSchema:register(XMLValueType.FLOAT, cKey .. ".foldable#minLimit" , "Fold min.time" , 0 )\n        cSchema:register(XMLValueType.FLOAT, cKey .. ".foldable#maxLimit" , "Fold max.time" , 1 )\n    end )\n\n    schema:addDelayedRegistrationFunc( "CraneShovel" , function (cSchema, cKey)\n        cSchema:register(XMLValueType.FLOAT, cKey .. ".foldable#minLimit" , "Fold min.time" , 0 )\n        cSchema:register(XMLValueType.FLOAT, cKey .. ".foldable#maxLimit" , "Fold max.time" , 1 )\n    end )\n\n    schema:register(XMLValueType.FLOAT, Sprayer.SPRAY_TYPE_XML_KEY .. "#foldMinLimit" , "Fold min.time" , 0 )\n    schema:register(XMLValueType.FLOAT, Sprayer.SPRAY_TYPE_XML_KEY .. "#foldMaxLimit" , "Fold max.time" , 1 )\n    schema:register(XMLValueType.INT, Sprayer.SPRAY_TYPE_XML_KEY .. "#foldingConfigurationIndex" , "Index of folding configuration to activate spray type" )\n    schema:register(XMLValueType.VECTOR_N, Sprayer.SPRAY_TYPE_XML_KEY .. "#foldingConfigurationIndices" , "List of folding configuration indices to activate spray type" )\n\n    schema:register(XMLValueType.FLOAT, Attachable.INPUT_ATTACHERJOINT_XML_KEY .. "#foldMinLimit" , "Fold min.time" , 0 )\n    schema:register(XMLValueType.FLOAT, Attachable.INPUT_ATTACHERJOINT_XML_KEY .. "#foldMaxLimit" , "Fold max.time" , 1 )\n\n    schema:register(XMLValueType.FLOAT, Attachable.INPUT_ATTACHERJOINT_CONFIG_XML_KEY .. "#foldMinLimit" , "Fold min.time" , 0 )\n    schema:register(XMLValueType.FLOAT, Attachable.INPUT_ATTACHERJOINT_CONFIG_XML_KEY .. "#foldMaxLimit" , "Fold max.time" , 1 )\n\n    schema:register(XMLValueType.FLOAT, Attachable.INPUT_ATTACHERJOINT_XML_KEY .. ".heightNode(?)#foldMinLimit" , "Fold min.time" , 0 )\n    schema:register(XMLValueType.FLOAT, Attachable.INPUT_ATTACHERJOINT_XML_KEY .. ".heightNode(?)#foldMaxLimit" , "Fold max.time" , 1 )\n\n    schema:register(XMLValueType.FLOAT, Attachable.INPUT_ATTACHERJOINT_CONFIG_XML_KEY .. ".heightNode(?)#foldMinLimit" , "Fold min.time" , 0 )\n    schema:register(XMLValueType.FLOAT, Attachable.INPUT_ATTACHERJOINT_CONFIG_XML_KEY .. ".heightNode(?)#foldMaxLimit" , "Fold max.time" , 1 )\n\n    schema:register(XMLValueType.FLOAT, Enterable.ADDITIONAL_CHARACTER_XML_KEY .. "#foldMinLimit" , "Fold min.time" , 0 )\n    schema:register(XMLValueType.FLOAT, Enterable.ADDITIONAL_CHARACTER_XML_KEY .. "#foldMaxLimit" , "Fold max.time" , 1 )\n\n    schema:register(XMLValueType.FLOAT, Attachable.STEERING_AXLE_XML_KEY .. ".folding#minLimit" , "Min.fold limit" , 0 )\n    schema:register(XMLValueType.FLOAT, Attachable.STEERING_AXLE_XML_KEY .. ".folding#maxLimit" , "Max.fold limit" , 1 )\n\n    schema:register(XMLValueType.FLOAT, Wheels.WHEEL_XML_PATH .. "#versatileFoldMinLimit" , "Fold min.time for versatility" , 0 )\n        schema:register(XMLValueType.FLOAT, Wheels.WHEEL_XML_PATH .. "#versatileFoldMaxLimit" , "Fold max.time for versatility" , 1 )\n\n            schema:register(XMLValueType.FLOAT, FillUnit.FILL_UNIT_XML_KEY .. "#foldMinLimit" , "Fold min.time for filling" , 0 )\n                schema:register(XMLValueType.FLOAT, FillUnit.FILL_UNIT_XML_KEY .. "#foldMaxLimit" , "Fold max.time for filling" , 1 )\n\n                    schema:register(XMLValueType.FLOAT, TurnOnVehicle.TURNED_ON_ANIMATION_XML_PATH .. "#foldMinLimit" , "Fold min.time for running turned on animation" , 0 )\n                        schema:register(XMLValueType.FLOAT, TurnOnVehicle.TURNED_ON_ANIMATION_XML_PATH .. "#foldMaxLimit" , "Fold max.time for running turned on animation" , 1 )\n\n                            schema:register(XMLValueType.FLOAT, Pickup.PICKUP_XML_KEY .. "#foldMinLimit" , "Fold min.time for pickup lowering" , 0 )\n                                schema:register(XMLValueType.FLOAT, Pickup.PICKUP_XML_KEY .. "#foldMaxLimit" , "Fold max.time for pickup lowering" , 1 )\n\n                                    schema:register(XMLValueType.FLOAT, Cutter.CUTTER_TILT_XML_KEY .. "#foldMinLimit" , "Fold min.time for cutter automatic tilt" , 0 )\n                                        schema:register(XMLValueType.FLOAT, Cutter.CUTTER_TILT_XML_KEY .. "#foldMaxLimit" , "Fold max.time for cutter automatic tilt" , 1 )\n\n                                            schema:register(XMLValueType.FLOAT, VinePrepruner.PRUNER_NODE_XML_KEY .. "#foldMinLimit" , "Fold min.time for pruner node update" , 0 )\n                                                schema:register(XMLValueType.FLOAT, VinePrepruner.PRUNER_NODE_XML_KEY .. "#foldMaxLimit" , "Fold max.time for pruner node update" , 1 )\n\n                                                    schema:register(XMLValueType.FLOAT, Shovel.SHOVEL_NODE_XML_KEY .. "#foldMinLimit" , "Fold min.time for shovel pickup" , 0 )\n                                                        schema:register(XMLValueType.FLOAT, Shovel.SHOVEL_NODE_XML_KEY .. "#foldMaxLimit" , "Fold max.time for shovel pickup" , 1 )\n\n                                                            schema:register(XMLValueType.FLOAT, Attachable.STEERING_ANGLE_NODE_XML_KEY .. "#foldMinLimit" , "Fold min.time for steering angle nodes to update" , 0 )\n                                                                schema:register(XMLValueType.FLOAT, Attachable.STEERING_ANGLE_NODE_XML_KEY .. "#foldMaxLimit" , "Fold max.time for steering angle nodes to update" , 1 )\n\n                                                                    schema:register(XMLValueType.FLOAT, WoodHarvester.HEADER_JOINT_TILT_XML_KEY .. "#foldMinLimit" , "Fold min.time for header tilt to be allowed" , 0 )\n                                                                        schema:register(XMLValueType.FLOAT, WoodHarvester.HEADER_JOINT_TILT_XML_KEY .. "#foldMaxLimit" , "Fold max.time for header tilt to be allowed" , 1 )\n\n                                                                            schema:register(XMLValueType.FLOAT, Suspensions.SUSPENSION_NODE_XML_KEY .. "#foldMinLimit" , "Fold min.time for suspension node to be active" , 0 )\n                                                                                schema:register(XMLValueType.FLOAT, Suspensions.SUSPENSION_NODE_XML_KEY .. "#foldMaxLimit" , "Fold max.time for suspension node to be active" , 1 )\n\n                                                                                    schema:setXMLSpecializationType()\n\n                                                                                    local schemaSavegame = Vehicle.xmlSchemaSavegame\n                                                                                    schemaSavegame:register(XMLValueType.FLOAT, "vehicles.vehicle(?).foldable#foldAnimTime" , "Fold animation time" )\n                                                                                    schemaSavegame:register(XMLValueType.BOOL, "vehicles.vehicle(?).foldable#isAllowed" , "If folding is allowed" )\n                                                                                end\n\n'})}),"\n",(0,t.jsx)(n.h3,{id:"isattachallowed",children:"isAttachAllowed"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Description"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"Returns true if attaching the vehicle is allowed"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Definition"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"isAttachAllowed(integer farmId, table attacherVehicle, )"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"integer"}),(0,t.jsx)(n.th,{children:"farmId"}),(0,t.jsx)(n.th,{children:"farmId of attacher vehicle"})]})}),(0,t.jsxs)(n.tbody,{children:[(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"table"}),(0,t.jsx)(n.td,{children:"attacherVehicle"}),(0,t.jsx)(n.td,{children:"attacher vehicle"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"any"}),(0,t.jsx)(n.td,{children:"attacherVehicle"}),(0,t.jsx)(n.td,{})]})]})]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Return Values"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"any"}),(0,t.jsx)(n.th,{children:"detachAllowed"}),(0,t.jsx)(n.th,{children:"detach is allowed"})]})}),(0,t.jsx)(n.tbody,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"any"}),(0,t.jsx)(n.td,{children:"warning"}),(0,t.jsx)(n.td,{children:"[optional] warning text to display"})]})})]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Code"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:"function Foldable:isAttachAllowed(superFunc, farmId, attacherVehicle)\n    local spec = self.spec_foldable\n\n    if spec.foldAnimTime > spec.attachingMaxLimit or spec.foldAnimTime < spec.attachingMinLimit then\n        return false , spec.unfoldWarning\n    end\n\n    return superFunc( self , farmId, attacherVehicle)\nend\n\n"})}),"\n",(0,t.jsx)(n.h3,{id:"isdetachallowed",children:"isDetachAllowed"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Description"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"Returns true if detach is allowed"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Definition"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"isDetachAllowed()"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,t.jsx)(n.table,{children:(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"any"}),(0,t.jsx)(n.th,{children:"superFunc"})]})})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Return Values"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"any"}),(0,t.jsx)(n.th,{children:"detachAllowed"}),(0,t.jsx)(n.th,{children:"detach is allowed"})]})}),(0,t.jsx)(n.tbody,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"any"}),(0,t.jsx)(n.td,{children:"warning"}),(0,t.jsx)(n.td,{children:"[optional] warning text to display"})]})})]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Code"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:"function Foldable:isDetachAllowed(superFunc)\n    local spec = self.spec_foldable\n\n    if spec.foldAnimTime > spec.detachingMaxLimit or spec.foldAnimTime < spec.detachingMinLimit then\n        return false , spec.unfoldWarning\n    end\n\n    if not spec.allowDetachingWhileFolding then\n        if (spec.foldMiddleAnimTime = = nil or math.abs(spec.foldAnimTime - spec.foldMiddleAnimTime) > 0.001 ) and(spec.foldAnimTime > 0 and spec.foldAnimTime < 1 ) then\n            return false , spec.detachWarning\n        end\n    end\n\n    return superFunc( self )\nend\n\n"})}),"\n",(0,t.jsx)(n.h3,{id:"loadadditionalcharacterfromxml",children:"loadAdditionalCharacterFromXML"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Description"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Definition"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"loadAdditionalCharacterFromXML()"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"any"}),(0,t.jsx)(n.th,{children:"superFunc"})]})}),(0,t.jsx)(n.tbody,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"any"}),(0,t.jsx)(n.td,{children:"xmlFile"})]})})]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Code"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:'function Foldable:loadAdditionalCharacterFromXML(superFunc, xmlFile)\n    local spec = self.spec_enterable\n\n    spec.additionalCharacterFoldMinLimit = xmlFile:getValue( "vehicle.enterable.additionalCharacter#foldMinLimit" )\n    spec.additionalCharacterFoldMaxLimit = xmlFile:getValue( "vehicle.enterable.additionalCharacter#foldMaxLimit" )\n\n    return superFunc( self , xmlFile)\nend\n\n'})}),"\n",(0,t.jsx)(n.h3,{id:"loadattacherjointheightnode",children:"loadAttacherJointHeightNode"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Description"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Definition"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"loadAttacherJointHeightNode()"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"any"}),(0,t.jsx)(n.th,{children:"superFunc"})]})}),(0,t.jsxs)(n.tbody,{children:[(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"any"}),(0,t.jsx)(n.td,{children:"xmlFile"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"any"}),(0,t.jsx)(n.td,{children:"key"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"any"}),(0,t.jsx)(n.td,{children:"heightNode"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"any"}),(0,t.jsx)(n.td,{children:"attacherJointNode"})]})]})]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Code"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:'function Foldable:loadAttacherJointHeightNode(superFunc, xmlFile, key, heightNode, attacherJointNode)\n    heightNode.foldMinLimit = xmlFile:getValue(key .. "#foldMinLimit" , 0 )\n    heightNode.foldMaxLimit = xmlFile:getValue(key .. "#foldMaxLimit" , 1 )\n\n    return superFunc( self , xmlFile, key, heightNode, attacherJointNode)\nend\n\n'})}),"\n",(0,t.jsx)(n.h3,{id:"loadcrabsteeringmodefromxml",children:"loadCrabSteeringModeFromXML"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Description"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Definition"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"loadCrabSteeringModeFromXML()"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"any"}),(0,t.jsx)(n.th,{children:"superFunc"})]})}),(0,t.jsxs)(n.tbody,{children:[(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"any"}),(0,t.jsx)(n.td,{children:"xmlFile"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"any"}),(0,t.jsx)(n.td,{children:"key"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"any"}),(0,t.jsx)(n.td,{children:"mode"})]})]})]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Code"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:'function Foldable:loadCrabSteeringModeFromXML(superFunc, xmlFile, key, mode)\n    if not superFunc( self , xmlFile, key, mode) then\n        return false\n    end\n\n    mode.foldMinLimit = xmlFile:getValue(key .. ".folding#minLimit" , 0 )\n    mode.foldMaxLimit = xmlFile:getValue(key .. ".folding#maxLimit" , 1 )\n\n    return true\nend\n\n'})}),"\n",(0,t.jsx)(n.h3,{id:"loadcraneshovelfromxml",children:"loadCraneShovelFromXML"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Description"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Definition"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"loadCraneShovelFromXML()"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"any"}),(0,t.jsx)(n.th,{children:"superFunc"})]})}),(0,t.jsxs)(n.tbody,{children:[(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"any"}),(0,t.jsx)(n.td,{children:"spec"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"any"}),(0,t.jsx)(n.td,{children:"xmlFile"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"any"}),(0,t.jsx)(n.td,{children:"key"})]})]})]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Code"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:'function Foldable:loadCraneShovelFromXML(superFunc, spec, xmlFile, key)\n    if not superFunc( self , spec, xmlFile, key) then\n        return false\n    end\n\n    spec.foldableMinLimit = xmlFile:getValue(key .. ".foldable#minLimit" , 0 )\n    spec.foldableMaxLimit = xmlFile:getValue(key .. ".foldable#maxLimit" , 1 )\n\n    return true\nend\n\n'})}),"\n",(0,t.jsx)(n.h3,{id:"loadcuttertiltfromxml",children:"loadCutterTiltFromXML"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Description"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"Loads header tilt from xml file"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Definition"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"loadCutterTiltFromXML(table xmlFile, string key, , )"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"table"}),(0,t.jsx)(n.th,{children:"xmlFile"}),(0,t.jsx)(n.th,{children:"xml file object"})]})}),(0,t.jsxs)(n.tbody,{children:[(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"string"}),(0,t.jsx)(n.td,{children:"key"}),(0,t.jsx)(n.td,{children:"key to load from"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"any"}),(0,t.jsx)(n.td,{children:"key"}),(0,t.jsx)(n.td,{})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"any"}),(0,t.jsx)(n.td,{children:"target"}),(0,t.jsx)(n.td,{})]})]})]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Return Values"})}),"\n\n\n\n\n\n\n\n\n",(0,t.jsx)(n.table,{children:(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"any"}),(0,t.jsx)(n.th,{children:"success"}),(0,t.jsx)(n.th,{children:"successfully loaded"})]})})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Code"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:'function Foldable:loadCutterTiltFromXML(superFunc, xmlFile, key, target)\n    if not superFunc( self , xmlFile, key, target) then\n        return false\n    end\n\n    target.foldMinLimit = xmlFile:getValue(key .. "#foldMinLimit" , 0 )\n    target.foldMaxLimit = xmlFile:getValue(key .. "#foldMaxLimit" , 1 )\n\n    return true\nend\n\n'})}),"\n",(0,t.jsx)(n.h3,{id:"loadfillunitfromxml",children:"loadFillUnitFromXML"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Description"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Definition"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"loadFillUnitFromXML()"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"any"}),(0,t.jsx)(n.th,{children:"superFunc"})]})}),(0,t.jsxs)(n.tbody,{children:[(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"any"}),(0,t.jsx)(n.td,{children:"xmlFile"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"any"}),(0,t.jsx)(n.td,{children:"key"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"any"}),(0,t.jsx)(n.td,{children:"entry"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"any"}),(0,t.jsx)(n.td,{children:"index"})]})]})]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Code"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:'function Foldable:loadFillUnitFromXML(superFunc, xmlFile, key, entry, index)\n    entry.foldMinLimit = xmlFile:getValue(key .. "#foldMinLimit" , 0 )\n    entry.foldMaxLimit = xmlFile:getValue(key .. "#foldMaxLimit" , 1 )\n\n    return superFunc( self , xmlFile, key, entry, index)\nend\n\n'})}),"\n",(0,t.jsx)(n.h3,{id:"loadfoldingpartfromxml",children:"loadFoldingPartFromXML"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Description"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"Load folding part from xml"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Definition"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"loadFoldingPartFromXML(table xmlFile, string baseKey, table foldingPart)"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"table"}),(0,t.jsx)(n.th,{children:"xmlFile"}),(0,t.jsx)(n.th,{children:"xml file object"})]})}),(0,t.jsxs)(n.tbody,{children:[(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"string"}),(0,t.jsx)(n.td,{children:"baseKey"}),(0,t.jsx)(n.td,{children:"xml key"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"table"}),(0,t.jsx)(n.td,{children:"foldingPart"}),(0,t.jsx)(n.td,{children:"folding part data"})]})]})]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Return Values"})}),"\n\n\n\n\n\n\n\n\n",(0,t.jsx)(n.table,{children:(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"table"}),(0,t.jsx)(n.th,{children:"success"}),(0,t.jsx)(n.th,{children:"successfully loaded folding part"})]})})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Code"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:'function Foldable:loadFoldingPartFromXML(xmlFile, baseKey, foldingPart)\n    local isValid = false\n\n    foldingPart.speedScale = xmlFile:getValue(baseKey .. "#speedScale" , 1 )\n    if foldingPart.speedScale < = 0 then\n        Logging.xmlWarning(xmlFile, "Negative speed scale for folding part \'%s\' not allowed!" , baseKey)\n            return false\n        end\n\n        local componentJointIndex = xmlFile:getValue(baseKey .. "#componentJointIndex" )\n        local componentJoint = nil\n        if componentJointIndex ~ = nil then\n            if componentJointIndex = = 0 then\n                Logging.xmlWarning(xmlFile, "Invalid componentJointIndex for folding part \'%s\'.Indexing starts with 1!" , baseKey)\n                    return false\n                else\n                        componentJoint = self.componentJoints[componentJointIndex]\n                        foldingPart.componentJoint = componentJoint\n                    end\n                end\n                foldingPart.anchorActor = xmlFile:getValue( baseKey .. "#anchorActor" , 0 )\n\n                foldingPart.animCharSet = 0\n\n                local rootNode = xmlFile:getValue(baseKey .. "#rootNode" , nil , self.components, self.i3dMappings)\n                if rootNode ~ = nil then\n                    local animCharSet = getAnimCharacterSet(rootNode)\n                    if animCharSet ~ = 0 then\n                        local clip = getAnimClipIndex(animCharSet, xmlFile:getValue(baseKey .. "#animationClip" ))\n                        if clip > = 0 then\n                            isValid = true\n\n                            foldingPart.animCharSet = animCharSet\n                            assignAnimTrackClip(foldingPart.animCharSet, 0 , clip)\n                            setAnimTrackLoopState(foldingPart.animCharSet, 0 , false )\n                            foldingPart.animDuration = getAnimClipDuration(foldingPart.animCharSet, clip)\n                        end\n                    end\n                end\n\n                if not isValid then\n                    if SpecializationUtil.hasSpecialization( AnimatedVehicle , self.specializations) then\n                        local animationName = xmlFile:getValue(baseKey .. "#animationName" )\n                        if animationName ~ = nil then\n                            if self:getAnimationExists(animationName) then\n                                foldingPart.animDuration = self:getAnimationDuration(animationName)\n                                if foldingPart.animDuration > 0 then\n                                    isValid = true\n                                    foldingPart.animationName = animationName\n\n                                    local animation = self:getAnimationByName(animationName)\n                                    animation.resetOnStart = true\n                                else\n                                        Logging.xmlWarning(xmlFile, "Empty animation in folding part \'%s\'" , baseKey)\n                                    end\n                                end\n                            end\n                        else\n                                if xmlFile:getValue(baseKey .. "#animationName" ) ~ = nil then\n                                    Logging.xmlWarning(xmlFile, "Found animationName in folding part \'%s\', but vehicle has no animations!" , baseKey)\n                                    return false\n                                end\n                            end\n                        end\n\n                        if not isValid then\n                            Logging.xmlWarning(xmlFile, "Invalid folding part \'%s\'.Either a animationClip or animationName needs to be defined!" , baseKey)\n                            return false\n                        end\n\n                        local distance = xmlFile:getValue(baseKey .. "#delayDistance" )\n                        if distance ~ = nil then\n                            foldingPart.delayedLowering = { }\n\n                            foldingPart.delayedLowering.distance = distance\n                            foldingPart.delayedLowering.previousDuration = xmlFile:getValue(baseKey .. "#previousDuration" , 1 ) * 1000\n                            foldingPart.delayedLowering.loweringDuration = xmlFile:getValue(baseKey .. "#loweringDuration" , 1 ) * 1000\n                            foldingPart.delayedLowering.maxDelayDuration = xmlFile:getValue(baseKey .. "#maxDelayDuration" , 7.5 ) * 1000\n                            foldingPart.delayedLowering.aiSkipDelay = xmlFile:getValue(baseKey .. "#aiSkipDelay" , false )\n                            foldingPart.delayedLowering.skipDelayOnReverse = xmlFile:getValue(baseKey .. "#skipDelayOnReverse" , true )\n                            foldingPart.delayedLowering.currentDistance = - 1\n                            foldingPart.delayedLowering.startTime = math.huge\n                            foldingPart.delayedLowering.speedScale = 0\n                            foldingPart.delayedLowering.animTime = 0\n                            foldingPart.delayedLowering.stopAnimTime = 0\n                            foldingPart.delayedLowering.prevDistance = nil\n                        end\n\n                        if componentJoint ~ = nil then\n                            local node = self.components[componentJoint.componentIndices[((foldingPart.anchorActor + 1 ) % 2 ) + 1 ] ].node\n                            foldingPart.x, foldingPart.y, foldingPart.z = worldToLocal(componentJoint.jointNode, getWorldTranslation(node))\n                            foldingPart.upX, foldingPart.upY, foldingPart.upZ = worldDirectionToLocal(componentJoint.jointNode, localDirectionToWorld(node, 0 , 1 , 0 ))\n                            foldingPart.dirX, foldingPart.dirY, foldingPart.dirZ = worldDirectionToLocal(componentJoint.jointNode, localDirectionToWorld(node, 0 , 0 , 1 ))\n                        end\n\n                        return true\n                    end\n\n'})}),"\n",(0,t.jsx)(n.h3,{id:"loadgroundadjustednodefromxml",children:"loadGroundAdjustedNodeFromXML"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Description"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Definition"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"loadGroundAdjustedNodeFromXML()"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"any"}),(0,t.jsx)(n.th,{children:"superFunc"})]})}),(0,t.jsxs)(n.tbody,{children:[(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"any"}),(0,t.jsx)(n.td,{children:"xmlFile"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"any"}),(0,t.jsx)(n.td,{children:"key"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"any"}),(0,t.jsx)(n.td,{children:"adjustedNode"})]})]})]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Code"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:'function Foldable:loadGroundAdjustedNodeFromXML(superFunc, xmlFile, key, adjustedNode)\n    if not superFunc( self , xmlFile, key, adjustedNode) then\n        return false\n    end\n\n    XMLUtil.checkDeprecatedXMLElements(xmlFile, key .. "#foldMinLimit" , key .. ".foldable#minLimit" ) --FS17 to FS19\n    XMLUtil.checkDeprecatedXMLElements(xmlFile, key .. "#foldMaxLimit" , key .. ".foldable#maxLimit" ) --FS17 to FS19\n\n    adjustedNode.foldMinLimit = xmlFile:getValue(key .. ".foldable#minLimit" , 0 )\n    adjustedNode.foldMaxLimit = xmlFile:getValue(key .. ".foldable#maxLimit" , 1 )\n\n    return true\nend\n\n'})}),"\n",(0,t.jsx)(n.h3,{id:"loadgroundreferencenode",children:"loadGroundReferenceNode"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Description"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Definition"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"loadGroundReferenceNode()"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"any"}),(0,t.jsx)(n.th,{children:"superFunc"})]})}),(0,t.jsxs)(n.tbody,{children:[(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"any"}),(0,t.jsx)(n.td,{children:"xmlFile"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"any"}),(0,t.jsx)(n.td,{children:"key"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"any"}),(0,t.jsx)(n.td,{children:"groundReferenceNode"})]})]})]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Code"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:'function Foldable:loadGroundReferenceNode(superFunc, xmlFile, key, groundReferenceNode)\n    local returnValue = superFunc( self , xmlFile, key, groundReferenceNode)\n\n    if returnValue then\n        groundReferenceNode.foldMinLimit = xmlFile:getValue(key .. ".folding#minLimit" , 0 )\n        groundReferenceNode.foldMaxLimit = xmlFile:getValue(key .. ".folding#maxLimit" , 1 )\n    end\n\n    return returnValue\nend\n\n'})}),"\n",(0,t.jsx)(n.h3,{id:"loadinputattacherjoint",children:"loadInputAttacherJoint"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Description"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Definition"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"loadInputAttacherJoint()"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"any"}),(0,t.jsx)(n.th,{children:"superFunc"})]})}),(0,t.jsxs)(n.tbody,{children:[(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"any"}),(0,t.jsx)(n.td,{children:"xmlFile"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"any"}),(0,t.jsx)(n.td,{children:"key"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"any"}),(0,t.jsx)(n.td,{children:"inputAttacherJoint"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"any"}),(0,t.jsx)(n.td,{children:"index"})]})]})]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Code"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:'function Foldable:loadInputAttacherJoint(superFunc, xmlFile, key, inputAttacherJoint, index)\n    inputAttacherJoint.foldMinLimit = xmlFile:getValue(key .. "#foldMinLimit" )\n    inputAttacherJoint.foldMaxLimit = xmlFile:getValue(key .. "#foldMaxLimit" )\n\n    return superFunc( self , xmlFile, key, inputAttacherJoint, index)\nend\n\n'})}),"\n",(0,t.jsx)(n.h3,{id:"loadlevelernodefromxml",children:"loadLevelerNodeFromXML"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Description"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Definition"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"loadLevelerNodeFromXML()"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"any"}),(0,t.jsx)(n.th,{children:"superFunc"})]})}),(0,t.jsxs)(n.tbody,{children:[(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"any"}),(0,t.jsx)(n.td,{children:"levelerNode"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"any"}),(0,t.jsx)(n.td,{children:"xmlFile"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"any"}),(0,t.jsx)(n.td,{children:"key"})]})]})]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Code"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:'function Foldable:loadLevelerNodeFromXML(superFunc, levelerNode, xmlFile, key)\n    levelerNode.foldLimitedOuterRange = xmlFile:getValue(key .. "#foldLimitedOuterRange" , false )\n    local minFoldLimit = 0\n    local maxFoldLimit = 1\n    if levelerNode.foldLimitedOuterRange then\n        minFoldLimit = 0.5\n        maxFoldLimit = 0.5\n    end\n    levelerNode.foldMinLimit = xmlFile:getValue(key .. "#foldMinLimit" , minFoldLimit)\n    levelerNode.foldMaxLimit = xmlFile:getValue(key .. "#foldMaxLimit" , maxFoldLimit)\n\n    return superFunc( self , levelerNode, xmlFile, key)\nend\n\n'})}),"\n",(0,t.jsx)(n.h3,{id:"loadmovingpartfromxml",children:"loadMovingPartFromXML"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Description"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Definition"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"loadMovingPartFromXML()"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"any"}),(0,t.jsx)(n.th,{children:"superFunc"})]})}),(0,t.jsxs)(n.tbody,{children:[(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"any"}),(0,t.jsx)(n.td,{children:"xmlFile"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"any"}),(0,t.jsx)(n.td,{children:"key"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"any"}),(0,t.jsx)(n.td,{children:"entry"})]})]})]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Code"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:'function Foldable:loadMovingPartFromXML(superFunc, xmlFile, key, entry)\n    if not superFunc( self , xmlFile, key, entry) then\n        return false\n    end\n\n    entry.foldMinLimit = xmlFile:getValue(key .. "#foldMinLimit" , 0 )\n    entry.foldMaxLimit = xmlFile:getValue(key .. "#foldMaxLimit" , 1 )\n\n    return true\nend\n\n'})}),"\n",(0,t.jsx)(n.h3,{id:"loadmovingtoolfromxml",children:"loadMovingToolFromXML"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Description"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Definition"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"loadMovingToolFromXML()"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"any"}),(0,t.jsx)(n.th,{children:"superFunc"})]})}),(0,t.jsxs)(n.tbody,{children:[(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"any"}),(0,t.jsx)(n.td,{children:"xmlFile"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"any"}),(0,t.jsx)(n.td,{children:"key"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"any"}),(0,t.jsx)(n.td,{children:"entry"})]})]})]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Code"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:'function Foldable:loadMovingToolFromXML(superFunc, xmlFile, key, entry)\n    if not superFunc( self , xmlFile, key, entry) then\n        return false\n    end\n\n    entry.foldMinLimit = xmlFile:getValue(key .. "#foldMinLimit" , 0 )\n    entry.foldMaxLimit = xmlFile:getValue(key .. "#foldMaxLimit" , 1 )\n\n    entry.hasRequiredFoldingConfiguration = true\n    if self.configurations[ "folding" ] ~ = nil then\n        local foldingConfigurationIndex = xmlFile:getValue(key .. "#foldingConfigurationIndex" )\n        if foldingConfigurationIndex ~ = nil then\n            if self.configurations[ "folding" ] ~ = foldingConfigurationIndex then\n                entry.hasRequiredFoldingConfiguration = false\n            end\n        end\n        local foldingConfigurationIndices = xmlFile:getValue(key .. "#foldingConfigurationIndices" , nil , true )\n        if foldingConfigurationIndices ~ = nil and #foldingConfigurationIndices > 0 then\n            entry.hasRequiredFoldingConfiguration = false\n            for i = 1 , #foldingConfigurationIndices do\n                if self.configurations[ "folding" ] = = foldingConfigurationIndices[i] then\n                    entry.hasRequiredFoldingConfiguration = true\n                    break\n                end\n            end\n        end\n    end\n\n    return true\nend\n\n'})}),"\n",(0,t.jsx)(n.h3,{id:"loadpickupfromxml",children:"loadPickupFromXML"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Description"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Definition"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"loadPickupFromXML()"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"any"}),(0,t.jsx)(n.th,{children:"superFunc"})]})}),(0,t.jsxs)(n.tbody,{children:[(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"any"}),(0,t.jsx)(n.td,{children:"xmlFile"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"any"}),(0,t.jsx)(n.td,{children:"key"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"any"}),(0,t.jsx)(n.td,{children:"spec"})]})]})]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Code"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:'function Foldable:loadPickupFromXML(superFunc, xmlFile, key, spec)\n    spec.foldMinLimit = xmlFile:getValue(key .. "#foldMinLimit" , 0 )\n    spec.foldMaxLimit = xmlFile:getValue(key .. "#foldMaxLimit" , 1 )\n\n    return superFunc( self , xmlFile, key, spec)\nend\n\n'})}),"\n",(0,t.jsx)(n.h3,{id:"loadpreprunernodefromxml",children:"loadPreprunerNodeFromXML"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Description"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Definition"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"loadPreprunerNodeFromXML()"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"any"}),(0,t.jsx)(n.th,{children:"superFunc"})]})}),(0,t.jsxs)(n.tbody,{children:[(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"any"}),(0,t.jsx)(n.td,{children:"xmlFile"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"any"}),(0,t.jsx)(n.td,{children:"key"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"any"}),(0,t.jsx)(n.td,{children:"prunerNode"})]})]})]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Code"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:'function Foldable:loadPreprunerNodeFromXML(superFunc, xmlFile, key, prunerNode)\n    if not superFunc( self , xmlFile, key, prunerNode) then\n        return false\n    end\n\n    prunerNode.foldMinLimit = xmlFile:getValue(key .. "#foldMinLimit" , 0 )\n    prunerNode.foldMaxLimit = xmlFile:getValue(key .. "#foldMaxLimit" , 1 )\n\n    return true\nend\n\n'})}),"\n",(0,t.jsx)(n.h3,{id:"loadshovelnode",children:"loadShovelNode"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Description"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Definition"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"loadShovelNode()"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"any"}),(0,t.jsx)(n.th,{children:"superFunc"})]})}),(0,t.jsxs)(n.tbody,{children:[(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"any"}),(0,t.jsx)(n.td,{children:"xmlFile"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"any"}),(0,t.jsx)(n.td,{children:"key"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"any"}),(0,t.jsx)(n.td,{children:"shovelNode"})]})]})]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Code"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:'function Foldable:loadShovelNode(superFunc, xmlFile, key, shovelNode)\n    superFunc( self , xmlFile, key, shovelNode)\n\n    shovelNode.foldMinLimit = xmlFile:getValue(key .. "#foldMinLimit" , 0 )\n    shovelNode.foldMaxLimit = xmlFile:getValue(key .. "#foldMaxLimit" , 1 )\n\n    return true\nend\n\n'})}),"\n",(0,t.jsx)(n.h3,{id:"loadslopecompensationnodefromxml",children:"loadSlopeCompensationNodeFromXML"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Description"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Definition"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"loadSlopeCompensationNodeFromXML()"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"any"}),(0,t.jsx)(n.th,{children:"superFunc"})]})}),(0,t.jsxs)(n.tbody,{children:[(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"any"}),(0,t.jsx)(n.td,{children:"compensationNode"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"any"}),(0,t.jsx)(n.td,{children:"xmlFile"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"any"}),(0,t.jsx)(n.td,{children:"key"})]})]})]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Code"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:'function Foldable:loadSlopeCompensationNodeFromXML(superFunc, compensationNode, xmlFile, key)\n    compensationNode.foldAngleScale = xmlFile:getValue(key .. "#foldAngleScale" )\n    compensationNode.invertFoldAngleScale = xmlFile:getValue(key .. "#invertFoldAngleScale" , false )\n\n    return superFunc( self , compensationNode, xmlFile, key)\nend\n\n'})}),"\n",(0,t.jsx)(n.h3,{id:"loadspeedrotatingpartfromxml",children:"loadSpeedRotatingPartFromXML"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Description"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Definition"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"loadSpeedRotatingPartFromXML()"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"any"}),(0,t.jsx)(n.th,{children:"superFunc"})]})}),(0,t.jsxs)(n.tbody,{children:[(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"any"}),(0,t.jsx)(n.td,{children:"speedRotatingPart"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"any"}),(0,t.jsx)(n.td,{children:"xmlFile"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"any"}),(0,t.jsx)(n.td,{children:"key"})]})]})]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Code"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:'function Foldable:loadSpeedRotatingPartFromXML(superFunc, speedRotatingPart, xmlFile, key)\n    if not superFunc( self , speedRotatingPart, xmlFile, key) then\n        return false\n    end\n\n    speedRotatingPart.foldLimitedOuterRange = xmlFile:getValue(key .. "#foldLimitedOuterRange" , false )\n    local minFoldLimit = 0\n    local maxFoldLimit = 1\n    if speedRotatingPart.foldLimitedOuterRange then\n        minFoldLimit = 0.5\n        maxFoldLimit = 0.5\n    end\n    speedRotatingPart.foldMinLimit = xmlFile:getValue(key .. "#foldMinLimit" , minFoldLimit)\n    speedRotatingPart.foldMaxLimit = xmlFile:getValue(key .. "#foldMaxLimit" , maxFoldLimit)\n\n    return true\nend\n\n'})}),"\n",(0,t.jsx)(n.h3,{id:"loadspraytypefromxml",children:"loadSprayTypeFromXML"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Description"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Definition"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"loadSprayTypeFromXML()"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"any"}),(0,t.jsx)(n.th,{children:"superFunc"})]})}),(0,t.jsxs)(n.tbody,{children:[(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"any"}),(0,t.jsx)(n.td,{children:"xmlFile"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"any"}),(0,t.jsx)(n.td,{children:"key"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"any"}),(0,t.jsx)(n.td,{children:"sprayType"})]})]})]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Code"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:'function Foldable:loadSprayTypeFromXML(superFunc, xmlFile, key, sprayType)\n    sprayType.foldMinLimit = xmlFile:getValue(key .. "#foldMinLimit" )\n    sprayType.foldMaxLimit = xmlFile:getValue(key .. "#foldMaxLimit" )\n\n    sprayType.hasRequiredFoldingConfiguration = true\n    if self.configurations[ "folding" ] ~ = nil then\n        local foldingConfigurationIndex = xmlFile:getValue(key .. "#foldingConfigurationIndex" )\n        if foldingConfigurationIndex ~ = nil then\n            if self.configurations[ "folding" ] ~ = foldingConfigurationIndex then\n                sprayType.hasRequiredFoldingConfiguration = false\n            end\n        end\n        local foldingConfigurationIndices = xmlFile:getValue(key .. "#foldingConfigurationIndices" , nil , true )\n        if foldingConfigurationIndices ~ = nil and #foldingConfigurationIndices > 0 then\n            sprayType.hasRequiredFoldingConfiguration = false\n            for i = 1 , #foldingConfigurationIndices do\n                if self.configurations[ "folding" ] = = foldingConfigurationIndices[i] then\n                    sprayType.hasRequiredFoldingConfiguration = true\n                    break\n                end\n            end\n        end\n    end\n\n    return superFunc( self , xmlFile, key, sprayType)\nend\n\n'})}),"\n",(0,t.jsx)(n.h3,{id:"loadsteeringanglenodefromxml",children:"loadSteeringAngleNodeFromXML"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Description"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Definition"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"loadSteeringAngleNodeFromXML()"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"any"}),(0,t.jsx)(n.th,{children:"superFunc"})]})}),(0,t.jsxs)(n.tbody,{children:[(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"any"}),(0,t.jsx)(n.td,{children:"entry"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"any"}),(0,t.jsx)(n.td,{children:"xmlFile"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"any"}),(0,t.jsx)(n.td,{children:"key"})]})]})]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Code"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:'function Foldable:loadSteeringAngleNodeFromXML(superFunc, entry, xmlFile, key)\n    if not superFunc( self , entry, xmlFile, key) then\n        return false\n    end\n\n    entry.foldMinLimit = xmlFile:getValue(key .. "#foldMinLimit" , 0 )\n    entry.foldMaxLimit = xmlFile:getValue(key .. "#foldMaxLimit" , 1 )\n\n    return true\nend\n\n'})}),"\n",(0,t.jsx)(n.h3,{id:"loadsteeringaxlefromxml",children:"loadSteeringAxleFromXML"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Description"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Definition"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"loadSteeringAxleFromXML()"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"any"}),(0,t.jsx)(n.th,{children:"superFunc"})]})}),(0,t.jsxs)(n.tbody,{children:[(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"any"}),(0,t.jsx)(n.td,{children:"spec"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"any"}),(0,t.jsx)(n.td,{children:"xmlFile"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"any"}),(0,t.jsx)(n.td,{children:"key"})]})]})]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Code"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:'function Foldable:loadSteeringAxleFromXML(superFunc, spec, xmlFile, key)\n    XMLUtil.checkDeprecatedXMLElements( self.xmlFile, key .. "#foldMinLimit" , key .. ".folding#minLimit" ) --FS19 to FS22\n    XMLUtil.checkDeprecatedXMLElements( self.xmlFile, key .. "#foldMaxLimit" , key .. ".folding#maxLimit" ) --FS19 to FS22\n\n    spec.foldMinLimit = xmlFile:getValue(key .. ".folding#minLimit" , 0 )\n    spec.foldMaxLimit = xmlFile:getValue(key .. ".folding#maxLimit" , 1 )\n\n    return superFunc( self , spec, xmlFile, key)\nend\n\n'})}),"\n",(0,t.jsx)(n.h3,{id:"loadsupportanimationfromxml",children:"loadSupportAnimationFromXML"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Description"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"Loads support animation from xml"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Definition"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"loadSupportAnimationFromXML(table spec, integer xmlFile, string key, )"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"table"}),(0,t.jsx)(n.th,{children:"spec"}),(0,t.jsx)(n.th,{children:"spec"})]})}),(0,t.jsxs)(n.tbody,{children:[(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"integer"}),(0,t.jsx)(n.td,{children:"xmlFile"}),(0,t.jsx)(n.td,{children:"xmlFile id"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"string"}),(0,t.jsx)(n.td,{children:"key"}),(0,t.jsx)(n.td,{children:"key to load from"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"any"}),(0,t.jsx)(n.td,{children:"key"}),(0,t.jsx)(n.td,{})]})]})]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Code"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:'function Foldable:loadSupportAnimationFromXML(superFunc, supportAnimation, xmlFile, key)\n    XMLUtil.checkDeprecatedXMLElements( self.xmlFile, key .. "#foldMinLimit" , key .. ".folding#minLimit" ) --FS19 to FS22\n    XMLUtil.checkDeprecatedXMLElements( self.xmlFile, key .. "#foldMaxLimit" , key .. ".folding#maxLimit" ) --FS19 to FS22\n\n    supportAnimation.foldMinLimit = xmlFile:getValue(key .. ".folding#minLimit" , 0 )\n    supportAnimation.foldMaxLimit = xmlFile:getValue(key .. ".folding#maxLimit" , 1 )\n\n    return superFunc( self , supportAnimation, xmlFile, key)\nend\n\n'})}),"\n",(0,t.jsx)(n.h3,{id:"loadsuspensionnodefromxml",children:"loadSuspensionNodeFromXML"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Description"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Definition"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"loadSuspensionNodeFromXML()"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"any"}),(0,t.jsx)(n.th,{children:"superFunc"})]})}),(0,t.jsxs)(n.tbody,{children:[(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"any"}),(0,t.jsx)(n.td,{children:"xmlFile"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"any"}),(0,t.jsx)(n.td,{children:"key"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"any"}),(0,t.jsx)(n.td,{children:"suspensionNode"})]})]})]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Code"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:'function Foldable:loadSuspensionNodeFromXML(superFunc, xmlFile, key, suspensionNode)\n    if not superFunc( self , xmlFile, key, suspensionNode) then\n        return false\n    end\n\n    suspensionNode.foldMinLimit = xmlFile:getValue(key .. "#foldMinLimit" , 0 )\n    suspensionNode.foldMaxLimit = xmlFile:getValue(key .. "#foldMaxLimit" , 1 )\n\n    return true\nend\n\n'})}),"\n",(0,t.jsx)(n.h3,{id:"loadturnedonanimationfromxml",children:"loadTurnedOnAnimationFromXML"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Description"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Definition"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"loadTurnedOnAnimationFromXML()"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"any"}),(0,t.jsx)(n.th,{children:"superFunc"})]})}),(0,t.jsxs)(n.tbody,{children:[(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"any"}),(0,t.jsx)(n.td,{children:"xmlFile"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"any"}),(0,t.jsx)(n.td,{children:"key"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"any"}),(0,t.jsx)(n.td,{children:"turnedOnAnimation"})]})]})]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Code"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:'function Foldable:loadTurnedOnAnimationFromXML(superFunc, xmlFile, key, turnedOnAnimation)\n    turnedOnAnimation.foldMinLimit = xmlFile:getValue(key .. "#foldMinLimit" , 0 )\n    turnedOnAnimation.foldMaxLimit = xmlFile:getValue(key .. "#foldMaxLimit" , 1 )\n\n    return superFunc( self , xmlFile, key, turnedOnAnimation)\nend\n\n'})}),"\n",(0,t.jsx)(n.h3,{id:"loadwheelfromxml",children:"loadWheelFromXML"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Description"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Definition"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"loadWheelFromXML()"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"any"}),(0,t.jsx)(n.th,{children:"superFunc"})]})}),(0,t.jsx)(n.tbody,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"any"}),(0,t.jsx)(n.td,{children:"wheel"})]})})]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Code"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:'function Foldable:loadWheelFromXML(superFunc, wheel)\n    wheel.versatileFoldMinLimit = wheel.xmlObject:getValue( "#versatileFoldMinLimit" , 0 )\n    wheel.versatileFoldMaxLimit = wheel.xmlObject:getValue( "#versatileFoldMaxLimit" , 1 )\n\n    return superFunc( self , wheel)\nend\n\n'})}),"\n",(0,t.jsx)(n.h3,{id:"loadwoodharvesterheadertiltfromxml",children:"loadWoodHarvesterHeaderTiltFromXML"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Description"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Definition"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"loadWoodHarvesterHeaderTiltFromXML()"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"any"}),(0,t.jsx)(n.th,{children:"superFunc"})]})}),(0,t.jsxs)(n.tbody,{children:[(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"any"}),(0,t.jsx)(n.td,{children:"headerTilt"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"any"}),(0,t.jsx)(n.td,{children:"xmlFile"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"any"}),(0,t.jsx)(n.td,{children:"key"})]})]})]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Code"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:'function Foldable:loadWoodHarvesterHeaderTiltFromXML(superFunc, headerTilt, xmlFile, key)\n    if not superFunc( self , headerTilt, xmlFile, key) then\n        return false\n    end\n\n    headerTilt.foldMinLimit = xmlFile:getValue(key .. "#foldMinLimit" , 0 )\n    headerTilt.foldMaxLimit = xmlFile:getValue(key .. "#foldMaxLimit" , 1 )\n\n    return true\nend\n\n'})}),"\n",(0,t.jsx)(n.h3,{id:"loadworkareafromxml",children:"loadWorkAreaFromXML"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Description"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Definition"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"loadWorkAreaFromXML()"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"any"}),(0,t.jsx)(n.th,{children:"superFunc"})]})}),(0,t.jsxs)(n.tbody,{children:[(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"any"}),(0,t.jsx)(n.td,{children:"workArea"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"any"}),(0,t.jsx)(n.td,{children:"xmlFile"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"any"}),(0,t.jsx)(n.td,{children:"key"})]})]})]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Code"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:'function Foldable:loadWorkAreaFromXML(superFunc, workArea, xmlFile, key)\n    workArea.foldLimitedOuterRange = xmlFile:getValue(key .. "#foldLimitedOuterRange" , false )\n    local minFoldLimit = 0\n    local maxFoldLimit = 1\n    if workArea.foldLimitedOuterRange then\n        minFoldLimit = 0.5\n        maxFoldLimit = 0.5\n    end\n\n    XMLUtil.checkDeprecatedXMLElements(xmlFile, key .. "#foldMinLimit" , key .. ".folding#minLimit" ) --FS17 to FS19\n    XMLUtil.checkDeprecatedXMLElements(xmlFile, key .. "#foldMaxLimit" , key .. ".folding#maxLimit" ) --FS17 to FS19\n\n    workArea.foldMinLimit = xmlFile:getValue(key .. ".folding#minLimit" , minFoldLimit)\n    workArea.foldMaxLimit = xmlFile:getValue(key .. ".folding#maxLimit" , maxFoldLimit)\n\n    return superFunc( self , workArea, xmlFile, key)\nend\n\n'})}),"\n",(0,t.jsx)(n.h3,{id:"ondeactivate",children:"onDeactivate"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Description"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Definition"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"onDeactivate()"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Code"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:"function Foldable:onDeactivate()\n    -- keep on folding while on mobile version since tools are folded when detached\n        local spec = self.spec_foldable\n        if not spec.keepFoldingWhileDetached and not spec.lowerWhileDetach and not spec.foldWhileDetach then\n            self:setFoldDirection( 0 , true )\n        end\n    end\n\n"})}),"\n",(0,t.jsx)(n.h3,{id:"ondynamicmounttypechanged",children:"onDynamicMountTypeChanged"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Description"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Definition"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"onDynamicMountTypeChanged()"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"any"}),(0,t.jsx)(n.th,{children:"dynamicMountType"})]})}),(0,t.jsx)(n.tbody,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"any"}),(0,t.jsx)(n.td,{children:"mountObject"})]})})]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Code"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:"function Foldable:onDynamicMountTypeChanged(dynamicMountType, mountObject)\n    if dynamicMountType ~ = MountableObject.MOUNT_TYPE_NONE then\n        self:setFoldDirection( 0 , true )\n    end\nend\n\n"})}),"\n",(0,t.jsx)(n.h3,{id:"onload",children:"onLoad"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Description"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Definition"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"onLoad()"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,t.jsx)(n.table,{children:(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"any"}),(0,t.jsx)(n.th,{children:"savegame"})]})})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Code"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:'function Foldable:onLoad(savegame)\n    local spec = self.spec_foldable\n\n    XMLUtil.checkDeprecatedXMLElements( self.xmlFile, "vehicle.foldingParts" , "vehicle.foldable.foldingConfigurations.foldingConfiguration.foldingParts" ) --FS17 to FS19\n    XMLUtil.checkDeprecatedXMLElements( self.xmlFile, "vehicle.foldable.foldingParts" , "vehicle.foldable.foldingConfigurations.foldingConfiguration.foldingParts" ) --FS19 to FS21\n\n    local foldingConfigurationId = Utils.getNoNil( self.configurations[ "folding" ], 1 )\n    local configKey = string.format( "vehicle.foldable.foldingConfigurations.foldingConfiguration(%d).foldingParts" , foldingConfigurationId - 1 )\n\n    spec.isFoldAllowed = true\n    spec.objectText = self.xmlFile:getValue(configKey .. "#objectText" , self.typeDesc, self.customEnvironment, false )\n    spec.posDirectionText = string.format( self.xmlFile:getValue(configKey .. "#posDirectionText" , "action_foldOBJECT" , self.customEnvironment, false ), spec.objectText)\n    spec.negDirectionText = string.format( self.xmlFile:getValue(configKey .. "#negDirectionText" , "action_unfoldOBJECT" , self.customEnvironment, false ), spec.objectText)\n    spec.middlePosDirectionText = string.format( self.xmlFile:getValue(configKey .. "#middlePosDirectionText" , "action_liftOBJECT" , self.customEnvironment, false ), spec.objectText)\n    spec.middleNegDirectionText = string.format( self.xmlFile:getValue(configKey .. "#middleNegDirectionText" , "action_lowerOBJECT" , self.customEnvironment, false ), spec.objectText)\n\n    spec.startAnimTime = self.xmlFile:getValue(configKey .. "#startAnimTime" )\n    spec.foldMoveDirection = 0\n    spec.moveToMiddle = false\n    if spec.startAnimTime = = nil then\n        spec.startAnimTime = 0\n        local startMoveDirection = self.xmlFile:getValue(configKey .. "#startMoveDirection" , 0 )\n        if startMoveDirection > 0.1 then\n            spec.startAnimTime = 1\n        end\n    end\n    spec.turnOnFoldDirection = 1\n    if spec.startAnimTime > 0.5 then\n        spec.turnOnFoldDirection = - 1\n    end\n\n    spec.turnOnFoldDirection = math.sign( self.xmlFile:getValue(configKey .. "#turnOnFoldDirection" , spec.turnOnFoldDirection))\n    if spec.turnOnFoldDirection = = 0 then\n        Logging.xmlWarning( self.xmlFile, "Foldable \'turnOnFoldDirection\' not allowed to be 0! Only -1 and 1 are allowed" )\n        spec.turnOnFoldDirection = - 1\n    end\n\n    spec.allowUnfoldingByAI = self.xmlFile:getValue(configKey .. "#allowUnfoldingByAI" , true )\n\n    local foldInputButtonStr = self.xmlFile:getValue(configKey .. "#foldInputButton" )\n    if foldInputButtonStr ~ = nil then\n        spec.foldInputButton = InputAction[foldInputButtonStr]\n    end\n    spec.foldInputButton = Utils.getNoNil(spec.foldInputButton, InputAction.IMPLEMENT_EXTRA2)\n\n    local foldMiddleInputButtonStr = self.xmlFile:getValue(configKey .. "#foldMiddleInputButton" )\n    if foldMiddleInputButtonStr ~ = nil then\n        spec.foldMiddleInputButton = InputAction[foldMiddleInputButtonStr]\n    end\n    spec.foldMiddleInputButton = Utils.getNoNil(spec.foldMiddleInputButton, InputAction.LOWER_IMPLEMENT)\n\n    spec.foldMiddleAnimTime = self.xmlFile:getValue(configKey .. "#foldMiddleAnimTime" )\n    spec.foldMiddleDirection = self.xmlFile:getValue(configKey .. "#foldMiddleDirection" , 1 )\n    spec.foldMiddleAIRaiseDirection = self.xmlFile:getValue(configKey .. "#foldMiddleAIRaiseDirection" , spec.foldMiddleDirection)\n\n    spec.turnOnFoldMaxLimit = self.xmlFile:getValue(configKey .. "#turnOnFoldMaxLimit" , 1 )\n    spec.turnOnFoldMinLimit = self.xmlFile:getValue(configKey .. "#turnOnFoldMinLimit" , 0 )\n    spec.toggleCoverMaxLimit = self.xmlFile:getValue(configKey .. "#toggleCoverMaxLimit" , 1 )\n    spec.toggleCoverMinLimit = self.xmlFile:getValue(configKey .. "#toggleCoverMinLimit" , 0 )\n    spec.detachingMaxLimit = self.xmlFile:getValue(configKey .. "#detachingMaxLimit" , 1 )\n    spec.detachingMinLimit = self.xmlFile:getValue(configKey .. "#detachingMinLimit" , 0 )\n    spec.attachingMaxLimit = self.xmlFile:getValue(configKey .. "#attachingMaxLimit" , 1 )\n    spec.attachingMinLimit = self.xmlFile:getValue(configKey .. "#attachingMinLimit" , 0 )\n    spec.allowDetachingWhileFolding = self.xmlFile:getValue(configKey .. "#allowDetachingWhileFolding" , false )\n    spec.loweringMaxLimit = self.xmlFile:getValue(configKey .. "#loweringMaxLimit" , 1 )\n    spec.loweringMinLimit = self.xmlFile:getValue(configKey .. "#loweringMinLimit" , 0 )\n    spec.loadMovingToolStatesMaxLimit = self.xmlFile:getValue(configKey .. "#loadMovingToolStatesMaxLimit" , 1 )\n    spec.loadMovingToolStatesMinLimit = self.xmlFile:getValue(configKey .. "#loadMovingToolStatesMinLimit" , 0 )\n    spec.dynamicMountMinLimit = self.xmlFile:getValue(configKey .. "#dynamicMountMinLimit" , 0 )\n    spec.dynamicMountMaxLimit = self.xmlFile:getValue(configKey .. "#dynamicMountMaxLimit" , 1 )\n    spec.crabSteeringMinLimit = self.xmlFile:getValue(configKey .. "#crabSteeringMinLimit" , 0 )\n    spec.crabSteeringMaxLimit = self.xmlFile:getValue(configKey .. "#crabSteeringMaxLimit" , 1 )\n    spec.toggleFoldingMinLimit = self.xmlFile:getValue(configKey .. ".toggleFolding#minLimit" , 0 )\n    spec.toggleFoldingMaxLimit = self.xmlFile:getValue(configKey .. ".toggleFolding#maxLimit" , 1 )\n    spec.toggleFoldingBlockedDirection = self.xmlFile:getValue(configKey .. ".toggleFolding#blockedDirection" , 0 )\n    spec.unfoldWarning = string.format( self.xmlFile:getValue(configKey .. "#unfoldWarning" , "warning_firstUnfoldTheTool" , self.customEnvironment, false ), spec.objectText)\n    spec.detachWarning = string.format( self.xmlFile:getValue(configKey .. "#detachWarning" , "warning_doNotDetachWhileFolding" , self.customEnvironment, false ), spec.objectText)\n\n    spec.useParentFoldingState = self.xmlFile:getValue(configKey .. "#useParentFoldingState" , false )\n    spec.subFoldingStateVehicles = { }\n\n    spec.ignoreFoldMiddleWhileFolded = self.xmlFile:getValue(configKey .. "#ignoreFoldMiddleWhileFolded" , false )\n    spec.lowerWhileDetach = self.xmlFile:getValue(configKey .. "#lowerWhileDetach" , false )\n    spec.foldWhileDetach = self.xmlFile:getValue(configKey .. "#foldWhileDetach" , false )\n    spec.keepFoldingWhileDetached = self.xmlFile:getValue(configKey .. "#keepFoldingWhileDetached" , Platform.gameplay.keepFoldingWhileDetached)\n    spec.releaseBrakesWhileFolding = self.xmlFile:getValue(configKey .. "#releaseBrakesWhileFolding" , false )\n    spec.requiresPower = self.xmlFile:getValue(configKey .. "#requiresPower" , true )\n    spec.allowControlWhileFolding = self.xmlFile:getValue(configKey .. "#allowControlWhileFolding" , true )\n\n    spec.foldAnimTime = 0\n    spec.maxFoldAnimDuration = 0.0001\n\n    spec.foldingParts = { }\n    local i = 0\n    while true do\n        local baseKey = string.format(configKey .. ".foldingPart(%d)" , i)\n        if not self.xmlFile:hasProperty(baseKey) then\n            break\n        end\n\n        local foldingPart = { }\n        if self:loadFoldingPartFromXML( self.xmlFile, baseKey, foldingPart) then\n            table.insert(spec.foldingParts, foldingPart)\n            spec.maxFoldAnimDuration = math.max(spec.maxFoldAnimDuration, foldingPart.animDuration)\n        end\n\n        i = i + 1\n    end\n\n    spec.hasFoldingParts = #spec.foldingParts > 0\n\n    spec.actionEventsLowering = { }\n\n    if spec.hasFoldingParts then\n        if savegame ~ = nil and not savegame.resetVehicles then\n            spec.loadedFoldAnimTime = savegame.xmlFile:getValue(savegame.key .. ".foldable#foldAnimTime" )\n            spec.isFoldAllowed = savegame.xmlFile:getValue(savegame.key .. ".foldable#isAllowed" , spec.isFoldAllowed)\n        end\n    end\n\n    if spec.loadedFoldAnimTime = = nil then\n        spec.loadedFoldAnimTime = spec.startAnimTime\n    end\n\n    if self.vehicleLoadingData:getCustomParameter( "foldableInvertFoldState" ) then\n        spec.loadedFoldAnimTime = 1 - spec.loadedFoldAnimTime\n    else\n            local foldAnimTime = self.vehicleLoadingData:getCustomParameter( "foldableFoldingTime" )\n            if foldAnimTime ~ = nil then\n                spec.loadedFoldAnimTime = foldAnimTime\n            end\n        end\n    end\n\n'})}),"\n",(0,t.jsx)(n.h3,{id:"onloadwheelchockfromxml",children:"onLoadWheelChockFromXML"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Description"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Definition"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"onLoadWheelChockFromXML()"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"any"}),(0,t.jsx)(n.th,{children:"superFunc"})]})}),(0,t.jsxs)(n.tbody,{children:[(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"any"}),(0,t.jsx)(n.td,{children:"wheelChock"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"any"}),(0,t.jsx)(n.td,{children:"xmlObject"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"any"}),(0,t.jsx)(n.td,{children:"key"})]})]})]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Code"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:'function Foldable:onLoadWheelChockFromXML(superFunc, wheelChock, xmlObject, key)\n    superFunc( self )\n\n    wheelChock.foldMinLimit = xmlObject:getValue(key .. "#foldMinLimit" , 0 )\n    wheelChock.foldMaxLimit = xmlObject:getValue(key .. "#foldMaxLimit" , 1 )\nend\n\n'})}),"\n",(0,t.jsx)(n.h3,{id:"onpostattach",children:"onPostAttach"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Description"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Definition"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"onPostAttach()"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"any"}),(0,t.jsx)(n.th,{children:"attacherVehicle"})]})}),(0,t.jsxs)(n.tbody,{children:[(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"any"}),(0,t.jsx)(n.td,{children:"inputJointDescIndex"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"any"}),(0,t.jsx)(n.td,{children:"jointDescIndex"})]})]})]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Code"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:"function Foldable:onPostAttach(attacherVehicle, inputJointDescIndex, jointDescIndex)\n    local spec = self.spec_foldable\n    if spec.lowerWhileDetach then\n        if attacherVehicle ~ = nil then\n            local jointDesc = attacherVehicle:getAttacherJointByJointDescIndex(jointDescIndex)\n            if not jointDesc.moveDown then\n                if self:getFoldAnimTime() < 0.001 then\n                    self:setFoldState( 1 , true , true )\n                end\n            end\n        end\n    end\nend\n\n"})}),"\n",(0,t.jsx)(n.h3,{id:"onpostload",children:"onPostLoad"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Description"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Definition"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"onPostLoad()"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,t.jsx)(n.table,{children:(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"any"}),(0,t.jsx)(n.th,{children:"savegame"})]})})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Code"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:'function Foldable:onPostLoad(savegame)\n    local spec = self.spec_foldable\n    Foldable.setAnimTime( self , spec.loadedFoldAnimTime, false )\n\n    if #spec.foldingParts = = 0 or spec.useParentFoldingState then\n        SpecializationUtil.removeEventListener( self , "onReadStream" , Foldable )\n        SpecializationUtil.removeEventListener( self , "onWriteStream" , Foldable )\n        SpecializationUtil.removeEventListener( self , "onUpdate" , Foldable )\n        SpecializationUtil.removeEventListener( self , "onUpdateTick" , Foldable )\n        SpecializationUtil.removeEventListener( self , "onRegisterActionEvents" , Foldable )\n        SpecializationUtil.removeEventListener( self , "onRegisterExternalActionEvents" , Foldable )\n        SpecializationUtil.removeEventListener( self , "onDeactivate" , Foldable )\n        SpecializationUtil.removeEventListener( self , "onSetLoweredAll" , Foldable )\n        SpecializationUtil.removeEventListener( self , "onPostAttach" , Foldable )\n        SpecializationUtil.removeEventListener( self , "onPreDetach" , Foldable )\n        SpecializationUtil.removeEventListener( self , "onDynamicMountTypeChanged" , Foldable )\n    end\nend\n\n'})}),"\n",(0,t.jsx)(n.h3,{id:"onpreattachimplement",children:"onPreAttachImplement"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Description"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"Called if vehicle gets detached"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Definition"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"onPreAttachImplement(table attacherVehicle, table implement, , )"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"table"}),(0,t.jsx)(n.th,{children:"attacherVehicle"}),(0,t.jsx)(n.th,{children:"attacher vehicle"})]})}),(0,t.jsxs)(n.tbody,{children:[(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"table"}),(0,t.jsx)(n.td,{children:"implement"}),(0,t.jsx)(n.td,{children:"implement"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"any"}),(0,t.jsx)(n.td,{children:"jointDescIndex"}),(0,t.jsx)(n.td,{})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"any"}),(0,t.jsx)(n.td,{children:"loadFromSavegame"}),(0,t.jsx)(n.td,{})]})]})]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Code"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:"function Foldable:onPreAttachImplement(object, inputJointDescIndex, jointDescIndex, loadFromSavegame)\n    local subSpec = object.spec_foldable\n    if subSpec ~ = nil then\n        if subSpec.useParentFoldingState then\n            self.spec_foldable.subFoldingStateVehicles[object] = object\n            Foldable.setAnimTime(object, self.spec_foldable.foldAnimTime, false )\n        end\n    end\nend\n\n"})}),"\n",(0,t.jsx)(n.h3,{id:"onpredetach",children:"onPreDetach"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Description"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"Called if vehicle gets detached"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Definition"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"onPreDetach(table attacherVehicle, table implement)"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"table"}),(0,t.jsx)(n.th,{children:"attacherVehicle"}),(0,t.jsx)(n.th,{children:"attacher vehicle"})]})}),(0,t.jsx)(n.tbody,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"table"}),(0,t.jsx)(n.td,{children:"implement"}),(0,t.jsx)(n.td,{children:"implement"})]})})]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Code"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:"function Foldable:onPreDetach(attacherVehicle, implement)\n    local spec = self.spec_foldable\n    if spec.lowerWhileDetach and spec.foldMiddleAnimTime ~ = nil then\n        local foldAnimTime = self:getFoldAnimTime()\n        if math.abs(foldAnimTime - spec.foldMiddleAnimTime) < 0.001 then\n            self:setFoldState( - 1 , false , true )\n        end\n    elseif spec.foldWhileDetach then\n            self:setFoldState( - spec.turnOnFoldDirection, false , true )\n        end\n    end\n\n"})}),"\n",(0,t.jsx)(n.h3,{id:"onpredetachimplement",children:"onPreDetachImplement"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Description"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"Called if vehicle gets detached"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Definition"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"onPreDetachImplement(table attacherVehicle, table implement)"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"table"}),(0,t.jsx)(n.th,{children:"attacherVehicle"}),(0,t.jsx)(n.th,{children:"attacher vehicle"})]})}),(0,t.jsx)(n.tbody,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"table"}),(0,t.jsx)(n.td,{children:"implement"}),(0,t.jsx)(n.td,{children:"implement"})]})})]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Code"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:"function Foldable:onPreDetachImplement(implement)\n    local subSpec = implement.object.spec_foldable\n    if subSpec ~ = nil then\n        if subSpec.useParentFoldingState then\n            self.spec_foldable.subFoldingStateVehicles[implement.object] = nil\n        end\n    end\nend\n\n"})}),"\n",(0,t.jsx)(n.h3,{id:"onreadstream",children:"onReadStream"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Description"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Definition"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"onReadStream()"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"any"}),(0,t.jsx)(n.th,{children:"streamId"})]})}),(0,t.jsx)(n.tbody,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"any"}),(0,t.jsx)(n.td,{children:"connection"})]})})]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Code"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:"function Foldable:onReadStream(streamId, connection)\n    local direction = streamReadUIntN(streamId, 2 ) - 1\n    local moveToMiddle = streamReadBool(streamId)\n    local animTime = streamReadFloat32(streamId)\n    Foldable.setAnimTime( self , animTime, false )\n    self:setFoldState(direction, moveToMiddle, true )\nend\n\n"})}),"\n",(0,t.jsx)(n.h3,{id:"onregisteractionevents",children:"onRegisterActionEvents"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Description"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Definition"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"onRegisterActionEvents()"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"any"}),(0,t.jsx)(n.th,{children:"isActiveForInput"})]})}),(0,t.jsx)(n.tbody,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"any"}),(0,t.jsx)(n.td,{children:"isActiveForInputIgnoreSelection"})]})})]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Code"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:"function Foldable:onRegisterActionEvents(isActiveForInput, isActiveForInputIgnoreSelection)\n    if self.isClient then\n        local spec = self.spec_foldable\n        self:clearActionEventsTable(spec.actionEvents)\n\n        if isActiveForInputIgnoreSelection then\n            local isOnlyLowering = spec.foldMiddleAnimTime ~ = nil and spec.foldMiddleAnimTime = = 1\n            if not isOnlyLowering then\n                local _, actionEventId\n                if spec.requiresPower then\n                    _, actionEventId = self:addPoweredActionEvent(spec.actionEvents, spec.foldInputButton, self , Foldable.actionEventFold, false , true , false , true , nil )\n                else\n                        _, actionEventId = self:addActionEvent(spec.actionEvents, spec.foldInputButton, self , Foldable.actionEventFold, false , true , false , true , nil )\n                    end\n\n                    g_inputBinding:setActionEventTextPriority(actionEventId, GS_PRIO_HIGH)\n                    Foldable.updateActionEventFold( self )\n\n                    _, actionEventId = self:addPoweredActionEvent(spec.actionEvents, InputAction.FOLD_ALL_IMPLEMENTS, self , Foldable.actionEventFoldAll, false , true , false , true , nil )\n                    g_inputBinding:setActionEventTextVisibility(actionEventId, false )\n                end\n            end\n        end\n    end\n\n"})}),"\n",(0,t.jsx)(n.h3,{id:"onregistered",children:"onRegistered"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Description"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Definition"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"onRegistered()"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Code"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:"function Foldable:onRegistered()\n    local spec = self.spec_foldable\n    if not spec.allowControlWhileFolding then\n        if self.registerPlayerVehicleControlAllowedFunction ~ = nil then\n            self:registerPlayerVehicleControlAllowedFunction( self , Foldable.getIsVehicleControlAllowed)\n        end\n    end\nend\n\n"})}),"\n",(0,t.jsx)(n.h3,{id:"onregisterexternalactionevents",children:"onRegisterExternalActionEvents"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Description"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"Called on load to register external action events"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Definition"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"onRegisterExternalActionEvents()"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"any"}),(0,t.jsx)(n.th,{children:"trigger"})]})}),(0,t.jsxs)(n.tbody,{children:[(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"any"}),(0,t.jsx)(n.td,{children:"name"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"any"}),(0,t.jsx)(n.td,{children:"xmlFile"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"any"}),(0,t.jsx)(n.td,{children:"key"})]})]})]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Code"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:'function Foldable:onRegisterExternalActionEvents(trigger, name, xmlFile, key)\n    if name = = "folding" then\n        local spec = self.spec_foldable\n        if spec.hasFoldingParts then\n            self:registerExternalActionEvent(trigger, name, Foldable.externalActionEventRegister, Foldable.externalActionEventUpdate)\n        end\n    end\nend\n\n'})}),"\n",(0,t.jsx)(n.h3,{id:"onrootvehiclechanged",children:"onRootVehicleChanged"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Description"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"Called if root vehicle changes"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Definition"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"onRootVehicleChanged(table rootVehicle)"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n",(0,t.jsx)(n.table,{children:(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"table"}),(0,t.jsx)(n.th,{children:"rootVehicle"}),(0,t.jsx)(n.th,{children:"root vehicle"})]})})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Code"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:'function Foldable:onRootVehicleChanged(rootVehicle)\n    local spec = self.spec_foldable\n    if spec.hasFoldingParts then\n        local actionController = rootVehicle.actionController\n        if actionController ~ = nil then\n            if spec.controlledActionFold ~ = nil then\n                spec.controlledActionFold:updateParent(actionController)\n\n                if spec.controlledActionLower ~ = nil then\n                    spec.controlledActionLower:updateParent(actionController)\n                end\n\n                if spec.controlledActionLowerAIStart ~ = nil then\n                    spec.controlledActionLowerAIStart:updateParent(actionController)\n                end\n\n                return\n            end\n\n            spec.controlledActionFold = actionController:registerAction( "fold" , spec.toggleTurnOnInputBinding, 4 )\n            spec.controlledActionFold:setCallback( self , Foldable.actionControllerFoldEvent)\n            spec.controlledActionFold:setFinishedFunctions( self , function (vehicle)\n                if spec.turnOnFoldDirection < 0 then\n                    local foldTime = vehicle:getFoldAnimTime()\n                    return foldTime = = 1 or foldTime < = (spec.foldMiddleAnimTime or 0 )\n                else\n                        local foldTime = vehicle:getFoldAnimTime()\n                        return foldTime = = 0 or foldTime > = (spec.foldMiddleAnimTime or 1 )\n                    end\n                end , true , true )\n                if spec.allowUnfoldingByAI then\n                    spec.controlledActionFold:addAIEventListener( self , "onAIFieldWorkerPrepareForWork" , 1 )\n                    spec.controlledActionFold:addAIEventListener( self , "onAIImplementPrepareForWork" , 1 )\n\n                    spec.controlledActionFold:addAIEventListener( self , "onAIImplementPrepareForTransport" , - 1 , true )\n\n                    if Platform.gameplay.foldAfterAIFinished then\n                        spec.controlledActionFold:addAIEventListener( self , "onAIImplementEnd" , - 1 , true )\n                        spec.controlledActionFold:addAIEventListener( self , "onAIFieldWorkerEnd" , - 1 )\n                    end\n                end\n\n                if self:getIsFoldMiddleAllowed() then\n                    spec.controlledActionLower = actionController:registerAction( "lowerFoldable" , spec.toggleTurnOnInputBinding, 3 )\n                    spec.controlledActionLower:setCallback( self , Foldable.actionControllerLowerEvent)\n                    spec.controlledActionLower:setFinishedFunctions( self , self.getFoldAnimTime, spec.turnOnFoldDirection < 0 and 0 or 1 , spec.foldMiddleAnimTime)\n                    spec.controlledActionLower:setResetOnDeactivation( false )\n                    if spec.allowUnfoldingByAI then\n                        spec.controlledActionLower:addAIEventListener( self , "onAIImplementStartLine" , 1 )\n                        spec.controlledActionLower:addAIEventListener( self , "onAIImplementEndLine" , - 1 )\n                    end\n\n                    spec.controlledActionLowerAIStart = actionController:registerAction( "lowerFoldableAIStart" , spec.toggleTurnOnInputBinding, 3 )\n                    spec.controlledActionLowerAIStart:setCallback( self , Foldable.actionControllerLowerEventAIStart)\n                    spec.controlledActionLowerAIStart:setFinishedFunctions( self , self.getFoldAnimTime, spec.turnOnFoldDirection < 0 and 0 or 1 , spec.foldMiddleAnimTime)\n                    spec.controlledActionLowerAIStart:setResetOnDeactivation( false )\n                    if spec.allowUnfoldingByAI then\n                        spec.controlledActionLowerAIStart:addAIEventListener( self , "onAIImplementStart" , - 1 )\n                    end\n                end\n            else\n                    if spec.controlledActionFold ~ = nil then\n                        spec.controlledActionFold:remove()\n                    end\n                    if spec.controlledActionLower ~ = nil then\n                        spec.controlledActionLower:remove()\n                    end\n                    if spec.controlledActionLowerAIStart ~ = nil then\n                        spec.controlledActionLowerAIStart:remove()\n                    end\n                end\n            end\n        end\n\n'})}),"\n",(0,t.jsx)(n.h3,{id:"onsetloweredall",children:"onSetLoweredAll"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Description"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Definition"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"onSetLoweredAll()"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"any"}),(0,t.jsx)(n.th,{children:"doLowering"})]})}),(0,t.jsx)(n.tbody,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"any"}),(0,t.jsx)(n.td,{children:"jointDescIndex"})]})})]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Code"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:"function Foldable:onSetLoweredAll(doLowering, jointDescIndex)\n    self:setFoldMiddleState(doLowering)\nend\n\n"})}),"\n",(0,t.jsx)(n.h3,{id:"onupdate",children:"onUpdate"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Description"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Definition"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"onUpdate()"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"any"}),(0,t.jsx)(n.th,{children:"dt"})]})}),(0,t.jsxs)(n.tbody,{children:[(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"any"}),(0,t.jsx)(n.td,{children:"isActiveForInput"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"any"}),(0,t.jsx)(n.td,{children:"isActiveForInputIgnoreSelection"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"any"}),(0,t.jsx)(n.td,{children:"isSelected"})]})]})]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Code"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:'function Foldable:onUpdate(dt, isActiveForInput, isActiveForInputIgnoreSelection, isSelected)\n    local spec = self.spec_foldable\n    if math.abs(spec.foldMoveDirection) > 0.1 then\n        local isInvalid = false\n        local foldAnimTime = 0\n        if spec.foldMoveDirection < - 0.1 then\n            foldAnimTime = 1\n        end\n        for _,foldingPart in pairs(spec.foldingParts) do\n            local charSet = foldingPart.animCharSet\n            if spec.foldMoveDirection > 0 then\n                local animTime\n                if charSet ~ = 0 then\n                    animTime = getAnimTrackTime(charSet, 0 )\n                else\n                        animTime = self:getRealAnimationTime(foldingPart.animationName)\n                    end\n                    if animTime < foldingPart.animDuration then\n                        isInvalid = true\n                    end\n                    foldAnimTime = math.max(foldAnimTime, animTime / spec.maxFoldAnimDuration)\n                elseif spec.foldMoveDirection < 0 then\n                        local animTime\n                        if charSet ~ = 0 then\n                            animTime = getAnimTrackTime(charSet, 0 )\n                        else\n                                animTime = self:getRealAnimationTime(foldingPart.animationName)\n                            end\n                            if animTime > 0 then\n                                isInvalid = true\n                            end\n                            foldAnimTime = math.min(foldAnimTime, animTime / spec.maxFoldAnimDuration)\n                        end\n                    end\n                    foldAnimTime = math.clamp(foldAnimTime, 0 , 1 )\n                    if foldAnimTime ~ = spec.foldAnimTime then\n                        spec.foldAnimTime = foldAnimTime\n                        SpecializationUtil.raiseEvent( self , "onFoldTimeChanged" , spec.foldAnimTime)\n                    end\n\n                    if spec.foldMoveDirection > 0 then\n                        if not spec.moveToMiddle or spec.foldMiddleAnimTime = = nil then\n                            if spec.foldAnimTime = = 1 then\n                                spec.foldMoveDirection = 0\n                            end\n                        else\n                                if spec.foldAnimTime = = spec.foldMiddleAnimTime then\n                                    spec.foldMoveDirection = 0\n                                end\n                            end\n                        elseif spec.foldMoveDirection < 0 then\n                                if not spec.moveToMiddle or spec.foldMiddleAnimTime = = nil then\n                                    if spec.foldAnimTime = = 0 then\n                                        spec.foldMoveDirection = 0\n                                    end\n                                else\n                                        if spec.foldAnimTime = = spec.foldMiddleAnimTime then\n                                            spec.foldMoveDirection = 0\n                                        end\n                                    end\n                                end\n\n                                if isInvalid and self.isServer then\n                                    for _,foldingPart in pairs(spec.foldingParts) do\n                                        if foldingPart.componentJoint ~ = nil then\n                                            self:setComponentJointFrame(foldingPart.componentJoint, foldingPart.anchorActor)\n                                        end\n                                    end\n                                end\n\n                                for _, vehicle in pairs(spec.subFoldingStateVehicles) do\n                                    Foldable.setAnimTime(vehicle, spec.foldAnimTime, false )\n                                end\n\n                                if not spec.allowControlWhileFolding then\n                                    if self.brake ~ = nil then\n                                        self:brake( self:getBrakeForce())\n                                    end\n                                end\n                            end\n\n                            for i = 1 , #spec.foldingParts do\n                                local foldingPart = spec.foldingParts[i]\n\n                                local delayedLowering = foldingPart.delayedLowering\n                                if delayedLowering ~ = nil then\n                                    if delayedLowering.currentDistance > = 0 then\n                                        delayedLowering.currentDistance = delayedLowering.currentDistance + self.lastMovedDistance\n\n                                        if delayedLowering.prevDistance = = nil and delayedLowering.startTime + delayedLowering.previousDuration < g_ time then\n                                            delayedLowering.prevDistance = delayedLowering.currentDistance\n                                        end\n\n                                        local lowerDistance = self.lastSpeedReal * delayedLowering.loweringDuration\n                                        local prevDistance = delayedLowering.prevDistance or( self.lastSpeedReal * delayedLowering.previousDuration)\n\n                                        local distance = (delayedLowering.distance + prevDistance) - lowerDistance\n                                        local force = g_ time > delayedLowering.startTime + delayedLowering.maxDelayDuration * math.clamp((delayedLowering.currentDistance / distance) * 0.5 + 0.5 , 0 , 1 )\n\n                                        if delayedLowering.aiSkipDelay then\n                                            force = force or self:getIsAIActive()\n                                        end\n\n                                        if delayedLowering.skipDelayOnReverse then\n                                            force = force or( self:getLastSpeed() > 2.5 and self.movingDirection < 0 )\n                                        end\n\n                                        if delayedLowering.currentDistance > = distance or force then\n                                            self:playAnimation(foldingPart.animationName, delayedLowering.speedScale, delayedLowering.animTime, true )\n\n                                            if delayedLowering.stopAnimTime ~ = nil then\n                                                self:setAnimationStopTime(foldingPart.animationName, delayedLowering.stopAnimTime)\n                                            end\n\n                                            delayedLowering.currentDistance = - 1\n                                        end\n                                    end\n                                end\n                            end\n                        end\n\n'})}),"\n",(0,t.jsx)(n.h3,{id:"onupdatetick",children:"onUpdateTick"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Description"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Definition"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"onUpdateTick()"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"any"}),(0,t.jsx)(n.th,{children:"dt"})]})}),(0,t.jsxs)(n.tbody,{children:[(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"any"}),(0,t.jsx)(n.td,{children:"isActiveForInput"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"any"}),(0,t.jsx)(n.td,{children:"isActiveForInputIgnoreSelection"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"any"}),(0,t.jsx)(n.td,{children:"isSelected"})]})]})]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Code"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:"function Foldable:onUpdateTick(dt, isActiveForInput, isActiveForInputIgnoreSelection, isSelected)\n    local spec = self.spec_foldable\n\n    -- update actionEvents\n    if self.isClient then\n        Foldable.updateActionEventFold( self )\n        if spec.foldMiddleAnimTime ~ = nil then\n            Foldable.updateActionEventFoldMiddle( self )\n        end\n    end\n\n    if self.isServer then\n        -- after the tool has been unfolded we need to sync the attacher joint lowering state with the folding lowering state to be in line\n        if spec.ignoreFoldMiddleWhileFolded and self.getAttacherVehicle ~ = nil then\n            if math.abs(spec.foldAnimTime - spec.foldMiddleAnimTime) < 0.001 and(spec.foldMoveDirection = = 1 ) = = (spec.turnOnFoldDirection = = 1 ) then\n                local attacherVehicle = self:getAttacherVehicle()\n                if attacherVehicle ~ = nil then\n                    local jointDesc = attacherVehicle:getAttacherJointDescFromObject( self )\n                    if jointDesc.allowsLowering or jointDesc.isDefaultLowered then\n                        if jointDesc.moveDown then\n                            self:setFoldState( - 1 , false )\n                        end\n                    end\n                end\n            end\n        end\n    end\nend\n\n"})}),"\n",(0,t.jsx)(n.h3,{id:"onwritestream",children:"onWriteStream"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Description"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Definition"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"onWriteStream()"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"any"}),(0,t.jsx)(n.th,{children:"streamId"})]})}),(0,t.jsx)(n.tbody,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"any"}),(0,t.jsx)(n.td,{children:"connection"})]})})]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Code"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:"function Foldable:onWriteStream(streamId, connection)\n    local spec = self.spec_foldable\n\n    local direction = math.sign(spec.foldMoveDirection) + 1\n    streamWriteUIntN(streamId, direction, 2 )\n    streamWriteBool(streamId, spec.moveToMiddle)\n    streamWriteFloat32(streamId, spec.foldAnimTime)\nend\n\n"})}),"\n",(0,t.jsx)(n.h3,{id:"prerequisitespresent",children:"prerequisitesPresent"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Description"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Definition"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"prerequisitesPresent()"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,t.jsx)(n.table,{children:(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"any"}),(0,t.jsx)(n.th,{children:"specializations"})]})})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Code"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:"function Foldable.prerequisitesPresent(specializations)\n    return true\nend\n\n"})}),"\n",(0,t.jsx)(n.h3,{id:"registereventlisteners",children:"registerEventListeners"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Description"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Definition"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"registerEventListeners()"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,t.jsx)(n.table,{children:(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"any"}),(0,t.jsx)(n.th,{children:"vehicleType"})]})})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Code"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:'function Foldable.registerEventListeners(vehicleType)\n    SpecializationUtil.registerEventListener(vehicleType, "onLoad" , Foldable )\n    SpecializationUtil.registerEventListener(vehicleType, "onPostLoad" , Foldable )\n    SpecializationUtil.registerEventListener(vehicleType, "onRegistered" , Foldable )\n    SpecializationUtil.registerEventListener(vehicleType, "onReadStream" , Foldable )\n    SpecializationUtil.registerEventListener(vehicleType, "onWriteStream" , Foldable )\n    SpecializationUtil.registerEventListener(vehicleType, "onUpdate" , Foldable )\n    SpecializationUtil.registerEventListener(vehicleType, "onUpdateTick" , Foldable )\n    SpecializationUtil.registerEventListener(vehicleType, "onRegisterActionEvents" , Foldable )\n    SpecializationUtil.registerEventListener(vehicleType, "onRegisterExternalActionEvents" , Foldable )\n    SpecializationUtil.registerEventListener(vehicleType, "onDeactivate" , Foldable )\n    SpecializationUtil.registerEventListener(vehicleType, "onSetLoweredAll" , Foldable )\n    SpecializationUtil.registerEventListener(vehicleType, "onPostAttach" , Foldable )\n    SpecializationUtil.registerEventListener(vehicleType, "onPreDetach" , Foldable )\n    SpecializationUtil.registerEventListener(vehicleType, "onRootVehicleChanged" , Foldable )\n    SpecializationUtil.registerEventListener(vehicleType, "onPreAttachImplement" , Foldable )\n    SpecializationUtil.registerEventListener(vehicleType, "onPreDetachImplement" , Foldable )\n    SpecializationUtil.registerEventListener(vehicleType, "onDynamicMountTypeChanged" , Foldable )\nend\n\n'})}),"\n",(0,t.jsx)(n.h3,{id:"registerevents",children:"registerEvents"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Description"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Definition"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"registerEvents()"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,t.jsx)(n.table,{children:(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"any"}),(0,t.jsx)(n.th,{children:"vehicleType"})]})})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Code"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:'function Foldable.registerEvents(vehicleType)\n    SpecializationUtil.registerEvent(vehicleType, "onFoldStateChanged" )\n    SpecializationUtil.registerEvent(vehicleType, "onFoldTimeChanged" )\nend\n\n'})}),"\n",(0,t.jsx)(n.h3,{id:"registerfoldingxmlpaths",children:"registerFoldingXMLPaths"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Description"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Definition"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"registerFoldingXMLPaths()"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"any"}),(0,t.jsx)(n.th,{children:"schema"})]})}),(0,t.jsx)(n.tbody,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"any"}),(0,t.jsx)(n.td,{children:"basePath"})]})})]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Code"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:'function Foldable.registerFoldingXMLPaths(schema, basePath)\n    schema:register(XMLValueType.L10N_STRING, basePath .. "#objectText" , "override OBJECT text inserted in folding action string" , "vehicle typeDesc" )\n    schema:register(XMLValueType.L10N_STRING, basePath .. "#posDirectionText" , "Positive direction text" , "$l10n_action_foldOBJECT" )\n    schema:register(XMLValueType.L10N_STRING, basePath .. "#negDirectionText" , "Negative direction text" , "$l10n_action_unfoldOBJECT" )\n    schema:register(XMLValueType.L10N_STRING, basePath .. "#middlePosDirectionText" , "Positive middle direction text" , "$l10n_action_liftOBJECT" )\n    schema:register(XMLValueType.L10N_STRING, basePath .. "#middleNegDirectionText" , "Negative middle direction text" , "$l10n_action_lowerOBJECT" )\n\n    schema:register(XMLValueType.FLOAT, basePath .. "#startAnimTime" , "Start animation time" , "Depending on startMoveDirection" )\n    schema:register(XMLValueType.INT, basePath .. "#startMoveDirection" , "Start move direction" , 0 )\n    schema:register(XMLValueType.INT, basePath .. "#turnOnFoldDirection" , "Turn on fold direction" )\n    schema:register(XMLValueType.BOOL, basePath .. "#allowUnfoldingByAI" , "Allow folding by AI" , true )\n\n    schema:register(XMLValueType.STRING, basePath .. "#foldInputButton" , "Fold Input action" , "IMPLEMENT_EXTRA2" )\n    schema:register(XMLValueType.STRING, basePath .. "#foldMiddleInputButton" , "Fold middle Input action" , "LOWER_IMPLEMENT" )\n\n    schema:register(XMLValueType.FLOAT, basePath .. "#foldMiddleAnimTime" , "Fold middle anim time" )\n    schema:register(XMLValueType.INT, basePath .. "#foldMiddleDirection" , "Fold middle direction" , 1 )\n    schema:register(XMLValueType.INT, basePath .. "#foldMiddleAIRaiseDirection" , "Fold middle AI raise direction" , "same as foldMiddleDirection" )\n\n    schema:register(XMLValueType.FLOAT, basePath .. "#turnOnFoldMaxLimit" , "Turn on fold max.limit" , 1 )\n    schema:register(XMLValueType.FLOAT, basePath .. "#turnOnFoldMinLimit" , "Turn on fold min.limit" , 0 )\n    schema:register(XMLValueType.FLOAT, basePath .. "#toggleCoverMaxLimit" , "Toggle cover fold max.limit" , 1 )\n    schema:register(XMLValueType.FLOAT, basePath .. "#toggleCoverMinLimit" , "Toggle cover fold min.limit" , 0 )\n    schema:register(XMLValueType.FLOAT, basePath .. "#detachingMaxLimit" , "Detach fold max.limit" , 1 )\n    schema:register(XMLValueType.FLOAT, basePath .. "#detachingMinLimit" , "Detach fold min.limit" , 0 )\n    schema:register(XMLValueType.FLOAT, basePath .. "#attachingMaxLimit" , "Attach fold max.limit" , 1 )\n    schema:register(XMLValueType.FLOAT, basePath .. "#attachingMinLimit" , "Attach fold min.limit" , 0 )\n    schema:register(XMLValueType.BOOL, basePath .. "#allowDetachingWhileFolding" , "Allow detaching while folding" , false )\n        schema:register(XMLValueType.FLOAT, basePath .. "#loweringMaxLimit" , "Lowering fold max.limit" , 1 )\n        schema:register(XMLValueType.FLOAT, basePath .. "#loweringMinLimit" , "Lowering fold min.limit" , 0 )\n        schema:register(XMLValueType.FLOAT, basePath .. "#loadMovingToolStatesMaxLimit" , "Load moving tool states fold max.limit" , 1 )\n        schema:register(XMLValueType.FLOAT, basePath .. "#loadMovingToolStatesMinLimit" , "Load moving tool states fold min.limit" , 0 )\n        schema:register(XMLValueType.FLOAT, basePath .. "#dynamicMountMaxLimit" , "Dynamic mount fold max.limit" , 1 )\n        schema:register(XMLValueType.FLOAT, basePath .. "#dynamicMountMinLimit" , "Dynamic mount fold min.limit" , 0 )\n        schema:register(XMLValueType.FLOAT, basePath .. "#crabSteeringMinLimit" , "Crab steering change fold max.limit" , 1 )\n        schema:register(XMLValueType.FLOAT, basePath .. "#crabSteeringMaxLimit" , "Crab steering change fold min.limit" , 0 )\n        schema:register(XMLValueType.FLOAT, basePath .. ".toggleFolding#minLimit" , "Min.fold time to invert the current folding direction when already folding" , 0 )\n        schema:register(XMLValueType.FLOAT, basePath .. ".toggleFolding#maxLimit" , "Max.fold time to invert the current folding direction when already folding" , 1 )\n        schema:register(XMLValueType.INT, basePath .. ".toggleFolding#blockedDirection" , "Direction which is blocked while not in the given range(0 = all directions)" , 0 )\n\n            schema:register(XMLValueType.L10N_STRING, basePath .. "#unfoldWarning" , "Unfold warning(Triggered when not in the right folding state for certain action(due to min/max limits))" , "$l10n_warning_firstUnfoldTheTool" )\n                schema:register(XMLValueType.L10N_STRING, basePath .. "#detachWarning" , "Detach warning(Triggered when trying to detach while currently folding)" , "$l10n_warning_doNotDetachWhileFolding" )\n\n                    schema:register(XMLValueType.BOOL, basePath .. "#useParentFoldingState" , "The fold state can not be controlled manually.It\'s always a copy of the fold state of the parent vehicle." , false )\n                    schema:register(XMLValueType.BOOL, basePath .. "#ignoreFoldMiddleWhileFolded" , "While the tool is folded pressing the lowering button will only control the attacher joint state, not the fold state.The lowering key has only function if the tool is unfolded. (only if fold middle time defined)" , false )\n                        schema:register(XMLValueType.BOOL, basePath .. "#lowerWhileDetach" , "If tool is in fold middle state it gets lowered on detach and lifted while it\'s attached again" , false )\n                            schema:register(XMLValueType.BOOL, basePath .. "#foldWhileDetach" , "Fold the tool while it is being detached" , false )\n                                schema:register(XMLValueType.BOOL, basePath .. "#keepFoldingWhileDetached" , "If set to \'true\' the tool is still continuing with the folding animation after the tool is detached, otherwise it\'s stopped" , "true for mobile platform, otherwise false" )\n                                    schema:register(XMLValueType.BOOL, basePath .. "#releaseBrakesWhileFolding" , "If set to \'true\' the tool is releasing it\'s brakes while the folding is active" , false )\n                                        schema:register(XMLValueType.BOOL, basePath .. "#requiresPower" , "Vehicle needs to be powered to change folding state" , true )\n                                        schema:register(XMLValueType.BOOL, basePath .. "#allowControlWhileFolding" , "Allow controlling of vehicle while folding is in progress" , true )\n\n                                            schema:register(XMLValueType.FLOAT, basePath .. ".foldingPart(?)#speedScale" , "Speed scale" , 1 )\n                                            schema:register(XMLValueType.INT, basePath .. ".foldingPart(?)#componentJointIndex" , "Component joint index" )\n                                            schema:register(XMLValueType.INT, basePath .. ".foldingPart(?)#anchorActor" , "Component joint anchor actor" , 0 )\n\n                                            schema:register(XMLValueType.NODE_INDEX, basePath .. ".foldingPart(?)#rootNode" , "Root node for animation clip" )\n                                                schema:register(XMLValueType.STRING, basePath .. ".foldingPart(?)#animationClip" , "Animation clip name" )\n                                                schema:register(XMLValueType.STRING, basePath .. ".foldingPart(?)#animationName" , "Animation name" )\n\n                                                schema:register(XMLValueType.FLOAT, basePath .. ".foldingPart(?)#delayDistance" , "Distance to be moved by the vehicle until part is played" )\n                                                schema:register(XMLValueType.FLOAT, basePath .. ".foldingPart(?)#previousDuration" , "lowering duration if previous part" , 1 )\n                                                    schema:register(XMLValueType.FLOAT, basePath .. ".foldingPart(?)#loweringDuration" , "lowering duration if folding part" , 1 )\n                                                        schema:register(XMLValueType.FLOAT, basePath .. ".foldingPart(?)#maxDelayDuration" , "Max.duration of distance delay until movement is forced.Decreases by half when not moving" , 7.5 )\n                                                        schema:register(XMLValueType.BOOL, basePath .. ".foldingPart(?)#aiSkipDelay" , "Defines if the AI uses the delayed lowering/lifting or is controls all parts synchronized" , false )\n                                                            schema:register(XMLValueType.BOOL, basePath .. ".foldingPart(?)#skipDelayOnReverse" , "While reversing the delay is completely skipped" , true )\n                                                        end\n\n'})}),"\n",(0,t.jsx)(n.h3,{id:"registerfunctions",children:"registerFunctions"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Description"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Definition"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"registerFunctions()"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,t.jsx)(n.table,{children:(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"any"}),(0,t.jsx)(n.th,{children:"vehicleType"})]})})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Code"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:'function Foldable.registerFunctions(vehicleType)\n    SpecializationUtil.registerFunction(vehicleType, "loadFoldingPartFromXML" , Foldable.loadFoldingPartFromXML)\n    SpecializationUtil.registerFunction(vehicleType, "setFoldDirection" , Foldable.setFoldDirection)\n    SpecializationUtil.registerFunction(vehicleType, "setFoldState" , Foldable.setFoldState)\n    SpecializationUtil.registerFunction(vehicleType, "setFoldMiddleState" , Foldable.setFoldMiddleState)\n    SpecializationUtil.registerFunction(vehicleType, "getIsUnfolded" , Foldable.getIsUnfolded)\n    SpecializationUtil.registerFunction(vehicleType, "getFoldAnimTime" , Foldable.getFoldAnimTime)\n    SpecializationUtil.registerFunction(vehicleType, "setIsFoldActionAllowed" , Foldable.setIsFoldActionAllowed)\n    SpecializationUtil.registerFunction(vehicleType, "getIsFoldActionAllowed" , Foldable.getIsFoldActionAllowed)\n    SpecializationUtil.registerFunction(vehicleType, "getIsFoldAllowed" , Foldable.getIsFoldAllowed)\n    SpecializationUtil.registerFunction(vehicleType, "getIsFoldMiddleAllowed" , Foldable.getIsFoldMiddleAllowed)\n    SpecializationUtil.registerFunction(vehicleType, "getToggledFoldDirection" , Foldable.getToggledFoldDirection)\n    SpecializationUtil.registerFunction(vehicleType, "getToggledFoldMiddleDirection" , Foldable.getToggledFoldMiddleDirection)\nend\n\n'})}),"\n",(0,t.jsx)(n.h3,{id:"registerloweringactionevent",children:"registerLoweringActionEvent"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Description"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Definition"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"registerLoweringActionEvent()"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"any"}),(0,t.jsx)(n.th,{children:"superFunc"})]})}),(0,t.jsxs)(n.tbody,{children:[(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"any"}),(0,t.jsx)(n.td,{children:"actionEventsTable"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"any"}),(0,t.jsx)(n.td,{children:"inputAction"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"any"}),(0,t.jsx)(n.td,{children:"target"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"any"}),(0,t.jsx)(n.td,{children:"callback"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"any"}),(0,t.jsx)(n.td,{children:"triggerUp"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"any"}),(0,t.jsx)(n.td,{children:"triggerDown"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"any"}),(0,t.jsx)(n.td,{children:"triggerAlways"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"any"}),(0,t.jsx)(n.td,{children:"startActive"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"any"}),(0,t.jsx)(n.td,{children:"callbackState"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"any"}),(0,t.jsx)(n.td,{children:"customIconName"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"any"}),(0,t.jsx)(n.td,{children:"ignoreCollisions"})]})]})]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Code"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:"function Foldable:registerLoweringActionEvent(superFunc, actionEventsTable, inputAction, target, callback, triggerUp, triggerDown, triggerAlways, startActive, callbackState, customIconName, ignoreCollisions)\n    local spec = self.spec_foldable\n    if spec.hasFoldingParts then\n        if spec.foldMiddleAnimTime ~ = nil then\n            self:clearActionEventsTable(spec.actionEventsLowering)\n\n            local state, actionEventId\n            if spec.requiresPower then\n                state, actionEventId = self:addPoweredActionEvent(spec.actionEventsLowering, spec.foldMiddleInputButton, self , Foldable.actionEventFoldMiddle, false , true , false , true , nil , nil , ignoreCollisions)\n            else\n                    state, actionEventId = self:addActionEvent(spec.actionEventsLowering, spec.foldMiddleInputButton, self , Foldable.actionEventFoldMiddle, false , true , false , true , nil , nil , ignoreCollisions)\n                end\n\n                g_inputBinding:setActionEventTextPriority(actionEventId, GS_PRIO_HIGH)\n                Foldable.updateActionEventFoldMiddle( self )\n\n                -- if we are using the same button we use only Foldable.actionEventFoldMiddle, if not, we use both\n                    if spec.foldMiddleInputButton = = inputAction then\n                        return state, actionEventId\n                    end\n                end\n            end\n\n            return superFunc( self , actionEventsTable, inputAction, target, callback, triggerUp, triggerDown, triggerAlways, startActive, callbackState, customIconName)\n        end\n\n"})}),"\n",(0,t.jsx)(n.h3,{id:"registeroverwrittenfunctions",children:"registerOverwrittenFunctions"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Description"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Definition"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"registerOverwrittenFunctions()"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,t.jsx)(n.table,{children:(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"any"}),(0,t.jsx)(n.th,{children:"vehicleType"})]})})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Code"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:'function Foldable.registerOverwrittenFunctions(vehicleType)\n    SpecializationUtil.registerOverwrittenFunction(vehicleType, "allowLoadMovingToolStates" , Foldable.allowLoadMovingToolStates)\n    SpecializationUtil.registerOverwrittenFunction(vehicleType, "loadSpeedRotatingPartFromXML" , Foldable.loadSpeedRotatingPartFromXML)\n    SpecializationUtil.registerOverwrittenFunction(vehicleType, "getIsSpeedRotatingPartActive" , Foldable.getIsSpeedRotatingPartActive)\n    SpecializationUtil.registerOverwrittenFunction(vehicleType, "loadSlopeCompensationNodeFromXML" , Foldable.loadSlopeCompensationNodeFromXML)\n    SpecializationUtil.registerOverwrittenFunction(vehicleType, "getSlopeCompensationAngleScale" , Foldable.getSlopeCompensationAngleScale)\n    SpecializationUtil.registerOverwrittenFunction(vehicleType, "loadWheelFromXML" , Foldable.loadWheelFromXML)\n    SpecializationUtil.registerOverwrittenFunction(vehicleType, "getIsVersatileYRotActive" , Foldable.getIsVersatileYRotActive)\n    SpecializationUtil.registerOverwrittenFunction(vehicleType, "loadWorkAreaFromXML" , Foldable.loadWorkAreaFromXML)\n    SpecializationUtil.registerOverwrittenFunction(vehicleType, "getIsWorkAreaActive" , Foldable.getIsWorkAreaActive)\n    SpecializationUtil.registerOverwrittenFunction(vehicleType, "loadGroundReferenceNode" , Foldable.loadGroundReferenceNode)\n    SpecializationUtil.registerOverwrittenFunction(vehicleType, "updateGroundReferenceNode" , Foldable.updateGroundReferenceNode)\n    SpecializationUtil.registerOverwrittenFunction(vehicleType, "loadLevelerNodeFromXML" , Foldable.loadLevelerNodeFromXML)\n    SpecializationUtil.registerOverwrittenFunction(vehicleType, "getIsLevelerPickupNodeActive" , Foldable.getIsLevelerPickupNodeActive)\n    SpecializationUtil.registerOverwrittenFunction(vehicleType, "loadMovingToolFromXML" , Foldable.loadMovingToolFromXML)\n    SpecializationUtil.registerOverwrittenFunction(vehicleType, "getIsMovingToolActive" , Foldable.getIsMovingToolActive)\n    SpecializationUtil.registerOverwrittenFunction(vehicleType, "loadMovingPartFromXML" , Foldable.loadMovingPartFromXML)\n    SpecializationUtil.registerOverwrittenFunction(vehicleType, "getIsMovingPartActive" , Foldable.getIsMovingPartActive)\n    SpecializationUtil.registerOverwrittenFunction(vehicleType, "getCanBeTurnedOn" , Foldable.getCanBeTurnedOn)\n    SpecializationUtil.registerOverwrittenFunction(vehicleType, "getIsNextCoverStateAllowed" , Foldable.getIsNextCoverStateAllowed)\n    SpecializationUtil.registerOverwrittenFunction(vehicleType, "getIsNextCoverStateAllowedWarning" , Foldable.getIsNextCoverStateAllowedWarning)\n    SpecializationUtil.registerOverwrittenFunction(vehicleType, "getIsInWorkPosition" , Foldable.getIsInWorkPosition)\n    SpecializationUtil.registerOverwrittenFunction(vehicleType, "getTurnedOnNotAllowedWarning" , Foldable.getTurnedOnNotAllowedWarning)\n    SpecializationUtil.registerOverwrittenFunction(vehicleType, "isDetachAllowed" , Foldable.isDetachAllowed)\n    SpecializationUtil.registerOverwrittenFunction(vehicleType, "isAttachAllowed" , Foldable.isAttachAllowed)\n    SpecializationUtil.registerOverwrittenFunction(vehicleType, "getAllowsLowering" , Foldable.getAllowsLowering)\n    SpecializationUtil.registerOverwrittenFunction(vehicleType, "getIsLowered" , Foldable.getIsLowered)\n    SpecializationUtil.registerOverwrittenFunction(vehicleType, "getCanAIImplementContinueWork" , Foldable.getCanAIImplementContinueWork)\n    SpecializationUtil.registerOverwrittenFunction(vehicleType, "getIsAIReadyToDrive" , Foldable.getIsAIReadyToDrive)\n    SpecializationUtil.registerOverwrittenFunction(vehicleType, "getIsAIPreparingToDrive" , Foldable.getIsAIPreparingToDrive)\n    SpecializationUtil.registerOverwrittenFunction(vehicleType, "registerLoweringActionEvent" , Foldable.registerLoweringActionEvent)\n    SpecializationUtil.registerOverwrittenFunction(vehicleType, "registerSelfLoweringActionEvent" , Foldable.registerSelfLoweringActionEvent)\n    SpecializationUtil.registerOverwrittenFunction(vehicleType, "loadGroundAdjustedNodeFromXML" , Foldable.loadGroundAdjustedNodeFromXML)\n    SpecializationUtil.registerOverwrittenFunction(vehicleType, "getIsGroundAdjustedNodeActive" , Foldable.getIsGroundAdjustedNodeActive)\n    SpecializationUtil.registerOverwrittenFunction(vehicleType, "loadSprayTypeFromXML" , Foldable.loadSprayTypeFromXML)\n    SpecializationUtil.registerOverwrittenFunction(vehicleType, "getIsSprayTypeActive" , Foldable.getIsSprayTypeActive)\n    SpecializationUtil.registerOverwrittenFunction(vehicleType, "getCanBeSelected" , Foldable.getCanBeSelected)\n    SpecializationUtil.registerOverwrittenFunction(vehicleType, "loadInputAttacherJoint" , Foldable.loadInputAttacherJoint)\n    SpecializationUtil.registerOverwrittenFunction(vehicleType, "getIsInputAttacherActive" , Foldable.getIsInputAttacherActive)\n    SpecializationUtil.registerOverwrittenFunction(vehicleType, "loadAdditionalCharacterFromXML" , Foldable.loadAdditionalCharacterFromXML)\n    SpecializationUtil.registerOverwrittenFunction(vehicleType, "getIsAdditionalCharacterActive" , Foldable.getIsAdditionalCharacterActive)\n    SpecializationUtil.registerOverwrittenFunction(vehicleType, "getAllowDynamicMountObjects" , Foldable.getAllowDynamicMountObjects)\n    SpecializationUtil.registerOverwrittenFunction(vehicleType, "loadSupportAnimationFromXML" , Foldable.loadSupportAnimationFromXML)\n    SpecializationUtil.registerOverwrittenFunction(vehicleType, "getIsSupportAnimationAllowed" , Foldable.getIsSupportAnimationAllowed)\n    SpecializationUtil.registerOverwrittenFunction(vehicleType, "loadSteeringAxleFromXML" , Foldable.loadSteeringAxleFromXML)\n    SpecializationUtil.registerOverwrittenFunction(vehicleType, "getIsSteeringAxleAllowed" , Foldable.getIsSteeringAxleAllowed)\n    SpecializationUtil.registerOverwrittenFunction(vehicleType, "loadFillUnitFromXML" , Foldable.loadFillUnitFromXML)\n    SpecializationUtil.registerOverwrittenFunction(vehicleType, "getFillUnitSupportsToolType" , Foldable.getFillUnitSupportsToolType)\n    SpecializationUtil.registerOverwrittenFunction(vehicleType, "loadTurnedOnAnimationFromXML" , Foldable.loadTurnedOnAnimationFromXML)\n    SpecializationUtil.registerOverwrittenFunction(vehicleType, "getIsTurnedOnAnimationActive" , Foldable.getIsTurnedOnAnimationActive)\n    SpecializationUtil.registerOverwrittenFunction(vehicleType, "loadAttacherJointHeightNode" , Foldable.loadAttacherJointHeightNode)\n    SpecializationUtil.registerOverwrittenFunction(vehicleType, "getIsAttacherJointHeightNodeActive" , Foldable.getIsAttacherJointHeightNodeActive)\n    SpecializationUtil.registerOverwrittenFunction(vehicleType, "loadPickupFromXML" , Foldable.loadPickupFromXML)\n    SpecializationUtil.registerOverwrittenFunction(vehicleType, "getCanChangePickupState" , Foldable.getCanChangePickupState)\n    SpecializationUtil.registerOverwrittenFunction(vehicleType, "loadCutterTiltFromXML" , Foldable.loadCutterTiltFromXML)\n    SpecializationUtil.registerOverwrittenFunction(vehicleType, "getCutterTiltIsActive" , Foldable.getCutterTiltIsActive)\n    SpecializationUtil.registerOverwrittenFunction(vehicleType, "loadPreprunerNodeFromXML" , Foldable.loadPreprunerNodeFromXML)\n    SpecializationUtil.registerOverwrittenFunction(vehicleType, "getIsPreprunerNodeActive" , Foldable.getIsPreprunerNodeActive)\n    SpecializationUtil.registerOverwrittenFunction(vehicleType, "loadShovelNode" , Foldable.loadShovelNode)\n    SpecializationUtil.registerOverwrittenFunction(vehicleType, "getShovelNodeIsActive" , Foldable.getShovelNodeIsActive)\n    SpecializationUtil.registerOverwrittenFunction(vehicleType, "loadSteeringAngleNodeFromXML" , Foldable.loadSteeringAngleNodeFromXML)\n    SpecializationUtil.registerOverwrittenFunction(vehicleType, "updateSteeringAngleNode" , Foldable.updateSteeringAngleNode)\n    SpecializationUtil.registerOverwrittenFunction(vehicleType, "loadWoodHarvesterHeaderTiltFromXML" , Foldable.loadWoodHarvesterHeaderTiltFromXML)\n    SpecializationUtil.registerOverwrittenFunction(vehicleType, "getIsWoodHarvesterTiltStateAllowed" , Foldable.getIsWoodHarvesterTiltStateAllowed)\n    SpecializationUtil.registerOverwrittenFunction(vehicleType, "loadSuspensionNodeFromXML" , Foldable.loadSuspensionNodeFromXML)\n    SpecializationUtil.registerOverwrittenFunction(vehicleType, "getIsSuspensionNodeActive" , Foldable.getIsSuspensionNodeActive)\n    SpecializationUtil.registerOverwrittenFunction(vehicleType, "loadCrabSteeringModeFromXML" , Foldable.loadCrabSteeringModeFromXML)\n    SpecializationUtil.registerOverwrittenFunction(vehicleType, "getCrabSteeringModeAvailable" , Foldable.getCrabSteeringModeAvailable)\n    SpecializationUtil.registerOverwrittenFunction(vehicleType, "getCanToggleCrabSteering" , Foldable.getCanToggleCrabSteering)\n    SpecializationUtil.registerOverwrittenFunction(vehicleType, "onLoadWheelChockFromXML" , Foldable.onLoadWheelChockFromXML)\n    SpecializationUtil.registerOverwrittenFunction(vehicleType, "getIsWheelChockAllowed" , Foldable.getIsWheelChockAllowed)\n    SpecializationUtil.registerOverwrittenFunction(vehicleType, "loadCraneShovelFromXML" , Foldable.loadCraneShovelFromXML)\n    SpecializationUtil.registerOverwrittenFunction(vehicleType, "getCraneShovelStateChangedAllowed" , Foldable.getCraneShovelStateChangedAllowed)\n    SpecializationUtil.registerOverwrittenFunction(vehicleType, "getBrakeForce" , Foldable.getBrakeForce)\n    SpecializationUtil.registerOverwrittenFunction(vehicleType, "getRequiresPower" , Foldable.getRequiresPower)\nend\n\n'})}),"\n",(0,t.jsx)(n.h3,{id:"registerselfloweringactionevent",children:"registerSelfLoweringActionEvent"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Description"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Definition"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"registerSelfLoweringActionEvent()"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"any"}),(0,t.jsx)(n.th,{children:"superFunc"})]})}),(0,t.jsxs)(n.tbody,{children:[(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"any"}),(0,t.jsx)(n.td,{children:"actionEventsTable"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"any"}),(0,t.jsx)(n.td,{children:"inputAction"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"any"}),(0,t.jsx)(n.td,{children:"target"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"any"}),(0,t.jsx)(n.td,{children:"callback"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"any"}),(0,t.jsx)(n.td,{children:"triggerUp"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"any"}),(0,t.jsx)(n.td,{children:"triggerDown"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"any"}),(0,t.jsx)(n.td,{children:"triggerAlways"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"any"}),(0,t.jsx)(n.td,{children:"startActive"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"any"}),(0,t.jsx)(n.td,{children:"callbackState"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"any"}),(0,t.jsx)(n.td,{children:"customIconName"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"any"}),(0,t.jsx)(n.td,{children:"ignoreCollisions"})]})]})]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Code"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:"function Foldable:registerSelfLoweringActionEvent(superFunc, actionEventsTable, inputAction, target, callback, triggerUp, triggerDown, triggerAlways, startActive, callbackState, customIconName, ignoreCollisions)\n    return Foldable.registerLoweringActionEvent( self , superFunc, actionEventsTable, inputAction, target, callback, triggerUp, triggerDown, triggerAlways, startActive, callbackState, customIconName, ignoreCollisions)\nend\n\n"})}),"\n",(0,t.jsx)(n.h3,{id:"savetoxmlfile",children:"saveToXMLFile"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Description"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Definition"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"saveToXMLFile()"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"any"}),(0,t.jsx)(n.th,{children:"xmlFile"})]})}),(0,t.jsxs)(n.tbody,{children:[(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"any"}),(0,t.jsx)(n.td,{children:"key"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"any"}),(0,t.jsx)(n.td,{children:"usedModNames"})]})]})]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Code"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:'function Foldable:saveToXMLFile(xmlFile, key, usedModNames)\n    local spec = self.spec_foldable\n    if spec.hasFoldingParts then\n        xmlFile:setValue(key .. "#foldAnimTime" , spec.foldAnimTime)\n        xmlFile:setValue(key .. "#isAllowed" , spec.isFoldAllowed)\n    end\nend\n\n'})}),"\n",(0,t.jsx)(n.h3,{id:"setanimtime",children:"setAnimTime"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Description"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Definition"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"setAnimTime()"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"any"}),(0,t.jsx)(n.th,{children:"self"})]})}),(0,t.jsxs)(n.tbody,{children:[(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"any"}),(0,t.jsx)(n.td,{children:"animTime"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"any"}),(0,t.jsx)(n.td,{children:"placeComponents"})]})]})]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Code"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:'function Foldable.setAnimTime( self , animTime, placeComponents)\n    local spec = self.spec_foldable\n\n    spec.foldAnimTime = animTime\n    spec.loadedFoldAnimTime = nil\n    for _,foldingPart in pairs(spec.foldingParts) do\n        if foldingPart.animCharSet ~ = 0 then\n            enableAnimTrack(foldingPart.animCharSet, 0 )\n            setAnimTrackTime(foldingPart.animCharSet, 0 , spec.foldAnimTime * foldingPart.animDuration, true )\n            disableAnimTrack(foldingPart.animCharSet, 0 )\n        else\n                animTime = (spec.foldAnimTime * spec.maxFoldAnimDuration) / self:getAnimationDuration(foldingPart.animationName)\n                self:setAnimationTime(foldingPart.animationName, animTime, true )\n            end\n        end\n\n        if placeComponents = = nil then\n            placeComponents = true\n        end\n\n        if self.updateCylinderedInitial ~ = nil then\n            self:updateCylinderedInitial(placeComponents)\n        end\n\n        if placeComponents then\n            if self.isServer then\n                for _,foldingPart in pairs(spec.foldingParts) do\n                    if foldingPart.componentJoint ~ = nil then\n                        local componentJoint = foldingPart.componentJoint\n\n                        local jointNode = componentJoint.jointNode\n                        if foldingPart.anchorActor = = 1 then\n                            jointNode = componentJoint.jointNodeActor1\n                        end\n\n                        local node = self.components[componentJoint.componentIndices[ ((foldingPart.anchorActor + 1 ) % 2 ) + 1 ] ].node\n                        local x,y,z = localToWorld(jointNode, foldingPart.x, foldingPart.y, foldingPart.z)\n                        local upX,upY,upZ = localDirectionToWorld(jointNode, foldingPart.upX,foldingPart.upY,foldingPart.upZ)\n                        local dirX,dirY,dirZ = localDirectionToWorld(jointNode, foldingPart.dirX,foldingPart.dirY,foldingPart.dirZ)\n                        setWorldTranslation(node, x,y,z)\n                        I3DUtil.setWorldDirection(node, dirX,dirY,dirZ, upX,upY,upZ)\n\n                        self:setComponentJointFrame(componentJoint, foldingPart.anchorActor)\n                    end\n                end\n            end\n        end\n\n        for _, vehicle in pairs(spec.subFoldingStateVehicles) do\n            Foldable.setAnimTime(vehicle, animTime, placeComponents)\n        end\n\n        SpecializationUtil.raiseEvent( self , "onFoldTimeChanged" , spec.foldAnimTime)\n    end\n\n'})}),"\n",(0,t.jsx)(n.h3,{id:"setfolddirection",children:"setFoldDirection"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Description"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Definition"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"setFoldDirection()"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"any"}),(0,t.jsx)(n.th,{children:"direction"})]})}),(0,t.jsx)(n.tbody,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"any"}),(0,t.jsx)(n.td,{children:"noEventSend"})]})})]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Code"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:"function Foldable:setFoldDirection(direction, noEventSend)\n    self:setFoldState(direction, false , noEventSend)\nend\n\n"})}),"\n",(0,t.jsx)(n.h3,{id:"setfoldmiddlestate",children:"setFoldMiddleState"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Description"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Definition"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"setFoldMiddleState()"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,t.jsx)(n.table,{children:(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"any"}),(0,t.jsx)(n.th,{children:"doLowering"})]})})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Code"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:"function Foldable:setFoldMiddleState(doLowering)\n    local spec = self.spec_foldable\n    if spec.foldMiddleAnimTime ~ = nil then\n        if self:getIsFoldMiddleAllowed() then\n            if doLowering then\n                self:setFoldState( - spec.foldMiddleAIRaiseDirection, false )\n            else\n                    self:setFoldState(spec.foldMiddleAIRaiseDirection, true )\n                end\n            end\n        end\n    end\n\n"})}),"\n",(0,t.jsx)(n.h3,{id:"setfoldstate",children:"setFoldState"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Description"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Definition"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"setFoldState()"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"any"}),(0,t.jsx)(n.th,{children:"direction"})]})}),(0,t.jsxs)(n.tbody,{children:[(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"any"}),(0,t.jsx)(n.td,{children:"moveToMiddle"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"any"}),(0,t.jsx)(n.td,{children:"noEventSend"})]})]})]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Code"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:'function Foldable:setFoldState(direction, moveToMiddle, noEventSend)\n    local spec = self.spec_foldable\n\n    if spec.foldMiddleAnimTime = = nil then\n        moveToMiddle = false\n    end\n    if spec.foldMoveDirection ~ = direction or spec.moveToMiddle ~ = moveToMiddle then\n        if noEventSend = = nil or noEventSend = = false then\n            if g_server ~ = nil then\n                g_server:broadcastEvent( FoldableSetFoldDirectionEvent.new( self , direction, moveToMiddle), nil , nil , self )\n            else\n                    g_client:getServerConnection():sendEvent( FoldableSetFoldDirectionEvent.new( self , direction, moveToMiddle))\n                end\n            end\n            spec.foldMoveDirection = direction\n            spec.moveToMiddle = moveToMiddle\n\n            for _,foldingPart in pairs(spec.foldingParts) do\n                local speedScale = nil\n                -- We don\'t do any animations if we are already past the middle time\n                    if spec.foldMoveDirection > 0.1 then\n                        if not spec.moveToMiddle or spec.foldAnimTime < spec.foldMiddleAnimTime then\n                            speedScale = foldingPart.speedScale\n                        end\n                    elseif spec.foldMoveDirection < - 0.1 then\n                            if not spec.moveToMiddle or spec.foldAnimTime > spec.foldMiddleAnimTime then\n                                speedScale = - foldingPart.speedScale\n                            end\n                        end\n\n                        local charSet = foldingPart.animCharSet\n                        if charSet ~ = 0 then\n                            if speedScale ~ = nil then\n                                if speedScale > 0 then\n                                    if getAnimTrackTime(charSet, 0 ) < 0.0 then\n                                        setAnimTrackTime(charSet, 0 , 0.0 )\n                                    end\n                                else\n                                        if getAnimTrackTime(charSet, 0 ) > foldingPart.animDuration then\n                                            setAnimTrackTime(charSet, 0 , foldingPart.animDuration)\n                                        end\n                                    end\n                                    setAnimTrackSpeedScale(charSet, 0 , speedScale)\n                                    enableAnimTrack(charSet, 0 )\n                                else\n                                        disableAnimTrack(charSet, 0 )\n                                    end\n                                else\n                                        -- always stop to make sure the animation state is reset\n                                        local animTime\n                                        if self:getIsAnimationPlaying(foldingPart.animationName) then\n                                            animTime = self:getAnimationTime(foldingPart.animationName)\n                                        else\n                                                animTime = (spec.foldAnimTime * spec.maxFoldAnimDuration) / self:getAnimationDuration(foldingPart.animationName)\n                                            end\n                                            local alreadyPlaying = self:getIsAnimationPlaying(foldingPart.animationName)\n                                            self:stopAnimation(foldingPart.animationName, true )\n                                            if speedScale ~ = nil then\n                                                local stopAnimTime\n                                                if moveToMiddle then\n                                                    stopAnimTime = (spec.foldMiddleAnimTime * spec.maxFoldAnimDuration) / self:getAnimationDuration(foldingPart.animationName)\n                                                end\n\n                                                local isFolding = ((direction ~ = spec.turnOnFoldDirection) = = not moveToMiddle)\n                                                if foldingPart.delayedLowering = = nil or isFolding or alreadyPlaying then\n                                                    self:playAnimation(foldingPart.animationName, speedScale, animTime, true )\n\n                                                    if moveToMiddle then\n                                                        self:setAnimationStopTime(foldingPart.animationName, stopAnimTime)\n                                                    end\n\n                                                    if foldingPart.delayedLowering ~ = nil then\n                                                        foldingPart.delayedLowering.currentDistance = - 1\n                                                    end\n                                                else\n                                                        local delayedLowering = foldingPart.delayedLowering\n                                                        delayedLowering.currentDistance = 0\n                                                        delayedLowering.speedScale = speedScale\n                                                        delayedLowering.animTime = animTime\n                                                        delayedLowering.stopAnimTime = stopAnimTime\n                                                        delayedLowering.startTime = g_ time\n                                                        delayedLowering.prevDistance = nil\n                                                    end\n                                                end\n                                            end\n                                        end\n                                        -- slightly move fold anim time, so that fold limits can trigger for different actions\n                                            if spec.foldMoveDirection > 0.1 then\n                                                spec.foldAnimTime = math.min(spec.foldAnimTime + 0.0001 , math.max(spec.foldAnimTime, 1 ))\n                                            elseif spec.foldMoveDirection < - 0.1 then\n                                                    spec.foldAnimTime = math.max(spec.foldAnimTime - 0.0001 , math.min(spec.foldAnimTime, 0 ))\n                                                end\n\n                                                if not spec.allowControlWhileFolding then\n                                                    if self.setCruiseControlState ~ = nil then\n                                                        self:setCruiseControlState( Drivable.CRUISECONTROL_STATE_OFF)\n                                                    end\n                                                end\n\n                                                SpecializationUtil.raiseEvent( self , "onFoldStateChanged" , direction, moveToMiddle)\n                                            end\n                                        end\n\n'})}),"\n",(0,t.jsx)(n.h3,{id:"setisfoldactionallowed",children:"setIsFoldActionAllowed"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Description"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"Used to block the folding input action"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Definition"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"setIsFoldActionAllowed(boolean isAllowed)"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,t.jsx)(n.table,{children:(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"boolean"}),(0,t.jsx)(n.th,{children:"isAllowed"})]})})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Code"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:"function Foldable:setIsFoldActionAllowed(isAllowed)\n    self.spec_foldable.isFoldAllowed = isAllowed\nend\n\n"})}),"\n",(0,t.jsx)(n.h3,{id:"updateactioneventfold",children:"updateActionEventFold"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Description"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Definition"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"updateActionEventFold()"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,t.jsx)(n.table,{children:(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"any"}),(0,t.jsx)(n.th,{children:"self"})]})})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Code"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:"function Foldable.updateActionEventFold( self )\n    local spec = self.spec_foldable\n    local actionEvent = spec.actionEvents[spec.foldInputButton]\n    if actionEvent ~ = nil then\n        local direction = self:getToggledFoldDirection()\n        local text\n        if direction = = spec.turnOnFoldDirection then\n            text = spec.negDirectionText\n        else\n                text = spec.posDirectionText\n            end\n            g_inputBinding:setActionEventText(actionEvent.actionEventId, text)\n            g_inputBinding:setActionEventActive(actionEvent.actionEventId, self:getIsFoldActionAllowed())\n        end\n    end\n\n"})}),"\n",(0,t.jsx)(n.h3,{id:"updateactioneventfoldmiddle",children:"updateActionEventFoldMiddle"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Description"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Definition"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"updateActionEventFoldMiddle()"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,t.jsx)(n.table,{children:(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"any"}),(0,t.jsx)(n.th,{children:"self"})]})})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Code"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:"function Foldable.updateActionEventFoldMiddle( self )\n    local spec = self.spec_foldable\n    local actionEvent = spec.actionEventsLowering[spec.foldMiddleInputButton]\n    if actionEvent ~ = nil then\n        local state = self:getIsFoldMiddleAllowed()\n        g_inputBinding:setActionEventActive(actionEvent.actionEventId, state)\n        if state then\n            local direction = self:getToggledFoldMiddleDirection() = = spec.foldMiddleDirection\n            if spec.ignoreFoldMiddleWhileFolded then\n                if self:getFoldAnimTime() > spec.foldMiddleAnimTime then\n                    direction = self:getIsLowered( true )\n                end\n            end\n\n            local text\n            if direction then\n                text = spec.middlePosDirectionText\n            else\n                    text = spec.middleNegDirectionText\n                end\n                g_inputBinding:setActionEventText(actionEvent.actionEventId, text)\n            end\n        end\n    end\n\n"})}),"\n",(0,t.jsx)(n.h3,{id:"updategroundreferencenode",children:"updateGroundReferenceNode"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Description"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Definition"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"updateGroundReferenceNode()"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"any"}),(0,t.jsx)(n.th,{children:"superFunc"})]})}),(0,t.jsx)(n.tbody,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"any"}),(0,t.jsx)(n.td,{children:"groundReferenceNode"})]})})]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Code"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:"function Foldable:updateGroundReferenceNode(superFunc, groundReferenceNode)\n    superFunc( self , groundReferenceNode)\n\n    local foldAnimTime = self:getFoldAnimTime()\n    if foldAnimTime > groundReferenceNode.foldMaxLimit or foldAnimTime < groundReferenceNode.foldMinLimit then\n        groundReferenceNode.isActive = false\n    end\nend\n\n"})}),"\n",(0,t.jsx)(n.h3,{id:"updatesteeringanglenode",children:"updateSteeringAngleNode"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Description"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Definition"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"updateSteeringAngleNode()"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"any"}),(0,t.jsx)(n.th,{children:"superFunc"})]})}),(0,t.jsxs)(n.tbody,{children:[(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"any"}),(0,t.jsx)(n.td,{children:"steeringAngleNode"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"any"}),(0,t.jsx)(n.td,{children:"angle"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"any"}),(0,t.jsx)(n.td,{children:"dt"})]})]})]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Code"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:"function Foldable:updateSteeringAngleNode(superFunc, steeringAngleNode, angle, dt)\n    local foldAnimTime = self:getFoldAnimTime()\n    if foldAnimTime < steeringAngleNode.foldMinLimit or foldAnimTime > steeringAngleNode.foldMaxLimit then\n        return\n    end\n\n    return superFunc( self , steeringAngleNode, angle, dt)\nend\n\n"})})]})}function h(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(a,{...e})}):a(e)}},28453(e,n,i){i.d(n,{R:()=>d,x:()=>s});var l=i(96540);const t={},r=l.createContext(t);function d(e){const n=l.useContext(r);return l.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function s(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:d(e.components),l.createElement(r.Provider,{value:n},e.children)}}}]);