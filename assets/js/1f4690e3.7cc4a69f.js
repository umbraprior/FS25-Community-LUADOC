"use strict";(globalThis.webpackChunkfs25_community_luadoc=globalThis.webpackChunkfs25_community_luadoc||[]).push([[14303],{28453(e,n,t){t.d(n,{R:()=>d,x:()=>i});var s=t(96540);const o={},r=s.createContext(o);function d(e){const n=s.useContext(r);return s.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function i(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:d(e.components),s.createElement(r.Provider,{value:n},e.children)}},69069(e,n,t){t.r(n),t.d(n,{assets:()=>h,contentTitle:()=>i,default:()=>c,frontMatter:()=>d,metadata:()=>s,toc:()=>a});const s=JSON.parse('{"id":"engine/Shape/setShapeBones","title":"setShapeBones","description":"setShapeBones","source":"@site/../docs/engine/Shape/setShapeBones.md","sourceDirName":"engine/Shape","slug":"/engine/Shape/setShapeBones","permalink":"/FS25-Community-LUADOC/engine/Shape/setShapeBones","draft":false,"unlisted":false,"tags":[],"version":"current","lastUpdatedAt":1767330635000,"frontMatter":{},"sidebar":"docsSidebar","previous":{"title":"setShaderParameterRecursive","permalink":"/FS25-Community-LUADOC/engine/Shape/setShaderParameterRecursive"},"next":{"title":"setShapeBonesFromShape","permalink":"/FS25-Community-LUADOC/engine/Shape/setShapeBonesFromShape"}}');var o=t(74848),r=t(28453);const d={},i=void 0,h={},a=[{value:"setShapeBones",id:"setshapebones",level:3}];function l(e){const n={blockquote:"blockquote",h3:"h3",p:"p",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",...(0,r.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(n.h3,{id:"setshapebones",children:"setShapeBones"}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Description"})}),"\n",(0,o.jsxs)(n.blockquote,{children:["\n",(0,o.jsx)(n.p,{children:"Set the bones of the shape given the new root node. The hierarchy of the new bones must be mostly the same as for the\ncurrently set bones. Additional children after the used bones are allowed. Bones are matched by node indices and not\nby\nname.\nThe new root newRootBoneId must match with oldRootBoneId or the currently assigned root (lowest common root node of\nall bones) if oldRootBoneId is 0."}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Definition"})}),"\n",(0,o.jsxs)(n.blockquote,{children:["\n",(0,o.jsx)(n.p,{children:"setShapeBones(entityId shapeId, entityId newRootBoneId, entityId oldRootBoneId, boolean? keepBindPoses)"}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,o.jsxs)(n.table,{children:[(0,o.jsx)(n.thead,{children:(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.th,{children:"entityId"}),(0,o.jsx)(n.th,{children:"shapeId"}),(0,o.jsx)(n.th,{children:"shapeId"})]})}),(0,o.jsxs)(n.tbody,{children:[(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:"entityId"}),(0,o.jsx)(n.td,{children:"newRootBoneId"}),(0,o.jsx)(n.td,{children:"The roof the new skeleton"})]}),(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:"entityId"}),(0,o.jsx)(n.td,{children:"oldRootBoneId"}),(0,o.jsx)(n.td,{children:"The root of the currently assigned skeleton. If 0, the lowest common root node of the currently assigned bones is used"})]}),(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:"boolean?"}),(0,o.jsx)(n.td,{children:"keepBindPoses"}),(0,o.jsx)(n.td,{children:"If true, the bind poses of the current bones are kept, otherwise the new bones are assumed to be in the bind pose [optional]"})]})]})]}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Return Values"})}),"\n\n\n\n\n\n\n\n",(0,o.jsx)(n.table,{children:(0,o.jsx)(n.thead,{children:(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.th,{children:"boolean"}),(0,o.jsx)(n.th,{children:"success"})]})})})]})}function c(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(l,{...e})}):l(e)}}}]);