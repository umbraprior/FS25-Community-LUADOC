"use strict";(globalThis.webpackChunkfs25_community_luadoc=globalThis.webpackChunkfs25_community_luadoc||[]).push([[32626],{28453(e,n,t){t.d(n,{R:()=>r,x:()=>h});var i=t(96540);const s={},l=i.createContext(s);function r(e){const n=i.useContext(l);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function h(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:r(e.components),i.createElement(l.Provider,{value:n},e.children)}},62013(e,n,t){t.r(n),t.d(n,{assets:()=>d,contentTitle:()=>h,default:()=>o,frontMatter:()=>r,metadata:()=>i,toc:()=>a});const i=JSON.parse('{"id":"script/Components/StaticLight","title":"StaticLight","description":"StaticLight","source":"@site/../docs/script/Components/StaticLight.md","sourceDirName":"script/Components","slug":"/script/Components/StaticLight","permalink":"/FS25-Community-LUADOC/script/Components/StaticLight","draft":false,"unlisted":false,"tags":[],"version":"current","lastUpdatedAt":1767161192000,"frontMatter":{},"sidebar":"docsSidebar","previous":{"title":"SharedLight","permalink":"/FS25-Community-LUADOC/script/Components/SharedLight"},"next":{"title":"StaticLightCompound","permalink":"/FS25-Community-LUADOC/script/Components/StaticLightCompound"}}');var s=t(74848),l=t(28453);const r={},h=void 0,d={},a=[{value:"StaticLight",id:"staticlight",level:2},{value:"loadFromXML",id:"loadfromxml",level:3},{value:"loadLightsFromXML",id:"loadlightsfromxml",level:3},{value:"merge",id:"merge",level:3},{value:"new",id:"new",level:3},{value:"registerXMLPaths",id:"registerxmlpaths",level:3},{value:"setChargeFunction",id:"setchargefunction",level:3},{value:"setIsBlinking",id:"setisblinking",level:3},{value:"setLightTypesMask",id:"setlighttypesmask",level:3},{value:"setState",id:"setstate",level:3}];function c(e){const n={a:"a",blockquote:"blockquote",code:"code",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,l.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.h2,{id:"staticlight",children:"StaticLight"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"Class for static light mesh control"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Functions"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#loadfromxml",children:"loadFromXML"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#loadlightsfromxml",children:"loadLightsFromXML"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#merge",children:"merge"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#new",children:"new"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#registerxmlpaths",children:"registerXMLPaths"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#setchargefunction",children:"setChargeFunction"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#setisblinking",children:"setIsBlinking"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#setlighttypesmask",children:"setLightTypesMask"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#setstate",children:"setState"})}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"loadfromxml",children:"loadFromXML"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Definition"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"loadFromXML()"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"any"}),(0,s.jsx)(n.th,{children:"xmlFile"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"any"}),(0,s.jsx)(n.td,{children:"baseKey"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"any"}),(0,s.jsx)(n.td,{children:"components"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"any"}),(0,s.jsx)(n.td,{children:"i3dMappings"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"any"}),(0,s.jsx)(n.td,{children:"loadLightTypes"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"any"}),(0,s.jsx)(n.td,{children:"sharedLight"})]})]})]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Code"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:'function StaticLight:loadFromXML(xmlFile, baseKey, components, i3dMappings, loadLightTypes, sharedLight)\n    self.node = xmlFile:getValue(baseKey .. "#node" , nil , components, i3dMappings) or xmlFile:getValue(baseKey .. "#shaderNode" , nil , components, i3dMappings)\n    if self.node = = nil then\n        Logging.xmlWarning(xmlFile, "Missing static lights node in \'%s\'" , baseKey)\n        return false\n    end\n\n    if getHasClassId( self.node, ClassIds.LIGHT_SOURCE) then\n        Logging.xmlWarning(xmlFile, "Light source used in static light \'%s\'" , baseKey)\n        return false\n    end\n\n    if not getHasClassId( self.node, ClassIds.SHAPE) then\n        Logging.xmlWarning(xmlFile, "Node used in static light \'%s\' is not a shape" , baseKey)\n        return false\n    end\n\n    if sharedLight ~ = nil then\n        local isValid = false\n        local parent = self.node\n        while parent ~ = nil and parent ~ = 0 and parent ~ = getRootNode() do\n            if parent = = sharedLight.node then\n                isValid = true\n                break\n            end\n\n            parent = getParent(parent)\n        end\n\n        if not isValid then\n            Logging.xmlWarning(xmlFile, "Static light mesh \'%s\' is outside of the root shared light node(%s) in \'%s\'" , getName( self.node), getName(sharedLight.node), baseKey)\n            return false\n        end\n    end\n\n    self.useLightControlShaderParameter = getHasShaderParameter( self.node, "lightControl" )\n    if not self.useLightControlShaderParameter then\n        self.absUVSlotIndex = xmlFile:getValue(baseKey .. "#uvSlotIndex" )\n        if self.absUVSlotIndex ~ = nil then\n            self.uvSlotParameter = "lightIds0"\n            self.uvSlotIndex = self.absUVSlotIndex\n\n            if self.uvSlotIndex > 4 then\n                self.uvSlotParameter = "lightIds1"\n                self.uvSlotIndex = self.uvSlotIndex - 4\n            end\n\n            if self.uvSlotIndex > 4 then\n                self.uvSlotParameter = "lightIds2"\n                self.uvSlotIndex = self.uvSlotIndex - 4\n            end\n\n            if self.uvSlotIndex > 4 then\n                self.uvSlotParameter = "lightIds3"\n                self.uvSlotIndex = self.uvSlotIndex - 4\n            end\n        end\n    end\n\n    self.intensity = xmlFile:getValue(baseKey .. "#intensity" , 5 )\n\n    self.toggleVisibility = xmlFile:getValue(baseKey .. "#toggleVisibility" , false )\n    if self.toggleVisibility then\n        setVisibility( self.node, false )\n    else\n            if not getHasShaderParameter( self.node, "lightControl" ) and not getHasShaderParameter( self.node, "lightIds0" ) then\n                Logging.xmlWarning(xmlFile, "Static lights not using \'lightControl\' or \'lightIds0\' shader parameter in \'%s\'" , baseKey)\n                return false\n            end\n        end\n\n        if loadLightTypes ~ = false then\n            self.lightTypes = xmlFile:getValue(baseKey .. "#lightTypes" , nil , true )\n            self.excludedLightTypes = xmlFile:getValue(baseKey .. "#excludedLightTypes" , nil , true )\n\n            -- overwrite the light types if custom light types are defined in the shared light definition\n                if sharedLight ~ = nil then\n                    if sharedLight.lightTypes ~ = nil then\n                        self.lightTypes = table.clone(sharedLight.lightTypes, 1 )\n                    end\n                    if sharedLight.excludedLightTypes ~ = nil then\n                        self.excludedLightTypes = table.clone(sharedLight.excludedLightTypes, 1 )\n                    end\n                end\n            end\n\n            if sharedLight ~ = nil then\n                if sharedLight.additionalAttributes ~ = nil then\n                    for k, v in pairs(sharedLight.additionalAttributes) do\n                        self [k] = v\n                    end\n                end\n            end\n\n            if self.lightTypes = = nil then\n                self.lightTypes = { }\n            end\n\n            if self.excludedLightTypes = = nil then\n                self.excludedLightTypes = { }\n            end\n\n            -- additional attributes are not supported inside shared lights\n            if self.vehicle ~ = nil then\n                if xmlFile:getRootName() = = "vehicle" then\n                    self.vehicle:loadAdditionalLightAttributesFromXML(xmlFile, baseKey, self )\n                end\n            end\n\n            self:setState( false )\n\n            return true\n        end\n\n'})}),"\n",(0,s.jsx)(n.h3,{id:"loadlightsfromxml",children:"loadLightsFromXML"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Definition"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"loadLightsFromXML()"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"any"}),(0,s.jsx)(n.th,{children:"lights"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"any"}),(0,s.jsx)(n.td,{children:"xmlFile"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"any"}),(0,s.jsx)(n.td,{children:"baseKey"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"any"}),(0,s.jsx)(n.td,{children:"vehicle"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"any"}),(0,s.jsx)(n.td,{children:"components"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"any"}),(0,s.jsx)(n.td,{children:"i3dMappings"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"any"}),(0,s.jsx)(n.td,{children:"loadLightTypes"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"any"}),(0,s.jsx)(n.td,{children:"sharedLight"})]})]})]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Code"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:"function StaticLight.loadLightsFromXML(lights, xmlFile, baseKey, vehicle, components, i3dMappings, loadLightTypes, sharedLight)\n    if lights = = nil then\n        lights = { }\n    end\n\n    for _, key in xmlFile:iterator(baseKey) do\n        local light = StaticLight.new(vehicle)\n        if light:loadFromXML(xmlFile, key, components, i3dMappings, loadLightTypes, sharedLight) then\n            if vehicle ~ = nil then\n                local otherLight = vehicle:getStaticLightFromNode(light.node)\n                if otherLight ~ = nil then\n                    light = light:merge(otherLight)\n                end\n            end\n\n            table.insert(lights, light)\n        end\n    end\n\n    return lights\nend\n\n"})}),"\n",(0,s.jsx)(n.h3,{id:"merge",children:"merge"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Definition"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"merge()"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,s.jsx)(n.table,{children:(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"any"}),(0,s.jsx)(n.th,{children:"otherLight"})]})})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Code"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:"function StaticLight:merge(otherLight)\n    -- in case we are working with uv slot indices we only merge if we have the same index\n        if self.uvSlotIndex ~ = nil then\n            if self.uvSlotIndex ~ = otherLight.uvSlotIndex\n                or self.uvSlotParameter ~ = otherLight.uvSlotParameter then\n                return self\n            end\n        end\n\n        -- add the light types and exluded light types from ourself to the other light\n        -- and return the other light - so our instance is dropped, so we only have one StaticLight instance per node\n        for i, lightType in ipairs( self.lightTypes) do\n            table.addElement(otherLight.lightTypes, lightType)\n        end\n\n        for i, excludedLightType in ipairs( self.excludedLightTypes) do\n            table.addElement(otherLight.excludedLightTypes, excludedLightType)\n        end\n\n        return otherLight\n    end\n\n"})}),"\n",(0,s.jsx)(n.h3,{id:"new",children:"new"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Definition"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"new()"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"any"}),(0,s.jsx)(n.th,{children:"vehicle"})]})}),(0,s.jsx)(n.tbody,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"any"}),(0,s.jsx)(n.td,{children:"customMt"})]})})]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Code"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:"function StaticLight.new(vehicle, customMt)\n    local self = setmetatable( { } , customMt or StaticLight _mt)\n\n    self.vehicle = vehicle\n\n    self.chargeFunction = nil\n\n    return self\nend\n\n"})}),"\n",(0,s.jsx)(n.h3,{id:"registerxmlpaths",children:"registerXMLPaths"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Definition"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"registerXMLPaths()"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"any"}),(0,s.jsx)(n.th,{children:"schema"})]})}),(0,s.jsx)(n.tbody,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"any"}),(0,s.jsx)(n.td,{children:"basePath"})]})})]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Code"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:'function StaticLight.registerXMLPaths(schema, basePath)\n    schema:register(XMLValueType.NODE_INDEX, basePath .. "#node" , "Visual light node" )\n    schema:register(XMLValueType.NODE_INDEX, basePath .. "#shaderNode" , "Shader node" )\n\n    schema:register(XMLValueType.INT, basePath .. "#uvSlotIndex" , "UV slot if vehicleShader with \'lightIds\' shader parameter is used(slot 1-16)" , "if not defined, all slots will be set equally" )\n\n        schema:register(XMLValueType.FLOAT, basePath .. "#intensity" , "Intensity" , 5 )\n        schema:register(XMLValueType.BOOL, basePath .. "#toggleVisibility" , "Toggle visibility" , false )\n\n        schema:register(XMLValueType.VECTOR_N, basePath .. "#excludedLightTypes" , "Excluded light types" )\n        schema:register(XMLValueType.VECTOR_N, basePath .. "#lightTypes" , "Light types" )\n    end\n\n'})}),"\n",(0,s.jsx)(n.h3,{id:"setchargefunction",children:"setChargeFunction"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Definition"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"setChargeFunction()"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"any"}),(0,s.jsx)(n.th,{children:"func"})]})}),(0,s.jsx)(n.tbody,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"any"}),(0,s.jsx)(n.td,{children:"funcTarget"})]})})]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Code"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:"function StaticLight:setChargeFunction(func, funcTarget)\n    self.chargeFunction, self.chargeFunctionTarget = func, funcTarget\nend\n\n"})}),"\n",(0,s.jsx)(n.h3,{id:"setisblinking",children:"setIsBlinking"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Definition"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"setIsBlinking()"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,s.jsx)(n.table,{children:(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"any"}),(0,s.jsx)(n.th,{children:"isBlinking"})]})})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Code"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:'function StaticLight:setIsBlinking(isBlinking)\n    if not self.useLightControlShaderParameter then\n        if self.absUVSlotIndex = = nil then\n            local lightTypeBitMask = 0\n\n            -- set all to blinking\n            for i = 0 , 11 do\n                lightTypeBitMask = bit32.bor(lightTypeBitMask, bit32.lshift(StaticLightCompoundLightType.BLINKING - 1 , i * 2 ))\n            end\n\n            setShaderParameter( self.node, "lightTypeBitMask" , lightTypeBitMask, nil , nil , nil , false )\n        else\n                if self.absUVSlotIndex < = 12 then\n                    local lightTypeBitMask = getShaderParameter( self.node, "lightTypeBitMask" )\n\n                    local bitIndex = ( self.absUVSlotIndex - 1 ) * 2\n                    local mask = ( 2 ^ ( 12 * 2 ) - 1 ) - bit32.lshift(0x3, bitIndex)\n                    lightTypeBitMask = bit32.band(lightTypeBitMask, mask) -- erase\n                    lightTypeBitMask = bit32.bor(lightTypeBitMask, bit32.lshift(StaticLightCompoundLightType.BLINKING - 1 , bitIndex)) -- set to blinking\n                    setShaderParameter( self.node, "lightTypeBitMask" , lightTypeBitMask, nil , nil , nil , false )\n                end\n            end\n        end\n    end\n\n'})}),"\n",(0,s.jsx)(n.h3,{id:"setlighttypesmask",children:"setLightTypesMask"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Definition"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"setLightTypesMask()"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,s.jsx)(n.table,{children:(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"any"}),(0,s.jsx)(n.th,{children:"lightsTypesMask"})]})})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Code"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:"function StaticLight:setLightTypesMask(lightsTypesMask)\n    -- this function only works if any light types are defined, otherwise setState needs to be used\n        if # self.lightTypes = = 0 then\n            return\n        end\n\n        if self.vehicle = = nil then\n            return\n        end\n\n        if self.vehicle:getIsLightActive( self ) then\n            local isActive, chargeScale = false , nil\n\n            for _, lightType in pairs( self.lightTypes) do\n                if bit32.band(lightsTypesMask, 2 ^ lightType) ~ = 0 or(lightType = = - 1 and self.vehicle:getIsActiveForLights( true )) then\n                    if not isActive then\n                        isActive = true\n                    else\n                            -- if one base light type + one additional light type is enabled we increase the brightness(e.g.back and brake light)\n                                if lightType > self.vehicle.spec_lights.maxLightState then\n                                    chargeScale = 2\n                                end\n                            end\n                        end\n                    end\n\n                    if isActive and self.excludedLightTypes ~ = nil then\n                        for _, excludedLightType in pairs( self.excludedLightTypes) do\n                            if bit32.band(lightsTypesMask, 2 ^ excludedLightType) ~ = 0 then\n                                isActive = false\n                                break\n                            end\n                        end\n                    end\n\n                    if self.chargeFunction ~ = nil then\n                        chargeScale = self.chargeFunction( self.chargeFunctionTarget)\n                    end\n\n                    self:setState(isActive, chargeScale)\n                else\n                        self:setState( false , 0 )\n                    end\n                end\n\n"})}),"\n",(0,s.jsx)(n.h3,{id:"setstate",children:"setState"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Definition"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"setState()"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"any"}),(0,s.jsx)(n.th,{children:"isActive"})]})}),(0,s.jsx)(n.tbody,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"any"}),(0,s.jsx)(n.td,{children:"chargeScale"})]})})]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Code"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:'function StaticLight:setState(isActive, chargeScale)\n    if self.toggleVisibility then\n        setVisibility( self.node, isActive)\n    else\n            local lightCharge = chargeScale or(isActive and 1 or 0 )\n            local intensity = self.intensity * lightCharge\n            if self.useLightControlShaderParameter then\n                setShaderParameter( self.node, "lightControl" , intensity, nil , nil , nil , false )\n            else\n                    if self.uvSlotIndex ~ = nil then\n                        if self.uvSlotIndex = = 1 then\n                            setShaderParameter( self.node, self.uvSlotParameter, intensity, nil , nil , nil , false )\n                        elseif self.uvSlotIndex = = 2 then\n                                setShaderParameter( self.node, self.uvSlotParameter, nil , intensity, nil , nil , false )\n                            elseif self.uvSlotIndex = = 3 then\n                                    setShaderParameter( self.node, self.uvSlotParameter, nil , nil , intensity, nil , false )\n                                elseif self.uvSlotIndex = = 4 then\n                                        setShaderParameter( self.node, self.uvSlotParameter, nil , nil , nil , intensity, false )\n                                    end\n                                else\n                                        setShaderParameter( self.node, "lightIds0" , intensity, intensity, intensity, intensity, false )\n                                        setShaderParameter( self.node, "lightIds1" , intensity, intensity, intensity, intensity, false )\n                                        setShaderParameter( self.node, "lightIds2" , intensity, intensity, intensity, intensity, false )\n                                        setShaderParameter( self.node, "lightIds3" , intensity, intensity, intensity, intensity, false )\n                                    end\n                                end\n                            end\n                        end\n\n'})})]})}function o(e={}){const{wrapper:n}={...(0,l.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(c,{...e})}):c(e)}}}]);