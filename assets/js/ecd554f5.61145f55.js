"use strict";(globalThis.webpackChunkfs25_community_luadoc=globalThis.webpackChunkfs25_community_luadoc||[]).push([[28470],{28453(e,n,d){d.d(n,{R:()=>r,x:()=>i});var s=d(96540);const t={},o=s.createContext(t);function r(e){const n=s.useContext(o);return s.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function i(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:r(e.components),s.createElement(o.Provider,{value:n},e.children)}},46029(e,n,d){d.r(n),d.d(n,{assets:()=>a,contentTitle:()=>i,default:()=>u,frontMatter:()=>r,metadata:()=>s,toc:()=>l});const s=JSON.parse('{"id":"script/Specializations/GroundAdjustedNodes","title":"GroundAdjustedNodes","description":"GroundAdjustedNodes","source":"@site/../docs/script/Specializations/GroundAdjustedNodes.md","sourceDirName":"script/Specializations","slug":"/script/Specializations/GroundAdjustedNodes","permalink":"/FS25-Community-LUADOC/script/Specializations/GroundAdjustedNodes","draft":false,"unlisted":false,"tags":[],"version":"current","lastUpdatedAt":1767161192000,"frontMatter":{},"sidebar":"docsSidebar","previous":{"title":"FruitPreparer","permalink":"/FS25-Community-LUADOC/script/Specializations/FruitPreparer"},"next":{"title":"GroundReference","permalink":"/FS25-Community-LUADOC/script/Specializations/GroundReference"}}');var t=d(74848),o=d(28453);const r={},i=void 0,a={},l=[{value:"GroundAdjustedNodes",id:"groundadjustednodes",level:2},{value:"getIsGroundAdjustedNodeActive",id:"getisgroundadjustednodeactive",level:3},{value:"initGroundAdjustedAdjustNode",id:"initgroundadjustedadjustnode",level:3},{value:"initSpecialization",id:"initspecialization",level:3},{value:"loadGroundAdjustedAdjustNodeFromXML",id:"loadgroundadjustedadjustnodefromxml",level:3},{value:"loadGroundAdjustedNodeFromXML",id:"loadgroundadjustednodefromxml",level:3},{value:"loadGroundAdjustedRaycastNodeFromXML",id:"loadgroundadjustedraycastnodefromxml",level:3},{value:"onLoad",id:"onload",level:3},{value:"onLoadFinished",id:"onloadfinished",level:3},{value:"onRegisterAnimationValueTypes",id:"onregisteranimationvaluetypes",level:3},{value:"onUpdate",id:"onupdate",level:3},{value:"prerequisitesPresent",id:"prerequisitespresent",level:3},{value:"registerAdjustNodeXMLPaths",id:"registeradjustnodexmlpaths",level:3},{value:"registerEventListeners",id:"registereventlisteners",level:3},{value:"registerFunctions",id:"registerfunctions",level:3},{value:"registerNodeXMLPaths",id:"registernodexmlpaths",level:3},{value:"updateGroundAdjustedNode",id:"updategroundadjustednode",level:3},{value:"updateGroundAdjustedRaycasts",id:"updategroundadjustedraycasts",level:3}];function c(e){const n={a:"a",blockquote:"blockquote",code:"code",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,o.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.h2,{id:"groundadjustednodes",children:"GroundAdjustedNodes"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Description"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"Specialization for adjusting nodes to the ground/terrain height (e.g. liquid manure spreaders with hoses)"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Functions"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#getisgroundadjustednodeactive",children:"getIsGroundAdjustedNodeActive"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#initgroundadjustedadjustnode",children:"initGroundAdjustedAdjustNode"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#initspecialization",children:"initSpecialization"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#loadgroundadjustedadjustnodefromxml",children:"loadGroundAdjustedAdjustNodeFromXML"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#loadgroundadjustednodefromxml",children:"loadGroundAdjustedNodeFromXML"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#loadgroundadjustedraycastnodefromxml",children:"loadGroundAdjustedRaycastNodeFromXML"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#onload",children:"onLoad"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#onloadfinished",children:"onLoadFinished"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#onregisteranimationvaluetypes",children:"onRegisterAnimationValueTypes"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#onupdate",children:"onUpdate"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#prerequisitespresent",children:"prerequisitesPresent"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#registeradjustnodexmlpaths",children:"registerAdjustNodeXMLPaths"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#registereventlisteners",children:"registerEventListeners"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#registerfunctions",children:"registerFunctions"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#registernodexmlpaths",children:"registerNodeXMLPaths"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#updategroundadjustednode",children:"updateGroundAdjustedNode"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#updategroundadjustedraycasts",children:"updateGroundAdjustedRaycasts"})}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"getisgroundadjustednodeactive",children:"getIsGroundAdjustedNodeActive"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Description"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Definition"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"getIsGroundAdjustedNodeActive()"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"any"}),(0,t.jsx)(n.th,{children:"groundAdjustedNode"})]})}),(0,t.jsx)(n.tbody,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"any"}),(0,t.jsx)(n.td,{children:"ignoreAttachState"})]})})]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Code"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:"function GroundAdjustedNodes:getIsGroundAdjustedNodeActive(groundAdjustedNode, ignoreAttachState)\n    local spec = self.spec_groundAdjustedNodes\n    return not spec.onlyActiveWhileAttached or( self.getAttacherVehicle = = nil or self:getAttacherVehicle() ~ = nil ) or ignoreAttachState\nend\n\n"})}),"\n",(0,t.jsx)(n.h3,{id:"initgroundadjustedadjustnode",children:"initGroundAdjustedAdjustNode"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Description"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Definition"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"initGroundAdjustedAdjustNode()"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"any"}),(0,t.jsx)(n.th,{children:"groundAdjustedNode"})]})}),(0,t.jsx)(n.tbody,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"any"}),(0,t.jsx)(n.td,{children:"adjustNode"})]})})]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Code"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:"function GroundAdjustedNodes:initGroundAdjustedAdjustNode(groundAdjustedNode, adjustNode)\n    if #groundAdjustedNode.raycastNodes = = 2 then\n        local x1, _, z1 = localToLocal(adjustNode.node, getParent(groundAdjustedNode.raycastNodes[ 1 ].node), 0 , 0 , 0 )\n        local x2, _, z2 = localToLocal(groundAdjustedNode.raycastNodes[ 1 ].node, getParent(groundAdjustedNode.raycastNodes[ 1 ].node), 0 , 0 , 0 )\n        local x3, _, z3 = localToLocal(groundAdjustedNode.raycastNodes[ 2 ].node, getParent(groundAdjustedNode.raycastNodes[ 1 ].node), 0 , 0 , 0 )\n        local dirX, dirZ = x3 - x2, z3 - z2\n        local length = MathUtil.vector2Length(x3 - x2, z3 - z2)\n        dirX, dirZ = MathUtil.vector2Normalize(dirX, dirZ)\n\n        adjustNode.alpha = MathUtil.getProjectOnLineParameter(x1, z1, x2, z2, dirX, dirZ) / length\n    end\nend\n\n"})}),"\n",(0,t.jsx)(n.h3,{id:"initspecialization",children:"initSpecialization"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Description"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"Called on specialization initializing"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Definition"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"initSpecialization()"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Code"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:'function GroundAdjustedNodes.initSpecialization()\n    g_vehicleConfigurationManager:addConfigurationType( "groundAdjustedNode" , g_i18n:getText( "shop_configuration" ), "groundAdjustedNodes" , VehicleConfigurationItem )\n\n    local schema = Vehicle.xmlSchema\n    schema:setXMLSpecializationType( "GroundAdjustedNodes" )\n\n    schema:register(XMLValueType.FLOAT, "vehicle.groundAdjustedNodes#maxUpdateDistance" , "If the player is more than this distance away the nodes will no longer be updated" , 100 )\n    schema:register(XMLValueType.FLOAT, "vehicle.groundAdjustedNodes#maxUpdateDistanceWobble" , "If the player is more than this distance away the wobble effect which is applied on the field will not be shown anymore" , 50 )\n    schema:register(XMLValueType.BOOL, "vehicle.groundAdjustedNodes#adjustToWater" , "If \'true\', the adjust node will be placed on top of any water plane" , false )\n    schema:register(XMLValueType.BOOL, "vehicle.groundAdjustedNodes#onlyActiveWhileAttached" , "Defines if the tool needs to be attached to have the ground adjusted nodes active" , true )\n\n        GroundAdjustedNodes.registerNodeXMLPaths(schema, "vehicle.groundAdjustedNodes.groundAdjustedNode(?)" )\n        GroundAdjustedNodes.registerNodeXMLPaths(schema, "vehicle.groundAdjustedNodes.groundAdjustedNodeConfigurations.groundAdjustedNodeConfiguration(?).groundAdjustedNode(?)" )\n\n        schema:addDelayedRegistrationFunc( "AnimatedVehicle:part" , function (cSchema, cKey)\n            cSchema:register(XMLValueType.FLOAT, cKey .. "#startGroundAdjustScale" , "Start scale of ground adjusted node(blending between detected ground and inactive position)" )\n            cSchema:register(XMLValueType.FLOAT, cKey .. "#endGroundAdjustScale" , "Start scale of ground adjusted node(blending between detected ground and inactive position)" )\n        end )\n\n        schema:setXMLSpecializationType()\n    end\n\n'})}),"\n",(0,t.jsx)(n.h3,{id:"loadgroundadjustedadjustnodefromxml",children:"loadGroundAdjustedAdjustNodeFromXML"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Description"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Definition"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"loadGroundAdjustedAdjustNodeFromXML()"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"any"}),(0,t.jsx)(n.th,{children:"xmlFile"})]})}),(0,t.jsxs)(n.tbody,{children:[(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"any"}),(0,t.jsx)(n.td,{children:"key"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"any"}),(0,t.jsx)(n.td,{children:"groundAdjustedNode"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"any"}),(0,t.jsx)(n.td,{children:"adjustNode"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"any"}),(0,t.jsx)(n.td,{children:"required"})]})]})]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Code"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:'function GroundAdjustedNodes:loadGroundAdjustedAdjustNodeFromXML(xmlFile, key, groundAdjustedNode, adjustNode, required)\n    local node = xmlFile:getValue(key .. "#node" , nil , self.components, self.i3dMappings)\n    if node = = nil then\n        if required = = true then\n            Logging.xmlWarning(xmlFile, "Missing \'node\' for groundAdjustedNode \'%s\'!" , key)\n            end\n\n            return false\n        end\n\n        local x, y, z = getTranslation(node)\n        adjustNode.node = node\n        adjustNode.x = x\n        adjustNode.y = y\n        adjustNode.z = z\n\n        adjustNode.minY = xmlFile:getValue(key .. "#minY" , y - 1 )\n        adjustNode.maxY = xmlFile:getValue(key .. "#maxY" , adjustNode.minY + 1 )\n        adjustNode.moveSpeed = xmlFile:getValue(key .. "#moveSpeed" , 1 ) / 1000\n        adjustNode.moveSpeedStateChange = (xmlFile:getValue(key .. "#moveSpeedStateChange" , adjustNode.moveSpeed * 1000 )) / 1000\n        adjustNode.resetIfNotActive = xmlFile:getValue(key .. "#resetIfNotActive" , true )\n        adjustNode.updateThreshold = xmlFile:getValue(key .. "#updateThreshold" , 0.002 )\n\n        adjustNode.inActiveY = xmlFile:getValue(key .. "#inActiveY" , y) + xmlFile:getValue(key .. "#inActiveOffsetY" , 0 )\n        adjustNode.averageInActivePosY = xmlFile:getValue(key .. "#averageInActivePosY" , false )\n\n        adjustNode.targetY = adjustNode.inActiveY\n        adjustNode.curY = adjustNode.inActiveY\n        adjustNode.lastY = adjustNode.inActiveY\n\n        adjustNode.lastOffsetDistance = math.random() * 10000\n\n        return true\n    end\n\n'})}),"\n",(0,t.jsx)(n.h3,{id:"loadgroundadjustednodefromxml",children:"loadGroundAdjustedNodeFromXML"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Description"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Definition"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"loadGroundAdjustedNodeFromXML()"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"any"}),(0,t.jsx)(n.th,{children:"xmlFile"})]})}),(0,t.jsxs)(n.tbody,{children:[(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"any"}),(0,t.jsx)(n.td,{children:"key"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"any"}),(0,t.jsx)(n.td,{children:"groundAdjustedNode"})]})]})]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Code"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:'function GroundAdjustedNodes:loadGroundAdjustedNodeFromXML(xmlFile, key, groundAdjustedNode)\n    local spec = self.spec_groundAdjustedNodes\n\n    groundAdjustedNode.yOffset = xmlFile:getValue(key .. "#yOffset" )\n\n    groundAdjustedNode.activationTime = xmlFile:getValue(key .. "#activationTime" , 0 ) * 1000\n    groundAdjustedNode.activationTimer = 0\n\n    groundAdjustedNode.activeScale = 1 -- interpolation between raycasts target position and inactive position\n\n    groundAdjustedNode.adjustNodes = { }\n\n    -- fallback to still support the old writting style\n    local baseAdjustNode = { }\n    if self:loadGroundAdjustedAdjustNodeFromXML(xmlFile, key, groundAdjustedNode, baseAdjustNode, false ) then\n        table.insert(groundAdjustedNode.adjustNodes, baseAdjustNode)\n    end\n\n    xmlFile:iterate(key .. ".adjustNode" , function (index, adjustKey)\n        local adjustNode = { }\n        if self:loadGroundAdjustedAdjustNodeFromXML(xmlFile, adjustKey, groundAdjustedNode, adjustNode, true ) then\n            table.insert(groundAdjustedNode.adjustNodes, adjustNode)\n        end\n    end )\n\n    groundAdjustedNode.raycastNodes = { }\n    xmlFile:iterate(key .. ".raycastNode" , function (index, raycastKey)\n        local raycastNode = self:loadGroundAdjustedRaycastNodeFromXML(xmlFile, raycastKey, groundAdjustedNode, { } )\n        if raycastNode ~ = nil then\n            if #groundAdjustedNode.raycastNodes > 2 then\n                Logging.xmlWarning( self.xmlFile, "Max.two raycast nodes are allowed per groundAdjustedNode! (%s)" , key)\n                return\n            end\n\n            table.insert(groundAdjustedNode.raycastNodes, raycastNode)\n            spec.raycastNodesByNode[raycastNode.node] = raycastNode\n        end\n    end )\n\n    for i = 1 , #groundAdjustedNode.adjustNodes do\n        self:initGroundAdjustedAdjustNode(groundAdjustedNode, groundAdjustedNode.adjustNodes[i])\n    end\n\n    if #groundAdjustedNode.raycastNodes > 0 and #groundAdjustedNode.adjustNodes > 0 then\n        groundAdjustedNode.isActive = false\n        return true\n    else\n            Logging.xmlWarning( self.xmlFile, "No raycastNodes or adjust nodes defined for groundAdjustedNode \'%s\'!" , key)\n                return false\n            end\n        end\n\n'})}),"\n",(0,t.jsx)(n.h3,{id:"loadgroundadjustedraycastnodefromxml",children:"loadGroundAdjustedRaycastNodeFromXML"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Description"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Definition"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"loadGroundAdjustedRaycastNodeFromXML()"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"any"}),(0,t.jsx)(n.th,{children:"xmlFile"})]})}),(0,t.jsxs)(n.tbody,{children:[(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"any"}),(0,t.jsx)(n.td,{children:"key"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"any"}),(0,t.jsx)(n.td,{children:"groundAdjustedNode"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"any"}),(0,t.jsx)(n.td,{children:"raycastNode"})]})]})]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Code"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:'function GroundAdjustedNodes:loadGroundAdjustedRaycastNodeFromXML(xmlFile, key, groundAdjustedNode, raycastNode)\n    XMLUtil.checkDeprecatedXMLElements(xmlFile, key .. "#index" , key .. "#node" ) --FS17 to FS19\n\n    local node = xmlFile:getValue(key .. "#node" , nil , self.components, self.i3dMappings)\n    if node = = nil then\n        Logging.xmlWarning(xmlFile, "Missing \'node\' for groundAdjustedNodes raycast \'%s\'!" , key)\n            return nil\n        end\n\n        raycastNode.node = node\n\n        raycastNode.maxDistance = xmlFile:getValue(key .. "#distance" , 4 )\n        raycastNode.lastRaycastDistance = raycastNode.maxDistance\n\n        raycastNode.yOffset = xmlFile:getValue(key .. "#yOffset" , groundAdjustedNode.yOffset or 0 )\n\n        local spec = self.spec_groundAdjustedNodes\n        if spec.raycastNodesByNode[node] ~ = nil then\n            local otherRaycastNode = spec.raycastNodesByNode[node]\n\n            if math.abs(raycastNode.yOffset - otherRaycastNode.yOffset) < 0.01\n                and math.abs(raycastNode.maxDistance - otherRaycastNode.maxDistance) < 0.01 then\n                return spec.raycastNodesByNode[node]\n            else\n                    Logging.xmlWarning(xmlFile, "Found multiple groundAdjustedNode raycasts with different settings for \'%s\'!" , getName(node))\n                        return nil\n                    end\n                end\n\n                raycastNode.groundAdjustRaycastCallback = function (_, transformId, x, y, z, distance)\n                    if getHasTrigger(transformId) then\n                        return true\n                    end\n\n                    if transformId ~ = 0 then\n                        raycastNode.lastRaycastDistance = distance\n                    end\n\n                    return false\n                end\n\n                raycastNode.parent = groundAdjustedNode\n\n                return raycastNode\n            end\n\n'})}),"\n",(0,t.jsx)(n.h3,{id:"onload",children:"onLoad"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Description"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Definition"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"onLoad()"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,t.jsx)(n.table,{children:(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"any"}),(0,t.jsx)(n.th,{children:"savegame"})]})})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Code"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:'function GroundAdjustedNodes:onLoad(savegame)\n    local spec = self.spec_groundAdjustedNodes\n\n    local configurationId = self.configurations[ "groundAdjustedNode" ] or 1\n    local configKey = string.format( "vehicle.groundAdjustedNodes.groundAdjustedNodeConfigurations.groundAdjustedNodeConfiguration(%d)" , configurationId - 1 )\n\n    spec.raycastNodesByNode = { }\n\n    spec.maxUpdateDistance = self.xmlFile:getValue( "vehicle.groundAdjustedNodes#maxUpdateDistance" , 100 )\n    spec.maxUpdateDistanceWobble = self.xmlFile:getValue( "vehicle.groundAdjustedNodes#maxUpdateDistanceWobble" , 50 )\n    spec.adjustToWater = self.xmlFile:getValue( "vehicle.groundAdjustedNodes#adjustToWater" , false )\n    spec.onlyActiveWhileAttached = self.xmlFile:getValue( "vehicle.groundAdjustedNodes#onlyActiveWhileAttached" , true )\n\n    spec.groundAdjustedNodes = { }\n    self.xmlFile:iterate( "vehicle.groundAdjustedNodes.groundAdjustedNode" , function (index, key)\n        local groundAdjustedNode = { }\n        if self:loadGroundAdjustedNodeFromXML( self.xmlFile, key, groundAdjustedNode) then\n            table.insert(spec.groundAdjustedNodes, groundAdjustedNode)\n        end\n    end )\n\n    self.xmlFile:iterate(configKey .. ".groundAdjustedNode" , function (index, key)\n        local groundAdjustedNode = { }\n        if self:loadGroundAdjustedNodeFromXML( self.xmlFile, key, groundAdjustedNode) then\n            table.insert(spec.groundAdjustedNodes, groundAdjustedNode)\n        end\n    end )\n\n    if #spec.groundAdjustedNodes = = 0 then\n        SpecializationUtil.removeEventListener( self , "onLoadFinished" , GroundAdjustedNodes )\n        SpecializationUtil.removeEventListener( self , "onUpdate" , GroundAdjustedNodes )\n        SpecializationUtil.removeEventListener( self , "onRegisterAnimationValueTypes" , GroundAdjustedNodes )\n    end\nend\n\n'})}),"\n",(0,t.jsx)(n.h3,{id:"onloadfinished",children:"onLoadFinished"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Description"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Definition"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"onLoadFinished()"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,t.jsx)(n.table,{children:(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"any"}),(0,t.jsx)(n.th,{children:"savegame"})]})})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Code"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:"function GroundAdjustedNodes:onLoadFinished(savegame)\n    local spec = self.spec_groundAdjustedNodes\n\n    for _, groundAdjustedNode in pairs(spec.groundAdjustedNodes) do\n        groundAdjustedNode.isActive = self:getIsGroundAdjustedNodeActive(groundAdjustedNode, true )\n        if groundAdjustedNode.isActive then\n            for i = 1 , #groundAdjustedNode.adjustNodes do\n                local adjustNode = groundAdjustedNode.adjustNodes[i]\n                if math.abs(adjustNode.y - adjustNode.curY) > 0.01 then\n                    setTranslation(adjustNode.node, adjustNode.x, adjustNode.curY, adjustNode.z)\n\n                    if self.setMovingToolDirty ~ = nil then\n                        self:setMovingToolDirty(adjustNode.node)\n                    end\n                end\n            end\n        end\n    end\nend\n\n"})}),"\n",(0,t.jsx)(n.h3,{id:"onregisteranimationvaluetypes",children:"onRegisterAnimationValueTypes"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Description"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"Called on pre load to register animation value types"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Definition"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"onRegisterAnimationValueTypes()"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Code"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:'function GroundAdjustedNodes:onRegisterAnimationValueTypes()\n    self:registerAnimationValueType( "groundAdjustScale" , "startGroundAdjustScale" , "endGroundAdjustScale" , false , AnimationValueFloat ,\n    function (value, xmlFile, xmlKey)\n        value.node = xmlFile:getValue(xmlKey .. "#node" , nil , value.part.components, value.part.i3dMappings)\n\n        if value.node ~ = nil then\n            value:setWarningInformation( "node: " .. getName(value.node))\n            value:addCompareParameters( "node" )\n\n            return true\n        end\n\n        return false\n    end ,\n\n    function (value)\n        if value.groundAdjustedNode = = nil then\n            local spec = self.spec_groundAdjustedNodes\n            for _, groundAdjustedNode in pairs(spec.groundAdjustedNodes) do\n                for _, adjustNode in pairs(groundAdjustedNode.adjustNodes) do\n                    if adjustNode.node = = value.node then\n                        value.groundAdjustedNode = groundAdjustedNode\n                        break\n                    end\n                end\n\n                if value.groundAdjustedNode ~ = nil then\n                    break\n                end\n            end\n\n            if value.groundAdjustedNode = = nil then\n                Logging.xmlWarning(value.xmlFile, "Could not find groundAdjustedNode for node \'%s\'!" , getName(value.node))\n                    return 0\n                end\n            end\n\n            return value.groundAdjustedNode.activeScale\n        end ,\n\n        function (value, activeScale)\n            if value.groundAdjustedNode ~ = nil then\n                value.groundAdjustedNode.activeScale = activeScale\n            end\n        end )\n    end\n\n'})}),"\n",(0,t.jsx)(n.h3,{id:"onupdate",children:"onUpdate"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Description"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Definition"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"onUpdate()"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"any"}),(0,t.jsx)(n.th,{children:"dt"})]})}),(0,t.jsxs)(n.tbody,{children:[(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"any"}),(0,t.jsx)(n.td,{children:"isActiveForInput"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"any"}),(0,t.jsx)(n.td,{children:"isActiveForInputIgnoreSelection"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"any"}),(0,t.jsx)(n.td,{children:"isSelected"})]})]})]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Code"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:"function GroundAdjustedNodes:onUpdate(dt, isActiveForInput, isActiveForInputIgnoreSelection, isSelected)\n    local spec = self.spec_groundAdjustedNodes\n    if self.currentUpdateDistance < spec.maxUpdateDistance then\n        self:updateGroundAdjustedRaycasts(dt)\n\n        for _, groundAdjustedNode in pairs(spec.groundAdjustedNodes) do\n            self:updateGroundAdjustedNode(groundAdjustedNode, dt)\n        end\n    end\nend\n\n"})}),"\n",(0,t.jsx)(n.h3,{id:"prerequisitespresent",children:"prerequisitesPresent"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Description"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Definition"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"prerequisitesPresent()"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,t.jsx)(n.table,{children:(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"any"}),(0,t.jsx)(n.th,{children:"specializations"})]})})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Code"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:"function GroundAdjustedNodes.prerequisitesPresent(specializations)\n    return true\nend\n\n"})}),"\n",(0,t.jsx)(n.h3,{id:"registeradjustnodexmlpaths",children:"registerAdjustNodeXMLPaths"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Description"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Definition"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"registerAdjustNodeXMLPaths()"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"any"}),(0,t.jsx)(n.th,{children:"schema"})]})}),(0,t.jsx)(n.tbody,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"any"}),(0,t.jsx)(n.td,{children:"basePath"})]})})]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Code"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:'function GroundAdjustedNodes.registerAdjustNodeXMLPaths(schema, basePath)\n    schema:register(XMLValueType.NODE_INDEX, basePath .. "#node" , "Ground adjusted node" )\n    schema:register(XMLValueType.FLOAT, basePath .. "#minY" , "Min.Y translation" , "translation in i3d - 1" )\n    schema:register(XMLValueType.FLOAT, basePath .. "#maxY" , "Max.Y translation" , "minY + 1" )\n    schema:register(XMLValueType.FLOAT, basePath .. "#moveSpeed" , "Move speed" , 1 )\n    schema:register(XMLValueType.BOOL, basePath .. "#resetIfNotActive" , "Reset node to start translation if not active" , true )\n        schema:register(XMLValueType.FLOAT, basePath .. "#moveSpeedStateChange" , "Move speed while node is inactive or active an in range of #activationTime" , "#moveSpeed" )\n            schema:register(XMLValueType.FLOAT, basePath .. "#updateThreshold" , "Position of node will be updated if change is greater than this value" , 0.002 )\n                schema:register(XMLValueType.FLOAT, basePath .. "#inActiveOffsetY" , "Offset of the in active position in Y, will be applied on top of the current position in i3d" , 0 )\n                schema:register(XMLValueType.FLOAT, basePath .. "#inActiveY" , "Adjust node will go to this state while it\'s not active" , "Position in i3d file" )\n                    schema:register(XMLValueType.BOOL, basePath .. "#averageInActivePosY" , "While nodes are turned off the average Y position will be used as target for all nodes" , false )\n                    end\n\n'})}),"\n",(0,t.jsx)(n.h3,{id:"registereventlisteners",children:"registerEventListeners"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Description"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Definition"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"registerEventListeners()"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,t.jsx)(n.table,{children:(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"any"}),(0,t.jsx)(n.th,{children:"vehicleType"})]})})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Code"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:'function GroundAdjustedNodes.registerEventListeners(vehicleType)\n    SpecializationUtil.registerEventListener(vehicleType, "onLoad" , GroundAdjustedNodes )\n    SpecializationUtil.registerEventListener(vehicleType, "onLoadFinished" , GroundAdjustedNodes )\n    SpecializationUtil.registerEventListener(vehicleType, "onUpdate" , GroundAdjustedNodes )\n    SpecializationUtil.registerEventListener(vehicleType, "onRegisterAnimationValueTypes" , GroundAdjustedNodes )\nend\n\n'})}),"\n",(0,t.jsx)(n.h3,{id:"registerfunctions",children:"registerFunctions"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Description"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Definition"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"registerFunctions()"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,t.jsx)(n.table,{children:(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"any"}),(0,t.jsx)(n.th,{children:"vehicleType"})]})})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Code"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:'function GroundAdjustedNodes.registerFunctions(vehicleType)\n    SpecializationUtil.registerFunction(vehicleType, "loadGroundAdjustedNodeFromXML" , GroundAdjustedNodes.loadGroundAdjustedNodeFromXML)\n    SpecializationUtil.registerFunction(vehicleType, "loadGroundAdjustedAdjustNodeFromXML" , GroundAdjustedNodes.loadGroundAdjustedAdjustNodeFromXML)\n    SpecializationUtil.registerFunction(vehicleType, "initGroundAdjustedAdjustNode" , GroundAdjustedNodes.initGroundAdjustedAdjustNode)\n    SpecializationUtil.registerFunction(vehicleType, "loadGroundAdjustedRaycastNodeFromXML" , GroundAdjustedNodes.loadGroundAdjustedRaycastNodeFromXML)\n    SpecializationUtil.registerFunction(vehicleType, "getIsGroundAdjustedNodeActive" , GroundAdjustedNodes.getIsGroundAdjustedNodeActive)\n    SpecializationUtil.registerFunction(vehicleType, "updateGroundAdjustedRaycasts" , GroundAdjustedNodes.updateGroundAdjustedRaycasts)\n    SpecializationUtil.registerFunction(vehicleType, "updateGroundAdjustedNode" , GroundAdjustedNodes.updateGroundAdjustedNode)\nend\n\n'})}),"\n",(0,t.jsx)(n.h3,{id:"registernodexmlpaths",children:"registerNodeXMLPaths"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Description"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Definition"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"registerNodeXMLPaths()"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"any"}),(0,t.jsx)(n.th,{children:"schema"})]})}),(0,t.jsx)(n.tbody,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"any"}),(0,t.jsx)(n.td,{children:"basePath"})]})})]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Code"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:'function GroundAdjustedNodes.registerNodeXMLPaths(schema, basePath)\n    schema:addDelayedRegistrationPath(basePath, "GroundAdjustedNodes:node" )\n\n    schema:register(XMLValueType.FLOAT, basePath .. "#activationTime" , "In this time after the activation of the node the #moveSpeedStateChange will be used" , 0 )\n    schema:register(XMLValueType.FLOAT, basePath .. "#yOffset" , "Raycast Y translation offset(Raycast will start this distance above the node)" )\n\n    schema:register(XMLValueType.NODE_INDEX, basePath .. ".raycastNode(?)#node" , "Ground adjusted raycast node" )\n    schema:register(XMLValueType.FLOAT, basePath .. ".raycastNode(?)#distance" , "Ground adjusted raycast distance" , 4 )\n    schema:register(XMLValueType.INT, basePath .. ".raycastNode(?)#updateFrame" , "Defines the frame delay between two raycasts" , "Number of raycasts" )\n    schema:register(XMLValueType.FLOAT, basePath .. ".raycastNode(?)#yOffset" , "Raycast Y translation offset(Raycast will start this distance above the node)" , 0 )\n\n    GroundAdjustedNodes.registerAdjustNodeXMLPaths(schema, basePath)\n    GroundAdjustedNodes.registerAdjustNodeXMLPaths(schema, basePath .. ".adjustNode(?)" )\nend\n\n'})}),"\n",(0,t.jsx)(n.h3,{id:"updategroundadjustednode",children:"updateGroundAdjustedNode"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Description"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Definition"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"updateGroundAdjustedNode()"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"any"}),(0,t.jsx)(n.th,{children:"groundAdjustedNode"})]})}),(0,t.jsx)(n.tbody,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"any"}),(0,t.jsx)(n.td,{children:"dt"})]})})]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Code"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:"function GroundAdjustedNodes:updateGroundAdjustedNode(groundAdjustedNode, dt)\n    local spec = self.spec_groundAdjustedNodes\n\n    local wasActive = groundAdjustedNode.isActive\n    groundAdjustedNode.isActive = self:getIsGroundAdjustedNodeActive(groundAdjustedNode)\n    if groundAdjustedNode.isActive then\n        groundAdjustedNode.activationTimer = math.max(groundAdjustedNode.activationTimer - dt, 0 )\n    else\n            if groundAdjustedNode.averageInActivePosY and wasActive then\n                local groundAdjustedNodes = spec.groundAdjustedNodes\n                local inActiveY, numNodes = 0 , 0\n                for _, _groundAdjustedNode in pairs(groundAdjustedNodes) do\n                    for i = 1 , #_groundAdjustedNode.adjustNodes do\n                        local _adjustNode = _groundAdjustedNode.adjustNodes[i]\n                        if _adjustNode.averageInActivePosY then\n                            inActiveY = inActiveY + _adjustNode.curY\n                            numNodes = numNodes + 1\n                        end\n                    end\n                end\n\n                if numNodes > 0 then\n                    groundAdjustedNode.inActiveY = inActiveY / numNodes\n\n                    -- reapply to all since some could have already changed\n                    for _, _groundAdjustedNode in pairs(groundAdjustedNodes) do\n                        for i = 1 , #_groundAdjustedNode.adjustNodes do\n                            local _adjustNode = _groundAdjustedNode.adjustNodes[i]\n                            if _adjustNode.averageInActivePosY then\n                                _adjustNode.inActiveY = inActiveY / numNodes\n                            end\n                        end\n                    end\n                end\n            end\n\n            groundAdjustedNode.activationTimer = groundAdjustedNode.activationTime\n        end\n\n        for i = 1 , #groundAdjustedNode.adjustNodes do\n            local adjustNode = groundAdjustedNode.adjustNodes[i]\n\n            if groundAdjustedNode.isActive and groundAdjustedNode.activeScale > 0 then\n                if not wasActive then\n                    local _, y, _ = getTranslation(adjustNode.node)\n                    adjustNode.curY = y\n                end\n\n                local raycastNode = groundAdjustedNode.raycastNodes[ 1 ]\n                local height\n                if #groundAdjustedNode.raycastNodes = = 2 then\n                    height = groundAdjustedNode.raycastNodes[ 1 ].lastRaycastDistance * ( 1 - adjustNode.alpha)\n                    + groundAdjustedNode.raycastNodes[ 2 ].lastRaycastDistance * adjustNode.alpha\n                else\n                        height = groundAdjustedNode.raycastNodes[ 1 ].lastRaycastDistance\n                    end\n\n                    local _, targetY, _ = localToLocal(raycastNode.node, getParent(adjustNode.node), 0 , raycastNode.yOffset - height, 0 )\n\n                    if self.currentUpdateDistance < spec.maxUpdateDistanceWobble then\n                        if raycastNode.lastIsOnField then\n                            adjustNode.lastOffsetDistance = adjustNode.lastOffsetDistance + ( self.lastMovedDistance * self.movingDirection * 0.1 )\n                            local noise = getRandomOffset(adjustNode.lastOffsetDistance)\n                            targetY = targetY + noise * PERLIN_NOISE.maxOffset\n                        end\n                    end\n\n                    adjustNode.targetY = math.clamp(targetY, adjustNode.minY, adjustNode.maxY)\n                else\n                        if adjustNode.resetIfNotActive then\n                            adjustNode.targetY = adjustNode.inActiveY\n                        end\n                    end\n\n                    adjustNode.targetY = adjustNode.targetY * groundAdjustedNode.activeScale + adjustNode.inActiveY * ( 1 - groundAdjustedNode.activeScale)\n\n                    if adjustNode.targetY ~ = adjustNode.curY then\n                        local stateChangeActive = not groundAdjustedNode.isActive or groundAdjustedNode.activationTimer > 0\n                        local moveSpeed = stateChangeActive and adjustNode.moveSpeedStateChange or adjustNode.moveSpeed\n\n                        if adjustNode.targetY > adjustNode.curY then\n                            adjustNode.curY = math.min(adjustNode.curY + moveSpeed * dt, adjustNode.targetY)\n                        else\n                                adjustNode.curY = math.max(adjustNode.curY - moveSpeed * dt, adjustNode.targetY)\n                            end\n\n                            if math.abs(adjustNode.lastY - adjustNode.curY) > adjustNode.updateThreshold then\n                                setTranslation(adjustNode.node, adjustNode.x, adjustNode.curY, adjustNode.z)\n                                adjustNode.lastY = adjustNode.curY\n\n                                if self.setMovingToolDirty ~ = nil then\n                                    self:setMovingToolDirty(adjustNode.node)\n                                end\n                            end\n                        end\n                    end\n                end\n\n"})}),"\n",(0,t.jsx)(n.h3,{id:"updategroundadjustedraycasts",children:"updateGroundAdjustedRaycasts"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Description"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Definition"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"updateGroundAdjustedRaycasts()"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Arguments"})}),"\n\n\n\n\n\n\n\n",(0,t.jsx)(n.table,{children:(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"any"}),(0,t.jsx)(n.th,{children:"dt"})]})})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Code"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:'function GroundAdjustedNodes:updateGroundAdjustedRaycasts(dt)\n    local spec = self.spec_groundAdjustedNodes\n    for node, raycastNode in pairs(spec.raycastNodesByNode) do\n        if raycastNode.parent.isActive and raycastNode.parent.activeScale > 0 then\n            local x, y, z = localToWorld(raycastNode.node, 0 , raycastNode.yOffset, 0 )\n\n            raycastNode.lastIsOnField = getDensityAtWorldPos(g_currentMission.terrainDetailId, x, 0 , z) ~ = 0\n            if not raycastNode.lastIsOnField or spec.adjustToWater then\n                local dx, dy, dz = localDirectionToWorld(raycastNode.node, 0 , - 1 , 0 )\n\n                local mask = GroundAdjustedNodes.COLLISION_MASK\n                if spec.adjustToWater then\n                    mask = GroundAdjustedNodes.COLLISION_MASK_WATER\n                end\n\n                raycastAll(x, y, z, dx, dy, dz, raycastNode.maxDistance, "groundAdjustRaycastCallback" , raycastNode, mask)\n\n                --#debug drawDebugLine(x, y, z, 0, 1, 0, x+dx*raycastNode.maxDistance, y+dy*raycastNode.maxDistance, z+dz*raycastNode.maxDistance, 1, 0, 0, true)\n                --#debug local x, y, z = localToWorld(raycastNode.node, 0, raycastNode.yOffset - raycastNode.lastRaycastDistance, 0)\n                --#debug drawDebugPoint(x, y, z, 0, 1, 0, 1, true)\n            else\n                    local terrainHeight = getTerrainHeightAtWorldPos(g_terrainNode, x, 0 , z)\n                    if y > terrainHeight - 10 then\n                        raycastNode.lastRaycastDistance = math.min(y - terrainHeight, raycastNode.maxDistance)\n                        --#debug local x, y, z = localToWorld(raycastNode.node, 0, raycastNode.yOffset - raycastNode.lastRaycastDistance, 0)\n                        --#debug drawDebugPoint(x, y, z, 0, 0, 1, 1, true)\n                    end\n                end\n            end\n        end\n    end\n\n'})})]})}function u(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(c,{...e})}):c(e)}}}]);